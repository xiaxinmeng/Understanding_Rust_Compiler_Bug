{"sha": "63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZmNiY2YzY2U4ZjBjYTM5MWMxOGIyZDYxODMzYWU2YmViM2FjNzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-24T17:15:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-25T09:20:55Z"}, "message": "Merge remote-tracking branch 'rust-lang/master'\n\nConflicts:\n\tmk/tests.mk\n\tsrc/liballoc/arc.rs\n\tsrc/liballoc/boxed.rs\n\tsrc/liballoc/rc.rs\n\tsrc/libcollections/bit.rs\n\tsrc/libcollections/btree/map.rs\n\tsrc/libcollections/btree/set.rs\n\tsrc/libcollections/dlist.rs\n\tsrc/libcollections/ring_buf.rs\n\tsrc/libcollections/slice.rs\n\tsrc/libcollections/str.rs\n\tsrc/libcollections/string.rs\n\tsrc/libcollections/vec.rs\n\tsrc/libcollections/vec_map.rs\n\tsrc/libcore/any.rs\n\tsrc/libcore/array.rs\n\tsrc/libcore/borrow.rs\n\tsrc/libcore/error.rs\n\tsrc/libcore/fmt/mod.rs\n\tsrc/libcore/iter.rs\n\tsrc/libcore/marker.rs\n\tsrc/libcore/ops.rs\n\tsrc/libcore/result.rs\n\tsrc/libcore/slice.rs\n\tsrc/libcore/str/mod.rs\n\tsrc/libregex/lib.rs\n\tsrc/libregex/re.rs\n\tsrc/librustc/lint/builtin.rs\n\tsrc/libstd/collections/hash/map.rs\n\tsrc/libstd/collections/hash/set.rs\n\tsrc/libstd/sync/mpsc/mod.rs\n\tsrc/libstd/sync/mutex.rs\n\tsrc/libstd/sync/poison.rs\n\tsrc/libstd/sync/rwlock.rs\n\tsrc/libsyntax/feature_gate.rs\n\tsrc/libsyntax/test.rs", "tree": {"sha": "c732033c0822f25f2aebcdf193de1b257bac1855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c732033c0822f25f2aebcdf193de1b257bac1855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "html_url": "https://github.com/rust-lang/rust/commit/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b44ee371b8beea77aa1364460acbba14a8516559", "url": "https://api.github.com/repos/rust-lang/rust/commits/b44ee371b8beea77aa1364460acbba14a8516559", "html_url": "https://github.com/rust-lang/rust/commit/b44ee371b8beea77aa1364460acbba14a8516559"}, {"sha": "0430a43d635841db44978bb648e9cf7e7cfa1bba", "url": "https://api.github.com/repos/rust-lang/rust/commits/0430a43d635841db44978bb648e9cf7e7cfa1bba", "html_url": "https://github.com/rust-lang/rust/commit/0430a43d635841db44978bb648e9cf7e7cfa1bba"}], "stats": {"total": 19367, "additions": 7352, "deletions": 12015}, "files": [{"sha": "b2f8c33380ce7015caa5ea10f80555885f1b4aa3", "filename": "configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/configure", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -509,7 +509,6 @@ opt optimize-tests 1 \"build tests with optimizations\"\n opt libcpp 1 \"build with llvm with libc++ instead of libstdc++ when using clang\"\n opt llvm-assertions 1 \"build LLVM with assertions\"\n opt debug 1 \"build with extra debug fun\"\n-opt ratchet-bench 0 \"ratchet benchmarks\"\n opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\""}, {"sha": "a6f7f2ba1d66eb592e98cf844ce1c6a856b9c390", "filename": "mk/cfg/aarch64-linux-android.mk", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Fcfg%2Faarch64-linux-android.mk", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Fcfg%2Faarch64-linux-android.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-linux-android.mk?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,30 @@\n+# aarch64-linux-android configuration\n+# CROSS_PREFIX_aarch64-linux-android-\n+CC_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc\n+CXX_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-g++\n+CPP_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc -E\n+AR_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-ar\n+CFG_LIB_NAME_aarch64-linux-android=lib$(1).so\n+CFG_STATIC_LIB_NAME_aarch64-linux-android=lib$(1).a\n+CFG_LIB_GLOB_aarch64-linux-android=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_aarch64-linux-android=lib$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_aarch64-linux-android := -D__aarch64__ -DANDROID -D__ANDROID__ $(CFLAGS)\n+CFG_GCCISH_CFLAGS_aarch64-linux-android := -Wall -g -fPIC -D__aarch64__ -DANDROID -D__ANDROID__ $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_aarch64-linux-android := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_aarch64-linux-android := -shared -fPIC -ldl -g -lm -lsupc++\n+CFG_GCCISH_DEF_FLAG_aarch64-linux-android := -Wl,--export-dynamic,--dynamic-list=\n+CFG_GCCISH_PRE_LIB_FLAGS_aarch64-linux-android := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_aarch64-linux-android := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_aarch64-linux-android := .android.def\n+CFG_LLC_FLAGS_aarch64-linux-android :=\n+CFG_INSTALL_NAME_aarch64-linux-android =\n+CFG_EXE_SUFFIX_aarch64-linux-android :=\n+CFG_WINDOWSY_aarch64-linux-android :=\n+CFG_UNIXY_aarch64-linux-android := 1\n+CFG_PATH_MUNGE_aarch64-linux-android := true\n+CFG_LDPATH_aarch64-linux-android :=\n+CFG_RUN_aarch64-linux-android=\n+CFG_RUN_TARG_aarch64-linux-android=\n+RUSTC_FLAGS_aarch64-linux-android :=\n+RUSTC_CROSS_FLAGS_aarch64-linux-android :=\n+CFG_GNU_TRIPLE_aarch64-linux-android := aarch64-linux-android"}, {"sha": "be1965b7edadddd6358ab898816e33828121d57e", "filename": "mk/crates.mk", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std flate arena term \\\n                  serialize getopts collections test rand \\\n-                 log regex graphviz core rbml alloc \\\n+                 log graphviz core rbml alloc \\\n                  unicode rustc_bitflags\n RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy\n@@ -95,16 +95,15 @@ DEPS_term := std log\n DEPS_getopts := std\n DEPS_collections := core alloc unicode\n DEPS_num := std\n-DEPS_test := std getopts serialize rbml term regex native:rust_test_helpers\n+DEPS_test := std getopts serialize rbml term native:rust_test_helpers\n DEPS_rand := core\n-DEPS_log := std regex\n-DEPS_regex := std\n+DEPS_log := std\n DEPS_fmt_macros = std\n \n TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc\n TOOL_DEPS_rustc := rustc_driver\n-TOOL_DEPS_rustbook := std regex rustdoc\n+TOOL_DEPS_rustbook := std rustdoc\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n@@ -130,9 +129,8 @@ DOC_CRATES := $(filter-out rustc, \\\n               $(filter-out rustc_driver, \\\n               $(filter-out rustc_privacy, \\\n               $(filter-out log, \\\n-              $(filter-out regex, \\\n               $(filter-out getopts, \\\n-              $(filter-out syntax, $(CRATES))))))))))))\n+              $(filter-out syntax, $(CRATES)))))))))))\n COMPILER_DOC_CRATES := rustc rustc_trans rustc_borrowck rustc_resolve \\\n                        rustc_typeck rustc_driver syntax rustc_privacy\n "}, {"sha": "a8bbeb4151701055a1c961973565b3dbd24097a5", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -141,6 +141,8 @@ else ifeq ($(OSTYPE_$(1)), apple-ios)\n   JEMALLOC_ARGS_$(1) := --disable-tls\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n   JEMALLOC_ARGS_$(1) := --disable-tls\n+else ifeq ($(OSTYPE_$(1)), linux-android)\n+  JEMALLOC_ARGS_$(1) := --disable-tls\n endif\n \n ################################################################################"}, {"sha": "e28f56fffe41b3d547f7c82ed3f1b86ef2b18725", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -300,7 +300,8 @@ tidy:\n \t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n-\t\t$(Q)$(CFG_PYTHON) $(S)src/etc/featureck.py $(S)src/\n+\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/errorck.py $(S)src/\n+\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/featureck.py $(S)src/\n \n \n endif"}, {"sha": "1f4f444634dc254ad98fec426fdbdf8028a83a19", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -11,9 +11,8 @@ pub use self::Mode::*;\n \n use std::fmt;\n use std::str::FromStr;\n-use regex::Regex;\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum Mode {\n     CompileFail,\n     RunFail,\n@@ -43,9 +42,9 @@ impl FromStr for Mode {\n     }\n }\n \n-impl fmt::String for Mode {\n+impl fmt::Display for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(match *self {\n+        fmt::Display::fmt(match *self {\n             CompileFail => \"compile-fail\",\n             RunFail => \"run-fail\",\n             RunPass => \"run-pass\",\n@@ -58,12 +57,6 @@ impl fmt::String for Mode {\n     }\n }\n \n-impl fmt::Show for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct Config {\n     // The library paths required for running the compiler\n@@ -107,28 +100,11 @@ pub struct Config {\n     pub run_ignored: bool,\n \n     // Only run tests that match this filter\n-    pub filter: Option<Regex>,\n-\n-    // Precompiled regex for finding expected errors in cfail\n-    pub cfail_regex: Regex,\n+    pub filter: Option<String>,\n \n     // Write out a parseable log of tests that were run\n     pub logfile: Option<Path>,\n \n-    // Write out a json file containing any metrics of the run\n-    pub save_metrics: Option<Path>,\n-\n-    // Write and ratchet a metrics file\n-    pub ratchet_metrics: Option<Path>,\n-\n-    // Percent change in metrics to consider noise\n-    pub ratchet_noise_percent: Option<f64>,\n-\n-    // \"Shard\" of the testsuite to pub run: this has the form of\n-    // two numbers (a,b), and causes only those tests with\n-    // positional order equal to a mod b to run.\n-    pub test_shard: Option<(uint,uint)>,\n-\n     // A command line to prefix program execution with,\n     // for running under valgrind\n     pub runtool: Option<String>,"}, {"sha": "d2d1d3d8368588cb5a93e8c726ecd1781014b56e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 47, "deletions": 54, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -13,6 +13,15 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n+#![feature(test)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(path)]\n+#![feature(io)]\n+#![feature(core)]\n+#![feature(collections)]\n+#![feature(os)]\n+#![feature(unicode)]\n \n #![deny(warnings)]\n \n@@ -21,7 +30,6 @@ extern crate getopts;\n \n #[macro_use]\n extern crate log;\n-extern crate regex;\n \n use std::os;\n use std::io;\n@@ -32,7 +40,6 @@ use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};\n use util::logv;\n-use regex::Regex;\n \n pub mod procsrv;\n pub mod util;\n@@ -76,10 +83,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optopt(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\"),\n           optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\"),\n           optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\"),\n-          optopt(\"\", \"save-metrics\", \"file to save metrics to\", \"FILE\"),\n-          optopt(\"\", \"ratchet-metrics\", \"file to ratchet metrics against\", \"FILE\"),\n-          optopt(\"\", \"ratchet-noise-percent\",\n-                 \"percent change in metrics to consider noise\", \"N\"),\n           optflag(\"\", \"jit\", \"run tests under the JIT\"),\n           optopt(\"\", \"target\", \"the target to build for\", \"TARGET\"),\n           optopt(\"\", \"host\", \"the host to build for\", \"HOST\"),\n@@ -89,7 +92,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\"),\n           optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\"),\n           optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\"),\n-          optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\", \"A.B\"),\n           optflag(\"h\", \"help\", \"show this message\"));\n \n     assert!(!args.is_empty());\n@@ -120,14 +122,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     }\n \n     let filter = if !matches.free.is_empty() {\n-        let s = matches.free[0].as_slice();\n-        match regex::Regex::new(s) {\n-            Ok(re) => Some(re),\n-            Err(e) => {\n-                println!(\"failed to parse filter /{}/: {:?}\", s, e);\n-                panic!()\n-            }\n-        }\n+        Some(matches.free[0].clone())\n     } else {\n         None\n     };\n@@ -149,14 +144,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n                                        .as_slice()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n-        cfail_regex: Regex::new(errors::EXPECTED_PATTERN).unwrap(),\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n-        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n-        ratchet_metrics:\n-            matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n-        ratchet_noise_percent:\n-            matches.opt_str(\"ratchet-noise-percent\")\n-                   .and_then(|s| s.as_slice().parse::<f64>()),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n@@ -175,7 +163,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n                 opt_str2(matches.opt_str(\"adb-test-dir\")).as_slice() &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n-        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")),\n         verbose: matches.opt_present(\"verbose\"),\n     }\n }\n@@ -209,10 +196,6 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n     logv(c, format!(\"adb_device_status: {}\",\n                     config.adb_device_status));\n-    match config.test_shard {\n-        None => logv(c, \"test_shard: (all)\".to_string()),\n-        Some((a,b)) => logv(c, format!(\"test_shard: {}.{}\", a, b))\n-    }\n     logv(c, format!(\"verbose: {}\", config.verbose));\n     logv(c, format!(\"\\n\"));\n }\n@@ -263,6 +246,9 @@ pub fn run_tests(config: &Config) {\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n     io::test::raise_fd_limit();\n+    // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n+    // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n+    os::setenv(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n     let res = test::run_tests_console(&opts, tests.into_iter().collect());\n     match res {\n         Ok(true) => {}\n@@ -283,15 +269,8 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         run_benchmarks: true,\n-        ratchet_metrics: config.ratchet_metrics.clone(),\n-        ratchet_noise_percent: config.ratchet_noise_percent.clone(),\n-        save_metrics: config.save_metrics.clone(),\n-        test_shard: config.test_shard.clone(),\n         nocapture: false,\n         color: test::AutoColor,\n-        show_boxplot: false,\n-        boxplot_width: 50,\n-        show_all_stats: false,\n     }\n }\n \n@@ -393,18 +372,24 @@ fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n           if full_version_line.as_slice().trim().len() > 0 => {\n             let full_version_line = full_version_line.as_slice().trim();\n \n-            let re = Regex::new(r\"(^|[^0-9])([0-9]\\.[0-9])([^0-9]|$)\").unwrap();\n-\n-            match re.captures(full_version_line) {\n-                Some(captures) => {\n-                    Some(captures.at(2).unwrap_or(\"\").to_string())\n+            // used to be a regex \"(^|[^0-9])([0-9]\\.[0-9])([^0-9]|$)\"\n+            for (pos, c) in full_version_line.char_indices() {\n+                if !c.is_digit(10) { continue }\n+                if pos + 2 >= full_version_line.len() { continue }\n+                if full_version_line.char_at(pos + 1) != '.' { continue }\n+                if !full_version_line.char_at(pos + 2).is_digit(10) { continue }\n+                if pos > 0 && full_version_line.char_at_reverse(pos).is_digit(10) {\n+                    continue\n                 }\n-                None => {\n-                    println!(\"Could not extract GDB version from line '{}'\",\n-                             full_version_line);\n-                    None\n+                if pos + 3 < full_version_line.len() &&\n+                   full_version_line.char_at(pos + 3).is_digit(10) {\n+                    continue\n                 }\n+                return Some(full_version_line[pos..pos+3].to_string());\n             }\n+            println!(\"Could not extract GDB version from line '{}'\",\n+                     full_version_line);\n+            None\n         },\n         _ => None\n     }\n@@ -427,18 +412,26 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n           if full_version_line.as_slice().trim().len() > 0 => {\n             let full_version_line = full_version_line.as_slice().trim();\n \n-            let re = Regex::new(r\"[Ll][Ll][Dd][Bb]-([0-9]+)\").unwrap();\n-\n-            match re.captures(full_version_line) {\n-                Some(captures) => {\n-                    Some(captures.at(1).unwrap_or(\"\").to_string())\n-                }\n-                None => {\n-                    println!(\"Could not extract LLDB version from line '{}'\",\n-                             full_version_line);\n-                    None\n-                }\n+            for (pos, l) in full_version_line.char_indices() {\n+                if l != 'l' && l != 'L' { continue }\n+                if pos + 5 >= full_version_line.len() { continue }\n+                let l = full_version_line.char_at(pos + 1);\n+                if l != 'l' && l != 'L' { continue }\n+                let d = full_version_line.char_at(pos + 2);\n+                if d != 'd' && d != 'D' { continue }\n+                let b = full_version_line.char_at(pos + 3);\n+                if b != 'b' && b != 'B' { continue }\n+                let dash = full_version_line.char_at(pos + 4);\n+                if dash != '-' { continue }\n+\n+                let vers = full_version_line[pos + 5..].chars().take_while(|c| {\n+                    c.is_digit(10)\n+                }).collect::<String>();\n+                if vers.len() > 0 { return Some(vers) }\n             }\n+            println!(\"Could not extract LLDB version from line '{}'\",\n+                     full_version_line);\n+            None\n         },\n         _ => None\n     }"}, {"sha": "fc815d66a4d4205eaa8e90f591ab8b40ce29f468", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -9,32 +9,26 @@\n // except according to those terms.\n use self::WhichLine::*;\n \n-use std::ascii::AsciiExt;\n use std::io::{BufferedReader, File};\n-use regex::Regex;\n \n pub struct ExpectedError {\n     pub line: uint,\n     pub kind: String,\n     pub msg: String,\n }\n \n+#[derive(PartialEq, Show)]\n+enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n+\n /// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n /// The former is a \"follow\" that inherits its target from the preceding line;\n /// the latter is an \"adjusts\" that goes that many lines up.\n ///\n /// Goal is to enable tests both like: //~^^^ ERROR go up three\n /// and also //~^ ERROR message one for the preceding line, and\n ///          //~| ERROR message two for that same line.\n-\n-pub static EXPECTED_PATTERN : &'static str =\n-    r\"//~(?P<follow>\\|)?(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n-\n-#[derive(PartialEq, Show)]\n-enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n-\n // Load any test directives embedded in the file\n-pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n+pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n \n     // `last_nonfollow_error` tracks the most recently seen\n@@ -50,7 +44,7 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n     rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n         parse_expected(last_nonfollow_error,\n                        line_no + 1,\n-                       ln.unwrap().as_slice(), re)\n+                       ln.unwrap().as_slice())\n             .map(|(which, error)| {\n                 match which {\n                     FollowPrevious(_) => {}\n@@ -63,30 +57,39 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n \n fn parse_expected(last_nonfollow_error: Option<uint>,\n                   line_num: uint,\n-                  line: &str,\n-                  re: &Regex) -> Option<(WhichLine, ExpectedError)> {\n-    re.captures(line).and_then(|caps| {\n-        let adjusts = caps.name(\"adjusts\").unwrap_or(\"\").len();\n-        let kind = caps.name(\"kind\").unwrap_or(\"\").to_ascii_lowercase();\n-        let msg = caps.name(\"msg\").unwrap_or(\"\").trim().to_string();\n-        let follow = caps.name(\"follow\").unwrap_or(\"\").len() > 0;\n+                  line: &str) -> Option<(WhichLine, ExpectedError)> {\n+    let start = match line.find_str(\"//~\") { Some(i) => i, None => return None };\n+    let (follow, adjusts) = if line.char_at(start + 3) == '|' {\n+        (true, 0)\n+    } else {\n+        (false, line[start + 3..].chars().take_while(|c| *c == '^').count())\n+    };\n+    let kind_start = start + 3 + adjusts + (follow as usize);\n+    let letters = line[kind_start..].chars();\n+    let kind = letters.skip_while(|c| c.is_whitespace())\n+                      .take_while(|c| !c.is_whitespace())\n+                      .map(|c| c.to_lowercase())\n+                      .collect::<String>();\n+    let letters = line[kind_start..].chars();\n+    let msg = letters.skip_while(|c| c.is_whitespace())\n+                     .skip_while(|c| !c.is_whitespace())\n+                     .collect::<String>().trim().to_string();\n \n-        let (which, line) = if follow {\n-            assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n-            let line = last_nonfollow_error.unwrap_or_else(|| {\n-                panic!(\"encountered //~| without preceding //~^ line.\")\n-            });\n-            (FollowPrevious(line), line)\n-        } else {\n-            let which =\n-                if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n-            let line = line_num - adjusts;\n-            (which, line)\n-        };\n+    let (which, line) = if follow {\n+        assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n+        let line = last_nonfollow_error.unwrap_or_else(|| {\n+            panic!(\"encountered //~| without preceding //~^ line.\")\n+        });\n+        (FollowPrevious(line), line)\n+    } else {\n+        let which =\n+            if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n+        let line = line_num - adjusts;\n+        (which, line)\n+    };\n \n-        debug!(\"line={} which={:?} kind={:?} msg={:?}\", line_num, which, kind, msg);\n-        Some((which, ExpectedError { line: line,\n-                                     kind: kind,\n-                                     msg: msg, }))\n-    })\n+    debug!(\"line={} which={:?} kind={:?} msg={:?}\", line_num, which, kind, msg);\n+    Some((which, ExpectedError { line: line,\n+                                 kind: kind,\n+                                 msg: msg, }))\n }"}, {"sha": "d7af767688e81e7ecc92dc001ed6bf14d4f6e6c9", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -332,8 +332,7 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n     let keycolon = format!(\"{}:\", directive);\n     match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {\n-            let value = line.slice(colon + keycolon.len(),\n-                                   line.len()).to_string();\n+            let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n             debug!(\"{}: {}\", directive, value);\n             Some(value)\n         }"}, {"sha": "e5a973e7501ae6ad155757ac5ea9dd6740258f94", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -99,7 +99,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n-    let expected_errors = errors::load_errors(&config.cfail_regex, testfile);\n+    let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(\"both error pattern and expected errors specified\");\n@@ -294,6 +294,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_string(),\n+                            \"-Zunstable-options\".to_string(),\n                             \"--pretty\".to_string(),\n                             pretty_type,\n                             format!(\"--target={}\", config.target),\n@@ -340,7 +341,7 @@ actual:\\n\\\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_string(),\n-                            \"--no-trans\".to_string(),\n+                            \"-Zno-trans\".to_string(),\n                             \"--crate-type=lib\".to_string(),\n                             format!(\"--target={}\", target),\n                             \"-L\".to_string(),\n@@ -547,7 +548,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             // Add line breakpoints\n             for line in breakpoint_lines.iter() {\n-                script_str.push_str(&format!(\"break '{:?}':{}\\n\",\n+                script_str.push_str(&format!(\"break '{}':{}\\n\",\n                                              testfile.filename_display(),\n                                              *line)[]);\n             }\n@@ -750,7 +751,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n             status: status,\n             stdout: out,\n             stderr: err,\n-            cmdline: format!(\"{}\", cmd)\n+            cmdline: format!(\"{:?}\", cmd)\n         };\n     }\n }\n@@ -862,7 +863,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                         break;\n                     }\n                     Some(i) => {\n-                        rest = rest.slice_from(i + frag.len());\n+                        rest = &rest[(i + frag.len())..];\n                     }\n                 }\n                 first = false;\n@@ -953,7 +954,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{:?}:{}:\", testfile.display(), ee.line)\n+        format!(\"{}:{}:\", testfile.display(), ee.line)\n     }).collect::<Vec<String> >();\n \n     #[cfg(windows)]\n@@ -1045,7 +1046,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let opt = haystack.slice_from(*idx).find(needle);\n+    let opt = haystack[(*idx)..].find(needle);\n     if opt.is_none() {\n         return false;\n     }"}, {"sha": "b92d38215c29b3ecdd66ba4b99566ad51612f8ed", "filename": "src/doc/intro.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -480,14 +480,12 @@ use std::sync::{Arc,Mutex};\n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1is, 2, 3]));\n \n-    for i in 0..3 {\n+    for i in 0us..3 {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n             let mut array = number.lock().unwrap();\n-\n-            (*array)[i] += 1;\n-\n-            println!(\"numbers[{}] is {}\", i, (*array)[i]);\n+            array[i] += 1;\n+            println!(\"numbers[{}] is {}\", i, array[i]);\n         });\n     }\n }"}, {"sha": "f2d94d10ec69fd2cf5db21f97df70e128a974370", "filename": "src/doc/reference.md", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -739,6 +739,15 @@ Rust syntax is restricted in two ways:\n * `concat!` : concatenates a comma-separated list of literals\n * `concat_idents!` : create a new identifier by concatenating the arguments\n \n+The following attributes are used for quasiquoting in procedural macros:\n+\n+* `quote_expr!`\n+* `quote_item!`\n+* `quote_pat!`\n+* `quote_stmt!`\n+* `quote_tokens!`\n+* `quote_ty!`\n+\n # Crates and source files\n \n Rust is a *compiled* language. Its semantics obey a *phase distinction*\n@@ -803,8 +812,9 @@ Crates contain [items](#items), each of which may have some number of\n ## Items\n \n ```{.ebnf .gram}\n-item : mod_item | fn_item | type_item | struct_item | enum_item\n-     | static_item | trait_item | impl_item | extern_block ;\n+item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n+     | struct_item | enum_item | static_item | trait_item | impl_item\n+     | extern_block ;\n ```\n \n An _item_ is a component of a crate; some module items can be defined in crate\n@@ -818,6 +828,8 @@ execution, and may reside in read-only memory.\n \n There are several kinds of item:\n \n+* [`extern crate` declarations](#extern-crate-declarations)\n+* [`use` declarations](#use-declarations)\n * [modules](#modules)\n * [functions](#functions)\n * [type definitions](#type-definitions)\n@@ -854,13 +866,10 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ```{.ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : [ view_item | item ] * ;\n+mod : item * ;\n ```\n \n-A module is a container for zero or more [view items](#view-items) and zero or\n-more [items](#items). The view items manage the visibility of the items defined\n-within the module, as well as the visibility of names from outside the module\n-when referenced from inside the module.\n+A module is a container for zero or more [items](#items).\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n keyword `mod`. A module item introduces a new, named module into the tree of\n@@ -918,19 +927,6 @@ mod thread {\n }\n ```\n \n-#### View items\n-\n-```{.ebnf .gram}\n-view_item : extern_crate_decl | use_decl ;\n-```\n-\n-A view item manages the namespace of a module. View items do not define new\n-items, but rather, simply change other items' visibility. There are two\n-kinds of view items:\n-\n-* [`extern crate` declarations](#extern-crate-declarations)\n-* [`use` declarations](#use-declarations)\n-\n ##### Extern crate declarations\n \n ```{.ebnf .gram}\n@@ -2041,6 +2037,9 @@ type int8_t = i8;\n   item](#language-items) for more details.\n - `test` - indicates that this function is a test function, to only be compiled\n   in case of `--test`.\n+- `should_fail` - indicates that this test function should panic, inverting the success condition.\n+- `cold` - The function is unlikely to be executed, so optimize it (and calls\n+  to it) differently.\n \n ### Static-only attributes\n \n@@ -2377,10 +2376,6 @@ These types help drive the compiler's analysis\n   : ___Needs filling in___\n * `no_copy_bound`\n   : This type does not implement \"copy\", even if eligible.\n-* `no_send_bound`\n-  : This type does not implement \"send\", even if eligible.\n-* `no_sync_bound`\n-  : This type does not implement \"sync\", even if eligible.\n * `eh_personality`\n   : ___Needs filling in___\n * `exchange_free`\n@@ -2820,13 +2815,12 @@ Point3d {y: 0, z: 10, .. base};\n ### Block expressions\n \n ```{.ebnf .gram}\n-block_expr : '{' [ view_item ] *\n-                 [ stmt ';' | item ] *\n+block_expr : '{' [ stmt ';' | item ] *\n                  [ expr ] '}' ;\n ```\n \n A _block expression_ is similar to a module in terms of the declarations that\n-are possible. Each block conceptually introduces a new namespace scope. View\n+are possible. Each block conceptually introduces a new namespace scope. Use\n items can bring new names into scopes and declared items are in scope for only\n the block itself.\n \n@@ -3082,18 +3076,17 @@ The precedence of Rust binary operators is ordered as follows, going from\n strong to weak:\n \n ```{.text .precedence}\n-* / %\n as\n+* / %\n + -\n << >>\n &\n ^\n |\n-< > <= >=\n-== !=\n+== != < > <= >=\n &&\n ||\n-=\n+= ..\n ```\n \n Operators at the same precedence level are evaluated left-to-right. [Unary"}, {"sha": "d4a25efec17f6895baeed32178ca69baad319159", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 1, "deletions": 294, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1,296 +1,3 @@\n % Rust Documentation\n \n-`rustdoc` is the built-in tool for generating documentation. It integrates\n-with the compiler to provide accurate hyperlinking between usage of types and\n-their documentation. Furthermore, by not using a separate parser, it will\n-never reject your valid Rust code.\n-\n-# Creating Documentation\n-\n-Documenting Rust APIs is quite simple. To document a given item, we have \"doc\n-comments\":\n-\n-~~~\n-# #![allow(unused_attribute)]\n-// the \"link\" crate attribute is currently required for rustdoc, but normally\n-// isn't needed.\n-#![crate_id = \"universe\"]\n-#![crate_type=\"lib\"]\n-\n-//! Tools for dealing with universes (this is a doc comment, and is shown on\n-//! the crate index page. The ! makes it apply to the parent of the comment,\n-//! rather than what follows).\n-\n-# mod workaround_the_outer_function_rustdoc_inserts {\n-/// Widgets are very common (this is a doc comment, and will show up on\n-/// Widget's documentation).\n-pub struct Widget {\n-\t/// All widgets have a purpose (this is a doc comment, and will show up\n-\t/// the field's documentation).\n-\tpurpose: String,\n-\t/// Humans are not allowed to understand some widgets\n-\tunderstandable: bool\n-}\n-\n-pub fn recalibrate() {\n-\t//! Recalibrate a pesky universe (this is also a doc comment, like above,\n-\t//! the documentation will be applied to the *parent* item, so\n-\t//! `recalibrate`).\n-\t/* ... */\n-}\n-# }\n-~~~\n-\n-Documentation can also be controlled via the `doc` attribute on items. This is\n-implicitly done by the compiler when using the above form of doc comments\n-(converting the slash-based comments to `#[doc]` attributes).\n-\n-~~~\n-#[doc = \"\n-Calculates the factorial of a number.\n-\n-Given the input integer `n`, this function will calculate `n!` and return it.\n-\"]\n-pub fn factorial(n: int) -> int { if n < 2 {1} else {n * factorial(n - 1)} }\n-# fn main() {}\n-~~~\n-\n-The `doc` attribute can also be used to control how rustdoc emits documentation\n-in some cases.\n-\n-```\n-// Rustdoc will inline documentation of a `pub use` into this crate when the\n-// `pub use` reaches across crates, but this behavior can also be disabled.\n-#[doc(no_inline)]\n-pub use std::option::Option;\n-# fn main() {}\n-```\n-\n-Doc comments are markdown, and are currently parsed with the\n-[hoedown][hoedown] library. rustdoc does not yet do any fanciness such as\n-referencing other items inline, like javadoc's `@see`. One exception to this\n-is that the first paragraph will be used as the \"summary\" of an item in the\n-generated documentation:\n-\n-~~~\n-/// A whizbang. Does stuff. (this line is the summary)\n-///\n-/// Whizbangs are ...\n-struct Whizbang;\n-~~~\n-\n-To generate the docs, run `rustdoc universe.rs`. By default, it generates a\n-directory called `doc`, with the documentation for `universe` being in\n-`doc/universe/index.html`. If you are using other crates with `extern crate`,\n-rustdoc will even link to them when you use their types, as long as their\n-documentation has already been generated by a previous run of rustdoc, or the\n-crate advertises that its documentation is hosted at a given URL.\n-\n-The generated output can be controlled with the `doc` crate attribute, which\n-is how the above advertisement works. An example from the `libstd`\n-documentation:\n-\n-~~~\n-#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-      html_root_url = \"http://doc.rust-lang.org/\")];\n-~~~\n-\n-The `html_root_url` is the prefix that rustdoc will apply to any references to\n-that crate's types etc.\n-\n-rustdoc can also generate JSON, for consumption by other tools, with\n-`rustdoc --output-format json`, and also consume already-generated JSON with\n-`rustdoc --input-format json`.\n-\n-rustdoc also supports personalizing the output from crates' documentation,\n-similar to markdown options.\n-\n-- `--html-in-header FILE`: includes the contents of `FILE` at the\n-  end of the `<head>...</head>` section.\n-- `--html-before-content FILE`: includes the contents of `FILE`\n-  directly after `<body>`, before the rendered content (including the\n-  search bar).\n-- `--html-after-content FILE`: includes the contents of `FILE`\n-  after all the rendered content.\n-\n-# Using the Documentation\n-\n-The web pages generated by rustdoc present the same logical hierarchy that one\n-writes a library with. Every kind of item (function, struct, etc) has its own\n-color, and one can always click on a colored type to jump to its\n-documentation. There is a search bar at the top, which is powered by some\n-JavaScript and a statically-generated search index. No special web server is\n-required for the search.\n-\n-[hoedown]: https://github.com/hoedown/hoedown\n-\n-# Testing the Documentation\n-\n-`rustdoc` has support for testing code examples which appear in the\n-documentation. This is helpful for keeping code examples up to date with the\n-source code.\n-\n-To test documentation, the `--test` argument is passed to rustdoc:\n-\n-~~~ {.sh}\n-rustdoc --test crate.rs\n-~~~\n-\n-## Defining tests\n-\n-Rust documentation currently uses the markdown format, and rustdoc treats all\n-code blocks as testable-by-default unless they carry a language tag of another\n-language. In order to not run a test over a block of code, the `ignore` string\n-can be added to the three-backtick form of markdown code block.\n-\n-~~~md\n-```\n-// This is a testable code block\n-```\n-\n-```rust{.example}\n-// This is rust and also testable\n-```\n-\n-```ignore\n-// This is not a testable code block\n-```\n-\n-    // This is a testable code block (4-space indent)\n-\n-```sh\n-# this is shell code and not tested\n-```\n-~~~\n-\n-You can specify that the test's execution should fail with the `should_fail`\n-directive.\n-\n-~~~md\n-```should_fail\n-// This code block is expected to generate a panic when run\n-```\n-~~~\n-\n-You can specify that the code block should be compiled but not run with the\n-`no_run` directive.\n-\n-~~~md\n-```no_run\n-// This code will be compiled but not executed\n-```\n-~~~\n-\n-Lastly, you can specify that a code block be compiled as if `--test`\n-were passed to the compiler using the `test_harness` directive.\n-\n-~~~md\n-```test_harness\n-#[test]\n-fn foo() {\n-    panic!(\"oops! (will run & register as a failed test)\")\n-}\n-```\n-~~~\n-\n-Rustdoc also supplies some extra sugar for helping with some tedious\n-documentation examples. If a line is prefixed with `# `, then the line\n-will not show up in the HTML documentation, but it will be used when\n-testing the code block (NB. the space after the `#` is required, so\n-that one can still write things like `#[derive(Eq)]`).\n-\n-~~~md\n-```\n-# /!\\ The three following lines are comments, which are usually stripped off by\n-# the doc-generating tool.  In order to display them anyway in this particular\n-# case, the character following the leading '#' is not a usual space like in\n-# these first five lines but a non breakable one.\n-#\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n-#\u00a0// what's actually being documented.\n-#\u00a0fn fib(n: int) { n + 2 }\n-\n-spawn(move || { fib(200); })\n-```\n-~~~\n-\n-The documentation online would look like `spawn(move || { fib(200); })`, but when\n-testing this code, the `fib` function will be included (so it can compile).\n-\n-Rustdoc will automatically add a `main()` wrapper around your code, and in the right\n-place. For example:\n-\n-```\n-/// ```\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-/// ```\n-# fn foo() {}\n-```\n-\n-This will end up testing:\n-\n-```\n-fn main() {\n-    use std::rc::Rc;\n-    let five = Rc::new(5);\n-}\n-```\n-\n-Here's the full algorithm:\n-\n-1. Given a code block, if it does not contain `fn main`, it is wrapped in `fn main() { your_code }`\n-2. Given that result, if it contains no `extern crate` directives but it also\n-   contains the name of the crate being tested, then `extern crate <name>` is\n-   injected at the top.\n-3. Some common `allow` attributes are added for documentation examples at the top.\n-\n-## Running tests (advanced)\n-\n-Running tests often requires some special configuration to filter tests, find\n-libraries, or try running ignored examples. The testing framework that rustdoc\n-uses is built on crate `test`, which is also used when you compile crates with\n-rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n-with the `--test-args` flag.\n-\n-~~~console\n-# Only run tests containing 'foo' in their name\n-$ rustdoc --test lib.rs --test-args 'foo'\n-\n-# See what's possible when running tests\n-$ rustdoc --test lib.rs --test-args '--help'\n-~~~\n-\n-When testing a library, code examples will often show how functions are used,\n-and this code often requires `use`-ing paths from the crate. To accommodate this,\n-rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name of\n-the crate being tested to the top of each code example. This means that rustdoc\n-must be able to find a compiled version of the library crate being tested. Extra\n-search paths may be added via the `-L` flag to `rustdoc`.\n-\n-# Standalone Markdown files\n-\n-As well as Rust crates, rustdoc supports rendering pure Markdown files\n-into HTML and testing the code snippets from them. A Markdown file is\n-detected by a `.md` or `.markdown` extension.\n-\n-There are 4 options to modify the output that Rustdoc creates.\n-\n-- `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n-- `--html-in-header FILE`: includes the contents of `FILE` at the\n-  end of the `<head>...</head>` section.\n-- `--html-before-content FILE`: includes the contents of `FILE`\n-  directly after `<body>`, before the rendered content (including the\n-  title).\n-- `--html-after-content FILE`: includes the contents of `FILE`\n-  directly before `</body>`, after all the rendered content.\n-\n-All of these can be specified multiple times, and they are output in\n-the order in which they are specified. The first line of the file being rendered must\n-be the title, prefixed with `%` (e.g. this page has `% Rust\n-Documentation` on the first line).\n-\n-Like with a Rust crate, the `--test` argument will run the code\n-examples to check they compile, and obeys any `--test-args` flags. The\n-tests are named after the last `#` heading.\n+This has been moved [into the book](book/documentation.html)."}, {"sha": "6131e1b8a70703066498f0c28a25122ae0aabcfc", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -16,6 +16,7 @@\n     * [Standard Input](standard-input.md)\n     * [Guessing Game](guessing-game.md)\n * [II: Intermediate Rust](intermediate.md)\n+    * [More Strings](more-strings.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [Testing](testing.md)\n     * [Pointers](pointers.md)\n@@ -28,6 +29,7 @@\n     * [Traits](traits.md)\n     * [Threads](threads.md)\n     * [Error Handling](error-handling.md)\n+    * [Documentation](documentation.md)\n * [III: Advanced Topics](advanced.md)\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)"}, {"sha": "bfb1494efc785526c312a7c9635c1ad08f3cbcac", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -117,14 +117,7 @@ fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n arguments. `x` is an `i32`, we've done that a ton of times. `f` is a function,\n though, and that function takes an `i32` and returns an `i32`. This is\n what the requirement `Fn(i32) -> i32` for the type parameter `F` says.\n-You might ask yourself: why do we need to introduce a type parameter here?\n-That is because in Rust each closure has its own unique type.\n-So, not only do closures with different signatures have different types,\n-but different closures with the *same* signature have *different* types!\n-You can think of it this way: the behaviour of a closure is part of its type.\n-And since we want to support many different closures that all take\n-an `i32` and return an `i32` we introduced a type parameter that is able\n-to represent all these closures. \n+Now `F` represents *any* function that takes an `i32` and returns an `i32`.\n \n This is the most complicated function signature we've seen yet! Give it a read\n a few times until you can see how it works. It takes a teeny bit of practice, and\n@@ -181,6 +174,40 @@ fn main() {\n \n Doing this is not particularly common, but it's useful every once in a while.\n \n+Before we move on, let us look at a function that accepts two closures.\n+\n+```{rust}\n+fn compose<F, G>(x: i32, f: F, g: G) -> i32\n+    where F: Fn(i32) -> i32, G: Fn(i32) -> i32 {\n+    g(f(x))\n+}\n+\n+fn main() {\n+    compose(5,\n+            |&: n: i32| { n + 42 },\n+            |&: n: i32| { n * 2 }); // evaluates to 94\n+}\n+```\n+\n+You might ask yourself: why do we need to introduce two type\n+parameters `F` and `G` here?  Evidently, both `f` and `g` have the\n+same signature: `Fn(i32) -> i32`.\n+\n+That is because in Rust each closure has its own unique type.\n+So, not only do closures with different signatures have different types,\n+but different closures with the *same* signature have *different*\n+types, as well!\n+\n+You can think of it this way: the behavior of a closure is part of its\n+type.  Therefore, using a single type parameter for both closures\n+will accept the first of them, rejecting the second. The distinct\n+type of the second closure does not allow it to be represented by the\n+same type parameter as that of the first.  We acknowledge this, and\n+use two different type parameters `F` and `G`.\n+\n+This also introduces the `where` clause, which lets us describe type\n+parameters in a more flexible manner.\n+\n That's all you need to get the hang of closures! Closures are a little bit\n strange at first, but once you're used to them, you'll miss them\n in other languages. Passing functions to other functions is"}, {"sha": "efeb201efe8474977dc617783a395ec41811625c", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -257,7 +257,7 @@ fn goodbye() -> String {\n \n (This is \"Say\u014dnara\", if you're curious.)\n \n-Now that we have our some functionality in our crate, let's try to use it from\n+Now that we have some functionality in our crate, let's try to use it from\n another crate.\n \n # Importing External Crates\n@@ -287,8 +287,7 @@ mentioned earlier, you can use double colons to refer to sub-modules and the\n functions inside of them.\n \n Also, Cargo assumes that `src/main.rs` is the crate root of a binary crate,\n-rather than a library crate. Once we compile `src/main.rs`, we'll get an\n-executable that we can run. Our package now has two crates: `src/lib.rs` and\n+rather than a library crate. Our package now has two crates: `src/lib.rs` and\n `src/main.rs`. This pattern is quite common for executable crates: most\n functionality is in a library crate, and the executable crate uses that\n library. This way, other programs can also use the library crate, and it's also"}, {"sha": "0b686eb76dbfb2d5dcf1eba88d965d1c2b069cc7", "filename": "src/doc/trpl/documentation.md", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,296 @@\n+% Rust Documentation\n+\n+`rustdoc` is the built-in tool for generating documentation. It integrates\n+with the compiler to provide accurate hyperlinking between usage of types and\n+their documentation. Furthermore, by not using a separate parser, it will\n+never reject your valid Rust code.\n+\n+# Creating Documentation\n+\n+Documenting Rust APIs is quite simple. To document a given item, we have \"doc\n+comments\":\n+\n+~~~\n+# #![allow(unused_attribute)]\n+// the \"link\" crate attribute is currently required for rustdoc, but normally\n+// isn't needed.\n+#![crate_id = \"universe\"]\n+#![crate_type=\"lib\"]\n+\n+//! Tools for dealing with universes (this is a doc comment, and is shown on\n+//! the crate index page. The ! makes it apply to the parent of the comment,\n+//! rather than what follows).\n+\n+# mod workaround_the_outer_function_rustdoc_inserts {\n+/// Widgets are very common (this is a doc comment, and will show up on\n+/// Widget's documentation).\n+pub struct Widget {\n+\t/// All widgets have a purpose (this is a doc comment, and will show up\n+\t/// the field's documentation).\n+\tpurpose: String,\n+\t/// Humans are not allowed to understand some widgets\n+\tunderstandable: bool\n+}\n+\n+pub fn recalibrate() {\n+\t//! Recalibrate a pesky universe (this is also a doc comment, like above,\n+\t//! the documentation will be applied to the *parent* item, so\n+\t//! `recalibrate`).\n+\t/* ... */\n+}\n+# }\n+~~~\n+\n+Documentation can also be controlled via the `doc` attribute on items. This is\n+implicitly done by the compiler when using the above form of doc comments\n+(converting the slash-based comments to `#[doc]` attributes).\n+\n+~~~\n+#[doc = \"\n+Calculates the factorial of a number.\n+\n+Given the input integer `n`, this function will calculate `n!` and return it.\n+\"]\n+pub fn factorial(n: int) -> int { if n < 2 {1} else {n * factorial(n - 1)} }\n+# fn main() {}\n+~~~\n+\n+The `doc` attribute can also be used to control how rustdoc emits documentation\n+in some cases.\n+\n+```\n+// Rustdoc will inline documentation of a `pub use` into this crate when the\n+// `pub use` reaches across crates, but this behavior can also be disabled.\n+#[doc(no_inline)]\n+pub use std::option::Option;\n+# fn main() {}\n+```\n+\n+Doc comments are markdown, and are currently parsed with the\n+[hoedown][hoedown] library. rustdoc does not yet do any fanciness such as\n+referencing other items inline, like javadoc's `@see`. One exception to this\n+is that the first paragraph will be used as the \"summary\" of an item in the\n+generated documentation:\n+\n+~~~\n+/// A whizbang. Does stuff. (this line is the summary)\n+///\n+/// Whizbangs are ...\n+struct Whizbang;\n+~~~\n+\n+To generate the docs, run `rustdoc universe.rs`. By default, it generates a\n+directory called `doc`, with the documentation for `universe` being in\n+`doc/universe/index.html`. If you are using other crates with `extern crate`,\n+rustdoc will even link to them when you use their types, as long as their\n+documentation has already been generated by a previous run of rustdoc, or the\n+crate advertises that its documentation is hosted at a given URL.\n+\n+The generated output can be controlled with the `doc` crate attribute, which\n+is how the above advertisement works. An example from the `libstd`\n+documentation:\n+\n+~~~\n+#[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/\")];\n+~~~\n+\n+The `html_root_url` is the prefix that rustdoc will apply to any references to\n+that crate's types etc.\n+\n+rustdoc can also generate JSON, for consumption by other tools, with\n+`rustdoc --output-format json`, and also consume already-generated JSON with\n+`rustdoc --input-format json`.\n+\n+rustdoc also supports personalizing the output from crates' documentation,\n+similar to markdown options.\n+\n+- `--html-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--html-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  search bar).\n+- `--html-after-content FILE`: includes the contents of `FILE`\n+  after all the rendered content.\n+\n+# Using the Documentation\n+\n+The web pages generated by rustdoc present the same logical hierarchy that one\n+writes a library with. Every kind of item (function, struct, etc) has its own\n+color, and one can always click on a colored type to jump to its\n+documentation. There is a search bar at the top, which is powered by some\n+JavaScript and a statically-generated search index. No special web server is\n+required for the search.\n+\n+[hoedown]: https://github.com/hoedown/hoedown\n+\n+# Testing the Documentation\n+\n+`rustdoc` has support for testing code examples which appear in the\n+documentation. This is helpful for keeping code examples up to date with the\n+source code.\n+\n+To test documentation, the `--test` argument is passed to rustdoc:\n+\n+~~~ {.sh}\n+rustdoc --test crate.rs\n+~~~\n+\n+## Defining tests\n+\n+Rust documentation currently uses the markdown format, and rustdoc treats all\n+code blocks as testable-by-default unless they carry a language tag of another\n+language. In order to not run a test over a block of code, the `ignore` string\n+can be added to the three-backtick form of markdown code block.\n+\n+~~~md\n+```\n+// This is a testable code block\n+```\n+\n+```rust{.example}\n+// This is rust and also testable\n+```\n+\n+```ignore\n+// This is not a testable code block\n+```\n+\n+    // This is a testable code block (4-space indent)\n+\n+```sh\n+# this is shell code and not tested\n+```\n+~~~\n+\n+You can specify that the test's execution should fail with the `should_fail`\n+directive.\n+\n+~~~md\n+```should_fail\n+// This code block is expected to generate a panic when run\n+```\n+~~~\n+\n+You can specify that the code block should be compiled but not run with the\n+`no_run` directive.\n+\n+~~~md\n+```no_run\n+// This code will be compiled but not executed\n+```\n+~~~\n+\n+Lastly, you can specify that a code block be compiled as if `--test`\n+were passed to the compiler using the `test_harness` directive.\n+\n+~~~md\n+```test_harness\n+#[test]\n+fn foo() {\n+    panic!(\"oops! (will run & register as a failed test)\")\n+}\n+```\n+~~~\n+\n+Rustdoc also supplies some extra sugar for helping with some tedious\n+documentation examples. If a line is prefixed with `# `, then the line\n+will not show up in the HTML documentation, but it will be used when\n+testing the code block (NB. the space after the `#` is required, so\n+that one can still write things like `#[derive(Eq)]`).\n+\n+~~~md\n+```\n+# /!\\ The three following lines are comments, which are usually stripped off by\n+# the doc-generating tool.  In order to display them anyway in this particular\n+# case, the character following the leading '#' is not a usual space like in\n+# these first five lines but a non breakable one.\n+#\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n+#\u00a0// what's actually being documented.\n+#\u00a0fn fib(n: int) { n + 2 }\n+\n+spawn(move || { fib(200); })\n+```\n+~~~\n+\n+The documentation online would look like `spawn(move || { fib(200); })`, but when\n+testing this code, the `fib` function will be included (so it can compile).\n+\n+Rustdoc will automatically add a `main()` wrapper around your code, and in the right\n+place. For example:\n+\n+```\n+/// ```\n+/// use std::rc::Rc;\n+///\n+/// let five = Rc::new(5);\n+/// ```\n+# fn foo() {}\n+```\n+\n+This will end up testing:\n+\n+```\n+fn main() {\n+    use std::rc::Rc;\n+    let five = Rc::new(5);\n+}\n+```\n+\n+Here's the full algorithm:\n+\n+1. Given a code block, if it does not contain `fn main`, it is wrapped in `fn main() { your_code }`\n+2. Given that result, if it contains no `extern crate` directives but it also\n+   contains the name of the crate being tested, then `extern crate <name>` is\n+   injected at the top.\n+3. Some common `allow` attributes are added for documentation examples at the top.\n+\n+## Running tests (advanced)\n+\n+Running tests often requires some special configuration to filter tests, find\n+libraries, or try running ignored examples. The testing framework that rustdoc\n+uses is built on crate `test`, which is also used when you compile crates with\n+rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n+with the `--test-args` flag.\n+\n+~~~console\n+# Only run tests containing 'foo' in their name\n+$ rustdoc --test lib.rs --test-args 'foo'\n+\n+# See what's possible when running tests\n+$ rustdoc --test lib.rs --test-args '--help'\n+~~~\n+\n+When testing a library, code examples will often show how functions are used,\n+and this code often requires `use`-ing paths from the crate. To accommodate this,\n+rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name of\n+the crate being tested to the top of each code example. This means that rustdoc\n+must be able to find a compiled version of the library crate being tested. Extra\n+search paths may be added via the `-L` flag to `rustdoc`.\n+\n+# Standalone Markdown files\n+\n+As well as Rust crates, rustdoc supports rendering pure Markdown files\n+into HTML and testing the code snippets from them. A Markdown file is\n+detected by a `.md` or `.markdown` extension.\n+\n+There are 4 options to modify the output that Rustdoc creates.\n+\n+- `--markdown-css PATH`: adds a `<link rel=\"stylesheet\">` tag pointing to `PATH`.\n+- `--html-in-header FILE`: includes the contents of `FILE` at the\n+  end of the `<head>...</head>` section.\n+- `--html-before-content FILE`: includes the contents of `FILE`\n+  directly after `<body>`, before the rendered content (including the\n+  title).\n+- `--html-after-content FILE`: includes the contents of `FILE`\n+  directly before `</body>`, after all the rendered content.\n+\n+All of these can be specified multiple times, and they are output in\n+the order in which they are specified. The first line of the file being rendered must\n+be the title, prefixed with `%` (e.g. this page has `% Rust\n+Documentation` on the first line).\n+\n+Like with a Rust crate, the `--test` argument will run the code\n+examples to check they compile, and obeys any `--test-args` flags. The\n+tests are named after the last `#` heading."}, {"sha": "a350df67b1759ebe47afc150dd917d393ce1e4cf", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1,4 +1,4 @@\n-% `if`\n+% If\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional"}, {"sha": "4301149d1f8b3d62a26c07ba395f43976c5c3a5c", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -123,7 +123,7 @@ We now loop forever with `loop` and use `break` to break out early.\n iteration. This will only print the odd numbers:\n \n ```{rust}\n-for x in 0..10 {\n+for x in 0u32..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);"}, {"sha": "07b49751b10a0f377c53919256d610217b9c410d", "filename": "src/doc/trpl/more-strings.md", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,283 @@\n+% More Strings\n+\n+Strings are an important concept to master in any programming language. If you\n+come from a managed language background, you may be surprised at the complexity\n+of string handling in a systems programming language. Efficient access and\n+allocation of memory for a dynamically sized structure involves a lot of\n+details. Luckily, Rust has lots of tools to help us here.\n+\n+A **string** is a sequence of unicode scalar values encoded as a stream of\n+UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n+Additionally, strings are not null-terminated and can contain null bytes.\n+\n+Rust has two main types of strings: `&str` and `String`.\n+\n+# &str\n+\n+The first kind is a `&str`. This is pronounced a 'string slice'.\n+String literals are of the type `&str`:\n+\n+```\n+let string = \"Hello there.\";\n+```\n+\n+Like any Rust reference, string slices have an associated lifetime. A string\n+literal is a `&'static str`.  A string slice can be written without an explicit\n+lifetime in many cases, such as in function arguments. In these cases the\n+lifetime will be inferred:\n+\n+```\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+```\n+\n+Like vector slices, string slices are simply a pointer plus a length. This\n+means that they're a 'view' into an already-allocated string, such as a\n+string literal or a `String`.\n+\n+# String\n+\n+A `String` is a heap-allocated string. This string is growable, and is also\n+guaranteed to be UTF-8.\n+\n+```\n+let mut s = \"Hello\".to_string();\n+println!(\"{}\", s);\n+\n+s.push_str(\", world.\");\n+println!(\"{}\", s);\n+```\n+\n+You can coerce a `String` into a `&str` by dereferencing it:\n+\n+```\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+\n+fn main() {\n+    let s = \"Hello\".to_string();\n+    takes_slice(&*s);\n+}\n+```\n+\n+You can also get a `&str` from a stack-allocated array of bytes:\n+\n+```\n+use std::str;\n+\n+let x: &[u8] = &[b'a', b'b'];\n+let stack_str: &str = str::from_utf8(x).unwrap();\n+```\n+\n+# Best Practices\n+\n+## `String` vs. `&str`\n+\n+In general, you should prefer `String` when you need ownership, and `&str` when\n+you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n+and `T` vs `&T` in general.\n+\n+This means starting off with this:\n+\n+```{rust,ignore}\n+fn foo(s: &str) {\n+```\n+\n+and only moving to this:\n+\n+```{rust,ignore}\n+fn foo(s: String) {\n+```\n+\n+If you have good reason. It's not polite to hold on to ownership you don't\n+need, and it can make your lifetimes more complex.\n+\n+## Generic functions\n+\n+To write a function that's generic over types of strings, use `&str`.\n+\n+```\n+fn some_string_length(x: &str) -> uint {\n+        x.len()\n+}\n+\n+fn main() {\n+    let s = \"Hello, world\";\n+\n+    println!(\"{}\", some_string_length(s));\n+\n+    let s = \"Hello, world\".to_string();\n+\n+    println!(\"{}\", some_string_length(s.as_slice()));\n+}\n+```\n+\n+Both of these lines will print `12`.\n+\n+## Indexing strings\n+\n+You may be tempted to try to access a certain character of a `String`, like\n+this:\n+\n+```{rust,ignore}\n+let s = \"hello\".to_string();\n+\n+println!(\"{}\", s[0]);\n+```\n+\n+This does not compile. This is on purpose. In the world of UTF-8, direct\n+indexing is basically never what you want to do. The reason is that each\n+character can be a variable number of bytes. This means that you have to iterate\n+through the characters anyway, which is an O(n) operation.\n+\n+There's 3 basic levels of unicode (and its encodings):\n+\n+- code units, the underlying data type used to store everything\n+- code points/unicode scalar values (char)\n+- graphemes (visible characters)\n+\n+Rust provides iterators for each of these situations:\n+\n+- `.bytes()` will iterate over the underlying bytes\n+- `.chars()` will iterate over the code points\n+- `.graphemes()` will iterate over each grapheme\n+\n+Usually, the `graphemes()` method on `&str` is what you want:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.graphemes(true) {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This prints:\n+\n+```text\n+u\u0354\n+n\u030e\u0348\u0330\n+i\u0319\u032e\u035a\u0326\n+c\u0309\u035a\n+o\u0357\u033c\u0329\u0330\n+d\u0306\u0343\u0365\u0354\n+e\u0301\n+```\n+\n+Note that `l` has the type `&str` here, since a single grapheme can consist of\n+multiple codepoints, so a `char` wouldn't be appropriate.\n+\n+This will print out each visible character in turn, as you'd expect: first \"u\u0354\", then\n+\"n\u030e\u0348\u0330\", etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.chars() {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This prints:\n+\n+```text\n+u\n+\u0354\n+n\n+\u030e\n+\u0348\n+\u0330\n+i\n+\u0319\n+\u032e\n+\u035a\n+\u0326\n+c\n+\u0309\n+\u035a\n+o\n+\u0357\n+\u033c\n+\u0329\n+\u0330\n+d\n+\u0306\n+\u0343\n+\u0365\n+\u0354\n+e\n+\u0301\n+```\n+\n+You can see how some of them are combining characters, and therefore the output\n+looks a bit odd.\n+\n+If you want the individual byte representation of each codepoint, you can use\n+`.bytes()`:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.bytes() {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This will print:\n+\n+```text\n+117\n+205\n+148\n+110\n+204\n+142\n+205\n+136\n+204\n+176\n+105\n+204\n+153\n+204\n+174\n+205\n+154\n+204\n+166\n+99\n+204\n+137\n+205\n+154\n+111\n+205\n+151\n+204\n+188\n+204\n+169\n+204\n+176\n+100\n+204\n+134\n+205\n+131\n+205\n+165\n+205\n+148\n+101\n+204\n+129\n+```\n+\n+Many more bytes than graphemes!\n+\n+# Other Documentation\n+\n+* [the `&str` API documentation](std/str/index.html)\n+* [the `String` API documentation](std/string/index.html)"}, {"sha": "56cb5b1de699c4fd0aa40427db595d5a83faf39a", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -244,8 +244,8 @@ three. The ownership system in Rust does this through a concept called\n Remember the function that borrowed an `i32`? Let's look at it again.\n \n ```rust\n-fn add_one(num: &i32) -> i32 {\n-    *num + 1\n+fn add_one(num: &mut i32) {\n+    *num += 1;\n }\n ```\n \n@@ -255,8 +255,8 @@ cover the others later. Without eliding the lifetimes, `add_one` looks like\n this:\n \n ```rust\n-fn add_one<'a>(num: &'a i32) -> i32 {\n-    *num + 1\n+fn add_one<'a>(num: &'a mut i32) {\n+    *num += 1;\n }\n ```\n \n@@ -278,12 +278,12 @@ fn add_two<'a, 'b>(...)\n Then in our parameter list, we use the lifetimes we've named:\n \n ```{rust,ignore}\n-...(num: &'a i32) -> ...\n+...(num: &'a mut i32)\n ```\n \n-If you compare `&i32` to `&'a i32`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `i32`. We read `&i32` as \"a\n-reference to an i32\" and `&'a i32` as \"a reference to an i32 with the lifetime 'a.'\"\n+If you compare `&mut i32` to `&'a mut i32`, they're the same, it's just that the\n+lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut i32` as \"a\n+mutable reference to an i32\" and `&'a mut i32` as \"a mutable reference to an i32 with the lifetime 'a.'\"\n \n Why do lifetimes matter? Well, for example, here's some code:\n "}, {"sha": "29986d7f23577c499982e3118311aa4f8f8d89f6", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -87,7 +87,7 @@ println!(\"{}\", x + z);\n This gives us an error:\n \n ```text\n-hello.rs:6:24: 6:25 error: mismatched types: expected `i32` but found `&i32` (expected i32 but found &-ptr)\n+hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)\n hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n ```\n@@ -305,7 +305,7 @@ References are immutable by default:\n let x = 5;\n let y = &x;\n \n-*y = 5; // error: cannot assign to immutable dereference of `&`-pointer `*y`\n+*y = 5; // error: cannot assign to immutable borrowed content `*y`\n ```\n \n They can be made mutable with `mut`, but only if its referent is also mutable.\n@@ -668,7 +668,7 @@ struct BigStruct {\n }\n \n fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n-    return Box::new(*x);\n+    Box::new(*x)\n }\n \n fn main() {\n@@ -696,7 +696,7 @@ struct BigStruct {\n }\n \n fn foo(x: Box<BigStruct>) -> BigStruct {\n-    return *x;\n+    *x\n }\n \n fn main() {"}, {"sha": "a801a1ab0e9217e1982f406aeabe5160b42662ef", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -179,7 +179,7 @@ for init_val in 0 .. 3 {\n }\n \n let result = rx.recv().unwrap() + rx.recv().unwrap() + rx.recv().unwrap();\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n@@ -207,7 +207,7 @@ let rxs = (0 .. 3).map(|&:init_val| {\n \n // Wait on each port, accumulating the results\n let result = rxs.iter().fold(0, |&:accum, rx| accum + rx.recv().unwrap() );\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n ## Backgrounding computations: Futures"}, {"sha": "3acd1eefe89d06f1b7a8578eaa76c1ff7b4b13b4", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -707,7 +707,7 @@ Other features provided by lang items include:\n   various kinds; lang items `send`, `sync` and `copy`.\n - the marker types and variance indicators found in\n   `std::marker`; lang items `covariant_type`,\n-  `contravariant_lifetime`, `no_sync_bound`, etc.\n+  `contravariant_lifetime`, etc.\n \n Lang items are loaded lazily by the compiler; e.g. if one never uses\n `Box` then there is no need to define functions for `exchange_malloc`"}, {"sha": "dae685f3a540a63dc1185304c4710e7f42547673", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -54,6 +54,11 @@\n   :type 'integer\n   :group 'rust-mode)\n \n+(defcustom rust-indent-method-chain nil\n+  \"Indent Rust method chains, aligned by the '.' operators\"\n+  :type 'boolean\n+  :group 'rust-mode)\n+\n (defun rust-paren-level () (nth 0 (syntax-ppss)))\n (defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n (defun rust-rewind-past-str-cmnt () (goto-char (nth 8 (syntax-ppss))))\n@@ -73,10 +78,19 @@\n     ;; open bracket ends the line\n     (when (not (looking-at \"[[:blank:]]*\\\\(?://.*\\\\)?$\"))\n       (when (looking-at \"[[:space:]]\")\n-\t(forward-word 1)\n-\t(backward-word 1))\n+    (forward-word 1)\n+    (backward-word 1))\n       (current-column))))\n \n+(defun rust-align-to-method-chain ()\n+  (save-excursion\n+    (previous-line)\n+    (end-of-line)\n+    (backward-word 1)\n+    (backward-char)\n+    (when (looking-at \"\\\\..+\\(.*\\)\\n\")\n+      (- (current-column) rust-indent-offset))))\n+\n (defun rust-rewind-to-beginning-of-current-level-expr ()\n   (let ((current-level (rust-paren-level)))\n     (back-to-indentation)\n@@ -99,10 +113,13 @@\n                    ;; the inside of it correctly relative to the outside.\n                    (if (= 0 level)\n                        0\n+                     (or\n+                      (when rust-indent-method-chain\n+                        (rust-align-to-method-chain))\n                      (save-excursion\n                        (backward-up-list)\n                        (rust-rewind-to-beginning-of-current-level-expr)\n-                       (+ (current-column) rust-indent-offset)))))\n+                       (+ (current-column) rust-indent-offset))))))\n              (cond\n               ;; A function return type is indented to the corresponding function arguments\n               ((looking-at \"->\")\n@@ -114,6 +131,16 @@\n               ;; A closing brace is 1 level unindended\n               ((looking-at \"}\") (- baseline rust-indent-offset))\n \n+              ;;Line up method chains by their .'s\n+              ((when (and rust-indent-method-chain\n+                          (looking-at \"\\..+\\(.*\\);?\\n\"))\n+                 (or\n+                  (let ((method-indent (rust-align-to-method-chain)))\n+                    (when method-indent\n+                      (+ method-indent rust-indent-offset)))\n+                  (+ baseline rust-indent-offset))))\n+\n+              \n               ;; Doc comments in /** style with leading * indent to line up the *s\n               ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n                (+ 1 baseline))"}, {"sha": "17659309d3b0d6822dcedb2b0f773e06d0b1187f", "filename": "src/etc/errorck.py", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,70 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Digs error codes out of files named 'diagnostics.rs' across\n+# the tree, and ensures thare are no duplicates.\n+\n+import sys, os, re\n+\n+src_dir = sys.argv[1]\n+\n+errcode_map = { }\n+\n+for (dirpath, dirnames, filenames) in os.walk(src_dir):\n+\n+    if \"src/test\" in dirpath or \"src/llvm\" in dirpath:\n+        # Short circuit for fast\n+        continue\n+\n+    for filename in filenames:\n+        if filename != \"diagnostics.rs\":\n+            continue\n+\n+        path = os.path.join(dirpath, filename)\n+        line_num = 1\n+        with open(path, 'r') as f:\n+            for line in f:\n+\n+                p = re.compile(\"(E\\d\\d\\d\\d)\")\n+                m = p.search(line)\n+                if not m is None:\n+                    errcode = m.group(1)\n+\n+                    new_record = [(errcode, path, line_num, line)]\n+                    existing = errcode_map.get(errcode)\n+                    if existing is not None:\n+                        # This is a dupe\n+                        errcode_map[errcode] = existing + new_record\n+                    else:\n+                        errcode_map[errcode] = new_record\n+\n+                line_num += 1\n+\n+errors = False\n+all_errors = []\n+for errcode in errcode_map:\n+    entries = errcode_map[errcode]\n+    all_errors += [entries[0][0]]\n+    if len(entries) > 1:\n+        print \"error: duplicate error code \" + errcode\n+        for entry in entries:\n+            print entry[1] + \": \" + str(entry[2])\n+            print entry[3]\n+        errors = True\n+\n+print str(len(errcode_map)) + \" error codes\"\n+\n+all_errors.sort()\n+all_errors.reverse()\n+\n+print \"highest error code: \" + all_errors[0]\n+\n+if errors:\n+    sys.exit(1)"}, {"sha": "07e832d317adb2f91f098e960865e84d18e085fd", "filename": "src/etc/rustup.sh", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -433,11 +433,16 @@ CFG_TMP_DIR=$(mktemp -d 2>/dev/null \\\n            || mktemp -d -t 'rustup-tmp-install' 2>/dev/null \\\n            || create_tmp_dir)\n \n-# If we're saving nightlies and we didn't specify which one, grab todays.\n-# Otherwise we'll use the latest version.\n+# If we're saving nightlies and we didn't specify which one, grab the latest\n+# verison from the perspective of the server. Buildbot has typically finished\n+# building and uploading by ~8UTC, but we want to include a little buffer.\n+#\n+# FIXME It would be better to use the known most recent nightly that has been\n+# built. This is waiting on a change to have buildbot publish metadata that\n+# can be queried.\n if [ -n \"${CFG_SAVE}\" -a -z \"${CFG_DATE}\" ];\n then\n-    CFG_DATE=`date \"+%Y-%m-%d\"`\n+    CFG_DATE=`TZ=Etc/UTC+9 date \"+%Y-%m-%d\"`\n fi\n \n RUST_URL=\"https://static.rust-lang.org/dist\"\n@@ -453,16 +458,33 @@ then\n     RUST_URL=\"${RUST_URL}/${CFG_DATE}\"\n fi\n \n-verify_hash() {\n-    remote_sha256=\"$1\"\n-    local_file=\"$2\"\n-\n+download_hash() {\n     msg \"Downloading ${remote_sha256}\"\n     remote_sha256=`\"${CFG_CURL}\" -f \"${remote_sha256}\"`\n+    if [ -n \"${CFG_SAVE}\" ]; then\n+        echo \"${remote_sha256}\" > \"${local_sha_file}\"\n+    fi\n     if [ \"$?\" -ne 0 ]; then\n         rm -Rf \"${CFG_TMP_DIR}\"\n         err \"Failed to download ${remote_url}\"\n     fi\n+}\n+\n+verify_hash() {\n+    remote_sha256=\"$1\"\n+    local_file=\"$2\"\n+    local_sha_file=\"${local_file}.sha256\"\n+\n+    if [ -n \"${CFG_SAVE}\" ]; then\n+        if [ -f \"${local_sha_file}\" ]; then\n+            msg \"Local ${local_sha_file} exists, treating as remote hash\"\n+            remote_sha256=`cat \"${local_sha_file}\"`\n+        else\n+            download_hash\n+        fi\n+    else\n+        download_hash\n+    fi\n \n     msg \"Verifying hash\"\n     local_sha256=$(calculate_hash \"${local_file}\")"}, {"sha": "1288110df330a236306977793225a0dcb259e3e3", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -13,14 +13,11 @@\n extern crate syntax;\n extern crate rustc;\n \n-extern crate regex;\n-\n #[macro_use]\n extern crate log;\n \n use std::collections::HashMap;\n use std::io::File;\n-use regex::Regex;\n \n use syntax::parse;\n use syntax::parse::lexer;\n@@ -167,15 +164,19 @@ fn count(lit: &str) -> usize {\n }\n \n fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAndSpan {\n-    let re = Regex::new(\n-      r\"\\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\"\n-    ).unwrap();\n-\n-    let m = re.captures(s).expect(format!(\"The regex didn't match {}\", s).as_slice());\n-    let start = m.name(\"start\").unwrap_or(\"\");\n-    let end = m.name(\"end\").unwrap_or(\"\");\n-    let toknum = m.name(\"toknum\").unwrap_or(\"\");\n-    let content = m.name(\"content\").unwrap_or(\"\");\n+    // old regex:\n+    // \\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\n+    let start = s.find_str(\"[@\").unwrap();\n+    let comma = start + s[start..].find_str(\",\").unwrap();\n+    let colon = comma + s[comma..].find_str(\":\").unwrap();\n+    let content_start = colon + s[colon..].find_str(\"='\").unwrap();\n+    let content_end = content_start + s[content_start..].find_str(\"',<\").unwrap();\n+    let toknum_end = content_end + s[content_end..].find_str(\">,\").unwrap();\n+\n+    let start = &s[comma + 1 .. colon];\n+    let end = &s[colon + 1 .. content_start];\n+    let content = &s[content_start + 2 .. content_end];\n+    let toknum = &s[content_end + 3 .. toknum_end];\n \n     let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {:?} in the map\",\n                                                               toknum).as_slice());"}, {"sha": "1b75289c64f9fa57dfa43764ba2b549a7990d171", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -72,7 +72,7 @@ use core::prelude::*;\n use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::borrow::BorrowFrom;\n-use core::fmt::{self, Show};\n+use core::fmt;\n use core::cmp::{Ordering};\n use core::default::Default;\n use core::mem::{min_align_of, size_of};\n@@ -582,16 +582,17 @@ impl<T: Ord> Ord for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Arc<T> {}\n \n-impl<T: fmt::Show> fmt::Show for Arc<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Display> fmt::Display for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Arc({:?})\", (**self))\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::String> fmt::String for Arc<T> {\n+impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n@@ -809,7 +810,7 @@ mod tests {\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);\n-        assert!(format!(\"{:?}\", a) == \"Arc(5u32)\")\n+        assert_eq!(format!(\"{:?}\", a), \"5\");\n     }\n \n     // Make sure deriving works with Arc<T>"}, {"sha": "51e5fc5820cbf9002e9251b219a780dd87ed5024", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 91, "deletions": 64, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -8,27 +8,62 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A unique pointer type.\n+//! A pointer type for heap allocation.\n+//!\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n+//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n+//! scope.\n+//!\n+//! Boxes are useful in two situations: recursive data structures, and occasionally when returning\n+//! data. [The Pointer chapter of the Book](../../../book/pointers.html#best-practices-1) explains\n+//! these cases in detail.\n+//!\n+//! # Examples\n+//!\n+//! Creating a box:\n+//!\n+//! ```\n+//! let x = Box::new(5);\n+//! ```\n+//!\n+//! Creating a recursive data structure:\n+//!\n+//! ```\n+//! #[derive(Show)]\n+//! enum List<T> {\n+//!     Cons(T, Box<List<T>>),\n+//!     Nil,\n+//! }\n+//!\n+//! fn main() {\n+//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n+//!     println!(\"{:?}\", list);\n+//! }\n+//! ```\n+//!\n+//! This will print `Cons(1i32, Box(Cons(2i32, Box(Nil))))`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n+use core::error::{Error, FromError};\n use core::fmt;\n use core::hash::{self, Hash};\n+use core::iter::Iterator;\n use core::marker::Sized;\n use core::mem;\n+use core::ops::{Deref, DerefMut};\n use core::option::Option;\n use core::ptr::Unique;\n use core::raw::TraitObject;\n-use core::result::Result;\n use core::result::Result::{Ok, Err};\n-use core::ops::{Deref, DerefMut};\n+use core::result::Result;\n \n-/// A value that represents the global exchange heap. This is the default\n-/// place that the `box` keyword allocates into when no place is supplied.\n+/// A value that represents the heap. This is the default place that the `box` keyword allocates\n+/// into when no place is supplied.\n ///\n /// The following two examples are equivalent:\n ///\n@@ -37,24 +72,30 @@ use core::ops::{Deref, DerefMut};\n /// use std::boxed::HEAP;\n ///\n /// fn main() {\n-/// # struct Bar;\n-/// # impl Bar { fn new(_a: int) { } }\n-///     let foo = box(HEAP) Bar::new(2);\n-///     let foo = box Bar::new(2);\n+///     let foo = box(HEAP) 5;\n+///     let foo = box 5;\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n #[unstable(feature = \"alloc\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n pub static HEAP: () = ();\n \n-/// A type that represents a uniquely-owned value.\n+/// A pointer type for heap allocation.\n+///\n+/// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n-    /// Moves `x` into a freshly allocated box on the global exchange heap.\n+    /// Allocates memory on the heap and then moves `x` into it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(x: T) -> Box<T> {\n         box x\n@@ -75,11 +116,29 @@ impl<T> Default for Box<[T]> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Box<T> {\n-    /// Returns a copy of the owned box.\n+    /// Returns a new box with a `clone()` of this box's contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let y = x.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Box<T> { box {(**self).clone()} }\n \n-    /// Performs copy-assignment from `source` by reusing the existing allocation.\n+    /// Copies `source`'s contents into `self` without creating a new allocation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let mut y = Box::new(10);\n+    ///\n+    /// y.clone_from(&x);\n+    ///\n+    /// assert_eq!(*y, 5);\n+    /// ```\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n         (**self).clone_from(&(**source));\n@@ -158,20 +217,22 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Box({:?})\", &**self)\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n+impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-impl fmt::Show for Box<Any> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Box<Any> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Box<Any>\")\n     }\n@@ -189,56 +250,22 @@ impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n \n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn test_owned_clone() {\n-        let a = Box::new(5i);\n-        let b: Box<int> = a.clone();\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn any_move() {\n-        let a = Box::new(8u) as Box<Any>;\n-        let b = Box::new(Test) as Box<Any>;\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#[old_impl_check]\n+impl<'a, T> Iterator for Box<Iterator<Item=T> + 'a> {\n+    type Item = T;\n \n-        match a.downcast::<uint>() {\n-            Ok(a) => { assert!(a == Box::new(8u)); }\n-            Err(..) => panic!()\n-        }\n-        match b.downcast::<Test>() {\n-            Ok(a) => { assert!(a == Box::new(Test)); }\n-            Err(..) => panic!()\n-        }\n-\n-        let a = Box::new(8u) as Box<Any>;\n-        let b = Box::new(Test) as Box<Any>;\n-\n-        assert!(a.downcast::<Box<Test>>().is_err());\n-        assert!(b.downcast::<Box<uint>>().is_err());\n+    fn next(&mut self) -> Option<T> {\n+        (**self).next()\n     }\n \n-    #[test]\n-    fn test_show() {\n-        let a = Box::new(8u) as Box<Any>;\n-        let b = Box::new(Test) as Box<Any>;\n-        let a_str = a.to_str();\n-        let b_str = b.to_str();\n-        assert_eq!(a_str, \"Box<Any>\");\n-        assert_eq!(b_str, \"Box<Any>\");\n-\n-        let a = &8u as &Any;\n-        let b = &Test as &Any;\n-        let s = format!(\"{}\", a);\n-        assert_eq!(s, \"&Any\");\n-        let s = format!(\"{}\", b);\n-        assert_eq!(s, \"&Any\");\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n     }\n+}\n \n-    #[test]\n-    fn deref() {\n-        fn homura<T: Deref<Target=i32>>(_: T) { }\n-        homura(Box::new(765i32));\n+impl<'a, E: Error + 'a> FromError<E> for Box<Error + 'a> {\n+    fn from_error(err: E) -> Box<Error + 'a> {\n+        Box::new(err)\n     }\n }"}, {"sha": "c47a771f60d09ceb2ad74fed5a754413f396a34a", "filename": "src/liballoc/boxed_test.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Test for `boxed` mod.\n+\n+use core::any::Any;\n+use core::ops::Deref;\n+use core::result::Result::{Ok, Err};\n+use core::clone::Clone;\n+\n+use std::boxed::Box;\n+use std::boxed::BoxAny;\n+\n+#[test]\n+fn test_owned_clone() {\n+    let a = Box::new(5i);\n+    let b: Box<int> = a.clone();\n+    assert!(a == b);\n+}\n+\n+#[derive(PartialEq, Eq)]\n+struct Test;\n+\n+#[test]\n+fn any_move() {\n+    let a = Box::new(8u) as Box<Any>;\n+    let b = Box::new(Test) as Box<Any>;\n+\n+    match a.downcast::<uint>() {\n+        Ok(a) => { assert!(a == Box::new(8u)); }\n+        Err(..) => panic!()\n+    }\n+    match b.downcast::<Test>() {\n+        Ok(a) => { assert!(a == Box::new(Test)); }\n+        Err(..) => panic!()\n+    }\n+\n+    let a = Box::new(8u) as Box<Any>;\n+    let b = Box::new(Test) as Box<Any>;\n+\n+    assert!(a.downcast::<Box<Test>>().is_err());\n+    assert!(b.downcast::<Box<uint>>().is_err());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let a = Box::new(8u) as Box<Any>;\n+    let b = Box::new(Test) as Box<Any>;\n+    let a_str = format!(\"{:?}\", a);\n+    let b_str = format!(\"{:?}\", b);\n+    assert_eq!(a_str, \"Box<Any>\");\n+    assert_eq!(b_str, \"Box<Any>\");\n+\n+    static EIGHT: usize = 8us;\n+    static TEST: Test = Test;\n+    let a = &EIGHT as &Any;\n+    let b = &TEST as &Any;\n+    let s = format!(\"{:?}\", a);\n+    assert_eq!(s, \"&Any\");\n+    let s = format!(\"{:?}\", b);\n+    assert_eq!(s, \"&Any\");\n+}\n+\n+#[test]\n+fn deref() {\n+    fn homura<T: Deref<Target=i32>>(_: T) { }\n+    homura(Box::new(765i32));\n+}"}, {"sha": "dcbd4d57cf990399ca0feae11b623b4340bdc398", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -280,7 +280,7 @@ mod imp {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as libc::size_t) as *mut u8\n         } else {\n-            let mut out = 0 as *mut libc::c_void;\n+            let mut out = ptr::null_mut();\n             let ret = posix_memalign(&mut out,\n                                      align as libc::size_t,\n                                      size as libc::size_t);"}, {"sha": "6830a1c33dfabe0d830fcdaa327515a149f89d00", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -70,6 +70,8 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#![feature(old_impl_check)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(core)]\n #![feature(hash)]\n@@ -94,6 +96,8 @@ pub mod heap;\n \n #[cfg(not(test))]\n pub mod boxed;\n+#[cfg(test)]\n+mod boxed_test;\n pub mod arc;\n pub mod rc;\n "}, {"sha": "d41673f56edda2cb2a7e13b625fac3d5d4cbac80", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 8, "deletions": 165, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -173,63 +173,18 @@ struct RcBox<T> {\n ///\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n-    _nosend: marker::NoSend,\n-    _noshare: marker::NoSync\n }\n \n-/// An immutable reference-counted pointer type.\n-///\n-/// See the [module level documentation](../index.html) for more details.\n-#[unsafe_no_drop_flag]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n-    // type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<T> !marker::Send for Rc<T> {}\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<T> !marker::Sync for Rc<T> {}\n \n impl<T> Rc<T> {\n-    /// Constructs a new `Rc<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    /// ```\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(value: T) -> Rc<T> {\n-        unsafe {\n-            Rc {\n-                // there is an implicit weak pointer owned by all the strong pointers, which\n-                // ensures that the weak destructor never frees the allocation while the strong\n-                // destructor is running, even if the weak pointer is stored inside the strong one.\n-                _ptr: NonZero::new(transmute(box RcBox {\n-                    value: value,\n-                    strong: Cell::new(1),\n-                    weak: Cell::new(1)\n-                })),\n-                _nosend: marker::NoSend,\n-                _noshare: marker::NoSync\n-            }\n-        }\n-    }\n-\n     /// Constructs a new `Rc<T>`.\n     ///\n     /// # Examples\n@@ -240,7 +195,6 @@ impl<T> Rc<T> {\n     /// let five = Rc::new(5i);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -267,30 +221,6 @@ impl<T> Rc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    #[unstable(feature = \"alloc\",\n-               reason = \"Weak pointers may not belong in this module\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak {\n-            _ptr: self._ptr,\n-            _nosend: marker::NoSend,\n-            _noshare: marker::NoSync\n-        }\n-    }\n-\n-    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    /// ```\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     #[unstable(feature = \"alloc\",\n                reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n@@ -485,25 +415,6 @@ impl<T> Drop for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Rc<T> {\n-    /// Makes a clone of the `Rc<T>`.\n-    ///\n-    /// This increases the strong reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    ///\n-    /// five.clone();\n-    /// ```\n-    #[inline]\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    fn clone(&self) -> Rc<T> {\n-        self.inc_strong();\n-        Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync }\n-    }\n \n     /// Makes a clone of the `Rc<T>`.\n     ///\n@@ -519,7 +430,6 @@ impl<T> Clone for Rc<T> {\n     /// five.clone();\n     /// ```\n     #[inline]\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n         Rc { _ptr: self._ptr }\n@@ -695,37 +605,20 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[unstable(feature = \"alloc\", reason = \"Show is experimental.\")]\n-impl<T: fmt::Show> fmt::Show for Rc<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Rc({:?})\", **self)\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::String> fmt::String for Rc<T> {\n+impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-/// A weak version of `Rc<T>`.\n-///\n-/// Weak references do not count when determining if the inner value should be dropped.\n-///\n-/// See the [module level documentation](../index.html) for more.\n-#[unsafe_no_drop_flag]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-pub struct Weak<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-    _nosend: marker::NoSend,\n-    _noshare: marker::NoSync\n-}\n-\n /// A weak version of `Rc<T>`.\n ///\n /// Weak references do not count when determining if the inner value should be dropped.\n@@ -734,49 +627,20 @@ pub struct Weak<T> {\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<T> !marker::Send for Weak<T> {}\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<T> !marker::Sync for Weak<T> {}\n \n \n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n-    ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n-    ///\n-    /// Returns `None` if there were no strong references and the data was destroyed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    ///\n-    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n-    /// ```\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n-            None\n-        } else {\n-            self.inc_strong();\n-            Some(Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync })\n-        }\n-    }\n \n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -795,7 +659,6 @@ impl<T> Weak<T> {\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n     /// ```\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -853,25 +716,6 @@ impl<T> Drop for Weak<T> {\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n-    ///\n-    /// This increases the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let weak_five = Rc::new(5i).downgrade();\n-    ///\n-    /// weak_five.clone();\n-    /// ```\n-    #[inline]\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync }\n-    }\n \n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -887,15 +731,14 @@ impl<T> Clone for Weak<T> {\n     /// weak_five.clone();\n     /// ```\n     #[inline]\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n     }\n }\n \n-#[unstable(feature = \"alloc\", reason = \"Show is experimental.\")]\n-impl<T: fmt::Show> fmt::Show for Weak<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n@@ -1137,7 +980,7 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let foo = Rc::new(75u);\n-        assert!(format!(\"{:?}\", foo) == \"Rc(75u)\")\n+        assert_eq!(format!(\"{:?}\", foo), \"75\");\n     }\n \n }"}, {"sha": "2c9a502a20987bb298155c4a3b588c4bd6faaea6", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -331,7 +331,7 @@ impl Bitv {\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n-            for (i, &byte) in bytes[(complete_words*4)..].iter().enumerate() {\n+            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);\n@@ -974,7 +974,7 @@ impl Ord for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Show for Bitv {\n+impl fmt::Debug for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n@@ -1730,7 +1730,7 @@ impl BitvSet {\n     }\n }\n \n-impl fmt::Show for BitvSet {\n+impl fmt::Debug for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"BitvSet {{\"));\n         let mut first = true;\n@@ -2625,7 +2625,7 @@ mod bitv_set_test {\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"BitvSet {1u, 2u, 10u, 50u}\", format!(\"{:?}\", s));\n+        assert_eq!(\"BitvSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n     }\n \n     #[test]"}, {"sha": "17d26ed1a21e80908e942af4a16288343e198a6a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -22,7 +22,7 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n-use core::fmt::Show;\n+use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator};\n use core::ops::{Index, IndexMut};\n@@ -874,7 +874,7 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n+impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeMap {{\"));\n "}, {"sha": "95e424fb7a03cd04bcee56099299dc696ffbc91e", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -21,7 +21,7 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n-use core::ops::{Deref, DerefMut};\n+use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n use alloc::heap;\n@@ -1487,7 +1487,7 @@ impl<K, V, E, Impl> AbsTraversal<Impl>\n \n macro_rules! node_slice_impl {\n     ($NodeSlice:ident, $Traversal:ident,\n-     $as_slices_internal:ident, $slice_from:ident, $slice_to:ident, $iter:ident) => {\n+     $as_slices_internal:ident, $index:ident, $iter:ident) => {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n             fn search_linear<Q: ?Sized>(&self, key: &Q) -> (uint, bool)\n@@ -1521,10 +1521,10 @@ macro_rules! node_slice_impl {\n                     edges: if !self.has_edges {\n                         self.edges\n                     } else {\n-                        self.edges.$slice_from(pos)\n+                        self.edges.$index(&(pos ..))\n                     },\n-                    keys: self.keys.slice_from(pos),\n-                    vals: self.vals.$slice_from(pos),\n+                    keys: &self.keys[pos ..],\n+                    vals: self.vals.$index(&(pos ..)),\n                     head_is_edge: !pos_is_kv,\n                     tail_is_edge: self.tail_is_edge,\n                 }\n@@ -1550,10 +1550,10 @@ macro_rules! node_slice_impl {\n                     edges: if !self.has_edges {\n                         self.edges\n                     } else {\n-                        self.edges.$slice_to(pos + 1)\n+                        self.edges.$index(&(.. (pos + 1)))\n                     },\n-                    keys: self.keys.slice_to(pos),\n-                    vals: self.vals.$slice_to(pos),\n+                    keys: &self.keys[..pos],\n+                    vals: self.vals.$index(&(.. pos)),\n                     head_is_edge: self.head_is_edge,\n                     tail_is_edge: !pos_is_kv,\n                 }\n@@ -1583,6 +1583,5 @@ macro_rules! node_slice_impl {\n     }\n }\n \n-node_slice_impl!(NodeSlice, Traversal, as_slices_internal, slice_from, slice_to, iter);\n-node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, slice_from_mut,\n-                                                                     slice_to_mut, iter_mut);\n+node_slice_impl!(NodeSlice, Traversal, as_slices_internal, index, iter);\n+node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, index_mut, iter_mut);"}, {"sha": "e95087fa84689409eb6d4baed25336b5a44b7869", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -16,11 +16,8 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n-use core::fmt::Show;\n+use core::fmt::Debug;\n use core::fmt;\n-// NOTE(stage0) remove import after a snapshot\n-#[cfg(stage0)]\n-use core::hash::Hash;\n use core::iter::{Peekable, Map, FromIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n@@ -594,7 +591,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Show> Show for BTreeSet<T> {\n+impl<T: Debug> Debug for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeSet {{\"));\n \n@@ -894,7 +891,7 @@ mod test {\n \n         let set_str = format!(\"{:?}\", set);\n \n-        assert_eq!(set_str, \"BTreeSet {1i, 2i}\");\n+        assert_eq!(set_str, \"BTreeSet {1, 2}\");\n         assert_eq!(format!(\"{:?}\", empty), \"BTreeSet {}\");\n     }\n }"}, {"sha": "08f7cea4e92453063bbceb3614309bcb6b4d52cb", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -876,7 +876,7 @@ impl<A: Clone> Clone for DList<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: fmt::Show> fmt::Show for DList<A> {\n+impl<A: fmt::Debug> fmt::Debug for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DList [\"));\n \n@@ -1335,7 +1335,7 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i]\");\n+        assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)"}, {"sha": "f36da6f82eb730047323e4a42b02a74025855008", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -31,7 +31,7 @@ pub struct EnumSet<E> {\n \n impl<E> Copy for EnumSet<E> {}\n \n-impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n+impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"EnumSet {{\"));\n         let mut first = true;"}, {"sha": "15048998592a9dcf6a050d6db0306a06722b2642", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -12,13 +12,13 @@\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! vec {\n-    ($x:expr; $y:expr) => ({\n-        let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$x; $y]);\n-        $crate::slice::SliceExt::into_vec(xs)\n-    });\n-    ($($x:expr),*) => ({\n-        let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$($x),*]);\n-        $crate::slice::SliceExt::into_vec(xs)\n-    });\n+    ($x:expr; $y:expr) => (\n+        <[_] as $crate::slice::SliceExt>::into_vec(\n+            $crate::boxed::Box::new([$x; $y]))\n+    );\n+    ($($x:expr),*) => (\n+        <[_] as $crate::slice::SliceExt>::into_vec(\n+            $crate::boxed::Box::new([$($x),*]))\n+    );\n     ($($x:expr,)*) => (vec![$($x),*])\n }"}, {"sha": "2e3f61981122ee6dcadd36ee0df7a8003d820611", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -581,7 +581,7 @@ impl<T> RingBuf<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (buf.slice_mut(tail, head), empty)\n+                (&mut buf[tail .. head], empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);\n@@ -1619,7 +1619,7 @@ impl<A> Extend<A> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n+impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"RingBuf [\"));\n \n@@ -1638,7 +1638,7 @@ mod tests {\n     use self::Taggypar::*;\n     use prelude::*;\n     use core::iter;\n-    use std::fmt::Show;\n+    use std::fmt::Debug;\n     use std::hash::{self, SipHasher};\n     use test::Bencher;\n     use test;\n@@ -1686,7 +1686,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn test_parameterized<T:Clone + PartialEq + Show>(a: T, b: T, c: T, d: T) {\n+    fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n         let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n@@ -2310,7 +2310,7 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: RingBuf<int> = range(0i, 10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .map(|&s| s)"}, {"sha": "dff95711d49e16651980b3d5fe74e9b48487adcf", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 53, "deletions": 47, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -170,32 +170,22 @@ pub trait SliceExt {\n                reason = \"uncertain about this API approach\")]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n+    /// Deprecated: use `&s[start .. end]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n+    /// Deprecated: use `&s[start..]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] isntead\")]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n+    /// Deprecated: use `&s[..end]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -382,32 +372,22 @@ pub trait SliceExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n+    /// Deprecated: use `&mut s[start .. end]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n+    /// Deprecated: use `&mut s[start ..]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n+    /// Deprecated: use `&mut s[.. end]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n@@ -724,25 +704,25 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n     }\n \n     #[inline]\n     fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+        &self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+        &self[start ..]\n     }\n \n     #[inline]\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n+        &self[.. end]\n     }\n \n     #[inline]\n@@ -846,17 +826,17 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n+        &mut self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n+        &mut self[start ..]\n     }\n \n     #[inline]\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n+        &mut self[.. end]\n     }\n \n     #[inline]\n@@ -1005,11 +985,30 @@ impl<T> SliceExt for [T] {\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"hello\", \"world\"];\n+    ///\n+    /// let s: String = v.concat();\n+    ///\n+    /// println!(\"{}\", s); // prints \"helloworld\"\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> U;\n \n-    /// Flattens a slice of `T` into a single value `U`, placing a\n-    /// given separator between each.\n+    /// Flattens a slice of `T` into a single value `U`, placing a given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"hello\", \"world\"];\n+    ///\n+    /// let s: String = v.connect(\" \");\n+    ///\n+    /// println!(\"{}\", s); // prints \"hello world\"\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn connect(&self, sep: &T) -> U;\n }\n@@ -2421,8 +2420,12 @@ mod tests {\n \n     #[test]\n     fn test_chunksator() {\n+        use core::iter::ExactSizeIterator;\n+\n         let v = &[1i,2,3,4,5];\n \n+        assert_eq!(v.chunks(2).len(), 3);\n+\n         let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n         assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n@@ -2488,19 +2491,19 @@ mod tests {\n         }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n-        test_show_vec!(vec![1i], \"[1i]\");\n-        test_show_vec!(vec![1i, 2, 3], \"[1i, 2i, 3i]\");\n+        test_show_vec!(vec![1i], \"[1]\");\n+        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n-                       \"[[], [1u], [1u, 1u]]\");\n+                       \"[[], [1], [1, 1]]\");\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\");\n         let v: &mut[int] = &mut[1];\n-        test_show_vec!(v, \"[1i]\");\n+        test_show_vec!(v, \"[1]\");\n         let v: &mut[int] = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1i, 2i, 3i]\");\n+        test_show_vec!(v, \"[1, 2, 3]\");\n         let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n-        test_show_vec!(v, \"[[], [1u], [1u, 1u]]\");\n+        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n     #[test]\n@@ -2687,7 +2690,10 @@ mod tests {\n \n     #[test]\n     fn test_mut_chunks() {\n+        use core::iter::ExactSizeIterator;\n+\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n+        assert_eq!(v.chunks_mut(2).len(), 4);\n         for (i, chunk) in v.chunks_mut(3).enumerate() {\n             for x in chunk.iter_mut() {\n                 *x = i as u8;"}, {"sha": "63ae743b421b0ac15bdeb0d8587cb48693114b1e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 24, "deletions": 59, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -759,70 +759,23 @@ pub trait StrExt: Index<FullRange, Output = str> {\n         core_str::StrExt::lines_any(&self[])\n     }\n \n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n+    /// Deprecated: use `s[a .. b]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(&self[], begin, end)\n-    }\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n+    fn slice(&self, begin: uint, end: uint) -> &str;\n \n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n+    /// Deprecated: use `s[a..]` instead.\n     #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..] instead\")]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(&self[], begin)\n-    }\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n+    fn slice_from(&self, begin: uint) -> &str;\n \n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n+    /// Deprecated: use `s[..a]` instead.\n     #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [..a] instead\")]\n-    fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(&self[], end)\n-    }\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n+    fn slice_to(&self, end: uint) -> &str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -1374,7 +1327,19 @@ pub trait StrExt: Index<FullRange, Output = str> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl StrExt for str {}\n+impl StrExt for str {\n+    fn slice(&self, begin: uint, end: uint) -> &str {\n+        &self[begin..end]\n+    }\n+\n+    fn slice_from(&self, begin: uint) -> &str {\n+        &self[begin..]\n+    }\n+\n+    fn slice_to(&self, end: uint) -> &str {\n+        &self[..end]\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "cdceca7176d0abe52cba45df907a2076a7cf4035", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -18,6 +18,7 @@ use core::prelude::*;\n \n use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n+use core::error::Error;\n use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n@@ -40,6 +41,7 @@ pub struct String {\n \n /// A possible error value from the `String::from_utf8` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Show)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n@@ -48,6 +50,7 @@ pub struct FromUtf8Error {\n /// A possible error value from the `String::from_utf16` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_copy_implementations)]\n+#[derive(Show)]\n pub struct FromUtf16Error(());\n \n impl String {\n@@ -681,30 +684,28 @@ impl FromUtf8Error {\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n \n-impl fmt::Show for FromUtf8Error {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(&self.error, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::String for FromUtf8Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&self.error, f)\n-    }\n+impl Error for FromUtf8Error {\n+    fn description(&self) -> &str { \"invalid utf-8\" }\n }\n \n-impl fmt::Show for FromUtf16Error {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::String for FromUtf16Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n-    }\n+impl Error for FromUtf16Error {\n+    fn description(&self) -> &str { \"invalid utf-16\" }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -817,18 +818,18 @@ impl Default for String {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::String for String {\n+impl fmt::Display for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on fmt stabilization\")]\n-impl fmt::Show for String {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n@@ -852,27 +853,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::FullRange> for String {\n     type Output = str;\n     #[inline]\n@@ -938,7 +943,7 @@ pub trait ToString {\n     fn to_string(&self) -> String;\n }\n \n-impl<T: fmt::String + ?Sized> ToString for T {\n+impl<T: fmt::Display + ?Sized> ToString for T {\n     #[inline]\n     fn to_string(&self) -> String {\n         use core::fmt::Writer;\n@@ -1299,10 +1304,10 @@ mod tests {\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n         assert_eq!(format!(\"{:?}\", x), \"[]\");\n-        assert_eq!(format!(\"{:?}\", vec![1i]), \"[1i]\");\n-        assert_eq!(format!(\"{:?}\", vec![1i, 2, 3]), \"[1i, 2i, 3i]\");\n+        assert_eq!(format!(\"{:?}\", vec![1i]), \"[1]\");\n+        assert_eq!(format!(\"{:?}\", vec![1i, 2, 3]), \"[1, 2, 3]\");\n         assert!(format!(\"{:?}\", vec![vec![], vec![1i], vec![1i, 1]]) ==\n-               \"[[], [1i], [1i, 1i]]\");\n+               \"[[], [1], [1, 1]]\");\n     }\n \n     #[test]"}, {"sha": "53f75a3e778b77bb4dae97d0ecc75813824886b5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1235,7 +1235,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Index stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1245,6 +1245,7 @@ impl<T> Index<uint> for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1255,27 +1256,31 @@ impl<T> IndexMut<uint> for Vec<T> {\n }\n \n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1284,27 +1289,31 @@ impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1313,7 +1322,6 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n@@ -1494,10 +1502,10 @@ impl<T> Default for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Show stability\")]\n-impl<T: fmt::Show> fmt::Show for Vec<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(self.as_slice(), f)\n+        fmt::Debug::fmt(self.as_slice(), f)\n     }\n }\n \n@@ -2168,7 +2176,7 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_1() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        &x[(-1)..];\n+        &x[-1..];\n     }\n \n     #[test]\n@@ -2182,7 +2190,7 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_3() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        &x[(-1)..4];\n+        &x[-1..4];\n     }\n \n     #[test]"}, {"sha": "3d28284c9bf97e55245fea7c0f6d68e6805bb9a3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -514,7 +514,7 @@ impl<V: Ord> Ord for VecMap<V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: fmt::Show> fmt::Show for VecMap<V> {\n+impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"VecMap {{\"));\n \n@@ -991,7 +991,7 @@ mod test_map {\n         map.insert(3, 4i);\n \n         let map_str = format!(\"{:?}\", map);\n-        assert!(map_str == \"VecMap {1: 2i, 3: 4i}\" || map_str == \"{3: 4i, 1: 2i}\");\n+        assert!(map_str == \"VecMap {1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n         assert_eq!(format!(\"{:?}\", empty), \"VecMap {}\");\n     }\n "}, {"sha": "87030ed778da767d7139dffd54a6d1c85b2785db", "filename": "src/libcore/any.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -34,11 +34,11 @@\n //! use runtime reflection instead.\n //!\n //! ```rust\n-//! use std::fmt::Show;\n+//! use std::fmt::Debug;\n //! use std::any::Any;\n //!\n-//! // Logger function for any type that implements Show.\n-//! fn log<T: Any+Show>(value: &T) {\n+//! // Logger function for any type that implements Debug.\n+//! fn log<T: Any + Debug>(value: &T) {\n //!     let value_any = value as &Any;\n //!\n //!     // try to convert our value to a String.  If successful, we want to\n@@ -55,7 +55,7 @@\n //! }\n //!\n //! // This function wants to log its parameter out prior to doing work with it.\n-//! fn do_work<T: Show+'static>(value: &T) {\n+//! fn do_work<T: Debug + 'static>(value: &T) {\n //!     log(value);\n //!     // ...do some other work\n //! }\n@@ -75,7 +75,7 @@ use mem::transmute;\n use option::Option::{self, Some, None};\n use raw::TraitObject;\n use intrinsics;\n-#[cfg(not(stage0))] use marker::Sized;\n+use marker::Sized;\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -176,18 +176,11 @@ pub struct TypeId {\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n-    #[cfg(not(stage0))]\n     #[unstable(feature = \"core\",\n                reason = \"may grow a `Reflect` bound soon via marker traits\")]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }\n     }\n-\n-    /// dox\n-    #[cfg(stage0)]\n-    pub fn of<T: 'static>() -> TypeId {\n-        unsafe { intrinsics::type_id::<T>() }\n-    }\n }"}, {"sha": "44541c34ee278fb6637a586502994b4ac716424d", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -39,11 +39,10 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"core\",\n-                       reason = \"waiting for Show to stabilize\")]\n-            impl<T:fmt::Show> fmt::Show for [T; $N] {\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Show::fmt(&&self[], f)\n+                    fmt::Debug::fmt(&&self[], f)\n                 }\n             }\n "}, {"sha": "be144b052c7867056ab49a61770531a4b1aedf46", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -134,7 +134,6 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n-#[derive(Show)]\n pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n@@ -240,14 +239,27 @@ impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwne\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n-    B: fmt::String + ToOwned<T>,\n-    T: fmt::String,\n+impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n+    B: fmt::Debug + ToOwned<T>,\n+    T: fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Borrowed(ref b) => fmt::String::fmt(b, f),\n-            Owned(ref o) => fmt::String::fmt(o, f),\n+            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n+            Owned(ref o) => fmt::Debug::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, B: ?Sized> fmt::Display for Cow<'a, T, B> where\n+    B: fmt::Display + ToOwned<T>,\n+    T: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Display::fmt(b, f),\n+            Owned(ref o) => fmt::Display::fmt(o, f),\n         }\n     }\n }"}, {"sha": "3f25432e87abb63a13f62dba674c3c7478a4e641", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -74,6 +74,10 @@\n //! }\n //! ```\n //!\n+//! Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded\n+//! scenarios. Consider using `Mutex<T>` if you need shared mutability in a multi-threaded\n+//! situation.\n+//!\n //! ## Implementation details of logically-immutable methods\n //!\n //! Occasionally it may be desirable not to expose in an API that"}, {"sha": "9519539f000495547ea86dfcbf5d4713edfd7fe8", "filename": "src/libcore/error.rs", "status": "renamed", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -14,14 +14,15 @@\n //!\n //! `Error` is a trait representing the basic expectations for error values,\n //! i.e. values of type `E` in `Result<T, E>`. At a minimum, errors must provide\n-//! a description, but they may optionally provide additional detail and cause\n-//! chain information:\n+//! a description, but they may optionally provide additional detail (via\n+//! `Display`) and cause chain information:\n //!\n //! ```\n-//! trait Error {\n+//! use std::fmt::Display;\n+//!\n+//! trait Error: Display {\n //!     fn description(&self) -> &str;\n //!\n-//!     fn detail(&self) -> Option<String> { None }\n //!     fn cause(&self) -> Option<&Error> { None }\n //! }\n //! ```\n@@ -80,21 +81,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use prelude::v1::*;\n-\n-use str::Utf8Error;\n-use string::{FromUtf8Error, FromUtf16Error};\n+use prelude::*;\n+use fmt::Display;\n \n /// Base functionality for all errors in Rust.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"core\",\n            reason = \"the exact API of this trait may change\")]\n-pub trait Error {\n+pub trait Error: Display {\n     /// A short description of the error; usually a static string.\n     fn description(&self) -> &str;\n \n-    /// A detailed description of the error, usually including dynamic information.\n-    fn detail(&self) -> Option<String> { None }\n-\n     /// The lower-level cause of this error, if any.\n     fn cause(&self) -> Option<&Error> { None }\n }\n@@ -114,26 +110,3 @@ impl<E> FromError<E> for E {\n         err\n     }\n }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for Utf8Error {\n-    fn description(&self) -> &str {\n-        match *self {\n-            Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n-            Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n-        }\n-    }\n-\n-    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for FromUtf8Error {\n-    fn description(&self) -> &str { \"invalid utf-8\" }\n-    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for FromUtf16Error {\n-    fn description(&self) -> &str { \"invalid utf-16\" }\n-}", "previous_filename": "src/libstd/error.rs"}, {"sha": "245dc00d838244cf7746107a3e7773eef1aa2cfc", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -179,7 +179,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         _ => ()\n     }\n \n-    buf.slice_to_mut(end).reverse();\n+    buf[..end].reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -316,7 +316,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             impl<'a> fmt::Writer for Filler<'a> {\n                 fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n+                    slice::bytes::copy_memory(&mut self.buf[(*self.end)..],\n                                               s.as_bytes());\n                     *self.end += s.len();\n                     Ok(())"}, {"sha": "b4e141b9bc75ec49750757231bbbddf7ea8ec51c", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 93, "deletions": 50, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -26,12 +26,15 @@ use ops::{Deref, FnOnce};\n use result;\n use slice::SliceExt;\n use slice;\n-use str::{self, StrExt, Utf8Error};\n+use str::{self, StrExt};\n \n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n+#[cfg(stage0)] pub use self::Debug as Show;\n+#[cfg(stage0)] pub use self::Display as String;\n+\n mod num;\n mod float;\n pub mod rt;\n@@ -48,7 +51,7 @@ pub type Result = result::Result<(), Error>;\n /// some other means.\n #[unstable(feature = \"core\",\n            reason = \"core and I/O reconciliation may alter this definition\")]\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub struct Error;\n \n /// A collection of methods that are required to format a message into a stream.\n@@ -138,7 +141,7 @@ pub struct Argument<'a> {\n impl<'a> Argument<'a> {\n     #[inline(never)]\n     fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n-        Show::fmt(x, f)\n+        Display::fmt(x, f)\n     }\n \n     fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> {\n@@ -221,14 +224,15 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n-impl<'a> Show for Arguments<'a> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Debug for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n-        String::fmt(self, fmt)\n+        Display::fmt(self, fmt)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> String for Arguments<'a> {\n+impl<'a> Display for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n     }\n@@ -238,20 +242,52 @@ impl<'a> String for Arguments<'a> {\n /// should implement this.\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n+#[cfg(not(stage0))]\n pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+/// Format trait for the `:?` format. Useful for debugging, most all types\n+/// should implement this.\n+#[unstable(feature = \"core\",\n+           reason = \"I/O and core have yet to be reconciled\")]\n+pub trait Debug {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+#[cfg(not(stage0))]\n+impl<T: Show + ?Sized> Debug for T {\n+    #[allow(deprecated)]\n+    fn fmt(&self, f: &mut Formatter) -> Result { Show::fmt(self, f) }\n+}\n+\n+/// When a value can be semantically expressed as a String, this trait may be\n+/// used. It corresponds to the default format, `{}`.\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n+#[cfg(not(stage0))]\n+pub trait String {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n-pub trait String {\n+pub trait Display {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+#[cfg(not(stage0))]\n+impl<T: String + ?Sized> Display for T {\n+    #[allow(deprecated)]\n+    fn fmt(&self, f: &mut Formatter) -> Result { String::fmt(self, f) }\n+}\n \n /// Format trait for the `o` character\n #[unstable(feature = \"core\",\n@@ -605,9 +641,10 @@ impl<'a> Formatter<'a> {\n     pub fn precision(&self) -> Option<uint> { self.precision }\n }\n \n-impl Show for Error {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Display for Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(\"an error occurred when formatting an argument\", f)\n+        Display::fmt(\"an error occurred when formatting an argument\", f)\n     }\n }\n \n@@ -635,32 +672,36 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n macro_rules! fmt_refs {\n     ($($tr:ident),*) => {\n         $(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T: ?Sized + $tr> $tr for &'a T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n         )*\n     }\n }\n \n-fmt_refs! { Show, String, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n+fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-impl Show for bool {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Debug for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(self, f)\n+        Display::fmt(self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl String for bool {\n+impl Display for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n     }\n }\n \n-impl Show for str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Debug for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         try!(write!(f, \"\\\"\"));\n         for c in self.chars().flat_map(|c| c.escape_default()) {\n@@ -671,13 +712,14 @@ impl Show for str {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl String for str {\n+impl Display for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n-impl Show for char {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Debug for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n         try!(write!(f, \"'\"));\n@@ -689,15 +731,16 @@ impl Show for char {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl String for char {\n+impl Display for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(&utf8[..amt]) };\n-        String::fmt(s, f)\n+        Display::fmt(s, f)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n@@ -707,18 +750,21 @@ impl<T> Pointer for *const T {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(&**self as *const T), f)\n@@ -727,15 +773,15 @@ impl<'a, T> Pointer for &'a mut T {\n \n macro_rules! floating { ($ty:ident) => {\n \n-    impl Show for $ty {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            try!(String::fmt(self, fmt));\n-            fmt.write_str(stringify!($ty))\n+            Display::fmt(self, fmt)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl String for $ty {\n+    impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n \n@@ -756,6 +802,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -777,6 +824,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -801,12 +849,14 @@ macro_rules! floating { ($ty:ident) => {\n floating! { f32 }\n floating! { f64 }\n \n-// Implementation of Show for various core types\n+// Implementation of Display/Debug for various core types\n \n-impl<T> Show for *const T {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Debug for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-impl<T> Show for *mut T {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Debug for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n \n@@ -817,7 +867,8 @@ macro_rules! peel {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        impl<$($name:Show),*> Show for ($($name,)*) {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($name:Debug),*> Debug for ($($name,)*) {\n             #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 try!(write!(f, \"(\"));\n@@ -842,11 +893,13 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl<'a> Show for &'a (any::Any+'a) {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Debug for &'a (any::Any+'a) {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n \n-impl<T: Show> Show for [T] {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n             try!(write!(f, \"[\"));\n@@ -867,20 +920,22 @@ impl<T: Show> Show for [T] {\n     }\n }\n \n-impl Show for () {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Debug for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")\n     }\n }\n \n-impl<T: Copy + Show> Show for Cell<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         write!(f, \"Cell {{ value: {:?} }}\", self.get())\n     }\n }\n \n-#[unstable(feature = \"core\")]\n-impl<T: Show> Show for RefCell<T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.try_borrow() {\n             Some(val) => write!(f, \"RefCell {{ value: {:?} }}\", val),\n@@ -889,29 +944,17 @@ impl<T: Show> Show for RefCell<T> {\n     }\n }\n \n-impl<'b, T: Show> Show for Ref<'b, T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        Show::fmt(&**self, f)\n-    }\n-}\n-\n-impl<'b, T: Show> Show for RefMut<'b, T> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'b, T: Debug> Debug for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        Show::fmt(&*(self.deref()), f)\n+        Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl String for Utf8Error {\n+impl<'b, T: Debug> Debug for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            Utf8Error::InvalidByte(n) => {\n-                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n-            }\n-            Utf8Error::TooShort => {\n-                write!(f, \"invalid utf-8: byte slice too short\")\n-            }\n-        }\n+        Debug::fmt(&*(self.deref()), f)\n     }\n }\n "}, {"sha": "47da8d0c419b4cd47de1c666bc1ab759631e9471", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -157,13 +157,14 @@ pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n \n macro_rules! radix_fmt {\n     ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n-        impl fmt::Show for RadixFmt<$T, Radix> {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::Debug for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                try!(fmt::String::fmt(self, f));\n-                f.write_str($S)\n+                fmt::Display::fmt(self, f)\n             }\n         }\n-        impl fmt::String for RadixFmt<$T, Radix> {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::Display for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n             }\n@@ -172,6 +173,7 @@ macro_rules! radix_fmt {\n }\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl fmt::$Trait for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 $Radix.fmt_int(*self as $U, f)\n@@ -182,10 +184,10 @@ macro_rules! int_base {\n \n macro_rules! show {\n     ($T:ident with $S:expr) => {\n-        impl fmt::Show for $T {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::Debug for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                try!(fmt::String::fmt(self, f));\n-                f.write_str($S)\n+                fmt::Display::fmt(self, f)\n             }\n         }\n     }\n@@ -195,15 +197,15 @@ macro_rules! integer {\n         integer! { $Int, $Uint, stringify!($Int), stringify!($Uint) }\n     };\n     ($Int:ident, $Uint:ident, $SI:expr, $SU:expr) => {\n-        int_base! { String   for $Int as $Int   -> Decimal }\n+        int_base! { Display  for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n         radix_fmt! { $Int as $Int, fmt_int, $SI }\n         show! { $Int with $SI }\n \n-        int_base! { String   for $Uint as $Uint -> Decimal }\n+        int_base! { Display  for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }"}, {"sha": "dd6b1e7b4e8325d4c025a455e85f79bbc19fbc35", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -44,8 +44,6 @@\n \n use marker::Sized;\n \n-#[cfg(stage0)] use any::TypeId;\n-\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n@@ -208,12 +206,8 @@ extern \"rust-intrinsic\" {\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n-    #[cfg(not(stage0))]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n-    #[cfg(stage0)]\n-    pub fn type_id<T: ?Sized + 'static>() -> TypeId;\n-\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "8289c7403d29f01ad1d569f97f25b4ec12c5df90", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 355, "deletions": 270, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -32,7 +32,7 @@\n //! into a `loop`, for example, the `for` loop in this example is essentially\n //! translated to the `loop` below.\n //!\n-//! ```rust\n+//! ```\n //! let values = vec![1i, 2, 3];\n //!\n //! // \"Syntactical sugar\" taking advantage of an iterator\n@@ -68,7 +68,7 @@ use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n use std::marker::Sized;\n-use uint;\n+use usize;\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n@@ -93,10 +93,24 @@ pub trait Iterator {\n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n-    /// does not fit within a `uint`.\n+    /// does not fit within a `usize`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n+}\n+\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#[old_impl_check]\n+impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        (**self).next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n }\n \n /// Conversion from an `Iterator`\n@@ -121,26 +135,25 @@ pub trait Extend<A> {\n pub trait IteratorExt: Iterator + Sized {\n     /// Counts the number of elements in this iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.count() == 5);\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn count(self) -> uint {\n+    fn count(self) -> usize {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n \n     /// Loops through the entire iterator, returning the last element of the\n     /// iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n@@ -154,17 +167,17 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.nth(2).unwrap() == &3);\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn nth(&mut self, mut n: uint) -> Option<Self::Item> {\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n             n -= 1;\n@@ -176,11 +189,11 @@ pub trait IteratorExt: Iterator + Sized {\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [0i];\n-    /// let b = [1i];\n+    /// ```\n+    /// let a = [0];\n+    /// let b = [1];\n     /// let mut it = a.iter().chain(b.iter());\n     /// assert_eq!(it.next().unwrap(), &0);\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -199,14 +212,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// either iterator returns None, all further invocations of next() will\n     /// return None.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [0i];\n-    /// let b = [1i];\n+    /// ```\n+    /// let a = [0];\n+    /// let b = [1];\n     /// let mut it = a.iter().zip(b.iter());\n-    /// let (x0, x1) = (0i, 1i);\n-    /// assert_eq!(it.next().unwrap(), (&x0, &x1));\n+    /// assert_eq!(it.next().unwrap(), (&0, &1));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -220,10 +232,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates a new iterator that will apply the specified function to each\n     /// element returned by the first, yielding the mapped element instead.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2];\n+    /// ```\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().map(|&x| 2 * x);\n     /// assert_eq!(it.next().unwrap(), 2);\n     /// assert_eq!(it.next().unwrap(), 4);\n@@ -238,13 +250,13 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Creates an iterator that applies the predicate to each element returned\n-    /// by this iterator. Only elements that have the predicate evaluate to\n-    /// `true` will be yielded.\n+    /// by this iterator. The only elements that will be yieled are those that\n+    /// make the predicate evaluate to `true`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2];\n+    /// ```\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().filter(|&x| *x > 1);\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// assert!(it.next().is_none());\n@@ -261,10 +273,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// If the specified function returns None, the element is skipped.\n     /// Otherwise the option is unwrapped and the new value is yielded.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2];\n+    /// ```\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n     /// assert_eq!(it.next().unwrap(), 4);\n     /// assert!(it.next().is_none());\n@@ -280,14 +292,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that yields a pair of the value returned by this\n     /// iterator plus the current index of iteration.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [100i, 200];\n+    /// ```\n+    /// let a = [100, 200];\n     /// let mut it = a.iter().enumerate();\n-    /// let (x100, x200) = (100i, 200i);\n-    /// assert_eq!(it.next().unwrap(), (0, &x100));\n-    /// assert_eq!(it.next().unwrap(), (1, &x200));\n+    /// assert_eq!(it.next().unwrap(), (0, &100));\n+    /// assert_eq!(it.next().unwrap(), (1, &200));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -299,10 +310,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that has a `.peek()` method\n     /// that returns an optional reference to the next element.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let xs = [100i, 200, 300];\n+    /// ```\n+    /// let xs = [100, 200, 300];\n     /// let mut it = xs.iter().map(|x| *x).peekable();\n     /// assert_eq!(*it.peek().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 100);\n@@ -323,14 +334,14 @@ pub trait IteratorExt: Iterator + Sized {\n     /// until it returns false. Once the predicate returns false, that\n     /// element and all further elements are yielded.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 2, 1];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &3);\n-    /// assert_eq!(it.next().unwrap(), &2);\n-    /// assert_eq!(it.next().unwrap(), &1);\n+    /// assert_eq!(it.next().unwrap(), &4);\n+    /// assert_eq!(it.next().unwrap(), &5);\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -345,10 +356,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// returns true. After the predicate returns false for the first time, no\n     /// further elements will be yielded.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 2, 1];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -365,28 +376,28 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Creates an iterator that skips the first `n` elements of this iterator,\n     /// and then yields all further items.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip(3);\n     /// assert_eq!(it.next().unwrap(), &4);\n     /// assert_eq!(it.next().unwrap(), &5);\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn skip(self, n: uint) -> Skip<Self> {\n+    fn skip(self, n: usize) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n \n     /// Creates an iterator that yields the first `n` elements of this\n-    /// iterator, and then will always return None.\n+    /// iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take(3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -395,7 +406,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take(self, n: uint) -> Take<Self> {\n+    fn take(self, n: usize) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n \n@@ -404,10 +415,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// mutated as necessary. The yielded values from the closure are yielded\n     /// from the Scan instance when not None.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().scan(1, |fac, &x| {\n     ///   *fac = *fac * x;\n     ///   Some(*fac)\n@@ -432,21 +443,17 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Creates an iterator that maps each element to an iterator,\n-    /// and yields the elements of the produced iterators\n-    ///\n-    /// # Example\n+    /// and yields the elements of the produced iterators.\n     ///\n-    /// ```rust\n-    /// use std::iter::count;\n+    /// # Examples\n     ///\n-    /// let xs = [2u, 3];\n-    /// let ys = [0u, 1, 0, 1, 2];\n-    /// let mut it = xs.iter().flat_map(|&x| count(0u, 1).take(x));\n+    /// ```\n+    /// let xs = [2, 3];\n+    /// let ys = [0, 1, 0, 1, 2];\n+    /// let it = xs.iter().flat_map(|&x| std::iter::count(0, 1).take(x));\n     /// // Check that `it` has the same elements as `ys`\n-    /// let mut i = 0;\n-    /// for x in it {\n+    /// for (i, x) in it.enumerate() {\n     ///     assert_eq!(x, ys[i]);\n-    ///     i += 1;\n     /// }\n     /// ```\n     #[inline]\n@@ -462,10 +469,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// iterator yields `None`. Random-access iterator behavior is not\n     /// affected, only single and double-ended iterator behavior.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// fn process<U: Iterator<Item=int>>(it: U) -> int {\n+    /// ```\n+    /// fn process<U: Iterator<Item=isize>>(it: U) -> isize {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n     ///     for x in it {\n@@ -480,9 +487,9 @@ pub trait IteratorExt: Iterator + Sized {\n     ///     }\n     ///     sum\n     /// }\n-    /// let x = vec![1i,2,3,7,8,9];\n+    /// let x = vec![1, 2, 3, 7, 8, 9];\n     /// assert_eq!(process(x.into_iter()), 6);\n-    /// let x = vec![1i,2,3];\n+    /// let x = vec![1, 2, 3];\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n@@ -495,13 +502,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// element before yielding it. This is often useful for debugging an\n     /// iterator pipeline.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::AdditiveIterator;\n     ///\n-    /// let xs = [1u, 4, 2, 3, 8, 9, 6];\n-    /// let sum = xs.iter()\n+    /// let a = [1, 4, 2, 3, 8, 9, 6];\n+    /// let sum = a.iter()\n     ///             .map(|&x| x)\n     ///             .inspect(|&x| println!(\"filtering {}\", x))\n     ///             .filter(|&x| x % 2 == 0)\n@@ -522,15 +529,14 @@ pub trait IteratorExt: Iterator + Sized {\n     /// This is useful to allow applying iterator adaptors while still\n     /// retaining ownership of the original iterator value.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let mut xs = range(0u, 10);\n+    /// ```\n+    /// let mut it = 0..10;\n     /// // sum the first five values\n-    /// let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n+    /// let partial_sum = it.by_ref().take(5).fold(0, |a, b| a + b);\n     /// assert!(partial_sum == 10);\n-    /// // xs.next() is now `5`\n-    /// assert!(xs.next() == Some(5));\n+    /// assert!(it.next() == Some(5));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n@@ -540,12 +546,12 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let b: Vec<int> = a.iter().map(|&x| x).collect();\n-    /// assert!(a.as_slice() == b.as_slice());\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let b: Vec<_> = a.iter().map(|&x| x).collect();\n+    /// assert_eq!(a, b);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -559,8 +565,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// do not.\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2i, 3i, 4i];\n-    /// let (even, odd): (Vec<int>, Vec<int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n+    /// let vec = vec![1, 2, 3, 4];\n+    /// let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&n| n % 2 == 0);\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n@@ -587,10 +593,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n@@ -607,9 +613,9 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().all(|x| *x > 0));\n     /// assert!(!a.iter().all(|x| *x > 2));\n@@ -621,16 +627,18 @@ pub trait IteratorExt: Iterator + Sized {\n         true\n     }\n \n-    /// Tests whether any element of an iterator satisfies the specified\n-    /// predicate.\n+    /// Tests whether any element of an iterator satisfies the specified predicate.\n     ///\n-    /// # Example\n+    /// Does not consume the iterator past the first found element.\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n-    /// assert!(!it.any(|x| *x == 3));\n+    /// assert_eq!(it.as_slice(), [4, 5]);\n+    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -642,6 +650,14 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Returns the first element satisfying the specified predicate.\n     ///\n     /// Does not consume the iterator past the first found element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n+    /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n@@ -654,9 +670,19 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Return the index of the first element satisfying the specified predicate\n+    ///\n+    /// Does not consume the iterator past the first found element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n+    /// assert_eq!(it.as_slice(), [4, 5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n+    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n     {\n         let mut i = 0;\n@@ -672,9 +698,19 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Return the index of the last element satisfying the specified predicate\n     ///\n     /// If no element matches, None is returned.\n+    ///\n+    /// Does not consume the iterator *before* the first found element.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 2, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n+    /// assert_eq!(it.as_slice(), [1, 2]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n@@ -689,10 +725,10 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Consumes the entire iterator to return the maximum element.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     #[inline]\n@@ -709,10 +745,10 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Consumes the entire iterator to return the minimum element.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// ```\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     #[inline]\n@@ -740,25 +776,22 @@ pub trait IteratorExt: Iterator + Sized {\n     /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n     /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n     ///\n-    /// let v: [int; 0] = [];\n-    /// assert_eq!(v.iter().min_max(), NoElements);\n+    /// let a: [isize; 0] = [];\n+    /// assert_eq!(a.iter().min_max(), NoElements);\n     ///\n-    /// let v = [1i];\n-    /// assert!(v.iter().min_max() == OneElement(&1));\n+    /// let a = [1];\n+    /// assert!(a.iter().min_max() == OneElement(&1));\n     ///\n-    /// let v = [1i, 2, 3, 4, 5];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// assert!(a.iter().min_max() == MinMax(&1, &5));\n     ///\n-    /// let v = [1i, 2, 3, 4, 5, 6];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n-    ///\n-    /// let v = [1i, 1, 1, 1];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n+    /// let a = [1, 1, 1, 1];\n+    /// assert!(a.iter().min_max() == MinMax(&1, &1));\n     /// ```\n     #[unstable(feature = \"core\", reason = \"return type may change\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n@@ -808,13 +841,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Return the element that gives the maximum value from the\n     /// specified function.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use core::num::SignedInt;\n     ///\n-    /// let xs = [-3i, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n+    /// let a = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"core\",\n@@ -838,13 +871,13 @@ pub trait IteratorExt: Iterator + Sized {\n     /// Return the element that gives the minimum value from the\n     /// specified function.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use core::num::SignedInt;\n     ///\n-    /// let xs = [-3i, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n+    /// let a = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"core\",\n@@ -876,7 +909,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// of the original iterator.\n     ///\n     /// Note: Random access with flipped indices still only applies to the first\n-    /// `uint::MAX` elements of the original iterator.\n+    /// `std::usize::MAX` elements of the original iterator.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> {\n@@ -887,18 +920,27 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let a = [(1, 2), (3, 4)];\n+    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().map(|&x| x).unzip();\n+    /// assert_eq!([1, 3], left);\n+    /// assert_eq!([2, 4], right);\n+    /// ```\n     #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n         Self: Iterator<Item=(A, B)>,\n     {\n-        struct SizeHint<A>(uint, Option<uint>);\n+        struct SizeHint<A>(usize, Option<usize>);\n         impl<A> Iterator for SizeHint<A> {\n             type Item = A;\n \n             fn next(&mut self) -> Option<A> { None }\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 (self.0, self.1)\n             }\n         }\n@@ -931,15 +973,14 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Repeats an iterator endlessly\n     ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::count;\n+    /// # Examples\n     ///\n-    /// let a = count(1i,1i).take(1);\n-    /// let mut cy = a.cycle();\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// assert_eq!(cy.next(), Some(1));\n+    /// ```\n+    /// let a = [1, 2];\n+    /// let mut it = a.iter().cycle();\n+    /// assert_eq!(it.next().unwrap(), &1);\n+    /// assert_eq!(it.next().unwrap(), &2);\n+    /// assert_eq!(it.next().unwrap(), &1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -976,7 +1017,7 @@ pub trait DoubleEndedIterator: Iterator {\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n-/// An object implementing random access indexing by `uint`\n+/// An object implementing random access indexing by `usize`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n@@ -985,12 +1026,12 @@ pub trait DoubleEndedIterator: Iterator {\n #[unstable(feature = \"core\",\n            reason = \"not widely used, may be better decomposed into Index and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n-    /// Return the number of indexable elements. At most `std::uint::MAX`\n+    /// Return the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n-    fn indexable(&self) -> uint;\n+    fn indexable(&self) -> usize;\n \n     /// Return an element at an index, or `None` if the index is out of bounds\n-    fn idx(&mut self, index: uint) -> Option<Self::Item>;\n+    fn idx(&mut self, index: usize) -> Option<Self::Item>;\n }\n \n /// An iterator that knows its exact length\n@@ -999,12 +1040,12 @@ pub trait RandomAccessIterator: Iterator {\n /// it can support double-ended enumeration.\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n-/// Note that the size must fit in `uint`.\n+/// Note that the size must fit in `usize`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         let (lower, upper) = self.size_hint();\n         // Note: This assertion is overly defensive, but it checks the invariant\n         // guaranteed by the trait. If this trait were rust-internal,\n@@ -1049,7 +1090,7 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1061,9 +1102,9 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n-    fn indexable(&self) -> uint { self.iter.indexable() }\n+    fn indexable(&self) -> usize { self.iter.indexable() }\n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         let amt = self.indexable();\n         self.iter.idx(amt - index - 1)\n     }\n@@ -1083,7 +1124,7 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1092,15 +1133,18 @@ impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterat\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I> ExactSizeIterator for ByRef<'a, I> where I: 'a + ExactSizeIterator {}\n+\n /// A trait for iterators over elements which can be added together\n #[unstable(feature = \"core\",\n            reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::AdditiveIterator;\n     ///\n     /// let a = [1i, 2, 3, 4, 5];\n@@ -1125,12 +1169,12 @@ impl_additive! { i8,   0 }\n impl_additive! { i16,  0 }\n impl_additive! { i32,  0 }\n impl_additive! { i64,  0 }\n-impl_additive! { int,  0 }\n+impl_additive! { isize,  0 }\n impl_additive! { u8,   0 }\n impl_additive! { u16,  0 }\n impl_additive! { u32,  0 }\n impl_additive! { u64,  0 }\n-impl_additive! { uint, 0 }\n+impl_additive! { usize, 0 }\n impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n@@ -1140,12 +1184,12 @@ impl_additive! { f64,  0.0 }\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::{count, MultiplicativeIterator};\n     ///\n-    /// fn factorial(n: uint) -> uint {\n+    /// fn factorial(n: usize) -> usize {\n     ///     count(1u, 1).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n@@ -1170,12 +1214,12 @@ impl_multiplicative! { i8,   1 }\n impl_multiplicative! { i16,  1 }\n impl_multiplicative! { i32,  1 }\n impl_multiplicative! { i64,  1 }\n-impl_multiplicative! { int,  1 }\n+impl_multiplicative! { isize,  1 }\n impl_multiplicative! { u8,   1 }\n impl_multiplicative! { u16,  1 }\n impl_multiplicative! { u32,  1 }\n impl_multiplicative! { u64,  1 }\n-impl_multiplicative! { uint, 1 }\n+impl_multiplicative! { usize, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n@@ -1200,19 +1244,19 @@ impl<T: Clone> MinMaxResult<T> {\n     /// `Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\n     /// performing this operation will make one clone of `x`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::iter::MinMaxResult::{self, NoElements, OneElement, MinMax};\n     ///\n-    /// let r: MinMaxResult<int> = NoElements;\n+    /// let r: MinMaxResult<isize> = NoElements;\n     /// assert_eq!(r.into_option(), None);\n     ///\n-    /// let r = OneElement(1i);\n-    /// assert_eq!(r.into_option(), Some((1,1)));\n+    /// let r = OneElement(1);\n+    /// assert_eq!(r.into_option(), Some((1, 1)));\n     ///\n-    /// let r = MinMax(1i,2i);\n-    /// assert_eq!(r.into_option(), Some((1,2)));\n+    /// let r = MinMax(1, 2);\n+    /// assert_eq!(r.into_option(), Some((1, 2)));\n     /// ```\n     #[unstable(feature = \"core\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n@@ -1244,7 +1288,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n         self.it.next().cloned()\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.it.size_hint()\n     }\n }\n@@ -1289,12 +1333,12 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // the cycle iterator is either empty or infinite\n         match self.orig.size_hint() {\n             sz @ (0, Some(0)) => sz,\n             (0, _) => (0, None),\n-            _ => (uint::MAX, None)\n+            _ => (usize::MAX, None)\n         }\n     }\n }\n@@ -1304,16 +1348,16 @@ impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         if self.orig.indexable() > 0 {\n-            uint::MAX\n+            usize::MAX\n         } else {\n             0\n         }\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         let liter = self.iter.indexable();\n         let lorig = self.orig.indexable();\n         if lorig == 0 {\n@@ -1355,7 +1399,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n@@ -1390,13 +1434,13 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     B: RandomAccessIterator<Item=T>,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         let (a, b) = (self.a.indexable(), self.b.indexable());\n         a.saturating_add(b)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<T> {\n+    fn idx(&mut self, index: usize) -> Option<T> {\n         let len = self.a.indexable();\n         if index < len {\n             self.a.idx(index)\n@@ -1434,7 +1478,7 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n@@ -1482,12 +1526,12 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     B: RandomAccessIterator<Item=U>,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         cmp::min(self.a.indexable(), self.b.indexable())\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(T, U)> {\n+    fn idx(&mut self, index: usize) -> Option<(T, U)> {\n         match self.a.idx(index) {\n             None => None,\n             Some(x) => match self.b.idx(index) {\n@@ -1541,7 +1585,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n@@ -1564,12 +1608,12 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     F: FnMut(A) -> B,\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<B> {\n+    fn idx(&mut self, index: usize) -> Option<B> {\n         let elt = self.iter.idx(index);\n         self.do_map(elt)\n     }\n@@ -1614,7 +1658,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1677,7 +1721,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1706,15 +1750,15 @@ impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n-    count: uint\n+    count: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n-    type Item = (uint, <I as Iterator>::Item);\n+    type Item = (usize, <I as Iterator>::Item);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         match self.iter.next() {\n             Some(a) => {\n                 let ret = Some((self.count, a));\n@@ -1726,7 +1770,7 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n@@ -1736,7 +1780,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     I: ExactSizeIterator + DoubleEndedIterator\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n             Some(a) => {\n                 let len = self.iter.len();\n@@ -1750,12 +1794,12 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(uint, <I as Iterator>::Item)> {\n+    fn idx(&mut self, index: usize) -> Option<(usize, <I as Iterator>::Item)> {\n         match self.iter.idx(index) {\n             Some(a) => Some((self.count + index, a)),\n             _ => None,\n@@ -1783,7 +1827,7 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.iter.size_hint();\n         if self.peeked.is_some() {\n             let lo = lo.saturating_add(1);\n@@ -1798,6 +1842,9 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, I> ExactSizeIterator for Peekable<T, I> where I: ExactSizeIterator<Item = T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n@@ -1860,7 +1907,7 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1914,7 +1961,7 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n@@ -1926,7 +1973,7 @@ impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Skip<I> {\n     iter: I,\n-    n: uint\n+    n: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1959,7 +2006,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = lower.saturating_sub(self.n);\n@@ -1976,12 +2023,12 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable().saturating_sub(self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1990,13 +2037,16 @@ impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n /// An iterator that only iterates over the first `n` iterations of `iter`.\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<I> {\n     iter: I,\n-    n: uint\n+    n: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2014,7 +2064,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = cmp::min(lower, self.n);\n@@ -2031,12 +2081,12 @@ impl<I> Iterator for Take<I> where I: Iterator{\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         cmp::min(self.iter.indexable(), self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         if index >= self.n {\n             None\n         } else {\n@@ -2045,6 +2095,9 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -2086,7 +2139,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the scan function\n     }\n@@ -2149,7 +2202,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n         let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n         let lo = flo.saturating_add(blo);\n@@ -2213,7 +2266,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.done {\n             (0, Some(0))\n         } else {\n@@ -2244,16 +2297,19 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<<I as Iterator>::Item> {\n+    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         self.iter.idx(index)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n+\n impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n@@ -2310,7 +2366,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n@@ -2333,12 +2389,12 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     F: FnMut(&A),\n {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: usize) -> Option<A> {\n         let element = self.iter.idx(index);\n         self.do_inspect(element)\n     }\n@@ -2350,7 +2406,7 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n-/// ```rust\n+/// ```\n /// use std::iter::Unfold;\n /// use std::num::Int; // For `.checked_add()`\n ///\n@@ -2420,7 +2476,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // no possible known bounds at this point\n         (0, None)\n     }\n@@ -2458,8 +2514,8 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (uint::MAX, None) // Too bad we can't specify an infinite lower bound\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None) // Too bad we can't specify an infinite lower bound\n     }\n }\n \n@@ -2476,9 +2532,9 @@ pub struct Range<A> {\n /// Returns an iterator over the given range [start, stop) (that is, starting\n /// at start (inclusive), and ending at stop (exclusive)).\n ///\n-/// # Example\n+/// # Examples\n ///\n-/// ```rust\n+/// ```\n /// let array = [0, 1, 2, 3, 4];\n ///\n /// for i in range(0, 5u) {\n@@ -2515,9 +2571,9 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // This first checks if the elements are representable as i64. If they aren't, try u64 (to\n-        // handle cases like range(huge, huger)). We don't use uint/int because the difference of\n+        // handle cases like range(huge, huger)). We don't use usize/isize because the difference of\n         // the i64/u64 might lie within their range.\n         let bound = match self.state.to_i64() {\n             Some(a) => {\n@@ -2604,7 +2660,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.range.size_hint();\n         if self.done {\n             (lo, hi)\n@@ -2725,64 +2781,93 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n     }\n }\n \n-\n-/// The `Step` trait identifies objects which can be stepped over in both\n-/// directions. The `steps_between` function provides a way to\n-/// compare two Step objects (it could be provided using `step()` and `Ord`,\n-/// but the implementation would be so inefficient as to be useless).\n-#[unstable(feature = \"core\",\n-           reason = \"design of range notation/iteration is in flux\")]\n-pub trait Step: Ord {\n-    /// Change self to the next object.\n-    fn step(&mut self);\n-    /// Change self to the previous object.\n-    fn step_back(&mut self);\n-    /// The steps_between two step objects.\n-    /// start should always be less than end, so the result should never be negative.\n-    /// Return None if it is not possible to calculate steps_between without\n-    /// overflow.\n-    fn steps_between(start: &Self, end: &Self) -> Option<uint>;\n-}\n-\n-macro_rules! step_impl {\n+macro_rules! range_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"core\", reason = \"Trait is unstable.\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn step(&mut self) { *self += 1; }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+\n             #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<uint> {\n-                debug_assert!(end >= start);\n-                Some((*end - *start) as uint)\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                debug_assert!(self.end >= self.start);\n+                let hint = (self.end - self.start) as usize;\n+                (hint, Some(hint))\n             }\n         }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n-macro_rules! step_impl_no_between {\n+macro_rules! range_impl_no_hint {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"core\", reason = \"Trait is unstable.\")]\n-        impl Step for $t {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn step(&mut self) { *self += 1; }\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! range_other_impls {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl DoubleEndedIterator for ::ops::Range<$t> {\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next_back(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    self.end -= 1;\n+                    return Some(self.end);\n+                }\n+\n+                return None;\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Iterator for ::ops::RangeFrom<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn steps_between(_start: &$t, _end: &$t) -> Option<uint> {\n-                None\n+            fn next(&mut self) -> Option<$t> {\n+                let result = self.start;\n+                self.start += 1;\n+                debug_assert!(result < self.start);\n+                return Some(result);\n             }\n         }\n     )*)\n }\n \n-step_impl!(uint u8 u16 u32 int i8 i16 i32);\n+range_impl!(usize u8 u16 u32 isize i8 i16 i32);\n #[cfg(target_pointer_width = \"64\")]\n-step_impl!(u64 i64);\n+range_impl!(u64 i64);\n #[cfg(target_pointer_width = \"32\")]\n-step_impl_no_between!(u64 i64);\n+range_impl_no_hint!(u64 i64);\n \n+range_other_impls!(usize u8 u16 u32 u64 isize i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]\n@@ -2798,7 +2883,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.idx(0) }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2810,9 +2895,9 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n-    fn indexable(&self) -> uint { uint::MAX }\n+    fn indexable(&self) -> usize { usize::MAX }\n     #[inline]\n-    fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }\n+    fn idx(&mut self, _: usize) -> Option<A> { Some(self.element.clone()) }\n }\n \n type IterateState<T, F> = (F, Option<T>, bool);"}, {"sha": "d4ca5e3f8dcb59412edf41546a970c773afdb933", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -64,6 +64,8 @@\n #![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(on_unimplemented)]\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#![feature(old_impl_check)]\n #![deny(missing_docs)]\n \n #[macro_use]\n@@ -137,6 +139,7 @@ pub mod slice;\n pub mod str;\n pub mod hash;\n pub mod fmt;\n+pub mod error;\n \n // note: does not need to be public\n mod tuple;"}, {"sha": "0a31cb01ca28f79dca7f9d1f389cdd5e638f442f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -386,17 +386,6 @@ pub struct ContravariantLifetime<'a>;\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantLifetime<'a>;\n \n-/// A type which is considered \"not sendable\", meaning that it cannot\n-/// be safely sent between tasks, even if it is owned. This is\n-/// typically embedded in other types, such as `Gc`, to ensure that\n-/// their instances remain thread-local.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"no_send_bound\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-pub struct NoSend;\n-\n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n@@ -407,16 +396,6 @@ pub struct NoSend;\n #[allow(missing_copy_implementations)]\n pub struct NoCopy;\n \n-/// A type which is considered \"not sync\", meaning that\n-/// its contents are not threadsafe, hence they cannot be\n-/// shared between tasks.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"no_sync_bound\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-pub struct NoSync;\n-\n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n #[unstable(feature = \"core\","}, {"sha": "d482888e3bc8ca9608e526a566cfc6b50eb20f23", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 17, "deletions": 98, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -33,8 +33,6 @@\n //! demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n-//! #![feature(associated_types)]\n-//!\n //! use std::ops::{Add, Sub};\n //!\n //! #[derive(Show)]\n@@ -69,10 +67,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use clone::Clone;\n-use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use marker::Sized;\n-use option::Option::{self, Some, None};\n use fmt;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -168,8 +163,6 @@ macro_rules! forward_ref_binop {\n /// calling `add`, and therefore, `main` prints `Adding!`.\n ///\n /// ```rust\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Add;\n ///\n /// #[derive(Copy)]\n@@ -223,8 +216,6 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `sub`, and therefore, `main` prints `Subtracting!`.\n ///\n /// ```rust\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Sub;\n ///\n /// #[derive(Copy)]\n@@ -278,8 +269,6 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `mul`, and therefore, `main` prints `Multiplying!`.\n ///\n /// ```rust\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Mul;\n ///\n /// #[derive(Copy)]\n@@ -333,8 +322,6 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `div`, and therefore, `main` prints `Dividing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Div;\n ///\n /// #[derive(Copy)]\n@@ -388,8 +375,6 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Rem;\n ///\n /// #[derive(Copy)]\n@@ -462,8 +447,6 @@ rem_float_impl! { f64, fmod }\n /// `neg`, and therefore, `main` prints `Negating!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Neg;\n ///\n /// struct Foo;\n@@ -541,8 +524,6 @@ neg_uint_impl! { u64, i64 }\n /// `not`, and therefore, `main` prints `Not-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Not;\n ///\n /// struct Foo;\n@@ -597,8 +578,6 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::BitAnd;\n ///\n /// #[derive(Copy)]\n@@ -652,8 +631,6 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::BitOr;\n ///\n /// #[derive(Copy)]\n@@ -707,8 +684,6 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::BitXor;\n ///\n /// #[derive(Copy)]\n@@ -762,8 +737,6 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shl`, and therefore, `main` prints `Shifting left!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Shl;\n ///\n /// #[derive(Copy)]\n@@ -835,8 +808,6 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// calling `shr`, and therefore, `main` prints `Shifting right!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Shr;\n ///\n /// #[derive(Copy)]\n@@ -928,10 +899,12 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"index\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n }\n \n@@ -964,80 +937,41 @@ pub trait Index<Index: ?Sized> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason  = \"may be renamed to RangeFull\")]\n pub struct FullRange;\n \n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl fmt::Show for FullRange {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(\"..\", fmt)\n+        fmt::Debug::fmt(\"..\", fmt)\n     }\n }\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: Clone + Step> Iterator for Range<Idx> {\n-    type Item = Idx;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            let result = self.start.clone();\n-            self.start.step();\n-            return Some(result);\n-        }\n-\n-        return None;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if let Some(hint) = Step::steps_between(&self.start, &self.end) {\n-            (hint, Some(hint))\n-        } else {\n-            (0, None)\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            self.end.step_back();\n-            return Some(self.end.clone());\n-        }\n-\n-        return None;\n-    }\n-}\n-\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n-\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n     }\n@@ -1046,27 +980,16 @@ impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n-    type Item = Idx;\n \n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        // Deliberately overflow so we loop forever.\n-        let result = self.start.clone();\n-        self.start.step();\n-        return Some(result);\n-    }\n-}\n \n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n     }\n@@ -1075,14 +998,14 @@ impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"core\", reason = \"API still in development\")]\n-impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)\n     }\n@@ -1098,8 +1021,6 @@ impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n /// struct.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Deref;\n ///\n /// struct DerefExample<T> {\n@@ -1153,8 +1074,6 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// struct.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::{Deref, DerefMut};\n ///\n /// struct DerefMutExample<T> {"}, {"sha": "3441512e5529b4faad9cb41e27966b5006ae6a3f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -229,7 +229,7 @@\n use self::Result::{Ok, Err};\n \n use clone::Clone;\n-use fmt::Show;\n+use fmt::Display;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -715,7 +715,7 @@ impl<T, E> Result<T, E> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, E: Show> Result<T, E> {\n+impl<T, E: Display> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n     /// # Panics\n@@ -740,13 +740,13 @@ impl<T, E: Show> Result<T, E> {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n-                panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", e)\n+                panic!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Show, E> Result<T, E> {\n+impl<T: Display, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n     /// # Panics\n@@ -770,7 +770,7 @@ impl<T: Show, E> Result<T, E> {\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n-                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {:?}\", t),\n+                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n             Err(e) => e\n         }\n     }"}, {"sha": "2b682111781a5708244590807fdbe192e9abc897", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -67,9 +67,6 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n     fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n     fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n@@ -93,9 +90,6 @@ pub trait SliceExt {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n@@ -135,28 +129,6 @@ pub trait SliceExt {\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &[T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                data: self.as_ptr().offset(start as int),\n-                len: (end - start)\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &[T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &[T] {\n-        self.slice(0, end)\n-    }\n-\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n         (&self[..mid], &self[mid..])\n@@ -240,7 +212,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        &self[..(self.len() - 1)]\n+        &self[..self.len() - 1]\n     }\n \n     #[inline]\n@@ -291,20 +263,6 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::Range { start: start, end: end } )\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeFrom { start: start } )\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeTo { end: end } )\n-    }\n-\n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -345,13 +303,13 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn tail_mut(&mut self) -> &mut [T] {\n-        self.slice_from_mut(1)\n+        &mut self[1 ..]\n     }\n \n     #[inline]\n     fn init_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n-        self.slice_to_mut(len-1)\n+        &mut self[.. (len - 1)]\n     }\n \n     #[inline]\n@@ -449,7 +407,7 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == &self[(m-n)..]\n+        m >= n && needle == &self[m-n..]\n     }\n \n     #[unstable(feature = \"core\")]\n@@ -483,7 +441,7 @@ impl<T> SliceExt for [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         true\n     }\n@@ -505,7 +463,7 @@ impl<T> SliceExt for [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -522,15 +480,16 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n-        let dst = self.slice_to_mut(min);\n-        let src = src.slice_to(min);\n+        let dst = &mut self[.. min];\n+        let src = &src[.. min];\n         for i in range(0, min) {\n             dst[i].clone_from(&src[i]);\n         }\n         min\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<uint> for [T] {\n     type Output = T;\n \n@@ -541,6 +500,7 @@ impl<T> ops::Index<uint> for [T] {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<uint> for [T] {\n     type Output = T;\n \n@@ -551,6 +511,7 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -565,20 +526,23 @@ impl<T> ops::Index<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -587,6 +551,7 @@ impl<T> ops::Index<ops::FullRange> for [T] {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -601,13 +566,15 @@ impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -616,6 +583,7 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -974,7 +942,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n             None => self.finish(),\n             Some(idx) => {\n                 let ret = Some(&self.v[..idx]);\n-                self.v = &self.v[(idx + 1)..];\n+                self.v = &self.v[idx + 1..];\n                 ret\n             }\n         }\n@@ -999,7 +967,7 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(&self.v[(idx + 1)..]);\n+                let ret = Some(&self.v[idx + 1..]);\n                 self.v = &self.v[..idx];\n                 ret\n             }\n@@ -1052,7 +1020,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail.slice_from_mut(1);\n+                self.v = &mut tail[1..];\n                 Some(head)\n             }\n         }\n@@ -1088,7 +1056,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.slice_from_mut(1))\n+                Some(&mut tail[1..])\n             }\n         }\n     }\n@@ -1270,6 +1238,9 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n+\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n@@ -1348,6 +1319,8 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n //\n // Free functions"}, {"sha": "92c5de937cc001db0fb92524af69c48d183298ec", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 98, "deletions": 44, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -20,8 +20,10 @@ use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n use cmp::{self, Eq};\n use default::Default;\n-use iter::range;\n+use error::Error;\n+use fmt;\n use iter::ExactSizeIterator;\n+use iter::range;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n@@ -247,6 +249,30 @@ impl<'a> CharEq for &'a [char] {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for Utf8Error {\n+    fn description(&self) -> &str {\n+        match *self {\n+            Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n+            Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for Utf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Utf8Error::InvalidByte(n) => {\n+                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n+            }\n+            Utf8Error::TooShort => {\n+                write!(f, \"invalid utf-8: byte slice too short\")\n+            }\n+        }\n+    }\n+}\n+\n /*\n Section: Iterators\n */\n@@ -907,13 +933,13 @@ impl<'a> Iterator for SplitStr<'a> {\n \n         match self.it.next() {\n             Some((from, to)) => {\n-                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                let ret = Some(&self.it.haystack[self.last_end .. from]);\n                 self.last_end = to;\n                 ret\n             }\n             None => {\n                 self.finished = true;\n-                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+                Some(&self.it.haystack[self.last_end .. self.it.haystack.len()])\n             }\n         }\n     }\n@@ -1121,27 +1147,90 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::Range<uint>) -> &str {\n-            self.slice(index.start, index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self[0 .. end]`.\n+    ///\n+    /// Panics when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n-            self.slice_to(index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self[begin .. self.len()]`.\n+    ///\n+    /// Panics when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n-            self.slice_from(index.start)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n         }\n     }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::FullRange> for str {\n         type Output = str;\n         #[inline]\n@@ -1154,7 +1243,7 @@ mod traits {\n /// Any string that can be represented as a slice\n #[unstable(feature = \"core\",\n            reason = \"Instead of taking this bound generically, this trait will be \\\n-                     replaced with one of slicing syntax, deref coercions, or \\\n+                     replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n                      a more generic conversion trait\")]\n pub trait Str {\n     /// Work with `self` as a slice.\n@@ -1216,9 +1305,6 @@ pub trait StrExt {\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n-    fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n@@ -1340,7 +1426,7 @@ impl StrExt for str {\n     fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n-            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n             else { line }\n         }\n \n@@ -1351,38 +1437,6 @@ impl StrExt for str {\n     #[inline]\n     fn char_len(&self) -> uint { self.chars().count() }\n \n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if begin <= end &&\n-           self.is_char_boundary(begin) &&\n-           self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(begin, end) }\n-        } else {\n-            slice_error_fail(self, begin, end)\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(begin) {\n-            unsafe { self.slice_unchecked(begin, self.len()) }\n-        } else {\n-            slice_error_fail(self, begin, self.len())\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(0, end) }\n-        } else {\n-            slice_error_fail(self, 0, end)\n-        }\n-    }\n-\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n@@ -1423,7 +1477,7 @@ impl StrExt for str {\n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == &self.as_bytes()[(m-n)..]\n+        m >= n && needle.as_bytes() == &self.as_bytes()[m-n..]\n     }\n \n     #[inline]"}, {"sha": "6ec87203e00306c307ad8fab73c28ba4d9e23891", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)]\n+\n use core::finally::{try_finally, Finally};\n use std::thread::Thread;\n "}, {"sha": "e7792014446816c43fed31dae7cbe1c9ef285af0", "filename": "src/libcoretest/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -14,5 +14,5 @@ mod num;\n fn test_format_flags() {\n     // No residual flags left by pointer formatting\n     let p = \"\".as_ptr();\n-    assert_eq!(format!(\"{:p} {:x}\", p, 16u), format!(\"{:p} 10\", p));\n+    assert_eq!(format!(\"{:p} {:x}\", p, 16), format!(\"{:p} 10\", p));\n }"}, {"sha": "17180076cd8054feed8269470b647e9edde7ea6f", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -16,115 +16,115 @@ fn test_format_int() {\n     // Formatting integers should select the right implementation based off\n     // the type of the argument. Also, hex/octal/binary should be defined\n     // for integers, but they shouldn't emit the negative sign.\n-    assert!(format!(\"{}\", 1i) == \"1\");\n+    assert!(format!(\"{}\", 1is) == \"1\");\n     assert!(format!(\"{}\", 1i8) == \"1\");\n     assert!(format!(\"{}\", 1i16) == \"1\");\n     assert!(format!(\"{}\", 1i32) == \"1\");\n     assert!(format!(\"{}\", 1i64) == \"1\");\n-    assert!(format!(\"{}\", -1i) == \"-1\");\n+    assert!(format!(\"{}\", -1is) == \"-1\");\n     assert!(format!(\"{}\", -1i8) == \"-1\");\n     assert!(format!(\"{}\", -1i16) == \"-1\");\n     assert!(format!(\"{}\", -1i32) == \"-1\");\n     assert!(format!(\"{}\", -1i64) == \"-1\");\n-    assert!(format!(\"{:?}\", 1i) == \"1i\");\n-    assert!(format!(\"{:?}\", 1i8) == \"1i8\");\n-    assert!(format!(\"{:?}\", 1i16) == \"1i16\");\n-    assert!(format!(\"{:?}\", 1i32) == \"1i32\");\n-    assert!(format!(\"{:?}\", 1i64) == \"1i64\");\n-    assert!(format!(\"{:b}\", 1i) == \"1\");\n+    assert!(format!(\"{:?}\", 1is) == \"1\");\n+    assert!(format!(\"{:?}\", 1i8) == \"1\");\n+    assert!(format!(\"{:?}\", 1i16) == \"1\");\n+    assert!(format!(\"{:?}\", 1i32) == \"1\");\n+    assert!(format!(\"{:?}\", 1i64) == \"1\");\n+    assert!(format!(\"{:b}\", 1is) == \"1\");\n     assert!(format!(\"{:b}\", 1i8) == \"1\");\n     assert!(format!(\"{:b}\", 1i16) == \"1\");\n     assert!(format!(\"{:b}\", 1i32) == \"1\");\n     assert!(format!(\"{:b}\", 1i64) == \"1\");\n-    assert!(format!(\"{:x}\", 1i) == \"1\");\n+    assert!(format!(\"{:x}\", 1is) == \"1\");\n     assert!(format!(\"{:x}\", 1i8) == \"1\");\n     assert!(format!(\"{:x}\", 1i16) == \"1\");\n     assert!(format!(\"{:x}\", 1i32) == \"1\");\n     assert!(format!(\"{:x}\", 1i64) == \"1\");\n-    assert!(format!(\"{:X}\", 1i) == \"1\");\n+    assert!(format!(\"{:X}\", 1is) == \"1\");\n     assert!(format!(\"{:X}\", 1i8) == \"1\");\n     assert!(format!(\"{:X}\", 1i16) == \"1\");\n     assert!(format!(\"{:X}\", 1i32) == \"1\");\n     assert!(format!(\"{:X}\", 1i64) == \"1\");\n-    assert!(format!(\"{:o}\", 1i) == \"1\");\n+    assert!(format!(\"{:o}\", 1is) == \"1\");\n     assert!(format!(\"{:o}\", 1i8) == \"1\");\n     assert!(format!(\"{:o}\", 1i16) == \"1\");\n     assert!(format!(\"{:o}\", 1i32) == \"1\");\n     assert!(format!(\"{:o}\", 1i64) == \"1\");\n \n-    assert!(format!(\"{}\", 1u) == \"1\");\n+    assert!(format!(\"{}\", 1us) == \"1\");\n     assert!(format!(\"{}\", 1u8) == \"1\");\n     assert!(format!(\"{}\", 1u16) == \"1\");\n     assert!(format!(\"{}\", 1u32) == \"1\");\n     assert!(format!(\"{}\", 1u64) == \"1\");\n-    assert!(format!(\"{:?}\", 1u) == \"1u\");\n-    assert!(format!(\"{:?}\", 1u8) == \"1u8\");\n-    assert!(format!(\"{:?}\", 1u16) == \"1u16\");\n-    assert!(format!(\"{:?}\", 1u32) == \"1u32\");\n-    assert!(format!(\"{:?}\", 1u64) == \"1u64\");\n-    assert!(format!(\"{:b}\", 1u) == \"1\");\n+    assert!(format!(\"{:?}\", 1us) == \"1\");\n+    assert!(format!(\"{:?}\", 1u8) == \"1\");\n+    assert!(format!(\"{:?}\", 1u16) == \"1\");\n+    assert!(format!(\"{:?}\", 1u32) == \"1\");\n+    assert!(format!(\"{:?}\", 1u64) == \"1\");\n+    assert!(format!(\"{:b}\", 1us) == \"1\");\n     assert!(format!(\"{:b}\", 1u8) == \"1\");\n     assert!(format!(\"{:b}\", 1u16) == \"1\");\n     assert!(format!(\"{:b}\", 1u32) == \"1\");\n     assert!(format!(\"{:b}\", 1u64) == \"1\");\n-    assert!(format!(\"{:x}\", 1u) == \"1\");\n+    assert!(format!(\"{:x}\", 1us) == \"1\");\n     assert!(format!(\"{:x}\", 1u8) == \"1\");\n     assert!(format!(\"{:x}\", 1u16) == \"1\");\n     assert!(format!(\"{:x}\", 1u32) == \"1\");\n     assert!(format!(\"{:x}\", 1u64) == \"1\");\n-    assert!(format!(\"{:X}\", 1u) == \"1\");\n+    assert!(format!(\"{:X}\", 1us) == \"1\");\n     assert!(format!(\"{:X}\", 1u8) == \"1\");\n     assert!(format!(\"{:X}\", 1u16) == \"1\");\n     assert!(format!(\"{:X}\", 1u32) == \"1\");\n     assert!(format!(\"{:X}\", 1u64) == \"1\");\n-    assert!(format!(\"{:o}\", 1u) == \"1\");\n+    assert!(format!(\"{:o}\", 1us) == \"1\");\n     assert!(format!(\"{:o}\", 1u8) == \"1\");\n     assert!(format!(\"{:o}\", 1u16) == \"1\");\n     assert!(format!(\"{:o}\", 1u32) == \"1\");\n     assert!(format!(\"{:o}\", 1u64) == \"1\");\n \n     // Test a larger number\n-    assert!(format!(\"{:b}\", 55i) == \"110111\");\n-    assert!(format!(\"{:o}\", 55i) == \"67\");\n-    assert!(format!(\"{}\", 55i) == \"55\");\n-    assert!(format!(\"{:x}\", 55i) == \"37\");\n-    assert!(format!(\"{:X}\", 55i) == \"37\");\n+    assert!(format!(\"{:b}\", 55) == \"110111\");\n+    assert!(format!(\"{:o}\", 55) == \"67\");\n+    assert!(format!(\"{}\", 55) == \"55\");\n+    assert!(format!(\"{:x}\", 55) == \"37\");\n+    assert!(format!(\"{:X}\", 55) == \"37\");\n }\n \n #[test]\n fn test_format_int_zero() {\n-    assert!(format!(\"{}\", 0i) == \"0\");\n-    assert!(format!(\"{:?}\", 0i) == \"0i\");\n-    assert!(format!(\"{:b}\", 0i) == \"0\");\n-    assert!(format!(\"{:o}\", 0i) == \"0\");\n-    assert!(format!(\"{:x}\", 0i) == \"0\");\n-    assert!(format!(\"{:X}\", 0i) == \"0\");\n-\n-    assert!(format!(\"{}\", 0u) == \"0\");\n-    assert!(format!(\"{:?}\", 0u) == \"0u\");\n-    assert!(format!(\"{:b}\", 0u) == \"0\");\n-    assert!(format!(\"{:o}\", 0u) == \"0\");\n-    assert!(format!(\"{:x}\", 0u) == \"0\");\n-    assert!(format!(\"{:X}\", 0u) == \"0\");\n+    assert!(format!(\"{}\", 0) == \"0\");\n+    assert!(format!(\"{:?}\", 0) == \"0\");\n+    assert!(format!(\"{:b}\", 0) == \"0\");\n+    assert!(format!(\"{:o}\", 0) == \"0\");\n+    assert!(format!(\"{:x}\", 0) == \"0\");\n+    assert!(format!(\"{:X}\", 0) == \"0\");\n+\n+    assert!(format!(\"{}\", 0u32) == \"0\");\n+    assert!(format!(\"{:?}\", 0u32) == \"0\");\n+    assert!(format!(\"{:b}\", 0u32) == \"0\");\n+    assert!(format!(\"{:o}\", 0u32) == \"0\");\n+    assert!(format!(\"{:x}\", 0u32) == \"0\");\n+    assert!(format!(\"{:X}\", 0u32) == \"0\");\n }\n \n #[test]\n fn test_format_int_flags() {\n-    assert!(format!(\"{:3}\", 1i) == \"  1\");\n-    assert!(format!(\"{:>3}\", 1i) == \"  1\");\n-    assert!(format!(\"{:>+3}\", 1i) == \" +1\");\n-    assert!(format!(\"{:<3}\", 1i) == \"1  \");\n-    assert!(format!(\"{:#}\", 1i) == \"1\");\n-    assert!(format!(\"{:#x}\", 10i) == \"0xa\");\n-    assert!(format!(\"{:#X}\", 10i) == \"0xA\");\n-    assert!(format!(\"{:#5x}\", 10i) == \"  0xa\");\n-    assert!(format!(\"{:#o}\", 10i) == \"0o12\");\n-    assert!(format!(\"{:08x}\", 10i) == \"0000000a\");\n-    assert!(format!(\"{:8x}\", 10i) == \"       a\");\n-    assert!(format!(\"{:<8x}\", 10i) == \"a       \");\n-    assert!(format!(\"{:>8x}\", 10i) == \"       a\");\n-    assert!(format!(\"{:#08x}\", 10i) == \"0x00000a\");\n-    assert!(format!(\"{:08}\", -10i) == \"-0000010\");\n+    assert!(format!(\"{:3}\", 1) == \"  1\");\n+    assert!(format!(\"{:>3}\", 1) == \"  1\");\n+    assert!(format!(\"{:>+3}\", 1) == \" +1\");\n+    assert!(format!(\"{:<3}\", 1) == \"1  \");\n+    assert!(format!(\"{:#}\", 1) == \"1\");\n+    assert!(format!(\"{:#x}\", 10) == \"0xa\");\n+    assert!(format!(\"{:#X}\", 10) == \"0xA\");\n+    assert!(format!(\"{:#5x}\", 10) == \"  0xa\");\n+    assert!(format!(\"{:#o}\", 10) == \"0o12\");\n+    assert!(format!(\"{:08x}\", 10) == \"0000000a\");\n+    assert!(format!(\"{:8x}\", 10) == \"       a\");\n+    assert!(format!(\"{:<8x}\", 10) == \"a       \");\n+    assert!(format!(\"{:>8x}\", 10) == \"       a\");\n+    assert!(format!(\"{:#08x}\", 10) == \"0x00000a\");\n+    assert!(format!(\"{:08}\", -10) == \"-0000010\");\n     assert!(format!(\"{:x}\", -1u8) == \"ff\");\n     assert!(format!(\"{:X}\", -1u8) == \"FF\");\n     assert!(format!(\"{:b}\", -1u8) == \"11111111\");\n@@ -137,12 +137,12 @@ fn test_format_int_flags() {\n \n #[test]\n fn test_format_int_sign_padding() {\n-    assert!(format!(\"{:+5}\", 1i) == \"   +1\");\n-    assert!(format!(\"{:+5}\", -1i) == \"   -1\");\n-    assert!(format!(\"{:05}\", 1i) == \"00001\");\n-    assert!(format!(\"{:05}\", -1i) == \"-0001\");\n-    assert!(format!(\"{:+05}\", 1i) == \"+0001\");\n-    assert!(format!(\"{:+05}\", -1i) == \"-0001\");\n+    assert!(format!(\"{:+5}\", 1) == \"   +1\");\n+    assert!(format!(\"{:+5}\", -1) == \"   -1\");\n+    assert!(format!(\"{:05}\", 1) == \"00001\");\n+    assert!(format!(\"{:05}\", -1) == \"-0001\");\n+    assert!(format!(\"{:+05}\", 1) == \"+0001\");\n+    assert!(format!(\"{:+05}\", -1) == \"-0001\");\n }\n \n #[test]\n@@ -156,96 +156,98 @@ fn test_format_int_twos_complement() {\n \n #[test]\n fn test_format_radix() {\n-    assert!(format!(\"{:04}\", radix(3i, 2)) == \"0011\");\n-    assert!(format!(\"{}\", radix(55i, 36)) == \"1j\");\n+    assert!(format!(\"{:04}\", radix(3, 2)) == \"0011\");\n+    assert!(format!(\"{}\", radix(55, 36)) == \"1j\");\n }\n \n #[test]\n #[should_fail]\n fn test_radix_base_too_large() {\n-    let _ = radix(55i, 37);\n+    let _ = radix(55, 37);\n }\n \n-mod uint {\n+mod u32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n+    use std::io::util::NullWriter;\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:b}\", rng.gen::<uint>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:b}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:o}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{}\", rng.gen::<uint>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:x}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:?}\", rng.gen::<uint>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:?}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n+        b.iter(|| { write!(&mut NullWriter, \"{}\", radix(rng.gen::<u32>(), 36)) })\n     }\n }\n \n-mod int {\n+mod i32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n+    use std::io::util::NullWriter;\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:b}\", rng.gen::<int>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:b}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:o}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{}\", rng.gen::<int>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:x}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{:?}\", rng.gen::<int>()); })\n+        b.iter(|| { write!(&mut NullWriter, \"{:?}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n+        b.iter(|| { write!(&mut NullWriter, \"{}\", radix(rng.gen::<i32>(), 36)) })\n     }\n }"}, {"sha": "9481245f1206ee29fac5082d5f086f785c463c51", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -120,18 +120,32 @@ fn test_iterator_enumerate() {\n fn test_iterator_peekable() {\n     let xs = vec![0u, 1, 2, 3, 4, 5];\n     let mut it = xs.iter().map(|&x|x).peekable();\n+\n+    assert_eq!(it.len(), 6);\n     assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 6);\n     assert_eq!(it.next().unwrap(), 0);\n+    assert_eq!(it.len(), 5);\n     assert_eq!(it.next().unwrap(), 1);\n+    assert_eq!(it.len(), 4);\n     assert_eq!(it.next().unwrap(), 2);\n+    assert_eq!(it.len(), 3);\n     assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.len(), 3);\n     assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.len(), 3);\n     assert_eq!(it.next().unwrap(), 3);\n+    assert_eq!(it.len(), 2);\n     assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.len(), 1);\n     assert_eq!(it.peek().unwrap(), &5);\n+    assert_eq!(it.len(), 1);\n     assert_eq!(it.next().unwrap(), 5);\n+    assert_eq!(it.len(), 0);\n     assert!(it.peek().is_none());\n+    assert_eq!(it.len(), 0);\n     assert!(it.next().is_none());\n+    assert_eq!(it.len(), 0);\n }\n \n #[test]\n@@ -166,24 +180,45 @@ fn test_iterator_skip() {\n     let ys = [13, 15, 16, 17, 19, 20, 30];\n     let mut it = xs.iter().skip(5);\n     let mut i = 0;\n-    for &x in it {\n+    while let Some(&x) = it.next() {\n         assert_eq!(x, ys[i]);\n         i += 1;\n+        assert_eq!(it.len(), xs.len()-5-i);\n     }\n     assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n }\n \n #[test]\n fn test_iterator_take() {\n-    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-    let ys = [0u, 1, 2, 3, 5];\n+    let xs = [0us, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0us, 1, 2, 3, 5];\n     let mut it = xs.iter().take(5);\n     let mut i = 0;\n-    for &x in it {\n+    assert_eq!(it.len(), 5);\n+    while let Some(&x) = it.next() {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+        assert_eq!(it.len(), 5-i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_take_short() {\n+    let xs = [0us, 1, 2, 3];\n+    let ys = [0us, 1, 2, 3];\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    assert_eq!(it.len(), 4);\n+    while let Some(&x) = it.next() {\n         assert_eq!(x, ys[i]);\n         i += 1;\n+        assert_eq!(it.len(), 4-i);\n     }\n     assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n }\n \n #[test]\n@@ -585,7 +620,7 @@ fn check_randacc_iter<A, T>(a: T, len: uint) where\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[(*x)..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);\n@@ -828,6 +863,24 @@ fn test_repeat() {\n     assert_eq!(it.next(), Some(42u));\n }\n \n+#[test]\n+fn test_fuse() {\n+    let mut it = 0us..3;\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next(), Some(0us));\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next(), Some(1us));\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next(), Some(2us));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.len(), 0);\n+}\n+\n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n     let it: Vec<uint> = range(0u, 300).collect();"}, {"sha": "e0623bade5c0eb41ef4cfaba0bb47d31c0398ae9", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::cmp::PartialEq;\n-use core::fmt::Show;\n+use core::fmt::Debug;\n use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n@@ -37,7 +37,7 @@ pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq + NumCast\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + Show\n+     + Rem<Output=T> + Debug\n      + Copy\n {\n     assert_eq!(ten.add(two),  cast(12i).unwrap());"}, {"sha": "daccb709890e158e8a83944903d3a04ed5689c93", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -14,11 +14,11 @@ pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n #[test]\n pub fn test_and() {\n     assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n-    assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op1().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n \n     assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n-    assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op2().and(Err::<i32,&'static str>(\"bad\")).unwrap_err(),\n                \"sadface\");\n }\n \n@@ -94,7 +94,7 @@ pub fn test_fmt_default() {\n     let err: Result<int, &'static str> = Err(\"Err\");\n \n     let s = format!(\"{:?}\", ok);\n-    assert_eq!(s, \"Ok(100i)\");\n+    assert_eq!(s, \"Ok(100)\");\n     let s = format!(\"{:?}\", err);\n     assert_eq!(s, \"Err(\\\"Err\\\")\");\n }"}, {"sha": "e524d8de0569342549b485b424786cf98aa013ba", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -60,9 +60,9 @@ fn test_tuple_cmp() {\n #[test]\n fn test_show() {\n     let s = format!(\"{:?}\", (1i,));\n-    assert_eq!(s, \"(1i,)\");\n+    assert_eq!(s, \"(1,)\");\n     let s = format!(\"{:?}\", (1i, true));\n-    assert_eq!(s, \"(1i, true)\");\n+    assert_eq!(s, \"(1, true)\");\n     let s = format!(\"{:?}\", (1i, \"hi\", true));\n-    assert_eq!(s, \"(1i, \\\"hi\\\", true)\");\n+    assert_eq!(s, \"(1, \\\"hi\\\", true)\");\n }"}, {"sha": "4774262246a338de906dbcaebde80afb29e001e5", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -550,7 +550,7 @@ impl Fail {\n     }\n }\n \n-impl fmt::String for Fail {\n+impl fmt::Display for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ArgumentMissing(ref nm) => {\n@@ -899,7 +899,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                      &ss[last_start..(i + 1)]),\n+                                      &ss[last_start..i + 1]),\n             (B, Cr, OverLim)  => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 slice_start = last_start;"}, {"sha": "5ed93f0fd991fba2f73e03a78889652c304690ea", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -362,19 +362,19 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n+    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Option<Id<'a>> {\n         let name = name.into_cow();\n         {\n             let mut chars = name.chars();\n             match chars.next() {\n                 Some(c) if is_letter_or_underscore(c) => { ; },\n-                _ => return Err(())\n+                _ => return None\n             }\n             if !chars.all(is_constituent) {\n-                return Err(());\n+                return None\n             }\n         }\n-        return Ok(Id{ name: name });\n+        return Some(Id{ name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -878,17 +878,17 @@ r#\"digraph syntax_tree {\n     fn simple_id_construction() {\n         let id1 = Id::new(\"hello\");\n         match id1 {\n-            Ok(_) => {;},\n-            Err(_) => panic!(\"'hello' is not a valid value for id anymore\")\n+            Some(_) => {;},\n+            None => panic!(\"'hello' is not a valid value for id anymore\")\n         }\n     }\n \n     #[test]\n     fn badly_formatted_id() {\n         let id2 = Id::new(\"Weird { struct : ure } !!!\");\n         match id2 {\n-            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            Err(_) => {;}\n+            Some(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+            None => {;}\n         }\n     }\n }"}, {"sha": "71f117835935d63c8aa4fadab9005537f191b11e", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -125,7 +125,7 @@ impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n     }\n }\n \n-impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n+impl<'a,T:fmt::Debug> fmt::Debug for MaybeOwnedVector<'a,T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }"}, {"sha": "548782216bbe5f5d8ea936c0c01e38c89e2ae360", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -557,7 +557,8 @@ pub mod types {\n                 pub type mode_t = u16;\n                 pub type ssize_t = i32;\n             }\n-            #[cfg(target_arch = \"x86\")]\n+            #[cfg(any(target_arch = \"x86\",\n+                      target_arch = \"powerpc\"))]\n             pub mod posix01 {\n                 use types::os::arch::c95::{c_short, c_long, time_t};\n                 use types::os::arch::posix88::{dev_t, gid_t, ino_t};\n@@ -648,8 +649,7 @@ pub mod types {\n                 }\n             }\n             #[cfg(any(target_arch = \"mips\",\n-                      target_arch = \"mipsel\",\n-                      target_arch = \"powerpc\"))]\n+                      target_arch = \"mipsel\"))]\n             pub mod posix01 {\n                 use types::os::arch::c95::{c_long, c_ulong, time_t};\n                 use types::os::arch::posix88::{gid_t, ino_t};\n@@ -2493,7 +2493,8 @@ pub mod consts {\n         #[cfg(any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\",\n-                  target_arch = \"aarch64\"))]\n+                  target_arch = \"aarch64\",\n+                  target_arch = \"powerpc\"))]\n         pub mod posix88 {\n             use types::os::arch::c95::c_int;\n             use types::common::c95::c_void;\n@@ -2706,8 +2707,7 @@ pub mod consts {\n         }\n \n         #[cfg(any(target_arch = \"mips\",\n-                  target_arch = \"mipsel\",\n-                  target_arch = \"powerpc\"))]\n+                  target_arch = \"mipsel\"))]\n         pub mod posix88 {\n             use types::os::arch::c95::c_int;\n             use types::common::c95::c_void;\n@@ -3004,7 +3004,8 @@ pub mod consts {\n         #[cfg(any(target_arch = \"arm\",\n                   target_arch = \"aarch64\",\n                   target_arch = \"x86\",\n-                  target_arch = \"x86_64\"))]\n+                  target_arch = \"x86_64\",\n+                  target_arch = \"powerpc\"))]\n         pub mod bsd44 {\n             use types::os::arch::c95::c_int;\n \n@@ -3052,8 +3053,7 @@ pub mod consts {\n             pub const SHUT_RDWR: c_int = 2;\n         }\n         #[cfg(any(target_arch = \"mips\",\n-                  target_arch = \"mipsel\",\n-                  target_arch = \"powerpc\"))]\n+                  target_arch = \"mipsel\"))]\n         pub mod bsd44 {\n             use types::os::arch::c95::c_int;\n \n@@ -3101,7 +3101,8 @@ pub mod consts {\n         #[cfg(any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\",\n-                  target_arch = \"aarch64\"))]\n+                  target_arch = \"aarch64\",\n+                  target_arch = \"powerpc\"))]\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n \n@@ -3129,8 +3130,7 @@ pub mod consts {\n             pub const MAP_STACK : c_int = 0x020000;\n         }\n         #[cfg(any(target_arch = \"mips\",\n-                  target_arch = \"mipsel\",\n-                  target_arch = \"powerpc\"))]\n+                  target_arch = \"mipsel\"))]\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n \n@@ -4650,13 +4650,13 @@ pub mod funcs {\n             use types::os::arch::c95::c_int;\n             use types::os::common::posix01::sighandler_t;\n \n-            #[cfg(not(target_os = \"android\"))]\n+            #[cfg(not(all(target_os = \"android\", target_arch = \"arm\")))]\n             extern {\n                 pub fn signal(signum: c_int,\n                               handler: sighandler_t) -> sighandler_t;\n             }\n \n-            #[cfg(target_os = \"android\")]\n+            #[cfg(all(target_os = \"android\", target_arch = \"arm\"))]\n             extern {\n                 #[link_name = \"bsd_signal\"]\n                 pub fn signal(signum: c_int,"}, {"sha": "5efa799f56279628f123fb617ed3ad375abc35fd", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use regex::Regex;\n use std::ascii::AsciiExt;\n use std::cmp;\n \n@@ -34,7 +33,7 @@ fn parse_log_level(level: &str) -> Option<u32> {\n ///\n /// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in\n /// std::).  Also supports string log levels of error, warn, info, and debug\n-pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<Regex>) {\n+pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n     let mut dirs = Vec::new();\n \n     let mut parts = spec.split('/');\n@@ -80,17 +79,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<Regex>) {\n         });\n     }});\n \n-    let filter = filter.map_or(None, |filter| {\n-        match Regex::new(filter) {\n-            Ok(re) => Some(re),\n-            Err(e) => {\n-                println!(\"warning: invalid regex filter - {:?}\", e);\n-                None\n-            }\n-        }\n-    });\n-\n-    return (dirs, filter);\n+    (dirs, filter.map(|s| s.to_string()))\n }\n \n #[cfg(test)]"}, {"sha": "05b831a5a592a7d60892febce44b098c453f8a65", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -123,11 +123,11 @@\n //!\n //! # Filtering results\n //!\n-//! A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n-//! followed by a regex. Each message is checked against the regex, and is only\n-//! logged if it matches. Note that the matching is done after formatting the log\n-//! string but before adding any logging meta-data. There is a single filter for all\n-//! modules.\n+//! A RUST_LOG directive may include a string filter. The syntax is to append\n+//! `/` followed by a string. Each message is checked against the string and is\n+//! only logged if it contains the string. Note that the matching is done after\n+//! formatting the log string but before adding any logging meta-data. There is\n+//! a single filter for all modules.\n //!\n //! Some examples:\n //!\n@@ -179,20 +179,17 @@\n #![feature(rustc_private)]\n #![feature(std_misc)]\n \n-extern crate regex;\n-\n use std::cell::RefCell;\n use std::fmt;\n use std::io::LineBufferedWriter;\n use std::io;\n use std::mem;\n use std::os;\n+use std::ptr;\n use std::rt;\n use std::slice;\n use std::sync::{Once, ONCE_INIT};\n \n-use regex::Regex;\n-\n use directive::LOG_LEVEL_NAMES;\n \n #[macro_use]\n@@ -215,8 +212,8 @@ static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n     0 as *const Vec<directive::LogDirective>;\n \n-/// Optional regex filter.\n-static mut FILTER: *const Regex = 0 as *const _;\n+/// Optional filter.\n+static mut FILTER: *const String = 0 as *const _;\n \n /// Debug log level\n pub const DEBUG: u32 = 4;\n@@ -246,21 +243,15 @@ struct DefaultLogger {\n }\n \n /// Wraps the log level with fmt implementations.\n-#[derive(Copy, PartialEq, PartialOrd)]\n+#[derive(Copy, PartialEq, PartialOrd, Show)]\n pub struct LogLevel(pub u32);\n \n-impl fmt::Show for LogLevel {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, fmt)\n-    }\n-}\n-\n-impl fmt::String for LogLevel {\n+impl fmt::Display for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as uint - 1) {\n-            Some(ref name) => fmt::String::fmt(name, fmt),\n-            None => fmt::String::fmt(&level, fmt)\n+            Some(ref name) => fmt::Display::fmt(name, fmt),\n+            None => fmt::Display::fmt(&level, fmt)\n         }\n     }\n }\n@@ -300,7 +291,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(&args.to_string()[]) => return,\n+        Some(filter) if !args.to_string().contains(&filter[]) => return,\n         _ => {}\n     }\n \n@@ -444,10 +435,10 @@ fn init() {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n-            DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n+            DIRECTIVES = ptr::null();\n \n             if !FILTER.is_null() {\n-                let _filter: Box<Regex> = mem::transmute(FILTER);\n+                let _filter: Box<String> = mem::transmute(FILTER);\n                 FILTER = 0 as *const _;\n             }\n         });"}, {"sha": "3332e06e19e74e25220a5087537ed5100f92085b", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -174,7 +174,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n         // reset state\n         self.init(&[0u32; KEY_WORDS]);\n         // set key in place\n-        let key = self.state.slice_mut(4, 4+KEY_WORDS);\n+        let key = &mut self.state[4 .. 4+KEY_WORDS];\n         for (k, s) in key.iter_mut().zip(seed.iter()) {\n             *k = *s;\n         }\n@@ -292,4 +292,3 @@ mod test {\n         }\n     }\n }\n-"}, {"sha": "9c746c69baafcf1f72eafc6df0b5eca5c3a24636", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -103,7 +103,7 @@ impl Writer for SeekableMemWriter {\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n+                slice::bytes::copy_memory(&mut self.buf[self.pos..], left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "2819dec3ebbfdf36fac7b1bb2fe0377eba3a1875", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -42,6 +42,7 @@ pub use self::EbmlEncoderTag::*;\n pub use self::Error::*;\n \n use std::str;\n+use std::fmt;\n \n pub mod io;\n \n@@ -117,6 +118,13 @@ pub enum Error {\n     IoError(std::io::IoError),\n     ApplicationError(String)\n }\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME: this should be a more useful display form\n+        fmt::Debug::fmt(self, f)\n+    }\n+}\n // --------------------------------------\n \n pub mod reader {"}, {"sha": "d29a7a425c1164d1825549f49a99305377d89a95", "filename": "src/libregex/compile.rs", "status": "removed", "additions": 0, "deletions": 275, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,275 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Enable this to squash warnings due to exporting pieces of the representation\n-// for use with the regex! macro. See lib.rs for explanation.\n-\n-pub use self::Inst::*;\n-\n-use std::cmp;\n-use std::iter::repeat;\n-use parse;\n-use parse::{\n-    Flags, FLAG_EMPTY,\n-    Nothing, Literal, Dot, AstClass, Begin, End, WordBoundary, Capture, Cat, Alt,\n-    Rep,\n-    ZeroOne, ZeroMore, OneMore,\n-};\n-\n-type InstIdx = uint;\n-\n-#[derive(Show, Clone)]\n-pub enum Inst {\n-    // When a Match instruction is executed, the current thread is successful.\n-    Match,\n-\n-    // The OneChar instruction matches a literal character.\n-    // The flags indicate whether to do a case insensitive match.\n-    OneChar(char, Flags),\n-\n-    // The CharClass instruction tries to match one input character against\n-    // the range of characters given.\n-    // The flags indicate whether to do a case insensitive match and whether\n-    // the character class is negated or not.\n-    CharClass(Vec<(char, char)>, Flags),\n-\n-    // Matches any character except new lines.\n-    // The flags indicate whether to include the '\\n' character.\n-    Any(Flags),\n-\n-    // Matches the beginning of the string, consumes no characters.\n-    // The flags indicate whether it matches if the preceding character\n-    // is a new line.\n-    EmptyBegin(Flags),\n-\n-    // Matches the end of the string, consumes no characters.\n-    // The flags indicate whether it matches if the proceeding character\n-    // is a new line.\n-    EmptyEnd(Flags),\n-\n-    // Matches a word boundary (\\w on one side and \\W \\A or \\z on the other),\n-    // and consumes no character.\n-    // The flags indicate whether this matches a word boundary or something\n-    // that isn't a word boundary.\n-    EmptyWordBoundary(Flags),\n-\n-    // Saves the current position in the input string to the Nth save slot.\n-    Save(uint),\n-\n-    // Jumps to the instruction at the index given.\n-    Jump(InstIdx),\n-\n-    // Jumps to the instruction at the first index given. If that leads to\n-    // a panic state, then the instruction at the second index given is\n-    // tried.\n-    Split(InstIdx, InstIdx),\n-}\n-\n-/// Program represents a compiled regular expression. Once an expression is\n-/// compiled, its representation is immutable and will never change.\n-///\n-/// All of the data in a compiled expression is wrapped in \"MaybeStatic\" or\n-/// \"MaybeOwned\" types so that a `Program` can be represented as static data.\n-/// (This makes it convenient and efficient for use with the `regex!` macro.)\n-#[derive(Clone)]\n-pub struct Program {\n-    /// A sequence of instructions.\n-    pub insts: Vec<Inst>,\n-    /// If the regular expression requires a literal prefix in order to have a\n-    /// match, that prefix is stored here. (It's used in the VM to implement\n-    /// an optimization.)\n-    pub prefix: String,\n-}\n-\n-impl Program {\n-    /// Compiles a Regex given its AST.\n-    pub fn new(ast: parse::Ast) -> (Program, Vec<Option<String>>) {\n-        let mut c = Compiler {\n-            insts: Vec::with_capacity(100),\n-            names: Vec::with_capacity(10),\n-        };\n-\n-        c.insts.push(Save(0));\n-        c.compile(ast);\n-        c.insts.push(Save(1));\n-        c.insts.push(Match);\n-\n-        // Try to discover a literal string prefix.\n-        // This is a bit hacky since we have to skip over the initial\n-        // 'Save' instruction.\n-        let mut pre = String::with_capacity(5);\n-        for inst in c.insts[1..].iter() {\n-            match *inst {\n-                OneChar(c, FLAG_EMPTY) => pre.push(c),\n-                _ => break\n-            }\n-        }\n-\n-        let Compiler { insts, names } = c;\n-        let prog = Program {\n-            insts: insts,\n-            prefix: pre,\n-        };\n-        (prog, names)\n-    }\n-\n-    /// Returns the total number of capture groups in the regular expression.\n-    /// This includes the zeroth capture.\n-    pub fn num_captures(&self) -> uint {\n-        let mut n = 0;\n-        for inst in self.insts.iter() {\n-            match *inst {\n-                Save(c) => n = cmp::max(n, c+1),\n-                _ => {}\n-            }\n-        }\n-        // There's exactly 2 Save slots for every capture.\n-        n / 2\n-    }\n-}\n-\n-struct Compiler<'r> {\n-    insts: Vec<Inst>,\n-    names: Vec<Option<String>>,\n-}\n-\n-// The compiler implemented here is extremely simple. Most of the complexity\n-// in this crate is in the parser or the VM.\n-// The only tricky thing here is patching jump/split instructions to point to\n-// the right instruction.\n-impl<'r> Compiler<'r> {\n-    fn compile(&mut self, ast: parse::Ast) {\n-        match ast {\n-            Nothing => {},\n-            Literal(c, flags) => self.push(OneChar(c, flags)),\n-            Dot(nl) => self.push(Any(nl)),\n-            AstClass(ranges, flags) =>\n-                self.push(CharClass(ranges, flags)),\n-            Begin(flags) => self.push(EmptyBegin(flags)),\n-            End(flags) => self.push(EmptyEnd(flags)),\n-            WordBoundary(flags) => self.push(EmptyWordBoundary(flags)),\n-            Capture(cap, name, x) => {\n-                let len = self.names.len();\n-                if cap >= len {\n-                    self.names.extend(repeat(None).take(10 + cap - len))\n-                }\n-                self.names[cap] = name;\n-\n-                self.push(Save(2 * cap));\n-                self.compile(*x);\n-                self.push(Save(2 * cap + 1));\n-            }\n-            Cat(xs) => {\n-                for x in xs.into_iter() {\n-                    self.compile(x)\n-                }\n-            }\n-            Alt(x, y) => {\n-                let split = self.empty_split(); // push: split 0, 0\n-                let j1 = self.insts.len();\n-                self.compile(*x);                // push: insts for x\n-                let jmp = self.empty_jump();    // push: jmp 0\n-                let j2 = self.insts.len();\n-                self.compile(*y);                // push: insts for y\n-                let j3 = self.insts.len();\n-\n-                self.set_split(split, j1, j2);  // split 0, 0 -> split j1, j2\n-                self.set_jump(jmp, j3);         // jmp 0      -> jmp j3\n-            }\n-            Rep(x, ZeroOne, g) => {\n-                let split = self.empty_split();\n-                let j1 = self.insts.len();\n-                self.compile(*x);\n-                let j2 = self.insts.len();\n-\n-                if g.is_greedy() {\n-                    self.set_split(split, j1, j2);\n-                } else {\n-                    self.set_split(split, j2, j1);\n-                }\n-            }\n-            Rep(x, ZeroMore, g) => {\n-                let j1 = self.insts.len();\n-                let split = self.empty_split();\n-                let j2 = self.insts.len();\n-                self.compile(*x);\n-                let jmp = self.empty_jump();\n-                let j3 = self.insts.len();\n-\n-                self.set_jump(jmp, j1);\n-                if g.is_greedy() {\n-                    self.set_split(split, j2, j3);\n-                } else {\n-                    self.set_split(split, j3, j2);\n-                }\n-            }\n-            Rep(x, OneMore, g) => {\n-                let j1 = self.insts.len();\n-                self.compile(*x);\n-                let split = self.empty_split();\n-                let j2 = self.insts.len();\n-\n-                if g.is_greedy() {\n-                    self.set_split(split, j1, j2);\n-                } else {\n-                    self.set_split(split, j2, j1);\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Appends the given instruction to the program.\n-    #[inline]\n-    fn push(&mut self, x: Inst) {\n-        self.insts.push(x)\n-    }\n-\n-    /// Appends an *empty* `Split` instruction to the program and returns\n-    /// the index of that instruction. (The index can then be used to \"patch\"\n-    /// the actual locations of the split in later.)\n-    #[inline]\n-    fn empty_split(&mut self) -> InstIdx {\n-        self.insts.push(Split(0, 0));\n-        self.insts.len() - 1\n-    }\n-\n-    /// Sets the left and right locations of a `Split` instruction at index\n-    /// `i` to `pc1` and `pc2`, respectively.\n-    /// If the instruction at index `i` isn't a `Split` instruction, then\n-    /// `panic!` is called.\n-    #[inline]\n-    fn set_split(&mut self, i: InstIdx, pc1: InstIdx, pc2: InstIdx) {\n-        let split = &mut self.insts[i];\n-        match *split {\n-            Split(_, _) => *split = Split(pc1, pc2),\n-            _ => panic!(\"BUG: Invalid split index.\"),\n-        }\n-    }\n-\n-    /// Appends an *empty* `Jump` instruction to the program and returns the\n-    /// index of that instruction.\n-    #[inline]\n-    fn empty_jump(&mut self) -> InstIdx {\n-        self.insts.push(Jump(0));\n-        self.insts.len() - 1\n-    }\n-\n-    /// Sets the location of a `Jump` instruction at index `i` to `pc`.\n-    /// If the instruction at index `i` isn't a `Jump` instruction, then\n-    /// `panic!` is called.\n-    #[inline]\n-    fn set_jump(&mut self, i: InstIdx, pc: InstIdx) {\n-        let jmp = &mut self.insts[i];\n-        match *jmp {\n-            Jump(_) => *jmp = Jump(pc),\n-            _ => panic!(\"BUG: Invalid jump index.\"),\n-        }\n-    }\n-}"}, {"sha": "9631eb36056b334850b072f48e67a8683b65acc2", "filename": "src/libregex/lib.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,97 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Regular expressions implemented in Rust\n-//!\n-//! For official documentation, see the rust-lang/regex crate\n-#![crate_name = \"regex\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![unstable(feature = \"rustc_private\",\n-            reason = \"use the crates.io `regex` library instead\")]\n-#![feature(staged_api)]\n-#![staged_api]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(slicing_syntax)]\n-#![feature(box_syntax)]\n-#![allow(unknown_features)] #![feature(int_uint)]\n-#![deny(missing_docs)]\n-#![feature(collections)]\n-#![feature(core)]\n-#![feature(unicode)]\n-\n-#[cfg(test)]\n-extern crate \"test\" as stdtest;\n-#[cfg(test)]\n-extern crate rand;\n-\n-// During tests, this links with the `regex` crate so that the `regex!` macro\n-// can be tested.\n-#[cfg(test)]\n-extern crate regex;\n-\n-// Unicode tables for character classes are defined in libunicode\n-extern crate unicode;\n-\n-pub use parse::Error;\n-pub use re::{Regex, Captures, SubCaptures, SubCapturesPos};\n-pub use re::{FindCaptures, FindMatches};\n-pub use re::{Replacer, NoExpand, RegexSplits, RegexSplitsN};\n-pub use re::{quote, is_match};\n-\n-mod compile;\n-mod parse;\n-mod re;\n-mod vm;\n-\n-#[cfg(test)]\n-mod test;\n-\n-/// The `native` module exists to support the `regex!` macro. Do not use.\n-#[doc(hidden)]\n-pub mod native {\n-    // Exporting this stuff is bad form, but it's necessary for two reasons.\n-    // Firstly, the `regex!` syntax extension is in a different crate and\n-    // requires access to the representation of a regex (particularly the\n-    // instruction set) in order to compile to native Rust. This could be\n-    // mitigated if `regex!` was defined in the same crate, but this has\n-    // undesirable consequences (such as requiring a dependency on\n-    // `libsyntax`).\n-    //\n-    // Secondly, the code generated by `regex!` must *also* be able\n-    // to access various functions in this crate to reduce code duplication\n-    // and to provide a value with precisely the same `Regex` type in this\n-    // crate. This, AFAIK, is impossible to mitigate.\n-    //\n-    // On the bright side, `rustdoc` lets us hide this from the public API\n-    // documentation.\n-    pub use compile::{\n-        Program,\n-        OneChar, CharClass, Any, Save, Jump, Split,\n-        Match, EmptyBegin, EmptyEnd, EmptyWordBoundary,\n-    };\n-    pub use parse::{\n-        FLAG_EMPTY, FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL,\n-        FLAG_SWAP_GREED, FLAG_NEGATED,\n-    };\n-    pub use re::{Dynamic, ExDynamic, Native, ExNative};\n-    pub use vm::{\n-        MatchKind, Exists, Location, Submatches,\n-        StepState, StepMatchEarlyReturn, StepMatch, StepContinue,\n-        CharReader, find_prefix,\n-    };\n-}"}, {"sha": "1cc2b271e9ccda688ff3cdbdaffb75ee2c10a29f", "filename": "src/libregex/parse.rs", "status": "removed", "additions": 0, "deletions": 1086, "changes": 1086, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,1086 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::Ast::*;\n-pub use self::Repeater::*;\n-pub use self::Greed::*;\n-use self::BuildAst::*;\n-\n-use std::char;\n-use std::cmp;\n-use std::fmt;\n-use std::iter;\n-use std::num;\n-\n-/// Static data containing Unicode ranges for general categories and scripts.\n-use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n-\n-/// The maximum number of repetitions allowed with the `{n,m}` syntax.\n-static MAX_REPEAT: uint = 1000;\n-\n-/// Error corresponds to something that can go wrong while parsing\n-/// a regular expression.\n-///\n-/// (Once an expression is compiled, it is not possible to produce an error\n-/// via searching, splitting or replacing.)\n-pub struct Error {\n-    /// The *approximate* character index of where the error occurred.\n-    pub pos: uint,\n-    /// A message describing the error.\n-    pub msg: String,\n-}\n-\n-impl fmt::Show for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Regex syntax error near position {}: {:?}\",\n-               self.pos, self.msg)\n-    }\n-}\n-\n-/// Represents the abstract syntax of a regular expression.\n-/// It is showable so that error messages resulting from a bug can provide\n-/// useful information.\n-/// It is cloneable so that expressions can be repeated for the counted\n-/// repetition feature. (No other copying is done.)\n-///\n-/// Note that this representation prevents one from reproducing the regex as\n-/// it was typed. (But it could be used to reproduce an equivalent regex.)\n-#[derive(Show, Clone)]\n-pub enum Ast {\n-    Nothing,\n-    Literal(char, Flags),\n-    Dot(Flags),\n-    AstClass(Vec<(char, char)>, Flags),\n-    Begin(Flags),\n-    End(Flags),\n-    WordBoundary(Flags),\n-    Capture(uint, Option<String>, Box<Ast>),\n-    // Represent concatenation as a flat vector to avoid blowing the\n-    // stack in the compiler.\n-    Cat(Vec<Ast>),\n-    Alt(Box<Ast>, Box<Ast>),\n-    Rep(Box<Ast>, Repeater, Greed),\n-}\n-\n-#[derive(Show, PartialEq, Clone)]\n-pub enum Repeater {\n-    ZeroOne,\n-    ZeroMore,\n-    OneMore,\n-}\n-\n-#[derive(Copy, Show, Clone)]\n-pub enum Greed {\n-    Greedy,\n-    Ungreedy,\n-}\n-\n-impl Greed {\n-    pub fn is_greedy(&self) -> bool {\n-        match *self {\n-            Greedy => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn swap(self, swapped: bool) -> Greed {\n-        if !swapped { return self }\n-        match self {\n-            Greedy => Ungreedy,\n-            Ungreedy => Greedy,\n-        }\n-    }\n-}\n-\n-/// BuildAst is a regrettable type that represents intermediate state for\n-/// constructing an abstract syntax tree. Its central purpose is to facilitate\n-/// parsing groups and alternations while also maintaining a stack of flag\n-/// state.\n-#[derive(Show)]\n-enum BuildAst {\n-    Expr(Ast),\n-    Paren(Flags, uint, String), // '('\n-    Bar, // '|'\n-}\n-\n-impl BuildAst {\n-    fn paren(&self) -> bool {\n-        match *self {\n-            Paren(_, _, _) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn flags(&self) -> Flags {\n-        match *self {\n-            Paren(flags, _, _) => flags,\n-            _ => panic!(\"Cannot get flags from {:?}\", self),\n-        }\n-    }\n-\n-    fn capture(&self) -> Option<uint> {\n-        match *self {\n-            Paren(_, 0, _) => None,\n-            Paren(_, c, _) => Some(c),\n-            _ => panic!(\"Cannot get capture group from {:?}\", self),\n-        }\n-    }\n-\n-    fn capture_name(&self) -> Option<String> {\n-        match *self {\n-            Paren(_, 0, _) => None,\n-            Paren(_, _, ref name) => {\n-                if name.len() == 0 {\n-                    None\n-                } else {\n-                    Some(name.clone())\n-                }\n-            }\n-            _ => panic!(\"Cannot get capture name from {:?}\", self),\n-        }\n-    }\n-\n-    fn bar(&self) -> bool {\n-        match *self {\n-            Bar => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn unwrap(self) -> Result<Ast, Error> {\n-        match self {\n-            Expr(x) => Ok(x),\n-            _ => panic!(\"Tried to unwrap non-AST item: {:?}\", self),\n-        }\n-    }\n-}\n-\n-/// Flags represents all options that can be twiddled by a user in an\n-/// expression.\n-pub type Flags = u8;\n-\n-pub const FLAG_EMPTY:      u8 = 0;\n-pub const FLAG_NOCASE:     u8 = 1 << 0; // i\n-pub const FLAG_MULTI:      u8 = 1 << 1; // m\n-pub const FLAG_DOTNL:      u8 = 1 << 2; // s\n-pub const FLAG_SWAP_GREED: u8 = 1 << 3; // U\n-pub const FLAG_NEGATED:    u8 = 1 << 4; // char class or not word boundary\n-\n-struct Parser<'a> {\n-    // The input, parsed only as a sequence of UTF8 code points.\n-    chars: Vec<char>,\n-    // The index of the current character in the input.\n-    chari: uint,\n-    // The intermediate state representing the AST.\n-    stack: Vec<BuildAst>,\n-    // The current set of flags.\n-    flags: Flags,\n-    // The total number of capture groups.\n-    // Incremented each time an opening left paren is seen (assuming it is\n-    // opening a capture group).\n-    caps: uint,\n-    // A set of all capture group names used only to detect duplicates.\n-    names: Vec<String>,\n-}\n-\n-pub fn parse(s: &str) -> Result<Ast, Error> {\n-    Parser {\n-        chars: s.chars().collect(),\n-        chari: 0,\n-        stack: vec!(),\n-        flags: FLAG_EMPTY,\n-        caps: 0,\n-        names: vec!(),\n-    }.parse()\n-}\n-\n-impl<'a> Parser<'a> {\n-    fn parse(&mut self) -> Result<Ast, Error> {\n-        if self.chars.len() == 0 {\n-            return Ok(Nothing);\n-        }\n-        loop {\n-            let c = self.cur();\n-            match c {\n-                '?' | '*' | '+' => try!(self.push_repeater(c)),\n-                '\\\\' => {\n-                    let ast = try!(self.parse_escape());\n-                    self.push(ast)\n-                }\n-                '{' => try!(self.parse_counted()),\n-                '[' => match self.try_parse_ascii() {\n-                    None => try!(self.parse_class()),\n-                    Some(class) => self.push(class),\n-                },\n-                '(' => {\n-                    if self.peek_is(1, '?') {\n-                        try!(self.expect('?'));\n-                        try!(self.parse_group_opts())\n-                    } else {\n-                        self.caps += 1;\n-                        self.stack.push(Paren(self.flags,\n-                                              self.caps,\n-                                              \"\".to_string()))\n-                    }\n-                }\n-                ')' => {\n-                    let catfrom = try!(\n-                        self.pos_last(false, |x| x.paren() || x.bar()));\n-                    try!(self.concat(catfrom));\n-\n-                    let altfrom = try!(self.pos_last(false, |x| x.paren()));\n-                    // Before we smush the alternates together and pop off the\n-                    // left paren, let's grab the old flags and see if we\n-                    // need a capture.\n-                    let (cap, cap_name, oldflags) = {\n-                        let paren = &self.stack[altfrom-1];\n-                        (paren.capture(), paren.capture_name(), paren.flags())\n-                    };\n-                    try!(self.alternate(altfrom));\n-                    self.flags = oldflags;\n-\n-                    // If this was a capture, pop what we just pushed in\n-                    // alternate and make it a capture.\n-                    if cap.is_some() {\n-                        let ast = try!(self.pop_ast());\n-                        self.push(Capture(cap.unwrap(), cap_name, box ast));\n-                    }\n-                }\n-                '|' => {\n-                    let catfrom = try!(\n-                        self.pos_last(true, |x| x.paren() || x.bar()));\n-                    try!(self.concat(catfrom));\n-\n-                    self.stack.push(Bar);\n-                }\n-                _ => try!(self.push_literal(c)),\n-            }\n-            if !self.next_char() {\n-                break\n-            }\n-        }\n-\n-        // Try to improve error handling. At this point, there should be\n-        // no remaining open parens.\n-        if self.stack.iter().any(|x| x.paren()) {\n-            return self.err(\"Unclosed parenthesis.\")\n-        }\n-        let catfrom = try!(self.pos_last(true, |x| x.bar()));\n-        try!(self.concat(catfrom));\n-        try!(self.alternate(0));\n-\n-        assert!(self.stack.len() == 1);\n-        self.pop_ast()\n-    }\n-\n-    fn noteof(&mut self, expected: &str) -> Result<(), Error> {\n-        match self.next_char() {\n-            true => Ok(()),\n-            false => {\n-                self.err(&format!(\"Expected {:?} but got EOF.\",\n-                                  expected)[])\n-            }\n-        }\n-    }\n-\n-    fn expect(&mut self, expected: char) -> Result<(), Error> {\n-        match self.next_char() {\n-            true if self.cur() == expected => Ok(()),\n-            true => self.err(&format!(\"Expected '{:?}' but got '{:?}'.\",\n-                                      expected, self.cur())[]),\n-            false => {\n-                self.err(&format!(\"Expected '{:?}' but got EOF.\",\n-                                  expected)[])\n-            }\n-        }\n-    }\n-\n-    fn next_char(&mut self) -> bool {\n-        self.chari += 1;\n-        self.chari < self.chars.len()\n-    }\n-\n-    fn pop_ast(&mut self) -> Result<Ast, Error> {\n-        match self.stack.pop().unwrap().unwrap() {\n-            Err(e) => Err(e),\n-            Ok(ast) => Ok(ast),\n-        }\n-    }\n-\n-    fn push(&mut self, ast: Ast) {\n-        self.stack.push(Expr(ast))\n-    }\n-\n-    fn push_repeater(&mut self, c: char) -> Result<(), Error> {\n-        match self.stack.last() {\n-            Some(&Expr(..)) => (),\n-            // self.stack is empty, or the top item is not an Expr\n-            _ => return self.err(\"A repeat operator must be preceded by a valid expression.\"),\n-        }\n-        let rep: Repeater = match c {\n-            '?' => ZeroOne, '*' => ZeroMore, '+' => OneMore,\n-            _ => panic!(\"Not a valid repeater operator.\"),\n-        };\n-\n-        match self.peek(1) {\n-            Some('*') | Some('+') =>\n-                return self.err(\n-                    \"Double repeat operators are not supported.\"),\n-            _ => {},\n-        }\n-        let ast = try!(self.pop_ast());\n-        match ast {\n-            Begin(_) | End(_) | WordBoundary(_) =>\n-                return self.err(\n-                    \"Repeat arguments cannot be empty width assertions.\"),\n-            _ => {}\n-        }\n-        let greed = try!(self.get_next_greedy());\n-        self.push(Rep(box ast, rep, greed));\n-        Ok(())\n-    }\n-\n-    fn push_literal(&mut self, c: char) -> Result<(), Error> {\n-        let flags = self.flags;\n-        match c {\n-            '.' => {\n-                self.push(Dot(flags))\n-            }\n-            '^' => {\n-                self.push(Begin(flags))\n-            }\n-            '$' => {\n-                self.push(End(flags))\n-            }\n-            _ => {\n-                self.push(Literal(c, flags))\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    // Parses all forms of character classes.\n-    // Assumes that '[' is the current character.\n-    fn parse_class(&mut self) -> Result<(), Error> {\n-        let negated =\n-            if self.peek_is(1, '^') {\n-                try!(self.expect('^'));\n-                FLAG_NEGATED\n-            } else {\n-                FLAG_EMPTY\n-            };\n-        let mut ranges: Vec<(char, char)> = vec!();\n-        let mut alts: Vec<Ast> = vec!();\n-\n-        while self.peek_is(1, '-') {\n-            try!(self.expect('-'));\n-            ranges.push(('-', '-'))\n-        }\n-        loop {\n-            try!(self.noteof(\"a closing ']' or a non-empty character class)\"));\n-            let mut c = self.cur();\n-            match c {\n-                '[' =>\n-                    match self.try_parse_ascii() {\n-                        Some(AstClass(asciis, flags)) => {\n-                            alts.push(AstClass(asciis, flags ^ negated));\n-                            continue\n-                        }\n-                        Some(ast) =>\n-                            panic!(\"Expected Class AST but got '{:?}'\", ast),\n-                        // Just drop down and try to add as a regular character.\n-                        None => {},\n-                    },\n-                '\\\\' => {\n-                    match try!(self.parse_escape()) {\n-                        AstClass(asciis, flags) => {\n-                            alts.push(AstClass(asciis, flags ^ negated));\n-                            continue\n-                        }\n-                        Literal(c2, _) => c = c2, // process below\n-                        Begin(_) | End(_) | WordBoundary(_) =>\n-                            return self.err(\n-                                \"\\\\A, \\\\z, \\\\b and \\\\B are not valid escape \\\n-                                 sequences inside a character class.\"),\n-                        ast => panic!(\"Unexpected AST item '{:?}'\", ast),\n-                    }\n-                }\n-                ']' if ranges.len() > 0 || alts.len() > 0 => {\n-                    if ranges.len() > 0 {\n-                        let flags = negated | (self.flags & FLAG_NOCASE);\n-                        let mut ast = AstClass(combine_ranges(ranges), flags);\n-                        for alt in alts.into_iter() {\n-                            ast = Alt(box alt, box ast)\n-                        }\n-                        self.push(ast);\n-                    } else if alts.len() > 0 {\n-                        let mut ast = alts.pop().unwrap();\n-                        for alt in alts.into_iter() {\n-                            ast = Alt(box alt, box ast)\n-                        }\n-                        self.push(ast);\n-                    }\n-                    return Ok(())\n-                }\n-                _ => {}\n-            }\n-\n-            if self.peek_is(1, '-') && !self.peek_is(2, ']') {\n-                try!(self.expect('-'));\n-                // The regex can't end here.\n-                try!(self.noteof(\"not a ']'\"));\n-                // End the range with a single character or character escape.\n-                let mut c2 = self.cur();\n-                if c2 == '\\\\' {\n-                    match try!(self.parse_escape()) {\n-                        Literal(c3, _) => c2 = c3, // allow literal escapes below\n-                        ast =>\n-                            return self.err(&format!(\"Expected a literal, but got {:?}.\",\n-                                                     ast)[]),\n-                    }\n-                }\n-                if c2 < c {\n-                    return self.err(&format!(\"Invalid character class \\\n-                                              range '{}-{}'\",\n-                                             c,\n-                                             c2)[])\n-                }\n-                ranges.push((c, self.cur()))\n-            } else {\n-                ranges.push((c, c))\n-            }\n-        }\n-    }\n-\n-    // Tries to parse an ASCII character class of the form [:name:].\n-    // If successful, returns an AST character class corresponding to name\n-    // and moves the parser to the final ']' character.\n-    // If unsuccessful, no state is changed and None is returned.\n-    // Assumes that '[' is the current character.\n-    fn try_parse_ascii(&mut self) -> Option<Ast> {\n-        if !self.peek_is(1, ':') {\n-            return None\n-        }\n-        let closer =\n-            match self.pos(']') {\n-                Some(i) => i,\n-                None => return None,\n-            };\n-        if self.chars[closer-1] != ':' {\n-            return None\n-        }\n-        if closer - self.chari <= 3 {\n-            return None\n-        }\n-        let mut name_start = self.chari + 2;\n-        let negated =\n-            if self.peek_is(2, '^') {\n-                name_start += 1;\n-                FLAG_NEGATED\n-            } else {\n-                FLAG_EMPTY\n-            };\n-        let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, &name[]) {\n-            None => None,\n-            Some(ranges) => {\n-                self.chari = closer;\n-                let flags = negated | (self.flags & FLAG_NOCASE);\n-                Some(AstClass(combine_ranges(ranges), flags))\n-            }\n-        }\n-    }\n-\n-    // Parses counted repetition. Supports:\n-    // {n}, {n,}, {n,m}, {n}?, {n,}? and {n,m}?\n-    // Assumes that '{' is the current character.\n-    // Returns either an error or moves the parser to the final '}' character.\n-    // (Or the '?' character if not greedy.)\n-    fn parse_counted(&mut self) -> Result<(), Error> {\n-        // Scan until the closing '}' and grab the stuff in {}.\n-        let start = self.chari;\n-        let closer =\n-            match self.pos('}') {\n-                Some(i) => i,\n-                None => {\n-                    return self.err(&format!(\"No closing brace for counted \\\n-                                              repetition starting at position \\\n-                                              {:?}.\",\n-                                             start)[])\n-                }\n-            };\n-        self.chari = closer;\n-        let greed = try!(self.get_next_greedy());\n-        let inner = self.chars[(start+1)..closer].iter().cloned()\n-                                               .collect::<String>();\n-\n-        // Parse the min and max values from the regex.\n-        let (mut min, mut max): (uint, Option<uint>);\n-        if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(&inner[]));\n-            max = Some(min);\n-        } else {\n-            let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n-            let (smin, smax) = (pieces[0], pieces[1]);\n-            if smin.len() == 0 {\n-                return self.err(\"Max repetitions cannot be specified \\\n-                                    without min repetitions.\")\n-            }\n-            min = try!(self.parse_uint(smin));\n-            max =\n-                if smax.len() == 0 {\n-                    None\n-                } else {\n-                    Some(try!(self.parse_uint(smax)))\n-                };\n-        }\n-\n-        // Do some bounds checking and make sure max >= min.\n-        if min > MAX_REPEAT {\n-            return self.err(&format!(\n-                \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT)[]);\n-        }\n-        if max.is_some() {\n-            let m = max.unwrap();\n-            if m > MAX_REPEAT {\n-                return self.err(&format!(\n-                    \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT)[]);\n-            }\n-            if m < min {\n-                return self.err(&format!(\n-                    \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min)[]);\n-            }\n-        }\n-\n-        // Now manipulate the AST be repeating elements.\n-        if max.is_none() {\n-            // Require N copies of what's on the stack and then repeat it.\n-            let ast = try!(self.pop_ast());\n-            for _ in iter::range(0, min) {\n-                self.push(ast.clone())\n-            }\n-            self.push(Rep(box ast, ZeroMore, greed));\n-        } else {\n-            // Require N copies of what's on the stack and then repeat it\n-            // up to M times optionally.\n-            let ast = try!(self.pop_ast());\n-            for _ in iter::range(0, min) {\n-                self.push(ast.clone())\n-            }\n-            if max.is_some() {\n-                for _ in iter::range(min, max.unwrap()) {\n-                    self.push(Rep(box ast.clone(), ZeroOne, greed))\n-                }\n-            }\n-            // It's possible that we popped something off the stack but\n-            // never put anything back on it. To keep things simple, add\n-            // a no-op expression.\n-            if min == 0 && (max.is_none() || max == Some(0)) {\n-                self.push(Nothing)\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    // Parses all escape sequences.\n-    // Assumes that '\\' is the current character.\n-    fn parse_escape(&mut self) -> Result<Ast, Error> {\n-        try!(self.noteof(\"an escape sequence following a '\\\\'\"));\n-\n-        let c = self.cur();\n-        if is_punct(c) {\n-            return Ok(Literal(c, FLAG_EMPTY))\n-        }\n-        match c {\n-            'a' => Ok(Literal('\\x07', FLAG_EMPTY)),\n-            'f' => Ok(Literal('\\x0C', FLAG_EMPTY)),\n-            't' => Ok(Literal('\\t', FLAG_EMPTY)),\n-            'n' => Ok(Literal('\\n', FLAG_EMPTY)),\n-            'r' => Ok(Literal('\\r', FLAG_EMPTY)),\n-            'v' => Ok(Literal('\\x0B', FLAG_EMPTY)),\n-            'A' => Ok(Begin(FLAG_EMPTY)),\n-            'z' => Ok(End(FLAG_EMPTY)),\n-            'b' => Ok(WordBoundary(FLAG_EMPTY)),\n-            'B' => Ok(WordBoundary(FLAG_NEGATED)),\n-            '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7' => Ok(try!(self.parse_octal())),\n-            'x' => Ok(try!(self.parse_hex())),\n-            'p' | 'P' => Ok(try!(self.parse_unicode_name())),\n-            'd' | 'D' | 's' | 'S' | 'w' | 'W' => {\n-                let ranges = perl_unicode_class(c);\n-                let mut flags = self.flags & FLAG_NOCASE;\n-                if c.is_uppercase() { flags |= FLAG_NEGATED }\n-                Ok(AstClass(ranges, flags))\n-            }\n-            _ => {\n-                self.err(&format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n-            }\n-        }\n-    }\n-\n-    // Parses a Unicode character class name, either of the form \\pF where\n-    // F is a one letter Unicode class name or of the form \\p{name} where\n-    // name is the Unicode class name.\n-    // Assumes that \\p or \\P has been read (and 'p' or 'P' is the current\n-    // character).\n-    fn parse_unicode_name(&mut self) -> Result<Ast, Error> {\n-        let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n-        let mut name: String;\n-        if self.peek_is(1, '{') {\n-            try!(self.expect('{'));\n-            let closer =\n-                match self.pos('}') {\n-                    Some(i) => i,\n-                    None => return self.err(&format!(\n-                        \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari)[]),\n-                };\n-            if closer - self.chari + 1 == 0 {\n-                return self.err(\"No Unicode class name found.\")\n-            }\n-            name = self.slice(self.chari + 1, closer);\n-            self.chari = closer;\n-        } else {\n-            if self.chari + 1 >= self.chars.len() {\n-                return self.err(\"No single letter Unicode class name found.\")\n-            }\n-            name = self.slice(self.chari + 1, self.chari + 2);\n-            self.chari += 1;\n-        }\n-        match find_class(UNICODE_CLASSES, &name[]) {\n-            None => {\n-                return self.err(&format!(\"Could not find Unicode class '{}'\",\n-                                        name)[])\n-            }\n-            Some(ranges) => {\n-                Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n-            }\n-        }\n-    }\n-\n-    // Parses an octal number, up to 3 digits.\n-    // Assumes that \\n has been read, where n is the first digit.\n-    fn parse_octal(&mut self) -> Result<Ast, Error> {\n-        let start = self.chari;\n-        let mut end = start + 1;\n-        let (d2, d3) = (self.peek(1), self.peek(2));\n-        if d2 >= Some('0') && d2 <= Some('7') {\n-            try!(self.noteof(\"expected octal character in [0-7]\"));\n-            end += 1;\n-            if d3 >= Some('0') && d3 <= Some('7') {\n-                try!(self.noteof(\"expected octal character in [0-7]\"));\n-                end += 1;\n-            }\n-        }\n-        let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(&s[], 8) {\n-            Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n-            None => {\n-                self.err(&format!(\"Could not parse '{:?}' as octal number.\",\n-                                 s)[])\n-            }\n-        }\n-    }\n-\n-    // Parse a hex number. Either exactly two digits or anything in {}.\n-    // Assumes that \\x has been read.\n-    fn parse_hex(&mut self) -> Result<Ast, Error> {\n-        if !self.peek_is(1, '{') {\n-            try!(self.expect('{'));\n-            return self.parse_hex_two()\n-        }\n-        let start = self.chari + 2;\n-        let closer =\n-            match self.pos('}') {\n-                None => {\n-                    return self.err(&format!(\"Missing '}}' for unclosed \\\n-                                             '{{' at position {}\",\n-                                            start)[])\n-                }\n-                Some(i) => i,\n-            };\n-        self.chari = closer;\n-        self.parse_hex_digits(&self.slice(start, closer)[])\n-    }\n-\n-    // Parses a two-digit hex number.\n-    // Assumes that \\xn has been read, where n is the first digit and is the\n-    // current character.\n-    // After return, parser will point at the second digit.\n-    fn parse_hex_two(&mut self) -> Result<Ast, Error> {\n-        let (start, end) = (self.chari, self.chari + 2);\n-        let bad = self.slice(start - 2, self.chars.len());\n-        try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\",\n-                                 bad).as_slice()));\n-        self.parse_hex_digits(self.slice(start, end).as_slice())\n-    }\n-\n-    // Parses `s` as a hexadecimal number.\n-    fn parse_hex_digits(&self, s: &str) -> Result<Ast, Error> {\n-        match num::from_str_radix::<u32>(s, 16) {\n-            Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n-            None => {\n-                self.err(&format!(\"Could not parse '{}' as hex number.\", s)[])\n-            }\n-        }\n-    }\n-\n-    // Parses a named capture.\n-    // Assumes that '(?P<' has been consumed and that the current character\n-    // is '<'.\n-    // When done, parser will be at the closing '>' character.\n-    fn parse_named_capture(&mut self) -> Result<(), Error> {\n-        try!(self.noteof(\"a capture name\"));\n-        let closer =\n-            match self.pos('>') {\n-                Some(i) => i,\n-                None => return self.err(\"Capture name must end with '>'.\"),\n-            };\n-        if closer - self.chari == 0 {\n-            return self.err(\"Capture names must have at least 1 character.\")\n-        }\n-        let name = self.slice(self.chari, closer);\n-        if !name.chars().all(is_valid_cap) {\n-            return self.err(\n-                \"Capture names can only have underscores, letters and digits.\")\n-        }\n-        if self.names.contains(&name) {\n-            return self.err(&format!(\"Duplicate capture group name '{}'.\",\n-                                    name)[])\n-        }\n-        self.names.push(name.clone());\n-        self.chari = closer;\n-        self.caps += 1;\n-        self.stack.push(Paren(self.flags, self.caps, name));\n-        Ok(())\n-    }\n-\n-    // Parses non-capture groups and options.\n-    // Assumes that '(?' has already been consumed and '?' is the current\n-    // character.\n-    fn parse_group_opts(&mut self) -> Result<(), Error> {\n-        if self.peek_is(1, 'P') && self.peek_is(2, '<') {\n-            try!(self.expect('P'));\n-            try!(self.expect('<'));\n-            return self.parse_named_capture()\n-        }\n-        let start = self.chari;\n-        let mut flags = self.flags;\n-        let mut sign = 1i;\n-        let mut saw_flag = false;\n-        loop {\n-            try!(self.noteof(\n-                    \"expected non-empty set of flags or closing ')'\"));\n-            match self.cur() {\n-                'i' => { flags = flags | FLAG_NOCASE;     saw_flag = true},\n-                'm' => { flags = flags | FLAG_MULTI;      saw_flag = true},\n-                's' => { flags = flags | FLAG_DOTNL;      saw_flag = true},\n-                'U' => { flags = flags | FLAG_SWAP_GREED; saw_flag = true},\n-                '-' => {\n-                    if sign < 0 {\n-                        return self.err(&format!(\n-                            \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1))[])\n-                    }\n-                    sign = -1;\n-                    saw_flag = false;\n-                    flags = flags ^ flags;\n-                }\n-                ':' | ')' => {\n-                    if sign < 0 {\n-                        if !saw_flag {\n-                            return self.err(&format!(\n-                                \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1))[])\n-                        }\n-                        flags = flags ^ flags;\n-                    }\n-                    if self.cur() == ':' {\n-                        // Save the old flags with the opening paren.\n-                        self.stack.push(Paren(self.flags, 0, \"\".to_string()));\n-                    }\n-                    self.flags = flags;\n-                    return Ok(())\n-                }\n-                _ => return self.err(&format!(\n-                    \"Unrecognized flag '{}'.\", self.cur())[]),\n-            }\n-        }\n-    }\n-\n-    // Peeks at the next character and returns whether it's ungreedy or not.\n-    // If it is, then the next character is consumed.\n-    fn get_next_greedy(&mut self) -> Result<Greed, Error> {\n-        Ok(if self.peek_is(1, '?') {\n-            try!(self.expect('?'));\n-            Ungreedy\n-        } else {\n-            Greedy\n-        }.swap(self.flags & FLAG_SWAP_GREED > 0))\n-    }\n-\n-    // Searches the stack (starting at the top) until it finds an expression\n-    // for which `pred` returns true. The index of that expression in the\n-    // stack is returned.\n-    // If there's no match, then one of two things happens depending on the\n-    // values of `allow_start`. When it's true, then `0` will be returned.\n-    // Otherwise, an error will be returned.\n-    // Generally, `allow_start` is only true when you're *not* expecting an\n-    // opening parenthesis.\n-    fn pos_last<P>(&self, allow_start: bool, pred: P) -> Result<uint, Error> where\n-        P: FnMut(&BuildAst) -> bool,\n-   {\n-        let from = match self.stack.iter().rev().position(pred) {\n-            Some(i) => i,\n-            None => {\n-                if allow_start {\n-                    self.stack.len()\n-                } else {\n-                    return self.err(\"No matching opening parenthesis.\")\n-                }\n-            }\n-        };\n-        // Adjust index since 'from' is for the reversed stack.\n-        // Also, don't include the '(' or '|'.\n-        Ok(self.stack.len() - from)\n-    }\n-\n-    // concat starts at `from` in the parser's stack and concatenates all\n-    // expressions up to the top of the stack. The resulting concatenation is\n-    // then pushed on to the stack.\n-    // Usually `from` corresponds to the position of an opening parenthesis,\n-    // a '|' (alternation) or the start of the entire expression.\n-    fn concat(&mut self, from: uint) -> Result<(), Error> {\n-        let ast = try!(self.build_from(from, concat_flatten));\n-        self.push(ast);\n-        Ok(())\n-    }\n-\n-    // concat starts at `from` in the parser's stack and alternates all\n-    // expressions up to the top of the stack. The resulting alternation is\n-    // then pushed on to the stack.\n-    // Usually `from` corresponds to the position of an opening parenthesis\n-    // or the start of the entire expression.\n-    // This will also drop any opening parens or alternation bars found in\n-    // the intermediate AST.\n-    fn alternate(&mut self, mut from: uint) -> Result<(), Error> {\n-        // Unlike in the concatenation case, we want 'build_from' to continue\n-        // all the way to the opening left paren (so it will be popped off and\n-        // thrown away). But be careful with overflow---we can't count on the\n-        // open paren to be there.\n-        if from > 0 { from = from - 1}\n-        let ast = try!(self.build_from(from, |l,r| Alt(box l, box r)));\n-        self.push(ast);\n-        Ok(())\n-    }\n-\n-    // build_from combines all AST elements starting at 'from' in the\n-    // parser's stack using 'mk' to combine them. If any such element is not an\n-    // AST then it is popped off the stack and ignored.\n-    fn build_from<F>(&mut self, from: uint, mut mk: F) -> Result<Ast, Error> where\n-        F: FnMut(Ast, Ast) -> Ast,\n-    {\n-        if from >= self.stack.len() {\n-            return self.err(\"Empty group or alternate not allowed.\")\n-        }\n-\n-        let mut combined = try!(self.pop_ast());\n-        let mut i = self.stack.len();\n-        while i > from {\n-            i = i - 1;\n-            match self.stack.pop().unwrap() {\n-                Expr(x) => combined = mk(x, combined),\n-                _ => {},\n-            }\n-        }\n-        Ok(combined)\n-    }\n-\n-    fn parse_uint(&self, s: &str) -> Result<uint, Error> {\n-        match s.parse::<uint>() {\n-            Some(i) => Ok(i),\n-            None => {\n-                self.err(&format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s)[])\n-            }\n-        }\n-    }\n-\n-    fn char_from_u32(&self, n: u32) -> Result<char, Error> {\n-        match char::from_u32(n) {\n-            Some(c) => Ok(c),\n-            None => {\n-                self.err(&format!(\"Could not decode '{}' to unicode \\\n-                                  character.\", n)[])\n-            }\n-        }\n-    }\n-\n-    fn pos(&self, c: char) -> Option<uint> {\n-        self.chars.iter()\n-            .skip(self.chari).position(|&c2| c2 == c).map(|i| self.chari + i)\n-    }\n-\n-    fn err<T>(&self, msg: &str) -> Result<T, Error> {\n-        Err(Error {\n-            pos: self.chari,\n-            msg: msg.to_string(),\n-        })\n-    }\n-\n-    fn peek(&self, offset: uint) -> Option<char> {\n-        if self.chari + offset >= self.chars.len() {\n-            return None\n-        }\n-        Some(self.chars[self.chari + offset])\n-    }\n-\n-    fn peek_is(&self, offset: uint, is: char) -> bool {\n-        self.peek(offset) == Some(is)\n-    }\n-\n-    fn cur(&self) -> char {\n-        self.chars[self.chari]\n-    }\n-\n-    fn slice(&self, start: uint, end: uint) -> String {\n-        self.chars[start..end].iter().cloned().collect()\n-    }\n-}\n-\n-// Given an unordered collection of character ranges, combine_ranges returns\n-// an ordered sequence of character ranges where no two ranges overlap. They\n-// are ordered from least to greatest (using start position).\n-fn combine_ranges(unordered: Vec<(char, char)>) -> Vec<(char, char)> {\n-    // Returns true iff the two character classes overlap or share a boundary.\n-    // e.g., ('a', 'g') and ('h', 'm') would return true.\n-    fn should_merge((a, b): (char, char), (x, y): (char, char)) -> bool {\n-        cmp::max(a, x) as u32 <= cmp::min(b, y) as u32 + 1\n-    }\n-\n-    // This is currently O(n^2), but I think with sufficient cleverness,\n-    // it can be reduced to O(n) **if necessary**.\n-    let mut ordered: Vec<(char, char)> = Vec::with_capacity(unordered.len());\n-    for (us, ue) in unordered.into_iter() {\n-        let (mut us, mut ue) = (us, ue);\n-        assert!(us <= ue);\n-        let mut which: Option<uint> = None;\n-        for (i, &(os, oe)) in ordered.iter().enumerate() {\n-            if should_merge((us, ue), (os, oe)) {\n-                us = cmp::min(us, os);\n-                ue = cmp::max(ue, oe);\n-                which = Some(i);\n-                break\n-            }\n-        }\n-        match which {\n-            None => ordered.push((us, ue)),\n-            Some(i) => ordered[i] = (us, ue),\n-        }\n-    }\n-    ordered.sort();\n-    ordered\n-}\n-\n-// Constructs a Unicode friendly Perl character class from \\d, \\s or \\w\n-// (or any of their negated forms). Note that this does not handle negation.\n-fn perl_unicode_class(which: char) -> Vec<(char, char)> {\n-    match which.to_lowercase() {\n-        'd' => PERLD.to_vec(),\n-        's' => PERLS.to_vec(),\n-        'w' => PERLW.to_vec(),\n-        _ => unreachable!(),\n-    }\n-}\n-\n-// Returns a concatenation of two expressions. This also guarantees that a\n-// `Cat` expression will never be a direct child of another `Cat` expression.\n-fn concat_flatten(x: Ast, y: Ast) -> Ast {\n-    match (x, y) {\n-        (Cat(mut xs), Cat(ys)) => { xs.extend(ys.into_iter()); Cat(xs) }\n-        (Cat(mut xs), ast) => { xs.push(ast); Cat(xs) }\n-        (ast, Cat(mut xs)) => { xs.insert(0, ast); Cat(xs) }\n-        (ast1, ast2) => Cat(vec!(ast1, ast2)),\n-    }\n-}\n-\n-pub fn is_punct(c: char) -> bool {\n-    match c {\n-        '\\\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' |\n-        '[' | ']' | '{' | '}' | '^' | '$' => true,\n-        _ => false,\n-    }\n-}\n-\n-fn is_valid_cap(c: char) -> bool {\n-    c == '_' || (c >= '0' && c <= '9')\n-    || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n-}\n-\n-fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n-    match classes.binary_search_by(|&(s, _)| s.cmp(name)) {\n-        Ok(i) => Some(classes[i].1.to_vec()),\n-        Err(_) => None,\n-    }\n-}\n-\n-type Class = &'static [(char, char)];\n-type NamedClasses = &'static [(&'static str, &'static Class)];\n-\n-static ASCII_CLASSES: NamedClasses = &[\n-    // Classes must be in alphabetical order so that bsearch works.\n-    // [:alnum:]      alphanumeric (== [0-9A-Za-z])\n-    // [:alpha:]      alphabetic (== [A-Za-z])\n-    // [:ascii:]      ASCII (== [\\x00-\\x7F])\n-    // [:blank:]      blank (== [\\t ])\n-    // [:cntrl:]      control (== [\\x00-\\x1F\\x7F])\n-    // [:digit:]      digits (== [0-9])\n-    // [:graph:]      graphical (== [!-~])\n-    // [:lower:]      lower case (== [a-z])\n-    // [:print:]      printable (== [ -~] == [ [:graph:]])\n-    // [:punct:]      punctuation (== [!-/:-@[-`{-~])\n-    // [:space:]      whitespace (== [\\t\\n\\v\\f\\r ])\n-    // [:upper:]      upper case (== [A-Z])\n-    // [:word:]       word characters (== [0-9A-Za-z_])\n-    // [:xdigit:]     hex digit (== [0-9A-Fa-f])\n-    // Taken from: http://golang.org/pkg/regex/syntax/\n-    (\"alnum\", &ALNUM),\n-    (\"alpha\", &ALPHA),\n-    (\"ascii\", &ASCII),\n-    (\"blank\", &BLANK),\n-    (\"cntrl\", &CNTRL),\n-    (\"digit\", &DIGIT),\n-    (\"graph\", &GRAPH),\n-    (\"lower\", &LOWER),\n-    (\"print\", &PRINT),\n-    (\"punct\", &PUNCT),\n-    (\"space\", &SPACE),\n-    (\"upper\", &UPPER),\n-    (\"word\", &WORD),\n-    (\"xdigit\", &XDIGIT),\n-];\n-\n-static ALNUM: Class = &[('0', '9'), ('A', 'Z'), ('a', 'z')];\n-static ALPHA: Class = &[('A', 'Z'), ('a', 'z')];\n-static ASCII: Class = &[('\\x00', '\\x7F')];\n-static BLANK: Class = &[(' ', ' '), ('\\t', '\\t')];\n-static CNTRL: Class = &[('\\x00', '\\x1F'), ('\\x7F', '\\x7F')];\n-static DIGIT: Class = &[('0', '9')];\n-static GRAPH: Class = &[('!', '~')];\n-static LOWER: Class = &[('a', 'z')];\n-static PRINT: Class = &[(' ', '~')];\n-static PUNCT: Class = &[('!', '/'), (':', '@'), ('[', '`'), ('{', '~')];\n-static SPACE: Class = &[('\\t', '\\t'), ('\\n', '\\n'), ('\\x0B', '\\x0B'),\n-                        ('\\x0C', '\\x0C'), ('\\r', '\\r'), (' ', ' ')];\n-static UPPER: Class = &[('A', 'Z')];\n-static WORD: Class = &[('0', '9'), ('A', 'Z'), ('a', 'z'), ('_', '_')];\n-static XDIGIT: Class = &[('0', '9'), ('A', 'F'), ('a', 'f')];"}, {"sha": "8c9df74635a714d05b5ab19938b607c6d3d8e1a1", "filename": "src/libregex/re.rs", "status": "removed", "additions": 0, "deletions": 682, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,682 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::NamesIter::*;\n-pub use self::Regex::*;\n-\n-use std::borrow::IntoCow;\n-use std::collections::HashMap;\n-use std::fmt;\n-use std::string::CowString;\n-\n-use compile::Program;\n-use parse;\n-use vm;\n-use vm::{CaptureLocs, MatchKind, Exists, Location, Submatches};\n-\n-/// Escapes all regular expression meta characters in `text`.\n-///\n-/// The string returned may be safely used as a literal in a regular\n-/// expression.\n-pub fn quote(text: &str) -> String {\n-    let mut quoted = String::with_capacity(text.len());\n-    for c in text.chars() {\n-        if parse::is_punct(c) {\n-            quoted.push('\\\\')\n-        }\n-        quoted.push(c);\n-    }\n-    quoted\n-}\n-\n-/// Tests if the given regular expression matches somewhere in the text given.\n-///\n-/// If there was a problem compiling the regular expression, an error is\n-/// returned.\n-///\n-/// To find submatches, split or replace text, you'll need to compile an\n-/// expression first.\n-///\n-/// Note that you should prefer the `regex!` macro when possible. For example,\n-/// `regex!(\"...\").is_match(\"...\")`.\n-pub fn is_match(regex: &str, text: &str) -> Result<bool, parse::Error> {\n-    Regex::new(regex).map(|r| r.is_match(text))\n-}\n-\n-/// A compiled regular expression\n-#[derive(Clone)]\n-pub enum Regex {\n-    // The representation of `Regex` is exported to support the `regex!`\n-    // syntax extension. Do not rely on it.\n-    //\n-    // See the comments for the `program` module in `lib.rs` for a more\n-    // detailed explanation for what `regex!` requires.\n-    #[doc(hidden)]\n-    Dynamic(ExDynamic),\n-    #[doc(hidden)]\n-    Native(ExNative),\n-}\n-\n-#[derive(Clone)]\n-#[doc(hidden)]\n-pub struct ExDynamic {\n-    original: String,\n-    names: Vec<Option<String>>,\n-    #[doc(hidden)]\n-    pub prog: Program\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub struct ExNative {\n-    #[doc(hidden)]\n-    pub original: &'static str,\n-    #[doc(hidden)]\n-    pub names: &'static &'static [Option<&'static str>],\n-    #[doc(hidden)]\n-    pub prog: fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>\n-}\n-\n-impl Clone for ExNative {\n-    fn clone(&self) -> ExNative {\n-        *self\n-    }\n-}\n-\n-impl fmt::String for Regex {\n-    /// Shows the original regular expression.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self.as_str(), f)\n-    }\n-}\n-\n-impl Regex {\n-    /// Compiles a dynamic regular expression. Once compiled, it can be\n-    /// used repeatedly to search, split or replace text in a string.\n-    ///\n-    /// When possible, you should prefer the `regex!` macro since it is\n-    /// safer and always faster.\n-    ///\n-    /// If an invalid expression is given, then an error is returned.\n-    pub fn new(re: &str) -> Result<Regex, parse::Error> {\n-        let ast = try!(parse::parse(re));\n-        let (prog, names) = Program::new(ast);\n-        Ok(Dynamic(ExDynamic {\n-            original: re.to_string(),\n-            names: names,\n-            prog: prog,\n-        }))\n-    }\n-\n-    /// Returns true if and only if the regex matches the string given.\n-    pub fn is_match(&self, text: &str) -> bool {\n-        has_match(&exec(self, Exists, text))\n-    }\n-\n-    /// Returns the start and end byte range of the leftmost-first match in\n-    /// `text`. If no match exists, then `None` is returned.\n-    pub fn find(&self, text: &str) -> Option<(uint, uint)> {\n-        let caps = exec(self, Location, text);\n-        if has_match(&caps) {\n-            Some((caps[0].unwrap(), caps[1].unwrap()))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns an iterator for each successive non-overlapping match in\n-    /// `text`, returning the start and end byte indices with respect to\n-    /// `text`.\n-    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> FindMatches<'r, 't> {\n-        FindMatches {\n-            re: self,\n-            search: text,\n-            last_end: 0,\n-            last_match: None,\n-        }\n-    }\n-\n-    /// Returns the capture groups corresponding to the leftmost-first\n-    /// match in `text`. Capture group `0` always corresponds to the entire\n-    /// match. If no match is found, then `None` is returned.\n-    ///\n-    /// You should only use `captures` if you need access to submatches.\n-    /// Otherwise, `find` is faster for discovering the location of the overall\n-    /// match.\n-    pub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> {\n-        let caps = exec(self, Submatches, text);\n-        Captures::new(self, text, caps)\n-    }\n-\n-    /// Returns an iterator over all the non-overlapping capture groups matched\n-    /// in `text`. This is operationally the same as `find_iter` (except it\n-    /// yields information about submatches).\n-    pub fn captures_iter<'r, 't>(&'r self, text: &'t str)\n-                                -> FindCaptures<'r, 't> {\n-        FindCaptures {\n-            re: self,\n-            search: text,\n-            last_match: None,\n-            last_end: 0,\n-        }\n-    }\n-\n-    /// Returns an iterator of substrings of `text` delimited by a match\n-    /// of the regular expression.\n-    /// Namely, each element of the iterator corresponds to text that *isn't*\n-    /// matched by the regular expression.\n-    ///\n-    /// This method will *not* copy the text given.\n-    pub fn split<'r, 't>(&'r self, text: &'t str) -> RegexSplits<'r, 't> {\n-        RegexSplits {\n-            finder: self.find_iter(text),\n-            last: 0,\n-        }\n-    }\n-\n-    /// Returns an iterator of at most `limit` substrings of `text` delimited\n-    /// by a match of the regular expression. (A `limit` of `0` will return no\n-    /// substrings.)\n-    /// Namely, each element of the iterator corresponds to text that *isn't*\n-    /// matched by the regular expression.\n-    /// The remainder of the string that is not split will be the last element\n-    /// in the iterator.\n-    ///\n-    /// This method will *not* copy the text given.\n-    pub fn splitn<'r, 't>(&'r self, text: &'t str, limit: uint)\n-                         -> RegexSplitsN<'r, 't> {\n-        RegexSplitsN {\n-            splits: self.split(text),\n-            cur: 0,\n-            limit: limit,\n-        }\n-    }\n-\n-    /// Replaces the leftmost-first match with the replacement provided.\n-    /// The replacement can be a regular string (where `$N` and `$name` are\n-    /// expanded to match capture groups) or a function that takes the matches'\n-    /// `Captures` and returns the replaced string.\n-    ///\n-    /// If no match is found, then a copy of the string is returned unchanged.\n-    pub fn replace<R: Replacer>(&self, text: &str, rep: R) -> String {\n-        self.replacen(text, 1, rep)\n-    }\n-\n-    /// Replaces all non-overlapping matches in `text` with the\n-    /// replacement provided. This is the same as calling `replacen` with\n-    /// `limit` set to `0`.\n-    ///\n-    /// See the documentation for `replace` for details on how to access\n-    /// submatches in the replacement string.\n-    pub fn replace_all<R: Replacer>(&self, text: &str, rep: R) -> String {\n-        self.replacen(text, 0, rep)\n-    }\n-\n-    /// Replaces at most `limit` non-overlapping matches in `text` with the\n-    /// replacement provided. If `limit` is 0, then all non-overlapping matches\n-    /// are replaced.\n-    ///\n-    /// See the documentation for `replace` for details on how to access\n-    /// submatches in the replacement string.\n-    pub fn replacen<R: Replacer>\n-                   (&self, text: &str, limit: uint, mut rep: R) -> String {\n-        let mut new = String::with_capacity(text.len());\n-        let mut last_match = 0u;\n-\n-        for (i, cap) in self.captures_iter(text).enumerate() {\n-            // It'd be nicer to use the 'take' iterator instead, but it seemed\n-            // awkward given that '0' => no limit.\n-            if limit > 0 && i >= limit {\n-                break\n-            }\n-\n-            let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(&text[last_match..s]);\n-            new.push_str(&rep.reg_replace(&cap)[]);\n-            last_match = e;\n-        }\n-        new.push_str(&text[last_match..text.len()]);\n-        return new;\n-    }\n-\n-    /// Returns the original string of this regex.\n-    pub fn as_str<'a>(&'a self) -> &'a str {\n-        match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => &original[],\n-            Native(ExNative { ref original, .. }) => &original[],\n-        }\n-    }\n-\n-    #[doc(hidden)]\n-    pub fn names_iter<'a>(&'a self) -> NamesIter<'a> {\n-        match *self {\n-            Native(ref n) => NamesIterNative(n.names.iter()),\n-            Dynamic(ref d) => NamesIterDynamic(d.names.iter())\n-        }\n-    }\n-\n-    fn names_len(&self) -> uint {\n-        match *self {\n-            Native(ref n) => n.names.len(),\n-            Dynamic(ref d) => d.names.len()\n-        }\n-    }\n-\n-}\n-\n-#[derive(Clone)]\n-pub enum NamesIter<'a> {\n-    NamesIterNative(::std::slice::Iter<'a, Option<&'static str>>),\n-    NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n-}\n-\n-impl<'a> Iterator for NamesIter<'a> {\n-    type Item = Option<String>;\n-\n-    fn next(&mut self) -> Option<Option<String>> {\n-        match *self {\n-            NamesIterNative(ref mut i) => i.next().map(|x| x.map(|s| s.to_string())),\n-            NamesIterDynamic(ref mut i) => i.next().map(|x| x.as_ref().map(|s| s.to_string())),\n-        }\n-    }\n-}\n-\n-/// NoExpand indicates literal string replacement.\n-///\n-/// It can be used with `replace` and `replace_all` to do a literal\n-/// string replacement without expanding `$name` to their corresponding\n-/// capture groups.\n-///\n-/// `'r` is the lifetime of the literal text.\n-pub struct NoExpand<'t>(pub &'t str);\n-\n-/// Replacer describes types that can be used to replace matches in a string.\n-pub trait Replacer {\n-    /// Returns a possibly owned string that is used to replace the match\n-    /// corresponding to the `caps` capture group.\n-    ///\n-    /// The `'a` lifetime refers to the lifetime of a borrowed string when\n-    /// a new owned string isn't needed (e.g., for `NoExpand`).\n-    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a>;\n-}\n-\n-impl<'t> Replacer for NoExpand<'t> {\n-    fn reg_replace<'a>(&'a mut self, _: &Captures) -> CowString<'a> {\n-        let NoExpand(s) = *self;\n-        s.into_cow()\n-    }\n-}\n-\n-impl<'t> Replacer for &'t str {\n-    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a> {\n-        caps.expand(*self).into_cow()\n-    }\n-}\n-\n-impl<F> Replacer for F where F: FnMut(&Captures) -> String {\n-    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a> {\n-        (*self)(caps).into_cow()\n-    }\n-}\n-\n-/// Yields all substrings delimited by a regular expression match.\n-///\n-/// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n-/// of the string being split.\n-#[derive(Clone)]\n-pub struct RegexSplits<'r, 't> {\n-    finder: FindMatches<'r, 't>,\n-    last: uint,\n-}\n-\n-impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n-    type Item = &'t str;\n-\n-    fn next(&mut self) -> Option<&'t str> {\n-        let text = self.finder.search;\n-        match self.finder.next() {\n-            None => {\n-                if self.last >= text.len() {\n-                    None\n-                } else {\n-                    let s = &text[self.last..text.len()];\n-                    self.last = text.len();\n-                    Some(s)\n-                }\n-            }\n-            Some((s, e)) => {\n-                let matched = &text[self.last..s];\n-                self.last = e;\n-                Some(matched)\n-            }\n-        }\n-    }\n-}\n-\n-/// Yields at most `N` substrings delimited by a regular expression match.\n-///\n-/// The last substring will be whatever remains after splitting.\n-///\n-/// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n-/// of the string being split.\n-#[derive(Clone)]\n-pub struct RegexSplitsN<'r, 't> {\n-    splits: RegexSplits<'r, 't>,\n-    cur: uint,\n-    limit: uint,\n-}\n-\n-impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n-    type Item = &'t str;\n-\n-    fn next(&mut self) -> Option<&'t str> {\n-        let text = self.splits.finder.search;\n-        if self.cur >= self.limit {\n-            None\n-        } else {\n-            self.cur += 1;\n-            if self.cur >= self.limit {\n-                Some(&text[self.splits.last..text.len()])\n-            } else {\n-                self.splits.next()\n-            }\n-        }\n-    }\n-}\n-\n-/// Captures represents a group of captured strings for a single match.\n-///\n-/// The 0th capture always corresponds to the entire match. Each subsequent\n-/// index corresponds to the next capture group in the regex.\n-/// If a capture group is named, then the matched string is *also* available\n-/// via the `name` method. (Note that the 0th capture is always unnamed and so\n-/// must be accessed with the `at` method.)\n-///\n-/// Positions returned from a capture group are always byte indices.\n-///\n-/// `'t` is the lifetime of the matched text.\n-pub struct Captures<'t> {\n-    text: &'t str,\n-    locs: CaptureLocs,\n-    named: Option<HashMap<String, uint>>,\n-}\n-\n-impl<'t> Captures<'t> {\n-    fn new(re: &Regex, search: &'t str, locs: CaptureLocs)\n-          -> Option<Captures<'t>> {\n-        if !has_match(&locs) {\n-            return None\n-        }\n-\n-        let named =\n-            if re.names_len() == 0 {\n-                None\n-            } else {\n-                let mut named = HashMap::new();\n-                for (i, name) in re.names_iter().enumerate() {\n-                    match name {\n-                        None => {},\n-                        Some(name) => {\n-                            named.insert(name, i);\n-                        }\n-                    }\n-                }\n-                Some(named)\n-            };\n-        Some(Captures {\n-            text: search,\n-            locs: locs,\n-            named: named,\n-        })\n-    }\n-\n-    /// Returns the start and end positions of the Nth capture group.\n-    /// Returns `None` if `i` is not a valid capture group or if the capture\n-    /// group did not match anything.\n-    /// The positions returned are *always* byte indices with respect to the\n-    /// original string matched.\n-    pub fn pos(&self, i: uint) -> Option<(uint, uint)> {\n-        let (s, e) = (i * 2, i * 2 + 1);\n-        if e >= self.locs.len() || self.locs[s].is_none() {\n-            // VM guarantees that each pair of locations are both Some or None.\n-            return None\n-        }\n-        Some((self.locs[s].unwrap(), self.locs[e].unwrap()))\n-    }\n-\n-    /// Returns the matched string for the capture group `i`.  If `i` isn't\n-    /// a valid capture group or didn't match anything, then `None` is\n-    /// returned.\n-    pub fn at(&self, i: uint) -> Option<&'t str> {\n-        match self.pos(i) {\n-            None => None,\n-            Some((s, e)) => Some(self.text.slice(s, e))\n-        }\n-    }\n-\n-    /// Returns the matched string for the capture group named `name`.  If\n-    /// `name` isn't a valid capture group or didn't match anything, then\n-    /// `None` is returned.\n-    pub fn name(&self, name: &str) -> Option<&'t str> {\n-        match self.named {\n-            None => None,\n-            Some(ref h) => {\n-                match h.get(name) {\n-                    None => None,\n-                    Some(i) => self.at(*i),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Creates an iterator of all the capture groups in order of appearance\n-    /// in the regular expression.\n-    pub fn iter(&'t self) -> SubCaptures<'t> {\n-        SubCaptures { idx: 0, caps: self, }\n-    }\n-\n-    /// Creates an iterator of all the capture group positions in order of\n-    /// appearance in the regular expression. Positions are byte indices\n-    /// in terms of the original string matched.\n-    pub fn iter_pos(&'t self) -> SubCapturesPos<'t> {\n-        SubCapturesPos { idx: 0, caps: self, }\n-    }\n-\n-    /// Expands all instances of `$name` in `text` to the corresponding capture\n-    /// group `name`.\n-    ///\n-    /// `name` may be an integer corresponding to the index of the\n-    /// capture group (counted by order of opening parenthesis where `0` is the\n-    /// entire match) or it can be a name (consisting of letters, digits or\n-    /// underscores) corresponding to a named capture group.\n-    ///\n-    /// If `name` isn't a valid capture group (whether the name doesn't exist or\n-    /// isn't a valid index), then it is replaced with the empty string.\n-    ///\n-    /// To write a literal `$` use `$$`.\n-    pub fn expand(&self, text: &str) -> String {\n-        // How evil can you get?\n-        // FIXME: Don't use regexes for this. It's completely unnecessary.\n-        let re = Regex::new(r\"(^|[^$]|\\b)\\$(\\w+)\").unwrap();\n-        let text = re.replace_all(text, |&mut: refs: &Captures| -> String {\n-            let pre = refs.at(1).unwrap_or(\"\");\n-            let name = refs.at(2).unwrap_or(\"\");\n-            format!(\"{}{}\", pre,\n-                    match name.parse::<uint>() {\n-                None => self.name(name).unwrap_or(\"\").to_string(),\n-                Some(i) => self.at(i).unwrap_or(\"\").to_string(),\n-            })\n-        });\n-        let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(&text[], NoExpand(\"$\"))\n-    }\n-\n-    /// Returns the number of captured groups.\n-    #[inline]\n-    pub fn len(&self) -> uint { self.locs.len() / 2 }\n-\n-    /// Returns if there are no captured groups.\n-    #[inline]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-}\n-\n-/// An iterator over capture groups for a particular match of a regular\n-/// expression.\n-///\n-/// `'t` is the lifetime of the matched text.\n-#[derive(Clone)]\n-pub struct SubCaptures<'t> {\n-    idx: uint,\n-    caps: &'t Captures<'t>,\n-}\n-\n-impl<'t> Iterator for SubCaptures<'t> {\n-    type Item = &'t str;\n-\n-    fn next(&mut self) -> Option<&'t str> {\n-        if self.idx < self.caps.len() {\n-            self.idx += 1;\n-            Some(self.caps.at(self.idx - 1).unwrap_or(\"\"))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// An iterator over capture group positions for a particular match of a\n-/// regular expression.\n-///\n-/// Positions are byte indices in terms of the original string matched.\n-///\n-/// `'t` is the lifetime of the matched text.\n-#[derive(Clone)]\n-pub struct SubCapturesPos<'t> {\n-    idx: uint,\n-    caps: &'t Captures<'t>,\n-}\n-\n-impl<'t> Iterator for SubCapturesPos<'t> {\n-    type Item = Option<(uint, uint)>;\n-\n-    fn next(&mut self) -> Option<Option<(uint, uint)>> {\n-        if self.idx < self.caps.len() {\n-            self.idx += 1;\n-            Some(self.caps.pos(self.idx - 1))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// An iterator that yields all non-overlapping capture groups matching a\n-/// particular regular expression.\n-///\n-/// The iterator stops when no more matches can be found.\n-///\n-/// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n-/// of the matched string.\n-#[derive(Clone)]\n-pub struct FindCaptures<'r, 't> {\n-    re: &'r Regex,\n-    search: &'t str,\n-    last_match: Option<uint>,\n-    last_end: uint,\n-}\n-\n-impl<'r, 't> Iterator for FindCaptures<'r, 't> {\n-    type Item = Captures<'t>;\n-\n-    fn next(&mut self) -> Option<Captures<'t>> {\n-        if self.last_end > self.search.len() {\n-            return None\n-        }\n-\n-        let caps = exec_slice(self.re, Submatches, self.search,\n-                              self.last_end, self.search.len());\n-        let (s, e) =\n-            if !has_match(&caps) {\n-                return None\n-            } else {\n-                (caps[0].unwrap(), caps[1].unwrap())\n-            };\n-\n-        // Don't accept empty matches immediately following a match.\n-        // i.e., no infinite loops please.\n-        if e == s && Some(self.last_end) == self.last_match {\n-            self.last_end += 1;\n-            return self.next()\n-        }\n-        self.last_end = e;\n-        self.last_match = Some(self.last_end);\n-        Captures::new(self.re, self.search, caps)\n-    }\n-}\n-\n-/// An iterator over all non-overlapping matches for a particular string.\n-///\n-/// The iterator yields a tuple of integers corresponding to the start and end\n-/// of the match. The indices are byte offsets. The iterator stops when no more\n-/// matches can be found.\n-///\n-/// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n-/// of the matched string.\n-#[derive(Clone)]\n-pub struct FindMatches<'r, 't> {\n-    re: &'r Regex,\n-    search: &'t str,\n-    last_match: Option<uint>,\n-    last_end: uint,\n-}\n-\n-impl<'r, 't> Iterator for FindMatches<'r, 't> {\n-    type Item = (uint, uint);\n-\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        if self.last_end > self.search.len() {\n-            return None\n-        }\n-\n-        let caps = exec_slice(self.re, Location, self.search,\n-                              self.last_end, self.search.len());\n-        let (s, e) =\n-            if !has_match(&caps) {\n-                return None\n-            } else {\n-                (caps[0].unwrap(), caps[1].unwrap())\n-            };\n-\n-        // Don't accept empty matches immediately following a match.\n-        // i.e., no infinite loops please.\n-        if e == s && Some(self.last_end) == self.last_match {\n-            self.last_end += 1;\n-            return self.next()\n-        }\n-        self.last_end = e;\n-        self.last_match = Some(self.last_end);\n-        Some((s, e))\n-    }\n-}\n-\n-fn exec(re: &Regex, which: MatchKind, input: &str) -> CaptureLocs {\n-    exec_slice(re, which, input, 0, input.len())\n-}\n-\n-fn exec_slice(re: &Regex, which: MatchKind,\n-              input: &str, s: uint, e: uint) -> CaptureLocs {\n-    match *re {\n-        Dynamic(ExDynamic { ref prog, .. }) => vm::run(which, prog, input, s, e),\n-        Native(ExNative { ref prog, .. }) => (*prog)(which, input, s, e),\n-    }\n-}\n-\n-#[inline]\n-fn has_match(caps: &CaptureLocs) -> bool {\n-    caps.len() >= 2 && caps[0].is_some() && caps[1].is_some()\n-}"}, {"sha": "17521ff7ea54bb9ebcdaf01e6298451bdb21e68e", "filename": "src/libregex/test/bench.rs", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,183 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-#![allow(non_snake_case)]\n-\n-use std::rand::{Rng, thread_rng};\n-use stdtest::Bencher;\n-use std::iter::repeat;\n-\n-use regex::{Regex, NoExpand};\n-\n-fn bench_assert_match(b: &mut Bencher, re: Regex, text: &str) {\n-    b.iter(|| if !re.is_match(text) { panic!(\"no match\") });\n-}\n-\n-#[bench]\n-fn no_exponential(b: &mut Bencher) {\n-    let n = 100;\n-    let re = Regex::new(format!(\"{}{}\",\n-                                repeat(\"a?\").take(n).collect::<String>(),\n-                                repeat(\"a\").take(n).collect::<String>()).as_slice()).unwrap();\n-    let text = repeat(\"a\").take(n).collect::<String>();\n-    bench_assert_match(b, re, text.as_slice());\n-}\n-\n-#[bench]\n-fn literal(b: &mut Bencher) {\n-    let re = regex!(\"y\");\n-    let text = format!(\"{}y\", repeat(\"x\").take(50).collect::<String>());\n-    bench_assert_match(b, re, text.as_slice());\n-}\n-\n-#[bench]\n-fn not_literal(b: &mut Bencher) {\n-    let re = regex!(\".y\");\n-    let text = format!(\"{}y\", repeat(\"x\").take(50).collect::<String>());\n-    bench_assert_match(b, re, text.as_slice());\n-}\n-\n-#[bench]\n-fn match_class(b: &mut Bencher) {\n-    let re = regex!(\"[abcdw]\");\n-    let text = format!(\"{}w\", repeat(\"xxxx\").take(20).collect::<String>());\n-    bench_assert_match(b, re, text.as_slice());\n-}\n-\n-#[bench]\n-fn match_class_in_range(b: &mut Bencher) {\n-    // 'b' is between 'a' and 'c', so the class range checking doesn't help.\n-    let re = regex!(\"[ac]\");\n-    let text = format!(\"{}c\", repeat(\"bbbb\").take(20).collect::<String>());\n-    bench_assert_match(b, re, text.as_slice());\n-}\n-\n-#[bench]\n-fn replace_all(b: &mut Bencher) {\n-    let re = regex!(\"[cjrw]\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\";\n-    // FIXME: This isn't using the $name expand stuff.\n-    // It's possible RE2/Go is using it, but currently, the expand in this\n-    // crate is actually compiling a regex, so it's incredibly slow.\n-    b.iter(|| re.replace_all(text, NoExpand(\"\")));\n-}\n-\n-#[bench]\n-fn anchored_literal_short_non_match(b: &mut Bencher) {\n-    let re = regex!(\"^zbc(d|e)\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn anchored_literal_long_non_match(b: &mut Bencher) {\n-    let re = regex!(\"^zbc(d|e)\");\n-    let text = repeat(\"abcdefghijklmnopqrstuvwxyz\").take(15).collect::<String>();\n-    b.iter(|| re.is_match(text.as_slice()));\n-}\n-\n-#[bench]\n-fn anchored_literal_short_match(b: &mut Bencher) {\n-    let re = regex!(\"^.bc(d|e)\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn anchored_literal_long_match(b: &mut Bencher) {\n-    let re = regex!(\"^.bc(d|e)\");\n-    let text = repeat(\"abcdefghijklmnopqrstuvwxyz\").take(15).collect::<String>();\n-    b.iter(|| re.is_match(text.as_slice()));\n-}\n-\n-#[bench]\n-fn one_pass_short_a(b: &mut Bencher) {\n-    let re = regex!(\"^.bc(d|e)*$\");\n-    let text = \"abcddddddeeeededd\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn one_pass_short_a_not(b: &mut Bencher) {\n-    let re = regex!(\".bc(d|e)*$\");\n-    let text = \"abcddddddeeeededd\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn one_pass_short_b(b: &mut Bencher) {\n-    let re = regex!(\"^.bc(?:d|e)*$\");\n-    let text = \"abcddddddeeeededd\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn one_pass_short_b_not(b: &mut Bencher) {\n-    let re = regex!(\".bc(?:d|e)*$\");\n-    let text = \"abcddddddeeeededd\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn one_pass_long_prefix(b: &mut Bencher) {\n-    let re = regex!(\"^abcdefghijklmnopqrstuvwxyz.*$\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-#[bench]\n-fn one_pass_long_prefix_not(b: &mut Bencher) {\n-    let re = regex!(\"^.bcdefghijklmnopqrstuvwxyz.*$\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\";\n-    b.iter(|| re.is_match(text));\n-}\n-\n-macro_rules! throughput {\n-    ($name:ident, $regex:expr, $size:expr) => (\n-        #[bench]\n-        fn $name(b: &mut Bencher) {\n-            let text = gen_text($size);\n-            b.bytes = $size;\n-            b.iter(|| if $regex.is_match(text.as_slice()) { panic!(\"match\") });\n-        }\n-    );\n-}\n-\n-fn easy0() -> Regex { regex!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n-fn easy1() -> Regex { regex!(\"A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$\") }\n-fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n-fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n-\n-fn gen_text(n: uint) -> String {\n-    let mut rng = thread_rng();\n-    let mut bytes = rng.gen_ascii_chars().map(|n| n as u8).take(n)\n-                       .collect::<Vec<u8>>();\n-    for (i, b) in bytes.iter_mut().enumerate() {\n-        if i % 20 == 0 {\n-            *b = b'\\n'\n-        }\n-    }\n-    String::from_utf8(bytes).unwrap()\n-}\n-\n-throughput!{easy0_32, easy0(), 32}\n-throughput!{easy0_1K, easy0(), 1<<10}\n-throughput!{easy0_32K, easy0(), 32<<10}\n-\n-throughput!{easy1_32, easy1(), 32}\n-throughput!{easy1_1K, easy1(), 1<<10}\n-throughput!{easy1_32K, easy1(), 32<<10}\n-\n-throughput!{medium_32, medium(), 32}\n-throughput!{medium_1K, medium(), 1<<10}\n-throughput!{medium_32K,medium(), 32<<10}\n-\n-throughput!{hard_32, hard(), 32}\n-throughput!{hard_1K, hard(), 1<<10}\n-throughput!{hard_32K,hard(), 32<<10}"}, {"sha": "7508f4c50a2c313ff373fee34e22901c9565e005", "filename": "src/libregex/test/matches.rs", "status": "removed", "additions": 0, "deletions": 373, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmatches.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,373 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-// DO NOT EDIT. Automatically generated by 'src/etc/regex-match-tests'\n-// on 2014-04-23 01:33:36.539280.\n-\n-// Tests from basic.dat\n-mat!{match_basic_3, r\"abracadabra$\", r\"abracadabracadabra\", Some((7, 18))}\n-mat!{match_basic_4, r\"a...b\", r\"abababbb\", Some((2, 7))}\n-mat!{match_basic_5, r\"XXXXXX\", r\"..XXXXXX\", Some((2, 8))}\n-mat!{match_basic_6, r\"\\)\", r\"()\", Some((1, 2))}\n-mat!{match_basic_7, r\"a]\", r\"a]a\", Some((0, 2))}\n-mat!{match_basic_9, r\"\\}\", r\"}\", Some((0, 1))}\n-mat!{match_basic_10, r\"\\]\", r\"]\", Some((0, 1))}\n-mat!{match_basic_12, r\"]\", r\"]\", Some((0, 1))}\n-mat!{match_basic_15, r\"^a\", r\"ax\", Some((0, 1))}\n-mat!{match_basic_16, r\"\\^a\", r\"a^a\", Some((1, 3))}\n-mat!{match_basic_17, r\"a\\^\", r\"a^\", Some((0, 2))}\n-mat!{match_basic_18, r\"a$\", r\"aa\", Some((1, 2))}\n-mat!{match_basic_19, r\"a\\$\", r\"a$\", Some((0, 2))}\n-mat!{match_basic_20, r\"^$\", r\"\", Some((0, 0))}\n-mat!{match_basic_21, r\"$^\", r\"\", Some((0, 0))}\n-mat!{match_basic_22, r\"a($)\", r\"aa\", Some((1, 2)), Some((2, 2))}\n-mat!{match_basic_23, r\"a*(^a)\", r\"aa\", Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_24, r\"(..)*(...)*\", r\"a\", Some((0, 0))}\n-mat!{match_basic_25, r\"(..)*(...)*\", r\"abcd\", Some((0, 4)), Some((2, 4))}\n-mat!{match_basic_26, r\"(ab|a)(bc|c)\", r\"abc\", Some((0, 3)), Some((0, 2)), Some((2, 3))}\n-mat!{match_basic_27, r\"(ab)c|abc\", r\"abc\", Some((0, 3)), Some((0, 2))}\n-mat!{match_basic_28, r\"a{0}b\", r\"ab\", Some((1, 2))}\n-mat!{match_basic_29, r\"(a*)(b?)(b+)b{3}\", r\"aaabbbbbbb\", Some((0, 10)), Some((0, 3)), Some((3, 4)), Some((4, 7))}\n-mat!{match_basic_30, r\"(a*)(b{0,1})(b{1,})b{3}\", r\"aaabbbbbbb\", Some((0, 10)), Some((0, 3)), Some((3, 4)), Some((4, 7))}\n-mat!{match_basic_32, r\"((a|a)|a)\", r\"a\", Some((0, 1)), Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_33, r\"(a*)(a|aa)\", r\"aaaa\", Some((0, 4)), Some((0, 3)), Some((3, 4))}\n-mat!{match_basic_34, r\"a*(a.|aa)\", r\"aaaa\", Some((0, 4)), Some((2, 4))}\n-mat!{match_basic_35, r\"a(b)|c(d)|a(e)f\", r\"aef\", Some((0, 3)), None, None, Some((1, 2))}\n-mat!{match_basic_36, r\"(a|b)?.*\", r\"b\", Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_37, r\"(a|b)c|a(b|c)\", r\"ac\", Some((0, 2)), Some((0, 1))}\n-mat!{match_basic_38, r\"(a|b)c|a(b|c)\", r\"ab\", Some((0, 2)), None, Some((1, 2))}\n-mat!{match_basic_39, r\"(a|b)*c|(a|ab)*c\", r\"abc\", Some((0, 3)), Some((1, 2))}\n-mat!{match_basic_40, r\"(a|b)*c|(a|ab)*c\", r\"xc\", Some((1, 2))}\n-mat!{match_basic_41, r\"(.a|.b).*|.*(.a|.b)\", r\"xa\", Some((0, 2)), Some((0, 2))}\n-mat!{match_basic_42, r\"a?(ab|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2))}\n-mat!{match_basic_43, r\"a?(ac{0}b|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2))}\n-mat!{match_basic_44, r\"ab|abab\", r\"abbabab\", Some((0, 2))}\n-mat!{match_basic_45, r\"aba|bab|bba\", r\"baaabbbaba\", Some((5, 8))}\n-mat!{match_basic_46, r\"aba|bab\", r\"baaabbbaba\", Some((6, 9))}\n-mat!{match_basic_47, r\"(aa|aaa)*|(a|aaaaa)\", r\"aa\", Some((0, 2)), Some((0, 2))}\n-mat!{match_basic_48, r\"(a.|.a.)*|(a|.a...)\", r\"aa\", Some((0, 2)), Some((0, 2))}\n-mat!{match_basic_49, r\"ab|a\", r\"xabc\", Some((1, 3))}\n-mat!{match_basic_50, r\"ab|a\", r\"xxabc\", Some((2, 4))}\n-mat!{match_basic_51, r\"(?i)(Ab|cD)*\", r\"aBcD\", Some((0, 4)), Some((2, 4))}\n-mat!{match_basic_52, r\"[^-]\", r\"--a\", Some((2, 3))}\n-mat!{match_basic_53, r\"[a-]*\", r\"--a\", Some((0, 3))}\n-mat!{match_basic_54, r\"[a-m-]*\", r\"--amoma--\", Some((0, 4))}\n-mat!{match_basic_55, r\":::1:::0:|:::1:1:0:\", r\":::0:::1:::1:::0:\", Some((8, 17))}\n-mat!{match_basic_56, r\":::1:::0:|:::1:1:1:\", r\":::0:::1:::1:::0:\", Some((8, 17))}\n-mat!{match_basic_57, r\"[[:upper:]]\", r\"A\", Some((0, 1))}\n-mat!{match_basic_58, r\"[[:lower:]]+\", r\"`az{\", Some((1, 3))}\n-mat!{match_basic_59, r\"[[:upper:]]+\", r\"@AZ[\", Some((1, 3))}\n-mat!{match_basic_65, r\"\n-\", r\"\n-\", Some((0, 1))}\n-mat!{match_basic_66, r\"\n-\", r\"\n-\", Some((0, 1))}\n-mat!{match_basic_67, r\"[^a]\", r\"\n-\", Some((0, 1))}\n-mat!{match_basic_68, r\"\n-a\", r\"\n-a\", Some((0, 2))}\n-mat!{match_basic_69, r\"(a)(b)(c)\", r\"abc\", Some((0, 3)), Some((0, 1)), Some((1, 2)), Some((2, 3))}\n-mat!{match_basic_70, r\"xxx\", r\"xxx\", Some((0, 3))}\n-mat!{match_basic_71, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"feb 6,\", Some((0, 6))}\n-mat!{match_basic_72, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"2/7\", Some((0, 3))}\n-mat!{match_basic_73, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"feb 1,Feb 6\", Some((5, 11))}\n-mat!{match_basic_74, r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))\", r\"x\", Some((0, 1)), Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_75, r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))*\", r\"xx\", Some((0, 2)), Some((1, 2)), Some((1, 2))}\n-mat!{match_basic_76, r\"a?(ab|ba)*\", r\"ababababababababababababababababababababababababababababababababababababababababa\", Some((0, 81)), Some((79, 81))}\n-mat!{match_basic_77, r\"abaa|abbaa|abbbaa|abbbbaa\", r\"ababbabbbabbbabbbbabbbbaa\", Some((18, 25))}\n-mat!{match_basic_78, r\"abaa|abbaa|abbbaa|abbbbaa\", r\"ababbabbbabbbabbbbabaa\", Some((18, 22))}\n-mat!{match_basic_79, r\"aaac|aabc|abac|abbc|baac|babc|bbac|bbbc\", r\"baaabbbabac\", Some((7, 11))}\n-mat!{match_basic_80, r\".*\", r\"\u0001\u007f\", Some((0, 2))}\n-mat!{match_basic_81, r\"aaaa|bbbb|cccc|ddddd|eeeeee|fffffff|gggg|hhhh|iiiii|jjjjj|kkkkk|llll\", r\"XaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa\", Some((53, 57))}\n-mat!{match_basic_83, r\"a*a*a*a*a*b\", r\"aaaaaaaaab\", Some((0, 10))}\n-mat!{match_basic_84, r\"^\", r\"\", Some((0, 0))}\n-mat!{match_basic_85, r\"$\", r\"\", Some((0, 0))}\n-mat!{match_basic_86, r\"^$\", r\"\", Some((0, 0))}\n-mat!{match_basic_87, r\"^a$\", r\"a\", Some((0, 1))}\n-mat!{match_basic_88, r\"abc\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_89, r\"abc\", r\"xabcy\", Some((1, 4))}\n-mat!{match_basic_90, r\"abc\", r\"ababc\", Some((2, 5))}\n-mat!{match_basic_91, r\"ab*c\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_92, r\"ab*bc\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_93, r\"ab*bc\", r\"abbc\", Some((0, 4))}\n-mat!{match_basic_94, r\"ab*bc\", r\"abbbbc\", Some((0, 6))}\n-mat!{match_basic_95, r\"ab+bc\", r\"abbc\", Some((0, 4))}\n-mat!{match_basic_96, r\"ab+bc\", r\"abbbbc\", Some((0, 6))}\n-mat!{match_basic_97, r\"ab?bc\", r\"abbc\", Some((0, 4))}\n-mat!{match_basic_98, r\"ab?bc\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_99, r\"ab?c\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_100, r\"^abc$\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_101, r\"^abc\", r\"abcc\", Some((0, 3))}\n-mat!{match_basic_102, r\"abc$\", r\"aabc\", Some((1, 4))}\n-mat!{match_basic_103, r\"^\", r\"abc\", Some((0, 0))}\n-mat!{match_basic_104, r\"$\", r\"abc\", Some((3, 3))}\n-mat!{match_basic_105, r\"a.c\", r\"abc\", Some((0, 3))}\n-mat!{match_basic_106, r\"a.c\", r\"axc\", Some((0, 3))}\n-mat!{match_basic_107, r\"a.*c\", r\"axyzc\", Some((0, 5))}\n-mat!{match_basic_108, r\"a[bc]d\", r\"abd\", Some((0, 3))}\n-mat!{match_basic_109, r\"a[b-d]e\", r\"ace\", Some((0, 3))}\n-mat!{match_basic_110, r\"a[b-d]\", r\"aac\", Some((1, 3))}\n-mat!{match_basic_111, r\"a[-b]\", r\"a-\", Some((0, 2))}\n-mat!{match_basic_112, r\"a[b-]\", r\"a-\", Some((0, 2))}\n-mat!{match_basic_113, r\"a]\", r\"a]\", Some((0, 2))}\n-mat!{match_basic_114, r\"a[]]b\", r\"a]b\", Some((0, 3))}\n-mat!{match_basic_115, r\"a[^bc]d\", r\"aed\", Some((0, 3))}\n-mat!{match_basic_116, r\"a[^-b]c\", r\"adc\", Some((0, 3))}\n-mat!{match_basic_117, r\"a[^]b]c\", r\"adc\", Some((0, 3))}\n-mat!{match_basic_118, r\"ab|cd\", r\"abc\", Some((0, 2))}\n-mat!{match_basic_119, r\"ab|cd\", r\"abcd\", Some((0, 2))}\n-mat!{match_basic_120, r\"a\\(b\", r\"a(b\", Some((0, 3))}\n-mat!{match_basic_121, r\"a\\(*b\", r\"ab\", Some((0, 2))}\n-mat!{match_basic_122, r\"a\\(*b\", r\"a((b\", Some((0, 4))}\n-mat!{match_basic_123, r\"((a))\", r\"abc\", Some((0, 1)), Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_124, r\"(a)b(c)\", r\"abc\", Some((0, 3)), Some((0, 1)), Some((2, 3))}\n-mat!{match_basic_125, r\"a+b+c\", r\"aabbabc\", Some((4, 7))}\n-mat!{match_basic_126, r\"a*\", r\"aaa\", Some((0, 3))}\n-mat!{match_basic_128, r\"(a*)*\", r\"-\", Some((0, 0)), None}\n-mat!{match_basic_129, r\"(a*)+\", r\"-\", Some((0, 0)), Some((0, 0))}\n-mat!{match_basic_131, r\"(a*|b)*\", r\"-\", Some((0, 0)), None}\n-mat!{match_basic_132, r\"(a+|b)*\", r\"ab\", Some((0, 2)), Some((1, 2))}\n-mat!{match_basic_133, r\"(a+|b)+\", r\"ab\", Some((0, 2)), Some((1, 2))}\n-mat!{match_basic_134, r\"(a+|b)?\", r\"ab\", Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_135, r\"[^ab]*\", r\"cde\", Some((0, 3))}\n-mat!{match_basic_137, r\"(^)*\", r\"-\", Some((0, 0)), None}\n-mat!{match_basic_138, r\"a*\", r\"\", Some((0, 0))}\n-mat!{match_basic_139, r\"([abc])*d\", r\"abbbcd\", Some((0, 6)), Some((4, 5))}\n-mat!{match_basic_140, r\"([abc])*bcd\", r\"abcd\", Some((0, 4)), Some((0, 1))}\n-mat!{match_basic_141, r\"a|b|c|d|e\", r\"e\", Some((0, 1))}\n-mat!{match_basic_142, r\"(a|b|c|d|e)f\", r\"ef\", Some((0, 2)), Some((0, 1))}\n-mat!{match_basic_144, r\"((a*|b))*\", r\"-\", Some((0, 0)), None, None}\n-mat!{match_basic_145, r\"abcd*efg\", r\"abcdefg\", Some((0, 7))}\n-mat!{match_basic_146, r\"ab*\", r\"xabyabbbz\", Some((1, 3))}\n-mat!{match_basic_147, r\"ab*\", r\"xayabbbz\", Some((1, 2))}\n-mat!{match_basic_148, r\"(ab|cd)e\", r\"abcde\", Some((2, 5)), Some((2, 4))}\n-mat!{match_basic_149, r\"[abhgefdc]ij\", r\"hij\", Some((0, 3))}\n-mat!{match_basic_150, r\"(a|b)c*d\", r\"abcd\", Some((1, 4)), Some((1, 2))}\n-mat!{match_basic_151, r\"(ab|ab*)bc\", r\"abc\", Some((0, 3)), Some((0, 1))}\n-mat!{match_basic_152, r\"a([bc]*)c*\", r\"abc\", Some((0, 3)), Some((1, 3))}\n-mat!{match_basic_153, r\"a([bc]*)(c*d)\", r\"abcd\", Some((0, 4)), Some((1, 3)), Some((3, 4))}\n-mat!{match_basic_154, r\"a([bc]+)(c*d)\", r\"abcd\", Some((0, 4)), Some((1, 3)), Some((3, 4))}\n-mat!{match_basic_155, r\"a([bc]*)(c+d)\", r\"abcd\", Some((0, 4)), Some((1, 2)), Some((2, 4))}\n-mat!{match_basic_156, r\"a[bcd]*dcdcde\", r\"adcdcde\", Some((0, 7))}\n-mat!{match_basic_157, r\"(ab|a)b*c\", r\"abc\", Some((0, 3)), Some((0, 2))}\n-mat!{match_basic_158, r\"((a)(b)c)(d)\", r\"abcd\", Some((0, 4)), Some((0, 3)), Some((0, 1)), Some((1, 2)), Some((3, 4))}\n-mat!{match_basic_159, r\"[A-Za-z_][A-Za-z0-9_]*\", r\"alpha\", Some((0, 5))}\n-mat!{match_basic_160, r\"^a(bc+|b[eh])g|.h$\", r\"abh\", Some((1, 3))}\n-mat!{match_basic_161, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"effgz\", Some((0, 5)), Some((0, 5))}\n-mat!{match_basic_162, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"ij\", Some((0, 2)), Some((0, 2)), Some((1, 2))}\n-mat!{match_basic_163, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"reffgz\", Some((1, 6)), Some((1, 6))}\n-mat!{match_basic_164, r\"(((((((((a)))))))))\", r\"a\", Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1))}\n-mat!{match_basic_165, r\"multiple words\", r\"multiple words yeah\", Some((0, 14))}\n-mat!{match_basic_166, r\"(.*)c(.*)\", r\"abcde\", Some((0, 5)), Some((0, 2)), Some((3, 5))}\n-mat!{match_basic_167, r\"abcd\", r\"abcd\", Some((0, 4))}\n-mat!{match_basic_168, r\"a(bc)d\", r\"abcd\", Some((0, 4)), Some((1, 3))}\n-mat!{match_basic_169, r\"a[\u0001-\u0003]?c\", r\"a\u0002c\", Some((0, 3))}\n-mat!{match_basic_170, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Qaddafi\", Some((0, 15)), None, Some((10, 12))}\n-mat!{match_basic_171, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mo'ammar Gadhafi\", Some((0, 16)), None, Some((11, 13))}\n-mat!{match_basic_172, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Kaddafi\", Some((0, 15)), None, Some((10, 12))}\n-mat!{match_basic_173, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Qadhafi\", Some((0, 15)), None, Some((10, 12))}\n-mat!{match_basic_174, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Gadafi\", Some((0, 14)), None, Some((10, 11))}\n-mat!{match_basic_175, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mu'ammar Qadafi\", Some((0, 15)), None, Some((11, 12))}\n-mat!{match_basic_176, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moamar Gaddafi\", Some((0, 14)), None, Some((9, 11))}\n-mat!{match_basic_177, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mu'ammar Qadhdhafi\", Some((0, 18)), None, Some((13, 15))}\n-mat!{match_basic_178, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Khaddafi\", Some((0, 16)), None, Some((11, 13))}\n-mat!{match_basic_179, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghaddafy\", Some((0, 16)), None, Some((11, 13))}\n-mat!{match_basic_180, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghadafi\", Some((0, 15)), None, Some((11, 12))}\n-mat!{match_basic_181, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghaddafi\", Some((0, 16)), None, Some((11, 13))}\n-mat!{match_basic_182, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muamar Kaddafi\", Some((0, 14)), None, Some((9, 11))}\n-mat!{match_basic_183, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Quathafi\", Some((0, 16)), None, Some((11, 13))}\n-mat!{match_basic_184, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Gheddafi\", Some((0, 16)), None, Some((11, 13))}\n-mat!{match_basic_185, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moammar Khadafy\", Some((0, 15)), None, Some((11, 12))}\n-mat!{match_basic_186, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moammar Qudhafi\", Some((0, 15)), None, Some((10, 12))}\n-mat!{match_basic_187, r\"a+(b|c)*d+\", r\"aabcdd\", Some((0, 6)), Some((3, 4))}\n-mat!{match_basic_188, r\"^.+$\", r\"vivi\", Some((0, 4))}\n-mat!{match_basic_189, r\"^(.+)$\", r\"vivi\", Some((0, 4)), Some((0, 4))}\n-mat!{match_basic_190, r\"^([^!.]+).att.com!(.+)$\", r\"gryphon.att.com!eby\", Some((0, 19)), Some((0, 7)), Some((16, 19))}\n-mat!{match_basic_191, r\"^([^!]+!)?([^!]+)$\", r\"bas\", Some((0, 3)), None, Some((0, 3))}\n-mat!{match_basic_192, r\"^([^!]+!)?([^!]+)$\", r\"bar!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n-mat!{match_basic_193, r\"^([^!]+!)?([^!]+)$\", r\"foo!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n-mat!{match_basic_194, r\"^.+!([^!]+!)([^!]+)$\", r\"foo!bar!bas\", Some((0, 11)), Some((4, 8)), Some((8, 11))}\n-mat!{match_basic_195, r\"((foo)|(bar))!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)), None, Some((0, 3))}\n-mat!{match_basic_196, r\"((foo)|(bar))!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)), None, Some((4, 7))}\n-mat!{match_basic_197, r\"((foo)|(bar))!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3))}\n-mat!{match_basic_198, r\"((foo)|bar)!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3))}\n-mat!{match_basic_199, r\"((foo)|bar)!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7))}\n-mat!{match_basic_200, r\"((foo)|bar)!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3))}\n-mat!{match_basic_201, r\"(foo|(bar))!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3))}\n-mat!{match_basic_202, r\"(foo|(bar))!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)), Some((4, 7))}\n-mat!{match_basic_203, r\"(foo|(bar))!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3))}\n-mat!{match_basic_204, r\"(foo|bar)!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3))}\n-mat!{match_basic_205, r\"(foo|bar)!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7))}\n-mat!{match_basic_206, r\"(foo|bar)!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3))}\n-mat!{match_basic_207, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bar!bas\", Some((0, 11)), Some((0, 11)), None, None, Some((4, 8)), Some((8, 11))}\n-mat!{match_basic_208, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"bas\", Some((0, 3)), None, Some((0, 3))}\n-mat!{match_basic_209, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"bar!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n-mat!{match_basic_210, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"foo!bar!bas\", Some((0, 11)), None, None, Some((4, 8)), Some((8, 11))}\n-mat!{match_basic_211, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"foo!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n-mat!{match_basic_212, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"bas\", Some((0, 3)), Some((0, 3)), None, Some((0, 3))}\n-mat!{match_basic_213, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"bar!bas\", Some((0, 7)), Some((0, 7)), Some((0, 4)), Some((4, 7))}\n-mat!{match_basic_214, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bar!bas\", Some((0, 11)), Some((0, 11)), None, None, Some((4, 8)), Some((8, 11))}\n-mat!{match_basic_215, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bas\", Some((0, 7)), Some((0, 7)), Some((0, 4)), Some((4, 7))}\n-mat!{match_basic_216, r\".*(/XXX).*\", r\"/XXX\", Some((0, 4)), Some((0, 4))}\n-mat!{match_basic_217, r\".*(\\\\XXX).*\", r\"\\XXX\", Some((0, 4)), Some((0, 4))}\n-mat!{match_basic_218, r\"\\\\XXX\", r\"\\XXX\", Some((0, 4))}\n-mat!{match_basic_219, r\".*(/000).*\", r\"/000\", Some((0, 4)), Some((0, 4))}\n-mat!{match_basic_220, r\".*(\\\\000).*\", r\"\\000\", Some((0, 4)), Some((0, 4))}\n-mat!{match_basic_221, r\"\\\\000\", r\"\\000\", Some((0, 4))}\n-\n-// Tests from nullsubexpr.dat\n-mat!{match_nullsubexpr_3, r\"(a*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_5, r\"(a*)*\", r\"x\", Some((0, 0)), None}\n-mat!{match_nullsubexpr_6, r\"(a*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_7, r\"(a*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_8, r\"(a*)+\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_9, r\"(a*)+\", r\"x\", Some((0, 0)), Some((0, 0))}\n-mat!{match_nullsubexpr_10, r\"(a*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_11, r\"(a*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_12, r\"(a+)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_13, r\"(a+)*\", r\"x\", Some((0, 0))}\n-mat!{match_nullsubexpr_14, r\"(a+)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_15, r\"(a+)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_16, r\"(a+)+\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_17, r\"(a+)+\", r\"x\", None}\n-mat!{match_nullsubexpr_18, r\"(a+)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_19, r\"(a+)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_21, r\"([a]*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_23, r\"([a]*)*\", r\"x\", Some((0, 0)), None}\n-mat!{match_nullsubexpr_24, r\"([a]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_25, r\"([a]*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_26, r\"([a]*)+\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_27, r\"([a]*)+\", r\"x\", Some((0, 0)), Some((0, 0))}\n-mat!{match_nullsubexpr_28, r\"([a]*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_29, r\"([a]*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_30, r\"([^b]*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_32, r\"([^b]*)*\", r\"b\", Some((0, 0)), None}\n-mat!{match_nullsubexpr_33, r\"([^b]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_34, r\"([^b]*)*\", r\"aaaaaab\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_35, r\"([ab]*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_36, r\"([ab]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_37, r\"([ab]*)*\", r\"ababab\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_38, r\"([ab]*)*\", r\"bababa\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_39, r\"([ab]*)*\", r\"b\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_40, r\"([ab]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_41, r\"([ab]*)*\", r\"aaaabcde\", Some((0, 5)), Some((0, 5))}\n-mat!{match_nullsubexpr_42, r\"([^a]*)*\", r\"b\", Some((0, 1)), Some((0, 1))}\n-mat!{match_nullsubexpr_43, r\"([^a]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_45, r\"([^a]*)*\", r\"aaaaaa\", Some((0, 0)), None}\n-mat!{match_nullsubexpr_46, r\"([^ab]*)*\", r\"ccccxx\", Some((0, 6)), Some((0, 6))}\n-mat!{match_nullsubexpr_48, r\"([^ab]*)*\", r\"ababab\", Some((0, 0)), None}\n-mat!{match_nullsubexpr_50, r\"((z)+|a)*\", r\"zabcde\", Some((0, 2)), Some((1, 2))}\n-mat!{match_nullsubexpr_69, r\"(a*)*(x)\", r\"x\", Some((0, 1)), None, Some((0, 1))}\n-mat!{match_nullsubexpr_70, r\"(a*)*(x)\", r\"ax\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n-mat!{match_nullsubexpr_71, r\"(a*)*(x)\", r\"axa\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n-mat!{match_nullsubexpr_73, r\"(a*)+(x)\", r\"x\", Some((0, 1)), Some((0, 0)), Some((0, 1))}\n-mat!{match_nullsubexpr_74, r\"(a*)+(x)\", r\"ax\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n-mat!{match_nullsubexpr_75, r\"(a*)+(x)\", r\"axa\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n-mat!{match_nullsubexpr_77, r\"(a*){2}(x)\", r\"x\", Some((0, 1)), Some((0, 0)), Some((0, 1))}\n-mat!{match_nullsubexpr_78, r\"(a*){2}(x)\", r\"ax\", Some((0, 2)), Some((1, 1)), Some((1, 2))}\n-mat!{match_nullsubexpr_79, r\"(a*){2}(x)\", r\"axa\", Some((0, 2)), Some((1, 1)), Some((1, 2))}\n-\n-// Tests from repetition.dat\n-mat!{match_repetition_10, r\"((..)|(.))\", r\"\", None}\n-mat!{match_repetition_11, r\"((..)|(.))((..)|(.))\", r\"\", None}\n-mat!{match_repetition_12, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"\", None}\n-mat!{match_repetition_14, r\"((..)|(.)){1}\", r\"\", None}\n-mat!{match_repetition_15, r\"((..)|(.)){2}\", r\"\", None}\n-mat!{match_repetition_16, r\"((..)|(.)){3}\", r\"\", None}\n-mat!{match_repetition_18, r\"((..)|(.))*\", r\"\", Some((0, 0))}\n-mat!{match_repetition_20, r\"((..)|(.))\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1))}\n-mat!{match_repetition_21, r\"((..)|(.))((..)|(.))\", r\"a\", None}\n-mat!{match_repetition_22, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"a\", None}\n-mat!{match_repetition_24, r\"((..)|(.)){1}\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1))}\n-mat!{match_repetition_25, r\"((..)|(.)){2}\", r\"a\", None}\n-mat!{match_repetition_26, r\"((..)|(.)){3}\", r\"a\", None}\n-mat!{match_repetition_28, r\"((..)|(.))*\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1))}\n-mat!{match_repetition_30, r\"((..)|(.))\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_31, r\"((..)|(.))((..)|(.))\", r\"aa\", Some((0, 2)), Some((0, 1)), None, Some((0, 1)), Some((1, 2)), None, Some((1, 2))}\n-mat!{match_repetition_32, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aa\", None}\n-mat!{match_repetition_34, r\"((..)|(.)){1}\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_35, r\"((..)|(.)){2}\", r\"aa\", Some((0, 2)), Some((1, 2)), None, Some((1, 2))}\n-mat!{match_repetition_36, r\"((..)|(.)){3}\", r\"aa\", None}\n-mat!{match_repetition_38, r\"((..)|(.))*\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_40, r\"((..)|(.))\", r\"aaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_41, r\"((..)|(.))((..)|(.))\", r\"aaa\", Some((0, 3)), Some((0, 2)), Some((0, 2)), None, Some((2, 3)), None, Some((2, 3))}\n-mat!{match_repetition_42, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaa\", Some((0, 3)), Some((0, 1)), None, Some((0, 1)), Some((1, 2)), None, Some((1, 2)), Some((2, 3)), None, Some((2, 3))}\n-mat!{match_repetition_44, r\"((..)|(.)){1}\", r\"aaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_46, r\"((..)|(.)){2}\", r\"aaa\", Some((0, 3)), Some((2, 3)), Some((0, 2)), Some((2, 3))}\n-mat!{match_repetition_47, r\"((..)|(.)){3}\", r\"aaa\", Some((0, 3)), Some((2, 3)), None, Some((2, 3))}\n-mat!{match_repetition_50, r\"((..)|(.))*\", r\"aaa\", Some((0, 3)), Some((2, 3)), Some((0, 2)), Some((2, 3))}\n-mat!{match_repetition_52, r\"((..)|(.))\", r\"aaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_53, r\"((..)|(.))((..)|(.))\", r\"aaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_54, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 3)), None, Some((2, 3)), Some((3, 4)), None, Some((3, 4))}\n-mat!{match_repetition_56, r\"((..)|(.)){1}\", r\"aaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_57, r\"((..)|(.)){2}\", r\"aaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_59, r\"((..)|(.)){3}\", r\"aaaa\", Some((0, 4)), Some((3, 4)), Some((0, 2)), Some((3, 4))}\n-mat!{match_repetition_61, r\"((..)|(.))*\", r\"aaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_63, r\"((..)|(.))\", r\"aaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_64, r\"((..)|(.))((..)|(.))\", r\"aaaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_65, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaaa\", Some((0, 5)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None, Some((4, 5)), None, Some((4, 5))}\n-mat!{match_repetition_67, r\"((..)|(.)){1}\", r\"aaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_68, r\"((..)|(.)){2}\", r\"aaaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_70, r\"((..)|(.)){3}\", r\"aaaaa\", Some((0, 5)), Some((4, 5)), Some((2, 4)), Some((4, 5))}\n-mat!{match_repetition_73, r\"((..)|(.))*\", r\"aaaaa\", Some((0, 5)), Some((4, 5)), Some((2, 4)), Some((4, 5))}\n-mat!{match_repetition_75, r\"((..)|(.))\", r\"aaaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_76, r\"((..)|(.))((..)|(.))\", r\"aaaaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_77, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaaaa\", Some((0, 6)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None, Some((4, 6)), Some((4, 6)), None}\n-mat!{match_repetition_79, r\"((..)|(.)){1}\", r\"aaaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n-mat!{match_repetition_80, r\"((..)|(.)){2}\", r\"aaaaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n-mat!{match_repetition_81, r\"((..)|(.)){3}\", r\"aaaaaa\", Some((0, 6)), Some((4, 6)), Some((4, 6)), None}\n-mat!{match_repetition_83, r\"((..)|(.))*\", r\"aaaaaa\", Some((0, 6)), Some((4, 6)), Some((4, 6)), None}\n-mat!{match_repetition_90, r\"X(.?){0,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_91, r\"X(.?){1,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_92, r\"X(.?){2,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_93, r\"X(.?){3,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_94, r\"X(.?){4,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_95, r\"X(.?){5,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_96, r\"X(.?){6,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_97, r\"X(.?){7,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n-mat!{match_repetition_98, r\"X(.?){8,}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_100, r\"X(.?){0,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_102, r\"X(.?){1,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_104, r\"X(.?){2,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_106, r\"X(.?){3,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_108, r\"X(.?){4,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_110, r\"X(.?){5,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_112, r\"X(.?){6,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_114, r\"X(.?){7,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_115, r\"X(.?){8,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n-mat!{match_repetition_126, r\"(a|ab|c|bcd){0,}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n-mat!{match_repetition_127, r\"(a|ab|c|bcd){1,}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n-mat!{match_repetition_128, r\"(a|ab|c|bcd){2,}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n-mat!{match_repetition_129, r\"(a|ab|c|bcd){3,}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n-mat!{match_repetition_130, r\"(a|ab|c|bcd){4,}(d*)\", r\"ababcd\", None}\n-mat!{match_repetition_131, r\"(a|ab|c|bcd){0,10}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n-mat!{match_repetition_132, r\"(a|ab|c|bcd){1,10}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n-mat!{match_repetition_133, r\"(a|ab|c|bcd){2,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n-mat!{match_repetition_134, r\"(a|ab|c|bcd){3,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n-mat!{match_repetition_135, r\"(a|ab|c|bcd){4,10}(d*)\", r\"ababcd\", None}\n-mat!{match_repetition_136, r\"(a|ab|c|bcd)*(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n-mat!{match_repetition_137, r\"(a|ab|c|bcd)+(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n-mat!{match_repetition_143, r\"(ab|a|c|bcd){0,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_145, r\"(ab|a|c|bcd){1,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_147, r\"(ab|a|c|bcd){2,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_149, r\"(ab|a|c|bcd){3,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_150, r\"(ab|a|c|bcd){4,}(d*)\", r\"ababcd\", None}\n-mat!{match_repetition_152, r\"(ab|a|c|bcd){0,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_154, r\"(ab|a|c|bcd){1,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_156, r\"(ab|a|c|bcd){2,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_158, r\"(ab|a|c|bcd){3,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_159, r\"(ab|a|c|bcd){4,10}(d*)\", r\"ababcd\", None}\n-mat!{match_repetition_161, r\"(ab|a|c|bcd)*(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-mat!{match_repetition_163, r\"(ab|a|c|bcd)+(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n-"}, {"sha": "62e14731c207bb3e99685bfd51d143a287f59494", "filename": "src/libregex/test/native_static.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Fnative_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Fnative_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fnative_static.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use regex::Regex;\n-static RE: Regex = regex!(r\"\\d+\");\n-\n-#[test]\n-fn static_splitn() {\n-    let text = \"cauchy123plato456tyler789binx\";\n-    let subs: Vec<&str> = RE.splitn(text, 2).collect();\n-    assert_eq!(subs, vec!(\"cauchy\", \"plato456tyler789binx\"));\n-}\n-\n-#[test]\n-fn static_split() {\n-    let text = \"cauchy123plato456tyler789binx\";\n-    let subs: Vec<&str> = RE.split(text).collect();\n-    assert_eq!(subs, vec!(\"cauchy\", \"plato\", \"tyler\", \"binx\"));\n-}"}, {"sha": "b69420ac05bd1336e5b187950f8037bd0c2815e6", "filename": "src/libregex/test/tests.rs", "status": "removed", "additions": 0, "deletions": 245, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,245 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-// ignore-lexer-test FIXME #15679\n-\n-use regex::{Regex, NoExpand};\n-\n-#[test]\n-fn splitn() {\n-    let re = regex!(r\"\\d+\");\n-    let text = \"cauchy123plato456tyler789binx\";\n-    let subs: Vec<&str> = re.splitn(text, 2).collect();\n-    assert_eq!(subs, vec!(\"cauchy\", \"plato456tyler789binx\"));\n-}\n-\n-#[test]\n-fn split() {\n-    let re = regex!(r\"\\d+\");\n-    let text = \"cauchy123plato456tyler789binx\";\n-    let subs: Vec<&str> = re.split(text).collect();\n-    assert_eq!(subs, vec!(\"cauchy\", \"plato\", \"tyler\", \"binx\"));\n-}\n-\n-#[test]\n-fn empty_regex_empty_match() {\n-    let re = regex!(\"\");\n-    let ms = re.find_iter(\"\").collect::<Vec<(uint, uint)>>();\n-    assert_eq!(ms, vec![(0, 0)]);\n-}\n-\n-#[test]\n-fn empty_regex_nonempty_match() {\n-    let re = regex!(\"\");\n-    let ms = re.find_iter(\"abc\").collect::<Vec<(uint, uint)>>();\n-    assert_eq!(ms, vec![(0, 0), (1, 1), (2, 2), (3, 3)]);\n-}\n-\n-#[test]\n-fn quoted_bracket_set() {\n-    let re = regex!(r\"([\\x{5b}\\x{5d}])\");\n-    let ms = re.find_iter(\"[]\").collect::<Vec<(uint, uint)>>();\n-    assert_eq!(ms, vec![(0, 1), (1, 2)]);\n-    let re = regex!(r\"([\\[\\]])\");\n-    let ms = re.find_iter(\"[]\").collect::<Vec<(uint, uint)>>();\n-    assert_eq!(ms, vec![(0, 1), (1, 2)]);\n-}\n-\n-#[test]\n-fn first_range_starts_with_left_bracket() {\n-    let re = regex!(r\"([[-z])\");\n-    let ms = re.find_iter(\"[]\").collect::<Vec<(uint, uint)>>();\n-    assert_eq!(ms, vec![(0, 1), (1, 2)]);\n-}\n-\n-#[test]\n-fn range_ends_with_escape() {\n-    let re = regex!(r\"([\\[-\\x{5d}])\");\n-    let ms = re.find_iter(\"[]\").collect::<Vec<(uint, uint)>>();\n-    assert_eq!(ms, vec![(0, 1), (1, 2)]);\n-}\n-\n-macro_rules! replace {\n-    ($name:ident, $which:ident, $re:expr,\n-     $search:expr, $replace:expr, $result:expr) => (\n-        #[test]\n-        fn $name() {\n-            let re = regex!($re);\n-            assert_eq!(re.$which($search, $replace), String::from_str($result));\n-        }\n-    );\n-}\n-\n-replace!{rep_first, replace, r\"\\d\", \"age: 26\", \"Z\", \"age: Z6\"}\n-replace!{rep_plus, replace, r\"\\d+\", \"age: 26\", \"Z\", \"age: Z\"}\n-replace!{rep_all, replace_all, r\"\\d\", \"age: 26\", \"Z\", \"age: ZZ\"}\n-replace!{rep_groups, replace, r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", \"$2 $1\", \"w2 w1\"}\n-replace!{rep_double_dollar, replace,\n-         r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", \"$2 $$1\", \"w2 $1\"}\n-replace!{rep_no_expand, replace,\n-         r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", NoExpand(\"$2 $1\"), \"$2 $1\"}\n-replace!{rep_named, replace_all,\n-         r\"(?P<first>\\S+)\\s+(?P<last>\\S+)(?P<space>\\s*)\",\n-         \"w1 w2 w3 w4\", \"$last $first$space\", \"w2 w1 w4 w3\"}\n-replace!{rep_trim, replace_all, \"^[ \\t]+|[ \\t]+$\", \" \\t  trim me\\t   \\t\",\n-         \"\", \"trim me\"}\n-\n-macro_rules! noparse {\n-    ($name:ident, $re:expr) => (\n-        #[test]\n-        fn $name() {\n-            let re = $re;\n-            match Regex::new(re) {\n-                Err(_) => {},\n-                Ok(_) => panic!(\"Regex '{}' should cause a parse error.\", re),\n-            }\n-        }\n-    );\n-}\n-\n-noparse!{fail_double_repeat, \"a**\"}\n-noparse!{fail_no_repeat_arg, \"*\"}\n-noparse!{fail_no_repeat_arg_begin, \"^*\"}\n-noparse!{fail_incomplete_escape, \"\\\\\"}\n-noparse!{fail_class_incomplete, \"[A-\"}\n-noparse!{fail_class_not_closed, \"[A\"}\n-noparse!{fail_class_no_begin, r\"[\\A]\"}\n-noparse!{fail_class_no_end, r\"[\\z]\"}\n-noparse!{fail_class_no_boundary, r\"[\\b]\"}\n-noparse!{fail_open_paren, \"(\"}\n-noparse!{fail_close_paren, \")\"}\n-noparse!{fail_invalid_range, \"[a-Z]\"}\n-noparse!{fail_empty_capture_name, \"(?P<>a)\"}\n-noparse!{fail_empty_capture_exp, \"(?P<name>)\"}\n-noparse!{fail_bad_capture_name, \"(?P<na-me>)\"}\n-noparse!{fail_bad_flag, \"(?a)a\"}\n-noparse!{fail_empty_alt_before, \"|a\"}\n-noparse!{fail_empty_alt_after, \"a|\"}\n-noparse!{fail_counted_big_exact, \"a{1001}\"}\n-noparse!{fail_counted_big_min, \"a{1001,}\"}\n-noparse!{fail_counted_no_close, \"a{1001\"}\n-noparse!{fail_unfinished_cap, \"(?\"}\n-noparse!{fail_unfinished_escape, \"\\\\\"}\n-noparse!{fail_octal_digit, r\"\\8\"}\n-noparse!{fail_hex_digit, r\"\\xG0\"}\n-noparse!{fail_hex_short, r\"\\xF\"}\n-noparse!{fail_hex_long_digits, r\"\\x{fffg}\"}\n-noparse!{fail_flag_bad, \"(?a)\"}\n-noparse!{fail_flag_empty, \"(?)\"}\n-noparse!{fail_double_neg, \"(?-i-i)\"}\n-noparse!{fail_neg_empty, \"(?i-)\"}\n-noparse!{fail_empty_group, \"()\"}\n-noparse!{fail_dupe_named, \"(?P<a>.)(?P<a>.)\"}\n-noparse!{fail_range_end_no_class, \"[a-[:lower:]]\"}\n-noparse!{fail_range_end_no_begin, r\"[a-\\A]\"}\n-noparse!{fail_range_end_no_end, r\"[a-\\z]\"}\n-noparse!{fail_range_end_no_boundary, r\"[a-\\b]\"}\n-noparse!{fail_repeat_no_expr, r\"-|+\"}\n-\n-macro_rules! mat {\n-    ($name:ident, $re:expr, $text:expr, $($loc:tt)+) => (\n-        #[test]\n-        fn $name() {\n-            let text = $text;\n-            let expected: Vec<Option<(uint, uint)>> = vec!($($loc)+);\n-            let r = regex!($re);\n-            let got = match r.captures(text) {\n-                Some(c) => c.iter_pos().collect::<Vec<Option<(uint, uint)>>>(),\n-                None => vec!(None),\n-            };\n-            // The test set sometimes leave out capture groups, so truncate\n-            // actual capture groups to match test set.\n-            let mut sgot = got.as_slice();\n-            if sgot.len() > expected.len() {\n-                sgot = &sgot[..expected.len()]\n-            }\n-            if expected != sgot {\n-                panic!(\"For RE '{}' against '{}', expected '{:?}' but got '{:?}'\",\n-                      $re, text, expected, sgot);\n-            }\n-        }\n-    );\n-}\n-\n-// Some crazy expressions from regular-expressions.info.\n-mat!{match_ranges,\n-     r\"\\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\",\n-     \"num: 255\", Some((5, 8))}\n-mat!{match_ranges_not,\n-     r\"\\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\",\n-     \"num: 256\", None}\n-mat!{match_float1, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1\", Some((0, 3))}\n-mat!{match_float2, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1.2\", Some((0, 3))}\n-mat!{match_float3, r\"[-+]?[0-9]*\\.?[0-9]+\", \"a1.2\", Some((1, 4))}\n-mat!{match_float4, r\"^[-+]?[0-9]*\\.?[0-9]+$\", \"1.a\", None}\n-mat!{match_email, r\"(?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n-     \"mine is jam.slam@gmail.com \", Some((8, 26))}\n-mat!{match_email_not, r\"(?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n-     \"mine is jam.slam@gmail \", None}\n-mat!{match_email_big, r\"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\",\n-     \"mine is jam.slam@gmail.com \", Some((8, 26))}\n-mat!{match_date1,\n-     r\"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n-     \"1900-01-01\", Some((0, 10))}\n-mat!{match_date2,\n-     r\"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n-     \"1900-00-01\", None}\n-mat!{match_date3,\n-     r\"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n-     \"1900-13-01\", None}\n-\n-// Exercise the flags.\n-mat!{match_flag_case, \"(?i)abc\", \"ABC\", Some((0, 3))}\n-mat!{match_flag_weird_case, \"(?i)a(?-i)bc\", \"Abc\", Some((0, 3))}\n-mat!{match_flag_weird_case_not, \"(?i)a(?-i)bc\", \"ABC\", None}\n-mat!{match_flag_case_dotnl, \"(?is)a.\", \"A\\n\", Some((0, 2))}\n-mat!{match_flag_case_dotnl_toggle, \"(?is)a.(?-is)a.\", \"A\\nab\", Some((0, 4))}\n-mat!{match_flag_case_dotnl_toggle_not, \"(?is)a.(?-is)a.\", \"A\\na\\n\", None}\n-mat!{match_flag_case_dotnl_toggle_ok, \"(?is)a.(?-is:a.)?\", \"A\\na\\n\", Some((0, 2))}\n-mat!{match_flag_multi, \"(?m)(?:^\\\\d+$\\n?)+\", \"123\\n456\\n789\", Some((0, 11))}\n-mat!{match_flag_ungreedy, \"(?U)a+\", \"aa\", Some((0, 1))}\n-mat!{match_flag_ungreedy_greedy, \"(?U)a+?\", \"aa\", Some((0, 2))}\n-mat!{match_flag_ungreedy_noop, \"(?U)(?-U)a+\", \"aa\", Some((0, 2))}\n-\n-// Some Unicode tests.\n-// A couple of these are commented out because something in the guts of macro expansion is creating\n-// invalid byte strings.\n-//mat!{uni_literal, r\"\u2160\", \"\u2160\", Some((0, 3))}\n-mat!{uni_one, r\"\\pN\", \"\u2160\", Some((0, 3))}\n-mat!{uni_mixed, r\"\\pN+\", \"\u21601\u21612\", Some((0, 8))}\n-mat!{uni_not, r\"\\PN+\", \"ab\u2160\", Some((0, 2))}\n-mat!{uni_not_class, r\"[\\PN]+\", \"ab\u2160\", Some((0, 2))}\n-mat!{uni_not_class_neg, r\"[^\\PN]+\", \"ab\u2160\", Some((2, 5))}\n-mat!{uni_case, r\"(?i)\u0394\", \"\u03b4\", Some((0, 2))}\n-//mat!{uni_case_not, r\"\u0394\", \"\u03b4\", None}\n-mat!{uni_case_upper, r\"\\p{Lu}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 8))}\n-mat!{uni_case_upper_nocase_flag, r\"(?i)\\p{Lu}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 10))}\n-mat!{uni_case_upper_nocase, r\"\\p{L}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 10))}\n-mat!{uni_case_lower, r\"\\p{Ll}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((8, 10))}\n-\n-// Test the Unicode friendliness of Perl character classes.\n-mat!{uni_perl_w, r\"\\w+\", \"d\u03b4d\", Some((0, 4))}\n-mat!{uni_perl_w_not, r\"\\w+\", \"\u2961\", None}\n-mat!{uni_perl_w_neg, r\"\\W+\", \"\u2961\", Some((0, 3))}\n-mat!{uni_perl_d, r\"\\d+\", \"1\u0968\u09699\", Some((0, 8))}\n-mat!{uni_perl_d_not, r\"\\d+\", \"\u2161\", None}\n-mat!{uni_perl_d_neg, r\"\\D+\", \"\u2161\", Some((0, 3))}\n-mat!{uni_perl_s, r\"\\s+\", \"\u1680\", Some((0, 3))}\n-mat!{uni_perl_s_not, r\"\\s+\", \"\u2603\", None}\n-mat!{uni_perl_s_neg, r\"\\S+\", \"\u2603\", Some((0, 3))}\n-\n-// And do the same for word boundaries.\n-mat!{uni_boundary_none, r\"\\d\\b\", \"6\u03b4\", None}\n-mat!{uni_boundary_ogham, r\"\\d\\b\", \"6\u1680\", Some((0, 1))}\n-\n-// A whole mess of tests from Glenn Fowler's regex test suite.\n-// Generated by the 'src/etc/regex-match-tests' program.\n-mod matches;"}, {"sha": "f47dbf4c449bcc067f3d535cce4b43b4cc52e21d", "filename": "src/libregex/testdata/LICENSE", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftestdata%2FLICENSE?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,19 +0,0 @@\n-The following license covers testregex.c and all associated test data.\n-\n-Permission is hereby granted, free of charge, to any person obtaining a\n-copy of THIS SOFTWARE FILE (the \"Software\"), to deal in the Software\n-without restriction, including without limitation the rights to use,\n-copy, modify, merge, publish, distribute, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do\n-so, subject to the following disclaimer:\n-\n-THIS SOFTWARE IS PROVIDED BY AT&T ``AS IS'' AND ANY EXPRESS OR IMPLIED\n-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n-IN NO EVENT SHALL AT&T BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "33b0ba17ed7f6aed2808a98f8fc00dcaa3dc488e", "filename": "src/libregex/testdata/README", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftestdata%2FREADME?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,17 +0,0 @@\n-Test data was taken from the Go distribution, which was in turn taken from the \n-testregex test suite:\n-\n-  http://www2.research.att.com/~astopen/testregex/testregex.html\n-\n-The LICENSE in this directory corresponds to the LICENSE that the data was\n-released under.\n-\n-The tests themselves were modified for RE2/Go. A couple were modified further \n-by me (Andrew Gallant) (only in repetition.dat) so that RE2/Go would pass them. \n-(Yes, it seems like RE2/Go includes failing test cases.) This may or may not \n-have been a bad idea, but I think being consistent with an established Regex \n-library is worth something.\n-\n-Note that these files are read by 'src/etc/regexp-match-tests' and turned into \n-Rust tests found in 'src/libregexp/tests/matches.rs'.\n-"}, {"sha": "e55efaeec062428fa08511d579dd6b9d897ff83c", "filename": "src/libregex/testdata/basic.dat", "status": "removed", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2Fbasic.dat", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2Fbasic.dat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftestdata%2Fbasic.dat?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,221 +0,0 @@\n-NOTE\tall standard compliant implementations should pass these : 2002-05-31\n-\n-BE\tabracadabra$\tabracadabracadabra\t(7,18)\n-BE\ta...b\t\tabababbb\t\t(2,7)\n-BE\tXXXXXX\t\t..XXXXXX\t\t(2,8)\n-E\t\\)\t\t()\t(1,2)\n-BE\ta]\t\ta]a\t(0,2)\n-B\t}\t\t}\t(0,1)\n-E\t\\}\t\t}\t(0,1)\n-BE\t\\]\t\t]\t(0,1)\n-B\t]\t\t]\t(0,1)\n-E\t]\t\t]\t(0,1)\n-B\t{\t\t{\t(0,1)\n-B\t}\t\t}\t(0,1)\n-BE\t^a\t\tax\t(0,1)\n-BE\t\\^a\t\ta^a\t(1,3)\n-BE\ta\\^\t\ta^\t(0,2)\n-BE\ta$\t\taa\t(1,2)\n-BE\ta\\$\t\ta$\t(0,2)\n-BE\t^$\t\tNULL\t(0,0)\n-E\t$^\t\tNULL\t(0,0)\n-E\ta($)\t\taa\t(1,2)(2,2)\n-E\ta*(^a)\t\taa\t(0,1)(0,1)\n-E\t(..)*(...)*\t\ta\t(0,0)\n-E\t(..)*(...)*\t\tabcd\t(0,4)(2,4)\n-E\t(ab|a)(bc|c)\t\tabc\t(0,3)(0,2)(2,3)\n-E\t(ab)c|abc\t\tabc\t(0,3)(0,2)\n-E\ta{0}b\t\tab\t\t\t(1,2)\n-E\t(a*)(b?)(b+)b{3}\taaabbbbbbb\t(0,10)(0,3)(3,4)(4,7)\n-E\t(a*)(b{0,1})(b{1,})b{3}\taaabbbbbbb\t(0,10)(0,3)(3,4)(4,7)\n-E\ta{9876543210}\tNULL\tBADBR\n-E\t((a|a)|a)\t\t\ta\t(0,1)(0,1)(0,1)\n-E\t(a*)(a|aa)\t\t\taaaa\t(0,4)(0,3)(3,4)\n-E\ta*(a.|aa)\t\t\taaaa\t(0,4)(2,4)\n-E\ta(b)|c(d)|a(e)f\t\t\taef\t(0,3)(?,?)(?,?)(1,2)\n-E\t(a|b)?.*\t\t\tb\t(0,1)(0,1)\n-E\t(a|b)c|a(b|c)\t\t\tac\t(0,2)(0,1)\n-E\t(a|b)c|a(b|c)\t\t\tab\t(0,2)(?,?)(1,2)\n-E\t(a|b)*c|(a|ab)*c\t\tabc\t(0,3)(1,2)\n-E\t(a|b)*c|(a|ab)*c\t\txc\t(1,2)\n-E\t(.a|.b).*|.*(.a|.b)\t\txa\t(0,2)(0,2)\n-E\ta?(ab|ba)ab\t\t\tabab\t(0,4)(0,2)\n-E\ta?(ac{0}b|ba)ab\t\t\tabab\t(0,4)(0,2)\n-E\tab|abab\t\t\t\tabbabab\t(0,2)\n-E\taba|bab|bba\t\t\tbaaabbbaba\t(5,8)\n-E\taba|bab\t\t\t\tbaaabbbaba\t(6,9)\n-E\t(aa|aaa)*|(a|aaaaa)\t\taa\t(0,2)(0,2)\n-E\t(a.|.a.)*|(a|.a...)\t\taa\t(0,2)(0,2)\n-E\tab|a\t\t\t\txabc\t(1,3)\n-E\tab|a\t\t\t\txxabc\t(2,4)\n-Ei\t(Ab|cD)*\t\t\taBcD\t(0,4)(2,4)\n-BE\t[^-]\t\t\t--a\t\t(2,3)\n-BE\t[a-]*\t\t\t--a\t\t(0,3)\n-BE\t[a-m-]*\t\t\t--amoma--\t(0,4)\n-E\t:::1:::0:|:::1:1:0:\t:::0:::1:::1:::0:\t(8,17)\n-E\t:::1:::0:|:::1:1:1:\t:::0:::1:::1:::0:\t(8,17)\n-{E\t[[:upper:]]\t\tA\t\t(0,1)\t[[<element>]] not supported\n-E\t[[:lower:]]+\t\t`az{\t\t(1,3)\n-E\t[[:upper:]]+\t\t@AZ[\t\t(1,3)\n-# No collation in Go\n-#BE\t[[-]]\t\t\t[[-]]\t\t(2,4)\n-#BE\t[[.NIL.]]\tNULL\tECOLLATE\n-#BE\t[[=aleph=]]\tNULL\tECOLLATE\n-}\n-BE$\t\\n\t\t\\n\t(0,1)\n-BEn$\t\\n\t\t\\n\t(0,1)\n-BE$\t[^a]\t\t\\n\t(0,1)\n-BE$\t\\na\t\t\\na\t(0,2)\n-E\t(a)(b)(c)\tabc\t(0,3)(0,1)(1,2)(2,3)\n-BE\txxx\t\txxx\t(0,3)\n-E1\t(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\tfeb 6,\t(0,6)\n-E1\t(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\t2/7\t(0,3)\n-E1\t(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\tfeb 1,Feb 6\t(5,11)\n-E3\t((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))\tx\t(0,1)(0,1)(0,1)\n-E3\t((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))*\txx\t(0,2)(1,2)(1,2)\n-E\ta?(ab|ba)*\tababababababababababababababababababababababababababababababababababababababababa\t(0,81)(79,81)\n-E\tabaa|abbaa|abbbaa|abbbbaa\tababbabbbabbbabbbbabbbbaa\t(18,25)\n-E\tabaa|abbaa|abbbaa|abbbbaa\tababbabbbabbbabbbbabaa\t(18,22)\n-E\taaac|aabc|abac|abbc|baac|babc|bbac|bbbc\tbaaabbbabac\t(7,11)\n-BE$\t.*\t\t\t\\x01\\x7f\t(0,2)\n-E\taaaa|bbbb|cccc|ddddd|eeeeee|fffffff|gggg|hhhh|iiiii|jjjjj|kkkkk|llll\t\tXaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa\t(53,57)\n-L\taaaa\\nbbbb\\ncccc\\nddddd\\neeeeee\\nfffffff\\ngggg\\nhhhh\\niiiii\\njjjjj\\nkkkkk\\nllll\t\tXaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa\tNOMATCH\n-E\ta*a*a*a*a*b\t\taaaaaaaaab\t(0,10)\n-BE\t^\t\t\tNULL\t\t(0,0)\n-BE\t$\t\t\tNULL\t\t(0,0)\n-BE\t^$\t\t\tNULL\t\t(0,0)\n-BE\t^a$\t\t\ta\t\t(0,1)\n-BE\tabc\t\t\tabc\t\t(0,3)\n-BE\tabc\t\t\txabcy\t\t(1,4)\n-BE\tabc\t\t\tababc\t\t(2,5)\n-BE\tab*c\t\t\tabc\t\t(0,3)\n-BE\tab*bc\t\t\tabc\t\t(0,3)\n-BE\tab*bc\t\t\tabbc\t\t(0,4)\n-BE\tab*bc\t\t\tabbbbc\t\t(0,6)\n-E\tab+bc\t\t\tabbc\t\t(0,4)\n-E\tab+bc\t\t\tabbbbc\t\t(0,6)\n-E\tab?bc\t\t\tabbc\t\t(0,4)\n-E\tab?bc\t\t\tabc\t\t(0,3)\n-E\tab?c\t\t\tabc\t\t(0,3)\n-BE\t^abc$\t\t\tabc\t\t(0,3)\n-BE\t^abc\t\t\tabcc\t\t(0,3)\n-BE\tabc$\t\t\taabc\t\t(1,4)\n-BE\t^\t\t\tabc\t\t(0,0)\n-BE\t$\t\t\tabc\t\t(3,3)\n-BE\ta.c\t\t\tabc\t\t(0,3)\n-BE\ta.c\t\t\taxc\t\t(0,3)\n-BE\ta.*c\t\t\taxyzc\t\t(0,5)\n-BE\ta[bc]d\t\t\tabd\t\t(0,3)\n-BE\ta[b-d]e\t\t\tace\t\t(0,3)\n-BE\ta[b-d]\t\t\taac\t\t(1,3)\n-BE\ta[-b]\t\t\ta-\t\t(0,2)\n-BE\ta[b-]\t\t\ta-\t\t(0,2)\n-BE\ta]\t\t\ta]\t\t(0,2)\n-BE\ta[]]b\t\t\ta]b\t\t(0,3)\n-BE\ta[^bc]d\t\t\taed\t\t(0,3)\n-BE\ta[^-b]c\t\t\tadc\t\t(0,3)\n-BE\ta[^]b]c\t\t\tadc\t\t(0,3)\n-E\tab|cd\t\t\tabc\t\t(0,2)\n-E\tab|cd\t\t\tabcd\t\t(0,2)\n-E\ta\\(b\t\t\ta(b\t\t(0,3)\n-E\ta\\(*b\t\t\tab\t\t(0,2)\n-E\ta\\(*b\t\t\ta((b\t\t(0,4)\n-E\t((a))\t\t\tabc\t\t(0,1)(0,1)(0,1)\n-E\t(a)b(c)\t\t\tabc\t\t(0,3)(0,1)(2,3)\n-E\ta+b+c\t\t\taabbabc\t\t(4,7)\n-E\ta*\t\t\taaa\t\t(0,3)\n-#E\t(a*)*\t\t\t-\t\t(0,0)(0,0)\n-E\t(a*)*\t\t\t-\t\t(0,0)(?,?)\tRE2/Go\n-E\t(a*)+\t\t\t-\t\t(0,0)(0,0)\n-#E\t(a*|b)*\t\t\t-\t\t(0,0)(0,0)\n-E\t(a*|b)*\t\t\t-\t\t(0,0)(?,?)\tRE2/Go\n-E\t(a+|b)*\t\t\tab\t\t(0,2)(1,2)\n-E\t(a+|b)+\t\t\tab\t\t(0,2)(1,2)\n-E\t(a+|b)?\t\t\tab\t\t(0,1)(0,1)\n-BE\t[^ab]*\t\t\tcde\t\t(0,3)\n-#E\t(^)*\t\t\t-\t\t(0,0)(0,0)\n-E\t(^)*\t\t\t-\t\t(0,0)(?,?)\tRE2/Go\n-BE\ta*\t\t\tNULL\t\t(0,0)\n-E\t([abc])*d\t\tabbbcd\t\t(0,6)(4,5)\n-E\t([abc])*bcd\t\tabcd\t\t(0,4)(0,1)\n-E\ta|b|c|d|e\t\te\t\t(0,1)\n-E\t(a|b|c|d|e)f\t\tef\t\t(0,2)(0,1)\n-#E\t((a*|b))*\t\t-\t\t(0,0)(0,0)(0,0)\n-E\t((a*|b))*\t\t-\t\t(0,0)(?,?)(?,?)\tRE2/Go\n-BE\tabcd*efg\t\tabcdefg\t\t(0,7)\n-BE\tab*\t\t\txabyabbbz\t(1,3)\n-BE\tab*\t\t\txayabbbz\t(1,2)\n-E\t(ab|cd)e\t\tabcde\t\t(2,5)(2,4)\n-BE\t[abhgefdc]ij\t\thij\t\t(0,3)\n-E\t(a|b)c*d\t\tabcd\t\t(1,4)(1,2)\n-E\t(ab|ab*)bc\t\tabc\t\t(0,3)(0,1)\n-E\ta([bc]*)c*\t\tabc\t\t(0,3)(1,3)\n-E\ta([bc]*)(c*d)\t\tabcd\t\t(0,4)(1,3)(3,4)\n-E\ta([bc]+)(c*d)\t\tabcd\t\t(0,4)(1,3)(3,4)\n-E\ta([bc]*)(c+d)\t\tabcd\t\t(0,4)(1,2)(2,4)\n-E\ta[bcd]*dcdcde\t\tadcdcde\t\t(0,7)\n-E\t(ab|a)b*c\t\tabc\t\t(0,3)(0,2)\n-E\t((a)(b)c)(d)\t\tabcd\t\t(0,4)(0,3)(0,1)(1,2)(3,4)\n-BE\t[A-Za-z_][A-Za-z0-9_]*\talpha\t\t(0,5)\n-E\t^a(bc+|b[eh])g|.h$\tabh\t\t(1,3)\n-E\t(bc+d$|ef*g.|h?i(j|k))\teffgz\t\t(0,5)(0,5)\n-E\t(bc+d$|ef*g.|h?i(j|k))\tij\t\t(0,2)(0,2)(1,2)\n-E\t(bc+d$|ef*g.|h?i(j|k))\treffgz\t\t(1,6)(1,6)\n-E\t(((((((((a)))))))))\ta\t\t(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)\n-BE\tmultiple words\t\tmultiple words yeah\t(0,14)\n-E\t(.*)c(.*)\t\tabcde\t\t(0,5)(0,2)(3,5)\n-BE\tabcd\t\t\tabcd\t\t(0,4)\n-E\ta(bc)d\t\t\tabcd\t\t(0,4)(1,3)\n-E\ta[\u0001-\u0003]?c\t\ta\u0002c\t\t(0,3)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Qaddafi\t(0,15)(?,?)(10,12)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMo'ammar Gadhafi\t(0,16)(?,?)(11,13)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Kaddafi\t(0,15)(?,?)(10,12)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Qadhafi\t(0,15)(?,?)(10,12)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Gadafi\t(0,14)(?,?)(10,11)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMu'ammar Qadafi\t(0,15)(?,?)(11,12)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMoamar Gaddafi\t(0,14)(?,?)(9,11)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMu'ammar Qadhdhafi\t(0,18)(?,?)(13,15)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Khaddafi\t(0,16)(?,?)(11,13)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Ghaddafy\t(0,16)(?,?)(11,13)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Ghadafi\t(0,15)(?,?)(11,12)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Ghaddafi\t(0,16)(?,?)(11,13)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuamar Kaddafi\t(0,14)(?,?)(9,11)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Quathafi\t(0,16)(?,?)(11,13)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMuammar Gheddafi\t(0,16)(?,?)(11,13)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMoammar Khadafy\t(0,15)(?,?)(11,12)\n-E\tM[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\tMoammar Qudhafi\t(0,15)(?,?)(10,12)\n-E\ta+(b|c)*d+\t\taabcdd\t\t\t(0,6)(3,4)\n-E\t^.+$\t\t\tvivi\t\t\t(0,4)\n-E\t^(.+)$\t\t\tvivi\t\t\t(0,4)(0,4)\n-E\t^([^!.]+).att.com!(.+)$\tgryphon.att.com!eby\t(0,19)(0,7)(16,19)\n-E\t^([^!]+!)?([^!]+)$\tbas\t\t\t(0,3)(?,?)(0,3)\n-E\t^([^!]+!)?([^!]+)$\tbar!bas\t\t\t(0,7)(0,4)(4,7)\n-E\t^([^!]+!)?([^!]+)$\tfoo!bas\t\t\t(0,7)(0,4)(4,7)\n-E\t^.+!([^!]+!)([^!]+)$\tfoo!bar!bas\t\t(0,11)(4,8)(8,11)\n-E\t((foo)|(bar))!bas\tbar!bas\t\t\t(0,7)(0,3)(?,?)(0,3)\n-E\t((foo)|(bar))!bas\tfoo!bar!bas\t\t(4,11)(4,7)(?,?)(4,7)\n-E\t((foo)|(bar))!bas\tfoo!bas\t\t\t(0,7)(0,3)(0,3)\n-E\t((foo)|bar)!bas\t\tbar!bas\t\t\t(0,7)(0,3)\n-E\t((foo)|bar)!bas\t\tfoo!bar!bas\t\t(4,11)(4,7)\n-E\t((foo)|bar)!bas\t\tfoo!bas\t\t\t(0,7)(0,3)(0,3)\n-E\t(foo|(bar))!bas\t\tbar!bas\t\t\t(0,7)(0,3)(0,3)\n-E\t(foo|(bar))!bas\t\tfoo!bar!bas\t\t(4,11)(4,7)(4,7)\n-E\t(foo|(bar))!bas\t\tfoo!bas\t\t\t(0,7)(0,3)\n-E\t(foo|bar)!bas\t\tbar!bas\t\t\t(0,7)(0,3)\n-E\t(foo|bar)!bas\t\tfoo!bar!bas\t\t(4,11)(4,7)\n-E\t(foo|bar)!bas\t\tfoo!bas\t\t\t(0,7)(0,3)\n-E\t^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\tfoo!bar!bas\t(0,11)(0,11)(?,?)(?,?)(4,8)(8,11)\n-E\t^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\tbas\t\t(0,3)(?,?)(0,3)\n-E\t^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\tbar!bas\t\t(0,7)(0,4)(4,7)\n-E\t^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\tfoo!bar!bas\t(0,11)(?,?)(?,?)(4,8)(8,11)\n-E\t^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\tfoo!bas\t\t(0,7)(0,4)(4,7)\n-E\t^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\tbas\t\t(0,3)(0,3)(?,?)(0,3)\n-E\t^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\tbar!bas\t\t(0,7)(0,7)(0,4)(4,7)\n-E\t^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\tfoo!bar!bas\t(0,11)(0,11)(?,?)(?,?)(4,8)(8,11)\n-E\t^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\tfoo!bas\t\t(0,7)(0,7)(0,4)(4,7)\n-E\t.*(/XXX).*\t\t\t/XXX\t\t\t(0,4)(0,4)\n-E\t.*(\\\\XXX).*\t\t\t\\XXX\t\t\t(0,4)(0,4)\n-E\t\\\\XXX\t\t\t\t\\XXX\t\t\t(0,4)\n-E\t.*(/000).*\t\t\t/000\t\t\t(0,4)(0,4)\n-E\t.*(\\\\000).*\t\t\t\\000\t\t\t(0,4)(0,4)\n-E\t\\\\000\t\t\t\t\\000\t\t\t(0,4)"}, {"sha": "2e18fbb917070347df82ed24978b62884652a037", "filename": "src/libregex/testdata/nullsubexpr.dat", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2Fnullsubexpr.dat", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2Fnullsubexpr.dat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftestdata%2Fnullsubexpr.dat?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,79 +0,0 @@\n-NOTE\tnull subexpression matches : 2002-06-06\n-\n-E\t(a*)*\t\ta\t\t(0,1)(0,1)\n-#E\tSAME\t\tx\t\t(0,0)(0,0)\n-E\tSAME\t\tx\t\t(0,0)(?,?)\tRE2/Go\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaax\t\t(0,6)(0,6)\n-E\t(a*)+\t\ta\t\t(0,1)(0,1)\n-E\tSAME\t\tx\t\t(0,0)(0,0)\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaax\t\t(0,6)(0,6)\n-E\t(a+)*\t\ta\t\t(0,1)(0,1)\n-E\tSAME\t\tx\t\t(0,0)\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaax\t\t(0,6)(0,6)\n-E\t(a+)+\t\ta\t\t(0,1)(0,1)\n-E\tSAME\t\tx\t\tNOMATCH\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaax\t\t(0,6)(0,6)\n-\n-E\t([a]*)*\t\ta\t\t(0,1)(0,1)\n-#E\tSAME\t\tx\t\t(0,0)(0,0)\n-E\tSAME\t\tx\t\t(0,0)(?,?)\tRE2/Go\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaax\t\t(0,6)(0,6)\n-E\t([a]*)+\t\ta\t\t(0,1)(0,1)\n-E\tSAME\t\tx\t\t(0,0)(0,0)\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaax\t\t(0,6)(0,6)\n-E\t([^b]*)*\ta\t\t(0,1)(0,1)\n-#E\tSAME\t\tb\t\t(0,0)(0,0)\n-E\tSAME\t\tb\t\t(0,0)(?,?)\tRE2/Go\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\taaaaaab\t\t(0,6)(0,6)\n-E\t([ab]*)*\ta\t\t(0,1)(0,1)\n-E\tSAME\t\taaaaaa\t\t(0,6)(0,6)\n-E\tSAME\t\tababab\t\t(0,6)(0,6)\n-E\tSAME\t\tbababa\t\t(0,6)(0,6)\n-E\tSAME\t\tb\t\t(0,1)(0,1)\n-E\tSAME\t\tbbbbbb\t\t(0,6)(0,6)\n-E\tSAME\t\taaaabcde\t(0,5)(0,5)\n-E\t([^a]*)*\tb\t\t(0,1)(0,1)\n-E\tSAME\t\tbbbbbb\t\t(0,6)(0,6)\n-#E\tSAME\t\taaaaaa\t\t(0,0)(0,0)\n-E\tSAME\t\taaaaaa\t\t(0,0)(?,?)\tRE2/Go\n-E\t([^ab]*)*\tccccxx\t\t(0,6)(0,6)\n-#E\tSAME\t\tababab\t\t(0,0)(0,0)\n-E\tSAME\t\tababab\t\t(0,0)(?,?)\tRE2/Go\n-\n-E\t((z)+|a)*\tzabcde\t\t(0,2)(1,2)\n-\n-#{E\ta+?\t\taaaaaa\t\t(0,1)\tno *? +? mimimal match ops\n-#E\t(a)\t\taaa\t\t(0,1)(0,1)\n-#E\t(a*?)\t\taaa\t\t(0,0)(0,0)\n-#E\t(a)*?\t\taaa\t\t(0,0)\n-#E\t(a*?)*?\t\taaa\t\t(0,0)\n-#}\n-\n-B\t\\(a*\\)*\\(x\\)\t\tx\t(0,1)(0,0)(0,1)\n-B\t\\(a*\\)*\\(x\\)\t\tax\t(0,2)(0,1)(1,2)\n-B\t\\(a*\\)*\\(x\\)\t\taxa\t(0,2)(0,1)(1,2)\n-B\t\\(a*\\)*\\(x\\)\\(\\1\\)\tx\t(0,1)(0,0)(0,1)(1,1)\n-B\t\\(a*\\)*\\(x\\)\\(\\1\\)\tax\t(0,2)(1,1)(1,2)(2,2)\n-B\t\\(a*\\)*\\(x\\)\\(\\1\\)\taxa\t(0,3)(0,1)(1,2)(2,3)\n-B\t\\(a*\\)*\\(x\\)\\(\\1\\)\\(x\\)\taxax\t(0,4)(0,1)(1,2)(2,3)(3,4)\n-B\t\\(a*\\)*\\(x\\)\\(\\1\\)\\(x\\)\taxxa\t(0,3)(1,1)(1,2)(2,2)(2,3)\n-\n-#E\t(a*)*(x)\t\tx\t(0,1)(0,0)(0,1)\n-E\t(a*)*(x)\t\tx\t(0,1)(?,?)(0,1)\tRE2/Go\n-E\t(a*)*(x)\t\tax\t(0,2)(0,1)(1,2)\n-E\t(a*)*(x)\t\taxa\t(0,2)(0,1)(1,2)\n-\n-E\t(a*)+(x)\t\tx\t(0,1)(0,0)(0,1)\n-E\t(a*)+(x)\t\tax\t(0,2)(0,1)(1,2)\n-E\t(a*)+(x)\t\taxa\t(0,2)(0,1)(1,2)\n-\n-E\t(a*){2}(x)\t\tx\t(0,1)(0,0)(0,1)\n-E\t(a*){2}(x)\t\tax\t(0,2)(1,1)(1,2)\n-E\t(a*){2}(x)\t\taxa\t(0,2)(1,1)(1,2)"}, {"sha": "3bb21211800058cef9beaad6cfdc54aa867926ad", "filename": "src/libregex/testdata/repetition.dat", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2Frepetition.dat", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Ftestdata%2Frepetition.dat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftestdata%2Frepetition.dat?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,163 +0,0 @@\n-NOTE\timplicit vs. explicit repetitions : 2009-02-02\n-\n-# Glenn Fowler <gsf@research.att.com>\n-# conforming matches (column 4) must match one of the following BREs\n-#\tNOMATCH\n-#\t(0,.)\\((\\(.\\),\\(.\\))(?,?)(\\2,\\3)\\)*\n-#\t(0,.)\\((\\(.\\),\\(.\\))(\\2,\\3)(?,?)\\)*\n-# i.e., each 3-tuple has two identical elements and one (?,?)\n-\n-E\t((..)|(.))\t\t\t\tNULL\t\tNOMATCH\n-E\t((..)|(.))((..)|(.))\t\t\tNULL\t\tNOMATCH\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\tNULL\t\tNOMATCH\n-\n-E\t((..)|(.)){1}\t\t\t\tNULL\t\tNOMATCH\n-E\t((..)|(.)){2}\t\t\t\tNULL\t\tNOMATCH\n-E\t((..)|(.)){3}\t\t\t\tNULL\t\tNOMATCH\n-\n-E\t((..)|(.))*\t\t\t\tNULL\t\t(0,0)\n-\n-E\t((..)|(.))\t\t\t\ta\t\t(0,1)(0,1)(?,?)(0,1)\n-E\t((..)|(.))((..)|(.))\t\t\ta\t\tNOMATCH\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\ta\t\tNOMATCH\n-\n-E\t((..)|(.)){1}\t\t\t\ta\t\t(0,1)(0,1)(?,?)(0,1)\n-E\t((..)|(.)){2}\t\t\t\ta\t\tNOMATCH\n-E\t((..)|(.)){3}\t\t\t\ta\t\tNOMATCH\n-\n-E\t((..)|(.))*\t\t\t\ta\t\t(0,1)(0,1)(?,?)(0,1)\n-\n-E\t((..)|(.))\t\t\t\taa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.))((..)|(.))\t\t\taa\t\t(0,2)(0,1)(?,?)(0,1)(1,2)(?,?)(1,2)\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\taa\t\tNOMATCH\n-\n-E\t((..)|(.)){1}\t\t\t\taa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.)){2}\t\t\t\taa\t\t(0,2)(1,2)(?,?)(1,2)\n-E\t((..)|(.)){3}\t\t\t\taa\t\tNOMATCH\n-\n-E\t((..)|(.))*\t\t\t\taa\t\t(0,2)(0,2)(0,2)(?,?)\n-\n-E\t((..)|(.))\t\t\t\taaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.))((..)|(.))\t\t\taaa\t\t(0,3)(0,2)(0,2)(?,?)(2,3)(?,?)(2,3)\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\taaa\t\t(0,3)(0,1)(?,?)(0,1)(1,2)(?,?)(1,2)(2,3)(?,?)(2,3)\n-\n-E\t((..)|(.)){1}\t\t\t\taaa\t\t(0,2)(0,2)(0,2)(?,?)\n-#E\t((..)|(.)){2}\t\t\t\taaa\t\t(0,3)(2,3)(?,?)(2,3)\n-E\t((..)|(.)){2}\t\t\t\taaa\t\t(0,3)(2,3)(0,2)(2,3)\tRE2/Go\n-E\t((..)|(.)){3}\t\t\t\taaa\t\t(0,3)(2,3)(?,?)(2,3)\n-\n-#E\t((..)|(.))*\t\t\t\taaa\t\t(0,3)(2,3)(?,?)(2,3)\n-E\t((..)|(.))*\t\t\t\taaa\t\t(0,3)(2,3)(0,2)(2,3)\tRE2/Go\n-\n-E\t((..)|(.))\t\t\t\taaaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.))((..)|(.))\t\t\taaaa\t\t(0,4)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\taaaa\t\t(0,4)(0,2)(0,2)(?,?)(2,3)(?,?)(2,3)(3,4)(?,?)(3,4)\n-\n-E\t((..)|(.)){1}\t\t\t\taaaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.)){2}\t\t\t\taaaa\t\t(0,4)(2,4)(2,4)(?,?)\n-#E\t((..)|(.)){3}\t\t\t\taaaa\t\t(0,4)(3,4)(?,?)(3,4)\n-E\t((..)|(.)){3}\t\t\t\taaaa\t\t(0,4)(3,4)(0,2)(3,4)\tRE2/Go\n-\n-E\t((..)|(.))*\t\t\t\taaaa\t\t(0,4)(2,4)(2,4)(?,?)\n-\n-E\t((..)|(.))\t\t\t\taaaaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.))((..)|(.))\t\t\taaaaa\t\t(0,4)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\taaaaa\t\t(0,5)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)(4,5)(?,?)(4,5)\n-\n-E\t((..)|(.)){1}\t\t\t\taaaaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.)){2}\t\t\t\taaaaa\t\t(0,4)(2,4)(2,4)(?,?)\n-#E\t((..)|(.)){3}\t\t\t\taaaaa\t\t(0,5)(4,5)(?,?)(4,5)\n-E\t((..)|(.)){3}\t\t\t\taaaaa\t\t(0,5)(4,5)(2,4)(4,5)\tRE2/Go\n-\n-#E\t((..)|(.))*\t\t\t\taaaaa\t\t(0,5)(4,5)(?,?)(4,5)\n-E\t((..)|(.))*\t\t\t\taaaaa\t\t(0,5)(4,5)(2,4)(4,5)\tRE2/Go\n-\n-E\t((..)|(.))\t\t\t\taaaaaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.))((..)|(.))\t\t\taaaaaa\t\t(0,4)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)\n-E\t((..)|(.))((..)|(.))((..)|(.))\t\taaaaaa\t\t(0,6)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)(4,6)(4,6)(?,?)\n-\n-E\t((..)|(.)){1}\t\t\t\taaaaaa\t\t(0,2)(0,2)(0,2)(?,?)\n-E\t((..)|(.)){2}\t\t\t\taaaaaa\t\t(0,4)(2,4)(2,4)(?,?)\n-E\t((..)|(.)){3}\t\t\t\taaaaaa\t\t(0,6)(4,6)(4,6)(?,?)\n-\n-E\t((..)|(.))*\t\t\t\taaaaaa\t\t(0,6)(4,6)(4,6)(?,?)\n-\n-NOTE\tadditional repetition tests graciously provided by Chris Kuklewicz www.haskell.org 2009-02-02\n-\n-# These test a bug in OS X / FreeBSD / NetBSD, and libtree. \n-# Linux/GLIBC gets the {8,} and {8,8} wrong.\n-\n-:HA#100:E\tX(.?){0,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#101:E\tX(.?){1,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#102:E\tX(.?){2,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#103:E\tX(.?){3,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#104:E\tX(.?){4,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#105:E\tX(.?){5,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#106:E\tX(.?){6,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#107:E\tX(.?){7,}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#108:E\tX(.?){8,}Y\tX1234567Y\t(0,9)(8,8)\n-#:HA#110:E\tX(.?){0,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#110:E\tX(.?){0,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#111:E\tX(.?){1,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#111:E\tX(.?){1,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#112:E\tX(.?){2,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#112:E\tX(.?){2,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#113:E\tX(.?){3,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#113:E\tX(.?){3,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#114:E\tX(.?){4,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#114:E\tX(.?){4,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#115:E\tX(.?){5,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#115:E\tX(.?){5,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#116:E\tX(.?){6,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#116:E\tX(.?){6,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-#:HA#117:E\tX(.?){7,8}Y\tX1234567Y\t(0,9)(7,8)\n-:HA#117:E\tX(.?){7,8}Y\tX1234567Y\t(0,9)(8,8)\tRE2/Go\n-:HA#118:E\tX(.?){8,8}Y\tX1234567Y\t(0,9)(8,8)\n-\n-# These test a fixed bug in my regex-tdfa that did not keep the expanded\n-# form properly grouped, so right association did the wrong thing with\n-# these ambiguous patterns (crafted just to test my code when I became\n-# suspicious of my implementation).  The first subexpression should use\n-# \"ab\" then \"a\" then \"bcd\".\n-\n-# OS X / FreeBSD / NetBSD badly fail many of these, with impossible\n-# results like (0,6)(4,5)(6,6).\n-\n-:HA#260:E\t(a|ab|c|bcd){0,}(d*)\tababcd\t(0,1)(0,1)(1,1)\n-:HA#261:E\t(a|ab|c|bcd){1,}(d*)\tababcd\t(0,1)(0,1)(1,1)\n-:HA#262:E\t(a|ab|c|bcd){2,}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#263:E\t(a|ab|c|bcd){3,}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#264:E\t(a|ab|c|bcd){4,}(d*)\tababcd\tNOMATCH\n-:HA#265:E\t(a|ab|c|bcd){0,10}(d*)\tababcd\t(0,1)(0,1)(1,1)\n-:HA#266:E\t(a|ab|c|bcd){1,10}(d*)\tababcd\t(0,1)(0,1)(1,1)\n-:HA#267:E\t(a|ab|c|bcd){2,10}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#268:E\t(a|ab|c|bcd){3,10}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#269:E\t(a|ab|c|bcd){4,10}(d*)\tababcd\tNOMATCH\n-:HA#270:E\t(a|ab|c|bcd)*(d*)\tababcd\t(0,1)(0,1)(1,1)\n-:HA#271:E\t(a|ab|c|bcd)+(d*)\tababcd\t(0,1)(0,1)(1,1)\n-\n-# The above worked on Linux/GLIBC but the following often fail.\n-# They also trip up OS X / FreeBSD / NetBSD:\n-\n-#:HA#280:E\t(ab|a|c|bcd){0,}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#280:E\t(ab|a|c|bcd){0,}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#281:E\t(ab|a|c|bcd){1,}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#281:E\t(ab|a|c|bcd){1,}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#282:E\t(ab|a|c|bcd){2,}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#282:E\t(ab|a|c|bcd){2,}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#283:E\t(ab|a|c|bcd){3,}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#283:E\t(ab|a|c|bcd){3,}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-:HA#284:E\t(ab|a|c|bcd){4,}(d*)\tababcd\tNOMATCH\n-#:HA#285:E\t(ab|a|c|bcd){0,10}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#285:E\t(ab|a|c|bcd){0,10}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#286:E\t(ab|a|c|bcd){1,10}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#286:E\t(ab|a|c|bcd){1,10}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#287:E\t(ab|a|c|bcd){2,10}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#287:E\t(ab|a|c|bcd){2,10}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#288:E\t(ab|a|c|bcd){3,10}(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#288:E\t(ab|a|c|bcd){3,10}(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-:HA#289:E\t(ab|a|c|bcd){4,10}(d*)\tababcd\tNOMATCH\n-#:HA#290:E\t(ab|a|c|bcd)*(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#290:E\t(ab|a|c|bcd)*(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go\n-#:HA#291:E\t(ab|a|c|bcd)+(d*)\tababcd\t(0,6)(3,6)(6,6)\n-:HA#291:E\t(ab|a|c|bcd)+(d*)\tababcd\t(0,6)(4,5)(5,6)\tRE2/Go"}, {"sha": "9605536a052c04d3135888e754e0c18269b128d5", "filename": "src/libregex/vm.rs", "status": "removed", "additions": 0, "deletions": 582, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559", "patch": "@@ -1,582 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: Currently, the VM simulates an NFA. It would be nice to have another\n-// VM that simulates a DFA.\n-//\n-// According to Russ Cox[1], a DFA performs better than an NFA, principally\n-// because it reuses states previously computed by the machine *and* doesn't\n-// keep track of capture groups. The drawback of a DFA (aside from its\n-// complexity) is that it can't accurately return the locations of submatches.\n-// The NFA *can* do that. (This is my understanding anyway.)\n-//\n-// Cox suggests that a DFA ought to be used to answer \"does this match\" and\n-// \"where does it match\" questions. (In the latter, the starting position of\n-// the match is computed by executing the regex backwards.) Cox also suggests\n-// that a DFA should be run when asking \"where are the submatches\", which can\n-// 1) quickly answer \"no\" is there's no match and 2) discover the substring\n-// that matches, which means running the NFA on smaller input.\n-//\n-// Currently, the NFA simulation implemented below does some dirty tricks to\n-// avoid tracking capture groups when they aren't needed (which only works\n-// for 'is_match', not 'find'). This is a half-measure, but does provide some\n-// perf improvement.\n-//\n-// AFAIK, the DFA/NFA approach is implemented in RE2/C++ but *not* in RE2/Go.\n-//\n-// [1] - http://swtch.com/~rsc/regex/regex3.html\n-\n-pub use self::MatchKind::*;\n-pub use self::StepState::*;\n-\n-use std::cmp;\n-use std::cmp::Ordering::{self, Less, Equal, Greater};\n-use std::mem;\n-use std::iter::repeat;\n-use std::slice::SliceExt;\n-use compile::{\n-    Program,\n-    Match, OneChar, CharClass, Any, EmptyBegin, EmptyEnd, EmptyWordBoundary,\n-    Save, Jump, Split,\n-};\n-use parse::{FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL, FLAG_NEGATED};\n-use unicode::regex::PERLW;\n-\n-pub type CaptureLocs = Vec<Option<uint>>;\n-\n-/// Indicates the type of match to be performed by the VM.\n-#[derive(Copy)]\n-pub enum MatchKind {\n-    /// Only checks if a match exists or not. Does not return location.\n-    Exists,\n-    /// Returns the start and end indices of the entire match in the input\n-    /// given.\n-    Location,\n-    /// Returns the start and end indices of each submatch in the input given.\n-    Submatches,\n-}\n-\n-/// Runs an NFA simulation on the compiled expression given on the search text\n-/// `input`. The search begins at byte index `start` and ends at byte index\n-/// `end`. (The range is specified here so that zero-width assertions will work\n-/// correctly when searching for successive non-overlapping matches.)\n-///\n-/// The `which` parameter indicates what kind of capture information the caller\n-/// wants. There are three choices: match existence only, the location of the\n-/// entire match or the locations of the entire match in addition to the\n-/// locations of each submatch.\n-pub fn run<'r, 't>(which: MatchKind, prog: &'r Program, input: &'t str,\n-                   start: uint, end: uint) -> CaptureLocs {\n-    Nfa {\n-        which: which,\n-        prog: prog,\n-        input: input,\n-        start: start,\n-        end: end,\n-        ic: 0,\n-        chars: CharReader::new(input),\n-    }.run()\n-}\n-\n-struct Nfa<'r, 't> {\n-    which: MatchKind,\n-    prog: &'r Program,\n-    input: &'t str,\n-    start: uint,\n-    end: uint,\n-    ic: uint,\n-    chars: CharReader<'t>,\n-}\n-\n-/// Indicates the next action to take after a single non-empty instruction\n-/// is processed.\n-#[derive(Copy)]\n-pub enum StepState {\n-    /// This is returned if and only if a Match instruction is reached and\n-    /// we only care about the existence of a match. It instructs the VM to\n-    /// quit early.\n-    StepMatchEarlyReturn,\n-    /// Indicates that a match was found. Thus, the rest of the states in the\n-    /// *current* queue should be dropped (i.e., leftmost-first semantics).\n-    /// States in the \"next\" queue can still be processed.\n-    StepMatch,\n-    /// No match was found. Continue with the next state in the queue.\n-    StepContinue,\n-}\n-\n-impl<'r, 't> Nfa<'r, 't> {\n-    fn run(&mut self) -> CaptureLocs {\n-        let ncaps = match self.which {\n-            Exists => 0,\n-            Location => 1,\n-            Submatches => self.prog.num_captures(),\n-        };\n-        let mut matched = false;\n-        let ninsts = self.prog.insts.len();\n-        let mut clist = &mut Threads::new(self.which, ninsts, ncaps);\n-        let mut nlist = &mut Threads::new(self.which, ninsts, ncaps);\n-\n-        let mut groups: Vec<_> = repeat(None).take(ncaps * 2).collect();\n-\n-        // Determine if the expression starts with a '^' so we can avoid\n-        // simulating .*?\n-        // Make sure multi-line mode isn't enabled for it, otherwise we can't\n-        // drop the initial .*?\n-        let prefix_anchor =\n-            match self.prog.insts[1] {\n-                EmptyBegin(flags) if flags & FLAG_MULTI == 0 => true,\n-                _ => false,\n-            };\n-\n-        self.ic = self.start;\n-        let mut next_ic = self.chars.set(self.start);\n-        while self.ic <= self.end {\n-            if clist.size == 0 {\n-                // We have a match and we're done exploring alternatives.\n-                // Time to quit.\n-                if matched {\n-                    break\n-                }\n-\n-                // If there are no threads to try, then we'll have to start\n-                // over at the beginning of the regex.\n-                // BUT, if there's a literal prefix for the program, try to\n-                // jump ahead quickly. If it can't be found, then we can bail\n-                // out early.\n-                if self.prog.prefix.len() > 0 && clist.size == 0 {\n-                    let needle = self.prog.prefix.as_bytes();\n-                    let haystack = &self.input.as_bytes()[self.ic..];\n-                    match find_prefix(needle, haystack) {\n-                        None => break,\n-                        Some(i) => {\n-                            self.ic += i;\n-                            next_ic = self.chars.set(self.ic);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // This simulates a preceding '.*?' for every regex by adding\n-            // a state starting at the current position in the input for the\n-            // beginning of the program only if we don't already have a match.\n-            if clist.size == 0 || (!prefix_anchor && !matched) {\n-                self.add(clist, 0, groups.as_mut_slice())\n-            }\n-\n-            // Now we try to read the next character.\n-            // As a result, the 'step' method will look at the previous\n-            // character.\n-            self.ic = next_ic;\n-            next_ic = self.chars.advance();\n-\n-            for i in range(0, clist.size) {\n-                let pc = clist.pc(i);\n-                let step_state = self.step(groups.as_mut_slice(), nlist,\n-                                           clist.groups(i), pc);\n-                match step_state {\n-                    StepMatchEarlyReturn => return vec![Some(0), Some(0)],\n-                    StepMatch => { matched = true; break },\n-                    StepContinue => {},\n-                }\n-            }\n-            mem::swap(&mut clist, &mut nlist);\n-            nlist.empty();\n-        }\n-        match self.which {\n-            Exists if matched     => vec![Some(0), Some(0)],\n-            Exists                => vec![None, None],\n-            Location | Submatches => groups,\n-        }\n-    }\n-\n-    fn step(&self, groups: &mut [Option<uint>], nlist: &mut Threads,\n-            caps: &mut [Option<uint>], pc: uint)\n-           -> StepState {\n-        match self.prog.insts[pc] {\n-            Match => {\n-                match self.which {\n-                    Exists => {\n-                        return StepMatchEarlyReturn\n-                    }\n-                    Location => {\n-                        groups[0] = caps[0];\n-                        groups[1] = caps[1];\n-                        return StepMatch\n-                    }\n-                    Submatches => {\n-                        for (slot, val) in groups.iter_mut().zip(caps.iter()) {\n-                            *slot = *val;\n-                        }\n-                        return StepMatch\n-                    }\n-                }\n-            }\n-            OneChar(c, flags) => {\n-                if self.char_eq(flags & FLAG_NOCASE > 0, self.chars.prev, c) {\n-                    self.add(nlist, pc+1, caps);\n-                }\n-            }\n-            CharClass(ref ranges, flags) => {\n-                if self.chars.prev.is_some() {\n-                    let c = self.chars.prev.unwrap();\n-                    let negate = flags & FLAG_NEGATED > 0;\n-                    let casei = flags & FLAG_NOCASE > 0;\n-                    let found = ranges.as_slice();\n-                    let found = found.binary_search_by(|&rc| class_cmp(casei, c, rc)).is_ok();\n-                    if found ^ negate {\n-                        self.add(nlist, pc+1, caps);\n-                    }\n-                }\n-            }\n-            Any(flags) => {\n-                if flags & FLAG_DOTNL > 0\n-                   || !self.char_eq(false, self.chars.prev, '\\n') {\n-                    self.add(nlist, pc+1, caps)\n-                }\n-            }\n-            EmptyBegin(_) | EmptyEnd(_) | EmptyWordBoundary(_)\n-            | Save(_) | Jump(_) | Split(_, _) => {},\n-        }\n-        StepContinue\n-    }\n-\n-    fn add(&self, nlist: &mut Threads, pc: uint, groups: &mut [Option<uint>]) {\n-        if nlist.contains(pc) {\n-            return\n-        }\n-        // We have to add states to the threads list even if their empty.\n-        // TL;DR - It prevents cycles.\n-        // If we didn't care about cycles, we'd *only* add threads that\n-        // correspond to non-jumping instructions (OneChar, Any, Match, etc.).\n-        // But, it's possible for valid regexs (like '(a*)*') to result in\n-        // a cycle in the instruction list. e.g., We'll keep chasing the Split\n-        // instructions forever.\n-        // So we add these instructions to our thread queue, but in the main\n-        // VM loop, we look for them but simply ignore them.\n-        // Adding them to the queue prevents them from being revisited so we\n-        // can avoid cycles (and the inevitable stack overflow).\n-        //\n-        // We make a minor optimization by indicating that the state is \"empty\"\n-        // so that its capture groups are not filled in.\n-        match self.prog.insts[pc] {\n-            EmptyBegin(flags) => {\n-                let multi = flags & FLAG_MULTI > 0;\n-                nlist.add(pc, groups, true);\n-                if self.chars.is_begin()\n-                   || (multi && self.char_is(self.chars.prev, '\\n')) {\n-                    self.add(nlist, pc + 1, groups)\n-                }\n-            }\n-            EmptyEnd(flags) => {\n-                let multi = flags & FLAG_MULTI > 0;\n-                nlist.add(pc, groups, true);\n-                if self.chars.is_end()\n-                   || (multi && self.char_is(self.chars.cur, '\\n')) {\n-                    self.add(nlist, pc + 1, groups)\n-                }\n-            }\n-            EmptyWordBoundary(flags) => {\n-                nlist.add(pc, groups, true);\n-                if self.chars.is_word_boundary() == !(flags & FLAG_NEGATED > 0) {\n-                    self.add(nlist, pc + 1, groups)\n-                }\n-            }\n-            Save(slot) => {\n-                nlist.add(pc, groups, true);\n-                match self.which {\n-                    Location if slot <= 1 => {\n-                        let old = groups[slot];\n-                        groups[slot] = Some(self.ic);\n-                        self.add(nlist, pc + 1, groups);\n-                        groups[slot] = old;\n-                    }\n-                    Submatches => {\n-                        let old = groups[slot];\n-                        groups[slot] = Some(self.ic);\n-                        self.add(nlist, pc + 1, groups);\n-                        groups[slot] = old;\n-                    }\n-                    Exists | Location => self.add(nlist, pc + 1, groups),\n-                }\n-            }\n-            Jump(to) => {\n-                nlist.add(pc, groups, true);\n-                self.add(nlist, to, groups)\n-            }\n-            Split(x, y) => {\n-                nlist.add(pc, groups, true);\n-                self.add(nlist, x, groups);\n-                self.add(nlist, y, groups);\n-            }\n-            Match | OneChar(_, _) | CharClass(_, _) | Any(_) => {\n-                nlist.add(pc, groups, false);\n-            }\n-        }\n-    }\n-\n-    // FIXME: For case insensitive comparisons, it uses the uppercase\n-    // character and tests for equality. IIUC, this does not generalize to\n-    // all of Unicode. I believe we need to check the entire fold for each\n-    // character. This will be easy to add if and when it gets added to Rust's\n-    // standard library.\n-    #[inline]\n-    fn char_eq(&self, casei: bool, textc: Option<char>, regc: char) -> bool {\n-        match textc {\n-            None => false,\n-            Some(textc) => {\n-                regc == textc\n-                    || (casei && regc.to_uppercase() == textc.to_uppercase())\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn char_is(&self, textc: Option<char>, regc: char) -> bool {\n-        textc == Some(regc)\n-    }\n-}\n-\n-/// CharReader is responsible for maintaining a \"previous\" and a \"current\"\n-/// character. This one-character lookahead is necessary for assertions that\n-/// look one character before or after the current position.\n-pub struct CharReader<'t> {\n-    /// The previous character read. It is None only when processing the first\n-    /// character of the input.\n-    pub prev: Option<char>,\n-    /// The current character.\n-    pub cur: Option<char>,\n-    input: &'t str,\n-    next: uint,\n-}\n-\n-impl<'t> CharReader<'t> {\n-    /// Returns a new CharReader that advances through the input given.\n-    /// Note that a CharReader has no knowledge of the range in which to search\n-    /// the input.\n-    pub fn new(input: &'t str) -> CharReader<'t> {\n-        CharReader {\n-            prev: None,\n-            cur: None,\n-            input: input,\n-            next: 0,\n-       }\n-    }\n-\n-    /// Sets the previous and current character given any arbitrary byte\n-    /// index (at a Unicode codepoint boundary).\n-    #[inline]\n-    pub fn set(&mut self, ic: uint) -> uint {\n-        self.prev = None;\n-        self.cur = None;\n-        self.next = 0;\n-\n-        if self.input.len() == 0 {\n-            return 1\n-        }\n-        if ic > 0 {\n-            let i = cmp::min(ic, self.input.len());\n-            let prev = self.input.char_range_at_reverse(i);\n-            self.prev = Some(prev.ch);\n-        }\n-        if ic < self.input.len() {\n-            let cur = self.input.char_range_at(ic);\n-            self.cur = Some(cur.ch);\n-            self.next = cur.next;\n-            self.next\n-        } else {\n-            self.input.len() + 1\n-        }\n-    }\n-\n-    /// Does the same as `set`, except it always advances to the next\n-    /// character in the input (and therefore does half as many UTF8 decodings).\n-    #[inline]\n-    pub fn advance(&mut self) -> uint {\n-        self.prev = self.cur;\n-        if self.next < self.input.len() {\n-            let cur = self.input.char_range_at(self.next);\n-            self.cur = Some(cur.ch);\n-            self.next = cur.next;\n-        } else {\n-            self.cur = None;\n-            self.next = self.input.len() + 1;\n-        }\n-        self.next\n-    }\n-\n-    /// Returns true if and only if this is the beginning of the input\n-    /// (ignoring the range of the input to search).\n-    #[inline]\n-    pub fn is_begin(&self) -> bool { self.prev.is_none() }\n-\n-    /// Returns true if and only if this is the end of the input\n-    /// (ignoring the range of the input to search).\n-    #[inline]\n-    pub fn is_end(&self) -> bool { self.cur.is_none() }\n-\n-    /// Returns true if and only if the current position is a word boundary.\n-    /// (Ignoring the range of the input to search.)\n-    pub fn is_word_boundary(&self) -> bool {\n-        if self.is_begin() {\n-            return is_word(self.cur)\n-        }\n-        if self.is_end() {\n-            return is_word(self.prev)\n-        }\n-        (is_word(self.cur) && !is_word(self.prev))\n-        || (is_word(self.prev) && !is_word(self.cur))\n-    }\n-}\n-\n-struct Thread {\n-    pc: uint,\n-    groups: Vec<Option<uint>>,\n-}\n-\n-struct Threads {\n-    which: MatchKind,\n-    queue: Vec<Thread>,\n-    sparse: Vec<uint>,\n-    size: uint,\n-}\n-\n-impl Threads {\n-    // This is using a wicked neat trick to provide constant time lookup\n-    // for threads in the queue using a sparse set. A queue of threads is\n-    // allocated once with maximal size when the VM initializes and is reused\n-    // throughout execution. That is, there should be zero allocation during\n-    // the execution of a VM.\n-    //\n-    // See http://research.swtch.com/sparse for the deets.\n-    fn new(which: MatchKind, num_insts: uint, ncaps: uint) -> Threads {\n-        Threads {\n-            which: which,\n-            queue: range(0, num_insts).map(|_| {\n-                Thread { pc: 0, groups: repeat(None).take(ncaps * 2).collect() }\n-            }).collect(),\n-            sparse: repeat(0u).take(num_insts).collect(),\n-            size: 0,\n-        }\n-    }\n-\n-    fn add(&mut self, pc: uint, groups: &[Option<uint>], empty: bool) {\n-        let t = &mut self.queue[self.size];\n-        t.pc = pc;\n-        match (empty, self.which) {\n-            (_, Exists) | (true, _) => {},\n-            (false, Location) => {\n-                t.groups[0] = groups[0];\n-                t.groups[1] = groups[1];\n-            }\n-            (false, Submatches) => {\n-                for (slot, val) in t.groups.iter_mut().zip(groups.iter()) {\n-                    *slot = *val;\n-                }\n-            }\n-        }\n-        self.sparse[pc] = self.size;\n-        self.size += 1;\n-    }\n-\n-    #[inline]\n-    fn contains(&self, pc: uint) -> bool {\n-        let s = self.sparse[pc];\n-        s < self.size && self.queue[s].pc == pc\n-    }\n-\n-    #[inline]\n-    fn empty(&mut self) {\n-        self.size = 0;\n-    }\n-\n-    #[inline]\n-    fn pc(&self, i: uint) -> uint {\n-        self.queue[i].pc\n-    }\n-\n-    #[inline]\n-    fn groups<'r>(&'r mut self, i: uint) -> &'r mut [Option<uint>] {\n-        let q = &mut self.queue[i];\n-        q.groups.as_mut_slice()\n-    }\n-}\n-\n-/// Returns true if the character is a word character, according to the\n-/// (Unicode friendly) Perl character class '\\w'.\n-/// Note that this is only use for testing word boundaries. The actual '\\w'\n-/// is encoded as a CharClass instruction.\n-pub fn is_word(c: Option<char>) -> bool {\n-    let c = match c {\n-        None => return false,\n-        Some(c) => c,\n-    };\n-    // Try the common ASCII case before invoking binary search.\n-    match c {\n-        '_' | '0' ... '9' | 'a' ... 'z' | 'A' ... 'Z' => true,\n-        _ => PERLW.binary_search_by(|&(start, end)| {\n-            if c >= start && c <= end {\n-                Equal\n-            } else if start > c {\n-                Greater\n-            } else {\n-                Less\n-            }\n-        }).is_ok()\n-    }\n-}\n-\n-/// Given a character and a single character class range, return an ordering\n-/// indicating whether the character is less than the start of the range,\n-/// in the range (inclusive) or greater than the end of the range.\n-///\n-/// If `casei` is `true`, then this ordering is computed case insensitively.\n-///\n-/// This function is meant to be used with a binary search.\n-#[inline]\n-fn class_cmp(casei: bool, mut textc: char,\n-             (mut start, mut end): (char, char)) -> Ordering {\n-    if casei {\n-        // FIXME: This is pretty ridiculous. All of this case conversion\n-        // can be moved outside this function:\n-        // 1) textc should be uppercased outside the bsearch.\n-        // 2) the character class itself should be uppercased either in the\n-        //    parser or the compiler.\n-        // FIXME: This is too simplistic for correct Unicode support.\n-        //        See also: char_eq\n-        textc = textc.to_uppercase();\n-        start = start.to_uppercase();\n-        end = end.to_uppercase();\n-    }\n-    if textc >= start && textc <= end {\n-        Equal\n-    } else if start > textc {\n-        Greater\n-    } else {\n-        Less\n-    }\n-}\n-\n-/// Returns the starting location of `needle` in `haystack`.\n-/// If `needle` is not in `haystack`, then `None` is returned.\n-///\n-/// Note that this is using a naive substring algorithm.\n-#[inline]\n-pub fn find_prefix(needle: &[u8], haystack: &[u8]) -> Option<uint> {\n-    let (hlen, nlen) = (haystack.len(), needle.len());\n-    if nlen > hlen || nlen == 0 {\n-        return None\n-    }\n-    for (offset, window) in haystack.windows(nlen).enumerate() {\n-        if window == needle {\n-            return Some(offset)\n-        }\n-    }\n-    None\n-}"}, {"sha": "b48df36a6793118c72b1526bd6ed3ad6d02260bc", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -10,28 +10,55 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic! { E0001, r##\"\n+register_long_diagnostics! {\n+    E0001: r##\"\n     This error suggests that the expression arm corresponding to the noted pattern\n     will never be reached as for all possible values of the expression being matched,\n     one of the preceeding patterns will match.\n \n     This means that perhaps some of the preceeding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n-\"## }\n+\"##,\n+\n+    E0003: r##\"\n+    Not-a-Number (NaN) values can not be compared for equality and hence can never match\n+    the input to a match expression. To match against NaN values, you should instead use\n+    the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+\"##,\n+\n+    E0004: r##\"\n+    This error indicates that the compiler can not guarantee a matching pattern for one\n+    or more possible inputs to a match expression. Guaranteed matches are required in order\n+    to assign values to match expressions, or alternatively, determine the flow of execution.\n+\n+    If you encounter this error you must alter your patterns so that every possible value of\n+    the input type is matched. For types with a small number of variants (like enums) you\n+    should probably cover all cases explicitly. Alternatively, the underscore `_` wildcard\n+    pattern can be added after all other patterns to match \"anything else\".\n+\"##,\n+\n+    // FIXME: Remove duplication here?\n+    E0005: r##\"\n+    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+    name will be extracted in all cases. If you encounter this error you probably need\n+    to use a `match` or `if let` to deal with the possibility of failure.\n+\"##,\n+\n+    E0006: r##\"\n+    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+    name will be extracted in all cases. If you encounter this error you probably need\n+    to use a `match` or `if let` to deal with the possibility of failure.\n+\"##\n+}\n \n register_diagnostics! {\n     E0002,\n-    E0003,\n-    E0004,\n-    E0005,\n-    E0006,\n     E0007,\n     E0008,\n     E0009,\n     E0010,\n     E0011,\n     E0012,\n-    E0013,\n     E0014,\n     E0015,\n     E0016,\n@@ -49,24 +76,58 @@ register_diagnostics! {\n     E0137,\n     E0138,\n     E0139,\n-    E0140,\n     E0152,\n-    E0153,\n-    E0157,\n     E0158,\n     E0161,\n     E0162,\n     E0165,\n-    E0166,\n-    E0167,\n-    E0168,\n-    E0169,\n     E0170,\n-    E0171,\n-    E0172,\n-    E0173,\n-    E0174,\n-    E0177,\n-    E0178,\n-    E0179\n+    E0261, // use of undeclared lifetime name\n+    E0262, // illegal lifetime parameter name\n+    E0263, // lifetime name declared twice in same scope\n+    E0264, // unknown external lang item\n+    E0265, // recursive constant\n+    E0266, // expected item\n+    E0267, // thing inside of a closure\n+    E0268, // thing outside of a loop\n+    E0269, // not all control paths return a value\n+    E0270, // computation may converge in a function marked as diverging\n+    E0271, // type mismatch resolving\n+    E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n+    E0273, // rustc_on_unimplemented must have named format arguments\n+    E0274, // rustc_on_unimplemented must have a value\n+    E0275, // overflow evaluating requirement\n+    E0276, // requirement appears on impl method but not on corresponding trait method\n+    E0277, // trait is not implemented for type\n+    E0278, // requirement is not satisfied\n+    E0279, // requirement is not satisfied\n+    E0280, // requirement is not satisfied\n+    E0281, // type implements trait but other trait is required\n+    E0282, // unable to infer enough type information about\n+    E0283, // cannot resolve type\n+    E0284, // cannot resolve type\n+    E0285, // overflow evaluation builtin bounds\n+    E0296, // malformed recursion limit attribute\n+    E0297, // refutable pattern in for loop binding\n+    E0298, // mismatched types between arms\n+    E0299, // mismatched types between arms\n+    E0300, // unexpanded macro\n+    E0301, // cannot mutable borrow in a pattern guard\n+    E0302, // cannot assign in a pattern guard\n+    E0303, // pattern bindings are not allowed after an `@`\n+    E0304, // expected signed integer constant\n+    E0305, // expected constant\n+    E0306, // expected positive integer for repeat count\n+    E0307, // expected constant integer for repeat count\n+    E0308,\n+    E0309, // thing may not live long enough\n+    E0310, // thing may not live long enough\n+    E0311, // thing may not live long enough\n+    E0312, // lifetime of reference outlives lifetime of borrowed content\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0314, // closure outlives stack frame\n+    E0315 // cannot invoke closure outside of its lifetime\n }\n+\n+__build_diagnostic_array! { DIAGNOSTICS }\n+"}, {"sha": "580e55f78a9e5385504780e42af0a663df5fc7e2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -40,14 +40,14 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(hash)]\n+#![cfg_attr(test, feature(test))]\n \n extern crate arena;\n extern crate flate;\n extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate regex;\n extern crate rustc_llvm;\n extern crate rustc_back;\n extern crate serialize;\n@@ -64,7 +64,9 @@ extern crate test;\n \n pub use rustc_llvm as llvm;\n \n-mod diagnostics;\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n \n pub mod back {\n     pub use rustc_back::abi;\n@@ -142,8 +144,6 @@ pub mod lib {\n     pub use llvm;\n }\n \n-__build_diagnostic_array! { DIAGNOSTICS }\n-\n // A private module so that macro-expanded idents like\n // `::rustc::lint::Lint` will also work in `rustc` itself.\n //"}, {"sha": "7f1e8acd57625aee64ab5e07890b28cb373d0bc1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1199,17 +1199,17 @@ impl LintPass for UnusedImportBraces {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n-    fn check_view_item(&mut self, cx: &Context, view_item: &ast::ViewItem) {\n-        match view_item.node {\n-            ast::ViewItemUse(ref view_path) => {\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref view_path) => {\n                 match view_path.node {\n-                    ast::ViewPathList(_, ref items, _) => {\n+                    ast::ViewPathList(_, ref items) => {\n                         if items.len() == 1 {\n                             match items[0].node {\n                                 ast::PathListIdent {ref name, ..} => {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n-                                    cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n+                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n                                                  &m[]);\n                                 },\n                                 _ => ()\n@@ -1326,7 +1326,7 @@ impl UnusedMut {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n                     if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        match mutables.entry(ident.name.uint()) {\n+                        match mutables.entry(ident.name.usize()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }\n@@ -1663,11 +1663,6 @@ impl LintPass for Stability {\n         lint_array!(DEPRECATED)\n     }\n \n-    fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n-        stability::check_view_item(cx.tcx, item,\n-                                   &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n-    }\n-\n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n         stability::check_item(cx.tcx, item,\n                               &mut |id, sp, stab| self.lint(cx, id, sp, stab));"}, {"sha": "abda815069d90068ee5170644b152564668453c5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -231,30 +231,7 @@ impl LintStore {\n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n \n-        // Insert temporary renamings for a one-time deprecation (#16545)\n-        self.register_renamed(\"unnecessary_typecast\", \"unused_typecasts\");\n-        self.register_renamed(\"unsigned_negate\", \"unsigned_negation\");\n-        self.register_renamed(\"type_limits\", \"unused_comparisons\");\n-        self.register_renamed(\"type_overflow\", \"overflowing_literals\");\n-        self.register_renamed(\"ctypes\", \"improper_ctypes\");\n-        self.register_renamed(\"owned_heap_memory\", \"box_pointers\");\n-        self.register_renamed(\"unused_attribute\", \"unused_attributes\");\n-        self.register_renamed(\"path_statement\", \"path_statements\");\n-        self.register_renamed(\"unused_result\", \"unused_results\");\n-        self.register_renamed(\"non_uppercase_statics\", \"non_upper_case_globals\");\n-        self.register_renamed(\"unnecessary_parens\", \"unused_parens\");\n-        self.register_renamed(\"unnecessary_import_braces\", \"unused_import_braces\");\n-        self.register_renamed(\"unsafe_block\", \"unsafe_blocks\");\n-        self.register_renamed(\"unnecessary_allocation\", \"unused_allocation\");\n-        self.register_renamed(\"missing_doc\", \"missing_docs\");\n-        self.register_renamed(\"unused_extern_crate\", \"unused_extern_crates\");\n-        self.register_renamed(\"unnecessary_qualification\", \"unused_qualifications\");\n-        self.register_renamed(\"unrecognized_lint\", \"unknown_lints\");\n-        self.register_renamed(\"unused_variable\", \"unused_variables\");\n-        self.register_renamed(\"dead_assignment\", \"unused_assignments\");\n-        self.register_renamed(\"unknown_crate_type\", \"unknown_crate_types\");\n-        self.register_renamed(\"variant_size_difference\", \"variant_size_differences\");\n-        self.register_renamed(\"transmute_fat_ptr\", \"fat_ptr_transmutes\");\n+        // Insert temporary renamings for a one-time deprecation\n         self.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n \n         self.register_renamed(\"unknown_features\", \"unused_features\");\n@@ -595,14 +572,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(&i.attrs[], |cx| {\n-            run_lints!(cx, check_view_item, i);\n-            cx.visit_ids(|v| v.visit_view_item(i));\n-            visit::walk_view_item(cx, i);\n-        })\n-    }\n-\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         run_lints!(self, check_pat, p);\n         visit::walk_pat(self, p);"}, {"sha": "a4a3f485af1d1034cfe4acc8d460ed8e00c31df4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -128,7 +128,6 @@ pub trait LintPass {\n     fn check_crate(&mut self, _: &Context, _: &ast::Crate) { }\n     fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n     fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_view_item(&mut self, _: &Context, _: &ast::ViewItem) { }\n     fn check_foreign_item(&mut self, _: &Context, _: &ast::ForeignItem) { }\n     fn check_item(&mut self, _: &Context, _: &ast::Item) { }\n     fn check_local(&mut self, _: &Context, _: &ast::Local) { }"}, {"sha": "7b71120ba64a6ea9807cb4f53dad5b3b7cc07904", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -40,10 +40,6 @@ pub struct CrateReader<'a> {\n }\n \n impl<'a, 'v> visit::Visitor<'v> for CrateReader<'a> {\n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        self.process_view_item(a);\n-        visit::walk_view_item(self, a);\n-    }\n     fn visit_item(&mut self, a: &ast::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n@@ -64,9 +60,8 @@ fn dump_crates(cstore: &CStore) {\n     })\n }\n \n-fn should_link(i: &ast::ViewItem) -> bool {\n+fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs[], \"no_link\")\n-\n }\n \n struct CrateInfo {\n@@ -181,29 +176,10 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn process_view_item(&mut self, i: &ast::ViewItem) {\n-        if !should_link(i) {\n-            return;\n-        }\n-\n-        match self.extract_crate_info(i) {\n-            Some(info) => {\n-                let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      &info.ident[],\n-                                                      &info.name[],\n-                                                      None,\n-                                                      i.span,\n-                                                      PathKind::Crate);\n-                self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-            }\n-            None => ()\n-        }\n-    }\n-\n-    fn extract_crate_info(&self, i: &ast::ViewItem) -> Option<CrateInfo> {\n+    fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n-            ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n-                let ident = token::get_ident(ident);\n+            ast::ItemExternCrate(ref path_opt) => {\n+                let ident = token::get_ident(i.ident);\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n                        ident, path_opt);\n                 let name = match *path_opt {\n@@ -218,16 +194,34 @@ impl<'a> CrateReader<'a> {\n                 Some(CrateInfo {\n                     ident: ident.get().to_string(),\n                     name: name,\n-                    id: id,\n+                    id: i.id,\n                     should_link: should_link(i),\n                 })\n             }\n             _ => None\n         }\n     }\n \n-    fn process_item(&self, i: &ast::Item) {\n+    fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if !should_link(i) {\n+                    return;\n+                }\n+\n+                match self.extract_crate_info(i) {\n+                    Some(info) => {\n+                        let (cnum, _, _) = self.resolve_crate(&None,\n+                                                              &info.ident[],\n+                                                              &info.name[],\n+                                                              None,\n+                                                              i.span,\n+                                                              PathKind::Crate);\n+                        self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                    }\n+                    None => ()\n+                }\n+            }\n             ast::ItemForeignMod(ref fm) => {\n                 if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n                     return;\n@@ -533,7 +527,7 @@ impl<'a> CrateReader<'a> {\n \n #[derive(Copy)]\n pub enum CrateOrString<'a> {\n-    Krate(&'a ast::ViewItem),\n+    Krate(&'a ast::Item),\n     Str(&'a str)\n }\n "}, {"sha": "7b7159da4385df37d9536543846695990caaf599", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -242,7 +242,7 @@ impl MetadataBlob {\n                        ((slice[2] as u32) << 8) |\n                        ((slice[3] as u32) << 0)) as uint;\n             if len + 4 <= slice.len() {\n-                slice.slice(4, len + 4)\n+                &slice[4.. len + 4]\n             } else {\n                 &[] // corrupt or old metadata\n             }"}, {"sha": "1197276b9908ff6f4a3c6b1c7c8ff65cac298f27", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -74,7 +74,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(&elt.data[(elt.start + 4) .. elt.end]) {\n+        if eq_fn(&elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {"}, {"sha": "d0989160488f2da416d39fef8a5fc143cab3092c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1456,8 +1456,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n         }\n       }\n-      ast::ItemMac(..) => {\n-        // macros are encoded separately\n+      ast::ItemExternCrate(_) | ast::ItemUse(_) |ast::ItemMac(..) => {\n+        // these are encoded separately\n       }\n     }\n }"}, {"sha": "b1043a4152cfc74d1867f49a9313756f49a32483", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -392,11 +392,11 @@ impl<'a> Context<'a> {\n             };\n             let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n-                (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n+                (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n                  true)\n             } else if file.starts_with(dylib_prefix.as_slice()) &&\n                       file.ends_with(dypair.1.as_slice()) {\n-                (file.slice(dylib_prefix.len(), file.len() - dypair.1.len()),\n+                (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n                  false)\n             } else {\n                 return FileDoesntMatch"}, {"sha": "943be282103a70a8e640e8a986579962e75f8c1d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -243,19 +243,6 @@ fn parse_size(st: &mut PState) -> Option<uint> {\n     }\n }\n \n-fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        '~' => ty::UniqTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n-        c => {\n-            st.tcx.sess.bug(&format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c)[])\n-        }\n-    }\n-}\n-\n fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n                                              mut f: F)\n                                              -> VecPerParamSpace<T> where\n@@ -641,14 +628,6 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     })\n }\n \n-fn parse_onceness(c: char) -> ast::Onceness {\n-    match c {\n-        'o' => ast::Once,\n-        'm' => ast::Many,\n-        _ => panic!(\"parse_onceness: bad onceness\")\n-    }\n-}\n-\n fn parse_closure_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n                                  mut conv: F) -> ty::ClosureTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n@@ -661,16 +640,10 @@ fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let unsafety = parse_unsafety(next(st));\n-    let onceness = parse_onceness(next(st));\n-    let store = parse_trait_store_(st, conv);\n-    let bounds = parse_existential_bounds_(st, conv);\n     let sig = parse_sig_(st, conv);\n     let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         unsafety: unsafety,\n-        onceness: onceness,\n-        store: store,\n-        bounds: bounds,\n         sig: sig,\n         abi: abi,\n     }\n@@ -734,7 +707,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     }\n \n     let crate_part = &buf[0u..colon_idx];\n-    let def_part = &buf[(colon_idx + 1u)..len];\n+    let def_part = &buf[colon_idx + 1u..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "9aead5bf4e7f8ade91c33639a1512e4736f1297a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -305,17 +305,6 @@ pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     enc_substs(w, cx, s.substs);\n }\n \n-pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore) {\n-    match s {\n-        ty::UniqTraitStore => mywrite!(w, \"~\"),\n-        ty::RegionTraitStore(re, m) => {\n-            mywrite!(w, \"&\");\n-            enc_region(w, cx, re);\n-            enc_mutability(w, m);\n-        }\n-    }\n-}\n-\n fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),\n@@ -329,13 +318,6 @@ fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: &mut SeekableMemWriter, o: ast::Onceness) {\n-    match o {\n-        ast::Once => mywrite!(w, \"o\"),\n-        ast::Many => mywrite!(w, \"m\")\n-    }\n-}\n-\n pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::BareFnTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n@@ -346,9 +328,6 @@ pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::ClosureTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n-    enc_onceness(w, ft.onceness);\n-    enc_trait_store(w, cx, ft.store);\n-    enc_existential_bounds(w, cx, &ft.bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);\n }"}, {"sha": "537a2b3f545a2e4579e29beaa36897965b10a26f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -332,8 +332,6 @@ impl Folder for NestedItemsDropper {\n                 }\n             }).collect();\n             let blk_sans_items = P(ast::Block {\n-                view_items: Vec::new(), // I don't know if we need the view_items\n-                                        // here, but it doesn't break tests!\n                 stmts: stmts_sans_items,\n                 expr: expr,\n                 id: id,\n@@ -515,17 +513,6 @@ impl tr for ty::BoundRegion {\n     }\n }\n \n-impl tr for ty::TraitStore {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::TraitStore {\n-        match *self {\n-            ty::RegionTraitStore(r, m) => {\n-                ty::RegionTraitStore(r.tr(dcx), m)\n-            }\n-            ty::UniqTraitStore => ty::UniqTraitStore\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n "}, {"sha": "1a2162b3076ece7a2a85affafe7f025635796369", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &*args[0], args.slice_from(1).iter().map(|e| &**e))\n+                self.call(expr, pred, &*args[0], args[1..].iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |"}, {"sha": "623f3525d4a90b3111740d20ce7e43b51d50c38a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -73,12 +73,12 @@ impl<'a> CheckLoopVisitor<'a> {\n         match self.cx {\n             Loop => {}\n             Closure => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` inside of a closure\", name)[]);\n+                span_err!(self.sess, span, E0267,\n+                                   \"`{}` inside of a closure\", name);\n             }\n             Normal => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` outside of loop\", name)[]);\n+                span_err!(self.sess, span, E0268,\n+                                   \"`{}` outside of loop\", name);\n             }\n         }\n     }"}, {"sha": "aa803d9d8aea5b6971bebb648f61e7e250681114", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -57,7 +57,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n /// ++++++++++++++++++++++++++\n /// + _     + [_, _, ..tail] +\n /// ++++++++++++++++++++++++++\n-impl<'a> fmt::Show for Matrix<'a> {\n+impl<'a> fmt::Debug for Matrix<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"\\n\"));\n \n@@ -226,11 +226,10 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n         ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n-                cx.tcx.sess.span_err(\n-                    pat.span,\n-                    &format!(\"refutable pattern in `for` loop binding: \\\n+                span_err!(cx.tcx.sess, pat.span, E0297,\n+                    \"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat))[]);\n+                            pat_to_string(uncovered_pat));\n             });\n \n             // Check legality of move bindings.\n@@ -869,7 +868,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -882,7 +881,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -921,13 +920,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatMac(_) => {\n-            cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n+            span_err!(cx.tcx.sess, pat_span, E0300, \"unexpanded macro\");\n             None\n         }\n     };\n     head.map(|mut head| {\n         head.push_all(&r[..col]);\n-        head.push_all(&r[(col + 1)..]);\n+        head.push_all(&r[col + 1..]);\n         head\n     })\n }\n@@ -1082,11 +1081,8 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n               _: LoanCause) {\n         match kind {\n             MutBorrow => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span,\n-                              \"cannot mutably borrow in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0301,\n+                          \"cannot mutably borrow in a pattern guard\")\n             }\n             ImmBorrow | UniqueImmBorrow => {}\n         }\n@@ -1095,10 +1091,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n             JustWrite | WriteAndRead => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span, \"cannot assign in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n             }\n             Init => {}\n         }\n@@ -1120,7 +1113,7 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n-            self.cx.tcx.sess.span_err(pat.span,\n+            span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                       \"pattern bindings are not allowed \\\n                                        after an `@`\");\n         }"}, {"sha": "4280b7fe3f09649170a73dc7e37f90873a22fa9f", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -83,7 +83,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n-            self.sess.span_err(self.root_it.span, \"recursive constant\");\n+            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n             return;\n         }\n         self.idstack.push(it.id);\n@@ -103,9 +103,9 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                             self.visit_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n-                            self.sess.span_err(e.span,\n-                              &format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node))[]);\n+                            span_err!(self.sess, e.span, E0266,\n+                              \"expected item, found {}\",\n+                                      self.ast_map.node_to_string(def_id.node));\n                             return;\n                           },\n                         }"}, {"sha": "a17278698103167229069e82b10248c4ff08b49f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -118,17 +118,17 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             assert!(self.bits_per_id > 0);\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n             let (start, end) = self.compute_id_range(cfgidx);\n-            let on_entry = self.on_entry.slice(start, end);\n+            let on_entry = &self.on_entry[start.. end];\n             let entry_str = bits_to_string(on_entry);\n \n-            let gens = self.gens.slice(start, end);\n+            let gens = &self.gens[start.. end];\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n                 format!(\" gen: {}\", bits_to_string(gens))\n             } else {\n                 \"\".to_string()\n             };\n \n-            let kills = self.kills.slice(start, end);\n+            let kills = &self.kills[start .. end];\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n                 format!(\" kill: {}\", bits_to_string(kills))\n             } else {\n@@ -232,7 +232,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice_mut(start, end);\n+        let gens = &mut self.gens[start.. end];\n         set_bit(gens, bit);\n     }\n \n@@ -245,7 +245,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = self.kills.slice_mut(start, end);\n+        let kills = &mut self.kills[start.. end];\n         set_bit(kills, bit);\n     }\n \n@@ -256,9 +256,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.bits_per_id > 0);\n \n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n+        let gens = &self.gens[start.. end];\n         bitwise(bits, gens, &Union);\n-        let kills = self.kills.slice(start, end);\n+        let kills = &self.kills[start.. end];\n         bitwise(bits, kills, &Subtract);\n \n         debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n@@ -304,7 +304,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n \n         let (start, end) = self.compute_id_range(cfgidx);\n-        let on_entry = self.on_entry.slice(start, end);\n+        let on_entry = &self.on_entry[start.. end];\n         let temp_bits;\n         let slice = match e {\n             Entry => on_entry,\n@@ -336,7 +336,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n+        let gens = &self.gens[start.. end];\n         debug!(\"{} each_gen_bit(id={}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n@@ -396,15 +396,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         cfg.graph.each_edge(|_edge_index, edge| {\n             let flow_exit = edge.source();\n             let (start, end) = self.compute_id_range(flow_exit);\n-            let mut orig_kills = self.kills.slice(start, end).to_vec();\n+            let mut orig_kills = self.kills[start.. end].to_vec();\n \n             let mut changed = false;\n             for &node_id in edge.data.exiting_scopes.iter() {\n                 let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);\n-                        let kills = self.kills.slice(start, end);\n+                        let kills = &self.kills[start.. end];\n                         if bitwise(orig_kills.as_mut_slice(), kills, &Union) {\n                             changed = true;\n                         }\n@@ -418,7 +418,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             }\n \n             if changed {\n-                let bits = self.kills.slice_mut(start, end);\n+                let bits = &mut self.kills[start.. end];\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.clone_from_slice(&orig_kills[]);\n@@ -487,7 +487,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             let (start, end) = self.dfcx.compute_id_range(node_index);\n \n             // Initialize local bitvector with state on-entry.\n-            in_out.clone_from_slice(self.dfcx.on_entry.slice(start, end));\n+            in_out.clone_from_slice(&self.dfcx.on_entry[start.. end]);\n \n             // Compute state on-exit by applying transfer function to\n             // state on-entry.\n@@ -528,13 +528,13 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)\n-            let on_entry = self.dfcx.on_entry.slice_mut(start, end);\n+            let on_entry = &mut self.dfcx.on_entry[start.. end];\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n             debug!(\"{} changed entry set for {:?} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n-                   bits_to_string(self.dfcx.on_entry.slice(start, end)));\n+                   bits_to_string(&self.dfcx.on_entry[start.. end]));\n             self.changed = true;\n         }\n     }"}, {"sha": "affeef330c4541cbafeae7e255fcb449fc3407b6", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -32,7 +32,7 @@\n \n #![allow(dead_code)] // still WIP\n \n-use std::fmt::{Formatter, Error, Show};\n+use std::fmt::{Formatter, Error, Debug};\n use std::uint;\n use std::collections::BitvSet;\n \n@@ -53,7 +53,7 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n-impl<E: Show> Show for Edge<E> {\n+impl<E: Debug> Debug for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n         write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n                self.next_edge[0], self.next_edge[1], self.source,\n@@ -353,7 +353,7 @@ impl<E> Edge<E> {\n #[cfg(test)]\n mod test {\n     use middle::graph::*;\n-    use std::fmt::Show;\n+    use std::fmt::Debug;\n \n     type TestNode = Node<&'static str>;\n     type TestEdge = Edge<&'static str>;\n@@ -408,7 +408,7 @@ mod test {\n         });\n     }\n \n-    fn test_adjacent_edges<N:PartialEq+Show,E:PartialEq+Show>(graph: &Graph<N,E>,\n+    fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n                                       start_index: NodeIndex,\n                                       start_data: N,\n                                       expected_incoming: &[(E,N)],"}, {"sha": "3280769ff03866bedbb3ad4dd9c0271299674b34", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -202,39 +202,6 @@ pub trait Combine<'tcx> : Sized {\n                          sig: sig})\n     }\n \n-    fn closure_tys(&self, a: &ty::ClosureTy<'tcx>,\n-                   b: &ty::ClosureTy<'tcx>) -> cres<'tcx, ty::ClosureTy<'tcx>> {\n-\n-        let store = match (a.store, b.store) {\n-            (ty::RegionTraitStore(a_r, a_m),\n-             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                let r = try!(self.contraregions(a_r, b_r));\n-                ty::RegionTraitStore(r, a_m)\n-            }\n-\n-            _ if a.store == b.store => {\n-                a.store\n-            }\n-\n-            _ => {\n-                return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n-            }\n-        };\n-        let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n-        let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = try!(self.existential_bounds(&a.bounds, &b.bounds));\n-        let sig = try!(self.binders(&a.sig, &b.sig));\n-        let abi = try!(self.abi(a.abi, b.abi));\n-        Ok(ty::ClosureTy {\n-            unsafety: unsafety,\n-            onceness: onceness,\n-            store: store,\n-            bounds: bounds,\n-            sig: sig,\n-            abi: abi,\n-        })\n-    }\n-\n     fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n         if a.variadic != b.variadic {\n             return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n@@ -356,31 +323,6 @@ pub trait Combine<'tcx> : Sized {\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n-    fn trait_stores(&self,\n-                    vk: ty::terr_vstore_kind,\n-                    a: ty::TraitStore,\n-                    b: ty::TraitStore)\n-                    -> cres<'tcx, ty::TraitStore> {\n-        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n-\n-        match (a, b) {\n-            (ty::RegionTraitStore(a_r, a_m),\n-             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::RegionTraitStore(r, a_m))\n-                })\n-            }\n-\n-            _ if a == b => {\n-                Ok(a)\n-            }\n-\n-            _ => {\n-                Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n-            }\n-        }\n-    }\n-\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)"}, {"sha": "18c36f870b5bce09da24a3222f81d46bc56a487f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -371,12 +371,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n-        self.tcx.sess.span_err(\n-            trace.origin.span(),\n-            &format!(\"{}: {} ({})\",\n+        span_err!(self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr))[]);\n+                 ty::type_err_to_str(self.tcx, terr));\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -443,9 +442,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0309,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -456,9 +454,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0310,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -468,11 +465,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\n+                span_err!(self.tcx.sess, origin.span(), E0311,\n                         \"{} may not live long enough\",\n-                        labeled_user_string)[]);\n+                        labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -499,8 +494,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n                 note_and_explain_region(\n@@ -515,14 +509,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"lifetime of borrowed pointer outlives \\\n+                span_err!(self.tcx.sess, span, E0313,\n+                    \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[]);\n+                                .to_string());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -539,8 +532,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n                 note_and_explain_region(\n                     self.tcx,\n@@ -554,8 +546,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "9339f435d8fa01853080f199079612fb11b3ca14", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -609,8 +609,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n                                        -> Vec<RegionVid>\n     {\n-        self.undo_log.borrow()\n-            .slice_from(mark.length)\n+        self.undo_log.borrow()[mark.length..]\n             .iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n@@ -637,7 +636,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n             for undo_entry in\n-                self.undo_log.borrow().slice_from(mark.length).iter()\n+                self.undo_log.borrow()[mark.length..].iter()\n             {\n                 match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {"}, {"sha": "ed11cafdca9b5573015fe077ba260f729a68f3b6", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -17,7 +17,7 @@ use middle::ty::{self, Ty};\n use middle::infer::{uok, ures};\n use middle::infer::InferCtxt;\n use std::cell::RefCell;\n-use std::fmt::Show;\n+use std::fmt::Debug;\n use syntax::ast;\n use util::ppaux::Repr;\n use util::snapshot_vec as sv;\n@@ -32,7 +32,7 @@ use util::snapshot_vec as sv;\n /// (possibly not yet known) sort of integer.\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey<'tcx, V> : Clone + Show + PartialEq + Repr<'tcx> {\n+pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;"}, {"sha": "2c0de9d16348618359f78709e9739e031031329e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -320,9 +320,7 @@ lets_do_this! {\n     ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n \n-    NoSendItem,                      \"no_send_bound\",           no_send_bound;\n     NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n-    NoSyncItem,                      \"no_sync_bound\",           no_sync_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n \n     NonZeroItem,                     \"non_zero\",                non_zero;"}, {"sha": "43989d0aadc8adf1322e8cc744f4cb7cd13958cf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -198,13 +198,13 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-impl fmt::Show for LiveNode {\n+impl fmt::Debug for LiveNode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ln({})\", self.get())\n     }\n }\n \n-impl fmt::Show for Variable {\n+impl fmt::Debug for Variable {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"v({})\", self.get())\n     }\n@@ -1557,8 +1557,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             },\n                         _ => false\n                     };\n-                    self.ir.tcx.sess.span_err(\n-                        sp, \"not all control paths return a value\");\n+                    span_err!(self.ir.tcx.sess, sp, E0269, \"not all control paths return a value\");\n                     if ends_with_stmt {\n                         let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n@@ -1575,7 +1574,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n             ty::FnDiverging\n                 if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n-                    self.ir.tcx.sess.span_err(sp,\n+                    span_err!(self.ir.tcx.sess, sp, E0270,\n                         \"computation may converge in a function marked as diverging\");\n                 }\n "}, {"sha": "b93cde4bf646448b4c315279e1823cf1be0aaa49", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -297,6 +297,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n+                    ast::ItemExternCrate(_) | ast::ItemUse(_) |\n                     ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n                     ast::ItemMod(..) | ast::ItemForeignMod(..) |\n                     ast::ItemImpl(..) | ast::ItemTrait(..) |"}, {"sha": "81cbdf13c518925c60ef57b9b1d260a42fb8b870", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -33,7 +33,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n             }\n         }\n \n-        sess.span_err(attr.span, \"malformed recursion limit attribute, \\\n+        span_err!(sess, attr.span, E0296, \"malformed recursion limit attribute, \\\n                                   expected #![recursion_limit=\\\"N\\\"]\");\n     }\n }"}, {"sha": "b4b2e1b63e80cfe4c0f950df38c12418ef5160e6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -22,9 +22,6 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n-// NOTE(stage0) remove import after a snapshot\n-#[cfg(stage0)]\n-use std::hash::{Hash};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};"}, {"sha": "030bf26699fb23778ee57f58f3d38ceb3724256c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -94,6 +94,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     // Fn lifetimes get added in visit_fn below:\n                     visit::walk_item(this, item);\n                 }\n+                ast::ItemExternCrate(_) |\n+                ast::ItemUse(_) |\n                 ast::ItemMod(..) |\n                 ast::ItemMac(..) |\n                 ast::ItemForeignMod(..) |\n@@ -396,10 +398,9 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n-        self.sess.span_err(\n-            lifetime_ref.span,\n-            &format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name))[]);\n+        span_err!(self.sess, lifetime_ref.span, E0261,\n+            \"use of undeclared lifetime name `{}`\",\n+                    token::get_name(lifetime_ref.name));\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -409,11 +410,9 @@ impl<'a> LifetimeContext<'a> {\n             let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n-                    self.sess.span_err(\n-                        lifetime.lifetime.span,\n-                        &format!(\"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.lifetime.name))\n-                        []);\n+                    span_err!(self.sess, lifetime.lifetime.span, E0262,\n+                        \"illegal lifetime parameter name: `{}`\",\n+                                token::get_name(lifetime.lifetime.name));\n                 }\n             }\n \n@@ -422,12 +421,10 @@ impl<'a> LifetimeContext<'a> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    self.sess.span_err(\n-                        lifetime_j.lifetime.span,\n-                        &format!(\"lifetime name `{}` declared twice in \\\n+                    span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n+                        \"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.lifetime.name))\n-                        []);\n+                                token::get_name(lifetime_j.lifetime.name));\n                 }\n             }\n \n@@ -462,11 +459,11 @@ impl<'a> LifetimeContext<'a> {\n                             format!(\"lifetime name `{}` shadows another \\\n                                     lifetime name that is already in scope\",\n                                     token::get_name(lifetime.name)).as_slice());\n-                        self.sess.span_help(\n+                        self.sess.span_note(\n                             lifetime_def.span,\n                             format!(\"shadowed lifetime `{}` declared here\",\n                                     token::get_name(lifetime.name)).as_slice());\n-                        self.sess.span_help(\n+                        self.sess.span_note(\n                             lifetime.span,\n                             \"shadowed lifetimes are deprecated \\\n                              and will become a hard error before 1.0\");\n@@ -602,7 +599,7 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n     }\n }\n \n-impl<'a> fmt::Show for ScopeChain<'a> {\n+impl<'a> fmt::Debug for ScopeChain<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),"}, {"sha": "714dd7d98cf427c8517706faf21f2c26efb24f1a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -244,12 +244,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n-    fn visit_view_item(&mut self, item: &ast::ViewItem) {\n-        check_view_item(self.tcx, item,\n-                        &mut |id, sp, stab| self.check(id, sp, stab));\n-        visit::walk_view_item(self, item)\n-    }\n-\n     fn visit_item(&mut self, item: &ast::Item) {\n         check_item(self.tcx, item,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n@@ -264,22 +258,34 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_view_item(tcx: &ty::ctxt, item: &ast::ViewItem,\n-                       cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n-    // compiler-generated `extern crate` statements have a dummy span.\n-    if item.span == DUMMY_SP { return }\n-\n-    let id = match item.node {\n-        ast::ViewItemExternCrate(_, _, id) => id,\n-        ast::ViewItemUse(..) => return,\n-    };\n-    let cnum = match tcx.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-        Some(cnum) => cnum,\n-        None => return,\n-    };\n-    let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n-\n-    maybe_do_stability_check(tcx, id, item.span, cb);\n+pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    match item.node {\n+        ast::ItemExternCrate(_) => {\n+            // compiler-generated `extern crate` items have a dummy span.\n+            if item.span == DUMMY_SP { return }\n+\n+            let cnum = match tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                Some(cnum) => cnum,\n+                None => return,\n+            };\n+            let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+            maybe_do_stability_check(tcx, id, item.span, cb);\n+        }\n+        ast::ItemTrait(_, _, ref supertraits, _) => {\n+            for t in supertraits.iter() {\n+                if let ast::TraitTyParamBound(ref t, _) = *t {\n+                    let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n+                    maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n+                }\n+            }\n+        }\n+        ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n+            let id = ty::trait_ref_to_def_id(tcx, t);\n+            maybe_do_stability_check(tcx, id, t.path.span, cb);\n+        }\n+        _ => (/* pass */)\n+    }\n }\n \n /// Helper for discovering nodes to check for stability\n@@ -331,28 +337,6 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n-/// Helper for discovering nodes to check for stability\n-pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n-    if is_internal(tcx, item.span) { return }\n-\n-    match item.node {\n-        ast::ItemTrait(_, _, ref supertraits, _) => {\n-            for t in supertraits.iter() {\n-                if let ast::TraitTyParamBound(ref t, _) = *t {\n-                    let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n-                    maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n-                }\n-            }\n-        }\n-        ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n-            let id = ty::trait_ref_to_def_id(tcx, t);\n-            maybe_do_stability_check(tcx, id, t.path.span, cb);\n-        }\n-        _ => (/* pass */)\n-    }\n-}\n-\n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n                             cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     if !is_staged_api(tcx, id) { return  }"}, {"sha": "889d8b4052f0f4d0a73c834dc36f76348da16d68", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -238,7 +238,7 @@ pub struct SeparateVecsPerParamSpace<T> {\n     pub fns: Vec<T>,\n }\n \n-impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n+impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n         for space in ParamSpace::all().iter() {\n@@ -373,12 +373,12 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.slice(start, limit)\n+        &self.content[start.. limit]\n     }\n \n     pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.slice_mut(start, limit)\n+        &mut self.content[start.. limit]\n     }\n \n     pub fn opt_get<'a>(&'a self,"}, {"sha": "7ccb5e6e7116022f811c8546b104de064399afac", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -55,12 +55,10 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     if !predicate.references_error() {\n-        infcx.tcx.sess.span_err(\n-            obligation.cause.span,\n-            format!(\n+        span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n                 predicate.user_string(infcx.tcx),\n-                ty::type_err_to_str(infcx.tcx, &error.err)).as_slice());\n+                ty::type_err_to_str(infcx.tcx, &error.err));\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -97,28 +95,25 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             Position::ArgumentNamed(s) => match generic_map.get(s) {\n                                 Some(val) => Some(val.as_slice()),\n                                 None => {\n-                                    infcx.tcx.sess\n-                                         .span_err(err_sp,\n-                                                   format!(\"the #[rustc_on_unimplemented] \\\n+                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n+                                                   \"the #[rustc_on_unimplemented] \\\n                                                             attribute on \\\n                                                             trait definition for {} refers to \\\n                                                             non-existent type parameter {}\",\n-                                                           trait_str, s)\n-                                                   .as_slice());\n+                                                           trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n                             },\n                             _ => {\n-                                infcx.tcx.sess\n-                                     .span_err(err_sp,\n-                                               format!(\"the #[rustc_on_unimplemented] \\\n+                                     span_err!(infcx.tcx.sess, err_sp, E0273,\n+                                               \"the #[rustc_on_unimplemented] \\\n                                                         attribute on \\\n                                                         trait definition for {} must have named \\\n                                                         format arguments, \\\n                                                         eg `#[rustc_on_unimplemented = \\\n                                                         \\\"foo {{T}}\\\"]`\",\n-                                                       trait_str).as_slice());\n+                                                       trait_str);\n                                 errored = true;\n                                 None\n                             }\n@@ -130,11 +125,11 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     report = Some(err);\n                 }\n             } else {\n-                infcx.tcx.sess.span_err(err_sp,\n-                                        format!(\"the #[rustc_on_unimplemented] attribute on \\\n+                span_err!(infcx.tcx.sess, err_sp, E0274,\n+                                        \"the #[rustc_on_unimplemented] attribute on \\\n                                                  trait definition for {} must have a value, \\\n                                                  eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                 trait_str).as_slice());\n+                                                 trait_str);\n             }\n             break;\n         }\n@@ -151,11 +146,9 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             // We could track the stack here more precisely if we wanted, I imagine.\n             let predicate =\n                 infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-            infcx.tcx.sess.span_err(\n-                obligation.cause.span,\n-                format!(\n+            span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n                     \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(infcx.tcx)).as_slice());\n+                    predicate.user_string(infcx.tcx));\n \n             suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -165,12 +158,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         SelectionError::Unimplemented => {\n             match &obligation.cause.code {\n                 &ObligationCauseCode::CompareImplMethodObligation => {\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n+                    span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string(infcx.tcx)).as_slice());\n+                            obligation.predicate.user_string(infcx.tcx));;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -180,12 +171,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                             if !trait_predicate.references_error() {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n                                         trait_ref.user_string(infcx.tcx),\n-                                        trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                                        trait_ref.self_ty().user_string(infcx.tcx));\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n@@ -200,35 +189,29 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         ty::Predicate::Equate(ref predicate) => {\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.equality_predicate(obligation.cause.span,\n-                                                               &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                                                               &predicate).err().unwrap();\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                                      &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                                                                      &predicate).err().unwrap();\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                                 let predicate =\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string(infcx.tcx)).as_slice());\n+                                        predicate.user_string(infcx.tcx));\n                         }\n                     }\n                 }\n@@ -239,15 +222,13 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n                         expected_trait_ref.self_ty().user_string(infcx.tcx),\n                         expected_trait_ref.user_string(infcx.tcx),\n                         actual_trait_ref.user_string(infcx.tcx),\n-                        ty::type_err_to_str(infcx.tcx, e)).as_slice());\n+                        ty::type_err_to_str(infcx.tcx, e));\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -293,18 +274,14 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations required\",\n-                                self_ty.user_string(infcx.tcx)).as_slice());\n+                                self_ty.user_string(infcx.tcx));\n                     } else {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string(infcx.tcx)).as_slice());\n+                                predicate.user_string(infcx.tcx));;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -323,11 +300,9 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string(infcx.tcx)).as_slice());\n+                        predicate.user_string(infcx.tcx));;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }"}, {"sha": "568286e39d597df84be12997581b347890fcbd5b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -84,6 +84,7 @@ pub struct FulfillmentContext<'tcx> {\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n }\n \n+#[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region,\n     pub sup_type: Ty<'tcx>,"}, {"sha": "89459f95b879fe730c020fc9ab88ae94309b54ba", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -379,11 +379,10 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             false\n         }\n         Err(Overflow) => {\n-            infcx.tcx.sess.span_err(\n-                span,\n-                format!(\"overflow evaluating whether `{}` is `{}`\",\n-                        ty.user_string(infcx.tcx),\n-                        bound.user_string(infcx.tcx)).as_slice());\n+            span_err!(infcx.tcx.sess, span, E0285,\n+                \"overflow evaluating whether `{}` is `{}`\",\n+                      ty.user_string(infcx.tcx),\n+                      bound.user_string(infcx.tcx));\n             suggest_new_overflow_limit(infcx.tcx, span);\n             false\n         }"}, {"sha": "e8d82150ade4bd2888c9d06ad5c93b7e1beafd4d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1554,10 +1554,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let tcx = this.tcx();\n             match bound {\n                 ty::BoundSend => {\n-                    if\n-                        Some(def_id) == tcx.lang_items.no_send_bound() ||\n-                        Some(def_id) == tcx.lang_items.managed_bound()\n-                    {\n+                    if Some(def_id) == tcx.lang_items.managed_bound() {\n                         return Err(Unimplemented)\n                     }\n                 }\n@@ -1568,7 +1565,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 ty::BoundSync => {\n                     if\n-                        Some(def_id) == tcx.lang_items.no_sync_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound() ||\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {"}, {"sha": "bdf9b16f139602346c2d3b88d34d2009ff0733fd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -236,13 +236,13 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n+impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)\n     }\n }\n \n-impl<'tcx> fmt::Show for super::VtableObjectData<'tcx> {\n+impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableObject(...)\")\n     }\n@@ -449,7 +449,7 @@ impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n+impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n@@ -465,7 +465,7 @@ impl<'tcx> Repr<'tcx> for super::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Show for super::MismatchedProjectionTypes<'tcx> {\n+impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"MismatchedProjectionTypes(..)\")\n     }"}, {"sha": "83bbdf14e4a74e4029145df21ded019da80afe00", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 90, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -17,7 +17,6 @@ pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n pub use self::UnboxedClosureKind::*;\n-pub use self::TraitStore::*;\n pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n@@ -61,7 +60,7 @@ use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::TypeWalker;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n-use util::ppaux::{trait_store_to_string, ty_to_string};\n+use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -70,7 +69,7 @@ use util::nodemap::{FnvHashMap};\n use arena::TypedArena;\n use std::borrow::{BorrowFrom, Cow};\n use std::cell::{Cell, RefCell};\n-use std::cmp::{self, Ordering};\n+use std::cmp;\n use std::fmt::{self, Show};\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n use std::mem;\n@@ -247,14 +246,6 @@ pub struct mt<'tcx> {\n     pub mutbl: ast::Mutability,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show)]\n-pub enum TraitStore {\n-    /// Box<Trait>\n-    UniqTraitStore,\n-    /// &Trait and &mut Trait\n-    RegionTraitStore(Region, ast::Mutability),\n-}\n-\n #[derive(Clone, Copy, Show)]\n pub struct field_ty {\n     pub name: Name,\n@@ -934,7 +925,7 @@ pub struct TyS<'tcx> {\n     region_depth: u32,\n }\n \n-impl fmt::Show for TypeFlags {\n+impl fmt::Debug for TypeFlags {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.bits)\n     }\n@@ -1041,11 +1032,8 @@ pub struct BareFnTy<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n-    pub onceness: ast::Onceness,\n-    pub store: TraitStore,\n-    pub bounds: ExistentialBounds<'tcx>,\n-    pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n+    pub sig: PolyFnSig<'tcx>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n@@ -1545,7 +1533,6 @@ pub enum type_err<'tcx> {\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n-    terr_sigil_mismatch(expected_found<TraitStore>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -1559,7 +1546,6 @@ pub enum type_err<'tcx> {\n     terr_regions_no_overlap(Region, Region),\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_sorts(expected_found<Ty<'tcx>>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n@@ -1703,37 +1689,37 @@ impl cmp::PartialEq for InferRegion {\n     }\n }\n \n-impl fmt::Show for TyVid {\n+impl fmt::Debug for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n         write!(f, \"_#{}t\", self.index)\n     }\n }\n \n-impl fmt::Show for IntVid {\n+impl fmt::Debug for IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}i\", self.index)\n     }\n }\n \n-impl fmt::Show for FloatVid {\n+impl fmt::Debug for FloatVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}f\", self.index)\n     }\n }\n \n-impl fmt::Show for RegionVid {\n+impl fmt::Debug for RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"'_#{}r\", self.index)\n     }\n }\n \n-impl<'tcx> fmt::Show for FnSig<'tcx> {\n+impl<'tcx> fmt::Debug for FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n     }\n }\n \n-impl fmt::Show for InferTy {\n+impl fmt::Debug for InferTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TyVar(ref v) => v.fmt(f),\n@@ -1745,7 +1731,7 @@ impl fmt::Show for InferTy {\n     }\n }\n \n-impl fmt::Show for IntVarValue {\n+impl fmt::Debug for IntVarValue {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             IntType(ref v) => v.fmt(f),\n@@ -3319,7 +3305,7 @@ impl ops::Sub for TypeContents {\n     }\n }\n \n-impl fmt::Show for TypeContents {\n+impl fmt::Debug for TypeContents {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TypeContents({:b})\", self.bits)\n     }\n@@ -4194,19 +4180,6 @@ pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n     ty_fn_sig(fty).inputs()\n }\n \n-pub fn ty_closure_store(fty: Ty) -> TraitStore {\n-    match fty.sty {\n-        ty_unboxed_closure(..) => {\n-            // Close enough for the purposes of all the callers of this\n-            // function (which is soon to be deprecated anyhow).\n-            UniqTraitStore\n-        }\n-        ref s => {\n-            panic!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n-        }\n-    }\n-}\n-\n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => f.sig.output(),\n@@ -4751,13 +4724,6 @@ impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n-    fn tstore_to_closure(s: &TraitStore) -> String {\n-        match s {\n-            &UniqTraitStore => \"proc\".to_string(),\n-            &RegionTraitStore(..) => \"closure\".to_string()\n-        }\n-    }\n-\n     match *err {\n         terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n         terr_mismatch => \"types differ\".to_string(),\n@@ -4776,11 +4742,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                     values.expected,\n                     values.found)\n         }\n-        terr_sigil_mismatch(values) => {\n-            format!(\"expected {}, found {}\",\n-                    tstore_to_closure(&values.expected),\n-                    tstore_to_closure(&values.found))\n-        }\n         terr_mutability => \"values differ in mutability\".to_string(),\n         terr_box_mutability => {\n             \"boxed values differ in mutability\".to_string()\n@@ -4828,11 +4789,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                      found bound lifetime parameter {}\",\n                     bound_region_ptr_to_string(cx, br))\n         }\n-        terr_trait_stores_differ(_, ref values) => {\n-            format!(\"trait storage differs: expected `{}`, found `{}`\",\n-                    trait_store_to_string(cx, (*values).expected),\n-                    trait_store_to_string(cx, (*values).found))\n-        }\n         terr_sorts(values) => {\n             // A naive approach to making sure that we're not reporting silly errors such as:\n             // (expected closure, found closure).\n@@ -5089,25 +5045,6 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n }\n \n-#[derive(Copy, PartialEq, Eq)]\n-pub struct AssociatedTypeInfo {\n-    pub def_id: ast::DefId,\n-    pub index: uint,\n-    pub name: ast::Name,\n-}\n-\n-impl PartialOrd for AssociatedTypeInfo {\n-    fn partial_cmp(&self, other: &AssociatedTypeInfo) -> Option<Ordering> {\n-        Some(self.index.cmp(&other.index))\n-    }\n-}\n-\n-impl Ord for AssociatedTypeInfo {\n-    fn cmp(&self, other: &AssociatedTypeInfo) -> Ordering {\n-        self.index.cmp(&other.index)\n-    }\n-}\n-\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\",\n@@ -5369,15 +5306,13 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 discriminant = val as Disr\n                                             }\n                                             Ok(_) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n+                                                span_err!(cx.sess, e.span, E0304,\n                                                             \"expected signed integer constant\");\n                                             }\n                                             Err(ref err) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n-                                                            &format!(\"expected constant: {}\",\n-                                                                    *err)[]);\n+                                                span_err!(cx.sess, e.span, E0305,\n+                                                            \"expected constant: {}\",\n+                                                                    *err);\n                                             }\n                                         },\n                                     None => {}\n@@ -5851,9 +5786,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 const_eval::const_binary(_) =>\n                     \"binary array\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0306,\n                 \"expected positive integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5866,9 +5801,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 _ =>\n                     \"non-constant expression\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0307,\n                 \"expected constant integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n     }\n     0\n@@ -7338,11 +7273,8 @@ impl ReferencesError for Region\n \n impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureTy({},{},{:?},{},{},{})\",\n+        format!(\"ClosureTy({},{},{})\",\n                 self.unsafety,\n-                self.onceness,\n-                self.store,\n-                self.bounds.repr(tcx),\n                 self.sig.repr(tcx),\n                 self.abi)\n     }\n@@ -7373,5 +7305,5 @@ impl<'a, 'tcx> Repr<'tcx> for ParameterEnvironment<'a, 'tcx> {\n             self.free_substs.repr(tcx),\n             self.implicit_region_bound.repr(tcx),\n             self.caller_bounds.repr(tcx))\n-        }\n     }\n+}"}, {"sha": "b4e6cff954bcc745b94aa07ce6b94f1055539b8f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -124,10 +124,6 @@ pub trait TypeFolder<'tcx> : Sized {\n         r\n     }\n \n-    fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n-        super_fold_trait_store(self, s)\n-    }\n-\n     fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n                                -> ty::ExistentialBounds<'tcx> {\n         super_fold_existential_bounds(self, s)\n@@ -225,12 +221,6 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitStore {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n-        folder.fold_trait_store(*self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n         folder.fold_ty(*self)\n@@ -699,11 +689,8 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                         -> ty::ClosureTy<'tcx>\n {\n     ty::ClosureTy {\n-        store: fty.store.fold_with(this),\n         sig: fty.sig.fold_with(this),\n         unsafety: fty.unsafety,\n-        onceness: fty.onceness,\n-        bounds: fty.bounds.fold_with(this),\n         abi: fty.abi,\n     }\n }\n@@ -726,17 +713,6 @@ pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                         trait_store: ty::TraitStore)\n-                                                         -> ty::TraitStore {\n-    match trait_store {\n-        ty::UniqTraitStore => ty::UniqTraitStore,\n-        ty::RegionTraitStore(r, m) => {\n-            ty::RegionTraitStore(r.fold_with(this), m)\n-        }\n-    }\n-}\n-\n pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n     this: &mut T,\n     bounds: &ty::ExistentialBounds<'tcx>)"}, {"sha": "25cca98c5fb4788af7f1fce215b2444bb43f8579", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -99,9 +99,9 @@ impl<'a> Context<'a> {\n                 self.items.missing.push(lang_items::$item);\n             }\n         } else)* {\n-            self.sess.span_err(span,\n-                               format!(\"unknown external lang item: `{}`\",\n-                                       name).as_slice());\n+            span_err!(self.sess, span, E0264,\n+                               \"unknown external lang item: `{}`\",\n+                                       name);\n         }\n     }\n }"}, {"sha": "c420d1f15b43b1213691b3c7735ddb1635ef80b8", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -73,8 +73,10 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n-    for vi in krate.module.view_items.iter() {\n-        loader.span_whitelist.insert(vi.span);\n+    for item in krate.module.items.iter() {\n+        if let ast::ItemExternCrate(_) = item.node {\n+            loader.span_whitelist.insert(item.span);\n+        }\n     }\n \n     visit::walk_crate(&mut loader, krate);\n@@ -91,18 +93,21 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n \n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // We're only interested in `extern crate`.\n-        match vi.node {\n-            ast::ViewItemExternCrate(..) => (),\n-            _ => return,\n+        match item.node {\n+            ast::ItemExternCrate(_) => {}\n+            _ => {\n+                visit::walk_item(self, item);\n+                return;\n+            }\n         }\n \n         // Parse the attributes relating to macro / plugin loading.\n         let mut plugin_attr = None;\n         let mut macro_selection = Some(HashSet::new());  // None => load all\n         let mut reexport = HashSet::new();\n-        for attr in vi.attrs.iter() {\n+        for attr in item.attrs.iter() {\n             let mut used = true;\n             match attr.name().get() {\n                 \"phase\" => {\n@@ -155,7 +160,10 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n             }\n         }\n \n-        self.load_plugin(CrateOrString::Krate(vi), plugin_attr, macro_selection, Some(reexport))\n+        self.load_plugin(CrateOrString::Krate(item),\n+                         plugin_attr,\n+                         macro_selection,\n+                         Some(reexport))\n     }\n \n     fn visit_mac(&mut self, _: &ast::Mac) {"}, {"sha": "a2bba313cca87331810027506a364395f18998ba", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 98, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -249,7 +249,7 @@ pub enum EntryFnType {\n     EntryNone,\n }\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Show)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,\n@@ -786,30 +786,14 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi(\"\", \"extern\", \"Specify where an external rust library is \\\n                                 located\",\n                  \"NAME=PATH\"),\n-        opt::opt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n         opt::opt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n         opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n         opt::opt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n \n-        // DEPRECATED\n-        opt::flag(\"\", \"print-crate-name\", \"Output the crate name and exit\"),\n-        opt::flag(\"\", \"print-file-name\", \"Output the file(s) that would be \\\n-                                        written if compilation \\\n-                                        continued and exit\"),\n-        opt::opt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n-             0 = no debug info,\n-             1 = line-tables only (for stacktraces and breakpoints),\n-             2 = full debug info with variable and type information \\\n-                    (same as -g)\", \"LEVEL\"),\n-        opt::flag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n-        opt::flag(\"\", \"no-analysis\", \"Parse and expand the source, but run no \\\n-                                    analysis and produce no output\"),\n-        opt::flag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, \\\n-                                   or link\"),\n-        opt::flagopt(\"\", \"pretty\",\n+        opt::flagopt_u(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n                    `expanded` (crates expanded),\n@@ -823,9 +807,6 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                       `everybody_loops` (all function bodies replaced with `loop {}`).\",\n                      \"TYPE\"),\n         opt::opt_u(\"\", \"show-span\", \"Show spans for compiler debugging\", \"expr|pat|ty\"),\n-        opt::flagopt(\"\", \"dep-info\",\n-                 \"Output dependency info to <filename> after compiling, \\\n-                  in a format suitable for use by Makefiles\", \"FILENAME\"),\n     ]);\n     opts\n }\n@@ -861,27 +842,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let debugging_opts = build_debugging_options(matches);\n \n-    let parse_only = if matches.opt_present(\"parse-only\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--parse-only is deprecated in favor of -Z parse-only\");\n-        true\n-    } else {\n-        debugging_opts.parse_only\n-    };\n-    let no_trans = if matches.opt_present(\"no-trans\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--no-trans is deprecated in favor of -Z no-trans\");\n-        true\n-    } else {\n-        debugging_opts.no_trans\n-    };\n-    let no_analysis = if matches.opt_present(\"no-analysis\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--no-analysis is deprecated in favor of -Z no-analysis\");\n-        true\n-    } else {\n-        debugging_opts.no_analysis\n-    };\n+    let parse_only = debugging_opts.parse_only;\n+    let no_trans = debugging_opts.no_trans;\n+    let no_analysis = debugging_opts.no_analysis;\n \n     if debugging_opts.debug_llvm {\n         unsafe { llvm::LLVMSetDebug(1); }\n@@ -921,28 +884,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         host_triple().to_string());\n     let opt_level = {\n         if matches.opt_present(\"O\") {\n-            if matches.opt_present(\"opt-level\") {\n-                early_error(\"-O and --opt-level both provided\");\n-            }\n             if cg.opt_level.is_some() {\n                 early_error(\"-O and -C opt-level both provided\");\n             }\n             Default\n-        } else if matches.opt_present(\"opt-level\") {\n-            // FIXME(acrichto) remove this eventually\n-            early_warn(\"--opt-level=N is deprecated in favor of -C opt-level=N\");\n-            match matches.opt_str(\"opt-level\").as_ref().map(|s| s.as_slice()) {\n-                None      |\n-                Some(\"0\") => No,\n-                Some(\"1\") => Less,\n-                Some(\"2\") => Default,\n-                Some(\"3\") => Aggressive,\n-                Some(arg) => {\n-                    early_error(&format!(\"optimization level needs to be \\\n-                                         between 0-3 (instead was `{}`)\",\n-                                        arg)[]);\n-                }\n-            }\n         } else {\n             match cg.opt_level {\n                 None => No,\n@@ -960,27 +905,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n     let gc = debugging_opts.gc;\n     let debuginfo = if matches.opt_present(\"g\") {\n-        if matches.opt_present(\"debuginfo\") {\n-            early_error(\"-g and --debuginfo both provided\");\n-        }\n         if cg.debuginfo.is_some() {\n             early_error(\"-g and -C debuginfo both provided\");\n         }\n         FullDebugInfo\n-    } else if matches.opt_present(\"debuginfo\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--debuginfo=N is deprecated in favor of -C debuginfo=N\");\n-        match matches.opt_str(\"debuginfo\").as_ref().map(|s| s.as_slice()) {\n-            Some(\"0\") => NoDebugInfo,\n-            Some(\"1\") => LimitedDebugInfo,\n-            None      |\n-            Some(\"2\") => FullDebugInfo,\n-            Some(arg) => {\n-                early_error(&format!(\"debug info level needs to be between \\\n-                                     0-2 (instead was `{}`)\",\n-                                    arg)[]);\n-            }\n-        }\n     } else {\n         match cg.debuginfo {\n             None | Some(0) => NoDebugInfo,\n@@ -1036,15 +964,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let test = matches.opt_present(\"test\");\n-    let write_dependency_info = if matches.opt_present(\"dep-info\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--dep-info has been deprecated in favor of --emit\");\n-        (true, matches.opt_str(\"dep-info\").map(|p| Path::new(p)))\n-    } else {\n-        (output_types.contains(&OutputTypeDepInfo), None)\n-    };\n+    let write_dependency_info = (output_types.contains(&OutputTypeDepInfo), None);\n \n-    let mut prints = matches.opt_strs(\"print\").into_iter().map(|s| {\n+    let prints = matches.opt_strs(\"print\").into_iter().map(|s| {\n         match s.as_slice() {\n             \"crate-name\" => PrintRequest::CrateName,\n             \"file-names\" => PrintRequest::FileNames,\n@@ -1054,18 +976,6 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n     }).collect::<Vec<_>>();\n-    if matches.opt_present(\"print-crate-name\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--print-crate-name has been deprecated in favor of \\\n-                    --print crate-name\");\n-        prints.push(PrintRequest::CrateName);\n-    }\n-    if matches.opt_present(\"print-file-name\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--print-file-name has been deprecated in favor of \\\n-                    --print file-names\");\n-        prints.push(PrintRequest::FileNames);\n-    }\n \n     if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n         early_warn(\"-C remark will not show source locations without \\\n@@ -1159,7 +1069,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n     return Ok(crate_types);\n }\n \n-impl fmt::Show for CrateType {\n+impl fmt::Display for CrateType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             CrateTypeExecutable => \"bin\".fmt(f),"}, {"sha": "f90a60c9754a06e8b9d276274293cb883550f06c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 70, "deletions": 54, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -15,8 +15,6 @@ use metadata::filesearch;\n use session::search_paths::PathKind;\n use util::nodemap::NodeMap;\n \n-use regex::Regex;\n-\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax::diagnostic::{self, Emitter};\n@@ -69,65 +67,23 @@ impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+        self.diagnostic().span_fatal_with_code(sp, msg, code)\n+    }\n     pub fn fatal(&self, msg: &str) -> ! {\n         self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        // Conditions for enabling multi-line errors:\n-        if !msg.contains(\"mismatched types\") &&\n-           !msg.contains(\"type mismatch resolving\") &&\n-           !msg.contains(\"if and else have incompatible types\") &&\n-           !msg.contains(\"if may be missing an else clause\") &&\n-           !msg.contains(\"match arms have incompatible types\") &&\n-           !msg.contains(\"structure constructor specifies a structure of type\") {\n-            return self.diagnostic().span_err(sp, msg);\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err(sp, &msg[]),\n+            None => self.diagnostic().span_err(sp, msg)\n         }\n-\n-        let first  = Regex::new(r\"[( ]expected\").unwrap();\n-        let second = Regex::new(r\" found\").unwrap();\n-        let third  = Regex::new(\n-                     r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n-\n-        let mut new_msg = String::new();\n-        let mut head = 0u;\n-\n-        // Insert `\\n` before expected and found.\n-        for (pos1, pos2) in first.find_iter(msg).zip(\n-                            second.find_iter(msg)) {\n-            new_msg = new_msg +\n-            // A `(` may be preceded by a space and it should be trimmed\n-                      msg[head..pos1.0].trim_right() + // prefix\n-                      \"\\n\" +                           // insert before first\n-                      &msg[pos1.0..pos1.1] +           // insert what first matched\n-                      &msg[pos1.1..pos2.0] +           // between matches\n-                      \"\\n   \" +                        // insert before second\n-            //           123\n-            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n-            // 3 spaces prepended.\n-                      &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-            head = pos2.1;\n-        }\n-\n-        let mut tail = &msg[head..];\n-        // Insert `\\n` before any remaining messages which match.\n-        for pos in third.find_iter(tail).take(1) {\n-            // The end of the message may just be wrapped in `()` without `expected`/`found`.\n-            // Push this also to a new line and add the final tail after.\n-            new_msg = new_msg +\n-            // `(` is usually preceded by a space and should be trimmed.\n-                      tail[..pos.0].trim_right() + // prefix\n-                      \"\\n\" +                       // insert before paren\n-                      &tail[pos.0..];              // append the tail\n-\n-            tail = \"\";\n-        }\n-\n-        new_msg.push_str(tail);\n-        self.diagnostic().span_err(sp, &new_msg[])\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.diagnostic().span_err_with_code(sp, msg, code)\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[], code),\n+            None => self.diagnostic().span_err_with_code(sp, msg, code)\n+        }\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().handler().err(msg)\n@@ -285,6 +241,66 @@ impl Session {\n     }\n }\n \n+fn split_msg_into_multilines(msg: &str) -> Option<String> {\n+    // Conditions for enabling multi-line errors:\n+    if !msg.contains(\"mismatched types\") &&\n+        !msg.contains(\"type mismatch resolving\") &&\n+        !msg.contains(\"if and else have incompatible types\") &&\n+        !msg.contains(\"if may be missing an else clause\") &&\n+        !msg.contains(\"match arms have incompatible types\") &&\n+        !msg.contains(\"structure constructor specifies a structure of type\") {\n+            return None\n+    }\n+    let first = msg.match_indices(\"expected\").filter(|s| {\n+        s.0 > 0 && (msg.char_at_reverse(s.0) == ' ' ||\n+                    msg.char_at_reverse(s.0) == '(')\n+    }).map(|(a, b)| (a - 1, b));\n+    let second = msg.match_indices(\"found\").filter(|s| {\n+        msg.char_at_reverse(s.0) == ' '\n+    }).map(|(a, b)| (a - 1, b));\n+\n+    let mut new_msg = String::new();\n+    let mut head = 0u;\n+\n+    // Insert `\\n` before expected and found.\n+    for (pos1, pos2) in first.zip(second) {\n+        new_msg = new_msg +\n+        // A `(` may be preceded by a space and it should be trimmed\n+                  msg[head..pos1.0].trim_right() + // prefix\n+                  \"\\n\" +                           // insert before first\n+                  &msg[pos1.0..pos1.1] +           // insert what first matched\n+                  &msg[pos1.1..pos2.0] +           // between matches\n+                  \"\\n   \" +                        // insert before second\n+        //           123\n+        // `expected` is 3 char longer than `found`. To align the types,\n+        // `found` gets 3 spaces prepended.\n+                  &msg[pos2.0..pos2.1];            // insert what second matched\n+\n+        head = pos2.1;\n+    }\n+\n+    let mut tail = &msg[head..];\n+    let third = tail.find_str(\"(values differ\")\n+                   .or(tail.find_str(\"(lifetime\"))\n+                   .or(tail.find_str(\"(cyclic type of infinite size\"));\n+    // Insert `\\n` before any remaining messages which match.\n+    if let Some(pos) = third {\n+        // The end of the message may just be wrapped in `()` without\n+        // `expected`/`found`.  Push this also to a new line and add the\n+        // final tail after.\n+        new_msg = new_msg +\n+        // `(` is usually preceded by a space and should be trimmed.\n+                  tail[..pos].trim_right() + // prefix\n+                  \"\\n\" +                     // insert before paren\n+                  &tail[pos..];              // append the tail\n+\n+        tail = \"\";\n+    }\n+\n+    new_msg.push_str(tail);\n+    return Some(new_msg);\n+}\n+\n pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<Path>,\n                      registry: diagnostics::registry::Registry)"}, {"sha": "dfc27d3ae684d1370611c95d43d75de579724619", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -36,13 +36,13 @@ impl SearchPaths {\n \n     pub fn add_path(&mut self, path: &str) {\n         let (kind, path) = if path.starts_with(\"native=\") {\n-            (PathKind::Native, path.slice_from(\"native=\".len()))\n+            (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {\n-            (PathKind::Crate, path.slice_from(\"crate=\".len()))\n+            (PathKind::Crate, &path[\"crate=\".len()..])\n         } else if path.starts_with(\"dependency=\") {\n-            (PathKind::Dependency, path.slice_from(\"dependency=\".len()))\n+            (PathKind::Dependency, &path[\"dependency=\".len()..])\n         } else if path.starts_with(\"all=\") {\n-            (PathKind::All, path.slice_from(\"all=\".len()))\n+            (PathKind::All, &path[\"all=\".len()..])\n         } else {\n             (PathKind::All, path)\n         };"}, {"sha": "8915d55e2063e7b5fa7ce1c4ffee26bfaedbff3e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -12,7 +12,7 @@\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::iter::repeat;\n use std::time::Duration;\n@@ -58,7 +58,7 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n }\n \n pub fn indent<R, F>(op: F) -> R where\n-    R: Show,\n+    R: Debug,\n     F: FnOnce() -> R,\n {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`"}, {"sha": "c5aced4eb86f5902a9db6a5d974874705a5b47e1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -164,7 +164,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     fn explain_span(cx: &ctxt, heading: &str, span: Span)\n                     -> (String, Option<Span>) {\n         let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_uint()),\n+        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n          Some(span))\n     }\n }\n@@ -237,15 +237,6 @@ pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n         ty_to_string(cx, m.ty))\n }\n \n-pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n-    match s {\n-        ty::UniqTraitStore => \"Box \".to_string(),\n-        ty::RegionTraitStore(r, m) => {\n-            format!(\"{}{}\", region_ptr_to_string(cx, r), mutability_to_string(m))\n-        }\n-    }\n-}\n-\n pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n     F: FnMut(&T) -> String,\n {\n@@ -285,7 +276,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             _ => { }\n         }\n \n-        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n+        push_sig_to_string(cx, &mut s, '(', ')', sig);\n \n         match opt_def_id {\n             Some(def_id) => {\n@@ -303,13 +294,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n \n-        match cty.store {\n-            ty::UniqTraitStore => {}\n-            ty::RegionTraitStore(region, _) => {\n-                s.push_str(&region_to_string(cx, \"\", true, region)[]);\n-            }\n-        }\n-\n         match cty.unsafety {\n             ast::Unsafety::Normal => {}\n             ast::Unsafety::Unsafe => {\n@@ -318,24 +302,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             }\n         };\n \n-        let bounds_str = cty.bounds.user_string(cx);\n-\n-        match cty.store {\n-            ty::UniqTraitStore => {\n-                assert_eq!(cty.onceness, ast::Once);\n-                s.push_str(\"proc\");\n-                push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   &bounds_str[]);\n-            }\n-            ty::RegionTraitStore(..) => {\n-                match cty.onceness {\n-                    ast::Many => {}\n-                    ast::Once => s.push_str(\"once \")\n-                }\n-                push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   &bounds_str[]);\n-            }\n-        }\n+        push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n \n         s\n     }\n@@ -344,8 +311,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                                 s: &mut String,\n                                 bra: char,\n                                 ket: char,\n-                                sig: &ty::PolyFnSig<'tcx>,\n-                                bounds: &str) {\n+                                sig: &ty::PolyFnSig<'tcx>) {\n         s.push(bra);\n         let strs = sig.0.inputs\n             .iter()\n@@ -357,11 +323,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         s.push(ket);\n \n-        if !bounds.is_empty() {\n-            s.push_str(\":\");\n-            s.push_str(bounds);\n-        }\n-\n         match sig.0.output {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n@@ -542,17 +503,17 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[..(tps.len() - num_defaults)].iter() {\n+    for t in tps[..tps.len() - num_defaults].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    &strs[0][1 .. (strs[0].len() - 2)] // Remove '(' and ',)'\n+                    &strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    &strs[0][1 .. (strs[0].len() - 1)] // Remove '(' and ')'\n+                    &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n                 } else {\n                     &strs[0][]\n                 },\n@@ -1090,12 +1051,6 @@ impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitStore {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        trait_store_to_string(tcx, *self)\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{:?}\", *self)"}, {"sha": "fa754b4a3018cda0fb8fa671529365c1c8ebdd57", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -59,7 +59,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n     let mut cmd = Command::new(ar);\n \n     cmd.arg(args).args(paths);\n-    debug!(\"{}\", cmd);\n+    debug!(\"{:?}\", cmd);\n \n     match cwd {\n         Some(p) => {\n@@ -73,9 +73,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                handler.err(&format!(\"{} failed with: {}\",\n-                                 cmd,\n-                                 o.status)[]);\n+                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status)[]);\n                 handler.note(&format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(&o.output[]).unwrap())[]);\n                 handler.note(&format!(\"stderr ---\\n{}\","}, {"sha": "0228098b8f8384c4aad7eb4068b401504d372381", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -156,7 +156,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(&input[i..(i + size)]);\n+            func(&input[i..i + size]);\n             i += size;\n         }\n "}, {"sha": "ebeaf3e6e22d7e6a02d078fb09aa0734664399f4", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -52,7 +52,7 @@ use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Show)]\n pub struct Svh {\n     hash: String,\n }\n@@ -117,13 +117,7 @@ impl Svh {\n     }\n }\n \n-impl fmt::Show for Svh {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Svh {{ {} }}\", self.as_str())\n-    }\n-}\n-\n-impl fmt::String for Svh {\n+impl fmt::Display for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(self.as_str())\n     }\n@@ -188,7 +182,6 @@ mod svh_visitor {\n         SawLifetimeDef(token::InternedString),\n \n         SawMod,\n-        SawViewItem,\n         SawForeignItem,\n         SawItem,\n         SawDecl,\n@@ -436,19 +429,6 @@ mod svh_visitor {\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n-        fn visit_view_item(&mut self, i: &ViewItem) {\n-            // Two kinds of view items can affect the ABI for a crate:\n-            // exported `pub use` view items (since that may expose\n-            // items that downstream crates can call), and `use\n-            // foo::Trait`, since changing that may affect method\n-            // resolution.\n-            //\n-            // The simplest approach to handling both of the above is\n-            // just to adopt the same simple-minded (fine-grained)\n-            // hash that I am deploying elsewhere here.\n-            SawViewItem.hash(self.st); visit::walk_view_item(self, i)\n-        }\n-\n         fn visit_foreign_item(&mut self, i: &ForeignItem) {\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items"}, {"sha": "313c0dc2a6ea74c1ee10d8ce3109379165a90ecd", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::linux_base::opts();\n+    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n+    base.position_independent_executables = true;\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                      n32:64-S128\".to_string(),\n+        llvm_target: \"aarch64-linux-android\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"android\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "4626f2dc483394863517558e38ef23a7988aca87", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -65,6 +65,7 @@ mod arm_linux_androideabi;\n mod arm_unknown_linux_gnueabi;\n mod arm_unknown_linux_gnueabihf;\n mod aarch64_apple_ios;\n+mod aarch64_linux_android;\n mod aarch64_unknown_linux_gnu;\n mod i686_apple_darwin;\n mod i686_pc_windows_gnu;\n@@ -357,6 +358,7 @@ impl Target {\n             i386_apple_ios,\n             x86_64_apple_ios,\n             aarch64_apple_ios,\n+            aarch64_linux_android,\n             armv7_apple_ios,\n             armv7s_apple_ios,\n "}, {"sha": "0ade916f6390a34c0b6350e850ab9372a4eeafa7", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -370,7 +370,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n-            for &y in new_loan_indices.slice_from(i+1).iter() {\n+            for &y in new_loan_indices[(i+1) ..].iter() {\n                 let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }"}, {"sha": "b1cc3a651200c427592334bd2fe3302ac000637d", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -491,7 +491,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n             let param_env = ty::empty_parameter_environment(self.bccx.tcx);\n             let mc = mc::MemCategorizationContext::new(&param_env);\n-            let base_cmt = mc.cat_expr(&**base).unwrap();\n+            let base_cmt = mc.cat_expr(&**base).ok().unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n             if check_aliasability(self.bccx, ex.span, euv::AddrOf,"}, {"sha": "d525c22f0ab6f22de8bfc8603bc87c3493fb4bd3", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -27,6 +27,7 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(rustc_private)]\n+#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "ffce577899bf977af00975b0e88fd9ab2ede1e70", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -70,7 +70,6 @@ use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n use rustc::metadata::creader::CrateOrString::Str;\n-use rustc::DIAGNOSTICS;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n@@ -107,7 +106,7 @@ fn run_compiler(args: &[String]) {\n         None => return\n     };\n \n-    let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n+    let descriptions = diagnostics_registry();\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n             match descriptions.find_description(&code[]) {\n@@ -163,10 +162,14 @@ fn run_compiler(args: &[String]) {\n         return\n     }\n \n-    let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        // stable pretty-print variants only\n-        pretty::parse_pretty(&sess, a.as_slice(), false)\n-    });\n+    let pretty = if sess.opts.debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            pretty::parse_pretty(&sess, a.as_slice(), false)\n+        })\n+    } else {\n+        None\n+    };\n     let pretty = if pretty.is_none() &&\n         sess.unstable_options() {\n             matches.opt_str(\"xpretty\").map(|a| {\n@@ -668,8 +671,20 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     }\n }\n \n+pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n+    use syntax::diagnostics::registry::Registry;\n+\n+    let all_errors = Vec::new() +\n+        rustc::diagnostics::DIAGNOSTICS.as_slice() +\n+        rustc_typeck::diagnostics::DIAGNOSTICS.as_slice() +\n+        rustc_resolve::diagnostics::DIAGNOSTICS.as_slice();\n+\n+    Registry::new(&*all_errors)\n+}\n+\n pub fn main() {\n     let args = std::os::args();\n     let result = run(args);\n     std::os::set_exit_status(result);\n }\n+"}, {"sha": "582e10323248cfb80ea95f35bb78b75f052eeb83", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -477,7 +477,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                          e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                 expr: e,\n-                view_items: vec![], stmts: vec![], rules: rules,\n+                stmts: vec![], rules: rules,\n                 id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP,\n             })\n         }"}, {"sha": "3543fe072690e15e32ec2e813cb59410a6dc6d79", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -200,6 +200,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n \n             return match it.node {\n+                ast::ItemUse(..) | ast::ItemExternCrate(..) |\n                 ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemFn(..) |\n                 ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None"}, {"sha": "db2a569cdeffa0edbae0f09bf8914215c00fa1a3", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -14,6 +14,7 @@ pub use self::OptimizationDiagnosticKind::*;\n pub use self::Diagnostic::*;\n \n use libc::c_char;\n+use std::ptr;\n \n use {ValueRef, TwineRef, DebugLocRef, DiagnosticInfoRef};\n \n@@ -52,10 +53,10 @@ impl OptimizationDiagnostic {\n \n         let mut opt = OptimizationDiagnostic {\n             kind: kind,\n-            pass_name: 0 as *const c_char,\n-            function: 0 as ValueRef,\n-            debug_loc: 0 as DebugLocRef,\n-            message: 0 as TwineRef,\n+            pass_name: ptr::null(),\n+            function: ptr::null_mut(),\n+            debug_loc: ptr::null_mut(),\n+            message: ptr::null_mut(),\n         };\n \n         super::LLVMUnpackOptimizationDiagnostic(di,"}, {"sha": "101a0957290e5aca2c881d6d969aaf473e7fbab3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -32,6 +32,7 @@\n #![feature(libc)]\n #![feature(path)]\n #![feature(std_misc)]\n+#![feature(hash)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -58,7 +59,7 @@ pub use self::Linkage::*;\n \n use std::ffi::CString;\n use std::cell::RefCell;\n-use std::{raw, mem};\n+use std::{raw, mem, ptr};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n use libc::{c_longlong, c_ulonglong, c_void};\n use debuginfo::{DIBuilderRef, DIDescriptor,\n@@ -2267,19 +2268,18 @@ pub unsafe fn static_link_hack_this_sucks() {\n     LLVMInitializePowerPCAsmPrinter();\n     LLVMInitializePowerPCAsmParser();\n \n-    LLVMRustSetLLVMOptions(0 as c_int,\n-                                       0 as *const _);\n+    LLVMRustSetLLVMOptions(0 as c_int, ptr::null());\n \n-    LLVMPassManagerBuilderPopulateModulePassManager(0 as *mut _, 0 as *mut _);\n-    LLVMPassManagerBuilderPopulateLTOPassManager(0 as *mut _, 0 as *mut _, False, False);\n-    LLVMPassManagerBuilderPopulateFunctionPassManager(0 as *mut _, 0 as *mut _);\n-    LLVMPassManagerBuilderSetOptLevel(0 as *mut _, 0 as c_uint);\n-    LLVMPassManagerBuilderUseInlinerWithThreshold(0 as *mut _, 0 as c_uint);\n-    LLVMWriteBitcodeToFile(0 as *mut _, 0 as *const _);\n+    LLVMPassManagerBuilderPopulateModulePassManager(ptr::null_mut(), ptr::null_mut());\n+    LLVMPassManagerBuilderPopulateLTOPassManager(ptr::null_mut(), ptr::null_mut(), False, False);\n+    LLVMPassManagerBuilderPopulateFunctionPassManager(ptr::null_mut(), ptr::null_mut());\n+    LLVMPassManagerBuilderSetOptLevel(ptr::null_mut(), 0 as c_uint);\n+    LLVMPassManagerBuilderUseInlinerWithThreshold(ptr::null_mut(), 0 as c_uint);\n+    LLVMWriteBitcodeToFile(ptr::null_mut(), ptr::null());\n     LLVMPassManagerBuilderCreate();\n-    LLVMPassManagerBuilderDispose(0 as *mut _);\n+    LLVMPassManagerBuilderDispose(ptr::null_mut());\n \n-    LLVMRustLinkInExternalBitcode(0 as *mut _, 0 as *const _, 0 as size_t);\n+    LLVMRustLinkInExternalBitcode(ptr::null_mut(), ptr::null(), 0 as size_t);\n \n     LLVMLinkInMCJIT();\n     LLVMLinkInInterpreter();"}, {"sha": "b6bc484bc108ffd21a43eac305ac3bbc2cf36cce", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -833,6 +833,38 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref vpath) => {\n+                match vpath.node {\n+                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n+                    ast::ViewPathList(ref prefix, ref list) => {\n+                        for pid in list.iter() {\n+                            match pid.node {\n+                                ast::PathListIdent { id, name } => {\n+                                    debug!(\"privacy - ident item {}\", id);\n+                                    let seg = ast::PathSegment {\n+                                        identifier: name,\n+                                        parameters: ast::PathParameters::none(),\n+                                    };\n+                                    let segs = vec![seg];\n+                                    let path = ast::Path {\n+                                        global: false,\n+                                        span: pid.span,\n+                                        segments: segs,\n+                                    };\n+                                    self.check_path(pid.span, id, &path);\n+                                }\n+                                ast::PathListMod { id } => {\n+                                    debug!(\"privacy - mod item {}\", id);\n+                                    self.check_path(pid.span, id, prefix);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item);\n         self.curitem = orig_curitem;\n@@ -929,42 +961,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         visit::walk_expr(self, expr);\n     }\n \n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        match a.node {\n-            ast::ViewItemExternCrate(..) => {}\n-            ast::ViewItemUse(ref vpath) => {\n-                match vpath.node {\n-                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n-                    ast::ViewPathList(ref prefix, ref list, _) => {\n-                        for pid in list.iter() {\n-                            match pid.node {\n-                                ast::PathListIdent { id, name } => {\n-                                    debug!(\"privacy - ident item {}\", id);\n-                                    let seg = ast::PathSegment {\n-                                        identifier: name,\n-                                        parameters: ast::PathParameters::none(),\n-                                    };\n-                                    let segs = vec![seg];\n-                                    let path = ast::Path {\n-                                        global: false,\n-                                        span: pid.span,\n-                                        segments: segs,\n-                                    };\n-                                    self.check_path(pid.span, id, &path);\n-                                }\n-                                ast::PathListMod { id } => {\n-                                    debug!(\"privacy - mod item {}\", id);\n-                                    self.check_path(pid.span, id, prefix);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, a);\n-    }\n-\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n@@ -1072,23 +1068,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n         visit::walk_fn(self, fk, fd, b, s);\n         self.in_fn = orig_in_fn;\n     }\n-\n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.vis {\n-            ast::Inherited => {}\n-            ast::Public => {\n-                if self.in_fn {\n-                    self.tcx.sess.span_err(i.span, \"unnecessary `pub`, imports \\\n-                                                    in functions are never \\\n-                                                    reachable\");\n-                } else if let ast::ViewItemExternCrate(..) = i.node {\n-                    self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n-                                                    is not allowed\");\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i);\n-    }\n }\n \n impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n@@ -1165,7 +1144,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemMac(..) => {}\n+            ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n         }\n     }\n \n@@ -1222,6 +1201,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n             ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n@@ -1524,11 +1504,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n \n     // we don't need to introspect into these at all: an\n-    // expression/block context can't possibly contain exported\n-    // things, and neither do view_items. (Making them no-ops stops us\n-    // from traversing the whole AST without having to be super\n-    // careful about our `walk_...` calls above.)\n-    fn visit_view_item(&mut self, _: &ast::ViewItem) {}\n+    // expression/block context can't possibly contain exported things.\n+    // (Making them no-ops stops us from traversing the whole AST without\n+    // having to be super careful about our `walk_...` calls above.)\n     fn visit_block(&mut self, _: &ast::Block) {}\n     fn visit_expr(&mut self, _: &ast::Expr) {}\n }"}, {"sha": "65bd83d7937fb5bc43c08c78f855562b7979653a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 131, "deletions": 153, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -39,9 +39,9 @@ use rustc::middle::subst::FnSpace;\n use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use syntax::ast::{Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n use syntax::ast::{PathListIdent, PathListMod};\n use syntax::ast::{Public, SelfStatic};\n@@ -50,8 +50,7 @@ use syntax::ast::StructVariantKind;\n use syntax::ast::TupleVariantKind;\n use syntax::ast::TyObjectSum;\n use syntax::ast::{TypeImplItem, UnnamedField};\n-use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n-use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast::TyPath;\n use syntax::ast;\n@@ -238,11 +237,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // If the block has view items, we need an anonymous module.\n-        if block.view_items.len() > 0 {\n-            return true;\n-        }\n-\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n@@ -262,7 +256,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n         }\n \n-        // If we found neither view items nor items, we don't need to create\n+        // If we found no items, we don't need to create\n         // an anonymous module.\n \n         return false;\n@@ -280,6 +274,133 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n \n         match item.node {\n+            ItemUse(ref view_path) => {\n+                // Extract and intern the module part of the path. For\n+                // globs and lists, the path is found directly in the AST;\n+                // for simple paths we have to munge the path a little.\n+                let module_path = match view_path.node {\n+                    ViewPathSimple(_, ref full_path) => {\n+                        full_path.segments\n+                            .init()\n+                            .iter().map(|ident| ident.identifier.name)\n+                            .collect()\n+                    }\n+\n+                    ViewPathGlob(ref module_ident_path) |\n+                    ViewPathList(ref module_ident_path, _) => {\n+                        module_ident_path.segments\n+                            .iter().map(|ident| ident.identifier.name).collect()\n+                    }\n+                };\n+\n+                // Build up the import directives.\n+                let shadowable = item.attrs.iter().any(|attr| {\n+                    attr.name() == token::get_name(special_idents::prelude_import.name)\n+                });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n+\n+                match view_path.node {\n+                    ViewPathSimple(binding, ref full_path) => {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" ||\n+                           token::get_name(source_name).get() == \"self\" {\n+                            self.resolve_error(view_path.span,\n+                                \"`self` imports are only allowed within a { } list\");\n+                        }\n+\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    subclass,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                    ViewPathList(_, ref source_items) => {\n+                        // Make sure there's at most one `mod` import in the list.\n+                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n+                            PathListMod { .. } => Some(item.span),\n+                            _ => None\n+                        }).collect::<Vec<Span>>();\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`self` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `self` import appears here\");\n+                            }\n+                        }\n+\n+                        for source_item in source_items.iter() {\n+                            let (module_path, name) = match source_item.node {\n+                                PathListIdent { name, .. } =>\n+                                    (module_path.clone(), name.name),\n+                                PathListMod { .. } => {\n+                                    let name = match module_path.last() {\n+                                        Some(name) => *name,\n+                                        None => {\n+                                            self.resolve_error(source_item.span,\n+                                                \"`self` import can only appear in an import list \\\n+                                                 with a non-empty prefix\");\n+                                            continue;\n+                                        }\n+                                    };\n+                                    let module_path = module_path.init();\n+                                    (module_path.to_vec(), name)\n+                                }\n+                            };\n+                            self.build_import_directive(\n+                                &**parent,\n+                                module_path,\n+                                SingleImport(name, name),\n+                                source_item.span,\n+                                source_item.node.id(),\n+                                is_public,\n+                                shadowable);\n+                        }\n+                    }\n+                    ViewPathGlob(_) => {\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    GlobImport,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                }\n+                parent.clone()\n+            }\n+\n+            ItemExternCrate(_) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link = ModuleParentLink(parent.downgrade(), name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_string(&*external_module));\n+                    self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n+                    parent.external_module_children.borrow_mut()\n+                          .insert(name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(&external_module);\n+                }\n+                parent.clone()\n+            }\n+\n             ItemMod(..) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n@@ -650,145 +771,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                           variant.span, PUBLIC | IMPORTABLE);\n     }\n \n-    /// Constructs the reduced graph for one 'view item'. View items consist\n-    /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem, parent: &Rc<Module>) {\n-        match view_item.node {\n-            ViewItemUse(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n-                    ViewPathSimple(_, ref full_path, _) => {\n-                        full_path.segments\n-                            .init()\n-                            .iter().map(|ident| ident.identifier.name)\n-                            .collect()\n-                    }\n-\n-                    ViewPathGlob(ref module_ident_path, _) |\n-                    ViewPathList(ref module_ident_path, _, _) => {\n-                        module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n-                    }\n-                };\n-\n-                // Build up the import directives.\n-                let is_public = view_item.vis == ast::Public;\n-                let shadowable =\n-                    view_item.attrs\n-                             .iter()\n-                             .any(|attr| {\n-                                 attr.name() == token::get_name(\n-                                    special_idents::prelude_import.name)\n-                             });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n-\n-                match view_path.node {\n-                    ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" ||\n-                           token::get_name(source_name).get() == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n-                        }\n-\n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                    ViewPathList(_, ref source_items, _) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n-                        if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `self` import appears here\");\n-                            }\n-                        }\n-\n-                        for source_item in source_items.iter() {\n-                            let (module_path, name) = match source_item.node {\n-                                PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name.name),\n-                                PathListMod { .. } => {\n-                                    let name = match module_path.last() {\n-                                        Some(name) => *name,\n-                                        None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n-                                            continue;\n-                                        }\n-                                    };\n-                                    let module_path = module_path.init();\n-                                    (module_path.to_vec(), name)\n-                                }\n-                            };\n-                            self.build_import_directive(\n-                                &**parent,\n-                                module_path,\n-                                SingleImport(name, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n-                        }\n-                    }\n-                    ViewPathGlob(_, id) => {\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                }\n-            }\n-\n-            ViewItemExternCrate(name, _, node_id) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n-                    self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(parent.downgrade(), name.name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n-                    self.check_for_conflicts_between_external_crates(\n-                        &**parent,\n-                        name.name,\n-                        view_item.span);\n-                    parent.external_module_children.borrow_mut()\n-                          .insert(name.name, external_module.clone());\n-                    self.build_reduced_graph_for_external_crate(&external_module);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item<F>(&mut self,\n                                                foreign_item: &ForeignItem,\n@@ -1270,10 +1252,6 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        self.builder.build_reduced_graph_for_view_item(view_item, &self.parent);\n-    }\n-\n     fn visit_block(&mut self, block: &Block) {\n         let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n         let old_parent = replace(&mut self.parent, np);"}, {"sha": "97370112ab40f422af7504dad50f23f71d84709a", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -25,7 +25,6 @@ use Namespace::{TypeNS, ValueNS};\n use rustc::lint;\n use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n-use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse};\n use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n@@ -109,53 +108,54 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_view_item(&mut self, vi: &ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if vi.vis == ast::Public || vi.span == DUMMY_SP {\n-            visit::walk_view_item(self, vi);\n+        if item.vis == ast::Public || item.span == DUMMY_SP {\n+            visit::walk_item(self, item);\n             return;\n         }\n \n-        match vi.node {\n-            ViewItemExternCrate(_, _, id) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+        match item.node {\n+            ast::ItemExternCrate(_) => {\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                              id,\n-                                              vi.span,\n+                                              item.id,\n+                                              item.span,\n                                               \"unused extern crate\".to_string());\n                     }\n                 }\n             },\n-            ViewItemUse(ref p) => {\n+            ast::ItemUse(ref p) => {\n                 match p.node {\n-                    ViewPathSimple(_, _, id) => {\n-                        self.finalize_import(id, p.span)\n+                    ViewPathSimple(_, _) => {\n+                        self.finalize_import(item.id, p.span)\n                     }\n \n-                    ViewPathList(_, ref list, _) => {\n+                    ViewPathList(_, ref list) => {\n                         for i in list.iter() {\n                             self.finalize_import(i.node.id(), i.span);\n                         }\n                     }\n-                    ViewPathGlob(_, id) => {\n-                        if !self.used_imports.contains(&(id, TypeNS)) &&\n-                           !self.used_imports.contains(&(id, ValueNS)) {\n+                    ViewPathGlob(_) => {\n+                        if !self.used_imports.contains(&(item.id, TypeNS)) &&\n+                           !self.used_imports.contains(&(item.id, ValueNS)) {\n                             self.session\n                                 .add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                          id,\n+                                          item.id,\n                                           p.span,\n                                           \"unused import\".to_string());\n                         }\n                     }\n                 }\n             }\n+            _ => {}\n         }\n \n-        visit::walk_view_item(self, vi);\n+        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "dd9ccfbda7ca6a438ee6f4f57edc9126dfbc42a6", "filename": "src/librustc_resolve/diagnostics.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_diagnostics! {\n+    E0154,\n+    E0157,\n+    E0153,\n+    E0251, // a named type or value has already been imported in this module\n+    E0252, // a named type or value has already been imported in this module\n+    E0253, // not directly importable\n+    E0254, // import conflicts with imported crate in this module\n+    E0255, // import conflicts with value in this module\n+    E0256, // import conflicts with type in this module\n+    E0257, // inherent implementations are only allowen on types defined in the current module\n+    E0258, // import conflicts with existing submodule\n+    E0259, // an extern crate has already been imported into this module\n+    E0260 // name conflicts with an external crate that has been imported into this module\n+}\n+\n+__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "affd2b541358635713f705d59c31946b3686022b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 51, "deletions": 44, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -26,6 +26,7 @@\n #![feature(core)]\n #![feature(rustc_private)]\n #![feature(std_misc)]\n+#![feature(hash)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -70,10 +71,10 @@ use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n-use syntax::ast::{MethodImplItem, Mod, Name, NodeId};\n+use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n+use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n+use syntax::ast::{Local, MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path};\n use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n@@ -102,6 +103,10 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod check_unused;\n mod record_exports;\n mod build_reduced_graph;\n@@ -541,7 +546,7 @@ impl Module {\n     }\n }\n \n-impl fmt::Show for Module {\n+impl fmt::Debug for Module {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}, kind: {:?}, {}\",\n                self.def_id,\n@@ -1144,7 +1149,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.krate == LOCAL_CRATE {\n+        if did.krate == ast::LOCAL_CRATE {\n             self.ast_map.expect_item(did.node).ident.name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n@@ -1723,7 +1728,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            in this module\",\n                                           namespace_name,\n                                           token::get_name(name).get());\n-                        self.session.span_err(import_directive.span, msg.as_slice());\n+                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg.as_slice());\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n                                                  name_bindings.clone(),\n@@ -1753,10 +1758,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                token::get_name(name).get(),\n                target.is_some());\n@@ -1770,7 +1771,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, &msg[]);\n+                span_err!(self.session, import_span, E0252, \"{}\", &msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1785,7 +1786,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, &msg[]);\n+            span_err!(self.session, import_span, E0253, \"{}\", &msg[]);\n         }\n     }\n \n@@ -1796,10 +1797,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                      &ImportResolution,\n                                                      import_span: Span,\n                                                      name: Name) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         // First, check for conflicts between imports and `extern crate`s.\n         if module.external_module_children\n                  .borrow()\n@@ -1810,7 +1807,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, &msg[]);\n+                    span_err!(self.session, import_span, E0254, \"{}\", &msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1832,7 +1829,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, &msg[]);\n+                    span_err!(self.session, import_span, E0255, \"{}\", &msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1850,7 +1847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, &msg[]);\n+                            span_err!(self.session, import_span, E0256, \"{}\", &msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1863,7 +1860,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, &msg[]);\n+                                        span_err!(self.session, span, E0257, \"{}\", &msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1872,7 +1869,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, &msg[]);\n+                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1893,16 +1890,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                    module: &Module,\n                                                    name: Name,\n                                                    span: Span) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         if module.external_module_children.borrow().contains_key(&name) {\n-            self.session\n-                .span_err(span,\n-                          &format!(\"an external crate named `{}` has already \\\n+                span_err!(self.session, span, E0259,\n+                          \"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get());\n         }\n     }\n \n@@ -1911,17 +1903,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                              module: &Module,\n                                                              name: Name,\n                                                              span: Span) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         if module.external_module_children.borrow().contains_key(&name) {\n-            self.session\n-                .span_err(span,\n-                          &format!(\"the name `{}` conflicts with an external \\\n+                span_err!(self.session, span, E0260,\n+                          \"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get());\n         }\n     }\n \n@@ -1970,7 +1957,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[] {\n-                        span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n+                        span.hi = span.lo + Pos::from_usize(segment_name.get().len());\n \n                         match search_parent_externals(name,\n                                                      &self.current_module) {\n@@ -2088,8 +2075,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            &mpath[(idx + 1)..],\n-                                            &mpath[..(idx - 1)]);\n+                                            &mpath[idx + 1..],\n+                                            &mpath[..idx - 1]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -2765,7 +2752,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n-                    return self.upvarify(&ribs[(i + 1)..], def_like, span);\n+                    return self.upvarify(&ribs[i + 1..], def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -2987,9 +2974,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n-           ItemMac(..) => {\n+            ItemExternCrate(_) | ItemUse(_) | ItemMac(..) => {\n                 // do nothing, these are just around to be encoded\n-           }\n+            }\n         }\n     }\n \n@@ -3530,6 +3517,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n+        // Check for imports appearing after non-item statements.\n+        let mut found_non_item = false;\n+        for statement in block.stmts.iter() {\n+            if let ast::StmtDecl(ref declaration, _) = statement.node {\n+                if let ast::DeclItem(ref i) = declaration.node {\n+                    match i.node {\n+                        ItemExternCrate(_) | ItemUse(_) if found_non_item => {\n+                            span_err!(self.session, i.span, E0154,\n+                                \"imports are not allowed after non-item statements\");\n+                        }\n+                        _ => {}\n+                    }\n+                } else {\n+                    found_non_item = true\n+                }\n+            } else {\n+                found_non_item = true;\n+            }\n+        }\n+\n         // Descend into the block.\n         visit::walk_block(self, block);\n "}, {"sha": "eedfc9407515c99d000276da650b57ef03b4ae54", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -178,7 +178,7 @@ pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n     let output = symbol_hasher.result_bytes();\n     // 64 bits should be enough to avoid collisions.\n-    output.slice_to(8).to_hex().to_string()\n+    output[.. 8].to_hex().to_string()\n }\n \n \n@@ -779,22 +779,22 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     }\n \n     if sess.opts.debugging_opts.print_link_args {\n-        println!(\"{}\", &cmd);\n+        println!(\"{:?}\", &cmd);\n     }\n \n     // May have not found libraries in the right formats.\n     sess.abort_if_errors();\n \n     // Invoke the system linker\n-    debug!(\"{}\", &cmd);\n+    debug!(\"{:?}\", &cmd);\n     let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n                                  prog.status)[]);\n-                sess.note(&format!(\"{}\", &cmd)[]);\n+                sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n                 output.push_all(&prog.output[]);\n                 sess.note(str::from_utf8(&output[]).unwrap());\n@@ -1183,7 +1183,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = &name[3..(name.len() - 5)]; // chop off lib/.rlib\n+            let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n                  &format!(\"altering {}.rlib\", name)[],\n                  (), |()| {"}, {"sha": "590354ab54e0af5c99f3eb40eeea62bea81eaa2c", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -60,7 +60,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = &file[3..(file.len() - 5)]; // chop off lib/.rlib\n+        let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n@@ -201,7 +201,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = &bytes[position_in_bytes..(position_in_bytes + mem::size_of::<T>())];\n+    let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "b07c2060e692f043bff622efb6dc8f93dc3dc16e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -67,11 +67,11 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        let output = CString::from_slice(output.as_vec());\n+        let output_c = CString::from_slice(output.as_vec());\n         let result = llvm::LLVMRustWriteOutputFile(\n-                target, pm, m, output.as_ptr(), file_type);\n+                target, pm, m, output_c.as_ptr(), file_type);\n         if !result {\n-            llvm_err(handler, \"could not write output\".to_string());\n+            llvm_err(handler, format!(\"could not write output to {}\", output.display()));\n         }\n     }\n }\n@@ -716,7 +716,7 @@ pub fn run_passes(sess: &Session,\n         cmd.args(&sess.target.target.options.post_link_args[]);\n \n         if sess.opts.debugging_opts.print_link_args {\n-            println!(\"{}\", &cmd);\n+            println!(\"{:?}\", &cmd);\n         }\n \n         cmd.stdin(::std::io::process::Ignored)\n@@ -725,7 +725,7 @@ pub fn run_passes(sess: &Session,\n         match cmd.status() {\n             Ok(status) => {\n                 if !status.success() {\n-                    sess.err(&format!(\"linking of {} with `{}` failed\",\n+                    sess.err(&format!(\"linking of {} with `{:?}` failed\",\n                                      output_path.display(), cmd)[]);\n                     sess.abort_if_errors();\n                 }\n@@ -953,15 +953,15 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n-    debug!(\"{}\", &cmd);\n+    debug!(\"{:?}\", &cmd);\n \n     match cmd.output() {\n         Ok(prog) => {\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n                                  prog.status)[]);\n-                sess.note(&format!(\"{}\", &cmd)[]);\n+                sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n                 note.push_all(&prog.output[]);\n                 sess.note(str::from_utf8(&note[]).unwrap());"}, {"sha": "4aec53711ad8af02b250b6e40edfff9b522d3747", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 107, "deletions": 116, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -157,7 +157,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n \n-        let sub_paths = sub_paths.slice(0, len-1);\n+        let sub_paths = &sub_paths[.. (len-1)];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n@@ -174,7 +174,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 1 {\n             return;\n         }\n-        let sub_paths = sub_paths.slice_to(len-1);\n+        let sub_paths = &sub_paths[.. (len-1)];\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];\n@@ -186,7 +186,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = &sub_paths[..(len-2)];\n+        let sub_paths = &sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n@@ -1037,6 +1037,110 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match item.node {\n+            ast::ItemUse(ref use_item) => {\n+                match use_item.node {\n+                    ast::ViewPathSimple(ident, ref path) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(item.id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(item.id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   self.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               item.id,\n+                                               mod_id,\n+                                               get_ident(ident).get(),\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path);\n+                    }\n+                    ast::ViewPathGlob(ref path) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&item.id) {\n+                            for n in glob_map[item.id].iter() {\n+                                if name_string.len() > 0 {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              item.id,\n+                                              name_string.as_slice(),\n+                                              self.cur_scope);\n+                        self.write_sub_paths(path);\n+                    }\n+                    ast::ViewPathList(ref path, ref list) => {\n+                        for plid in list.iter() {\n+                            match plid.node {\n+                                ast::PathListIdent { id, .. } => {\n+                                    match self.lookup_type_ref(id) {\n+                                        Some(def_id) =>\n+                                            match self.lookup_def_kind(id, plid.span) {\n+                                                Some(kind) => {\n+                                                    self.fmt.ref_str(\n+                                                        kind, plid.span,\n+                                                        Some(plid.span),\n+                                                        def_id, self.cur_scope);\n+                                                }\n+                                                None => ()\n+                                            },\n+                                        None => ()\n+                                    }\n+                                },\n+                                ast::PathListMod { .. } => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path);\n+                    }\n+                }\n+            }\n+            ast::ItemExternCrate(ref s) => {\n+                let name = get_ident(item.ident);\n+                let name = name.get();\n+                let s = match *s {\n+                    Some((ref s, _)) => s.get().to_string(),\n+                    None => name.to_string(),\n+                };\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Crate);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(item.span,\n+                                          sub_span,\n+                                          item.id,\n+                                          cnum,\n+                                          name,\n+                                          &s[],\n+                                          self.cur_scope);\n+            }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n@@ -1160,119 +1264,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        if generated_code(i.span) {\n-            return\n-        }\n-\n-        match i.node {\n-            ast::ViewItemUse(ref item) => {\n-                match item.node {\n-                    ast::ViewPathSimple(ident, ref path, id) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(id) {\n-                            Some(def_id) => {\n-                                match self.lookup_def_kind(id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {},\n-                                }\n-                                Some(def_id)\n-                            },\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n-\n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               id,\n-                                               mod_id,\n-                                               get_ident(ident).get(),\n-                                               self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n-                    }\n-                    ast::ViewPathGlob(ref path, id) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n-                        let glob_map = &self.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&id) {\n-                            for n in glob_map[id].iter() {\n-                                if name_string.len() > 0 {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(n.as_str());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              id,\n-                                              name_string.as_slice(),\n-                                              self.cur_scope);\n-                        self.write_sub_paths(path);\n-                    }\n-                    ast::ViewPathList(ref path, ref list, _) => {\n-                        for plid in list.iter() {\n-                            match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n-                                    }\n-                                },\n-                                ast::PathListMod { .. } => ()\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path);\n-                    }\n-                }\n-            },\n-            ast::ViewItemExternCrate(ident, ref s, id) => {\n-                let name = get_ident(ident);\n-                let name = name.get();\n-                let s = match *s {\n-                    Some((ref s, _)) => s.get().to_string(),\n-                    None => name.to_string(),\n-                };\n-                let sub_span = self.span.sub_span_after_keyword(i.span, keywords::Crate);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-                    Some(cnum) => cnum,\n-                    None => 0,\n-                };\n-                self.fmt.extern_crate_str(i.span,\n-                                          sub_span,\n-                                          id,\n-                                          cnum,\n-                                          name,\n-                                          &s[],\n-                                          self.cur_scope);\n-            },\n-        }\n-    }\n-\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         if generated_code(t.span) {\n             return"}, {"sha": "97b3cda006bf7b36441b53b188ac58aacd105c8b", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -40,8 +40,8 @@ impl<'a> SpanUtils<'a> {\n         format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n                  file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n                 lo_loc.file.name,\n-                lo_loc.line, lo_loc.col.to_uint(), lo_pos.to_uint(), lo_pos_byte.to_uint(),\n-                hi_loc.line, hi_loc.col.to_uint(), hi_pos.to_uint(), hi_pos_byte.to_uint())\n+                lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n+                hi_loc.line, hi_loc.col.to_usize(), hi_pos.to_usize(), hi_pos_byte.to_usize())\n     }\n \n     // sub_span starts at span.lo, so we need to adjust the positions etc."}, {"sha": "dcb0b0ef4ea378c993cea041eb799c131addcd8d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -208,10 +208,10 @@ use trans::cleanup::{self, CleanupMethods};\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::expr::{self, Dest};\n use trans::tvec;\n use trans::type_of;\n-use trans::debuginfo;\n use middle::ty::{self, Ty};\n use session::config::FullDebugInfo;\n use util::common::indenter;\n@@ -472,7 +472,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n             let mut r = pats[..col].to_vec();\n-            r.push_all(&pats[(col + 1)..]);\n+            r.push_all(&pats[col + 1..]);\n             Some(r)\n         } else {\n             None\n@@ -632,7 +632,7 @@ fn bind_subslice_pat(bcx: Block,\n \n     let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n-    let slice_len = Sub(bcx, len, slice_len_offset);\n+    let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n                                 bcx.tcx().mk_region(ty::ReStatic),\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n@@ -656,7 +656,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     elems.extend(range(0, before).map(|i| GEPi(bcx, base, &[i])));\n     elems.extend(range(0, after).rev().map(|i| {\n         InBoundsGEP(bcx, base, &[\n-            Sub(bcx, len, C_uint(bcx.ccx(), i + 1))\n+            Sub(bcx, len, C_uint(bcx.ccx(), i + 1), DebugLoc::None)\n         ])\n     }));\n     ExtractedBlock { vals: elems, bcx: bcx }\n@@ -731,7 +731,7 @@ impl FailureHandler {\n             Infallible =>\n                 panic!(\"attempted to panic in a non-panicking panic handler!\"),\n             JumpToBasicBlock(basic_block) =>\n-                Br(bcx, basic_block),\n+                Br(bcx, basic_block, DebugLoc::None),\n             Unreachable =>\n                 build::Unreachable(bcx)\n         }\n@@ -889,7 +889,7 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    with_cond(bcx, Not(bcx, val), |bcx| {\n+    with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n         for (_, &binding_info) in data.bindings_map.iter() {\n             call_lifetime_end(bcx, binding_info.llmatch);\n@@ -966,7 +966,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            Br(bcx, data.bodycx.llbb);\n+            Br(bcx, data.bodycx.llbb, DebugLoc::None);\n         }\n     }\n }\n@@ -983,7 +983,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let dm = &tcx.def_map;\n \n     let mut vals_left = vals[0u..col].to_vec();\n-    vals_left.push_all(&vals[(col + 1u)..]);\n+    vals_left.push_all(&vals[col + 1u..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1096,7 +1096,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         if !exhaustive || i + 1 < len {\n             opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n-                Single => Br(bcx, opt_cx.llbb),\n+                Single => Br(bcx, opt_cx.llbb, DebugLoc::None),\n                 Switch => {\n                     match opt.trans(bcx) {\n                         SingleResult(r) => {\n@@ -1131,7 +1131,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     compare_scalar_types(\n                                     bcx, test_val, vend,\n                                     t, ast::BiLe);\n-                                Result::new(bcx, And(bcx, llge, llle))\n+                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n                                 compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n@@ -1149,12 +1149,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n                         branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                     }\n-                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, DebugLoc::None);\n                 }\n                 _ => ()\n             }\n         } else if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb);\n+            Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n \n         let mut size = 0u;\n@@ -1194,7 +1194,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Compile the fall-through case, if any\n     if !exhaustive && kind != Single {\n         if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb);\n+            Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n         match chk {\n             // If there is only one default arm left, move on to the next"}, {"sha": "c98515cff6857e38017a8466246ab32378d1fc75", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -62,6 +62,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum;\n+use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -979,7 +980,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n-                Br(variant_cx, bcx_next.llbb);\n+                Br(variant_cx, bcx_next.llbb, DebugLoc::None);\n             }\n \n             bcx_next"}, {"sha": "572dfd165eedabe1c19ea63af49216edce041838", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 40, "deletions": 52, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -57,7 +57,7 @@ use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n-use trans::common::{NodeInfo, Result};\n+use trans::common::{Result};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{tydesc_info, type_is_immediate};\n use trans::common::{type_is_zero_size, val_ty};\n@@ -66,7 +66,7 @@ use trans::consts;\n use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc};\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n@@ -362,18 +362,6 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n     }\n }\n \n-// Returns a pointer to the body for the box. The box may be an opaque\n-// box. The result will be casted to the type of body_t, if it is statically\n-// known.\n-pub fn at_box_body<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               body_t: Ty<'tcx>, boxptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"at_box_body\");\n-    let ccx = bcx.ccx();\n-    let ty = Type::at_box(ccx, type_of(ccx, body_t));\n-    let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n-    GEPi(bcx, boxptr, &[0u, abi::BOX_FIELD_BODY])\n-}\n-\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 info_ty: Ty<'tcx>, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n@@ -792,7 +780,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                        &**variant,\n                                        substs,\n                                        &mut f);\n-                      Br(variant_cx, next_cx.llbb);\n+                      Br(variant_cx, next_cx.llbb, DebugLoc::None);\n                   }\n                   cx = next_cx;\n               }\n@@ -957,7 +945,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n                           fn_ty: Ty<'tcx>,\n-                          call_info: Option<NodeInfo>)\n+                          debug_loc: DebugLoc)\n                           -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n@@ -983,30 +971,25 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n \n-        match call_info {\n-            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n         let llresult = Invoke(bcx,\n                               llfn,\n                               &llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              Some(attributes));\n+                              Some(attributes),\n+                              debug_loc);\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n-        match call_info {\n-            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n-        let llresult = Call(bcx, llfn, &llargs[], Some(attributes));\n+        let llresult = Call(bcx,\n+                            llfn,\n+                            &llargs[],\n+                            Some(attributes),\n+                            debug_loc);\n         return (llresult, bcx);\n     }\n }\n@@ -1094,10 +1077,10 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");\n     let cond_cx = fcx.new_temp_block(\"cond\");\n-    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n+    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb, DebugLoc::None);\n     let after_cx = f(cond_cx);\n     if !after_cx.terminated.get() {\n-        Br(after_cx, next_cx.llbb);\n+        Br(after_cx, next_cx.llbb, DebugLoc::None);\n     }\n     next_cx\n }\n@@ -1113,7 +1096,7 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx, lifetime_start, &[llsize, ptr], None);\n+    Call(cx, lifetime_start, &[llsize, ptr], None, DebugLoc::None);\n }\n \n pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n@@ -1127,7 +1110,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx, lifetime_end, &[llsize, ptr], None);\n+    Call(cx, lifetime_end, &[llsize, ptr], None, DebugLoc::None);\n }\n \n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n@@ -1144,7 +1127,7 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n+    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None, DebugLoc::None);\n }\n \n pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -1697,13 +1680,14 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n                              last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput<'tcx>) {\n+                             retty: ty::FnOutput<'tcx>,\n+                             ret_debug_loc: DebugLoc) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n             if !last_bcx.terminated.get() {\n-                Br(last_bcx, llreturn);\n+                Br(last_bcx, llreturn, DebugLoc::None);\n             }\n             raw_block(fcx, false, llreturn)\n         }\n@@ -1713,7 +1697,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n     let substd_retty = fcx.monomorphize(&retty);\n-    build_return_block(fcx, ret_cx, substd_retty);\n+    build_return_block(fcx, ret_cx, substd_retty, ret_debug_loc);\n \n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n@@ -1722,10 +1706,11 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n // Builds the return block for a function.\n pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                                       ret_cx: Block<'blk, 'tcx>,\n-                                      retty: ty::FnOutput<'tcx>) {\n+                                      retty: ty::FnOutput<'tcx>,\n+                                      ret_debug_location: DebugLoc) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n-        return RetVoid(ret_cx);\n+        return RetVoid(ret_cx, ret_debug_location);\n     }\n \n     let retslot = if fcx.needs_ret_allocas {\n@@ -1755,26 +1740,26 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                 if let ty::FnConverging(retty) = retty {\n                     store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n                 }\n-                RetVoid(ret_cx)\n+                RetVoid(ret_cx, ret_debug_location)\n             } else {\n-                Ret(ret_cx, retval)\n+                Ret(ret_cx, retval, ret_debug_location)\n             }\n         }\n         // Otherwise, copy the return value to the ret slot\n         None => match retty {\n             ty::FnConverging(retty) => {\n                 if fcx.caller_expects_out_pointer {\n                     memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n-                    RetVoid(ret_cx)\n+                    RetVoid(ret_cx, ret_debug_location)\n                 } else {\n-                    Ret(ret_cx, load_ty(ret_cx, retslot, retty))\n+                    Ret(ret_cx, load_ty(ret_cx, retslot, retty), ret_debug_location)\n                 }\n             }\n             ty::FnDiverging => {\n                 if fcx.caller_expects_out_pointer {\n-                    RetVoid(ret_cx)\n+                    RetVoid(ret_cx, ret_debug_location)\n                 } else {\n-                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)))\n+                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)), ret_debug_location)\n                 }\n             }\n         }\n@@ -1832,7 +1817,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n     let monomorphized_arg_types = match closure_env.kind {\n-        closure::NotClosure | closure::BoxedClosure(..) => {\n+        closure::NotClosure => {\n             monomorphized_arg_types\n         }\n \n@@ -1859,7 +1844,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n \n     bcx = match closure_env.kind {\n-        closure::NotClosure | closure::BoxedClosure(..) => {\n+        closure::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n                                  &decl.inputs[],\n@@ -1905,7 +1890,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match fcx.llreturn.get() {\n         Some(_) => {\n-            Br(bcx, fcx.return_exit_block());\n+            Br(bcx, fcx.return_exit_block(), DebugLoc::None);\n             fcx.pop_custom_cleanup_scope(arg_scope);\n         }\n         None => {\n@@ -1924,8 +1909,11 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n+    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id,\n+                                     fn_cleanup_debug_loc.span);\n+\n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx, output_type);\n+    finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -1977,7 +1965,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n-                                                 call_info: Option<NodeInfo>)\n+                                                 debug_loc: DebugLoc)\n                                                  -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n@@ -2016,7 +2004,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       &fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n-                                      call_info);\n+                                      debug_loc);\n             }\n             _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")\n         }\n@@ -2027,7 +2015,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let bcx = match dest {\n         expr::SaveIn(_) => bcx,\n         expr::Ignore => {\n-            glue::drop_ty(bcx, llresult, result_ty, call_info)\n+            glue::drop_ty(bcx, llresult, result_ty, debug_loc)\n         }\n     };\n \n@@ -2094,7 +2082,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         adt::trans_set_discr(bcx, &*repr, dest, disr);\n     }\n \n-    finish_fn(&fcx, bcx, result_ty);\n+    finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n }\n \n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {"}, {"sha": "7acac5a12ebd216c8e1132b477881b5512a8a17e", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 318, "deletions": 80, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -20,6 +20,7 @@ use syntax::codemap::Span;\n \n use trans::builder::Builder;\n use trans::type_::Type;\n+use trans::debuginfo::DebugLoc;\n \n use libc::{c_uint, c_char};\n \n@@ -48,41 +49,59 @@ pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n // for (panic/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: Block) {\n-    if cx.unreachable.get() { return; }\n+pub fn RetVoid(cx: Block, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: Block, v: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Ret(cx: Block, v: ValueRef, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).ret(v);\n }\n \n-pub fn AggregateRet(cx: Block, ret_vals: &[ValueRef]) {\n-    if cx.unreachable.get() { return; }\n+pub fn AggregateRet(cx: Block,\n+                    ret_vals: &[ValueRef],\n+                    debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).aggregate_ret(ret_vals);\n }\n \n-pub fn Br(cx: Block, dest: BasicBlockRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Br(cx: Block, dest: BasicBlockRef, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).br(dest);\n }\n \n pub fn CondBr(cx: Block,\n               if_: ValueRef,\n               then: BasicBlockRef,\n-              else_: BasicBlockRef) {\n-    if cx.unreachable.get() { return; }\n+              else_: BasicBlockRef,\n+              debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).cond_br(if_, then, else_);\n }\n \n@@ -101,10 +120,16 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: Block, addr: ValueRef, num_dests: uint) {\n-    if cx.unreachable.get() { return; }\n+pub fn IndirectBr(cx: Block,\n+                  addr: ValueRef,\n+                  num_dests: uint,\n+                  debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).indirect_br(addr, num_dests);\n }\n \n@@ -113,7 +138,8 @@ pub fn Invoke(cx: Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: Option<AttrBuilder>)\n+              attributes: Option<AttrBuilder>,\n+              debug_loc: DebugLoc)\n               -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8(cx.ccx()));\n@@ -123,6 +149,7 @@ pub fn Invoke(cx: Block,\n     debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_string(fn_),\n            args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().connect(\", \"));\n+    debug_loc.apply(cx.fcx);\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n \n@@ -143,176 +170,378 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Add(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).add(lhs, rhs)\n }\n \n-pub fn NSWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWAdd(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswadd(lhs, rhs)\n }\n \n-pub fn NUWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWAdd(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwadd(lhs, rhs)\n }\n \n-pub fn FAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FAdd(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fadd(lhs, rhs)\n }\n \n-pub fn Sub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Sub(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).sub(lhs, rhs)\n }\n \n-pub fn NSWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWSub(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswsub(lhs, rhs)\n }\n \n-pub fn NUWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWSub(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwsub(lhs, rhs)\n }\n \n-pub fn FSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FSub(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fsub(lhs, rhs)\n }\n \n-pub fn Mul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Mul(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).mul(lhs, rhs)\n }\n \n-pub fn NSWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWMul(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswmul(lhs, rhs)\n }\n \n-pub fn NUWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWMul(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwmul(lhs, rhs)\n }\n \n-pub fn FMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FMul(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fmul(lhs, rhs)\n }\n \n-pub fn UDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn UDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).udiv(lhs, rhs)\n }\n \n-pub fn SDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn SDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).sdiv(lhs, rhs)\n }\n \n-pub fn ExactSDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn ExactSDiv(cx: Block,\n+                 lhs: ValueRef,\n+                 rhs: ValueRef,\n+                 debug_loc: DebugLoc)\n+                 -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).exactsdiv(lhs, rhs)\n }\n \n-pub fn FDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fdiv(lhs, rhs)\n }\n \n-pub fn URem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn URem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).urem(lhs, rhs)\n }\n \n-pub fn SRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn SRem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).srem(lhs, rhs)\n }\n \n-pub fn FRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FRem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).frem(lhs, rhs)\n }\n \n-pub fn Shl(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Shl(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).shl(lhs, rhs)\n }\n \n-pub fn LShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn LShr(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).lshr(lhs, rhs)\n }\n \n-pub fn AShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn AShr(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).ashr(lhs, rhs)\n }\n \n-pub fn And(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn And(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).and(lhs, rhs)\n }\n \n-pub fn Or(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Or(cx: Block,\n+          lhs: ValueRef,\n+          rhs: ValueRef,\n+          debug_loc: DebugLoc)\n+          -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).or(lhs, rhs)\n }\n \n-pub fn Xor(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Xor(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).xor(lhs, rhs)\n }\n \n-pub fn BinOp(cx: Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+pub fn BinOp(cx: Block,\n+             op: Opcode,\n+             lhs: ValueRef,\n+             rhs: ValueRef,\n+             debug_loc: DebugLoc)\n           -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).binop(op, lhs, rhs)\n }\n \n-pub fn Neg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn Neg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).neg(v)\n }\n \n-pub fn NSWNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn NSWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswneg(v)\n }\n \n-pub fn NUWNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn NUWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwneg(v)\n }\n-pub fn FNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn FNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fneg(v)\n }\n \n-pub fn Not(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn Not(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).not(v)\n }\n \n /* Memory */\n-pub fn Malloc(cx: Block, ty: Type) -> ValueRef {\n+pub fn Malloc(cx: Block, ty: Type, debug_loc: DebugLoc) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).malloc(ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: Block,\n+                   ty: Type,\n+                   val: ValueRef,\n+                   debug_loc: DebugLoc) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).array_malloc(ty, val)\n     }\n }\n@@ -327,6 +556,7 @@ pub fn Alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n     let b = fcx.ccx.builder();\n     b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+    DebugLoc::None.apply(fcx);\n     b.alloca(ty, name)\n }\n \n@@ -335,6 +565,7 @@ pub fn ArrayAlloca(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n         b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+        DebugLoc::None.apply(cx.fcx);\n         b.array_alloca(ty, val)\n     }\n }\n@@ -680,9 +911,16 @@ pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: Block, fn_: ValueRef, args: &[ValueRef],\n-            attributes: Option<AttrBuilder>) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+pub fn Call(cx: Block,\n+            fn_: ValueRef,\n+            args: &[ValueRef],\n+            attributes: Option<AttrBuilder>,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _UndefReturn(cx, fn_);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).call(fn_, args, attributes)\n }\n "}, {"sha": "3c0530bbb9a6497b74f9d01ee7c811db1a14e5d0", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -361,7 +361,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                     }\n                     _ => unreachable!(),\n                 };\n-                let vec_len = llvec_len(&cls[(i + 1u)..]);\n+                let vec_len = llvec_len(&cls[i + 1u..]);\n                 let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "7ed4727404e10557c960976b787ec3aacee1a240", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -40,6 +40,7 @@ use trans::common;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::glue;\n use trans::inline;\n@@ -356,7 +357,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            ArgVals(&llargs[]),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output);\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n \n@@ -646,7 +647,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           call_info: Option<NodeInfo>,\n+                                           call_info: Option<NodeIdAndSpan>,\n                                            callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n@@ -703,7 +704,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n-                                                       call_info);\n+                                                       call_info.debug_loc());\n         }\n     };\n \n@@ -781,7 +782,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                       llfn,\n                                       &llargs[],\n                                       callee_ty,\n-                                      call_info);\n+                                      call_info.debug_loc());\n         bcx = b;\n         llresult = llret;\n \n@@ -828,7 +829,10 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     match (dest, opt_llretslot, ret_ty) {\n         (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, ret_ty, call_info);\n+            bcx = glue::drop_ty(bcx,\n+                                llretslot,\n+                                ret_ty,\n+                                call_info.debug_loc());\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}"}, {"sha": "a25f4f778ab7ac34f903801b12ebe240e59976be", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -21,8 +21,8 @@ use trans::base;\n use trans::build;\n use trans::callee;\n use trans::common;\n-use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n-use trans::debuginfo;\n+use trans::common::{Block, FunctionContext, ExprId, NodeIdAndSpan};\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n@@ -44,7 +44,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n \n     // The debug location any drop calls generated for this scope will be\n     // associated with.\n-    debug_loc: Option<NodeInfo>,\n+    debug_loc: DebugLoc,\n \n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n@@ -65,7 +65,7 @@ pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>; EXIT_MAX])\n }\n \n-impl<'blk, 'tcx: 'blk> fmt::Show for CleanupScopeKind<'blk, 'tcx> {\n+impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             CustomScopeKind => write!(f, \"CustomScopeKind\"),\n@@ -100,7 +100,7 @@ pub trait Cleanup<'tcx> {\n     fn is_lifetime_end(&self) -> bool;\n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx>;\n }\n \n@@ -114,7 +114,7 @@ pub enum ScopeId {\n \n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Invoked when we start to trans the code contained within a new cleanup scope.\n-    fn push_ast_cleanup_scope(&self, debug_loc: NodeInfo) {\n+    fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {\n         debug!(\"push_ast_cleanup_scope({})\",\n                self.ccx.tcx().map.node_to_string(debug_loc.id));\n \n@@ -139,7 +139,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n-                                          Some(debug_loc)));\n+                                          debug_loc.debug_loc()));\n     }\n \n     fn push_loop_cleanup_scope(&self,\n@@ -168,19 +168,20 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                             .borrow()\n                             .last()\n                             .map(|opt_scope| opt_scope.debug_loc)\n-                            .unwrap_or(None);\n+                            .unwrap_or(DebugLoc::None);\n \n         self.push_scope(CleanupScope::new(CustomScopeKind, debug_loc));\n         CustomScopeIndex { index: index }\n     }\n \n     fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeInfo)\n+                                                debug_loc: NodeIdAndSpan)\n                                                 -> CustomScopeIndex {\n         let index = self.scopes_len();\n         debug!(\"push_custom_cleanup_scope(): {}\", index);\n \n-        self.push_scope(CleanupScope::new(CustomScopeKind, Some(debug_loc)));\n+        self.push_scope(CleanupScope::new(CustomScopeKind,\n+                                          debug_loc.debug_loc()));\n         CustomScopeIndex { index: index }\n     }\n \n@@ -664,7 +665,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                                                 scope.debug_loc);\n                     }\n                 }\n-                build::Br(bcx_out, prev_llbb);\n+                build::Br(bcx_out, prev_llbb, DebugLoc::None);\n                 prev_llbb = bcx_in.llbb;\n             } else {\n                 debug!(\"no suitable cleanups in {}\",\n@@ -766,15 +767,15 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n         // Generate the cleanup block and branch to it.\n         let cleanup_llbb = self.trans_cleanups_to_exit_scope(UnwindExit);\n-        build::Br(pad_bcx, cleanup_llbb);\n+        build::Br(pad_bcx, cleanup_llbb, DebugLoc::None);\n \n         return pad_bcx.llbb;\n     }\n }\n \n impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n     fn new(kind: CleanupScopeKind<'blk, 'tcx>,\n-           debug_loc: Option<NodeInfo>)\n+           debug_loc: DebugLoc)\n         -> CleanupScope<'blk, 'tcx> {\n         CleanupScope {\n             kind: kind,\n@@ -896,7 +897,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n@@ -937,9 +938,9 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n \n         match self.heap {\n             HeapExchange => {\n@@ -972,9 +973,9 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n \n         match self.heap {\n             HeapExchange => {\n@@ -1004,9 +1005,9 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx\n     }\n@@ -1041,33 +1042,22 @@ fn cleanup_is_suitable_for(c: &Cleanup,\n     !label.is_unwind() || c.clean_on_unwind()\n }\n \n-fn apply_debug_loc(fcx: &FunctionContext, debug_loc: Option<NodeInfo>) {\n-    match debug_loc {\n-        Some(ref src_loc) => {\n-            debuginfo::set_source_location(fcx, src_loc.id, src_loc.span);\n-        }\n-        None => {\n-            debuginfo::clear_source_location(fcx);\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n \n pub trait CleanupMethods<'blk, 'tcx> {\n-    fn push_ast_cleanup_scope(&self, id: NodeInfo);\n+    fn push_ast_cleanup_scope(&self, id: NodeIdAndSpan);\n     fn push_loop_cleanup_scope(&self,\n                                id: ast::NodeId,\n                                exits: [Block<'blk, 'tcx>; EXIT_MAX]);\n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n     fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeInfo)\n+                                                debug_loc: NodeIdAndSpan)\n                                                 -> CustomScopeIndex;\n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                              bcx: Block<'blk, 'tcx>,\n-                                              cleanup_scope: ast::NodeId)\n-                                              -> Block<'blk, 'tcx>;\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       cleanup_scope: ast::NodeId)\n+                                       -> Block<'blk, 'tcx>;\n     fn pop_loop_cleanup_scope(&self,\n                               cleanup_scope: ast::NodeId);\n     fn pop_custom_cleanup_scope(&self,"}, {"sha": "7a6c0c50dd1ffed8223b22dc095396016fe1900f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 319, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -10,278 +10,34 @@\n \n pub use self::ClosureKind::*;\n \n-use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::ValueRef;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::cleanup::{CleanupMethods, ScopeId};\n use trans::common::*;\n-use trans::datum::{Datum, Lvalue, rvalue_scratch_datum};\n+use trans::datum::{Datum, rvalue_scratch_datum};\n use trans::datum::{Rvalue, ByValue};\n use trans::debuginfo;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n-use trans::type_::Type;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, UnboxedClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n-use util::ppaux::ty_to_string;\n \n use syntax::ast;\n use syntax::ast_util;\n \n-// ___Good to know (tm)__________________________________________________\n-//\n-// The layout of a closure environment in memory is\n-// roughly as follows:\n-//\n-// struct rust_opaque_box {         // see rust_internal.h\n-//   unsigned ref_count;            // obsolete (part of @T's header)\n-//   fn(void*) *drop_glue;          // destructor (for proc)\n-//   rust_opaque_box *prev;         // obsolete (part of @T's header)\n-//   rust_opaque_box *next;         // obsolete (part of @T's header)\n-//   struct closure_data {\n-//       upvar1_t upvar1;\n-//       ...\n-//       upvarN_t upvarN;\n-//    }\n-// };\n-//\n-// Note that the closure is itself a rust_opaque_box.  This is true\n-// even for ~fn and ||, because we wish to keep binary compatibility\n-// between all kinds of closures.  The allocation strategy for this\n-// closure depends on the closure type.  For a sendfn, the closure\n-// (and the referenced type descriptors) will be allocated in the\n-// exchange heap.  For a fn, the closure is allocated in the task heap\n-// and is reference counted.  For a block, the closure is allocated on\n-// the stack.\n-//\n-// ## Opaque closures and the embedded type descriptor ##\n-//\n-// One interesting part of closures is that they encapsulate the data\n-// that they close over.  So when I have a ptr to a closure, I do not\n-// know how many type descriptors it contains nor what upvars are\n-// captured within.  That means I do not know precisely how big it is\n-// nor where its fields are located.  This is called an \"opaque\n-// closure\".\n-//\n-// Typically an opaque closure suffices because we only manipulate it\n-// by ptr.  The routine Type::at_box().ptr_to() returns an appropriate\n-// type for such an opaque closure; it allows access to the box fields,\n-// but not the closure_data itself.\n-//\n-// But sometimes, such as when cloning or freeing a closure, we need\n-// to know the full information.  That is where the type descriptor\n-// that defines the closure comes in handy.  We can use its take and\n-// drop glue functions to allocate/free data as needed.\n-//\n-// ## Subtleties concerning alignment ##\n-//\n-// It is important that we be able to locate the closure data *without\n-// knowing the kind of data that is being bound*.  This can be tricky\n-// because the alignment requirements of the bound data affects the\n-// alignment requires of the closure_data struct as a whole.  However,\n-// right now this is a non-issue in any case, because the size of the\n-// rust_opaque_box header is always a multiple of 16-bytes, which is\n-// the maximum alignment requirement we ever have to worry about.\n-//\n-// The only reason alignment matters is that, in order to learn what data\n-// is bound, we would normally first load the type descriptors: but their\n-// location is ultimately depend on their content!  There is, however, a\n-// workaround.  We can load the tydesc from the rust_opaque_box, which\n-// describes the closure_data struct and has self-contained derived type\n-// descriptors, and read the alignment from there.   It's just annoying to\n-// do.  Hopefully should this ever become an issue we'll have monomorphized\n-// and type descriptors will all be a bad dream.\n-//\n-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-#[derive(Copy)]\n-pub struct EnvValue<'tcx> {\n-    action: ast::CaptureClause,\n-    datum: Datum<'tcx, Lvalue>\n-}\n-\n-impl<'tcx> EnvValue<'tcx> {\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"{:?}({})\", self.action, self.datum.to_string(ccx))\n-    }\n-}\n-\n-// Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            bound_values: &[EnvValue<'tcx>])\n-                            -> Ty<'tcx> {\n-    // determine the types of the values in the env.  Note that this\n-    // is the actual types that will be stored in the map, not the\n-    // logical types as the user sees them, so by-ref upvars must be\n-    // converted to ptrs.\n-    let bound_tys = bound_values.iter().map(|bv| {\n-        match bv.action {\n-            ast::CaptureByValue => bv.datum.ty,\n-            ast::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n-        }\n-    }).collect();\n-    let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!(\"cdata_ty={}\", ty_to_string(tcx, cdata_ty));\n-    return cdata_ty;\n-}\n-\n-fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    let ptr = ty::mk_imm_ptr(tcx, tcx.types.i8);\n-    ty::mk_tup(tcx, vec!(tcx.types.uint, ty::mk_nil_ptr(tcx), ptr, ptr, t))\n-}\n-\n-pub struct ClosureResult<'blk, 'tcx: 'blk> {\n-    llbox: ValueRef,        // llvalue of ptr to closure\n-    cdata_ty: Ty<'tcx>,     // type of the closure data\n-    bcx: Block<'blk, 'tcx>  // final bcx\n-}\n-\n-// Given a block context and a list of tydescs and values to bind\n-// construct a closure out of them. If copying is true, it is a\n-// heap allocated closure that copies the upvars into environment.\n-// Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     bound_values: Vec<EnvValue<'tcx>>)\n-                                     -> ClosureResult<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::store_environment\");\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx();\n-\n-    // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, &bound_values[]);\n-\n-    // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n-    // tuple.  This could be a ptr in uniq or a box or on stack,\n-    // whatever.\n-    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::MutImmutable});\n-    let llboxptr_ty = type_of(ccx, cboxptr_ty);\n-\n-    // If there are no bound values, no point in allocating anything.\n-    if bound_values.is_empty() {\n-        return ClosureResult {llbox: C_null(llboxptr_ty),\n-                              cdata_ty: cdata_ty,\n-                              bcx: bcx};\n-    }\n-\n-    // allocate closure in the heap\n-    let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n-\n-    let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug!(\"tuplify_box_ty = {}\", ty_to_string(tcx, cbox_ty));\n-\n-    // Copy expr values into boxed bindings.\n-    let mut bcx = bcx;\n-    for (i, bv) in bound_values.into_iter().enumerate() {\n-        debug!(\"Copy {} into closure\", bv.to_string(ccx));\n-\n-        if ccx.sess().asm_comments() {\n-            add_comment(bcx, &format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx))[]);\n-        }\n-\n-        let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n-\n-        match bv.action {\n-            ast::CaptureByValue => {\n-                bcx = bv.datum.store_to(bcx, bound_data);\n-            }\n-            ast::CaptureByRef => {\n-                Store(bcx, bv.datum.to_llref(), bound_data);\n-            }\n-        }\n-    }\n-\n-    ClosureResult { llbox: llbox, cdata_ty: cdata_ty, bcx: bcx }\n-}\n-\n-// Given a context and a list of upvars, build a closure. This just\n-// collects the upvars and packages them up for store_environment.\n-fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n-                             freevar_mode: ast::CaptureClause,\n-                             freevars: &Vec<ty::Freevar>)\n-                             -> ClosureResult<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::build_closure\");\n-\n-    // If we need to, package up the iterator body to call\n-    let bcx = bcx0;\n-\n-    // Package up the captured upvars\n-    let mut env_vals = Vec::new();\n-    for freevar in freevars.iter() {\n-        let datum = expr::trans_local_var(bcx, freevar.def);\n-        env_vals.push(EnvValue {action: freevar_mode, datum: datum});\n-    }\n-\n-    store_environment(bcx, env_vals)\n-}\n-\n-// Given an enclosing block context, a new function context, a closure type,\n-// and a list of upvars, generate code to load and populate the environment\n-// with the upvars and type descriptors.\n-fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                cdata_ty: Ty<'tcx>,\n-                                freevars: &[ty::Freevar],\n-                                store: ty::TraitStore)\n-                                -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_environment\");\n-\n-    // Load a pointer to the closure data, skipping over the box header:\n-    let llcdata = at_box_body(bcx, cdata_ty, bcx.fcx.llenv.unwrap());\n-\n-    // Store the pointer to closure data in an alloca for debug info because that's what the\n-    // llvm.dbg.declare intrinsic expects\n-    let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n-        let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n-        Store(bcx, llcdata, alloc);\n-        Some(alloc)\n-    } else {\n-        None\n-    };\n-\n-    // Populate the upvars from the environment\n-    let mut i = 0u;\n-    for freevar in freevars.iter() {\n-        let mut upvarptr = GEPi(bcx, llcdata, &[0u, i]);\n-        let captured_by_ref = match store {\n-            ty::RegionTraitStore(..) => {\n-                upvarptr = Load(bcx, upvarptr);\n-                true\n-            }\n-            ty::UniqTraitStore => false\n-        };\n-        let def_id = freevar.def.def_id();\n-\n-        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n-        if let Some(env_pointer_alloca) = env_pointer_alloca {\n-            debuginfo::create_captured_var_metadata(\n-                bcx,\n-                def_id.node,\n-                env_pointer_alloca,\n-                i,\n-                captured_by_ref,\n-                freevar.span);\n-        }\n-\n-        i += 1u;\n-    }\n-\n-    bcx\n-}\n \n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevar_mode: ast::CaptureClause,\n                                     freevars: &[ty::Freevar])\n                                     -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_environment\");\n+    let _icx = push_ctxt(\"closure::load_unboxed_closure_environment\");\n \n     // Special case for small by-value selfs.\n     let closure_id = ast_util::local_def(bcx.fcx.id);\n@@ -341,17 +97,9 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     bcx\n }\n \n-fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n-    Store(bcx, llfn, GEPi(bcx, pair, &[0u, abi::FAT_PTR_ADDR]));\n-    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n-    Store(bcx, llenvptr, GEPi(bcx, pair, &[0u, abi::FAT_PTR_EXTRA]));\n-}\n-\n #[derive(PartialEq)]\n pub enum ClosureKind<'tcx> {\n     NotClosure,\n-    // See load_environment.\n-    BoxedClosure(Ty<'tcx>, ty::TraitStore),\n     // See load_unboxed_closure_environment.\n     UnboxedClosure(ast::CaptureClause)\n }\n@@ -379,77 +127,13 @@ impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n \n         match self.kind {\n             NotClosure => bcx,\n-            BoxedClosure(cdata_ty, store) => {\n-                load_environment(bcx, cdata_ty, self.freevars, store)\n-            }\n             UnboxedClosure(freevar_mode) => {\n                 load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n             }\n         }\n     }\n }\n \n-/// Translates the body of a closure expression.\n-///\n-/// - `store`\n-/// - `decl`\n-/// - `body`\n-/// - `id`: The id of the closure expression.\n-/// - `cap_clause`: information about captured variables, if any.\n-/// - `dest`: where to write the closure value, which must be a\n-///   (fn ptr, env) pair\n-pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 store: ty::TraitStore,\n-                                 decl: &ast::FnDecl,\n-                                 body: &ast::Block,\n-                                 id: ast::NodeId,\n-                                 dest: expr::Dest)\n-                                 -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::trans_expr_fn\");\n-\n-    let dest_addr = match dest {\n-        expr::SaveIn(p) => p,\n-        expr::Ignore => {\n-            return bcx; // closure construction is non-side-effecting\n-        }\n-    };\n-\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-    let fty = node_id_type(bcx, id);\n-    let s = tcx.map.with_path(id, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"closure\")\n-    });\n-    let llfn = decl_internal_rust_fn(ccx, fty, &s[]);\n-\n-    // set an inline hint for all closures\n-    set_inline_hint(llfn);\n-\n-    let freevar_mode = tcx.capture_mode(id);\n-    let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n-\n-    let ClosureResult {\n-        llbox,\n-        cdata_ty,\n-        bcx\n-    } = build_closure(bcx, freevar_mode, &freevars);\n-\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfn,\n-                  bcx.fcx.param_substs,\n-                  id,\n-                  &[],\n-                  ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n-                  ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(&freevars[],\n-                                  BoxedClosure(cdata_ty, store)));\n-    fill_fn_pair(bcx, dest_addr, llfn, llbox);\n-    bcx\n-}\n-\n /// Returns the LLVM function declaration for an unboxed closure, creating it\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "3bc851c55953772c02278130695d3ebf70da5885", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -30,7 +30,7 @@ use trans::build;\n use trans::cleanup;\n use trans::consts;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc};\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -275,7 +275,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-    let num = token::gensym(name).uint();\n+    let num = token::gensym(name).usize();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n     PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n@@ -317,13 +317,13 @@ pub struct tydesc_info<'tcx> {\n */\n \n #[derive(Copy)]\n-pub struct NodeInfo {\n+pub struct NodeIdAndSpan {\n     pub id: ast::NodeId,\n     pub span: Span,\n }\n \n-pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n-    NodeInfo { id: expr.id, span: expr.span }\n+pub fn expr_info(expr: &ast::Expr) -> NodeIdAndSpan {\n+    NodeIdAndSpan { id: expr.id, span: expr.span }\n }\n \n pub struct BuilderRef_res {\n@@ -517,7 +517,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let mut reachable = false;\n         for bcx in in_cxs.iter() {\n             if !bcx.unreachable.get() {\n-                build::Br(*bcx, out.llbb);\n+                build::Br(*bcx, out.llbb, DebugLoc::None);\n                 reachable = true;\n             }\n         }\n@@ -848,7 +848,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+        let buf = CString::from_vec(format!(\"str{}\", gsym.usize()).into_bytes());\n         let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -873,7 +873,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         let lldata = C_bytes(cx, data);\n \n         let gsym = token::gensym(\"binary\");\n-        let name = format!(\"binary{}\", gsym.uint());\n+        let name = format!(\"binary{}\", gsym.usize());\n         let name = CString::from_vec(name.into_bytes());\n         let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n                                     name.as_ptr());"}, {"sha": "bea8a75997152ba8a4932f98a5b7864ceb100e83", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -22,6 +22,7 @@ use trans::common::*;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo;\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::meth;\n use trans::type_::Type;\n@@ -188,20 +189,22 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n+    let cond_source_loc = cond.debug_loc();\n+\n     let next_bcx;\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n             let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            &[then_bcx_out, else_bcx_out]);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb, cond_source_loc);\n         }\n \n         None => {\n             next_bcx = bcx.fcx.new_id_block(\"next-block\", if_id);\n-            Br(then_bcx_out, next_bcx.llbb);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb);\n+            Br(then_bcx_out, next_bcx.llbb, DebugLoc::None);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb, cond_source_loc);\n         }\n     }\n \n@@ -213,7 +216,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               loop_id: ast::NodeId,\n+                               loop_expr: &ast::Expr,\n                                cond: &ast::Expr,\n                                body: &ast::Block)\n                                -> Block<'blk, 'tcx> {\n@@ -231,33 +234,34 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     //    |           body_bcx_out --+\n     // next_bcx_in\n \n-    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_id);\n+    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_expr.id);\n     let cond_bcx_in = fcx.new_id_block(\"while_cond\", cond.id);\n     let body_bcx_in = fcx.new_id_block(\"while_body\", body.id);\n \n-    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, cond_bcx_in]);\n+    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, cond_bcx_in]);\n \n-    Br(bcx, cond_bcx_in.llbb);\n+    Br(bcx, cond_bcx_in.llbb, loop_expr.debug_loc());\n \n     // compile the block where we will handle loop cleanups\n-    let cleanup_llbb = fcx.normal_exit_block(loop_id, cleanup::EXIT_BREAK);\n+    let cleanup_llbb = fcx.normal_exit_block(loop_expr.id, cleanup::EXIT_BREAK);\n \n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n         expr::trans(cond_bcx_in, cond).to_llbool();\n-    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb);\n+\n+    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb, cond.debug_loc());\n \n     // loop body:\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, cond_bcx_in.llbb);\n+    Br(body_bcx_out, cond_bcx_in.llbb, DebugLoc::None);\n \n-    fcx.pop_loop_cleanup_scope(loop_id);\n+    fcx.pop_loop_cleanup_scope(loop_expr.id);\n     return next_bcx_in;\n }\n \n /// Translates a `for` loop.\n pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             loop_info: NodeInfo,\n+                             loop_info: NodeIdAndSpan,\n                              pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n@@ -292,7 +296,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n     bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n                                     [next_bcx_in, loopback_bcx_in]);\n-    Br(bcx, loopback_bcx_in.llbb);\n+    Br(bcx, loopback_bcx_in.llbb, DebugLoc::None);\n     let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n                                                  cleanup::EXIT_BREAK);\n \n@@ -347,7 +351,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                               None);\n     let i1_type = Type::i1(loopback_bcx_out.ccx());\n     let llcondition = Trunc(loopback_bcx_out, lldiscriminant, i1_type);\n-    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb);\n+    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb, DebugLoc::None);\n \n     // Now we're in the body. Unpack the `Option` value into the programmer-\n     // supplied pattern.\n@@ -377,15 +381,15 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         body_bcx_out.fcx\n                     .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n                                                         option_cleanup_scope);\n-    Br(body_bcx_out, loopback_bcx_in.llbb);\n+    Br(body_bcx_out, loopback_bcx_in.llbb, DebugLoc::None);\n \n     // Codegen cleanups and leave.\n     next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n     next_bcx_in\n }\n \n pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              loop_id: ast::NodeId,\n+                              loop_expr: &ast::Expr,\n                               body: &ast::Block)\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_loop\");\n@@ -402,22 +406,22 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Links between body_bcx_in and next_bcx are created by\n     // break statements.\n \n-    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_id);\n+    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_expr.id);\n     let body_bcx_in = bcx.fcx.new_id_block(\"loop_body\", body.id);\n \n-    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, body_bcx_in]);\n+    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, body_bcx_in]);\n \n-    Br(bcx, body_bcx_in.llbb);\n+    Br(bcx, body_bcx_in.llbb, loop_expr.debug_loc());\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, body_bcx_in.llbb);\n+    Br(body_bcx_out, body_bcx_in.llbb, DebugLoc::None);\n \n-    fcx.pop_loop_cleanup_scope(loop_id);\n+    fcx.pop_loop_cleanup_scope(loop_expr.id);\n \n     return next_bcx_in;\n }\n \n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    expr_id: ast::NodeId,\n+                                    expr: &ast::Expr,\n                                     opt_label: Option<Ident>,\n                                     exit: uint)\n                                     -> Block<'blk, 'tcx> {\n@@ -432,7 +436,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr_id) {\n+            match bcx.tcx().def_map.borrow().get(&expr.id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n@@ -444,39 +448,40 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Generate appropriate cleanup code and branch\n     let cleanup_llbb = fcx.normal_exit_block(loop_id, exit);\n-    Br(bcx, cleanup_llbb);\n+    Br(bcx, cleanup_llbb, expr.debug_loc());\n     Unreachable(bcx); // anything afterwards should be ignored\n     return bcx;\n }\n \n pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr_id: ast::NodeId,\n+                               expr: &ast::Expr,\n                                label_opt: Option<Ident>)\n                                -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_BREAK);\n+    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_BREAK);\n }\n \n pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr_id: ast::NodeId,\n+                              expr: &ast::Expr,\n                               label_opt: Option<Ident>)\n                               -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_LOOP);\n+    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_LOOP);\n }\n \n pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             e: Option<&ast::Expr>)\n+                             return_expr: &ast::Expr,\n+                             retval_expr: Option<&ast::Expr>)\n                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match (fcx.llretslotptr.get(), e) {\n-        (Some(_), Some(e)) => {\n-            let ret_ty = expr_ty(bcx, &*e);\n+    let dest = match (fcx.llretslotptr.get(), retval_expr) {\n+        (Some(_), Some(retval_expr)) => {\n+            let ret_ty = expr_ty(bcx, &*retval_expr);\n             expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };\n-    if let Some(x) = e {\n+    if let Some(x) = retval_expr {\n         bcx = expr::trans_into(bcx, &*x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n@@ -486,7 +491,7 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n     let cleanup_llbb = fcx.return_exit_block();\n-    Br(bcx, cleanup_llbb);\n+    Br(bcx, cleanup_llbb, return_expr.debug_loc());\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "cba12babb9b105aa674f179c3f139f7528f3673d", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -481,7 +481,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n }\n \n /// Generic methods applicable to any sort of datum.\n-impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n+impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     pub fn new(val: ValueRef, ty: Ty<'tcx>, kind: K) -> Datum<'tcx, K> {\n         Datum { val: val, ty: ty, kind: kind }\n     }\n@@ -591,7 +591,7 @@ impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n     }\n }\n \n-impl<'blk, 'tcx, K: KindOps + fmt::Show> DatumBlock<'blk, 'tcx, K> {\n+impl<'blk, 'tcx, K: KindOps + fmt::Debug> DatumBlock<'blk, 'tcx, K> {\n     pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n         DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }"}, {"sha": "39413d63482499bc828e13b751c6409ce73a2c0e", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 78, "deletions": 53, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -188,15 +188,16 @@ use self::MemberOffset::*;\n use self::MemberDescriptionFactory::*;\n use self::RecursiveTypeDescription::*;\n use self::EnumDiscriminantInfo::*;\n-use self::DebugLocation::*;\n+use self::InternalDebugLocation::*;\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n-use trans::common::*;\n+use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n+                    C_bytes, C_i32, C_i64, NormalizingUnboxedClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -551,28 +552,14 @@ impl<'tcx> TypeMap<'tcx> {\n                                               closure_ty: ty::ClosureTy<'tcx>,\n                                               unique_type_id: &mut String) {\n         let ty::ClosureTy { unsafety,\n-                            onceness,\n-                            store,\n-                            ref bounds,\n                             ref sig,\n                             abi: _ } = closure_ty;\n+\n         if unsafety == ast::Unsafety::Unsafe {\n             unique_type_id.push_str(\"unsafe \");\n         }\n \n-        if onceness == ast::Once {\n-            unique_type_id.push_str(\"once \");\n-        }\n-\n-        match store {\n-            ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n-            ty::RegionTraitStore(_, ast::MutMutable) => {\n-                unique_type_id.push_str(\"&mut|\")\n-            }\n-            ty::RegionTraitStore(_, ast::MutImmutable) => {\n-                unique_type_id.push_str(\"&|\")\n-            }\n-        };\n+        unique_type_id.push_str(\"|\");\n \n         let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n \n@@ -601,18 +588,6 @@ impl<'tcx> TypeMap<'tcx> {\n                 unique_type_id.push_str(\"!\");\n             }\n         }\n-\n-        unique_type_id.push(':');\n-\n-        for bound in bounds.builtin_bounds.iter() {\n-            match bound {\n-                ty::BoundSend => unique_type_id.push_str(\"Send\"),\n-                ty::BoundSized => unique_type_id.push_str(\"Sized\"),\n-                ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n-                ty::BoundSync => unique_type_id.push_str(\"Sync\"),\n-            };\n-            unique_type_id.push('+');\n-        }\n     }\n \n     // Get the UniqueTypeId for an enum variant. Enum variants are not really\n@@ -650,7 +625,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n-    current_debug_location: Cell<DebugLocation>,\n+    current_debug_location: Cell<InternalDebugLocation>,\n     created_files: RefCell<FnvHashMap<String, DIFile>>,\n     created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n \n@@ -940,13 +915,14 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let variable_type = node_id_type(bcx, node_id);\n+    let variable_type = common::node_id_type(bcx, node_id);\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n \n     // env_pointer is the alloca containing the pointer to the environment,\n     // so it's type is **EnvironmentType. In order to find out the type of\n     // the environment we have to \"dereference\" two times.\n-    let llvm_env_data_type = val_ty(env_pointer).element_type().element_type();\n+    let llvm_env_data_type = common::val_ty(env_pointer).element_type()\n+                                                        .element_type();\n     let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n                                                               llvm_env_data_type,\n                                                               env_index);\n@@ -1123,7 +1099,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n                                                     is_block: bool)\n-                                                 -> NodeInfo {\n+                                                 -> NodeIdAndSpan {\n     // A debug location needs two things:\n     // (1) A span (of which only the beginning will actually be used)\n     // (2) An AST node-id which will be used to look up the lexical scope\n@@ -1163,7 +1139,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Some(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && &bytes[(bytes.len()-1)..] == b\"}\" {\n+            if bytes.len() > 0 && &bytes[bytes.len()-1..] == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -1173,12 +1149,56 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    NodeInfo {\n+    NodeIdAndSpan {\n         id: node_id,\n         span: cleanup_span\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n+}\n+\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                clear_source_location(fcx);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n+\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n+        }\n+    }\n+}\n+\n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n@@ -1202,9 +1222,9 @@ pub fn set_source_location(fcx: &FunctionContext,\n                 let loc = span_start(cx, span);\n                 let scope = scope_metadata(fcx, node_id, span);\n \n-                set_debug_location(cx, DebugLocation::new(scope,\n-                                                          loc.line,\n-                                                          loc.col.to_uint()));\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_usize()));\n             } else {\n                 set_debug_location(cx, UnknownLocation);\n             }\n@@ -1615,8 +1635,8 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                         let prefix: &[u8] = &[dotdot[0], ::std::path::SEP_BYTE];\n                         let mut path_bytes = p.as_vec().to_vec();\n \n-                        if path_bytes.slice_to(2) != prefix &&\n-                           path_bytes.slice_to(2) != dotdot {\n+                        if &path_bytes[..2] != prefix &&\n+                           &path_bytes[..2] != dotdot {\n                             path_bytes.insert(0, prefix[0]);\n                             path_bytes.insert(1, prefix[1]);\n                         }\n@@ -1714,9 +1734,9 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         )\n     };\n \n-    set_debug_location(cx, DebugLocation::new(scope_metadata,\n-                                              loc.line,\n-                                              loc.col.to_uint()));\n+    set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                      loc.line,\n+                                                      loc.col.to_usize()));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -1752,7 +1772,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            &full_path[(work_dir.len() + 1u)..full_path.len()]\n+            &full_path[work_dir.len() + 1u..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -2068,7 +2088,13 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n-    let fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+    let mut fields = ty::struct_fields(cx.tcx(), def_id, substs);\n+\n+    // The `Ty` values returned by `ty::struct_fields` can still contain\n+    // `ty_projection` variants, so normalize those away.\n+    for field in fields.iter_mut() {\n+        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n+    }\n \n     create_and_register_recursive_type_forward_declaration(\n         cx,\n@@ -3095,13 +3121,13 @@ impl MetadataCreationResult {\n }\n \n #[derive(Copy, PartialEq)]\n-enum DebugLocation {\n+enum InternalDebugLocation {\n     KnownLocation { scope: DIScope, line: uint, col: uint },\n     UnknownLocation\n }\n \n-impl DebugLocation {\n-    fn new(scope: DIScope, line: uint, col: uint) -> DebugLocation {\n+impl InternalDebugLocation {\n+    fn new(scope: DIScope, line: uint, col: uint) -> InternalDebugLocation {\n         KnownLocation {\n             scope: scope,\n             line: line,\n@@ -3110,7 +3136,7 @@ impl DebugLocation {\n     }\n }\n \n-fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n+fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n     if debug_location == debug_context(cx).current_debug_location.get() {\n         return;\n     }\n@@ -3279,7 +3305,7 @@ fn create_scope_map(cx: &CrateContext,\n                 parent_scope,\n                 file_metadata,\n                 loc.line as c_uint,\n-                loc.col.to_uint() as c_uint)\n+                loc.col.to_usize() as c_uint)\n         };\n \n         scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata,\n@@ -3401,7 +3427,7 @@ fn create_scope_map(cx: &CrateContext,\n                                 parent_scope,\n                                 file_metadata,\n                                 loc.line as c_uint,\n-                                loc.col.to_uint() as c_uint)\n+                                loc.col.to_usize() as c_uint)\n                         };\n \n                         scope_stack.push(ScopeStackEntry {\n@@ -4122,4 +4148,3 @@ fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     !ccx.sess().target.target.options.is_like_windows &&\n     ccx.sess().opts.debuginfo != NoDebugInfo\n }\n-"}, {"sha": "4ebaf91d111737bf06a2e43cc896040b3bf9d56f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -46,7 +46,7 @@ use trans::build::*;\n use trans::cleanup::{self, CleanupMethods};\n use trans::common::*;\n use trans::datum::*;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::glue;\n use trans::machine;\n use trans::meth;\n@@ -65,7 +65,6 @@ use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n use syntax::{ast, ast_util, codemap};\n-use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::rc::Rc;\n@@ -779,7 +778,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n-                                None);\n+                                None,\n+                                index_expr.debug_loc());\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n                                                      index_expr.span,\n@@ -890,10 +890,10 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_into(bcx, &**e, Ignore)\n         }\n         ast::ExprBreak(label_opt) => {\n-            controlflow::trans_break(bcx, expr.id, label_opt)\n+            controlflow::trans_break(bcx, expr, label_opt)\n         }\n         ast::ExprAgain(label_opt) => {\n-            controlflow::trans_cont(bcx, expr.id, label_opt)\n+            controlflow::trans_cont(bcx, expr, label_opt)\n         }\n         ast::ExprRet(ref ex) => {\n             // Check to see if the return expression itself is reachable.\n@@ -905,7 +905,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             if reachable {\n-                controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+                controlflow::trans_ret(bcx, expr, ex.as_ref().map(|e| &**e))\n             } else {\n                 // If it's not reachable, just translate the inner expression\n                 // directly. This avoids having to manage a return slot when\n@@ -921,7 +921,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n-            controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n+            controlflow::trans_while(bcx, expr, &**cond, &**body)\n         }\n         ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n             controlflow::trans_for(bcx,\n@@ -931,7 +931,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    &**body)\n         }\n         ast::ExprLoop(ref body, _) => {\n-            controlflow::trans_loop(bcx, expr.id, &**body)\n+            controlflow::trans_loop(bcx, expr, &**body)\n         }\n         ast::ExprAssign(ref dst, ref src) => {\n             let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n@@ -960,7 +960,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = glue::drop_ty(bcx,\n                                     dst_datum.val,\n                                     dst_datum.ty,\n-                                    Some(NodeInfo { id: expr.id, span: expr.span }));\n+                                    expr.debug_loc());\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n                 src_datum.store_to(bcx, dst_datum.val)\n@@ -1078,7 +1078,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                       &numbered_fields[],\n                       None,\n                       dest,\n-                      Some(NodeInfo { id: expr.id, span: expr.span }))\n+                      expr.debug_loc())\n         }\n         ast::ExprLit(ref lit) => {\n             match lit.node {\n@@ -1102,17 +1102,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // closure or an older, legacy style closure. Store this\n             // into a variable to ensure the the RefCell-lock is\n             // released before we recurse.\n-            let is_unboxed_closure =\n-                bcx.tcx().unboxed_closures.borrow().contains_key(&ast_util::local_def(expr.id));\n-            if is_unboxed_closure {\n-                closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n-            } else {\n-                let expr_ty = expr_ty(bcx, expr);\n-                let store = ty::ty_closure_store(expr_ty);\n-                debug!(\"translating block function {} with type {}\",\n-                       expr_to_string(expr), expr_ty.repr(tcx));\n-                closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n-            }\n+            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n@@ -1417,7 +1407,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   numbered_fields.as_slice(),\n                   optbase,\n                   dest,\n-                  Some(NodeInfo { id: expr_id, span: expr_span }))\n+                  DebugLoc::At(expr_id, expr_span))\n     })\n }\n \n@@ -1448,18 +1438,13 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  fields: &[(uint, &ast::Expr)],\n                                  optbase: Option<StructBaseInfo<'a, 'tcx>>,\n                                  dest: Dest,\n-                                 source_location: Option<NodeInfo>)\n+                                 debug_location: DebugLoc)\n                                  -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n \n-    match source_location {\n-        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n-                                                        src_loc.id,\n-                                                        src_loc.span),\n-        None => {}\n-    };\n+    debug_location.apply(bcx.fcx);\n \n     // If we don't care about the result, just make a\n     // temporary stack slot\n@@ -1494,12 +1479,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    match source_location {\n-        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n-                                                        src_loc.id,\n-                                                        src_loc.span),\n-        None => {}\n-    };\n+    debug_location.apply(bcx.fcx);\n \n     if ty::type_is_simd(bcx.tcx(), ty) {\n         // This is the constructor of a SIMD type, such types are\n@@ -1540,7 +1520,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match dest {\n         SaveIn(_) => bcx,\n         Ignore => {\n-            bcx = glue::drop_ty(bcx, addr, ty, source_location);\n+            bcx = glue::drop_ty(bcx, addr, ty, debug_location);\n             base::call_lifetime_end(bcx, addr);\n             bcx\n         }\n@@ -1579,20 +1559,22 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let un_ty = expr_ty(bcx, expr);\n \n+    let debug_loc = expr.debug_loc();\n+\n     match op {\n         ast::UnNot => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            let llresult = Not(bcx, datum.to_llscalarish(bcx));\n+            let llresult = Not(bcx, datum.to_llscalarish(bcx), debug_loc);\n             immediate_rvalue_bcx(bcx, llresult, un_ty).to_expr_datumblock()\n         }\n         ast::UnNeg => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let val = datum.to_llscalarish(bcx);\n             let llneg = {\n                 if ty::type_is_fp(un_ty) {\n-                    FNeg(bcx, val)\n+                    FNeg(bcx, val, debug_loc)\n                 } else {\n-                    Neg(bcx, val)\n+                    Neg(bcx, val, debug_loc)\n                 }\n             };\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n@@ -1691,56 +1673,69 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n \n+    let binop_debug_loc = binop_expr.debug_loc();\n+\n     let mut bcx = bcx;\n     let val = match op {\n       ast::BiAdd => {\n-        if is_float { FAdd(bcx, lhs, rhs) }\n-        else { Add(bcx, lhs, rhs) }\n+        if is_float {\n+            FAdd(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Add(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiSub => {\n-        if is_float { FSub(bcx, lhs, rhs) }\n-        else { Sub(bcx, lhs, rhs) }\n+        if is_float {\n+            FSub(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Sub(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiMul => {\n-        if is_float { FMul(bcx, lhs, rhs) }\n-        else { Mul(bcx, lhs, rhs) }\n+        if is_float {\n+            FMul(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Mul(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiDiv => {\n         if is_float {\n-            FDiv(bcx, lhs, rhs)\n+            FDiv(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp /0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n-                SDiv(bcx, lhs, rhs)\n+                SDiv(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n-                UDiv(bcx, lhs, rhs)\n+                UDiv(bcx, lhs, rhs, binop_debug_loc)\n             }\n         }\n       }\n       ast::BiRem => {\n         if is_float {\n-            FRem(bcx, lhs, rhs)\n+            FRem(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n-                SRem(bcx, lhs, rhs)\n+                SRem(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n-                URem(bcx, lhs, rhs)\n+                URem(bcx, lhs, rhs, binop_debug_loc)\n             }\n         }\n       }\n-      ast::BiBitOr => Or(bcx, lhs, rhs),\n-      ast::BiBitAnd => And(bcx, lhs, rhs),\n-      ast::BiBitXor => Xor(bcx, lhs, rhs),\n-      ast::BiShl => Shl(bcx, lhs, rhs),\n+      ast::BiBitOr => Or(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiBitAnd => And(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiBitXor => Xor(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiShl => Shl(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiShr => {\n         if is_signed {\n-            AShr(bcx, lhs, rhs)\n-        } else { LShr(bcx, lhs, rhs) }\n+            AShr(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            LShr(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n@@ -1786,8 +1781,8 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n \n     match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb, DebugLoc::None),\n+      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb, DebugLoc::None)\n     }\n \n     let DatumBlock {bcx: past_rhs, datum: rhs} = trans(before_rhs, b);\n@@ -1797,7 +1792,7 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return immediate_rvalue_bcx(join, lhs, binop_ty).to_expr_datumblock();\n     }\n \n-    Br(past_rhs, join.llbb);\n+    Br(past_rhs, join.llbb, DebugLoc::None);\n     let phi = Phi(join, Type::i1(bcx.ccx()), &[lhs, rhs],\n                   &[past_lhs.llbb, past_rhs.llbb]);\n "}, {"sha": "fb2ee55940d0956d94c2423705243b9d33959682", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -29,7 +29,7 @@ use trans::cleanup::CleanupMethods;\n use trans::consts;\n use trans::common::*;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::machine::*;\n use trans::tvec;\n@@ -106,7 +106,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n-                           source_location: Option<NodeInfo>)\n+                           debug_loc: DebugLoc)\n                            -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n@@ -121,25 +121,20 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             v\n         };\n \n-        match source_location {\n-            Some(sl) => debuginfo::set_source_location(bcx.fcx, sl.id, sl.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n-        Call(bcx, glue, &[ptr], None);\n+        Call(bcx, glue, &[ptr], None, debug_loc);\n     }\n     bcx\n }\n \n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n                                      t: Ty<'tcx>,\n-                                     source_location: Option<NodeInfo>)\n+                                     debug_loc: DebugLoc)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty(bcx, vp, t, source_location)\n+    drop_ty(bcx, vp, t, debug_loc)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n@@ -295,7 +290,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, DebugLoc::None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -331,7 +326,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // Return the sum of sizes and max of aligns.\n-            let size = Add(bcx, sized_size, unsized_size);\n+            let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n             let align = Select(bcx,\n                                ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n                                sized_align,\n@@ -353,7 +348,8 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), unit_align))\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n+             C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n                                     bcx.ty_to_string(t))[])\n@@ -384,7 +380,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         Call(bcx,\n                              dtor,\n                              &[PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n-                             None);\n+                             None,\n+                             DebugLoc::None);\n                         bcx\n                     })\n                 }\n@@ -393,7 +390,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, v0, content_ty, None);\n+                        let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                         let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n@@ -406,7 +403,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, llbox, content_ty, None);\n+                        let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n                         trans_exchange_free_ty(bcx, llbox, content_ty)\n                     })\n                 }\n@@ -437,14 +434,16 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n                 ty::NoDtor => {\n                     // No dtor? Just the default case\n-                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n+                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n                 }\n             }\n         }\n-        ty::ty_unboxed_closure(..) => iter_structural_ty(bcx,\n-                                                         v0,\n-                                                         t,\n-                                                         |bb, vv, tt| drop_ty(bb, vv, tt, None)),\n+        ty::ty_unboxed_closure(..) => {\n+            iter_structural_ty(bcx,\n+                               v0,\n+                               t,\n+                               |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n+        }\n         ty::ty_trait(..) => {\n             // No need to do a null check here (as opposed to the Box<trait case\n             // above), because this happens for a trait field in an unsized\n@@ -456,7 +455,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n             Call(bcx,\n                  dtor,\n                  &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n-                 None);\n+                 None,\n+                 DebugLoc::None);\n             bcx\n         },\n         ty::ty_vec(_, None) | ty::ty_str => {\n@@ -465,9 +465,11 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         },\n         _ => {\n             assert!(type_is_sized(bcx.tcx(), t));\n-            if type_needs_drop(bcx.tcx(), t) &&\n-                ty::type_is_structural(t) {\n-                iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n+            if type_needs_drop(bcx.tcx(), t) && ty::type_is_structural(t) {\n+                iter_structural_ty(bcx,\n+                                   v0,\n+                                   t,\n+                                   |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n             } else {\n                 bcx\n             }\n@@ -559,7 +561,7 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n     llfn\n }"}, {"sha": "9bee2c5bbc61c69ecd3410f4c0297d645cf3e4ba", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 279, "deletions": 93, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::glue;\n use trans::type_of::*;\n@@ -149,9 +150,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n                                             substs: subst::Substs<'tcx>,\n-                                            call_info: NodeInfo)\n-                                            -> Result<'blk, 'tcx>\n-{\n+                                            call_info: NodeIdAndSpan)\n+                                            -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n@@ -270,10 +270,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     fcx.pop_custom_cleanup_scope(cleanup_scope);\n \n+    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+\n     // These are the only intrinsic functions that diverge.\n     if name.get() == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        Call(bcx, llfn, &[], None);\n+        Call(bcx, llfn, &[], None, call_debug_location);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n     } else if name.get() == \"unreachable\" {\n@@ -304,11 +306,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n     let llval = match (simple, name.get()) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, llargs.as_slice(), None)\n+            Call(bcx, llfn, llargs.as_slice(), None, call_debug_location)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, &[], None)\n+            Call(bcx, llfn, &[], None, call_debug_location)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -384,29 +386,63 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n \n         (_, \"copy_nonoverlapping_memory\") => {\n-            copy_intrinsic(bcx, false, false, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           false,\n+                           false,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"copy_memory\") => {\n-            copy_intrinsic(bcx, true, false, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           true,\n+                           false,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"set_memory\") => {\n-            memset_intrinsic(bcx, false, *substs.types.get(FnSpace, 0),\n-                             llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx,\n+                             false,\n+                             *substs.types.get(FnSpace, 0),\n+                             llargs[0],\n+                             llargs[1],\n+                             llargs[2],\n+                             call_debug_location)\n         }\n \n         (_, \"volatile_copy_nonoverlapping_memory\") => {\n-            copy_intrinsic(bcx, false, true, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           false,\n+                           true,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"volatile_copy_memory\") => {\n-            copy_intrinsic(bcx, true, true, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           true,\n+                           true,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"volatile_set_memory\") => {\n-            memset_intrinsic(bcx, true, *substs.types.get(FnSpace, 0),\n-                             llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx,\n+                             true,\n+                             *substs.types.get(FnSpace, 0),\n+                             llargs[0],\n+                             llargs[1],\n+                             llargs[2],\n+                             call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n             VolatileLoad(bcx, llargs[0])\n@@ -416,93 +452,208 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         },\n \n-        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", llargs[0]),\n-        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", llargs[0]),\n-        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", llargs[0]),\n-        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", llargs[0]),\n-        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", llargs[0]),\n-        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", llargs[0]),\n-        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", llargs[0]),\n-        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", llargs[0]),\n+        (_, \"ctlz8\") => count_zeros_intrinsic(bcx,\n+                                              \"llvm.ctlz.i8\",\n+                                              llargs[0],\n+                                              call_debug_location),\n+        (_, \"ctlz16\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i16\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"ctlz32\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i32\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"ctlz64\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i64\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz8\") => count_zeros_intrinsic(bcx,\n+                                              \"llvm.cttz.i8\",\n+                                              llargs[0],\n+                                              call_debug_location),\n+        (_, \"cttz16\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i16\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz32\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i32\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz64\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i64\",\n+                                               llargs[0],\n+                                               call_debug_location),\n \n         (_, \"i8_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n \n         (_, \"u8_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i8_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u8_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i8_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u8_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i8\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i16\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i32\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i64\", ret_ty,\n-                                    llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n                 tcx.sess.span_err(call_info.span,\n@@ -609,7 +760,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // If we made a temporary stack slot, let's clean it up\n     match dest {\n         expr::Ignore => {\n-            bcx = glue::drop_ty(bcx, llresult, ret_ty, Some(call_info));\n+            bcx = glue::drop_ty(bcx, llresult, ret_ty, call_debug_location);\n         }\n         expr::SaveIn(_) => {}\n     }\n@@ -618,8 +769,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              allow_overlap: bool, volatile: bool, tp_ty: Ty<'tcx>,\n-                              dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n+                              allow_overlap: bool,\n+                              volatile: bool,\n+                              tp_ty: Ty<'tcx>,\n+                              dst: ValueRef,\n+                              src: ValueRef,\n+                              count: ValueRef,\n+                              call_debug_location: DebugLoc)\n+                              -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -643,12 +800,25 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let src_ptr = PointerCast(bcx, src, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, &[dst_ptr, src_ptr, Mul(bcx, size, count), align,\n-                      C_bool(ccx, volatile)], None)\n+    Call(bcx,\n+         llfn,\n+         &[dst_ptr,\n+           src_ptr,\n+           Mul(bcx, size, count, DebugLoc::None),\n+           align,\n+           C_bool(ccx, volatile)],\n+         None,\n+         call_debug_location)\n }\n \n-fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: Ty<'tcx>,\n-                                dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n+fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                volatile: bool,\n+                                tp_ty: Ty<'tcx>,\n+                                dst: ValueRef,\n+                                val: ValueRef,\n+                                count: ValueRef,\n+                                call_debug_location: DebugLoc)\n+                                -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -662,22 +832,38 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: T\n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, &[dst_ptr, val, Mul(bcx, size, count), align,\n-                      C_bool(ccx, volatile)], None)\n+    Call(bcx,\n+         llfn,\n+         &[dst_ptr,\n+           val,\n+           Mul(bcx, size, count, DebugLoc::None),\n+           align,\n+           C_bool(ccx, volatile)],\n+         None,\n+         call_debug_location)\n }\n \n-fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> ValueRef {\n+fn count_zeros_intrinsic(bcx: Block,\n+                         name: &'static str,\n+                         val: ValueRef,\n+                         call_debug_location: DebugLoc)\n+                         -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, &[val, y], None)\n+    Call(bcx, llfn, &[val, y], None, call_debug_location)\n }\n \n-fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, name: &'static str,\n-                                       t: Ty<'tcx>, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       name: &'static str,\n+                                       t: Ty<'tcx>,\n+                                       a: ValueRef,\n+                                       b: ValueRef,\n+                                       call_debug_location: DebugLoc)\n+                                       -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, &[a, b], None);\n+    let val = Call(bcx, llfn, &[a, b], None, call_debug_location);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));"}, {"sha": "c2f19670e4f1558234e15fa575fb7174cd0eabfd", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -24,6 +24,7 @@ use trans::callee;\n use trans::cleanup;\n use trans::common::*;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr::{SaveIn, Ignore};\n use trans::expr;\n use trans::glue;\n@@ -494,7 +495,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n             let fake_sig =\n                 ty::Binder(ty::FnSig {\n-                    inputs: f.sig.0.inputs.slice_from(1).to_vec(),\n+                    inputs: f.sig.0.inputs[1..].to_vec(),\n                     output: f.sig.0.output,\n                     variadic: f.sig.0.variadic,\n                 });\n@@ -634,7 +635,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             }\n             _ => {\n                 // skip the self parameter:\n-                sig.inputs.slice_from(1)\n+                &sig.inputs[1..]\n             }\n         };\n \n@@ -676,7 +677,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                            ArgVals(llargs.as_slice()),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output);\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n     (llfn, method_bare_fn_ty)\n }\n@@ -785,7 +786,7 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     unsafe {\n         let tbl = C_struct(ccx, &components[], false);\n         let sym = token::gensym(\"vtable\");\n-        let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n+        let buf = CString::from_vec(format!(\"vtable{}\", sym.usize()).into_bytes());\n         let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),\n                                           buf.as_ptr());\n         llvm::LLVMSetInitializer(vt_gvar, tbl);"}, {"sha": "93076260349abd5c81aee5d5801823a800ec4a2d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -274,7 +274,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n-        ast_map::NodeViewItem(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n                                    map_node)[])"}, {"sha": "06bc19f45a47e6bbd305ebc5cae8f10f6903d37a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n use trans::glue;\n@@ -58,7 +59,11 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let dataptr = get_dataptr(bcx, vptr);\n         let bcx = if type_needs_drop(tcx, unit_ty) {\n             let len = get_len(bcx, vptr);\n-            iter_vec_raw(bcx, dataptr, unit_ty, len, |bb, vv, tt| glue::drop_ty(bb, vv, tt, None))\n+            iter_vec_raw(bcx,\n+                         dataptr,\n+                         unit_ty,\n+                         len,\n+                         |bb, vv, tt| glue::drop_ty(bb, vv, tt, DebugLoc::None))\n         } else {\n             bcx\n         };\n@@ -71,7 +76,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0u));\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n-                    let size = Mul(bcx, C_uint(ccx, unit_size), len);\n+                    let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n                     glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n                 })\n             } else {\n@@ -420,14 +425,14 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let cond_bcx = fcx.new_temp_block(\"expr_repeat: loop cond\");\n     let body_bcx = fcx.new_temp_block(\"expr_repeat: body: set\");\n     let inc_bcx = fcx.new_temp_block(\"expr_repeat: body: inc\");\n-    Br(bcx, loop_bcx.llbb);\n+    Br(bcx, loop_bcx.llbb, DebugLoc::None);\n \n     let loop_counter = {\n         // i = 0\n         let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n         Store(loop_bcx, C_uint(bcx.ccx(), 0u), i);\n \n-        Br(loop_bcx, cond_bcx.llbb);\n+        Br(loop_bcx, cond_bcx.llbb, DebugLoc::None);\n         i\n     };\n \n@@ -436,7 +441,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let rhs = count;\n         let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs);\n \n-        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb);\n+        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n     }\n \n     { // loop body\n@@ -448,15 +453,15 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         };\n         let body_bcx = f(body_bcx, lleltptr, vt.unit_ty);\n \n-        Br(body_bcx, inc_bcx.llbb);\n+        Br(body_bcx, inc_bcx.llbb, DebugLoc::None);\n     }\n \n     { // i += 1\n         let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u));\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u), DebugLoc::None);\n         Store(inc_bcx, plusone, loop_counter);\n \n-        Br(inc_bcx, cond_bcx.llbb);\n+        Br(inc_bcx, cond_bcx.llbb, DebugLoc::None);\n     }\n \n     next_bcx\n@@ -484,19 +489,19 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         // Now perform the iteration.\n         let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");\n-        Br(bcx, header_bcx.llbb);\n+        Br(bcx, header_bcx.llbb, DebugLoc::None);\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n         let not_yet_at_end =\n             ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n-        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n+        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                                &[C_int(bcx.ccx(), 1i)]),\n                          body_bcx.llbb);\n-        Br(body_bcx, header_bcx.llbb);\n+        Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n         next_bcx\n     }\n }"}, {"sha": "9640443f4f7a642265898dd1e40fe630c2993a30", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -21,6 +21,7 @@ use syntax::ast;\n \n use std::ffi::CString;\n use std::mem;\n+use std::ptr;\n use std::cell::RefCell;\n use std::iter::repeat;\n \n@@ -227,14 +228,6 @@ impl Type {\n         Type::vec(ccx, &Type::i8(ccx))\n     }\n \n-    // The box pointed to by @T.\n-    pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n-        Type::struct_(ccx, &[\n-            ccx.int_type(), Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n-            Type::i8p(ccx), Type::i8p(ccx), ty\n-        ], false)\n-    }\n-\n     pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n         Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n     }\n@@ -303,7 +296,7 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_elts).collect();\n+            let mut elts: Vec<_> = repeat(Type { rf: ptr::null_mut() }).take(n_elts).collect();\n             llvm::LLVMGetStructElementTypes(self.to_ref(),\n                                             elts.as_mut_ptr() as *mut TypeRef);\n             elts\n@@ -317,7 +310,7 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let mut args: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_args).collect();\n+            let mut args: Vec<_> = repeat(Type { rf: ptr::null_mut() }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args"}, {"sha": "921ed505fa3af3517fadc1d4ba1818a23748c865", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 64, "deletions": 84, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -100,8 +100,7 @@ pub trait AstConv<'tcx> {\n                                         -> Ty<'tcx>\n     {\n         if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n-            self.tcx().sess.span_err(\n-                span,\n+            span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n             self.tcx().types.err\n@@ -119,8 +118,7 @@ pub trait AstConv<'tcx> {\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        self.tcx().sess.span_err(\n-            span,\n+        span_err!(self.tcx().sess, span, E0213,\n             \"associated types are not accepted in this context\");\n \n         self.tcx().types.err\n@@ -268,8 +266,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            tcx.sess.span_err(\n-                path.span,\n+            span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n             (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n@@ -342,22 +339,22 @@ fn create_substs_for_ast_path<'tcx>(\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(span,\n-                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n+        span_fatal!(this.tcx().sess, span, E0243,\n+                                   \"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(span,\n-                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n+        span_fatal!(this.tcx().sess, span, E0244,\n+                                   \"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count);\n     }\n \n     let mut substs = Substs::new_type(types, regions);\n@@ -560,10 +557,9 @@ pub fn instantiate_trait_ref<'tcx>(\n             trait_ref\n         }\n         _ => {\n-            this.tcx().sess.span_fatal(\n-                ast_trait_ref.path.span,\n-                &format!(\"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx()))[]);\n+            span_fatal!(this.tcx().sess, ast_trait_ref.path.span, E0245,\n+                \"`{}` is not a trait\",\n+                        ast_trait_ref.path.user_string(this.tcx()));\n         }\n     }\n }\n@@ -610,7 +606,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_some()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -626,7 +622,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_none()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -738,32 +734,29 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     }\n \n     if candidates.len() > 1 {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n+        span_err!(tcx.sess, binding.span, E0217,\n+            \"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidates.user_string(tcx)).as_slice());\n+                    candidates.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n     let candidate = match candidates.pop() {\n         Some(c) => c,\n         None => {\n-            tcx.sess.span_err(\n-                binding.span,\n-                format!(\"no associated type `{}` defined in `{}`\",\n+            span_err!(tcx.sess, binding.span, E0218,\n+                \"no associated type `{}` defined in `{}`\",\n                         token::get_name(binding.item_name),\n-                        trait_ref.user_string(tcx)).as_slice());\n+                        trait_ref.user_string(tcx));\n             return Err(ErrorReported);\n         }\n     };\n \n     if ty::binds_late_bound_regions(tcx, &candidate) {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"associated type `{}` defined in higher-ranked supertrait `{}`\",\n+        span_err!(tcx.sess, binding.span, E0219,\n+            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidate.user_string(tcx)).as_slice());\n+                    candidate.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n@@ -893,14 +886,14 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                       pprust::ty_to_string(ty));\n             match ty.node {\n                 ast::TyRptr(None, ref mut_ty) => {\n-                    span_note!(this.tcx().sess, ty.span,\n+                    span_help!(this.tcx().sess, ty.span,\n                                \"perhaps you meant `&{}({} +{})`? (per RFC 438)\",\n                                ppaux::mutability_to_string(mut_ty.mutbl),\n                                pprust::ty_to_string(&*mut_ty.ty),\n                                pprust::bounds_to_string(bounds));\n                 }\n                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n-                    span_note!(this.tcx().sess, ty.span,\n+                    span_help!(this.tcx().sess, ty.span,\n                                \"perhaps you meant `&{} {}({} +{})`? (per RFC 438)\",\n                                pprust::lifetime_to_string(lt),\n                                ppaux::mutability_to_string(mut_ty.mutbl),\n@@ -909,7 +902,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                 }\n \n                 _ => {\n-                    span_note!(this.tcx().sess, ty.span,\n+                    span_help!(this.tcx().sess, ty.span,\n                                \"perhaps you forgot parentheses? (per RFC 438)\");\n                 }\n             }\n@@ -964,18 +957,18 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n \n     if suitable_bounds.len() == 0 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"associated type `{}` not found for type parameter `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0220,\n+                          \"associated type `{}` not found for type parameter `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n         return this.tcx().types.err;\n     }\n \n     if suitable_bounds.len() > 1 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"ambiguous associated type `{}` in bounds of `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0221,\n+                          \"ambiguous associated type `{}` in bounds of `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n \n         for suitable_bound in suitable_bounds.iter() {\n             span_note!(this.tcx().sess, ast_ty.span,\n@@ -1042,7 +1035,7 @@ pub fn ast_ty_to_ty<'tcx>(\n     match ast_ty_to_ty_cache.get(&ast_ty.id) {\n         Some(&ty::atttce_resolved(ty)) => return ty,\n         Some(&ty::atttce_unresolved) => {\n-            tcx.sess.span_fatal(ast_ty.span,\n+            span_fatal!(tcx.sess, ast_ty.span, E0246,\n                                 \"illegal recursive type; insert an enum \\\n                                  or struct in the cycle, if this is \\\n                                  desired\");\n@@ -1093,7 +1086,7 @@ pub fn ast_ty_to_ty<'tcx>(\n             ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n             ast::TyBareFn(ref bf) => {\n                 if bf.decl.variadic && bf.abi != abi::C {\n-                    tcx.sess.span_err(ast_ty.span,\n+                    span_err!(tcx.sess, ast_ty.span, E0222,\n                                       \"variadic function must have C calling convention\");\n                 }\n                 let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n@@ -1142,18 +1135,18 @@ pub fn ast_ty_to_ty<'tcx>(\n                         ty::mk_self_type(tcx)\n                     }\n                     def::DefMod(id) => {\n-                        tcx.sess.span_fatal(ast_ty.span,\n-                            &format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node))[]);\n+                        span_fatal!(tcx.sess, ast_ty.span, E0247,\n+                            \"found module name used as a type: {}\",\n+                                    tcx.map.node_to_string(id.node));\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     def::DefAssociatedTy(trait_type_id) => {\n                         let path_str = tcx.map.path_to_string(\n                             tcx.map.get_parent(trait_type_id.node));\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          &format!(\"ambiguous associated \\\n+                        span_err!(tcx.sess, ast_ty.span, E0223,\n+                                          \"ambiguous associated \\\n                                                    type; specify the type \\\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n@@ -1163,17 +1156,17 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get())[]);\n+                                                  .get());\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n-                        tcx.sess.span_fatal(ast_ty.span,\n-                                            &format!(\"found value name used \\\n+                        span_fatal!(tcx.sess, ast_ty.span, E0248,\n+                                            \"found value name used \\\n                                                      as a type: {:?}\",\n-                                                    a_def)[]);\n+                                                    a_def);\n                     }\n                 }\n             }\n@@ -1191,17 +1184,16 @@ pub fn ast_ty_to_ty<'tcx>(\n                                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             _ => {\n-                                tcx.sess.span_fatal(\n-                                    ast_ty.span, \"expected constant expr for array length\");\n+                                span_fatal!(tcx.sess, ast_ty.span, E0249,\n+                                            \"expected constant expr for array length\");\n                             }\n                         }\n                     }\n                     Err(ref r) => {\n-                        tcx.sess.span_fatal(\n-                            ast_ty.span,\n-                            &format!(\"expected constant expr for array \\\n+                        span_fatal!(tcx.sess, ast_ty.span, E0250,\n+                            \"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r)[]);\n+                                    *r);\n                     }\n                 }\n             }\n@@ -1321,7 +1313,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n     let input_params = if self_ty.is_some() {\n-        decl.inputs.slice_from(1)\n+        &decl.inputs[1..]\n     } else {\n         &decl.inputs[]\n     };\n@@ -1339,9 +1331,9 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let lifetimes_for_params = if implied_output_region.is_none() {\n         let input_tys = if self_ty.is_some() {\n             // Skip the first argument if `self` is present.\n-            self_and_input_tys.slice_from(1)\n+            &self_and_input_tys[1..]\n         } else {\n-            self_and_input_tys.slice_from(0)\n+            &self_and_input_tys[]\n         };\n \n         let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n@@ -1457,9 +1449,6 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n pub fn ty_of_closure<'tcx>(\n     this: &AstConv<'tcx>,\n     unsafety: ast::Unsafety,\n-    onceness: ast::Onceness,\n-    bounds: ty::ExistentialBounds<'tcx>,\n-    store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n     expected_sig: Option<ty::FnSig<'tcx>>)\n@@ -1509,9 +1498,6 @@ pub fn ty_of_closure<'tcx>(\n \n     ty::ClosureTy {\n         unsafety: unsafety,\n-        onceness: onceness,\n-        store: store,\n-        bounds: bounds,\n         abi: abi,\n         sig: ty::Binder(ty::FnSig {inputs: input_tys,\n                                    output: output_ty,\n@@ -1557,8 +1543,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                         None,\n                                         &mut projection_bounds))\n     } else {\n-        this.tcx().sess.span_err(\n-            span,\n+        span_err!(this.tcx().sess, span, E0224,\n             \"at least one non-builtin trait is required for an object type\");\n         None\n     };\n@@ -1593,10 +1578,9 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n \n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n-        this.tcx().sess.span_err(\n-            b.trait_ref.path.span,\n-            &format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\")[]);\n+        span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n+            \"only the builtin traits can be used \\\n+                     as closure or object bounds\");\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1633,9 +1617,8 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n            builtin_bounds.repr(tcx));\n \n     if explicit_region_bounds.len() > 1 {\n-        tcx.sess.span_err(\n-            explicit_region_bounds[1].span,\n-            format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n+        span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n+            \"only a single explicit lifetime bound is permitted\");\n     }\n \n     if explicit_region_bounds.len() != 0 {\n@@ -1665,11 +1648,10 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // of derived region bounds. If so, use that. Otherwise, report an\n     // error.\n     let r = derived_region_bounds[0];\n-    if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n-        tcx.sess.span_err(\n-            span,\n-            &format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\")[]);\n+    if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n+        span_err!(tcx.sess, span, E0227,\n+            \"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\");\n     }\n     return Some(r);\n }\n@@ -1693,9 +1675,8 @@ fn compute_region_bound<'tcx>(\n             match rscope.default_region_bound(span) {\n                 Some(r) => { r }\n                 None => {\n-                    this.tcx().sess.span_err(\n-                        span,\n-                        &format!(\"explicit lifetime bound required\")[]);\n+                    span_err!(this.tcx().sess, span, E0228,\n+                        \"explicit lifetime bound required\");\n                     ty::ReStatic\n                 }\n             }\n@@ -1779,8 +1760,7 @@ fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               bindings: &[ConvertedBinding<'tcx>])\n {\n     for binding in bindings.iter().take(1) {\n-        tcx.sess.span_err(\n-            binding.span,\n+        span_err!(tcx.sess, binding.span, E0229,\n             \"associated type bindings are not allowed here\");\n     }\n }"}, {"sha": "ffec1421f9289ae9512607c3f485c352b460d302", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -50,10 +50,9 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n                     check_unboxed_closure(fcx, expr, kind, decl, body, None);\n \n-                    fcx.ccx.tcx.sess.span_err(\n-                        expr.span,\n-                        \"can't infer the \\\"kind\\\" of the closure, explicitly annotate it. e.g. \\\n-                        `|&:| {}`\");\n+                    span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n+                        \"can't infer the \\\"kind\\\" of the closure; explicitly annotate it; e.g. \\\n+                        `|&:| {{}}`\");\n                 },\n                 Some((sig, kind)) => {\n                     check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));\n@@ -89,15 +88,6 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let mut fn_ty = astconv::ty_of_closure(\n         fcx,\n         ast::Unsafety::Normal,\n-        ast::Many,\n-\n-        // The `RegionTraitStore` and region_existential_bounds\n-        // are lies, but we ignore them so it doesn't matter.\n-        //\n-        // FIXME(pcwalton): Refactor this API.\n-        ty::region_existential_bound(ty::ReStatic),\n-        ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n-\n         decl,\n         abi::RustCall,\n         expected_sig);"}, {"sha": "e3e5d67869fa47afb4a6f93ced61ad4d33505a98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -59,23 +59,21 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         (&ty::StaticExplicitSelfCategory,\n          &ty::StaticExplicitSelfCategory) => {}\n         (&ty::StaticExplicitSelfCategory, _) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+            span_err!(tcx.sess, impl_m_span, E0185,\n+                \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).as_slice());\n+                            &impl_m.explicit_self));\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+            span_err!(tcx.sess, impl_m_span, E0186,\n+                \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).as_slice());\n+                            &trait_m.explicit_self));\n             return;\n         }\n         _ => {\n@@ -400,11 +398,10 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // are zero. Since I don't quite know how to phrase things at\n         // the moment, give a kind of vague error message.\n         if trait_params.len() != impl_params.len() {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\"lifetime parameters or bounds on method `{}` do \\\n+            span_err!(tcx.sess, span, E0195,\n+                \"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                         token::get_name(impl_m.name))[]);\n+                         token::get_name(impl_m.name));\n             return false;\n         }\n "}, {"sha": "3cf9a1a945668d624e1e8d12c65ab2a21d01366b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -145,6 +145,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n         candidates.sort();\n+        candidates.dedup();\n         let msg = format!(\n             \"methods from traits can only be called if the trait is in scope; \\\n              the following {traits_are} implemented but not in scope, \\\n@@ -172,6 +173,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     if candidates.len() > 0 {\n         // sort from most relevant to least relevant\n         candidates.sort_by(|a, b| a.cmp(b).reverse());\n+        candidates.dedup();\n \n         let msg = format!(\n             \"methods from traits can only be called if the trait is implemented and in scope; \\"}, {"sha": "5f8ae09b5bd6fa6ce8a599bba3ea0c13485d5a67", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -108,6 +108,7 @@ use lint;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux::{self, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n@@ -801,24 +802,23 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n-                                ccx.tcx.sess.span_err(attr.span,\n-                                                 format!(\"there is no type parameter \\\n+                                span_err!(ccx.tcx.sess, attr.span, E0230,\n+                                                 \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident.as_str())\n-                                            .as_slice());\n+                                                           s, item.ident.as_str());\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n                         Position::ArgumentIs(_) | Position::ArgumentNext => {\n-                            ccx.tcx.sess.span_err(attr.span,\n+                            span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n                         }\n                     }\n                 }\n             }\n         } else {\n-            ccx.tcx.sess.span_err(attr.span,\n+            span_err!(ccx.tcx.sess, attr.span, E0232,\n                                   \"this attribute must have a value, \\\n                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\")\n         }\n@@ -2099,8 +2099,8 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n-            fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    &err_string[]);\n+            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n+                                    \"{}\", &err_string[]);\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2123,11 +2123,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                fcx.tcx().sess.span_err(iterator_expr.span,\n-                                        &format!(\"`for` loop expression has type `{}` which does \\\n+                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n+                                        \"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\",\n-                                                ty_string)[]);\n+                                                maybe try .iter()\", ty_string);\n             }\n             fcx.tcx().types.err\n         }\n@@ -2162,11 +2161,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.tcx().types.err\n                 }\n                 _ => {\n-                    fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            &format!(\"`next` method of the `Iterator` \\\n+                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n+                                            \"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type))\n-                                            []);\n+                                                    fcx.infcx().ty_to_string(return_type));\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -3074,11 +3072,43 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             actual)\n                 },\n                 expr_t, None);\n+            if let Some(t) = ty::ty_to_def_id(expr_t) {\n+                suggest_field_names(t, field, tcx, vec![]);\n+            }\n         }\n \n         fcx.write_error(expr.id);\n     }\n \n+    // displays hints about the closest matches in field names\n+    fn suggest_field_names<'tcx>(id : DefId,\n+                                 field : &ast::SpannedIdent,\n+                                 tcx : &ty::ctxt<'tcx>,\n+                                 skip : Vec<&str>) {\n+        let ident = token::get_ident(field.node);\n+        let name = ident.get();\n+        // only find fits with at least one matching letter\n+        let mut best_dist = name.len();\n+        let mut best = None;\n+        let fields = ty::lookup_struct_fields(tcx, id);\n+        for elem in fields.iter() {\n+            let n = elem.name.as_str();\n+            // ignore already set fields\n+            if skip.iter().any(|&x| x == n) {\n+                continue;\n+            }\n+            let dist = lev_distance(n, name);\n+            if dist < best_dist {\n+                best = Some(n);\n+                best_dist = dist;\n+            }\n+        }\n+        if let Some(n) = best {\n+            tcx.sess.span_help(field.span,\n+                format!(\"did you mean `{}`?\", n).as_slice());\n+        }\n+    }\n+\n     // Check tuple index expressions\n     fn check_tup_field(fcx: &FnCtxt,\n                        expr: &ast::Expr,\n@@ -3186,6 +3216,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         },\n                         struct_ty,\n                         None);\n+                    // prevent all specified fields from being suggested\n+                    let skip_fields = ast_fields.iter().map(|ref x| x.ident.node.name.as_str());\n+                    let actual_id = match enum_id_opt {\n+                        Some(_) => class_id,\n+                        None => ty::ty_to_def_id(struct_ty).unwrap()\n+                    };\n+                    suggest_field_names(actual_id, &field.ident, tcx, skip_fields.collect());\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n@@ -3880,18 +3917,16 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 Err(type_error) => {\n                     let type_error_description =\n                         ty::type_err_to_str(tcx, &type_error);\n-                    fcx.tcx()\n-                       .sess\n-                       .span_err(path.span,\n-                                 &format!(\"structure constructor specifies a \\\n+                    span_err!(fcx.tcx().sess, path.span, E0235,\n+                                 \"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n                                          structure has type `{}`: {}\",\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description)[]);\n+                                         type_error_description);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4012,7 +4047,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4022,7 +4057,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let substs = Substs::new_type(vec![], vec![]);\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4872,8 +4907,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n-                fcx.tcx().sess.span_err(\n-                    span,\n+                span_err!(fcx.tcx().sess, span, E0238,\n                     \"parenthesized parameters may only be used with a trait\");\n                 push_explicit_parenthesized_parameters_from_segment_to_substs(\n                     fcx, space, span, type_defs, data, substs);\n@@ -5230,7 +5264,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, &s[]); }\n+                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,"}, {"sha": "56b700663d419de034e65b6abca9ef55d4597809", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -297,14 +297,25 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n-        let fulfillment_cx = self.fcx.inh.fulfillment_cx.borrow();\n-        for r_o in fulfillment_cx.region_obligations(node_id).iter() {\n+\n+        // Make a copy of the region obligations vec because we'll need\n+        // to be able to borrow the fulfillment-cx below when projecting.\n+        let region_obligations =\n+            self.fcx.inh.fulfillment_cx.borrow()\n+                                       .region_obligations(node_id)\n+                                       .to_vec();\n+\n+        for r_o in region_obligations.iter() {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateRegionParamBound(r_o.cause.span);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n+\n+        // Processing the region obligations should not cause the list to grow further:\n+        assert_eq!(region_obligations.len(),\n+                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -531,7 +542,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprMethodCall(_, _, ref args) => {\n             constrain_call(rcx, expr, Some(&*args[0]),\n-                           args.slice_from(1).iter().map(|e| &**e), false);\n+                           args[1..].iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -1480,6 +1491,15 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                    generic.to_ty(rcx.tcx()),\n                                    param_env.caller_bounds.predicates.as_slice().to_vec());\n \n+    // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n+    match *generic {\n+        GenericKind::Param(..) => { }\n+        GenericKind::Projection(ref projection_ty) => {\n+            param_bounds.push_all(\n+                &projection_bounds(rcx, origin.span(), projection_ty)[]);\n+        }\n+    }\n+\n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n@@ -1511,3 +1531,73 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                          region,\n                                          param_bounds);\n }\n+\n+fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                              span: Span,\n+                              projection_ty: &ty::ProjectionTy<'tcx>)\n+                              -> Vec<ty::Region>\n+{\n+    let fcx = rcx.fcx;\n+    let tcx = fcx.tcx();\n+    let infcx = fcx.infcx();\n+\n+    debug!(\"projection_bounds(projection_ty={})\",\n+           projection_ty.repr(tcx));\n+\n+    let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n+\n+    // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n+    // in looking for a trait definition like:\n+    //\n+    // ```\n+    // trait SomeTrait<'a> {\n+    //     type SomeType : 'a;\n+    // }\n+    // ```\n+    //\n+    // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n+    let trait_def = ty::lookup_trait_def(tcx, projection_ty.trait_ref.def_id);\n+    let predicates = trait_def.generics.predicates.as_slice().to_vec();\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            // we're only interesting in `T : 'a` style predicates:\n+            let outlives = match predicate {\n+                ty::Predicate::TypeOutlives(data) => data,\n+                _ => { return None; }\n+            };\n+\n+            debug!(\"projection_bounds: outlives={} (1)\",\n+                   outlives.repr(tcx));\n+\n+            // apply the substitutions (and normalize any projected types)\n+            let outlives = fcx.instantiate_type_scheme(span,\n+                                                       projection_ty.trait_ref.substs,\n+                                                       &outlives);\n+\n+            debug!(\"projection_bounds: outlives={} (2)\",\n+                   outlives.repr(tcx));\n+\n+            let region_result = infcx.try(|_| {\n+                let (outlives, _) =\n+                    infcx.replace_late_bound_regions_with_fresh_var(\n+                        span,\n+                        infer::AssocTypeProjection(projection_ty.item_name),\n+                        &outlives);\n+\n+                debug!(\"projection_bounds: outlives={} (3)\",\n+                       outlives.repr(tcx));\n+\n+                // check whether this predicate applies to our current projection\n+                match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n+                    Ok(()) => { Ok(outlives.1) }\n+                    Err(_) => { Err(()) }\n+                }\n+            });\n+\n+            debug!(\"projection_bounds: region_result={}\",\n+                   region_result.repr(tcx));\n+\n+            region_result.ok()\n+        })\n+        .collect()\n+}"}, {"sha": "41b63830279a8f1b8109d993f0c49a9019771758", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -51,7 +51,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         {\n             let object_trait = object_trait(&object_trait_ty);\n             if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                fcx.tcx().sess.span_err(source_expr.span,\n+                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n                                         \"types differ in mutability\");\n             } else {\n                 // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n@@ -70,19 +70,17 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         (_, &ty::ty_uniq(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast an boxed pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n+                \"can only cast a boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                      ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast a &-pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n+                \"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                        ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         _ => {\n@@ -272,11 +270,10 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+        span_err!(tcx.sess, span, E0191,\n+            \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+                    ty::item_path_str(tcx, trait_def_id));\n     }\n }\n "}, {"sha": "60284433ffe457f44cbfe52ccaa410a01ca50059", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -81,10 +81,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        ccx.tcx.sess.span_err(\n-                            item.span,\n-                            format!(\"negative impls are currently \\\n-                                     allowed just for `Send` and `Sync`\").as_slice())\n+                        span_err!(ccx.tcx.sess, item.span, E0192,\n+                            \"negative impls are currently \\\n+                                     allowed just for `Send` and `Sync`\")\n                     }\n                 }\n             }\n@@ -302,12 +301,11 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n                           span: Span,\n                           bounded_ty: ty::Ty<'t>) {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"cannot bound type `{}`, where clause \\\n+        span_err!(tcx.sess, span, E0193,\n+            \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr(tcx)).as_slice())\n+                bounded_ty.repr(tcx))\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -326,10 +324,9 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n         if impl_params.contains(&method_param.name) {\n-            tcx.sess.span_err(\n-                span,\n-                &*format!(\"type parameter `{}` shadows another type parameter of the same name\",\n-                          token::get_name(method_param.name)));\n+            span_err!(tcx.sess, span, E0194,\n+                \"type parameter `{}` shadows another type parameter of the same name\",\n+                          token::get_name(method_param.name));\n         }\n     }\n }"}, {"sha": "52e81585875abe1a3dce1ba4bb9473f32666c29f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -416,7 +416,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n \n                 ResolvingUnboxedClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n-                    self.tcx.sess.span_err(span,\n+                    span_err!(self.tcx.sess, span, E0196,\n                                            \"cannot determine a type for this \\\n                                             unboxed closure\")\n                 }"}, {"sha": "e535b86a7bfd1e0cfa72c2cb8e74ed84fcc3e261", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -34,10 +34,9 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n                     match trait_ref.self_ty().sty {\n                         ty::ty_struct(..) | ty::ty_enum(..) => {}\n                         _ => {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"builtin traits can only be \\\n-                                          implemented on structs or enums\")[]);\n+                            span_err!(self.tcx.sess, item.span, E0209,\n+                                \"builtin traits can only be \\\n+                                          implemented on structs or enums\");\n                         }\n                     }\n                 }"}, {"sha": "7d59c3f9d3ff5f8d785daeeea2259dee3eb0f0c3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -490,24 +490,21 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0204,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0205,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::TypeIsStructural) => {\n-                    tcx.sess\n-                       .span_err(span,\n+                       span_err!(tcx.sess, span, E0206,\n                                  \"the trait `Copy` may not be implemented \\\n                                   for this type; type is not a structure or \\\n                                   enumeration\")"}, {"sha": "60b1fa5f4cf5d1068b3a9479ee321270d351ce0c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -89,13 +89,11 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n                         if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                format!(\n+                            span_err!(self.tcx.sess, item.span, E0210,\n                                     \"type parameter `{}` is not constrained by any local type; \\\n                                      only traits defined in the current crate can be implemented \\\n                                      for a type parameter\",\n-                                    param_ty.user_string(self.tcx)).as_slice());\n+                                    param_ty.user_string(self.tcx));\n                             self.tcx.sess.span_note(\n                                 item.span,\n                                 format!(\"for a limited time, you can add \\"}, {"sha": "a7bad3dc789aaadcf981e58d42add7d394d6ffca", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -65,7 +65,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 continue;\n             }\n \n-            for &impl2_def_id in trait_impls.slice_from(i+1).iter() {\n+            for &impl2_def_id in trait_impls[(i+1)..].iter() {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);"}, {"sha": "867dea9588568b515c68d7f699b258505e9da37c", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -37,8 +37,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match unsafety {\n                             ast::Unsafety::Normal => { /* OK */ }\n                             ast::Unsafety::Unsafe => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n+                                span_err!(self.tcx.sess, item.span, E0197,\n                                     \"inherent impls cannot be declared as unsafe\");\n                             }\n                         }\n@@ -49,24 +48,21 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match (trait_def.unsafety, unsafety, polarity) {\n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"negative implementations are not unsafe\").as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0198,\n+                                    \"negative implementations are not unsafe\");\n                             }\n \n                             (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"implementing the trait `{}` is not unsafe\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0199,\n+                                    \"implementing the trait `{}` is not unsafe\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"the trait `{}` requires an `unsafe impl` declaration\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0200,\n+                                    \"the trait `{}` requires an `unsafe impl` declaration\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,"}, {"sha": "8158b8da86dfd6f149da7c5b76c95dae73faa269", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70", "patch": "@@ -452,7 +452,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut seen_methods = FnvHashSet();\n     for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n-            tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n+            span_err!(tcx.sess, m.span, E0201, \"duplicate method in trait impl\");\n         }\n \n         let m_def_id = local_def(m.id);\n@@ -555,6 +555,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n         // These don't define types.\n+        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n             let scheme = ty_of_item(ccx, it);\n@@ -608,7 +609,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n                         if opt_trait_ref.is_none() {\n-                            tcx.sess.span_err(typedef.span,\n+                            span_err!(tcx.sess, typedef.span, E0202,\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n@@ -1004,6 +1005,7 @@ fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n             tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n             return scheme;\n         }\n+        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n         ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n     }\n@@ -1160,7 +1162,8 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                ccx.tcx.sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                span_err!(ccx.tcx.sess, span, E0203,\n+                          \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n@@ -1690,11 +1693,10 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl trait, self type, or predicates\",\n                             param_ty.user_string(tcx)).as_slice());\n             } else {\n-                tcx.sess.span_err(\n-                    ty_param.span,\n-                    format!(\"the type parameter `{}` is not constrained by the \\\n+                span_err!(tcx.sess, ty_param.span, E0207,\n+                    \"the type parameter `{}` is not constrained by the \\\n                              impl trait, self type, or predicates\",\n-                            param_ty.user_string(tcx)).as_slice());\n+                            param_ty.user_string(tcx));\n                 tcx.sess.span_help(\n                     ty_param.span,\n                     format!(\"you can temporarily opt out of this rule by placing \\"}, {"sha": "3627fa41160608adf2778a3593e93737fc780277", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "31c9f9961260a116552ed2fa1b70cb97d05d1f7e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "6ed18368738e0b7985cc9bbeb62fcc2d62248a0f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "6e79bd9bebda1003233dfa0a9b8ce95d06e125f7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "07b5586e691f92f37e8b107762c9459a7873ba85", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 146, "deletions": 146, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "04947e41663ece794c6c2c52f3b29ef3950216da", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "0e8ab594c20c1e2125f75f67c52f21657da7aa2e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "fe8ac3fde5fcc596e3a2f4f37dd0e09302e7859e", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "b6db3222f3053b3c3fe0cb5eaa3207ecddab7080", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "356be2ffeb04cf4bebaa3dc22425d8d0a282f509", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "e3bd2b4e27f0074576fdc922561ddea25fa212e4", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "00182a80ab3dd828e414529299611fff3989fe9e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "9a25993d28a6450ef40cf732fb6c8afd5d2cf948", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 73, "deletions": 74, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "0914f93efd802b406a0f72cac14f4a174150d60b", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "aac3985f0cc9cd967115c98c7381b696f1e43eb6", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "aca6e5bb10ed106c4dc202e2f047be78a83e5541", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "b3b0a1fb373ef778ddf5f2fcf34f9691a479d9d3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "594cf3dcd43992d0a6dfeefd17a46fe9f0d11b80", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "30b2ad810f1db1ca67ef525cdb65de4437e76b5e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "f1d9aef7f7ce8c10b71526cacbb7248c42728fef", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "7f1bd9e6d59657ed075659b79b1e868653e4db24", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "848205f589eda229e137e96d21ab2ade0edeafbc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d13d110320e1754302d4c2664d3a20a3acffb860", "filename": "src/libserialize/base64.rs", "status": "removed", "additions": 0, "deletions": 428, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44ee371b8beea77aa1364460acbba14a8516559/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=b44ee371b8beea77aa1364460acbba14a8516559"}, {"sha": "e477f4418a52ffd8b49fecc66569f01292f440ff", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "5f4ba8ef9fcc743393f4f0ad3077dd19b50c0482", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d51bb3af62728a98f929c1a37a6d6844bcf15503", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "ae295c3e8e44239db67514754b788bf96e2a2790", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "84f01f70c3e885b722b5af6252e058b172dc7d1b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "0c55850b32a2dd5d689bd21914e173fb36728059", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "fdd7aa216d3c0edc9c84711a0de71353856ee5ca", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "6f2e011d59549ff4a72c861de273ce4e9b545c6c", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "1c1c73cddd18e9dd3e6803ab69881b8a9563ff03", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d3d49d41a679dc53d186ceb5aacfe325f4b5631f", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "cc36c5640d0a7c224436d24f3e61712201a118bd", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "8c0de78199484774984361070c035fcdbe34af3d", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "cc7f9f5b892744d4d0b36a7d266ab6d7721cf852", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "7e7603c826eb687d0dc900b30ba4c9d09e7ee0a9", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "a406d3c278856c374e2c363198a98cd867bc8968", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "a5664b9f013776000187bec2d2b5acf7674effe7", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "68ae7d0ff2083d061fca4eec189d2fdb712fa4e5", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "e4bf38a9ef5d8e0d7de059153cc00c366aaa5934", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "4827bc2b3c8621f452e128b194dd5551f3336504", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "dad8b70ceacdf7fce72daca57d971dc72fea7b73", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "1d3bf484edb9ab458150dbd6213b2884fb423da3", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d81e2b3aa4b7ba69caead4cf9dafda4b3b729006", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "e4a662f8463dee1e67f90cde1e3af7749272c50a", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "07fdd1a830f53858a6aa9946b126fc6cdb3fc21f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "ebded1f0855d00d927bc02553192824a7f642f60", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "bafbde2511dec6096816b5fc92e987b0f3cdba4a", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "18298f1c7f4f5ac3c5dd8e0d1d6e6ffceddd34dd", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "4023a0a4c100b3b86f5ee319bf857920048f248f", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "61ffb532d36ad49cb20a97822371d53ac7af5b73", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "101af8d5e9a4256521d47a5d53ed3c63ff7ad41d", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "c222c313ba6864748a50882d5d91a011e458c83e", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "e97c82a5b1b027122a8d36416bea597b9e566e35", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "c1983fcab194de1a614641e3834ca1eed5411608", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d38f14a91302fa6fde9b19dfcd819025f739dd68", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "f7fdd60eb8cb7e117731f39efc6620f626d9f245", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "b04c2310fc0b4988c30e156856bfa58f9dfb5c54", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "12befbf72e37e4d3f377f308ba91a9a64612ebc4", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d069d9ee3b8b89889b378c4841db7ae5a8bfc7e7", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "6f6179a436e914c3c77de9384be7e6b41799ea02", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "cb2edf50ebd3ea4ba3bb1ffb14abee25e7f91e8c", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "3bc414731526300d15d5fa0d0716b132c7d892f6", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "dd478347f819b36d1cd0bc5a7f1632916e75675c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "2c25af055ee1c66c0b1cf46d35fbe2dc1b01545a", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "2b4d168d881f6a1c25f6449aed1b3b6d64c5bbcd", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "cba7d81937acde588dca47a03fd2fcf0809ac5c1", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "cb8ef7eb66bc414d30658135feef4d382a213930", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "36dc9b2afe49feb673cfd58081e7634ca22a08c2", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d148f82184bd4d8b8b99c75c7f54edc444a2eac8", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "12b4e56bf5209f64c9f1e1360ba7218fafda830d", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "09f50059936ab8285754c2ec9529e7f6e475f77d", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "2a9bf452329cd636cf438340d0bb361b494ec849", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "fdd9cbdccf515e175aab6ba43417f6998ba26d5c", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "5f593ac7081c1a91335290d471ca49cd206deee3", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "7111fe3af1fa9e81814b055716997e0f38bbb81d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 47, "deletions": 83, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "8a114e4b7487de4ffc804bacd494a45fa01a0124", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "cf0aac5bf4ab5e5d144940301fdf86a811b1a4eb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 29, "deletions": 78, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "061600d9420f5c3c89cf7b6361ed0494a6ae866a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "a5e10f42750b8be8966895a409774ba9ec98de13", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "3eaac0fe333e8e3026f69abd6ca6b0f7d8f52653", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "0c7f6befc4e3e1b884c5a95df1828e5f050c559b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "9321d3ca3df1141196a45917db933c208d3fb56d", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "bd5247bbad6a78f9b6e4e2335afd910f0a9b174a", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "9cfdc942c21b66c105a62f4e8b0c05425791a2d6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "92619cf42e4d197a517990dddd2f78abb5de6f6d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "e458bd58e8b6a8cb51a1865f7bdc033f565d9330", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "f8fdd8575bd67dce5246129daa8c631d277ab422", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "4c78a7b6a0cfefaf7cb6b7840cd5ac964e885e93", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "272b0464010114d0c708b19b461d300ff691c871", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "85682d41b5ff65cffcdb971ca178d9d9d10c244e", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "8dac864c2ae3b689b9a89e38b3faa13f57c44b4d", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "e52a2b513ce1f3582a793c50045767a2b07d7676", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "bb902d7059c87b8aeacd4bd5eaa76e51f37b48b1", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "f5b5d4dda199c90ea1eeb4c014d5ab3ece96ac71", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "9f6bf352b040443609c0c30943259b5f8b0656d7", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "629991799e73de2d4638eb849521244acad18cb5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "8ea9d6168ef4130d90faa68776e2f59cf67ddc6f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "7adc443759fe87624bd861e6a4ad1cab2af74ed5", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "7e345a2d078ffa1aff57d20a375d14763f9b90b3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "a74adbf40851565929b38512893cbc2fef3b5965", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "d115f2ed6208265b7b69646471585caffe173f9d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "8350e0222ef898f4c082eec9234d0ece8c68c0e3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}, {"sha": "0bf20b8f3e1514c829ede4aa92a71b27e1349970", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=63fcbcf3ce8f0ca391c18b2d61833ae6beb3ac70"}]}