{"sha": "114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNGJlMWU5ZjBkYjJjODRlMzhiNWVkOTZkNGU0NDUwNzcxZThhNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-17T02:07:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-17T02:07:41Z"}, "message": "Auto merge of #34315 - Manishearth:rollup, r=Manishearth\n\nRollup of 4 pull requests\n\n- Successful merges: #34298, #34302, #34307, #34312\n- Failed merges:", "tree": {"sha": "cf17be35a47fd2c95f45392557ac094f2b206224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf17be35a47fd2c95f45392557ac094f2b206224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "html_url": "https://github.com/rust-lang/rust/commit/114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f911d87b3b6ee3e484ca8dd7da4be85970d9230d", "html_url": "https://github.com/rust-lang/rust/commit/f911d87b3b6ee3e484ca8dd7da4be85970d9230d"}, {"sha": "019c594c6aebada1cdbb4b7c3d947d9dc17088e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/019c594c6aebada1cdbb4b7c3d947d9dc17088e1", "html_url": "https://github.com/rust-lang/rust/commit/019c594c6aebada1cdbb4b7c3d947d9dc17088e1"}], "stats": {"total": 1971, "additions": 1037, "deletions": 934}, "files": [{"sha": "7eb50b8b86dac0abcfad3a0d9fc75094153fc09c", "filename": "src/bootstrap/build/cc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbootstrap%2Fbuild%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbootstrap%2Fbuild%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcc.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -57,7 +57,9 @@ pub fn find(build: &mut Build) {\n         let compiler = cfg.get_compiler();\n         let ar = cc2ar(compiler.path(), target);\n         build.verbose(&format!(\"CC_{} = {:?}\", target, compiler.path()));\n-        build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n+        if let Some(ref ar) = ar {\n+            build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n+        }\n         build.cc.insert(target.to_string(), (compiler, ar));\n     }\n "}, {"sha": "dadb0ffa6c98d73bb9b4d7c1dfcf7b75b7434e73", "filename": "src/bootstrap/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -119,7 +119,7 @@ pub struct Build {\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n-    cc: HashMap<String, (gcc::Tool, PathBuf)>,\n+    cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n     compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n }\n@@ -549,7 +549,7 @@ impl Build {\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n             cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n                  .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n         }\n \n@@ -825,8 +825,8 @@ impl Build {\n     }\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n-    fn ar(&self, target: &str) -> &Path {\n-        &self.cc[target].1\n+    fn ar(&self, target: &str) -> Option<&Path> {\n+        self.cc[target].1.as_ref().map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified, may panic"}, {"sha": "fd6cdc702cc3ba4bbc608277851756a70ff21648", "filename": "src/bootstrap/build/sanity.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fsanity.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -70,7 +70,9 @@ pub fn check(build: &mut Build) {\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in build.config.target.iter() {\n         need_cmd(build.cc(target).as_ref());\n-        need_cmd(build.ar(target).as_ref());\n+        if let Some(ar) = build.ar(target) {\n+            need_cmd(ar.as_ref());\n+        }\n     }\n     for host in build.config.host.iter() {\n         need_cmd(build.cxx(host).as_ref());"}, {"sha": "838cc4f07a9a175397c253dbec2ab730413926b8", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -39,20 +39,22 @@ pub fn gnu_target(target: &str) -> String {\n     }\n }\n \n-pub fn cc2ar(cc: &Path, target: &str) -> PathBuf {\n-    if target.contains(\"musl\") || target.contains(\"msvc\") {\n-        PathBuf::from(\"ar\")\n+pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n+    if target.contains(\"msvc\") {\n+        None\n+    } else if target.contains(\"musl\") {\n+        Some(PathBuf::from(\"ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n         for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n             if let Some(idx) = file.rfind(suffix) {\n                 let mut file = file[..idx].to_owned();\n                 file.push_str(\"ar\");\n-                return parent.join(&file);\n+                return Some(parent.join(&file));\n             }\n         }\n-        parent.join(file)\n+        Some(parent.join(file))\n     }\n }\n "}, {"sha": "d1b3583d256b6e11bc6136c6ea364a5216b33a2e", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -43,7 +43,8 @@ fn main() {\n     }\n \n     let compiler = gcc::Config::new().get_compiler();\n-    let ar = build_helper::cc2ar(compiler.path(), &target);\n+    // only msvc returns None for ar so unwrap is okay\n+    let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n     let cflags = compiler.args()\n                          .iter()\n                          .map(|s| s.to_str().unwrap())"}, {"sha": "65457a9cc80d6e8c57dc96e1fcffd9cb0bb4456b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -94,6 +94,7 @@ use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -127,12 +128,8 @@ pub struct Scope<'tcx> {\n     /// stage.\n     free: Option<FreeData<'tcx>>,\n \n-    /// The cached block for the cleanups-on-diverge path. This block\n-    /// contains a block that will just do a RESUME to an appropriate\n-    /// place. This block does not execute any of the drops or free:\n-    /// each of those has their own cached-blocks, which will branch\n-    /// to this point.\n-    cached_block: Option<BasicBlock>\n+    /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n+    cached_exits: FnvHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -172,7 +169,7 @@ pub struct LoopScope {\n     pub continue_block: BasicBlock,\n     /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n     /// having its condition to become false)\n-    pub break_block: BasicBlock, // where to go on a `break\n+    pub break_block: BasicBlock,\n     /// Indicates the reachability of the break_block for this loop\n     pub might_break: bool\n }\n@@ -183,7 +180,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     fn invalidate_cache(&mut self) {\n-        self.cached_block = None;\n+        self.cached_exits = FnvHashMap();\n         for dropdata in &mut self.drops {\n             dropdata.cached_block = None;\n         }\n@@ -192,7 +189,7 @@ impl<'tcx> Scope<'tcx> {\n         }\n     }\n \n-    /// Returns the cached block for this scope.\n+    /// Returns the cached entrypoint for diverging exit from this scope.\n     ///\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n@@ -270,7 +267,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent: extent,\n             drops: vec![],\n             free: None,\n-            cached_block: None,\n+            cached_exits: FnvHashMap()\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,\n@@ -314,13 +311,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                       .unwrap_or_else(||{\n             span_bug!(span, \"extent {:?} does not enclose\", extent)\n         });\n-\n+        let len = self.scopes.len();\n+        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n         let tmp = self.get_unit_temp();\n-        for (idx, ref scope) in self.scopes.iter().enumerate().rev().take(scope_count) {\n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              scope,\n-                                              &self.scopes[..idx],\n-                                              block));\n+        {\n+        let mut rest = &mut self.scopes[(len - scope_count)..];\n+        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n+            rest = rest_;\n+            block = if let Some(&e) = scope.cached_exits.get(&(target, extent)) {\n+                self.cfg.terminate(block, scope.source_info(span),\n+                                   TerminatorKind::Goto { target: e });\n+                return;\n+            } else {\n+                let b = self.cfg.start_new_block();\n+                self.cfg.terminate(block, scope.source_info(span),\n+                                   TerminatorKind::Goto { target: b });\n+                scope.cached_exits.insert((target, extent), b);\n+                b\n+            };\n+            unpack!(block = build_scope_drops(&mut self.cfg, scope, rest, block));\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n@@ -331,14 +340,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 .postdoms\n                 .push(self.cfg.current_location(block));\n         }\n-\n-        assert!(scope_count < self.scopes.len(),\n-                \"should never use `exit_scope` to pop *ALL* scopes\");\n-        let scope = self.scopes.iter().rev().skip(scope_count)\n-                                            .next()\n-                                            .unwrap();\n-        self.cfg.terminate(block,\n-                           scope.source_info(span),\n+        }\n+        let scope = &self.scopes[len - scope_count];\n+        self.cfg.terminate(block, scope.source_info(span),\n                            TerminatorKind::Goto { target: target });\n     }\n \n@@ -506,10 +510,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             resumeblk\n         };\n \n-        for scope in scopes {\n+        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n             target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, scope, target);\n         }\n-\n         Some(target)\n     }\n \n@@ -534,7 +537,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-\n+    /// Utility function for *non*-scope code to build their own drops\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n                                   span: Span,"}, {"sha": "15aaa77cc3518fe3ef7a6a587b0fa539c58c4ef9", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -102,6 +102,8 @@ pub struct EnumData {\n     pub qualname: String,\n     pub span: Span,\n     pub scope: NodeId,\n+    pub variants: Vec<NodeId>,\n+\n }\n \n /// Data for extern crates.\n@@ -212,6 +214,7 @@ pub struct MethodData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub value: String,\n+    pub decl_id: Option<DefId>,\n }\n \n /// Data for modules.\n@@ -223,6 +226,7 @@ pub struct ModData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub filename: String,\n+    pub items: Vec<NodeId>,\n }\n \n /// Data for a reference to a module.\n@@ -242,7 +246,8 @@ pub struct StructData {\n     pub ctor_id: NodeId,\n     pub qualname: String,\n     pub scope: NodeId,\n-    pub value: String\n+    pub value: String,\n+    pub fields: Vec<NodeId>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -263,7 +268,8 @@ pub struct TraitData {\n     pub name: String,\n     pub qualname: String,\n     pub scope: NodeId,\n-    pub value: String\n+    pub value: String,\n+    pub items: Vec<NodeId>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -317,6 +323,7 @@ pub struct UseGlobData {\n #[derive(Debug, RustcEncodable)]\n pub struct VariableData {\n     pub id: NodeId,\n+    pub kind: VariableKind,\n     pub name: String,\n     pub qualname: String,\n     pub span: Span,\n@@ -325,6 +332,14 @@ pub struct VariableData {\n     pub type_value: String,\n }\n \n+#[derive(Debug, RustcEncodable)]\n+pub enum VariableKind {\n+    Static,\n+    Const,\n+    Local,\n+    Field,\n+}\n+\n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refer to that variables declaration (by ref_id)).\n #[derive(Debug, RustcEncodable)]"}, {"sha": "56c7436a8fe5c3b08875bfa642fe81b21493322e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -30,7 +30,7 @@\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::session::Session;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, ImplOrTraitItem, ImplOrTraitItemContainer};\n \n use std::collections::HashSet;\n use std::hash::*;\n@@ -356,6 +356,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 if !self.span.filter_generated(sub_span, p.span) {\n                     self.dumper.variable(VariableData {\n                         id: id,\n+                        kind: VariableKind::Local,\n                         span: sub_span.expect(\"No span found for variable\"),\n                         name: path_to_string(p),\n                         qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n@@ -380,24 +381,42 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n-                if !self.span.filter_generated(Some(method_data.span), span) {\n-                    let mut data = method_data.clone();\n-                    data.value = sig_str;\n-                    self.dumper.function(data.lower(self.tcx));\n-                }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n-            } else {\n-                if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.method(MethodData {\n-                        id: method_data.id,\n-                        name: method_data.name,\n-                        span: method_data.span,\n-                        scope: method_data.scope,\n-                        qualname: method_data.qualname.clone(),\n-                        value: sig_str,\n-                    }.lower(self.tcx));\n-                }\n             }\n+\n+            // If the method is defined in an impl, then try and find the corresponding\n+            // method decl in a trait, and if there is one, make a decl_id for it. This\n+            // requires looking up the impl, then the trait, then searching for a method\n+            // with the right name.\n+            if !self.span.filter_generated(Some(method_data.span), span) {\n+                let container =\n+                    self.tcx.impl_or_trait_item(self.tcx.map.local_def_id(id)).container();\n+                let decl_id = if let ImplOrTraitItemContainer::ImplContainer(id) = container {\n+                    self.tcx.trait_id_of_impl(id).and_then(|id| {\n+                        for item in &**self.tcx.trait_items(id) {\n+                            if let &ImplOrTraitItem::MethodTraitItem(ref m) = item {\n+                                if m.name == name {\n+                                    return Some(m.def_id);\n+                                }\n+                            }\n+                        }\n+                        None\n+                    })\n+                } else {\n+                    None\n+                };\n+\n+                self.dumper.method(MethodData {\n+                    id: method_data.id,\n+                    name: method_data.name,\n+                    span: method_data.span,\n+                    scope: method_data.scope,\n+                    qualname: method_data.qualname.clone(),\n+                    value: sig_str,\n+                    decl_id: decl_id,\n+                }.lower(self.tcx));\n+            }\n+\n             self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n         }\n \n@@ -519,6 +538,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if !self.span.filter_generated(sub_span, span) {\n             self.dumper.variable(VariableData {\n                 span: sub_span.expect(\"No span found for variable\"),\n+                kind: VariableKind::Const,\n                 id: id,\n                 name: name.to_string(),\n                 qualname: qualname,\n@@ -542,17 +562,18 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n-        let val = if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) =\n-                    item.node {\n+        let (val, fields) =\n+            if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) = item.node\n+        {\n             let fields_str = fields.iter()\n                                    .enumerate()\n                                    .map(|(i, f)| f.ident.map(|i| i.to_string())\n                                                   .unwrap_or(i.to_string()))\n                                    .collect::<Vec<_>>()\n                                    .join(\", \");\n-            format!(\"{} {{ {} }}\", name, fields_str)\n+            (format!(\"{} {{ {} }}\", name, fields_str), fields.iter().map(|f| f.id).collect())\n         } else {\n-            String::new()\n+            (String::new(), vec![])\n         };\n \n         if !self.span.filter_generated(sub_span, item.span) {\n@@ -563,7 +584,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ctor_id: def.id(),\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n-                value: val\n+                value: val,\n+                fields: fields,\n             }.lower(self.tcx));\n         }\n \n@@ -718,7 +740,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 name: name,\n                 qualname: qualname.clone(),\n                 scope: self.cur_scope,\n-                value: val\n+                value: val,\n+                items: methods.iter().map(|i| i.id).collect(),\n             }.lower(self.tcx));\n         }\n \n@@ -958,6 +981,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if !self.span.filter_generated(sub_span, p.span) {\n                 self.dumper.variable(VariableData {\n                     span: sub_span.expect(\"No span found for variable\"),\n+                    kind: VariableKind::Local,\n                     id: id,\n                     name: path_to_string(p),\n                     qualname: format!(\"{}${}\", path_to_string(p), id),\n@@ -1366,6 +1390,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                     if !self.span.filter_generated(Some(p.span), p.span) {\n                         self.dumper.variable(VariableData {\n                             span: p.span,\n+                            kind: VariableKind::Local,\n                             id: id,\n                             name: path_to_string(p),\n                             qualname: format!(\"{}${}\", path_to_string(p), id),"}, {"sha": "7efd2624561e7ff915b8099df602d96cfe1c83fe", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TyCtxt;\n use syntax::ast::{CrateNum, NodeId};\n use syntax::codemap::{Span, CodeMap};\n \n-use super::data;\n+use data;\n \n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n pub trait Lower {\n@@ -90,6 +90,7 @@ pub struct EnumData {\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n+    pub variants: Vec<DefId>\n }\n \n impl Lower for data::EnumData {\n@@ -103,6 +104,7 @@ impl Lower for data::EnumData {\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n+            variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n         }\n     }\n }\n@@ -319,6 +321,7 @@ pub struct MethodData {\n     pub span: SpanData,\n     pub scope: DefId,\n     pub value: String,\n+    pub decl_id: Option<DefId>,\n }\n \n impl Lower for data::MethodData {\n@@ -332,6 +335,7 @@ impl Lower for data::MethodData {\n             id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n             value: self.value,\n+            decl_id: self.decl_id,\n         }\n     }\n }\n@@ -345,6 +349,7 @@ pub struct ModData {\n     pub span: SpanData,\n     pub scope: DefId,\n     pub filename: String,\n+    pub items: Vec<DefId>,\n }\n \n impl Lower for data::ModData {\n@@ -358,6 +363,7 @@ impl Lower for data::ModData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n             filename: self.filename,\n+            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n         }\n     }\n }\n@@ -392,7 +398,8 @@ pub struct StructData {\n     pub ctor_id: DefId,\n     pub qualname: String,\n     pub scope: DefId,\n-    pub value: String\n+    pub value: String,\n+    pub fields: Vec<DefId>,\n }\n \n impl Lower for data::StructData {\n@@ -406,7 +413,8 @@ impl Lower for data::StructData {\n             ctor_id: make_def_id(self.ctor_id, &tcx.map),\n             qualname: self.qualname,\n             scope: make_def_id(self.scope, &tcx.map),\n-            value: self.value\n+            value: self.value,\n+            fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n         }\n     }\n }\n@@ -445,7 +453,8 @@ pub struct TraitData {\n     pub id: DefId,\n     pub qualname: String,\n     pub scope: DefId,\n-    pub value: String\n+    pub value: String,\n+    pub items: Vec<DefId>,\n }\n \n impl Lower for data::TraitData {\n@@ -459,6 +468,7 @@ impl Lower for data::TraitData {\n             qualname: self.qualname,\n             scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n+            items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n         }\n     }\n }\n@@ -585,6 +595,7 @@ impl Lower for data::UseGlobData {\n pub struct VariableData {\n     pub id: DefId,\n     pub name: String,\n+    pub kind: data::VariableKind,\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -598,6 +609,7 @@ impl Lower for data::VariableData {\n     fn lower(self, tcx: TyCtxt) -> VariableData {\n         VariableData {\n             id: make_def_id(self.id, &tcx.map),\n+            kind: self.kind,\n             name: self.name,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),"}, {"sha": "b1955cbd7b8016cc9b0d85ea99b2f52d17c7286a", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -13,8 +13,9 @@ use std::io::Write;\n use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n-use super::external_data::*;\n-use super::dump::Dump;\n+use external_data::*;\n+use data::VariableKind;\n+use dump::Dump;\n \n pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n@@ -180,6 +181,8 @@ struct Def {\n     name: String,\n     qualname: String,\n     value: String,\n+    children: Vec<Id>,\n+    decl_id: Option<Id>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -194,14 +197,19 @@ enum DefKind {\n     Trait,\n     // value = type + generics\n     Function,\n+    // value = type + generics\n+    Method,\n     // No id, no value.\n     Macro,\n     // value = file_name\n     Mod,\n     // value = aliased type\n     Type,\n-    // value = type and init expression\n-    Variable,\n+    // value = type and init expression (for all variable kinds).\n+    Local,\n+    Static,\n+    Const,\n+    Field,\n }\n \n impl From<EnumData> for Def {\n@@ -213,6 +221,8 @@ impl From<EnumData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n         }\n     }\n }\n@@ -226,6 +236,8 @@ impl From<TupleVariantData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: vec![],\n+            decl_id: None,\n         }\n     }\n }\n@@ -238,6 +250,8 @@ impl From<StructVariantData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: vec![],\n+            decl_id: None,\n         }\n     }\n }\n@@ -250,6 +264,8 @@ impl From<StructData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n         }\n     }\n }\n@@ -262,6 +278,8 @@ impl From<TraitData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n         }\n     }\n }\n@@ -274,18 +292,22 @@ impl From<FunctionData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: vec![],\n+            decl_id: None,\n         }\n     }\n }\n impl From<MethodData> for Def {\n     fn from(data: MethodData) -> Def {\n         Def {\n-            kind: DefKind::Function,\n+            kind: DefKind::Method,\n             id: From::from(data.id),\n             span: data.span,\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: vec![],\n+            decl_id: data.decl_id.map(|id| From::from(id)),\n         }\n     }\n }\n@@ -298,6 +320,8 @@ impl From<MacroData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: String::new(),\n+            children: vec![],\n+            decl_id: None,\n         }\n     }\n }\n@@ -310,6 +334,8 @@ impl From<ModData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.filename,\n+            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n         }\n     }\n }\n@@ -322,18 +348,27 @@ impl From<TypeDefData> for Def {\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: vec![],\n+            decl_id: None,\n         }\n     }\n }\n impl From<VariableData> for Def {\n     fn from(data: VariableData) -> Def {\n         Def {\n-            kind: DefKind::Variable,\n+            kind: match data.kind {\n+                VariableKind::Static => DefKind::Static,\n+                VariableKind::Const => DefKind::Const,\n+                VariableKind::Local => DefKind::Local,\n+                VariableKind::Field => DefKind::Field,\n+            },\n             id: From::from(data.id),\n             span: data.span,\n             name: data.name,\n             qualname: data.qualname,\n             value: data.value,\n+            children: vec![],\n+            decl_id: None,\n         }\n     }\n }"}, {"sha": "3335133816043eedb916c632434817d57c093b74", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -153,6 +153,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, sub_span, item.span, None);\n                 Some(Data::VariableData(VariableData {\n                     id: item.id,\n+                    kind: VariableKind::Static,\n                     name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n@@ -167,6 +168,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, sub_span, item.span, None);\n                 Some(Data::VariableData(VariableData {\n                     id: item.id,\n+                    kind: VariableKind::Const,\n                     name: item.ident.to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n@@ -190,6 +192,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n                     filename: filename,\n+                    items: m.items.iter().map(|i| i.id).collect(),\n                 }))\n             }\n             ast::ItemKind::Enum(ref def, _) => {\n@@ -209,6 +212,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     span: sub_span.unwrap(),\n                     qualname: qualname,\n                     scope: self.enclosing_scope(item.id),\n+                    variants: def.variants.iter().map(|v| v.node.data.id()).collect(),\n                 }))\n             }\n             ast::ItemKind::Impl(_, _, _, ref trait_ref, ref typ, _) => {\n@@ -266,6 +270,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             filter!(self.span_utils, sub_span, field.span, None);\n             Some(VariableData {\n                 id: field.id,\n+                kind: VariableKind::Field,\n                 name: ident.to_string(),\n                 qualname: qualname,\n                 span: sub_span.unwrap(),"}, {"sha": "9c408366f8b481d38e983d83f4bdcac9cdcfbbde", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44", "patch": "@@ -80,7 +80,8 @@ fn build_libbacktrace(host: &str, target: &str) {\n     }\n \n     let compiler = gcc::Config::new().get_compiler();\n-    let ar = build_helper::cc2ar(compiler.path(), target);\n+    // only msvc returns None for ar so unwrap is okay\n+    let ar = build_helper::cc2ar(compiler.path(), target).unwrap();\n     let cflags = compiler.args().iter().map(|s| s.to_str().unwrap())\n                          .collect::<Vec<_>>().join(\" \");\n     run(Command::new(\"sh\")"}, {"sha": "0c90e102f3425c10c53b4dbb3bc281cd08001bb6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 859, "deletions": 859, "changes": 1718, "blob_url": "https://github.com/rust-lang/rust/blob/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/114be1e9f0db2c84e38b5ed96d4e4450771e8a44/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=114be1e9f0db2c84e38b5ed96d4e4450771e8a44"}]}