{"sha": "db29de7745047383031231857745c5ec9b0bb4e8", "node_id": "C_kwDOAAsO6NoAKGRiMjlkZTc3NDUwNDczODMwMzEyMzE4NTc3NDVjNWVjOWIwYmI0ZTg", "commit": {"author": {"name": "Markus Reiter", "email": "me@reitermark.us", "date": "2022-09-09T09:48:39Z"}, "committer": {"name": "Markus Reiter", "email": "me@reitermark.us", "date": "2022-09-14T00:00:18Z"}, "message": "Simplify `const` `memchr`.", "tree": {"sha": "0aecd9592e0bd44d520473cd7936f1fa104b0090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aecd9592e0bd44d520473cd7936f1fa104b0090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db29de7745047383031231857745c5ec9b0bb4e8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJFBAABCAAvFiEEbU1eLXPTwjnhHZwHJFKTtRcCZVsFAmMhGZIRHG1lQHJlaXRl\ncm1hcmsudXMACgkQJFKTtRcCZVuknw/9ENakdzrppBhrtQCMiwsq0sUr4IjyvHq6\nUctcp9xMzpIu5Z2fi2A5hJk1dfkOYCMVi3mlW61kbKKSvnMyTZnnZZRengMNlgZO\nCYbu6ZtUNiQLQV/PapVzXYD+dLz7lfEPB4Jm5lGHPEtcCWr5hOJtaPKah1y+SeZK\nXE4+Cma2JXGpRvcVO+4LeQwU8no7vaOd5HNKlyBBczsQLNuD6sYStZmnLF+vrc4U\nv/HJWUc68KQe+P83Kn5kGxB5V17PYjho6ohgOSAbL8EPMX22RXdBAYUq9RdEzIaA\n6uzEy+/EYcvgJ93DvPlKu+yXm5QaWYRe/3vmABXpAQmRhkG9BqWk83vjLA67Uy9e\nl9LZ6OkGXQ5ZhhuapvK2SX/QQgk/+wHSViFlU8Fe1IqWcmzvyeZRLjyyxRe2snZZ\nxEEN4xJBs79u4X0rJ+v4c1YsbRnwYCIoPoDailVWYV6SUlnEZo59BT54jIxVnCu6\nQnEOzO9N39Ij96eDIn7lKKgd8G9eJtI9CXEpB0eJtapfx4BPD2YPhnngocTl7WWv\nJkm2CtZNbp86FMOoIJfg6RMGZHw/dWpfPY9i0x7QpM+cw3oqPBK9RZn5aPRiVEnO\nHeN9EPz79tvqKW93bGaJoqKMkwU//YBSI+yVyyVPYJ3E6sO9RZv/mApxuZN5UW5t\nO5rQXqm0KzM=\n=QqlY\n-----END PGP SIGNATURE-----", "payload": "tree 0aecd9592e0bd44d520473cd7936f1fa104b0090\nparent c84083b08e2db69fcf270c4045837fa02663a3bf\nauthor Markus Reiter <me@reitermark.us> 1662716919 +0200\ncommitter Markus Reiter <me@reitermark.us> 1663113618 +0200\n\nSimplify `const` `memchr`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db29de7745047383031231857745c5ec9b0bb4e8", "html_url": "https://github.com/rust-lang/rust/commit/db29de7745047383031231857745c5ec9b0bb4e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db29de7745047383031231857745c5ec9b0bb4e8/comments", "author": {"login": "reitermarkus", "id": 1309829, "node_id": "MDQ6VXNlcjEzMDk4Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1309829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reitermarkus", "html_url": "https://github.com/reitermarkus", "followers_url": "https://api.github.com/users/reitermarkus/followers", "following_url": "https://api.github.com/users/reitermarkus/following{/other_user}", "gists_url": "https://api.github.com/users/reitermarkus/gists{/gist_id}", "starred_url": "https://api.github.com/users/reitermarkus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reitermarkus/subscriptions", "organizations_url": "https://api.github.com/users/reitermarkus/orgs", "repos_url": "https://api.github.com/users/reitermarkus/repos", "events_url": "https://api.github.com/users/reitermarkus/events{/privacy}", "received_events_url": "https://api.github.com/users/reitermarkus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reitermarkus", "id": 1309829, "node_id": "MDQ6VXNlcjEzMDk4Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1309829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reitermarkus", "html_url": "https://github.com/reitermarkus", "followers_url": "https://api.github.com/users/reitermarkus/followers", "following_url": "https://api.github.com/users/reitermarkus/following{/other_user}", "gists_url": "https://api.github.com/users/reitermarkus/gists{/gist_id}", "starred_url": "https://api.github.com/users/reitermarkus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reitermarkus/subscriptions", "organizations_url": "https://api.github.com/users/reitermarkus/orgs", "repos_url": "https://api.github.com/users/reitermarkus/repos", "events_url": "https://api.github.com/users/reitermarkus/events{/privacy}", "received_events_url": "https://api.github.com/users/reitermarkus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84083b08e2db69fcf270c4045837fa02663a3bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84083b08e2db69fcf270c4045837fa02663a3bf", "html_url": "https://github.com/rust-lang/rust/commit/c84083b08e2db69fcf270c4045837fa02663a3bf"}], "stats": {"total": 48, "additions": 23, "deletions": 25}, "files": [{"sha": "7de1f48e6c9022dbe685eeb11e03b1312f28d524", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/db29de7745047383031231857745c5ec9b0bb4e8/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db29de7745047383031231857745c5ec9b0bb4e8/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=db29de7745047383031231857745c5ec9b0bb4e8", "patch": "@@ -2,7 +2,6 @@\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n use crate::cmp;\n-use crate::intrinsics;\n use crate::mem;\n \n const LO_USIZE: usize = usize::repeat_u8(0x01);\n@@ -17,53 +16,51 @@ const USIZE_BYTES: usize = mem::size_of::<usize>();\n /// bytes where the borrow propagated all the way to the most significant\n /// bit.\"\n #[inline]\n-fn contains_zero_byte(x: usize) -> bool {\n+const fn contains_zero_byte(x: usize) -> bool {\n     x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[inline]\n-fn repeat_byte(b: u8) -> usize {\n+const fn repeat_byte(b: u8) -> usize {\n     (b as usize) << 8 | b as usize\n }\n \n #[cfg(not(target_pointer_width = \"16\"))]\n #[inline]\n-fn repeat_byte(b: u8) -> usize {\n+const fn repeat_byte(b: u8) -> usize {\n     (b as usize) * (usize::MAX / 255)\n }\n \n /// Returns the first index matching the byte `x` in `text`.\n #[must_use]\n #[inline]\n pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n-    #[inline]\n-    fn rt_impl(x: u8, text: &[u8]) -> Option<usize> {\n-        // Fast path for small slices\n-        if text.len() < 2 * USIZE_BYTES {\n-            return text.iter().position(|elt| *elt == x);\n-        }\n-\n-        memchr_general_case(x, text)\n+    // Fast path for small slices.\n+    if text.len() < 2 * USIZE_BYTES {\n+        return memchr_naive(x, text);\n     }\n \n-    const fn const_impl(x: u8, bytes: &[u8]) -> Option<usize> {\n-        let mut i = 0;\n-        while i < bytes.len() {\n-            if bytes[i] == x {\n-                return Some(i);\n-            }\n-            i += 1;\n+    memchr_aligned(x, text)\n+}\n+\n+#[inline]\n+const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {\n+    let mut i = 0;\n+\n+    // FIXME(const-hack): Replace with `text.iter().pos(|c| *c == x)`.\n+    while i < text.len() {\n+        if text[i] == x {\n+            return Some(i);\n         }\n \n-        None\n+        i += 1;\n     }\n \n-    // SAFETY: The const and runtime versions have identical behavior\n-    unsafe { intrinsics::const_eval_select((x, text), const_impl, rt_impl) }\n+    None\n }\n \n-fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n+const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //\n     // Split `text` in three parts\n@@ -78,7 +75,7 @@ fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n \n     if offset > 0 {\n         offset = cmp::min(offset, len);\n-        if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+        if let Some(index) = memchr_naive(x, &text[..offset]) {\n             return Some(index);\n         }\n     }\n@@ -103,7 +100,8 @@ fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n     }\n \n     // Find the byte after the point the body loop stopped.\n-    text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    // FIXME(const-hack): Use `?` instead.\n+    if let Some(i) = memchr_naive(x, &text[offset..]) { Some(offset + i) } else { None }\n }\n \n /// Returns the last index matching the byte `x` in `text`."}]}