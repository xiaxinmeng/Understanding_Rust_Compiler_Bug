{"sha": "d2368c3c11ddab9d812c4ddec2e44579326ad347", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMzY4YzNjMTFkZGFiOWQ4MTJjNGRkZWMyZTQ0NTc5MzI2YWQzNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-30T08:02:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-30T08:02:39Z"}, "message": "auto merge of #20320 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "b976bc0eb040da67646a9d99bb9b901cb9f55abd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b976bc0eb040da67646a9d99bb9b901cb9f55abd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2368c3c11ddab9d812c4ddec2e44579326ad347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2368c3c11ddab9d812c4ddec2e44579326ad347", "html_url": "https://github.com/rust-lang/rust/commit/d2368c3c11ddab9d812c4ddec2e44579326ad347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2368c3c11ddab9d812c4ddec2e44579326ad347/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fea5aa656ff4349f4d3e1fea1447d26986762ae1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fea5aa656ff4349f4d3e1fea1447d26986762ae1", "html_url": "https://github.com/rust-lang/rust/commit/fea5aa656ff4349f4d3e1fea1447d26986762ae1"}, {"sha": "470ae101d6e26a6ce07292b7fca6eaed527451c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/470ae101d6e26a6ce07292b7fca6eaed527451c7", "html_url": "https://github.com/rust-lang/rust/commit/470ae101d6e26a6ce07292b7fca6eaed527451c7"}], "stats": {"total": 4426, "additions": 2803, "deletions": 1623}, "files": [{"sha": "a2394101f3a72f8a30a7cc952bd712289165fba9", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -99,7 +99,7 @@\n # This is hardly all there is to know of The Rust Build System's\n # mysteries. The tale continues on the wiki[1][2].\n #\n-# [1]: https://github.com/rust-lang/rust/wiki/Note-build-system\n+# [1]: https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\n # [2]: https://github.com/rust-lang/rust/wiki/Note-testsuite\n #\n # If you really feel like getting your hands dirty, then:"}, {"sha": "963627dbe099723f16c3cf12512f33d2d6815154", "filename": "mk/dist.mk", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -23,6 +23,8 @@\n # * dist-docs - Stage docs for upload\n \n PKG_NAME := $(CFG_PACKAGE_NAME)\n+DOC_PKG_NAME := rust-docs-$(CFG_PACKAGE_VERS)\n+MINGW_PKG_NAME := rust-mingw-$(CFG_PACKAGE_VERS)\n \n # License suitable for displaying in a popup\n LICENSE.txt: $(S)COPYRIGHT $(S)LICENSE-APACHE $(S)LICENSE-MIT\n@@ -229,10 +231,20 @@ dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)\n-\t$$(Q)[ ! -d doc ] || cp -r doc $$(PREPARE_DEST_DIR)\n+\t$$(Q)mkdir -p $$(PREPARE_DEST_DIR)/share/doc/rust\n+\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)COPYRIGHT $$(PREPARE_DEST_DIR)/share/doc/rust\n+\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)/share/doc/rust\n+\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)/share/doc/rust\n+\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)/share/doc/rust\n \n dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t@$(call E, build: $$@)\n+# Copy essential gcc components into installer\n+ifdef CFG_WINDOWSY_$(1)\n+\t$$(Q)rm -Rf dist/win-rust-gcc-$(1)\n+\t$$(Q)$$(CFG_PYTHON) $$(S)src/etc/make-win-dist.py tmp/dist/$$(PKG_NAME)-$(1)-image dist/win-rust-gcc-$(1) $(1)\n+\t$$(Q)cp -r $$(S)src/etc/third-party tmp/dist/$$(PKG_NAME)-$(1)-image/share/doc/\n+endif\n \t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n \t\t--product-name=Rust \\\n \t\t--verify-bin=rustc \\\n@@ -242,9 +254,50 @@ dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t\t--work-dir=tmp/dist \\\n \t\t--output-dir=dist \\\n \t\t--non-installed-prefixes=$$(NON_INSTALLED_PREFIXES) \\\n-\t\t--package-name=$$(PKG_NAME)-$(1)\n+\t\t--package-name=$$(PKG_NAME)-$(1) \\\n+\t\t--component-name=rustc \\\n+\t\t--legacy-manifest-dirs=rustlib,cargo\n \t$$(Q)rm -R tmp/dist/$$(PKG_NAME)-$(1)-image\n \n+dist-doc-install-dir-$(1): docs compiler-docs\n+\t$$(Q)mkdir -p tmp/dist/$$(DOC_PKG_NAME)-$(1)-image/share/doc/rust\n+\t$$(Q)cp -r doc tmp/dist/$$(DOC_PKG_NAME)-$(1)-image/share/doc/rust/html\n+\n+dist/$$(DOC_PKG_NAME)-$(1).tar.gz: dist-doc-install-dir-$(1)\n+\t@$(call E, build: $$@)\n+\t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n+\t\t--product-name=Rust-Documentation \\\n+\t\t--rel-manifest-dir=rustlib \\\n+\t\t--success-message=Rust-documentation-is-installed. \\\n+\t\t--image-dir=tmp/dist/$$(DOC_PKG_NAME)-$(1)-image \\\n+\t\t--work-dir=tmp/dist \\\n+\t\t--output-dir=dist \\\n+\t\t--package-name=$$(DOC_PKG_NAME)-$(1) \\\n+\t\t--component-name=rust-docs \\\n+\t\t--legacy-manifest-dirs=rustlib,cargo \\\n+\t\t--bulk-dirs=share/doc/rust/html\n+\t$$(Q)rm -R tmp/dist/$$(DOC_PKG_NAME)-$(1)-image\n+\n+dist-mingw-install-dir-$(1):\n+\t$$(Q)mkdir -p tmp/dist/rust-mingw-tmp-$(1)-image\n+\t$$(Q)rm -Rf tmp/dist/$$(MINGW_PKG_NAME)-$(1)-image\n+\t$$(Q)$$(CFG_PYTHON) $$(S)src/etc/make-win-dist.py \\\n+\t\ttmp/dist/rust-mingw-tmp-$(1)-image tmp/dist/$$(MINGW_PKG_NAME)-$(1)-image $(1)\n+\n+dist/$$(MINGW_PKG_NAME)-$(1).tar.gz: dist-mingw-install-dir-$(1)\n+\t@$(call E, build: $$@)\n+\t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n+\t\t--product-name=Rust-MinGW \\\n+\t\t--rel-manifest-dir=rustlib \\\n+\t\t--success-message=Rust-MinGW-is-installed. \\\n+\t\t--image-dir=tmp/dist/$$(MINGW_PKG_NAME)-$(1)-image \\\n+\t\t--work-dir=tmp/dist \\\n+\t\t--output-dir=dist \\\n+\t\t--package-name=$$(MINGW_PKG_NAME)-$(1) \\\n+\t\t--component-name=rust-mingw \\\n+\t\t--legacy-manifest-dirs=rustlib,cargo\n+\t$$(Q)rm -R tmp/dist/$$(MINGW_PKG_NAME)-$(1)-image\n+\n endef\n \n ifneq ($(CFG_ENABLE_DIST_HOST_ONLY),)\n@@ -257,7 +310,16 @@ endif\n \n dist-install-dirs: $(foreach host,$(CFG_HOST),dist-install-dir-$(host))\n \n-dist-tar-bins: $(foreach host,$(CFG_HOST),dist/$(PKG_NAME)-$(host).tar.gz)\n+ifdef CFG_WINDOWSY_$(CFG_BUILD)\n+MAYBE_MINGW_TARBALLS=$(foreach host,$(CFG_HOST),dist/$(MINGW_PKG_NAME)-$(host).tar.gz)\n+endif\n+\n+ifeq ($(CFG_DISABLE_DOCS),)\n+MAYBE_DOC_TARBALLS=$(foreach host,$(CFG_HOST),dist/$(DOC_PKG_NAME)-$(host).tar.gz)\n+endif\n+\n+dist-tar-bins: $(foreach host,$(CFG_HOST),dist/$(PKG_NAME)-$(host).tar.gz) \\\n+\t$(MAYBE_DOC_TARBALLS) $(MAYBE_MINGW_TARBALLS)\n \n # Just try to run the compiler for the build host\n distcheck-tar-bins: dist-tar-bins\n@@ -289,27 +351,20 @@ distcheck-docs: dist-docs\n # Primary targets (dist, distcheck)\n ######################################################################\n \n-ifdef CFG_WINDOWSY_$(CFG_BUILD)\n-\n-dist: dist-win dist-tar-bins\n-\n-distcheck: distcheck-win\n-\t$(Q)rm -Rf tmp/distcheck\n-\t@echo\n-\t@echo -----------------------------------------------\n-\t@echo \"Rust ready for distribution (see ./dist)\"\n-\t@echo -----------------------------------------------\n-\n-else\n+MAYBE_DIST_TAR_SRC=dist-tar-src\n+MAYBE_DISTCHECK_TAR_SRC=distcheck-tar-src\n \n # FIXME #13224: On OS X don't produce tarballs simply because --exclude-vcs don't work.\n # This is a huge hack because I just don't have time to figure out another solution.\n ifeq ($(CFG_OSTYPE), apple-darwin)\n MAYBE_DIST_TAR_SRC=\n MAYBE_DISTCHECK_TAR_SRC=\n-else\n-MAYBE_DIST_TAR_SRC=dist-tar-src\n-MAYBE_DISTCHECK_TAR_SRC=distcheck-tar-src\n+endif\n+\n+# Don't bother with source tarballs on windows just because we historically haven't.\n+ifeq ($(CFG_OSTYPE), pc-windows-gnu)\n+MAYBE_DIST_TAR_SRC=\n+MAYBE_DISTCHECK_TAR_SRC=\n endif\n \n ifneq ($(CFG_DISABLE_DOCS),)\n@@ -320,15 +375,13 @@ MAYBE_DIST_DOCS=dist-docs\n MAYBE_DISTCHECK_DOCS=distcheck-docs\n endif\n \n-dist: $(MAYBE_DIST_TAR_SRC) dist-osx dist-tar-bins $(MAYBE_DIST_DOCS)\n+dist: $(MAYBE_DIST_TAR_SRC) dist-osx dist-win dist-tar-bins $(MAYBE_DIST_DOCS)\n \n-distcheck: $(MAYBE_DISTCHECK_TAR_SRC) distcheck-osx distcheck-tar-bins $(MAYBE_DISTCHECK_DOCS)\n+distcheck: $(MAYBE_DISTCHECK_TAR_SRC) distcheck-osx distcheck-win distcheck-tar-bins $(MAYBE_DISTCHECK_DOCS)\n \t$(Q)rm -Rf tmp/distcheck\n \t@echo\n \t@echo -----------------------------------------------\n \t@echo \"Rust ready for distribution (see ./dist)\"\n \t@echo -----------------------------------------------\n \n-endif\n-\n .PHONY: dist distcheck"}, {"sha": "08461f9dcc2b760c895a92d6a35a659ebeca782d", "filename": "mk/grammar.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Fgrammar.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Fgrammar.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fgrammar.mk?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -31,7 +31,7 @@ $(BG):\n \t$(Q)mkdir -p $(BG)\n \n $(BG)RustLexer.class: $(BG) $(SG)RustLexer.g4\n-\t$(Q)$(CFG_ANTLR4) -o $(B)grammar $(SG)RustLexer.g4\n+\t$(Q)$(CFG_ANTLR4) -o $(BG) $(SG)RustLexer.g4\n \t$(Q)$(CFG_JAVAC) -d $(BG) $(BG)RustLexer.java\n \n check-build-lexer-verifier: $(BG)verify"}, {"sha": "f36ca4db7ca7ef13eddcbaa26cc46c5fc2e81af1", "filename": "mk/install.mk", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -20,6 +20,9 @@ ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n \t$(Q)sudo -u \"$$SUDO_USER\" $(MAKE) prepare_install\n else\n \t$(Q)$(MAKE) prepare_install\n+endif\n+ifeq ($(CFG_DISABLE_DOCS),)\n+\t$(Q)cd tmp/empty_dir && sh ../../tmp/dist/$(DOC_PKG_NAME)-$(CFG_BUILD)/install.sh --prefix=\"$(DESTDIR)$(CFG_PREFIX)\" --libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" --mandir=\"$(DESTDIR)$(CFG_MANDIR)\" \"$(MAYBE_DISABLE_VERIFY)\"\n endif\n \t$(Q)cd tmp/empty_dir && sh ../../tmp/dist/$(PKG_NAME)-$(CFG_BUILD)/install.sh --prefix=\"$(DESTDIR)$(CFG_PREFIX)\" --libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" --mandir=\"$(DESTDIR)$(CFG_MANDIR)\" \"$(MAYBE_DISABLE_VERIFY)\"\n # Remove tmp files because it's a decent amount of disk space\n@@ -33,6 +36,9 @@ ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n \t$(Q)sudo -u \"$$SUDO_USER\" $(MAKE) prepare_uninstall\n else\n \t$(Q)$(MAKE) prepare_uninstall\n+endif\n+ifeq ($(CFG_DISABLE_DOCS),)\n+\t$(Q)cd tmp/empty_dir && sh ../../tmp/dist/$(DOC_PKG_NAME)-$(CFG_BUILD)/install.sh --uninstall --prefix=\"$(DESTDIR)$(CFG_PREFIX)\" --libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" --mandir=\"$(DESTDIR)$(CFG_MANDIR)\"\n endif\n \t$(Q)cd tmp/empty_dir && sh ../../tmp/dist/$(PKG_NAME)-$(CFG_BUILD)/install.sh --uninstall --prefix=\"$(DESTDIR)$(CFG_PREFIX)\" --libdir=\"$(DESTDIR)$(CFG_LIBDIR)\" --mandir=\"$(DESTDIR)$(CFG_MANDIR)\"\n # Remove tmp files because it's a decent amount of disk space"}, {"sha": "bf07d6de0e026eb766a27eeda227a63082f806af", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -74,14 +74,6 @@ endif\n TEST_LOG_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n TEST_OK_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).ok\n \n-# If we're sharding the testsuite between parallel testers,\n-# pass this argument along to the compiletest and crate test\n-# invocations.\n-ifdef TEST_SHARD\n-  CTEST_TESTARGS += --test-shard=$(TEST_SHARD)\n-  CRATE_TEST_EXTRA_ARGS += --test-shard=$(TEST_SHARD)\n-endif\n-\n define DEF_TARGET_COMMANDS\n \n ifdef CFG_UNIXY_$(1)\n@@ -297,6 +289,7 @@ tidy:\n \t\t| grep '^$(S)src/doc' -v \\\n \t\t| grep '^$(S)src/compiler-rt' -v \\\n \t\t| grep '^$(S)src/libbacktrace' -v \\\n+\t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \n endif"}, {"sha": "29c98e22ee9788d70fb19cecbcc0d9bb929ad5c4", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1,6 +1,6 @@\n-% The Rust Tasks and Communication Guide\n+% The Rust Threads and Communication Guide\n \n-**NOTE** This guide is badly out of date an needs to be rewritten.\n+**NOTE** This guide is badly out of date and needs to be rewritten.\n \n # Introduction\n \n@@ -9,36 +9,36 @@ primitives. This guide will describe the concurrency model in Rust, how it\n relates to the Rust type system, and introduce the fundamental library\n abstractions for constructing concurrent programs.\n \n-Tasks provide failure isolation and recovery. When a fatal error occurs in Rust\n+Threads provide failure isolation and recovery. When a fatal error occurs in Rust\n code as a result of an explicit call to `panic!()`, an assertion failure, or\n-another invalid operation, the runtime system destroys the entire task. Unlike\n+another invalid operation, the runtime system destroys the entire thread. Unlike\n in languages such as Java and C++, there is no way to `catch` an exception.\n-Instead, tasks may monitor each other to see if they panic.\n+Instead, threads may monitor each other to see if they panic.\n \n-Tasks use Rust's type system to provide strong memory safety guarantees.  In\n-particular, the type system guarantees that tasks cannot induce a data race\n+Threads use Rust's type system to provide strong memory safety guarantees.  In\n+particular, the type system guarantees that threads cannot induce a data race\n from shared mutable state.\n \n # Basics\n \n-At its simplest, creating a task is a matter of calling the `spawn` function\n-with a closure argument. `spawn` executes the closure in the new task.\n+At its simplest, creating a thread is a matter of calling the `spawn` function\n+with a closure argument. `spawn` executes the closure in the new thread.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n \n-// Print something profound in a different task using a named function\n-fn print_message() { println!(\"I am running in a different task!\"); }\n+// Print something profound in a different thread using a named function\n+fn print_message() { println!(\"I am running in a different thread!\"); }\n spawn(print_message);\n \n // Alternatively, use a `move ||` expression instead of a named function.\n // `||` expressions evaluate to an unnamed closure. The `move` keyword\n // indicates that the closure should take ownership of any variables it\n // touches.\n-spawn(move || println!(\"I am also running in a different task!\"));\n+spawn(move || println!(\"I am also running in a different thread!\"));\n ```\n \n-In Rust, a task is not a concept that appears in the language semantics.\n+In Rust, a thread is not a concept that appears in the language semantics.\n Instead, Rust's type system provides all the tools necessary to implement safe\n concurrency: particularly, ownership. The language leaves the implementation\n details to the standard library.\n@@ -49,26 +49,26 @@ argument a closure (of type `F`) that it will run exactly once. This\n closure is limited to capturing `Send`-able data from its environment\n (that is, data which is deeply owned). Limiting the closure to `Send`\n ensures that `spawn` can safely move the entire closure and all its\n-associated state into an entirely different task for execution.\n+associated state into an entirely different thread for execution.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n-# fn generate_task_number() -> int { 0 }\n+# use std::thread::spawn;\n+# fn generate_thread_number() -> int { 0 }\n // Generate some state locally\n-let child_task_number = generate_task_number();\n+let child_thread_number = generate_thread_number();\n \n spawn(move || {\n-    // Capture it in the remote task. The `move` keyword indicates\n-    // that this closure should move `child_task_number` into its\n+    // Capture it in the remote thread. The `move` keyword indicates\n+    // that this closure should move `child_thread_number` into its\n     // environment, rather than capturing a reference into the\n     // enclosing stack frame.\n-    println!(\"I am child number {}\", child_task_number);\n+    println!(\"I am child number {}\", child_thread_number);\n });\n ```\n \n ## Communication\n \n-Now that we have spawned a new task, it would be nice if we could communicate\n+Now that we have spawned a new thread, it would be nice if we could communicate\n with it. For this, we use *channels*. A channel is simply a pair of endpoints:\n one for sending messages and another for receiving messages.\n \n@@ -78,7 +78,7 @@ of a channel, and a **receiver** is the receiving endpoint. Consider the followi\n example of calculating two results concurrently:\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n \n@@ -102,12 +102,12 @@ into its component parts).\n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n ```\n \n-The child task will use the sender to send data to the parent task, which will\n+The child thread will use the sender to send data to the parent thread, which will\n wait to receive the data on the receiver. The next statement spawns the child\n-task.\n+thread.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n spawn(move || {\n@@ -116,10 +116,10 @@ spawn(move || {\n });\n ```\n \n-Notice that the creation of the task closure transfers `tx` to the child task\n+Notice that the creation of the thread closure transfers `tx` to the child thread\n implicitly: the closure captures `tx` in its environment. Both `Sender` and\n-`Receiver` are sendable types and may be captured into tasks or otherwise\n-transferred between them. In the example, the child task runs an expensive\n+`Receiver` are sendable types and may be captured into threads or otherwise\n+transferred between them. In the example, the child thread runs an expensive\n computation, then sends the result over the captured channel.\n \n Finally, the parent continues with some other expensive computation, then waits\n@@ -137,7 +137,7 @@ The `Sender` and `Receiver` pair created by `channel` enables efficient\n communication between a single sender and a single receiver, but multiple\n senders cannot use a single `Sender` value, and multiple receivers cannot use a\n single `Receiver` value.  What if our example needed to compute multiple\n-results across a number of tasks? The following program is ill-typed:\n+results across a number of threads? The following program is ill-typed:\n \n ```{rust,ignore}\n # fn some_expensive_computation() -> int { 42 }\n@@ -160,7 +160,7 @@ Instead we can clone the `tx`, which allows for multiple senders.\n let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n-    // Create a new channel handle to distribute to the child task\n+    // Create a new channel handle to distribute to the child thread\n     let child_tx = tx.clone();\n     spawn(move || {\n         child_tx.send(some_expensive_computation(init_val));\n@@ -172,7 +172,7 @@ let result = rx.recv() + rx.recv() + rx.recv();\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n-tasks to send data to a single receiver. It upgrades the channel internally in\n+threads to send data to a single receiver. It upgrades the channel internally in\n order to allow this functionality, which means that channels that are not\n cloned can avoid the overhead required to handle multiple senders. But this\n fact has no bearing on the channel's usage: the upgrade is transparent.\n@@ -182,9 +182,9 @@ simply use three `Sender` pairs, but it serves to illustrate the point. For\n reference, written with multiple streams, it might look like the example below.\n \n ```{rust,ignore}\n-# use std::task::spawn;\n+# use std::thread::spawn;\n \n-// Create a vector of ports, one for each child task\n+// Create a vector of ports, one for each child thread\n let rxs = Vec::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n     spawn(move || {\n@@ -256,18 +256,18 @@ fn main() {\n \n ## Sharing without copying: Arc\n \n-To share data between tasks, a first approach would be to only use channel as\n+To share data between threads, a first approach would be to only use channel as\n we have seen previously. A copy of the data to share would then be made for\n-each task. In some cases, this would add up to a significant amount of wasted\n+each thread. In some cases, this would add up to a significant amount of wasted\n memory and would require copying the same data more than necessary.\n \n To tackle this issue, one can use an Atomically Reference Counted wrapper\n (`Arc`) as implemented in the `sync` library of Rust. With an Arc, the data\n-will no longer be copied for each task. The Arc acts as a reference to the\n+will no longer be copied for each thread. The Arc acts as a reference to the\n shared data and only this reference is shared and cloned.\n \n Here is a small example showing how to use Arcs. We wish to run concurrently\n-several computations on a single large vector of floats. Each task needs the\n+several computations on a single large vector of floats. Each thread needs the\n full vector to perform its duty.\n \n ```{rust,ignore}\n@@ -284,10 +284,10 @@ fn main() {\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n-        let task_numbers = numbers_arc.clone();\n+        let thread_numbers = numbers_arc.clone();\n \n         spawn(move || {\n-            println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n+            println!(\"{}-norm = {}\", num, pnorm(thread_numbers.as_slice(), num));\n         });\n     }\n }\n@@ -306,8 +306,8 @@ let numbers_arc = Arc::new(numbers);\n # }\n ```\n \n-and a clone is captured for each task via a procedure. This only copies\n-the wrapper and not its contents. Within the task's procedure, the captured\n+and a clone is captured for each thread via a procedure. This only copies\n+the wrapper and not its contents. Within the thread's procedure, the captured\n Arc reference can be used as a shared reference to the underlying vector as\n if it were local.\n \n@@ -319,29 +319,29 @@ if it were local.\n # let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n # let num = 4;\n-let task_numbers = numbers_arc.clone();\n+let thread_numbers = numbers_arc.clone();\n spawn(move || {\n-    // Capture task_numbers and use it as if it was the underlying vector\n-    println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n+    // Capture thread_numbers and use it as if it was the underlying vector\n+    println!(\"{}-norm = {}\", num, pnorm(thread_numbers.as_slice(), num));\n });\n # }\n ```\n \n-# Handling task panics\n+# Handling thread panics\n \n Rust has a built-in mechanism for raising exceptions. The `panic!()` macro\n (which can also be written with an error string as an argument: `panic!(\n ~reason)`) and the `assert!` construct (which effectively calls `panic!()` if a\n-boolean expression is false) are both ways to raise exceptions. When a task\n-raises an exception, the task unwinds its stack\u2014running destructors and\n+boolean expression is false) are both ways to raise exceptions. When a thread\n+raises an exception, the thread unwinds its stack\u2014running destructors and\n freeing memory along the way\u2014and then exits. Unlike exceptions in C++,\n-exceptions in Rust are unrecoverable within a single task: once a task panics,\n+exceptions in Rust are unrecoverable within a single thread: once a thread panics,\n there is no way to \"catch\" the exception.\n \n-While it isn't possible for a task to recover from panicking, tasks may notify\n+While it isn't possible for a thread to recover from panicking, threads may notify\n each other if they panic. The simplest way of handling a panic is with the\n `try` function, which is similar to `spawn`, but immediately blocks and waits\n-for the child task to finish. `try` returns a value of type\n+for the child thread to finish. `try` returns a value of type\n `Result<T, Box<Any + Send>>`. `Result` is an `enum` type with two variants:\n `Ok` and `Err`. In this case, because the type arguments to `Result` are `int`\n and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n@@ -364,19 +364,19 @@ assert!(result.is_err());\n \n Unlike `spawn`, the function spawned using `try` may return a value, which\n `try` will dutifully propagate back to the caller in a [`Result`] enum. If the\n-child task terminates successfully, `try` will return an `Ok` result; if the\n-child task panics, `try` will return an `Error` result.\n+child thread terminates successfully, `try` will return an `Ok` result; if the\n+child thread panics, `try` will return an `Error` result.\n \n [`Result`]: std/result/index.html\n \n-> *Note:* A panicked task does not currently produce a useful error\n+> *Note:* A panicked thread does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the\n-> future, it may be possible for tasks to intercept the value passed to\n+> future, it may be possible for threads to intercept the value passed to\n > `panic!()`.\n \n But not all panics are created equal. In some cases you might need to abort\n the entire program (perhaps you're writing an assert which, if it trips,\n indicates an unrecoverable logic error); in other cases you might want to\n contain the panic at a certain boundary (perhaps a small piece of input from\n the outside world, which you happen to be processing in parallel, is malformed\n-such that the processing task cannot proceed).\n+such that the processing thread cannot proceed)."}, {"sha": "d094c47da93bb3f1386e61ae2dd9d210cdf23e0a", "filename": "src/doc/guide.md", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -23,11 +23,16 @@ Linux or a Mac, all you need to do is this (note that you don't need to type\n in the `$`s, they just indicate the start of each command):\n \n ```bash\n-$ curl -s https://static.rust-lang.org/rustup.sh | sudo sh\n+curl -L https://static.rust-lang.org/rustup.sh | sudo sh\n ```\n \n-(If you're concerned about `curl | sudo sh`, please keep reading. Disclaimer\n-below.)\n+If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`, \n+please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:\n+\n+```bash\n+curl -L https://static.rust-lang.org/rustup.sh -O\n+sudo sh rustup.sh\n+```\n \n If you're on Windows, please download either the [32-bit\n installer](https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.exe)\n@@ -482,7 +487,7 @@ src/main.rs:2     let x;\n \n Giving it a type will compile, though:\n \n-```{ignore}\n+```{rust}\n let x: int;\n ```\n \n@@ -1044,7 +1049,9 @@ struct Point(int, int, int);\n \n These two will not be equal, even if they have the same values:\n \n-```{rust,ignore}\n+```{rust}\n+# struct Color(int, int, int);\n+# struct Point(int, int, int);\n let black  = Color(0, 0, 0);\n let origin = Point(0, 0, 0);\n ```\n@@ -1604,10 +1611,6 @@ let a = [1i, 2i, 3i];     // a: [int, ..3]\n let mut m = [1i, 2i, 3i]; // mut m: [int, ..3]\n ```\n \n-You can create an array with a given number of elements, all initialized to the\n-same value, with `[val, ..N]` syntax. The compiler ensures that arrays are\n-always initialized.\n-\n There's a shorthand for initializing each element of an array to the same\n value. In this example, each element of `a` will be initialized to `0i`:\n \n@@ -1895,7 +1898,7 @@ authors = [\"Your Name <you@example.com>\"]\n Cargo gets this information from your environment. If it's not correct, go ahead\n and fix that.\n \n-Finally, Cargo generated a hello, world for us. Check out `src/main.rs`:\n+Finally, Cargo generated a \"Hello, world!\" for us. Check out `src/main.rs`:\n \n ```{rust}\n fn main() {\n@@ -3036,7 +3039,7 @@ test foo ... FAILED\n failures:\n \n ---- foo stdout ----\n-        task 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n+        thread 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n \n \n \n@@ -3045,7 +3048,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n+thread '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n ```\n \n Lots of output! Let's break this down:\n@@ -3088,7 +3091,7 @@ failed, especially as we accumulate more tests.\n failures:\n \n ---- foo stdout ----\n-        task 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n+        thread 'foo' failed at 'assertion failed: false', /home/you/projects/testing/tests/lib.rs:3\n \n \n \n@@ -3097,7 +3100,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n+thread '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n ```\n \n After all the tests run, Rust will show us any output from our failed tests.\n@@ -4263,7 +4266,7 @@ is that a moving closure always takes ownership of all variables that\n it uses. Ordinary closures, in contrast, just create a reference into\n the enclosing stack frame. Moving closures are most useful with Rust's\n concurrency features, and so we'll just leave it at this for\n-now. We'll talk about them more in the \"Tasks\" section of the guide.\n+now. We'll talk about them more in the \"Threads\" section of the guide.\n \n ## Accepting closures as arguments\n \n@@ -4290,7 +4293,9 @@ let square = |x: int| { x * x };\n We've seen this before. We make a closure that takes an integer, and returns\n its square.\n \n-```{rust,ignore}\n+```{rust}\n+# fn twice(x: int, f: |int| -> int) -> int { f(x) + f(x) }\n+# let square = |x: int| { x * x };\n twice(5i, square); // evaluates to 50\n ```\n \n@@ -5213,9 +5218,7 @@ as you can see, there's no overhead of deciding which version to call here,\n hence 'statically dispatched'. The downside is that we have two copies of\n the same function, so our binary is a little bit larger.\n \n-# Tasks\n-\n-**NOTE**: this section is currently out of date and will be rewritten soon.\n+# Threads \n \n Concurrency and parallelism are topics that are of increasing interest to a\n broad subsection of software developers. Modern computers are often multi-core,\n@@ -5224,24 +5227,22 @@ processor. Rust's semantics lend themselves very nicely to solving a number of\n issues that programmers have with concurrency. Many concurrency errors that are\n runtime errors in other languages are compile-time errors in Rust.\n \n-Rust's concurrency primitive is called a **task**. Tasks are similar to\n-threads, and do not share memory in an unsafe manner, preferring message\n-passing to communicate. It's worth noting that tasks are implemented as a\n-library, and not part of the language. This means that in the future, other\n-concurrency libraries can be written for Rust to help in specific scenarios.\n-Here's an example of creating a task:\n+Rust's concurrency primitive is called a **thread**. It's worth noting that\n+threads are implemented as a library, and not part of the language. This means\n+that in the future, other concurrency libraries can be written for Rust to help\n+in specific scenarios. Here's an example of creating a thread:\n \n ```{rust,ignore}\n spawn(move || {\n-    println!(\"Hello from a task!\");\n+    println!(\"Hello from a thread!\");\n });\n ```\n \n The `spawn` function takes a closure as an argument, and runs that\n-closure in a new task. Typically, you will want to use a moving\n+closure in a new thread. Typically, you will want to use a moving\n closure, so that the closure takes ownership of any variables that it\n touches.  This implies that those variables are not usable from the\n-parent task after the child task is spawned:\n+parent thread after the child thread is spawned:\n \n ```{rust,ignore}\n let mut x = vec![1i, 2i, 3i];\n@@ -5257,15 +5258,15 @@ println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n other languages would let us do this, but it's not safe to do\n so. Rust's borrow checker catches the error.\n \n-If tasks were only able to capture these values, they wouldn't be very useful.\n-Luckily, tasks can communicate with each other through **channel**s. Channels\n+If threads were only able to capture these values, they wouldn't be very useful.\n+Luckily, threads can communicate with each other through **channel**s. Channels\n work like this:\n \n ```{rust,ignore}\n let (tx, rx) = channel();\n \n spawn(move || {\n-    tx.send(\"Hello from a task!\".to_string());\n+    tx.send(\"Hello from a thread!\".to_string());\n });\n \n let message = rx.recv();\n@@ -5278,14 +5279,14 @@ receive the message on the `Receiver<T>` side with the `recv()` method.  This\n method blocks until it gets a message. There's a similar method, `.try_recv()`,\n which returns an `Result<T, TryRecvError>` and does not block.\n \n-If you want to send messages to the task as well, create two channels!\n+If you want to send messages to the thread as well, create two channels!\n \n ```{rust,ignore}\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n spawn(move || {\n-    tx1.send(\"Hello from a task!\".to_string());\n+    tx1.send(\"Hello from a thread!\".to_string());\n     let message = rx2.recv();\n     println!(\"{}\", message);\n });\n@@ -5296,9 +5297,9 @@ println!(\"{}\", message);\n tx2.send(\"Goodbye from main!\".to_string());\n ```\n \n-The closure has one sending end and one receiving end, and the main\n-task has one of each as well. Now they can talk back and forth in\n-whatever way they wish.\n+The closure has one sending end and one receiving end, and the main thread has\n+one of each as well. Now they can talk back and forth in whatever way they\n+wish.\n \n Notice as well that because `Sender` and `Receiver` are generic, while you can\n pass any kind of information through the channel, the ends are strongly typed.\n@@ -5337,7 +5338,7 @@ we'll just get the value immediately.\n \n ## Success and failure\n \n-Tasks don't always succeed, they can also panic. A task that wishes to panic\n+Threads don't always succeed, they can also panic. A thread that wishes to panic\n can call the `panic!` macro, passing a message:\n \n ```{rust,ignore}\n@@ -5346,14 +5347,14 @@ spawn(move || {\n });\n ```\n \n-If a task panics, it is not possible for it to recover. However, it can\n-notify other tasks that it has panicked. We can do this with `task::try`:\n+If a thread panics, it is not possible for it to recover. However, it can\n+notify other thread that it has panicked. We can do this with `thread::try`:\n \n ```{rust,ignore}\n-use std::task;\n+use std::thread;\n use std::rand;\n \n-let result = task::try(move || {\n+let result = thread::try(move || {\n     if rand::random() {\n         println!(\"OK\");\n     } else {\n@@ -5362,7 +5363,7 @@ let result = task::try(move || {\n });\n ```\n \n-This task will randomly panic or succeed. `task::try` returns a `Result`\n+This thread will randomly panic or succeed. `thread::try` returns a `Result`\n type, so we can handle the response like any other computation that may\n fail.\n \n@@ -5410,7 +5411,7 @@ fn main() {\n }\n ```\n \n-You can have the macros expanded like this: `rustc print.rs --pretty=expanded`, which will\n+You can have the macros expanded like this: `rustc --pretty=expanded print.rs`, which will\n give us this huge result:\n \n ```{rust,ignore}"}, {"sha": "e54bf0eb24282d3670d04549bbf752b6a73ce4ab", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -58,7 +58,7 @@ a guide that can help you out:\n * [Strings](guide-strings.html)\n * [Pointers](guide-pointers.html)\n * [Crates and modules](guide-crates.html)\n-* [Tasks and Communication](guide-tasks.html)\n+* [Threads and Communication](guide-threads.html)\n * [Error Handling](guide-error-handling.html)\n * [Foreign Function Interface](guide-ffi.html)\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)"}, {"sha": "a4e9d85bffdf8eb203e0de8dc2f0319b06e1b130", "filename": "src/doc/intro.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -483,7 +483,7 @@ fn main() {\n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n-            let mut array = number.lock();\n+            let mut array = number.lock().unwrap();\n \n             (*array)[i] += 1;\n "}, {"sha": "94c76aaa69518aa37f461c9156d0427bbb64791a", "filename": "src/doc/reference.md", "status": "modified", "additions": 56, "deletions": 59, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -194,11 +194,11 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n | else     | enum     | extern   | false    | final   |\n | fn       | for      | if       | impl     | in      |\n | let      | loop     | match    | mod      | move    |\n-| mut      | offsetof | once     | override | priv    |\n-| pub      | pure     | ref      | return   | sizeof  |\n-| static   | self     | struct   | super    | true    |\n-| trait    | type     | typeof   | unsafe   | unsized |\n-| use      | virtual  | where    | while    | yield   |\n+| mut      | offsetof | override | priv     | pub     |\n+| pure     | ref      | return   | sizeof   | static  |\n+| self     | struct   | super    | true     | trait   |\n+| type     | typeof   | unsafe   | unsized  | use     |\n+| virtual  | where    | while    | yield    |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -899,8 +899,8 @@ mirrors the module hierarchy.\n // Load the `vec` module from `vec.rs`\n mod vec;\n \n-mod task {\n-    // Load the `local_data` module from `task/local_data.rs`\n+mod thread {\n+    // Load the `local_data` module from `thread/local_data.rs`\n     mod local_data;\n }\n ```\n@@ -909,9 +909,9 @@ The directories and files used for loading external file modules can be\n influenced with the `path` attribute.\n \n ```{.ignore}\n-#[path = \"task_files\"]\n-mod task {\n-    // Load the `local_data` module from `task_files/tls.rs`\n+#[path = \"thread_files\"]\n+mod thread {\n+    // Load the `local_data` module from `thread_files/tls.rs`\n     #[path = \"tls.rs\"]\n     mod local_data;\n }\n@@ -1188,7 +1188,7 @@ code safe, in the surrounding context.\n Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n or implement features not directly present in the language. For example, Rust\n provides the language features necessary to implement memory-safe concurrency\n-in the language but the implementation of tasks and message passing is in the\n+in the language but the implementation of threads and message passing is in the\n standard library.\n \n Rust's type system is a conservative approximation of the dynamic safety\n@@ -1500,7 +1500,7 @@ be modified by the program. One of Rust's goals is to make concurrency bugs\n hard to run into, and this is obviously a very large source of race conditions\n or other bugs. For this reason, an `unsafe` block is required when either\n reading or writing a mutable static variable. Care should be taken to ensure\n-that modifications to a mutable static are safe with respect to other tasks\n+that modifications to a mutable static are safe with respect to other threads\n running in the same process.\n \n Mutable statics are still very useful, however. They can be used with C\n@@ -2253,11 +2253,11 @@ A complete list of the built-in language items follows:\n * `drop`\n   : Have destructors.\n * `send`\n-  : Able to be sent across task boundaries.\n+  : Able to be sent across thread boundaries.\n * `sized`\n   : Has a size known at compile time.\n * `sync`\n-  : Able to be safely shared between tasks when aliased.\n+  : Able to be safely shared between threads when aliased.\n \n #### Operators\n \n@@ -2621,7 +2621,7 @@ The currently implemented features of the reference compiler are:\n                    LLVM's implementation which works in concert with the kernel\n                    loader and dynamic linker. This is not necessarily available\n                    on all platforms, and usage of it is discouraged (rust\n-                   focuses more on task-local data instead of thread-local\n+                   focuses more on thread-local data instead of thread-local\n                    data).\n \n * `trace_macros` - Allows use of the `trace_macros` macro, which is a nasty\n@@ -2939,7 +2939,7 @@ array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can\n be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access is\n-bounds-checked at run-time. When the check fails, it will put the task in a\n+bounds-checked at run-time. When the check fails, it will put the thread in a\n _panicked state_.\n \n ```{should-fail}\n@@ -3950,7 +3950,7 @@ Types in Rust are categorized into kinds, based on various properties of the\n components of the type. The kinds are:\n \n * `Send`\n-  : Types of this kind can be safely sent between tasks.\n+  : Types of this kind can be safely sent between threads.\n     This kind includes scalars, boxes, procs, and\n     structural types containing only other owned types.\n     All `Send` types are `'static`.\n@@ -3998,21 +3998,21 @@ to sendable.\n \n # Memory and concurrency models\n \n-Rust has a memory model centered around concurrently-executing _tasks_. Thus\n+Rust has a memory model centered around concurrently-executing _threads_. Thus\n its memory model and its concurrency model are best discussed simultaneously,\n as parts of each only make sense when considered from the perspective of the\n other.\n \n When reading about the memory model, keep in mind that it is partitioned in\n-order to support tasks; and when reading about tasks, keep in mind that their\n+order to support threads; and when reading about threads, keep in mind that their\n isolation and communication mechanisms are only possible due to the ownership\n and lifetime semantics of the memory model.\n \n ## Memory model\n \n A Rust program's memory consists of a static set of *items*, a set of\n-[tasks](#tasks) each with its own *stack*, and a *heap*. Immutable portions of\n-the heap may be shared between tasks, mutable portions may not.\n+[threads](#threads) each with its own *stack*, and a *heap*. Immutable portions of\n+the heap may be shared between threads, mutable portions may not.\n \n Allocations in the stack consist of *slots*, and allocations in the heap\n consist of *boxes*.\n@@ -4023,8 +4023,8 @@ The _items_ of a program are those functions, modules and types that have their\n value calculated at compile-time and stored uniquely in the memory image of the\n rust process. Items are neither dynamically allocated nor freed.\n \n-A task's _stack_ consists of activation frames automatically allocated on entry\n-to each function as the task executes. A stack allocation is reclaimed when\n+A thread's _stack_ consists of activation frames automatically allocated on entry\n+to each function as the thread executes. A stack allocation is reclaimed when\n control leaves the frame containing it.\n \n The _heap_ is a general term that describes boxes.  The lifetime of an\n@@ -4034,10 +4034,10 @@ in the heap, heap allocations may outlive the frame they are allocated within.\n \n ### Memory ownership\n \n-A task owns all memory it can *safely* reach through local variables, as well\n+A thread owns all memory it can *safely* reach through local variables, as well\n as boxes and references.\n \n-When a task sends a value that has the `Send` trait to another task, it loses\n+When a thread sends a value that has the `Send` trait to another thread, it loses\n ownership of the value sent and can no longer refer to it. This is statically\n guaranteed by the combined use of \"move semantics\", and the compiler-checked\n _meaning_ of the `Send` trait: it is only instantiated for (transitively)\n@@ -4046,12 +4046,12 @@ sendable kinds of data constructor and pointers, never including references.\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-When a task finishes, its stack is necessarily empty and it therefore has no\n+When a thread finishes, its stack is necessarily empty and it therefore has no\n references to any boxes; the remainder of its heap is immediately freed.\n \n ### Memory slots\n \n-A task's stack contains slots.\n+A thread's stack contains slots.\n \n A _slot_ is a component of a stack frame, either a function parameter, a\n [temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n@@ -4105,72 +4105,69 @@ let y = x;\n // attempting to use `x` will result in an error here\n ```\n \n-## Tasks\n+## Threads\n \n-An executing Rust program consists of a tree of tasks. A Rust _task_ consists\n-of an entry function, a stack, a set of outgoing communication channels and\n-incoming communication ports, and ownership of some portion of the heap of a\n-single operating-system process.\n+Rust's primary concurrency mechanism is called a **thread**.\n \n-### Communication between tasks\n+### Communication between threads\n \n-Rust tasks are isolated and generally unable to interfere with one another's\n+Rust threads are isolated and generally unable to interfere with one another's\n memory directly, except through [`unsafe` code](#unsafe-functions).  All\n-contact between tasks is mediated by safe forms of ownership transfer, and data\n+contact between threads is mediated by safe forms of ownership transfer, and data\n races on memory are prohibited by the type system.\n \n-When you wish to send data between tasks, the values are restricted to the\n+When you wish to send data between threads, the values are restricted to the\n [`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n-kind ensures that no references move between tasks. Thus access to an entire\n+kind ensures that no references move between threads. Thus access to an entire\n data structure can be mediated through its owning \"root\" value; no further\n locking or copying is required to avoid data races within the substructure of\n such a value.\n \n-### Task lifecycle\n+### Thread\n \n-The _lifecycle_ of a task consists of a finite set of states and events that\n-cause transitions between the states. The lifecycle states of a task are:\n+The _lifecycle_ of a threads consists of a finite set of states and events that\n+cause transitions between the states. The lifecycle states of a thread are:\n \n * running\n * blocked\n * panicked\n * dead\n \n-A task begins its lifecycle &mdash; once it has been spawned &mdash; in the\n+A thread begins its lifecycle &mdash; once it has been spawned &mdash; in the\n *running* state. In this state it executes the statements of its entry\n function, and any functions called by the entry function.\n \n-A task may transition from the *running* state to the *blocked* state any time\n+A thread may transition from the *running* state to the *blocked* state any time\n it makes a blocking communication call. When the call can be completed &mdash;\n when a message arrives at a sender, or a buffer opens to receive a message\n-&mdash; then the blocked task will unblock and transition back to *running*.\n+&mdash; then the blocked thread will unblock and transition back to *running*.\n \n-A task may transition to the *panicked* state at any time, due being killed by\n+A thread may transition to the *panicked* state at any time, due being killed by\n some external event or internally, from the evaluation of a `panic!()` macro.\n-Once *panicking*, a task unwinds its stack and transitions to the *dead* state.\n-Unwinding the stack of a task is done by the task itself, on its own control\n+Once *panicking*, a thread unwinds its stack and transitions to the *dead* state.\n+Unwinding the stack of a thread is done by the thread itself, on its own control\n stack. If a value with a destructor is freed during unwinding, the code for the\n-destructor is run, also on the task's control stack. Running the destructor\n+destructor is run, also on the thread's control stack. Running the destructor\n code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions. The original task\n+destructor code to cause any subsequent state transitions. The original thread \n of unwinding and panicking thereby may suspend temporarily, and may involve\n (recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n outermost unwinding activity will continue until the stack is unwound and the\n-task transitions to the *dead* state. There is no way to \"recover\" from task\n-panics. Once a task has temporarily suspended its unwinding in the *panicking*\n+thread transitions to the *dead* state. There is no way to \"recover\" from thread \n+panics. Once a thread has temporarily suspended its unwinding in the *panicking*\n state, a panic occurring from within this destructor results in *hard* panic.\n A hard panic currently results in the process aborting.\n \n-A task in the *dead* state cannot transition to other states; it exists only to\n-have its termination status inspected by other tasks, and/or to await\n+A thread in the *dead* state cannot transition to other states; it exists only to\n+have its termination status inspected by other threads, and/or to await\n reclamation when the last reference to it drops.\n \n # Runtime services, linkage and debugging\n \n The Rust _runtime_ is a relatively compact collection of Rust code that\n-provides fundamental services and datatypes to all Rust tasks at run-time. It\n+provides fundamental services and datatypes to all Rust threads at run-time. It\n is smaller and simpler than many modern language runtimes. It is tightly\n-integrated into the language's execution model of memory, tasks, communication\n+integrated into the language's execution model of memory, threads, communication\n and logging.\n \n ### Memory allocation\n@@ -4181,23 +4178,23 @@ environment and releases them back to its environment when they are no longer\n needed. The default implementation of the service-provider interface consists\n of the C runtime functions `malloc` and `free`.\n \n-The runtime memory-management system, in turn, supplies Rust tasks with\n+The runtime memory-management system, in turn, supplies Rust threads with\n facilities for allocating releasing stacks, as well as allocating and freeing\n heap data.\n \n ### Built in types\n \n The runtime provides C and Rust code to assist with various built-in types,\n such as arrays, strings, and the low level communication system (ports,\n-channels, tasks).\n+channels, threads).\n \n Support for other built-in types such as simple types, tuples and enums is\n open-coded by the Rust compiler.\n \n-### Task scheduling and communication\n+### Thread scheduling and communication\n \n-The runtime provides code to manage inter-task communication. This includes\n-the system of task-lifecycle state transitions depending on the contents of\n+The runtime provides code to manage inter-thread communication. This includes\n+the system of thread-lifecycle state transitions depending on the contents of\n queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n communication facilities."}, {"sha": "9d0450285091c13703745d94a3ed53a611a3946a", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -245,6 +245,7 @@\n \t\t<context attribute=\"CharEscape\" lineEndContext=\"#pop\" name=\"CharEscape\">\n \t\t\t<AnyChar String=\"nrt\\&apos;&quot;\" attribute=\"CharEscape\" context=\"#pop\"/>\n \t\t\t<RegExpr String=\"x[0-9a-fA-F]{2}\" attribute=\"CharEscape\" context=\"#pop\"/>\n+\t\t\t<RegExpr String=\"u\\{[0-9a-fA-F]{1,6}\\}\" attribute=\"CharEscape\" context=\"#pop\"/>\n \t\t\t<RegExpr String=\"u[0-9a-fA-F]{4}\" attribute=\"CharEscape\" context=\"#pop\"/>\n \t\t\t<RegExpr String=\"U[0-9a-fA-F]{8}\" attribute=\"CharEscape\" context=\"#pop\"/>\n \t\t\t<RegExpr String=\".\" attribute=\"Error\" context=\"#pop\"/>\n@@ -255,7 +256,7 @@\n \t\t\t<Detect2Chars char=\"*\" char1=\"/\" attribute=\"Comment\" context=\"#pop\" endRegion=\"Comment\"/>\n \t\t</context>\n \t</contexts>\n-    <itemDatas>\n+\t<itemDatas>\n \t\t<itemData name=\"Normal Text\"  defStyleNum=\"dsNormal\"/>\n \t\t<itemData name=\"Keyword\"      defStyleNum=\"dsKeyword\" color=\"#770088\" bold=\"1\"/>\n \t\t<itemData name=\"Self\"         defStyleNum=\"dsKeyword\" color=\"#FF0000\" bold=\"1\"/>"}, {"sha": "ea2a98db2dc1f94bc98fce3668c9a33fa18fadfd", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -114,11 +114,5 @@ def make_win_dist(rust_root, gcc_root, target_triple):\n     for src in target_libs:\n         shutil.copy(src, target_lib_dir)\n \n-    # Copy license files\n-    lic_dir = os.path.join(rust_root, \"bin\", \"third-party\")\n-    if os.path.exists(lic_dir):\n-        shutil.rmtree(lic_dir) # copytree() won't overwrite existing files\n-    shutil.copytree(os.path.join(os.path.dirname(__file__), \"third-party\"), lic_dir)\n-\n if __name__==\"__main__\":\n     make_win_dist(sys.argv[1], sys.argv[2], sys.argv[3])"}, {"sha": "00af6d358e5eb3d3643592bb929db3c7adf2b275", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -112,7 +112,8 @@ LIT_INTEGER\n   ;\n \n LIT_FLOAT\n-  : [0-9][0-9_]* ('.' | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n+  : [0-9][0-9_]* ( '.' {_input.LA(1) != '.'}?\n+                 | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n   ;\n \n LIT_STR"}, {"sha": "bdb616fcc99b83d744c28afed4ce5c8dcd250a36", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -61,7 +61,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"SHL\"               => token::BinOp(token::Shl),\n             \"LBRACE\"            => token::OpenDelim(token::Brace),\n             \"RARROW\"            => token::RArrow,\n-            \"LIT_STR\"           => token::Literal(token::Str_(Name(0))),\n+            \"LIT_STR\"           => token::Literal(token::Str_(Name(0)), None),\n             \"DOTDOT\"            => token::DotDot,\n             \"MOD_SEP\"           => token::ModSep,\n             \"DOTDOTDOT\"         => token::DotDotDot,\n@@ -71,7 +71,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"ANDAND\"            => token::AndAnd,\n             \"AT\"                => token::At,\n             \"LBRACKET\"          => token::OpenDelim(token::Bracket),\n-            \"LIT_STR_RAW\"       => token::Literal(token::StrRaw(Name(0), 0)),\n+            \"LIT_STR_RAW\"       => token::Literal(token::StrRaw(Name(0), 0), None),\n             \"RPAREN\"            => token::CloseDelim(token::Paren),\n             \"SLASH\"             => token::BinOp(token::Slash),\n             \"COMMA\"             => token::Comma,\n@@ -80,8 +80,8 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"TILDE\"             => token::Tilde,\n             \"IDENT\"             => id(),\n             \"PLUS\"              => token::BinOp(token::Plus),\n-            \"LIT_CHAR\"          => token::Literal(token::Char(Name(0))),\n-            \"LIT_BYTE\"          => token::Literal(token::Byte(Name(0))),\n+            \"LIT_CHAR\"          => token::Literal(token::Char(Name(0)), None),\n+            \"LIT_BYTE\"          => token::Literal(token::Byte(Name(0)), None),\n             \"EQ\"                => token::Eq,\n             \"RBRACKET\"          => token::CloseDelim(token::Bracket),\n             \"COMMENT\"           => token::Comment,\n@@ -95,9 +95,9 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"BINOP\"             => token::BinOp(token::Plus),\n             \"POUND\"             => token::Pound,\n             \"OROR\"              => token::OrOr,\n-            \"LIT_INTEGER\"       => token::Literal(token::Integer(Name(0))),\n+            \"LIT_INTEGER\"       => token::Literal(token::Integer(Name(0)), None),\n             \"BINOPEQ\"           => token::BinOpEq(token::Plus),\n-            \"LIT_FLOAT\"         => token::Literal(token::Float(Name(0))),\n+            \"LIT_FLOAT\"         => token::Literal(token::Float(Name(0)), None),\n             \"WHITESPACE\"        => token::Whitespace,\n             \"UNDERSCORE\"        => token::Underscore,\n             \"MINUS\"             => token::BinOp(token::Minus),\n@@ -107,8 +107,8 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"OR\"                => token::BinOp(token::Or),\n             \"GT\"                => token::Gt,\n             \"LE\"                => token::Le,\n-            \"LIT_BINARY\"        => token::Literal(token::Binary(Name(0))),\n-            \"LIT_BINARY_RAW\"    => token::Literal(token::BinaryRaw(Name(0), 0)),\n+            \"LIT_BINARY\"        => token::Literal(token::Binary(Name(0)), None),\n+            \"LIT_BINARY_RAW\"    => token::Literal(token::BinaryRaw(Name(0), 0), None),\n             _                   => continue,\n         };\n \n@@ -189,17 +189,17 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAn\n         token::BinOp(..)           => token::BinOp(str_to_binop(content)),\n         token::BinOpEq(..)         => token::BinOpEq(str_to_binop(content.slice_to(\n                                                                     content.len() - 1))),\n-        token::Literal(token::Str_(..))      => token::Literal(token::Str_(fix(content))),\n-        token::Literal(token::StrRaw(..))    => token::Literal(token::StrRaw(fix(content),\n-                                                                             count(content))),\n-        token::Literal(token::Char(..))      => token::Literal(token::Char(fixchar(content))),\n-        token::Literal(token::Byte(..))      => token::Literal(token::Byte(fixchar(content))),\n+        token::Literal(token::Str_(..), n)      => token::Literal(token::Str_(fix(content)), n),\n+        token::Literal(token::StrRaw(..), n)    => token::Literal(token::StrRaw(fix(content),\n+                                                                             count(content)), n),\n+        token::Literal(token::Char(..), n)      => token::Literal(token::Char(fixchar(content)), n),\n+        token::Literal(token::Byte(..), n)      => token::Literal(token::Byte(fixchar(content)), n),\n         token::DocComment(..)      => token::DocComment(nm),\n-        token::Literal(token::Integer(..))   => token::Literal(token::Integer(nm)),\n-        token::Literal(token::Float(..))     => token::Literal(token::Float(nm)),\n-        token::Literal(token::Binary(..))    => token::Literal(token::Binary(nm)),\n-        token::Literal(token::BinaryRaw(..)) => token::Literal(token::BinaryRaw(fix(content),\n-                                                                                count(content))),\n+        token::Literal(token::Integer(..), n)   => token::Literal(token::Integer(nm), n),\n+        token::Literal(token::Float(..), n)     => token::Literal(token::Float(nm), n),\n+        token::Literal(token::Binary(..), n)    => token::Literal(token::Binary(nm), n),\n+        token::Literal(token::BinaryRaw(..), n) => token::Literal(token::BinaryRaw(fix(content),\n+                                                                                count(content)), n),\n         token::Ident(..)           => token::Ident(ast::Ident { name: nm, ctxt: 0 },\n                                                    token::ModName),\n         token::Lifetime(..)        => token::Lifetime(ast::Ident { name: nm, ctxt: 0 }),\n@@ -214,8 +214,8 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAn\n     };\n \n     let sp = syntax::codemap::Span {\n-        lo: syntax::codemap::BytePos(from_str::<u32>(start).unwrap() - offset),\n-        hi: syntax::codemap::BytePos(from_str::<u32>(end).unwrap() + 1),\n+        lo: syntax::codemap::BytePos(start.parse::<u32>().unwrap() - offset),\n+        hi: syntax::codemap::BytePos(end.parse::<u32>().unwrap() + 1),\n         expn_id: syntax::codemap::NO_EXPANSION\n     };\n \n@@ -247,7 +247,9 @@ fn main() {\n     let token_map = parse_token_list(token_file.read_to_string().unwrap().as_slice());\n \n     let mut stdin = std::io::stdin();\n-    let mut antlr_tokens = stdin.lines().map(|l| parse_antlr_token(l.unwrap().as_slice().trim(),\n+    let mut lock = stdin.lock();\n+    let lines = lock.lines();\n+    let mut antlr_tokens = lines.map(|l| parse_antlr_token(l.unwrap().as_slice().trim(),\n                                                                    &token_map));\n \n     let code = File::open(&Path::new(args[1].as_slice())).unwrap().read_to_string().unwrap();\n@@ -284,17 +286,17 @@ fn main() {\n                     ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n                 }\n             )\n-        )\n+        );\n \n         matches!(\n-            token::Literal(token::Byte(..)),\n-            token::Literal(token::Char(..)),\n-            token::Literal(token::Integer(..)),\n-            token::Literal(token::Float(..)),\n-            token::Literal(token::Str_(..)),\n-            token::Literal(token::StrRaw(..)),\n-            token::Literal(token::Binary(..)),\n-            token::Literal(token::BinaryRaw(..)),\n+            token::Literal(token::Byte(..), _),\n+            token::Literal(token::Char(..), _),\n+            token::Literal(token::Integer(..), _),\n+            token::Literal(token::Float(..), _),\n+            token::Literal(token::Str_(..), _),\n+            token::Literal(token::StrRaw(..), _),\n+            token::Literal(token::Binary(..), _),\n+            token::Literal(token::BinaryRaw(..), _),\n             token::Ident(..),\n             token::Lifetime(..),\n             token::Interpolated(..),"}, {"sha": "21c47cdf3d752129153e6d983120417650eb3410", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -58,7 +58,7 @@\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n-//!         let mut number = five.lock();\n+//!         let mut number = five.lock().unwrap();\n //!\n //!         *number += 1;\n //!\n@@ -80,7 +80,7 @@ use core::nonzero::NonZero;\n use core::ops::{Drop, Deref};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::ptr::{mod, RawPtr};\n+use core::ptr::{mod, PtrExt};\n use heap::deallocate;\n \n /// An atomically reference counted wrapper for shared state.\n@@ -722,7 +722,7 @@ mod tests {\n \n         let a = Arc::new(Cycle { x: Mutex::new(None) });\n         let b = a.clone().downgrade();\n-        *a.x.lock() = Some(b);\n+        *a.x.lock().unwrap() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n     }"}, {"sha": "cdc30efd2d9a289049492fe8e518f98c1f9a7cc2", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::ptr::RawPtr;\n+use core::ptr::PtrExt;\n \n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n@@ -371,7 +371,7 @@ mod imp {\n mod test {\n     extern crate test;\n     use self::test::Bencher;\n-    use core::ptr::RawPtr;\n+    use core::ptr::PtrExt;\n     use heap;\n \n     #[test]"}, {"sha": "214fae02ce27210e3010f41ec6cdda38c2c65fea", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task-local reference-counted boxes (the `Rc<T>` type).\n+//! Thread-local reference-counted boxes (the `Rc<T>` type).\n //!\n //! The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic,\n //! and will occur as soon as the last owner is gone. It is marked as non-sendable because it\n@@ -154,7 +154,7 @@ use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::ptr::{mod, RawPtr};\n+use core::ptr::{mod, PtrExt};\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n "}, {"sha": "b0fa5434a1474c65f2ebb64be23a4316f337b87f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -412,7 +412,7 @@ impl<T> TypedArenaChunk<T> {\n         let size = calculate_size::<T>(self.capacity);\n         deallocate(self as *mut TypedArenaChunk<T> as *mut u8, size,\n                    mem::min_align_of::<TypedArenaChunk<T>>());\n-        if next.is_not_null() {\n+        if !next.is_null() {\n             let capacity = (*next).capacity;\n             (*next).destroy(capacity);\n         }"}, {"sha": "d8ce79f4fe90d29c3e9f28e80cf46848cf7f3a94", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -95,7 +95,7 @@ impl<T> Rawlink<T> {\n     /// Convert the `Rawlink` into an Option value\n     fn resolve_immut<'a>(&self) -> Option<&'a T> {\n         unsafe {\n-            self.p.as_ref()\n+            mem::transmute(self.p.as_ref())\n         }\n     }\n "}, {"sha": "fe9d8de440a17aca42c15bad4f6d11fc071b031b", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -114,14 +114,14 @@ mod prelude {\n     pub use core::ops::{Drop, Fn, FnMut, FnOnce};\n     pub use core::option::Option;\n     pub use core::option::Option::{Some, None};\n-    pub use core::ptr::RawPtr;\n+    pub use core::ptr::PtrExt;\n     pub use core::result::Result;\n     pub use core::result::Result::{Ok, Err};\n \n     // in core and collections (may differ).\n     pub use slice::{PartialEqSliceExt, OrdSliceExt};\n     pub use slice::{AsSlice, SliceExt};\n-    pub use str::{from_str, Str};\n+    pub use str::{from_str, Str, StrExt};\n \n     // from other crates.\n     pub use alloc::boxed::Box;"}, {"sha": "c55a8ba104ebefc86c31fd17cc2053a02f82378d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -96,7 +96,7 @@ use core::mem::size_of;\n use core::mem;\n use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n+use core::prelude::{Ord, Ordering, PtrExt, Some, range};\n use core::ptr;\n use core::slice as core_slice;\n use self::Direction::*;\n@@ -1343,11 +1343,14 @@ pub mod raw {\n #[cfg(test)]\n mod tests {\n     use std::boxed::Box;\n-    use prelude::*;\n+    use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n+    use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n+    use prelude::{RandomAccessIterator, Ord, VectorVector};\n     use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n-    use std::rand::{Rng, task_rng};\n+    use std::rand::{Rng, thread_rng};\n     use std::rc::Rc;\n     use super::ElementSwaps;\n \n@@ -1963,7 +1966,7 @@ mod tests {\n     fn test_sort() {\n         for len in range(4u, 25) {\n             for _ in range(0i, 100) {\n-                let mut v = task_rng().gen_iter::<uint>().take(len)\n+                let mut v = thread_rng().gen_iter::<uint>().take(len)\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n \n@@ -1999,7 +2002,7 @@ mod tests {\n                 // number this element is, i.e. the second elements\n                 // will occur in sorted order.\n                 let mut v = range(0, len).map(|_| {\n-                        let n = task_rng().gen::<uint>() % 10;\n+                        let n = thread_rng().gen::<uint>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n                     }).collect::<Vec<(uint, int)>>();"}, {"sha": "7c7a7e19a2f18c92ece50074a8dceaf1e5992643", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -89,8 +89,6 @@ pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n pub use core::str::{Split, SplitTerminator};\n pub use core::str::{SplitN, RSplitN};\n \n-// FIXME(conventions): ensure bit/char conventions are followed by str's API\n-\n /*\n Section: Creating a string\n */\n@@ -1768,26 +1766,13 @@ impl StrExt for str {}\n \n #[cfg(test)]\n mod tests {\n-    use std::iter::AdditiveIterator;\n-    use std::iter::range;\n-    use std::default::Default;\n-    use std::char::Char;\n-    use std::clone::Clone;\n-    use std::cmp::{Ord, PartialOrd, Equiv};\n-    use std::cmp::Ordering::{Equal, Greater, Less};\n-    use std::option::Option::{mod, Some, None};\n-    use std::result::Result::{Ok, Err};\n-    use std::ptr::RawPtr;\n-    use std::iter::{Iterator, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::*;\n \n-    use super::*;\n+    use core::default::Default;\n+    use core::iter::AdditiveIterator;\n+    use super::{from_utf8, is_utf8, raw};\n     use super::MaybeOwned::{Owned, Slice};\n-    use std::slice::{AsSlice, SliceExt};\n-    use string::{String, ToString};\n-    use vec::Vec;\n-    use slice::CloneSliceExt;\n-\n-    use unicode::char::UnicodeChar;\n+    use super::Utf8Error;\n \n     #[test]\n     fn test_le() {\n@@ -3354,7 +3339,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use super::*;\n-    use prelude::*;\n+    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt};\n     use test::Bencher;\n     use test::black_box;\n "}, {"sha": "c6c19cae75f1efc1b55a005d0f6a8eeb6cf307d6", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 108, "deletions": 65, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -12,6 +12,8 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n+#![stable]\n+\n use core::prelude::*;\n \n use core::borrow::{Cow, IntoCow};\n@@ -36,6 +38,18 @@ pub struct String {\n     vec: Vec<u8>,\n }\n \n+/// A possible error value from the `String::from_utf8` function.\n+#[stable]\n+pub struct FromUtf8Error {\n+    bytes: Vec<u8>,\n+    error: Utf8Error,\n+}\n+\n+/// A possible error value from the `String::from_utf16` function.\n+#[stable]\n+#[allow(missing_copy_implementations)]\n+pub struct FromUtf16Error(());\n+\n impl String {\n     /// Creates a new string buffer initialized with the empty string.\n     ///\n@@ -98,19 +112,20 @@ impl String {\n     /// use std::str::Utf8Error;\n     ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n-    /// let s = String::from_utf8(hello_vec);\n-    /// assert_eq!(s, Ok(\"hello\".to_string()));\n+    /// let s = String::from_utf8(hello_vec).unwrap();\n+    /// assert_eq!(s, \"hello\");\n     ///\n     /// let invalid_vec = vec![240, 144, 128];\n-    /// let s = String::from_utf8(invalid_vec);\n-    /// assert_eq!(s, Err((vec![240, 144, 128], Utf8Error::TooShort)));\n+    /// let s = String::from_utf8(invalid_vec).err().unwrap();\n+    /// assert_eq!(s.utf8_error(), Utf8Error::TooShort);\n+    /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n     /// ```\n     #[inline]\n-    #[unstable = \"error type may change\"]\n-    pub fn from_utf8(vec: Vec<u8>) -> Result<String, (Vec<u8>, Utf8Error)> {\n+    #[stable]\n+    pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(vec.as_slice()) {\n             Ok(..) => Ok(String { vec: vec }),\n-            Err(e) => Err((vec, e))\n+            Err(e) => Err(FromUtf8Error { bytes: vec, error: e })\n         }\n     }\n \n@@ -124,7 +139,7 @@ impl String {\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n-    #[unstable = \"return type may change\"]\n+    #[stable]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         match str::from_utf8(v) {\n             Ok(s) => return Cow::Borrowed(s),\n@@ -251,22 +266,23 @@ impl String {\n     /// // \ud834\udd1emusic\n     /// let mut v = &mut [0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///                   0x0073, 0x0069, 0x0063];\n-    /// assert_eq!(String::from_utf16(v), Some(\"\ud834\udd1emusic\".to_string()));\n+    /// assert_eq!(String::from_utf16(v).unwrap(),\n+    ///            \"\ud834\udd1emusic\".to_string());\n     ///\n     /// // \ud834\udd1emu<invalid>ic\n     /// v[4] = 0xD800;\n-    /// assert_eq!(String::from_utf16(v), None);\n+    /// assert!(String::from_utf16(v).is_err());\n     /// ```\n-    #[unstable = \"error value in return may change\"]\n-    pub fn from_utf16(v: &[u16]) -> Option<String> {\n+    #[stable]\n+    pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n         let mut s = String::with_capacity(v.len());\n         for c in unicode_str::utf16_items(v) {\n             match c {\n                 Utf16Item::ScalarValue(c) => s.push(c),\n-                Utf16Item::LoneSurrogate(_) => return None\n+                Utf16Item::LoneSurrogate(_) => return Err(FromUtf16Error(())),\n             }\n         }\n-        Some(s)\n+        Ok(s)\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a string, replacing\n@@ -293,12 +309,13 @@ impl String {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![allow(deprecated)]\n     /// let chars = &['h', 'e', 'l', 'l', 'o'];\n     /// let s = String::from_chars(chars);\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[unstable = \"may be removed in favor of .collect()\"]\n+    #[deprecated = \"use .collect() instead\"]\n     pub fn from_chars(chs: &[char]) -> String {\n         chs.iter().map(|c| *c).collect()\n     }\n@@ -309,7 +326,7 @@ impl String {\n     /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n-    #[unstable = \"function just moved from string::raw\"]\n+    #[stable]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n@@ -344,7 +361,7 @@ impl String {\n     /// it contains valid UTF-8. This is unsafe because it assumes that\n     /// the UTF-8-ness of the vector has already been validated.\n     #[inline]\n-    #[unstable = \"awaiting stabilization\"]\n+    #[stable]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n         String { vec: bytes }\n     }\n@@ -369,12 +386,12 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let s = String::from_char(5, 'a');\n     /// assert_eq!(s.as_slice(), \"aaaaa\");\n     /// ```\n     #[inline]\n-    #[unstable = \"may be replaced with iterators, questionable usability, and \\\n-                  the name may change\"]\n+    #[deprecated = \"use repeat(ch).take(length).collect() instead\"]\n     pub fn from_char(length: uint, ch: char) -> String {\n         if length == 0 {\n             return String::new()\n@@ -400,7 +417,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"foobar\");\n     /// ```\n     #[inline]\n-    #[unstable = \"extra variants of `push`, could possibly be based on iterators\"]\n+    #[stable]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.push_all(string.as_bytes())\n     }\n@@ -410,19 +427,21 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(deprecated)]\n     /// let mut s = String::from_str(\"foo\");\n     /// s.grow(5, 'Z');\n     /// assert_eq!(s.as_slice(), \"fooZZZZZ\");\n     /// ```\n     #[inline]\n-    #[unstable = \"duplicate of iterator-based functionality\"]\n+    #[deprecated = \"deprecated in favor of .extend(repeat(ch).take(count))\"]\n     pub fn grow(&mut self, count: uint, ch: char) {\n         for _ in range(0, count) {\n             self.push(ch)\n         }\n     }\n \n-    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    /// Returns the number of bytes that this string buffer can hold without\n+    /// reallocating.\n     ///\n     /// # Examples\n     ///\n@@ -431,7 +450,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n@@ -442,8 +461,9 @@ impl String {\n         self.vec.reserve(extra)\n     }\n \n-    /// Reserves capacity for at least `additional` more bytes to be inserted in the given\n-    /// `String`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Reserves capacity for at least `additional` more bytes to be inserted\n+    /// in the given `String`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -457,17 +477,18 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve(&mut self, additional: uint) {\n         self.vec.reserve(additional)\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more bytes to be inserted in the\n-    /// given `String`. Does nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for exactly `additional` more bytes to be\n+    /// inserted in the given `String`. Does nothing if the capacity is already\n+    /// sufficient.\n     ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n-    /// insertions are expected.\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Panics\n     ///\n@@ -481,7 +502,7 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         self.vec.reserve_exact(additional)\n     }\n@@ -498,7 +519,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n-    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[stable]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -515,7 +536,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"abc123\");\n     /// ```\n     #[inline]\n-    #[stable = \"function just renamed from push_char\"]\n+    #[stable]\n     pub fn push(&mut self, ch: char) {\n         if (ch as u32) < 0x80 {\n             self.vec.push(ch as u8);\n@@ -568,7 +589,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"he\");\n     /// ```\n     #[inline]\n-    #[unstable = \"the panic conventions for strings are under development\"]\n+    #[stable]\n     pub fn truncate(&mut self, new_len: uint) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n@@ -587,7 +608,7 @@ impl String {\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"this function was just renamed from pop_char\"]\n+    #[stable]\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n@@ -602,7 +623,7 @@ impl String {\n     }\n \n     /// Removes the character from the string buffer at byte position `idx` and\n-    /// returns it. Returns `None` if `idx` is out of bounds.\n+    /// returns it.\n     ///\n     /// # Warning\n     ///\n@@ -611,23 +632,21 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// If `idx` does not lie on a character boundary, then this function will\n-    /// panic.\n+    /// If `idx` does not lie on a character boundary, or if it is out of\n+    /// bounds, then this function will panic.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n-    /// assert_eq!(s.remove(0), Some('f'));\n-    /// assert_eq!(s.remove(1), Some('o'));\n-    /// assert_eq!(s.remove(0), Some('o'));\n-    /// assert_eq!(s.remove(0), None);\n+    /// assert_eq!(s.remove(0), 'f');\n+    /// assert_eq!(s.remove(1), 'o');\n+    /// assert_eq!(s.remove(0), 'o');\n     /// ```\n-    #[unstable = \"the panic semantics of this function and return type \\\n-                  may change\"]\n-    pub fn remove(&mut self, idx: uint) -> Option<char> {\n+    #[stable]\n+    pub fn remove(&mut self, idx: uint) -> char {\n         let len = self.len();\n-        if idx >= len { return None }\n+        assert!(idx <= len);\n \n         let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n@@ -636,7 +655,7 @@ impl String {\n                              len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n-        Some(ch)\n+        ch\n     }\n \n     /// Insert a character into the string buffer at byte position `idx`.\n@@ -650,7 +669,7 @@ impl String {\n     ///\n     /// If `idx` does not lie on a character boundary or is out of bounds, then\n     /// this function will panic.\n-    #[unstable = \"the panic semantics of this function are uncertain\"]\n+    #[stable]\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n@@ -686,7 +705,7 @@ impl String {\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");\n     /// ```\n-    #[unstable = \"the name of this method may be changed\"]\n+    #[stable]\n     pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n         &mut self.vec\n     }\n@@ -713,6 +732,7 @@ impl String {\n     /// v.push('a');\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[stable]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Truncates the string, returning it to 0 length.\n@@ -731,6 +751,29 @@ impl String {\n     }\n }\n \n+impl FromUtf8Error {\n+    /// Consume this error, returning the bytes that were attempted to make a\n+    /// `String` with.\n+    #[stable]\n+    pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n+\n+    /// Access the underlying UTF8-error that was the cause of this error.\n+    #[stable]\n+    pub fn utf8_error(&self) -> Utf8Error { self.error }\n+}\n+\n+impl fmt::Show for FromUtf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.error.fmt(f)\n+    }\n+}\n+\n+impl fmt::Show for FromUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"invalid utf-16: lone surrogate found\".fmt(f)\n+    }\n+}\n+\n #[experimental = \"waiting on FromIterator stabilization\"]\n impl FromIterator<char> for String {\n     fn from_iter<I:Iterator<char>>(iterator: I) -> String {\n@@ -933,6 +976,7 @@ impl FromStr for String {\n }\n \n /// Trait for converting a type to a string, consuming it in the process.\n+#[deprecated = \"trait will be removed\"]\n pub trait IntoString {\n     /// Consume and convert to a string.\n     fn into_string(self) -> String;\n@@ -1038,7 +1082,7 @@ mod tests {\n     use prelude::*;\n     use test::Bencher;\n \n-    use str::{StrExt, Utf8Error};\n+    use str::Utf8Error;\n     use str;\n     use super::as_string;\n \n@@ -1057,16 +1101,17 @@ mod tests {\n     #[test]\n     fn test_from_utf8() {\n         let xs = b\"hello\".to_vec();\n-        assert_eq!(String::from_utf8(xs),\n-                   Ok(String::from_str(\"hello\")));\n+        assert_eq!(String::from_utf8(xs).unwrap(),\n+                   String::from_str(\"hello\"));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n-        assert_eq!(String::from_utf8(xs),\n-                   Ok(String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\")));\n+        assert_eq!(String::from_utf8(xs).unwrap(),\n+                   String::from_str(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"hello\\xFF\".to_vec();\n-        assert_eq!(String::from_utf8(xs),\n-                   Err((b\"hello\\xFF\".to_vec(), Utf8Error::TooShort)));\n+        let err = String::from_utf8(xs).err().unwrap();\n+        assert_eq!(err.utf8_error(), Utf8Error::TooShort);\n+        assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n     }\n \n     #[test]\n@@ -1171,15 +1216,15 @@ mod tests {\n     fn test_utf16_invalid() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(String::from_utf16(&[0xD800]), None);\n+        assert!(String::from_utf16(&[0xD800]).is_err());\n         // lead + lead\n-        assert_eq!(String::from_utf16(&[0xD800, 0xD800]), None);\n+        assert!(String::from_utf16(&[0xD800, 0xD800]).is_err());\n \n         // isolated trail\n-        assert_eq!(String::from_utf16(&[0x0061, 0xDC00]), None);\n+        assert!(String::from_utf16(&[0x0061, 0xDC00]).is_err());\n \n         // general\n-        assert_eq!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n+        assert!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]).is_err());\n     }\n \n     #[test]\n@@ -1312,12 +1357,10 @@ mod tests {\n     #[test]\n     fn remove() {\n         let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n-        assert_eq!(s.remove(0), Some('\u0e28'));\n+        assert_eq!(s.remove(0), '\u0e28');\n         assert_eq!(s.len(), 33);\n         assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n-        assert_eq!(s.remove(33), None);\n-        assert_eq!(s.remove(300), None);\n-        assert_eq!(s.remove(17), Some('\u1ec7'));\n+        assert_eq!(s.remove(17), '\u1ec7');\n         assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n     }\n "}, {"sha": "01a1e7f97110a93668dfa1a641e82459b4a23834", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -158,7 +158,7 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use kinds::{marker, Copy};\n+use kinds::{Copy, Send};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{None, Some};\n@@ -167,7 +167,6 @@ use option::Option::{None, Some};\n #[stable]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n-    noshare: marker::NoSync,\n }\n \n impl<T:Copy> Cell<T> {\n@@ -176,7 +175,6 @@ impl<T:Copy> Cell<T> {\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n             value: UnsafeCell::new(value),\n-            noshare: marker::NoSync,\n         }\n     }\n \n@@ -208,6 +206,9 @@ impl<T:Copy> Cell<T> {\n     }\n }\n \n+#[stable]\n+unsafe impl<T> Send for Cell<T> where T: Send {}\n+\n #[stable]\n impl<T:Copy> Clone for Cell<T> {\n     fn clone(&self) -> Cell<T> {\n@@ -235,7 +236,6 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n-    noshare: marker::NoSync,\n }\n \n // Values [1, MAX-1] represent the number of `Ref` active\n@@ -251,7 +251,6 @@ impl<T> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n             borrow: Cell::new(UNUSED),\n-            noshare: marker::NoSync,\n         }\n     }\n \n@@ -341,6 +340,9 @@ impl<T> RefCell<T> {\n     }\n }\n \n+#[stable]\n+unsafe impl<T> Send for RefCell<T> where T: Send {}\n+\n #[stable]\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {"}, {"sha": "5d84d0c7797ecfe5e20be75223be58fc107e0963", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -36,7 +36,7 @@ pub trait Clone {\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n     #[inline(always)]\n-    #[unstable = \"this function rarely unused\"]\n+    #[unstable = \"this function is rarely used\"]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n     }"}, {"sha": "781dbb0e55a3f8a99b61d8d084a4b5ab4ef1575b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -85,16 +85,6 @@ macro_rules! assert {\n     );\n }\n \n-/// Runtime assertion, only without `--cfg ndebug`\n-#[macro_export]\n-macro_rules! debug_assert {\n-    ($(a:tt)*) => ({\n-        if cfg!(not(ndebug)) {\n-            assert!($($a)*);\n-        }\n-    })\n-}\n-\n /// Runtime assertion for equality, for details see std::macros\n #[macro_export]\n macro_rules! assert_eq {\n@@ -117,7 +107,7 @@ macro_rules! debug_assert_eq {\n     })\n }\n \n-/// Runtime assertion, disableable at compile time\n+/// Runtime assertion, disableable at compile time with `--cfg ndebug`\n #[macro_export]\n macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })"}, {"sha": "fd1598db8cdfccbce8f40bf4f072ff51b80d7212", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -57,7 +57,7 @@ pub use iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n pub use num::{ToPrimitive, FromPrimitive};\n pub use option::Option;\n pub use option::Option::{Some, None};\n-pub use ptr::RawPtr;\n+pub use ptr::{PtrExt, MutPtrExt};\n pub use result::Result;\n pub use result::Result::{Ok, Err};\n pub use str::{Str, StrExt};"}, {"sha": "75bb8d33ea85f514419190b2d52be05d579d8f51", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 87, "deletions": 54, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,11 +16,10 @@\n //! typically limited to a few patterns.\n //!\n //! Use the [`null` function](fn.null.html) to create null pointers,\n-//! the [`is_null`](trait.RawPtr.html#tymethod.is_null)\n-//! and [`is_not_null`](trait.RawPtr.html#method.is_not_null)\n-//! methods of the [`RawPtr` trait](trait.RawPtr.html) to check for null.\n-//! The `RawPtr` trait is imported by the prelude, so `is_null` etc.\n-//! work everywhere. The `RawPtr` also defines the `offset` method,\n+//! the [`is_null`](trait.PtrExt.html#tymethod.is_null)\n+//! methods of the [`PtrExt` trait](trait.PtrExt.html) to check for null.\n+//! The `PtrExt` trait is imported by the prelude, so `is_null` etc.\n+//! work everywhere. The `PtrExt` also defines the `offset` method,\n //! for pointer math.\n //!\n //! # Common ways to create unsafe pointers\n@@ -87,16 +86,16 @@\n //! but C APIs hand out a lot of pointers generally, so are a common source\n //! of unsafe pointers in Rust.\n \n+#![stable]\n+\n use mem;\n use clone::Clone;\n use intrinsics;\n+use option::Option::{mod, Some, None};\n use kinds::{Send, Sync};\n-use option::Option;\n-use option::Option::{Some, None};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n-use cmp::Ordering;\n-use cmp::Ordering::{Less, Equal, Greater};\n+use cmp::Ordering::{mod, Less, Equal, Greater};\n \n // FIXME #19649: instrinsic docs don't render, so these have no docs :(\n \n@@ -121,7 +120,7 @@ pub use intrinsics::set_memory;\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[unstable = \"may need a different name after pending changes to pointer types\"]\n+#[stable]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -135,31 +134,31 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// assert!(p.is_null());\n /// ```\n #[inline]\n-#[unstable = \"may need a different name after pending changes to pointer types\"]\n+#[stable]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n-/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be `0`.\n+/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n+/// `0`.\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it will not drop the contents of `dst`,\n-/// and may be used to create invalid instances of `T`.\n+/// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n+/// contents of `dst`, and may be used to create invalid instances of `T`.\n #[inline]\n-#[experimental = \"uncertain about naming and semantics\"]\n-#[allow(experimental)]\n+#[unstable = \"may play a larger role in std::ptr future extensions\"]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n \n /// Swaps the values at two mutable locations of the same type, without\n-/// deinitialising either. They may overlap, unlike `mem::swap` which is otherwise\n-/// equivalent.\n+/// deinitialising either. They may overlap, unlike `mem::swap` which is\n+/// otherwise equivalent.\n ///\n /// # Safety\n ///\n /// This is only unsafe because it accepts a raw pointer.\n #[inline]\n-#[unstable]\n+#[stable]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n@@ -183,7 +182,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// This is only unsafe because it accepts a raw pointer.\n /// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n-#[unstable]\n+#[stable]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n@@ -201,7 +200,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n-#[unstable]\n+#[stable]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n@@ -214,8 +213,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[experimental]\n-#[allow(experimental)]\n+#[unstable = \"may play a larger role in std::ptr future extensions\"]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n     let tmp = read(&*dest);\n@@ -226,85 +224,105 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n-/// Overwrites a memory location with the given value without reading or dropping\n-/// the old value.\n+/// Overwrites a memory location with the given value without reading or\n+/// dropping the old value.\n ///\n /// # Safety\n ///\n /// Beyond accepting a raw pointer, this operation is unsafe because it does\n /// not drop the contents of `dst`. This could leak allocations or resources,\n /// so care must be taken not to overwrite an object that should be dropped.\n ///\n-/// This is appropriate for initializing uninitialized memory, or overwritting memory\n-/// that has previously been `read` from.\n+/// This is appropriate for initializing uninitialized memory, or overwritting\n+/// memory that has previously been `read` from.\n #[inline]\n-#[unstable]\n+#[stable]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n /// Methods on raw pointers\n-pub trait RawPtr<T> {\n-    /// Returns a null raw pointer.\n+#[stable]\n+pub trait PtrExt<T> {\n+    /// Returns the null pointer.\n+    #[deprecated = \"call ptr::null instead\"]\n     fn null() -> Self;\n \n     /// Returns true if the pointer is null.\n-    fn is_null(&self) -> bool;\n+    #[stable]\n+    fn is_null(self) -> bool;\n \n-    /// Returns true if the pointer is not null.\n-    fn is_not_null(&self) -> bool { !self.is_null() }\n+    /// Returns true if the pointer is not equal to the null pointer.\n+    #[deprecated = \"use !p.is_null() instead\"]\n+    fn is_not_null(self) -> bool { !self.is_null() }\n \n-    /// Returns the address of the pointer.\n-    fn to_uint(&self) -> uint;\n+    /// Returns true if the pointer is not null.\n+    #[deprecated = \"use `as uint` instead\"]\n+    fn to_uint(self) -> uint;\n \n-    /// Returns `None` if the pointer is null, or else returns a reference to the\n-    /// value wrapped in `Some`.\n+    /// Returns `None` if the pointer is null, or else returns a reference to\n+    /// the value wrapped in `Some`.\n     ///\n     /// # Safety\n     ///\n-    /// While this method and its mutable counterpart are useful for null-safety,\n-    /// it is important to note that this is still an unsafe operation because\n-    /// the returned value could be pointing to invalid memory.\n+    /// While this method and its mutable counterpart are useful for\n+    /// null-safety, it is important to note that this is still an unsafe\n+    /// operation because the returned value could be pointing to invalid\n+    /// memory.\n+    #[unstable = \"Option is not clearly the right return type, and we may want \\\n+                  to tie the return lifetime to a borrow of the raw pointer\"]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n \n     /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n     ///\n     /// # Safety\n     ///\n-    /// The offset must be in-bounds of the object, or one-byte-past-the-end. Otherwise\n-    /// `offset` invokes Undefined Behaviour, regardless of whether the pointer is used.\n+    /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n+    /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n+    /// the pointer is used.\n+    #[stable]\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n-pub trait RawMutPtr<T>{\n-    /// Returns `None` if the pointer is null, or else returns a mutable reference\n-    /// to the value wrapped in `Some`.\n+#[stable]\n+pub trait MutPtrExt<T>{\n+    /// Returns `None` if the pointer is null, or else returns a mutable\n+    /// reference to the value wrapped in `Some`.\n     ///\n     /// # Safety\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n+    #[unstable = \"Option is not clearly the right return type, and we may want \\\n+                  to tie the return lifetime to a borrow of the raw pointer\"]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n }\n \n-impl<T> RawPtr<T> for *const T {\n+#[stable]\n+impl<T> PtrExt<T> for *const T {\n     #[inline]\n+    #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *const T { null() }\n \n     #[inline]\n-    fn is_null(&self) -> bool { *self == RawPtr::null() }\n+    #[stable]\n+    fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    fn to_uint(&self) -> uint { *self as uint }\n+    #[deprecated = \"use `as uint` instead\"]\n+    fn to_uint(self) -> uint { self as uint }\n \n     #[inline]\n+    #[stable]\n     unsafe fn offset(self, count: int) -> *const T {\n         intrinsics::offset(self, count)\n     }\n \n     #[inline]\n+    #[unstable = \"return value does not necessarily convey all possible \\\n+                  information\"]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -314,22 +332,29 @@ impl<T> RawPtr<T> for *const T {\n     }\n }\n \n-impl<T> RawPtr<T> for *mut T {\n+#[stable]\n+impl<T> PtrExt<T> for *mut T {\n     #[inline]\n+    #[deprecated = \"call ptr::null instead\"]\n     fn null() -> *mut T { null_mut() }\n \n     #[inline]\n-    fn is_null(&self) -> bool { *self == RawPtr::null() }\n+    #[stable]\n+    fn is_null(self) -> bool { self as uint == 0 }\n \n     #[inline]\n-    fn to_uint(&self) -> uint { *self as uint }\n+    #[deprecated = \"use `as uint` instead\"]\n+    fn to_uint(self) -> uint { self as uint }\n \n     #[inline]\n+    #[stable]\n     unsafe fn offset(self, count: int) -> *mut T {\n         intrinsics::offset(self as *const T, count) as *mut T\n     }\n \n     #[inline]\n+    #[unstable = \"return value does not necessarily convey all possible \\\n+                  information\"]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n@@ -339,8 +364,11 @@ impl<T> RawPtr<T> for *mut T {\n     }\n }\n \n-impl<T> RawMutPtr<T> for *mut T {\n+#[stable]\n+impl<T> MutPtrExt<T> for *mut T {\n     #[inline]\n+    #[unstable = \"return value does not necessarily convey all possible \\\n+                  information\"]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n         if self.is_null() {\n             None\n@@ -510,28 +538,33 @@ impl<T> PartialOrd for *mut T {\n /// raw `*mut T` (which conveys no particular ownership semantics).\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n+#[unstable = \"recently added to this module\"]\n pub struct Unique<T>(pub *mut T);\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n+#[unstable = \"recently added to this module\"]\n unsafe impl<T:Send> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n+#[unstable = \"recently added to this module\"]\n unsafe impl<T:Sync> Sync for Unique<T> { }\n \n impl<T> Unique<T> {\n     /// Returns a null Unique.\n+    #[unstable = \"recently added to this module\"]\n     pub fn null() -> Unique<T> {\n-        Unique(RawPtr::null())\n+        Unique(null_mut())\n     }\n \n     /// Return an (unsafe) pointer into the memory owned by `self`.\n+    #[unstable = \"recently added to this module\"]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n-        (self.0 as *const T).offset(offset) as *mut T\n+        self.0.offset(offset)\n     }\n }"}, {"sha": "bd1c6dbcf1e9a4166d4a111cbbc32166dab2969f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -332,7 +332,7 @@ impl<T, E> Result<T, E> {\n \n     /// Convert from `Result<T, E>` to `Option<E>`\n     ///\n-    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// Converts `self` into an `Option<E>`, consuming `self`,\n     /// and discarding the value, if any.\n     ///\n     /// # Example"}, {"sha": "f356a0867d2529b57397d944790dbca42cff5ccb", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -47,7 +47,7 @@ use ops::{FnMut, mod};\n use option::Option;\n use option::Option::{None, Some};\n use ptr;\n-use ptr::RawPtr;\n+use ptr::PtrExt;\n use mem;\n use mem::size_of;\n use kinds::{Sized, marker};\n@@ -1335,7 +1335,7 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n #[deprecated]\n pub mod raw {\n     use mem::transmute;\n-    use ptr::RawPtr;\n+    use ptr::PtrExt;\n     use raw::Slice;\n     use ops::FnOnce;\n     use option::Option;"}, {"sha": "8db672b26537532fa44ad720c5cc91e7558e5c9b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -28,7 +28,7 @@ use mem;\n use num::Int;\n use ops::{Fn, FnMut};\n use option::Option::{mod, None, Some};\n-use ptr::RawPtr;\n+use ptr::PtrExt;\n use raw::{Repr, Slice};\n use result::Result::{mod, Ok, Err};\n use slice::{mod, SliceExt};\n@@ -1073,7 +1073,7 @@ const TAG_CONT_U8: u8 = 0b1000_0000u8;\n /// Unsafe operations\n #[deprecated]\n pub mod raw {\n-    use ptr::RawPtr;\n+    use ptr::PtrExt;\n     use raw::Slice;\n     use slice::SliceExt;\n     use str::StrExt;"}, {"sha": "aa1550ae5b874cfbfd5d08dfcfb82e4af1d4ccf9", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -112,7 +112,7 @@ mod tests {\n \n     #[test]\n     fn test_flate_round_trip() {\n-        let mut r = rand::task_rng();\n+        let mut r = rand::thread_rng();\n         let mut words = vec!();\n         for _ in range(0u, 20) {\n             let range = r.gen_range(1u, 10);"}, {"sha": "f31f3468a4c0065947d957f11a65f0e36c577a57", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -64,7 +64,7 @@ impl Rand for Exp1 {\n /// use std::rand::distributions::{Exp, IndependentSample};\n ///\n /// let exp = Exp::new(2.0);\n-/// let v = exp.ind_sample(&mut rand::task_rng());\n+/// let v = exp.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a Exp(2) distribution\", v);\n /// ```\n #[deriving(Copy)]"}, {"sha": "618db380db8d4d8bdf13e9df1ac8dbf9574d974a", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -44,7 +44,7 @@ use super::{IndependentSample, Sample, Exp};\n /// use std::rand::distributions::{IndependentSample, Gamma};\n ///\n /// let gamma = Gamma::new(2.0, 5.0);\n-/// let v = gamma.ind_sample(&mut rand::task_rng());\n+/// let v = gamma.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a Gamma(2, 5) distribution\", v);\n /// ```\n ///\n@@ -191,7 +191,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// use std::rand::distributions::{ChiSquared, IndependentSample};\n ///\n /// let chi = ChiSquared::new(11.0);\n-/// let v = chi.ind_sample(&mut rand::task_rng());\n+/// let v = chi.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a \u03c7\u00b2(11) distribution\", v)\n /// ```\n pub struct ChiSquared {\n@@ -248,7 +248,7 @@ impl IndependentSample<f64> for ChiSquared {\n /// use std::rand::distributions::{FisherF, IndependentSample};\n ///\n /// let f = FisherF::new(2.0, 32.0);\n-/// let v = f.ind_sample(&mut rand::task_rng());\n+/// let v = f.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from an F(2, 32) distribution\", v)\n /// ```\n pub struct FisherF {\n@@ -292,7 +292,7 @@ impl IndependentSample<f64> for FisherF {\n /// use std::rand::distributions::{StudentT, IndependentSample};\n ///\n /// let t = StudentT::new(11.0);\n-/// let v = t.ind_sample(&mut rand::task_rng());\n+/// let v = t.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a t(11) distribution\", v)\n /// ```\n pub struct StudentT {"}, {"sha": "54cb8ae19071893eb320ef1f13bc208111c83ea1", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -96,7 +96,7 @@ pub struct Weighted<T> {\n ///                      Weighted { weight: 4, item: 'b' },\n ///                      Weighted { weight: 1, item: 'c' });\n /// let wc = WeightedChoice::new(items.as_mut_slice());\n-/// let mut rng = rand::task_rng();\n+/// let mut rng = rand::thread_rng();\n /// for _ in range(0u, 16) {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));"}, {"sha": "3507282ec486af51ce63639998b1c1c624ed3fd7", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -81,7 +81,7 @@ impl Rand for StandardNormal {\n ///\n /// // mean 2, standard deviation 3\n /// let normal = Normal::new(2.0, 3.0);\n-/// let v = normal.ind_sample(&mut rand::task_rng());\n+/// let v = normal.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from a N(2, 9) distribution\", v)\n /// ```\n #[deriving(Copy)]\n@@ -129,7 +129,7 @@ impl IndependentSample<f64> for Normal {\n ///\n /// // mean 2, standard deviation 3\n /// let log_normal = LogNormal::new(2.0, 3.0);\n-/// let v = log_normal.ind_sample(&mut rand::task_rng());\n+/// let v = log_normal.ind_sample(&mut rand::thread_rng());\n /// println!(\"{} is from an ln N(2, 9) distribution\", v)\n /// ```\n #[deriving(Copy)]"}, {"sha": "20ba3566d5b1226601d66f2697a9a8d15c97c63a", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -39,7 +39,7 @@ use distributions::{Sample, IndependentSample};\n ///\n /// fn main() {\n ///     let between = Range::new(10u, 10000u);\n-///     let mut rng = std::rand::task_rng();\n+///     let mut rng = std::rand::thread_rng();\n ///     let mut sum = 0;\n ///     for _ in range(0u, 1000) {\n ///         sum += between.ind_sample(&mut rng);"}, {"sha": "273b991bc22f2a6561f032c014164b82b34551dc", "filename": "src/librand/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -138,10 +138,10 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut v = [0u8, .. 13579];\n-    /// task_rng().fill_bytes(&mut v);\n+    /// thread_rng().fill_bytes(&mut v);\n     /// println!(\"{}\", v.as_slice());\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n@@ -173,9 +173,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let x: uint = rng.gen();\n     /// println!(\"{}\", x);\n     /// println!(\"{}\", rng.gen::<(f64, bool)>());\n@@ -191,9 +191,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n     /// println!(\"{}\", x);\n     /// println!(\"{}\", rng.gen_iter::<(f64, bool)>().take(5)\n@@ -218,9 +218,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let n: uint = rng.gen_range(0u, 10);\n     /// println!(\"{}\", n);\n     /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n@@ -236,9 +236,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.gen_weighted_bool(3));\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n@@ -250,9 +250,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let s: String = task_rng().gen_ascii_chars().take(10).collect();\n+    /// let s: String = thread_rng().gen_ascii_chars().take(10).collect();\n     /// println!(\"{}\", s);\n     /// ```\n     fn gen_ascii_chars<'a>(&'a mut self) -> AsciiGenerator<'a, Self> {\n@@ -266,10 +266,10 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.choose(&choices));\n     /// assert_eq!(rng.choose(choices[..0]), None);\n     /// ```\n@@ -286,9 +286,9 @@ pub trait Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand::{task_rng, Rng};\n+    /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let mut rng = task_rng();\n+    /// let mut rng = thread_rng();\n     /// let mut y = [1i, 2, 3];\n     /// rng.shuffle(&mut y);\n     /// println!(\"{}\", y.as_slice());\n@@ -520,8 +520,8 @@ mod test {\n         }\n     }\n \n-    pub fn rng() -> MyRng<rand::TaskRng> {\n-        MyRng { inner: rand::task_rng() }\n+    pub fn rng() -> MyRng<rand::ThreadRng> {\n+        MyRng { inner: rand::thread_rng() }\n     }\n \n     pub fn weak_rng() -> MyRng<rand::XorShiftRng> {"}, {"sha": "e50153076c390698759ab5f9832b016c0f9c5b5b", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -215,7 +215,7 @@ impl<T:Rand> Rand for Option<T> {\n #[cfg(test)]\n mod tests {\n     use std::prelude::*;\n-    use std::rand::{Rng, task_rng, Open01, Closed01};\n+    use std::rand::{Rng, thread_rng, Open01, Closed01};\n \n     struct ConstantRng(u64);\n     impl Rng for ConstantRng {\n@@ -240,7 +240,7 @@ mod tests {\n     fn rand_open() {\n         // this is unlikely to catch an incorrect implementation that\n         // generates exactly 0 or 1, but it keeps it sane.\n-        let mut rng = task_rng();\n+        let mut rng = thread_rng();\n         for _ in range(0u, 1_000) {\n             // strict inequalities\n             let Open01(f) = rng.gen::<Open01<f64>>();\n@@ -253,7 +253,7 @@ mod tests {\n \n     #[test]\n     fn rand_closed() {\n-        let mut rng = task_rng();\n+        let mut rng = thread_rng();\n         for _ in range(0u, 1_000) {\n             // strict inequalities\n             let Closed01(f) = rng.gen::<Closed01<f64>>();"}, {"sha": "86c02de76dcc6b146839d378ee3473d264c9e814", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -519,8 +519,8 @@ impl<'a> Parser<'a> {\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = String::from_chars(\n-            self.chars[start+1..closer]);\n+        let inner = self.chars[start+1..closer].iter().cloned()\n+                                               .collect::<String>();\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n@@ -954,7 +954,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        String::from_chars(self.chars[start..end])\n+        self.chars[start..end].iter().cloned().collect()\n     }\n }\n "}, {"sha": "17521ff7ea54bb9ebcdaf01e6298451bdb21e68e", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n #![allow(non_snake_case)]\n \n-use std::rand::{Rng, task_rng};\n+use std::rand::{Rng, thread_rng};\n use stdtest::Bencher;\n+use std::iter::repeat;\n \n use regex::{Regex, NoExpand};\n \n@@ -22,38 +23,38 @@ fn bench_assert_match(b: &mut Bencher, re: Regex, text: &str) {\n fn no_exponential(b: &mut Bencher) {\n     let n = 100;\n     let re = Regex::new(format!(\"{}{}\",\n-                                \"a?\".repeat(n),\n-                                \"a\".repeat(n)).as_slice()).unwrap();\n-    let text = \"a\".repeat(n);\n+                                repeat(\"a?\").take(n).collect::<String>(),\n+                                repeat(\"a\").take(n).collect::<String>()).as_slice()).unwrap();\n+    let text = repeat(\"a\").take(n).collect::<String>();\n     bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn literal(b: &mut Bencher) {\n     let re = regex!(\"y\");\n-    let text = format!(\"{}y\", \"x\".repeat(50));\n+    let text = format!(\"{}y\", repeat(\"x\").take(50).collect::<String>());\n     bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn not_literal(b: &mut Bencher) {\n     let re = regex!(\".y\");\n-    let text = format!(\"{}y\", \"x\".repeat(50));\n+    let text = format!(\"{}y\", repeat(\"x\").take(50).collect::<String>());\n     bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn match_class(b: &mut Bencher) {\n     let re = regex!(\"[abcdw]\");\n-    let text = format!(\"{}w\", \"xxxx\".repeat(20));\n+    let text = format!(\"{}w\", repeat(\"xxxx\").take(20).collect::<String>());\n     bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn match_class_in_range(b: &mut Bencher) {\n     // 'b' is between 'a' and 'c', so the class range checking doesn't help.\n     let re = regex!(\"[ac]\");\n-    let text = format!(\"{}c\", \"bbbb\".repeat(20));\n+    let text = format!(\"{}c\", repeat(\"bbbb\").take(20).collect::<String>());\n     bench_assert_match(b, re, text.as_slice());\n }\n \n@@ -77,7 +78,7 @@ fn anchored_literal_short_non_match(b: &mut Bencher) {\n #[bench]\n fn anchored_literal_long_non_match(b: &mut Bencher) {\n     let re = regex!(\"^zbc(d|e)\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\".repeat(15);\n+    let text = repeat(\"abcdefghijklmnopqrstuvwxyz\").take(15).collect::<String>();\n     b.iter(|| re.is_match(text.as_slice()));\n }\n \n@@ -91,7 +92,7 @@ fn anchored_literal_short_match(b: &mut Bencher) {\n #[bench]\n fn anchored_literal_long_match(b: &mut Bencher) {\n     let re = regex!(\"^.bc(d|e)\");\n-    let text = \"abcdefghijklmnopqrstuvwxyz\".repeat(15);\n+    let text = repeat(\"abcdefghijklmnopqrstuvwxyz\").take(15).collect::<String>();\n     b.iter(|| re.is_match(text.as_slice()));\n }\n \n@@ -154,7 +155,7 @@ fn medium() -> Regex { regex!(\"[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn hard() -> Regex { regex!(\"[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n \n fn gen_text(n: uint) -> String {\n-    let mut rng = task_rng();\n+    let mut rng = thread_rng();\n     let mut bytes = rng.gen_ascii_chars().map(|n| n as u8).take(n)\n                        .collect::<Vec<u8>>();\n     for (i, b) in bytes.iter_mut().enumerate() {"}, {"sha": "35c29f646e4a01b1917cff23aa3c3214b298b6b6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1782,9 +1782,9 @@ impl LintPass for Stability {\n         if self.is_internal(cx, item.span) { return }\n \n         match item.node {\n-            ast::ItemTrait(_, _, _, ref supertraits, _) => {\n+            ast::ItemTrait(_, _, ref supertraits, _) => {\n                 for t in supertraits.iter() {\n-                    if let ast::TraitTyParamBound(ref t) = *t {\n+                    if let ast::TraitTyParamBound(ref t, _) = *t {\n                         let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n                         self.lint(cx, id, t.trait_ref.path.span);\n                     }"}, {"sha": "2a670b308b6b213d364c9e1014dd87b4babf39fb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1308,7 +1308,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n       }\n-      ast::ItemTrait(_, _, _, _, ref ms) => {\n+      ast::ItemTrait(_, _, _, ref ms) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);"}, {"sha": "c2992a81d208334d8d55154f6fb22940be885d6f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -25,7 +25,7 @@ use middle::ty::*;\n use middle::ty;\n use std::fmt;\n use std::iter::AdditiveIterator;\n-use std::iter::range_inclusive;\n+use std::iter::{range_inclusive, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{mod, DUMMY_NODE_ID, NodeId, Pat};\n@@ -76,7 +76,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n         }).collect();\n \n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n-        let br = String::from_char(total_width, '+');\n+        let br = repeat('+').take(total_width).collect::<String>();\n         try!(write!(f, \"{}\\n\", br));\n         for row in pretty_printed_matrix.into_iter() {\n             try!(write!(f, \"+\"));"}, {"sha": "3d3eac7b6ed9fe1d38e5aa3c4617bcf62b3fa5f5", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1043,7 +1043,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 ident: ty_param.ident,\n                 id: ty_param.id,\n                 bounds: bounds,\n-                unbound: ty_param.unbound.clone(),\n                 default: ty_param.default.clone(),\n                 span: ty_param.span,\n             }\n@@ -1063,7 +1062,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::TraitTyParamBound(ref poly_tr) => {\n+                &ast::TraitTyParamBound(ref poly_tr, modifier) => {\n                     let tr = &poly_tr.trait_ref;\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n@@ -1087,7 +1086,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             path: new_path,\n                             ref_id: tr.ref_id,\n                         }\n-                    })\n+                    }, modifier)\n                 }\n             }\n         })"}, {"sha": "730da26eda3dccc50f2fd722ffc334596191d193", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -122,7 +122,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             // method to the root. In this case, if the trait is private, then\n             // parent all the methods to the trait to indicate that they're\n             // private.\n-            ast::ItemTrait(_, _, _, _, ref methods) if item.vis != ast::Public => {\n+            ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::ProvidedMethod(ref m) => {\n@@ -328,7 +328,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             // Default methods on traits are all public so long as the trait\n             // is public\n-            ast::ItemTrait(_, _, _, _, ref methods) if public_first => {\n+            ast::ItemTrait(_, _, _, ref methods) if public_first => {\n                 for method in methods.iter() {\n                     match *method {\n                         ast::ProvidedMethod(ref m) => {\n@@ -1178,7 +1178,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemTrait(_, _, _, _, ref methods) => {\n+            ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::ProvidedMethod(ref m) => {\n@@ -1242,7 +1242,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n-            ast::ItemTrait(_, _, _, _, ref methods) => {\n+            ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::RequiredMethod(..) => {}\n@@ -1306,7 +1306,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn check_ty_param_bound(&self,\n                             ty_param_bound: &ast::TyParamBound) {\n-        if let ast::TraitTyParamBound(ref trait_ref) = *ty_param_bound {\n+        if let ast::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n             if !self.tcx.sess.features.borrow().visible_private_types &&\n                 self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n                     let span = trait_ref.trait_ref.path.span;\n@@ -1349,7 +1349,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             // namespace (the contents have their own privacies).\n             ast::ItemForeignMod(_) => {}\n \n-            ast::ItemTrait(_, _, _, ref bounds, _) => {\n+            ast::ItemTrait(_, _, ref bounds, _) => {\n                 if !self.trait_is_public(item.id) {\n                     return\n                 }"}, {"sha": "4feafff3b9211bb1ed823a84906d5b715e9017df", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 ast::ItemTy(_, ref generics) |\n                 ast::ItemEnum(_, ref generics) |\n                 ast::ItemStruct(_, ref generics) |\n-                ast::ItemTrait(_, ref generics, _, _, _) |\n+                ast::ItemTrait(_, ref generics, _, _) |\n                 ast::ItemImpl(_, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n@@ -232,7 +232,9 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n+    fn visit_poly_trait_ref(&mut self, trait_ref:\n+                            &ast::PolyTraitRef,\n+                            _modifier: &ast::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n \n         self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {"}, {"sha": "617be82701a093d6fd3a1f71e0d1915ab61265c6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -4740,7 +4740,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n         match cx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ItemTrait(_, _, _, _, ref ms) => {\n+                    ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n                             ast_util::split_trait_methods(ms[]);\n                         p.iter()"}, {"sha": "7e28cd699a1a6ae4d34e2d2d06d7ab14441e3e12", "filename": "src/librustc_back/arm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farm.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -26,47 +26,47 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsiOS => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsWindows => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsAndroid => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsFreebsd | abi::OsDragonfly => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n         },\n "}, {"sha": "bc7732157cefe3539bfa6b67607b500fe87950f2", "filename": "src/librustc_back/mips.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmips.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -21,47 +21,47 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsiOS => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsWindows => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsAndroid => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsFreebsd | abi::OsDragonfly => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n         },\n "}, {"sha": "3eea0a0dba4052eec331719899da153854c4c4a0", "filename": "src/librustc_back/mipsel.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fmipsel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fmipsel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmipsel.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -21,47 +21,47 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsiOS => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsWindows => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsAndroid => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n \n           abi::OsFreebsd | abi::OsDragonfly => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                 -f32:32:32-f64:64:64\\\n                 -v64:64:64-v128:64:128\\\n-                -a0:0:64-n32\".to_string()\n+                -a:0:64-n32\".to_string()\n           }\n         },\n "}, {"sha": "8bb64eae625f40651fe9cbfde43715a2a0e305cc", "filename": "src/librustc_back/target/arm_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n                       -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n-                      -a0:0:64-n32\".to_string(),\n+                      -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_word_size: \"32\".to_string(),"}, {"sha": "0a5aa56055e1b4e7ea99727aaa7042f40da44d9d", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -24,7 +24,7 @@ pub fn target() -> Target {\n                       -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n-                      -a0:0:64-n32\".to_string(),\n+                      -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_word_size: \"32\".to_string(),"}, {"sha": "985af35e1454cd90e1c06b9485e80f68bebad572", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> Target {\n                       -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n-                      -a0:0:64-n32\".to_string(),\n+                      -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_word_size: \"32\".to_string(),"}, {"sha": "3cf0c31282052f848758a72790ad4f9ea8483f15", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> Target {\n                       -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n-                      -a0:0:64-n32\".to_string(),\n+                      -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_word_size: \"32\".to_string(),"}, {"sha": "45669bc95859967028f6010e14a7780a3fae3e9e", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> Target {\n         data_layout: \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n                       -i32:32:32-i64:32:64\\\n                       -f32:32:32-f64:32:64-v64:64:64\\\n-                      -v128:128:128-a0:0:64-f80:128:128\\\n+                      -v128:128:128-a:0:64-f80:128:128\\\n                       -n8:16:32\".to_string(),\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "feef5b98dcbcf362fc92a4679a8b90ddc2abda3d", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> Target {\n         data_layout: \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n                       -i32:32:32-i64:32:64\\\n                       -f32:32:32-f64:32:64-v64:64:64\\\n-                      -v128:128:128-a0:0:64-f80:128:128\\\n+                      -v128:128:128-a:0:64-f80:128:128\\\n                       -n8:16:32\".to_string(),\n         llvm_target: \"i686-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "c8c5ddcbd0d008c588bd5894974a7bde8890973e", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n                       -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n-                      -a0:0:64-n32\".to_string(),\n+                      -a:0:64-n32\".to_string(),\n         llvm_target: \"mips-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_word_size: \"32\".to_string(),"}, {"sha": "3571f7b26c02184b0dfd0bc01c154f980e56f518", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n                       -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n-                      -a0:0:64-n32\".to_string(),\n+                      -a:0:64-n32\".to_string(),\n         llvm_target: \"mipsel-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_word_size: \"32\".to_string(),"}, {"sha": "07e6cdfed2c672a074d308f1226ebd3b9d388bca", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> Target {\n \n     Target {\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                       s0:64:64-f80:128:128-n8:16:32:64\".to_string(),\n         llvm_target: \"x86_64-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "6ca74eb7fc07d2ee1566bc353ac4e903099ec3d9", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n     Target {\n         // FIXME: Test this. Copied from linux (#2398)\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                       s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "bff3eaf6bc8fa283e31354a089e856108cde7058", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n \n     Target {\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "8d5603a3878dbc9f6cd976d2b3a60fadb3d9ca9a", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n \n     Target {\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                     f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "e0a67cd62504c3075a437e7b681b02ff73797bd7", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n \n     Target {\n         data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                       s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "52c07165900a9b87313a5e6e3044854c87abfb05", "filename": "src/librustc_back/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -22,15 +22,15 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n             \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n                 -i32:32:32-i64:32:64\\\n                 -f32:32:32-f64:32:64-v64:64:64\\\n-                -v128:128:128-a0:0:64-f80:128:128\\\n+                -v128:128:128-a:0:64-f80:128:128\\\n                 -n8:16:32\".to_string()\n           }\n \n           abi::OsiOS => {\n             \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n                 -i32:32:32-i64:32:64\\\n                 -f32:32:32-f64:32:64-v64:64:64\\\n-                -v128:128:128-a0:0:64-f80:128:128\\\n+                -v128:128:128-a:0:64-f80:128:128\\\n                 -n8:16:32\".to_string()\n           }\n "}, {"sha": "cbb288a533d6adba2a49bbdf07343dff20fb6091", "filename": "src/librustc_back/x86_64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_back%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86_64.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -19,42 +19,42 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n         data_layout: match target_os {\n           abi::OsMacos => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n           }\n \n           abi::OsiOS => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n           }\n \n           abi::OsWindows => {\n             // FIXME: Test this. Copied from Linux (#2398)\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n \n           abi::OsLinux => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n           abi::OsAndroid => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n \n           abi::OsFreebsd => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n           abi::OsDragonfly => {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n-                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n                 s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string()\n           }\n "}, {"sha": "e20404bf63891431031c6306c5f5eaf4fcaad563", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -540,7 +540,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     match cfg.spawn(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n-            // Task panicked without emitting a fatal diagnostic\n+            // Thread panicked without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n                 let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n "}, {"sha": "7f01bf087381bf4988fe72779959ec6f2a7bf811", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 130, "deletions": 125, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -345,9 +345,6 @@ impl Rib {\n #[deriving(Show,PartialEq,Clone,Copy)]\n enum Shadowable {\n     Always,\n-    /// Means that the recorded import obeys the glob shadowing rules, i.e., can\n-    /// only be shadowed by another glob import.\n-    Glob,\n     Never\n }\n \n@@ -462,6 +459,22 @@ impl ImportResolution {\n \n         target.unwrap().shadowable\n     }\n+\n+    fn set_target_and_id(&mut self,\n+                         namespace: Namespace,\n+                         target: Option<Target>,\n+                         id: NodeId) {\n+        match namespace {\n+            TypeNS  => {\n+                self.type_target = target;\n+                self.type_id = id;\n+            }\n+            ValueNS => {\n+                self.value_target = target;\n+                self.value_id = id;\n+            }\n+        }\n+    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -1493,7 +1506,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemImpl(_, _, Some(_), _, _) => parent,\n \n-            ItemTrait(_, _, _, _, ref items) => {\n+            ItemTrait(_, _, _, ref items) => {\n                 let name_bindings =\n                     self.add_child(name,\n                                    parent.clone(),\n@@ -1719,11 +1732,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     view_path.span,\n                                                     id,\n                                                     is_public,\n-                                                    if shadowable == Shadowable::Never {\n-                                                        Shadowable::Glob\n-                                                    } else {\n-                                                        shadowable\n-                                                    });\n+                                                    shadowable);\n                     }\n                 }\n             }\n@@ -2712,64 +2721,45 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let import_resolution = &mut (*import_resolutions)[target];\n+        {\n+            let check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+                let namespace_name = match namespace {\n+                    TypeNS => \"type\",\n+                    ValueNS => \"value\",\n+                };\n \n-        match value_result {\n-            BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found value target: {}\",\n-                       { name_bindings.value_def.borrow().clone().unwrap().def });\n-                self.check_for_conflicting_import(\n-                    &import_resolution.value_target,\n-                    directive.span,\n-                    target,\n-                    ValueNS);\n-\n-                self.check_that_import_is_importable(\n-                    &**name_bindings,\n-                    directive.span,\n-                    target,\n-                    ValueNS);\n-\n-                import_resolution.value_target =\n-                    Some(Target::new(target_module.clone(),\n-                                     name_bindings.clone(),\n-                                     directive.shadowable));\n-                import_resolution.value_id = directive.id;\n-                import_resolution.is_public = directive.is_public;\n-                value_used_public = name_bindings.defined_in_public_namespace(ValueNS);\n-            }\n-            UnboundResult => { /* Continue. */ }\n-            UnknownResult => {\n-                panic!(\"value result should be known at this point\");\n-            }\n-        }\n-        match type_result {\n-            BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found type target: {}\",\n-                       { name_bindings.type_def.borrow().clone().unwrap().type_def });\n-                self.check_for_conflicting_import(\n-                    &import_resolution.type_target,\n-                    directive.span,\n-                    target,\n-                    TypeNS);\n-\n-                self.check_that_import_is_importable(\n-                    &**name_bindings,\n-                    directive.span,\n-                    target,\n-                    TypeNS);\n-\n-                import_resolution.type_target =\n-                    Some(Target::new(target_module.clone(),\n-                                     name_bindings.clone(),\n-                                     directive.shadowable));\n-                import_resolution.type_id = directive.id;\n-                import_resolution.is_public = directive.is_public;\n-                type_used_public = name_bindings.defined_in_public_namespace(TypeNS);\n-            }\n-            UnboundResult => { /* Continue. */ }\n-            UnknownResult => {\n-                panic!(\"type result should be known at this point\");\n-            }\n+                match *result {\n+                    BoundResult(ref target_module, ref name_bindings) => {\n+                        debug!(\"(resolving single import) found {} target: {}\",\n+                               namespace_name,\n+                               name_bindings.def_for_namespace(namespace));\n+                        self.check_for_conflicting_import(\n+                            &import_resolution.target_for_namespace(namespace),\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        self.check_that_import_is_importable(\n+                            &**name_bindings,\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        let target = Some(Target::new(target_module.clone(),\n+                                                      name_bindings.clone(),\n+                                                      directive.shadowable));\n+                        import_resolution.set_target_and_id(namespace, target, directive.id);\n+                        import_resolution.is_public = directive.is_public;\n+                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                    }\n+                    UnboundResult => { /* Continue. */ }\n+                    UnknownResult => {\n+                        panic!(\"{} result should be known at this point\", namespace_name);\n+                    }\n+                }\n+            };\n+            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n+            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n         }\n \n         self.check_for_conflicts_between_imports_and_items(\n@@ -2825,7 +2815,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid).\n+    // that exports nothing is valid). containing_module is the module we are\n+    // actually importing, i.e., `foo` in `use foo::*`.\n     fn resolve_glob_import(&mut self,\n                            module_: &Module,\n                            containing_module: Rc<Module>,\n@@ -2851,12 +2842,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         assert_eq!(containing_module.glob_count.get(), 0);\n \n         // Add all resolved imports from the containing module.\n-        let import_resolutions = containing_module.import_resolutions\n-                                                  .borrow();\n+        let import_resolutions = containing_module.import_resolutions.borrow();\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   target_import_resolution.type_target.is_none(),\n+                   token::get_name(*ident),\n                    self.module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -2876,17 +2866,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // Continue.\n                         }\n                         Some(ref value_target) => {\n-                            dest_import_resolution.value_target =\n-                                Some(value_target.clone());\n+                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              ValueNS);\n+                            dest_import_resolution.value_target = Some(value_target.clone());\n                         }\n                     }\n                     match target_import_resolution.type_target {\n                         None => {\n                             // Continue.\n                         }\n                         Some(ref type_target) => {\n-                            dest_import_resolution.type_target =\n-                                Some(type_target.clone());\n+                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              TypeNS);\n+                            dest_import_resolution.type_target = Some(type_target.clone());\n                         }\n                     }\n                     dest_import_resolution.is_public = is_public;\n@@ -2908,8 +2904,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add all children from the containing module.\n         self.populate_module_if_necessary(&containing_module);\n \n-        for (&name, name_bindings) in containing_module.children\n-                                                       .borrow().iter() {\n+        for (&name, name_bindings) in containing_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n                                          containing_module.clone(),\n                                          import_directive,\n@@ -2919,8 +2914,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add external module children from the containing module.\n-        for (&name, module) in containing_module.external_module_children\n-                                                .borrow().iter() {\n+        for (&name, module) in containing_module.external_module_children.borrow().iter() {\n             let name_bindings =\n                 Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n@@ -2965,41 +2959,39 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               token::get_name(name).get().to_string(),\n+               token::get_name(name).get(),\n                self.module_to_string(&*containing_module),\n                self.module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n-        if name_bindings.defined_in_namespace_with(ValueNS, IMPORTABLE | PUBLIC) {\n-            debug!(\"(resolving glob import) ... for value target\");\n-            if dest_import_resolution.shadowable(ValueNS) == Shadowable::Never {\n-                let msg = format!(\"a value named `{}` has already been imported \\\n-                                   in this module\",\n-                                  token::get_name(name).get());\n-                self.session.span_err(import_directive.span, msg.as_slice());\n-            } else {\n-                dest_import_resolution.value_target =\n-                    Some(Target::new(containing_module.clone(),\n-                                     name_bindings.clone(),\n-                                     import_directive.shadowable));\n-                dest_import_resolution.value_id = id;\n-            }\n-        }\n-        if name_bindings.defined_in_namespace_with(TypeNS, IMPORTABLE | PUBLIC) {\n-            debug!(\"(resolving glob import) ... for type target\");\n-            if dest_import_resolution.shadowable(TypeNS) == Shadowable::Never {\n-                let msg = format!(\"a type named `{}` has already been imported \\\n-                                   in this module\",\n-                                  token::get_name(name).get());\n-                self.session.span_err(import_directive.span, msg.as_slice());\n-            } else {\n-                dest_import_resolution.type_target =\n-                    Some(Target::new(containing_module,\n-                                     name_bindings.clone(),\n-                                     import_directive.shadowable));\n-                dest_import_resolution.type_id = id;\n-            }\n+        {\n+            let merge_child_item = |namespace| {\n+                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                    let namespace_name = match namespace {\n+                        TypeNS => \"type\",\n+                        ValueNS => \"value\",\n+                    };\n+                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n+                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n+                        let msg = format!(\"a {} named `{}` has already been imported \\\n+                                           in this module\",\n+                                          namespace_name,\n+                                          token::get_name(name).get());\n+                        self.session.span_err(import_directive.span, msg.as_slice());\n+                    } else {\n+                        let target = Target::new(containing_module.clone(),\n+                                                 name_bindings.clone(),\n+                                                 import_directive.shadowable);\n+                        dest_import_resolution.set_target_and_id(namespace,\n+                                                                 Some(target),\n+                                                                 id);\n+                    }\n+                }\n+            };\n+            merge_child_item(ValueNS);\n+            merge_child_item(TypeNS);\n         }\n+\n         dest_import_resolution.is_public = is_public;\n \n         self.check_for_conflicts_between_imports_and_items(\n@@ -3019,6 +3011,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return\n         }\n \n+        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n+               token::get_name(name).get(),\n+               target.is_some());\n+\n         match *target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let msg = format!(\"a {} named `{}` has already been imported \\\n@@ -4008,6 +4004,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n+    /// Searches the current set of local scopes and\n+    /// applies translations for closures.\n     fn search_ribs(&self,\n                    ribs: &[Rib],\n                    name: Name,\n@@ -4029,6 +4027,27 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n+    /// Searches the current set of local scopes for labels.\n+    /// Stops after meeting a closure.\n+    fn search_label(&self, name: Name) -> Option<DefLike> {\n+        for rib in self.label_ribs.iter().rev() {\n+            match rib.kind {\n+                NormalRibKind => {\n+                    // Continue\n+                }\n+                _ => {\n+                    // Do not resolve labels across function boundary\n+                    return None\n+                }\n+            }\n+            let result = rib.bindings.get(&name).cloned();\n+            if result.is_some() {\n+                return result\n+            }\n+        }\n+        None\n+    }\n+\n     fn resolve_crate(&mut self, krate: &ast::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n@@ -4093,7 +4112,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             impl_items[]);\n             }\n \n-            ItemTrait(_, ref generics, ref unbound, ref bounds, ref trait_items) => {\n+            ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the self type.\n                 let mut self_type_rib = Rib::new(ItemRibKind);\n \n@@ -4114,13 +4133,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.resolve_type_parameter_bounds(item.id, bounds,\n                                                        TraitDerivation);\n \n-                    match *unbound {\n-                        Some(ref tpb) => {\n-                            this.resolve_trait_reference(item.id, tpb, TraitDerivation);\n-                        }\n-                        None => {}\n-                    }\n-\n                     for trait_item in (*trait_items).iter() {\n                         // Create a new rib for the trait_item-specific type\n                         // parameters.\n@@ -4368,12 +4380,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             self.resolve_type_parameter_bound(type_parameter.id, bound,\n                                               TraitBoundingTypeParameter);\n         }\n-        match &type_parameter.unbound {\n-            &Some(ref unbound) =>\n-                self.resolve_trait_reference(\n-                    type_parameter.id, unbound, TraitBoundingTypeParameter),\n-            &None => {}\n-        }\n         match type_parameter.default {\n             Some(ref ty) => self.resolve_type(&**ty),\n             None => {}\n@@ -4395,7 +4401,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     type_parameter_bound: &TyParamBound,\n                                     reference_type: TraitReferenceType) {\n         match *type_parameter_bound {\n-            TraitTyParamBound(ref tref) => {\n+            TraitTyParamBound(ref tref, _) => {\n                 self.resolve_poly_trait_reference(id, tref, reference_type)\n             }\n             RegionTyParamBound(..) => {}\n@@ -5848,8 +5854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);\n-                match self.search_ribs(self.label_ribs[],\n-                                       renamed, expr.span) {\n+                match self.search_label(renamed) {\n                     None => {\n                         self.resolve_error(\n                             expr.span,"}, {"sha": "99e11bf520205926d355518a2e2c17f1f01dd2ab", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -98,7 +98,7 @@ impl SharedEmitter {\n     }\n \n     fn dump(&mut self, handler: &Handler) {\n-        let mut buffer = self.buffer.lock();\n+        let mut buffer = self.buffer.lock().unwrap();\n         for diag in buffer.iter() {\n             match diag.code {\n                 Some(ref code) => {\n@@ -123,7 +123,7 @@ impl Emitter for SharedEmitter {\n             msg: &str, code: Option<&str>, lvl: Level) {\n         assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n \n-        self.buffer.lock().push(Diagnostic {\n+        self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n             code: code.map(|s| s.to_string()),\n             lvl: lvl,\n@@ -915,7 +915,7 @@ fn run_work_multithreaded(sess: &Session,\n \n             loop {\n                 // Avoid holding the lock for the entire duration of the match.\n-                let maybe_work = work_items_arc.lock().pop();\n+                let maybe_work = work_items_arc.lock().unwrap().pop();\n                 match maybe_work {\n                     Some(work) => {\n                         execute_work_item(&cgcx, work);"}, {"sha": "51ea0af8e10eaa3ccccdfed1883069cf6c16bebc", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 66, "deletions": 60, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -636,7 +636,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, enum_name[], variant.node.id);\n+                        self.process_struct_field_def(field, qualname[], variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n@@ -710,7 +710,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // super-traits\n         for super_bound in trait_refs.iter() {\n             let trait_ref = match *super_bound {\n-                ast::TraitTyParamBound(ref trait_ref) => {\n+                ast::TraitTyParamBound(ref trait_ref, _) => {\n                     trait_ref\n                 }\n                 ast::RegionTyParamBound(..) => {\n@@ -763,37 +763,38 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_path(&mut self,\n-                    ex: &ast::Expr,\n-                    path: &ast::Path) {\n+                    id: NodeId,\n+                    span: Span,\n+                    path: &ast::Path,\n+                    ref_kind: Option<recorder::Row>) {\n         if generated_code(path.span) {\n             return\n         }\n \n         let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&ex.id) {\n-            self.sess.span_bug(ex.span,\n-                               format!(\"def_map has no key for {} in visit_expr\",\n-                                       ex.id)[]);\n+        if !def_map.contains_key(&id) {\n+            self.sess.span_bug(span,\n+                               format!(\"def_map has no key for {} in visit_expr\", id)[]);\n         }\n-        let def = &(*def_map)[ex.id];\n-        let sub_span = self.span.span_for_last_ident(ex.span);\n+        let def = &(*def_map)[id];\n+        let sub_span = self.span.span_for_last_ident(span);\n         match *def {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n             def::DefConst(..) |\n-            def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n-                                                    ex.span,\n+            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n+                                                    span,\n                                                     sub_span,\n                                                     def.def_id(),\n                                                     self.cur_scope),\n             def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n-                                                       ex.span,\n+                                                       span,\n                                                        sub_span,\n                                                        def_id,\n-                                                        self.cur_scope),\n+                                                       self.cur_scope),\n             def::DefStaticMethod(declid, provenence) => {\n-                let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+                let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n                                                     declid);\n@@ -828,34 +829,31 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                self.fmt.meth_call_str(ex.span,\n+                self.fmt.meth_call_str(span,\n                                        sub_span,\n                                        defid,\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _) => self.fmt.fn_call_str(ex.span,\n-                                                             sub_span,\n-                                                             def_id,\n-                                                             self.cur_scope),\n-            _ => self.sess.span_bug(ex.span,\n+            def::DefFn(def_id, _) => self.fmt.fn_call_str(span,\n+                                                          sub_span,\n+                                                          def_id,\n+                                                          self.cur_scope),\n+            _ => self.sess.span_bug(span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(ex.span))[]),\n+                                            self.span.snippet(span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n-            def::DefStaticMethod(..) => {\n-                self.write_sub_path_trait_truncated(path);\n-            },\n+            def::DefStaticMethod(..) => self.write_sub_path_trait_truncated(path),\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n             def::DefStruct(_) |\n+            def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path),\n             _ => {},\n         }\n-\n-        visit::walk_path(self, path);\n     }\n \n     fn process_struct_lit(&mut self,\n@@ -982,18 +980,19 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n-                    self.visit_pat(&*field.pat);\n+                    let sub_span = self.span.span_for_first_ident(span);\n                     let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n                     for f in fields.iter() {\n                         if f.name == field.ident.name {\n                             self.fmt.ref_str(recorder::VarRef,\n-                                             p.span,\n-                                             Some(span),\n+                                             span,\n+                                             sub_span,\n                                              f.id,\n                                              self.cur_scope);\n                             break;\n                         }\n                     }\n+                    self.visit_pat(&*field.pat);\n                 }\n             }\n             ast::PatEnum(ref path, _) => {\n@@ -1052,7 +1051,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                   &**typ,\n                                   impl_items)\n             }\n-            ast::ItemTrait(_, ref generics, _, ref trait_refs, ref methods) =>\n+            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, m),\n             ast::ItemTy(ref ty, ref ty_params) => {\n@@ -1076,7 +1075,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_generics(&mut self, generics: &ast::Generics) {\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n-                if let ast::TraitTyParamBound(ref trait_ref) = *bound {\n+                if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n                     self.process_trait_ref(&trait_ref.trait_ref, None);\n                 }\n             }\n@@ -1162,8 +1161,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match i.node {\n-            ast::ViewItemUse(ref path) => {\n-                match path.node {\n+            ast::ViewItemUse(ref item) => {\n+                match item.node {\n                     ast::ViewPathSimple(ident, ref path, id) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n                         let mod_id = match self.lookup_type_ref(id) {\n@@ -1184,7 +1183,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         // 'use' always introduces an alias, if there is not an explicit\n                         // one, there is an implicit one.\n                         let sub_span =\n-                            match self.span.sub_span_before_token(path.span, token::Eq) {\n+                            match self.span.sub_span_after_keyword(item.span, keywords::As) {\n                                 Some(sub_span) => Some(sub_span),\n                                 None => sub_span,\n                             };\n@@ -1308,7 +1307,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n             },\n-            ast::ExprPath(ref path) => self.process_path(ex, path),\n+            ast::ExprPath(ref path) => {\n+                self.process_path(ex.id, ex.span, path, None);\n+                visit::walk_path(self, path);\n+            }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n@@ -1405,46 +1407,50 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_arm(&mut self, arm: &ast::Arm) {\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n-\n         for pattern in arm.pats.iter() {\n             // collect paths from the arm's patterns\n             self.visit_pat(&**pattern);\n         }\n-        self.collecting = false;\n+\n+        // This is to get around borrow checking, because we need mut self to call process_path.\n+        let mut paths_to_process = vec![];\n         // process collected paths\n         for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n-            let value = if *immut {\n-                self.span.snippet(p.span).to_string()\n-            } else {\n-                \"<mutable>\".to_string()\n-            };\n-            let sub_span = self.span.span_for_first_ident(p.span);\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\",\n-                                           id)[]);\n+                                   format!(\"def_map has no key for {} in visit_arm\", id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n-                def::DefLocal(id)  => self.fmt.variable_str(p.span,\n-                                                            sub_span,\n-                                                            id,\n-                                                            path_to_string(p)[],\n-                                                            value[],\n-                                                            \"\"),\n-                def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n-                                                            p.span,\n-                                                            sub_span,\n-                                                            id,\n-                                                            self.cur_scope),\n-                // FIXME(nrc) what is this doing here?\n+                def::DefLocal(id)  => {\n+                    let value = if *immut {\n+                        self.span.snippet(p.span).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+\n+                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n+                    self.fmt.variable_str(p.span,\n+                                          Some(p.span),\n+                                          id,\n+                                          path_to_string(p)[],\n+                                          value[],\n+                                          \"\")\n+                }\n+                def::DefVariant(..) => {\n+                    paths_to_process.push((id, p.span, p.clone(), Some(ref_kind)))\n+                }\n+                // FIXME(nrc) what are these doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {}\",\n-                            *def)\n+                _ => error!(\"unexpected definition kind when processing collected paths: {}\", *def)\n             }\n         }\n+        for &(id, span, ref path, ref_kind) in paths_to_process.iter() {\n+            self.process_path(id, span, path, ref_kind);\n+        }\n+        self.collecting = false;\n         self.collected_paths.clear();\n         visit::walk_expr_opt(self, &arm.guard);\n         self.visit_expr(&*arm.body);"}, {"sha": "f62073e54e6d963e4345d811c0d4c1dc060e4191", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -61,7 +61,7 @@ macro_rules! svec {\n     })\n }\n \n-#[deriving(Copy)]\n+#[deriving(Copy,Show)]\n pub enum Row {\n     Variable,\n     Enum,"}, {"sha": "244d0476832bdb7545699a8cc436dd1ca03cdb64", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -294,8 +294,8 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     pub fn sub_span_after_keyword(&self,\n-                              span: Span,\n-                              keyword: keywords::Keyword) -> Option<Span> {\n+                                  span: Span,\n+                                  keyword: keywords::Keyword) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n             let ts = toks.real_token();"}, {"sha": "f0d738d839d7a01e281de85cfc35ae38926af7cc", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -983,23 +983,14 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n                           fn_ty: Ty<'tcx>,\n-                          call_info: Option<NodeInfo>,\n-                          // FIXME(15064) is_lang_item is a horrible hack, please remove it\n-                          // at the soonest opportunity.\n-                          is_lang_item: bool)\n+                          call_info: Option<NodeInfo>)\n                           -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    // FIXME(15064) Lang item methods may (in the reflect case) not have proper\n-    // types, so doing an attribute lookup will fail.\n-    let attributes = if is_lang_item {\n-        llvm::AttrBuilder::new()\n-    } else {\n-        get_fn_llvm_attributes(bcx.ccx(), fn_ty)\n-    };\n+    let attributes = get_fn_llvm_attributes(bcx.ccx(), fn_ty);\n \n     match bcx.opt_node_id {\n         None => {\n@@ -1554,8 +1545,7 @@ pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n+type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n \n // create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into"}, {"sha": "5249f59d78f750b28ab2a1c001a41adda06f27b7", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn().val_to_string(val),\n                self.ccx.tn().val_to_string(ptr));\n-        assert!(self.llbuilder.is_not_null());\n+        assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         unsafe {\n             llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn().val_to_string(val),\n                self.ccx.tn().val_to_string(ptr));\n-        assert!(self.llbuilder.is_not_null());\n+        assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);"}, {"sha": "a159cda9fbaed81819d511ae1e2040ef48a6b00f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -779,8 +779,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                       llfn,\n                                       llargs[],\n                                       callee_ty,\n-                                      call_info,\n-                                      dest.is_none());\n+                                      call_info);\n         bcx = b;\n         llresult = llret;\n "}, {"sha": "b15b75c6715b755ddeeb0f9c1b2beabbd3d83f98", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -190,8 +190,8 @@ pub fn validate_substs(substs: &Substs) {\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n-pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n+type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these."}, {"sha": "e0a878c8261ef9f8a866ec02c491e0c22af3ceda", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -292,7 +292,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args[], dtor_ty, None, false);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args[], dtor_ty, None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx"}, {"sha": "9e959ce4221e71f8f61052169507b4bb8f1c1f89", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -20,7 +20,7 @@ pub struct Value(pub ValueRef);\n macro_rules! opt_val { ($e:expr) => (\n     unsafe {\n         match $e {\n-            p if p.is_not_null() => Some(Value(p)),\n+            p if !p.is_null() => Some(Value(p)),\n             _ => None\n         }\n     }\n@@ -37,7 +37,7 @@ impl Value {\n     pub fn get_parent(self) -> Option<BasicBlock> {\n         unsafe {\n             match llvm::LLVMGetInstructionParent(self.get()) {\n-                p if p.is_not_null() => Some(BasicBlock(p)),\n+                p if !p.is_null() => Some(BasicBlock(p)),\n                 _ => None\n             }\n         }\n@@ -77,7 +77,7 @@ impl Value {\n     pub fn get_first_use(self) -> Option<Use> {\n         unsafe {\n             match llvm::LLVMGetFirstUse(self.get()) {\n-                u if u.is_not_null() => Some(Use(u)),\n+                u if !u.is_null() => Some(Use(u)),\n                 _ => None\n             }\n         }\n@@ -119,7 +119,7 @@ impl Value {\n     /// Tests if this value is a terminator instruction\n     pub fn is_a_terminator_inst(self) -> bool {\n         unsafe {\n-            llvm::LLVMIsATerminatorInst(self.get()).is_not_null()\n+            !llvm::LLVMIsATerminatorInst(self.get()).is_null()\n         }\n     }\n }\n@@ -142,7 +142,7 @@ impl Use {\n     pub fn get_next_use(self) -> Option<Use> {\n         unsafe {\n             match llvm::LLVMGetNextUse(self.get()) {\n-                u if u.is_not_null() => Some(Use(u)),\n+                u if !u.is_null() => Some(Use(u)),\n                 _ => None\n             }\n         }"}, {"sha": "d6f1f5fedc5817554a085a5ae922074b65774a01", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -164,10 +164,16 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                             let mut m = String::new();\n                             let len = v.len();\n                             for (i, (name, n)) in v.into_iter().enumerate() {\n-                                m.push_str(if n == 1 {\n+                                let help_name = if name.is_empty() {\n+                                    format!(\"argument {}\", i + 1)\n+                                } else {\n                                     format!(\"`{}`\", name)\n+                                };\n+\n+                                m.push_str(if n == 1 {\n+                                    help_name\n                                 } else {\n-                                    format!(\"one of `{}`'s {} elided lifetimes\", name, n)\n+                                    format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n                                 }[]);\n \n                                 if len == 2 && i == 0 {\n@@ -1626,7 +1632,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut trait_def_ids = DefIdMap::new();\n     for ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n-            ast::TraitTyParamBound(ref b) => {\n+            ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {\n@@ -1664,6 +1670,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                 }\n                 trait_bounds.push(b);\n             }\n+            ast::TraitTyParamBound(_, ast::TraitBoundModifier::Maybe) => {}\n             ast::RegionTyParamBound(ref l) => {\n                 region_bounds.push(l);\n             }"}, {"sha": "c8c8211f29253ce3a5671f133a64e1b82503eaee", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -673,7 +673,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         }\n \n       }\n-      ast::ItemTrait(_, _, _, _, ref trait_methods) => {\n+      ast::ItemTrait(_, _, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in trait_methods.iter() {\n             match *trait_method {"}, {"sha": "8d07f1e4355031c2c32f8d2c7b519bcd18faed1e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -259,7 +259,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_def: &ty::TraitDef<'tcx>) {\n     let tcx = ccx.tcx;\n     if let ast_map::NodeItem(item) = tcx.map.get(trait_id) {\n-        if let ast::ItemTrait(_, _, _, _, ref trait_items) = item.node {\n+        if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.impl_or_trait_items` table:\n             for trait_item in trait_items.iter() {\n@@ -627,11 +627,6 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                 ast::RegionTyParamBound(..) => { }\n             }\n         }\n-\n-        match ty_param.unbound {\n-            Some(_) => { warn = true; }\n-            None => { }\n-        }\n     }\n \n     if warn {\n@@ -1146,7 +1141,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                                AllowEqConstraints::DontAllow);\n             }\n         },\n-        ast::ItemTrait(_, _, _, _, ref trait_methods) => {\n+        ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n \n             debug!(\"trait_def: ident={} trait_def={}\",\n@@ -1338,13 +1333,12 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return def.clone();\n     }\n \n-    let (unsafety, generics, unbound, bounds, items) = match it.node {\n+    let (unsafety, generics, bounds, items) = match it.node {\n         ast::ItemTrait(unsafety,\n                        ref generics,\n-                       ref unbound,\n                        ref supertraits,\n                        ref items) => {\n-            (unsafety, generics, unbound, supertraits, items.as_slice())\n+            (unsafety, generics, supertraits, items.as_slice())\n         }\n         ref s => {\n             tcx.sess.span_bug(\n@@ -1367,7 +1361,6 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 token::SELF_KEYWORD_NAME,\n                                 self_param_ty,\n                                 bounds.as_slice(),\n-                                unbound,\n                                 it.span);\n \n     let substs = mk_item_substs(ccx, &ty_generics);\n@@ -1683,29 +1676,37 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n                 create_type_parameters_for_associated_types)\n }\n \n-// Add the Sized bound, unless the type parameter is marked as `Sized?`.\n+// Add the Sized bound, unless the type parameter is marked as `?Sized`.\n fn add_unsized_bound<'tcx,AC>(this: &AC,\n-                              unbound: &Option<ast::TraitRef>,\n                               bounds: &mut ty::BuiltinBounds,\n-                              desc: &str,\n+                              ast_bounds: &[ast::TyParamBound],\n                               span: Span)\n                               where AC: AstConv<'tcx> {\n+    // Try to find an unbound in bounds.\n+    let mut unbound = None;\n+    for ab in ast_bounds.iter() {\n+        if let &ast::TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = ab  {\n+            if unbound.is_none() {\n+                assert!(ptr.bound_lifetimes.is_empty());\n+                unbound = Some(ptr.trait_ref.clone());\n+            } else {\n+                this.tcx().sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                                                bound, only one is supported\");\n+            }\n+        }\n+    }\n+\n     let kind_id = this.tcx().lang_items.require(SizedTraitLangItem);\n     match unbound {\n-        &Some(ref tpb) => {\n+        Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             let trait_def_id = ty::trait_ref_to_def_id(this.tcx(), tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n                     this.tcx().sess.span_warn(span,\n-                                              format!(\"default bound relaxed \\\n-                                                       for a {}, but this \\\n-                                                       does nothing because \\\n-                                                       the given bound is not \\\n-                                                       a default. \\\n-                                                       Only `Sized?` is \\\n-                                                       supported\",\n-                                                      desc)[]);\n+                                              \"default bound relaxed for a type parameter, but \\\n+                                               this does nothing because the given bound is not \\\n+                                               a default. Only `?Sized` is supported\");\n                     ty::try_add_builtin_trait(this.tcx(),\n                                               kind_id,\n                                               bounds);\n@@ -1717,7 +1718,7 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n             ty::try_add_builtin_trait(this.tcx(), kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n-        &None => {}\n+        None => {}\n     }\n }\n \n@@ -1807,7 +1808,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n-                        &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref) => {\n+                        &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let trait_ref = astconv::instantiate_poly_trait_ref(\n                                 this,\n                                 &ExplicitRscope,\n@@ -1880,7 +1881,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n             for bound in param.bounds.iter() {\n                 // In the above example, `ast_trait_ref` is `Iterator`.\n                 let ast_trait_ref = match *bound {\n-                    ast::TraitTyParamBound(ref r) => r,\n+                    ast::TraitTyParamBound(ref r, _) => r,\n                     ast::RegionTyParamBound(..) => { continue; }\n                 };\n \n@@ -1978,7 +1979,6 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                 param.ident.name,\n                                 param_ty,\n                                 param.bounds[],\n-                                &param.unbound,\n                                 param.span);\n     let default = match param.default {\n         None => None,\n@@ -2023,7 +2023,6 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                            name_of_bounded_thing: ast::Name,\n                            param_ty: ty::ParamTy,\n                            ast_bounds: &[ast::TyParamBound],\n-                           unbound: &Option<ast::TraitRef>,\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n                            where AC: AstConv<'tcx> {\n@@ -2032,11 +2031,9 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                                              param_ty,\n                                              ast_bounds);\n \n-\n     add_unsized_bound(this,\n-                      unbound,\n                       &mut param_bounds.builtin_bounds,\n-                      \"type parameter\",\n+                      ast_bounds,\n                       span);\n \n     check_bounds_compatible(this.tcx(),"}, {"sha": "30869186ba5e9ef7f67cd184c7cbcae15500d00b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(_, ref generics, _, _, _) => {\n+            ast::ItemTrait(_, ref generics, _, _) => {\n                 for (i, p) in generics.lifetimes.iter().enumerate() {\n                     let id = p.lifetime.id;\n                     self.add_inferred(item.id, RegionParam, TypeSpace, i, id);"}, {"sha": "3eda39f54a997e8a036a280d024bf73c92bed2bf", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -163,13 +163,12 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n-    let (bounds, default_unbound) = trait_def.bounds.clean(cx);\n+    let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n         unsafety: def.unsafety,\n         generics: (&def.generics, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n         bounds: bounds,\n-        default_unbound: default_unbound\n     }\n }\n \n@@ -328,7 +327,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             derived: clean::detect_derived(attrs.as_slice()),\n             trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n-                    clean::TraitBound(polyt) => polyt.trait_,\n+                    clean::TraitBound(polyt, _) => polyt.trait_,\n                     clean::RegionBound(..) => unreachable!(),\n                 }\n             }),"}, {"sha": "b7845f23be2983ea92eb219cf8b6a5f37b39065b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 34, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -458,8 +458,6 @@ pub struct TyParam {\n     pub did: ast::DefId,\n     pub bounds: Vec<TyParamBound>,\n     pub default: Option<Type>,\n-    /// An optional default bound on the parameter which is unbound, like `Sized?`\n-    pub default_unbound: Option<Type>\n }\n \n impl Clean<TyParam> for ast::TyParam {\n@@ -469,7 +467,6 @@ impl Clean<TyParam> for ast::TyParam {\n             did: ast::DefId { krate: ast::LOCAL_CRATE, node: self.id },\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n-            default_unbound: self.unbound.clean(cx)\n         }\n     }\n }\n@@ -478,28 +475,27 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         cx.external_typarams.borrow_mut().as_mut().unwrap()\n           .insert(self.def_id, self.name.clean(cx));\n-        let (bounds, default_unbound) = self.bounds.clean(cx);\n+        let bounds = self.bounds.clean(cx);\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n             bounds: bounds,\n             default: self.default.clean(cx),\n-            default_unbound: default_unbound\n         }\n     }\n }\n \n #[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n-    TraitBound(PolyTrait)\n+    TraitBound(PolyTrait, ast::TraitBoundModifier)\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         match *self {\n             ast::RegionTyParamBound(lt) => RegionBound(lt.clean(cx)),\n-            ast::TraitTyParamBound(ref t) => TraitBound(t.clean(cx)),\n+            ast::TraitTyParamBound(ref t, modifier) => TraitBound(t.clean(cx), modifier),\n         }\n     }\n }\n@@ -600,7 +596,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                 did: did,\n             },\n             lifetimes: vec![]\n-        })\n+        }, ast::TraitBoundModifier::None)\n     }\n }\n \n@@ -648,37 +644,20 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         TraitBound(PolyTrait {\n             trait_: ResolvedPath { path: path, typarams: None, did: self.def_id, },\n             lifetimes: late_bounds\n-        })\n+        }, ast::TraitBoundModifier::None)\n     }\n }\n \n-// Returns (bounds, default_unbound)\n-impl<'tcx> Clean<(Vec<TyParamBound>, Option<Type>)> for ty::ParamBounds<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> (Vec<TyParamBound>, Option<Type>) {\n+impl<'tcx> Clean<Vec<TyParamBound>> for ty::ParamBounds<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut v = Vec::new();\n-        let mut has_sized_bound = false;\n-        for b in self.builtin_bounds.iter() {\n-            if b != ty::BoundSized {\n-                v.push(b.clean(cx));\n-            } else {\n-                has_sized_bound = true;\n-            }\n-        }\n         for t in self.trait_bounds.iter() {\n             v.push(t.clean(cx));\n         }\n         for r in self.region_bounds.iter().filter_map(|r| r.clean(cx)) {\n             v.push(RegionBound(r));\n         }\n-        if has_sized_bound {\n-            (v, None)\n-        } else {\n-            let ty = match ty::BoundSized.clean(cx) {\n-                TraitBound(polyt) => polyt.trait_,\n-                _ => unreachable!()\n-            };\n-            (v, Some(ty))\n-        }\n+        v\n     }\n }\n \n@@ -689,7 +668,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n         v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n-        })));\n+        }, ast::TraitBoundModifier::None)));\n         if v.len() > 0 {Some(v)} else {None}\n     }\n }\n@@ -1047,8 +1026,6 @@ pub struct Trait {\n     pub items: Vec<TraitMethod>,\n     pub generics: Generics,\n     pub bounds: Vec<TyParamBound>,\n-    /// An optional default bound not required for `Self`, like `Sized?`\n-    pub default_unbound: Option<Type>\n }\n \n impl Clean<Item> for doctree::Trait {\n@@ -1065,7 +1042,6 @@ impl Clean<Item> for doctree::Trait {\n                 items: self.items.clean(cx),\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n-                default_unbound: self.default_unbound.clean(cx)\n             }),\n         }\n     }\n@@ -2412,7 +2388,6 @@ impl Clean<Item> for ty::AssociatedType {\n                 },\n                 bounds: vec![],\n                 default: None,\n-                default_unbound: None\n             }),\n             visibility: None,\n             def_id: self.def_id,"}, {"sha": "251ce5aefeb717429c5542d5d2ac10a0e7ae12b0", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -178,7 +178,6 @@ pub struct Trait {\n     pub whence: Span,\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n-    pub default_unbound: Option<ast::TraitRef> // FIXME(tomjakubowski)\n }\n \n pub struct Impl {"}, {"sha": "585183e2af75ed27ae2d22307000c5293cc52a23", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -97,9 +97,6 @@ impl fmt::Show for clean::Generics {\n                 if i > 0 {\n                     try!(f.write(\", \".as_bytes()))\n                 }\n-                if let Some(ref unbound) = tp.default_unbound {\n-                    try!(write!(f, \"{}? \", unbound));\n-                };\n                 try!(f.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n@@ -123,7 +120,7 @@ impl<'a> fmt::Show for WhereClause<'a> {\n         if gens.where_predicates.len() == 0 {\n             return Ok(());\n         }\n-        try!(f.write(\" where \".as_bytes()));\n+        try!(f.write(\" <span class='where'>where \".as_bytes()));\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n                 try!(f.write(\", \".as_bytes()));\n@@ -149,6 +146,7 @@ impl<'a> fmt::Show for WhereClause<'a> {\n                 }\n             }\n         }\n+        try!(f.write(\"</span>\".as_bytes()));\n         Ok(())\n     }\n }\n@@ -182,8 +180,12 @@ impl fmt::Show for clean::TyParamBound {\n             clean::RegionBound(ref lt) => {\n                 write!(f, \"{}\", *lt)\n             }\n-            clean::TraitBound(ref ty) => {\n-                write!(f, \"{}\", *ty)\n+            clean::TraitBound(ref ty, modifier) => {\n+                let modifier_str = match modifier {\n+                    ast::TraitBoundModifier::None => \"\",\n+                    ast::TraitBoundModifier::Maybe => \"?\",\n+                };\n+                write!(f, \"{}{}\", modifier_str, *ty)\n             }\n         }\n     }\n@@ -458,12 +460,15 @@ impl fmt::Show for clean::Type {\n                            for bound in decl.bounds.iter() {\n                                 match *bound {\n                                     clean::RegionBound(..) => {}\n-                                    clean::TraitBound(ref t) => {\n+                                    clean::TraitBound(ref t, modifier) => {\n                                         if ret.len() == 0 {\n                                             ret.push_str(\": \");\n                                         } else {\n                                             ret.push_str(\" + \");\n                                         }\n+                                        if modifier == ast::TraitBoundModifier::Maybe {\n+                                            ret.push_str(\"?\");\n+                                        }\n                                         ret.push_str(format!(\"{}\",\n                                                              *t).as_slice());\n                                     }"}, {"sha": "bfb03cb2589c2a3366ed6b48d7b3805c50abb5c5", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1679,9 +1679,6 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n-    if let Some(ref ty) = t.default_unbound {\n-        bounds.push_str(format!(\" for {}?\", ty).as_slice());\n-    }\n     if t.bounds.len() > 0 {\n         if bounds.len() > 0 {\n             bounds.push(' ');"}, {"sha": "9d4f341a30e25fa018dacb1e0fe9f508cd3c1e09", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -306,6 +306,11 @@ nav.sub {\n     font-size: 1em;\n     position: relative;\n }\n+/* Shift \"where ...\" part of method definition down a line */\n+.content .method .where { display: block; }\n+/* Bit of whitespace to indent it */\n+.content .method .where::before { content: '      '; }\n+\n .content .methods .docblock { margin-left: 40px; }\n \n .content .impl-items .docblock { margin-left: 40px; }"}, {"sha": "e71711aa8d6e77d80efdb56cf74d6e0aec444f1f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.constants.push(s);\n             },\n-            ast::ItemTrait(unsafety, ref gen, ref def_ub, ref b, ref items) => {\n+            ast::ItemTrait(unsafety, ref gen, ref b, ref items) => {\n                 let t = Trait {\n                     unsafety: unsafety,\n                     name: name,\n@@ -334,7 +334,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n-                    default_unbound: def_ub.clone()\n                 };\n                 om.traits.push(t);\n             },"}, {"sha": "fae73cc834fd243e804df191ed6c07a3d1fdffbe", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -392,10 +392,10 @@ mod tests {\n \n     #[test]\n     fn test_base64_random() {\n-        use std::rand::{task_rng, random, Rng};\n+        use std::rand::{thread_rng, random, Rng};\n \n         for _ in range(0u, 1000) {\n-            let times = task_rng().gen_range(1u, 100);\n+            let times = thread_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD)\n                         .from_base64()"}, {"sha": "3f0d59c319a69e7e44165573b698555b101129d5", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -29,7 +29,7 @@\n //! * `String`: equivalent to rust's `String`\n //! * `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the\n //!   same array\n-//! * `Object`: equivalent to rust's `Treemap<String, json::Json>`\n+//! * `Object`: equivalent to rust's `BTreeMap<String, json::Json>`\n //! * `Null`\n //!\n //! An object is a series of string keys mapping to values, in `\"key\": value` format.\n@@ -2517,7 +2517,7 @@ mod tests {\n     #[test]\n     fn test_from_str_trait() {\n         let s = \"null\";\n-        assert!(::std::str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n+        assert!(s.parse::<Json>().unwrap() == s.parse().unwrap());\n     }\n \n     #[test]\n@@ -3729,8 +3729,8 @@ mod tests {\n         let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = BTreeMap::new();\n-            tree_map.insert(\"a\".into_string(), U64(1));\n-            tree_map.insert(\"b\".into_string(), U64(2));\n+            tree_map.insert(\"a\".to_string(), U64(1));\n+            tree_map.insert(\"b\".to_string(), U64(2));\n             Object(tree_map)\n         };\n \n@@ -3762,8 +3762,8 @@ mod tests {\n         assert_eq!((vec![1u, 2]).to_json(), array2);\n         assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n         let mut tree_map = BTreeMap::new();\n-        tree_map.insert(\"a\".into_string(), 1u);\n-        tree_map.insert(\"b\".into_string(), 2);\n+        tree_map.insert(\"a\".to_string(), 1u);\n+        tree_map.insert(\"b\".to_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n         hash_map.insert(\"a\".to_string(), 1u);"}, {"sha": "a46b8a9ad9024c0922f3796c08d58dc376ccc326", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -104,6 +104,10 @@\n /// - `empty`: an empty set of flags\n /// - `all`: the set of all flags\n /// - `bits`: the raw value of the flags currently stored\n+/// - `from_bits`: convert from underlying bit representation, unless that\n+///                representation contains bits that do not correspond to a flag\n+/// - `from_bits_truncate`: convert from underlying bit representation, dropping\n+///                         any bits that do not correspond to flags\n /// - `is_empty`: `true` if no flags are currently stored\n /// - `is_all`: `true` if all flags are currently set\n /// - `intersects`: `true` if there are flags common to both `self` and `other`"}, {"sha": "f28abcc10cfd8dcf0d651005566e08a61a67834c", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -537,7 +537,8 @@ pub unsafe fn from_c_multistring<F>(buf: *const libc::c_char,\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use prelude::*;\n+    use prelude::{spawn, Some, None, Option, FnOnce, ToString, CloneSliceExt};\n+    use prelude::{Clone, PtrExt, Iterator, SliceExt, StrExt};\n     use ptr;\n     use thread::Thread;\n     use libc;"}, {"sha": "0aa51ee66ed63dc30324fcd75b43ddc5d8b7d13b", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -40,7 +40,7 @@ use mem;\n use ops::{Drop, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::RawPtr;\n+use ptr::PtrExt;\n use ptr;\n use raw;\n use slice::AsSlice;"}, {"sha": "7b7473b2c993c27d3cd13d6e9cd86034f3eed7ab", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -264,27 +264,35 @@ fn test_resize_policy() {\n /// }\n /// ```\n ///\n-/// The easiest way to use `HashMap` with a custom type is to derive `Eq` and `Hash`.\n+/// The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`.\n /// We must also derive `PartialEq`.\n ///\n /// ```\n /// use std::collections::HashMap;\n ///\n /// #[deriving(Hash, Eq, PartialEq, Show)]\n-/// struct Viking<'a> {\n-///     name: &'a str,\n-///     power: uint,\n+/// struct Viking {\n+///     name: String,\n+///     country: String,\n /// }\n ///\n+/// impl Viking {\n+///     /// Create a new Viking.\n+///     fn new(name: &str, country: &str) -> Viking {\n+///         Viking { name: name.to_string(), country: country.to_string() }\n+///     }\n+/// }\n+///\n+/// // Use a HashMap to store the vikings' health points.\n /// let mut vikings = HashMap::new();\n ///\n-/// vikings.insert(\"Norway\", Viking { name: \"Einar\", power: 9u });\n-/// vikings.insert(\"Denmark\", Viking { name: \"Olaf\", power: 4u });\n-/// vikings.insert(\"Iceland\", Viking { name: \"Harald\", power: 8u });\n+/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25u);\n+/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24u);\n+/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12u);\n ///\n-/// // Use derived implementation to print the vikings.\n-/// for (land, viking) in vikings.iter() {\n-///     println!(\"{} at {}\", viking, land);\n+/// // Use derived implementation to print the status of the vikings.\n+/// for (viking, health) in vikings.iter() {\n+///     println!(\"{} has {} hp\", viking, health);\n /// }\n /// ```\n #[deriving(Clone)]\n@@ -888,8 +896,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter(&self) -> Entries<K, V> {\n-        Entries { inner: self.table.iter() }\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter { inner: self.table.iter() }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n@@ -1305,8 +1313,8 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K\n }\n \n /// HashMap iterator\n-pub struct Entries<'a, K: 'a, V: 'a> {\n-    inner: table::Entries<'a, K, V>\n+pub struct Iter<'a, K: 'a, V: 'a> {\n+    inner: table::Iter<'a, K, V>\n }\n \n /// HashMap mutable values iterator\n@@ -1326,12 +1334,12 @@ pub struct IntoIter<K, V> {\n \n /// HashMap keys iterator\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// HashMap values iterator\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n /// HashMap drain iterator\n@@ -1373,7 +1381,7 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }"}, {"sha": "f76b8ac3326f5bec2d5d5ddb743d199bc74a221d", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -23,7 +23,7 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{Unique, RawPtr, copy_nonoverlapping_memory, zero_memory};\n+use ptr::{Unique, PtrExt, copy_nonoverlapping_memory, zero_memory};\n use ptr;\n use rt::heap::{allocate, deallocate};\n \n@@ -657,8 +657,8 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n-    pub fn iter(&self) -> Entries<K, V> {\n-        Entries {\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter {\n             iter: self.raw_buckets(),\n             elems_left: self.size(),\n         }\n@@ -770,7 +770,7 @@ impl<'a, K, V> Iterator<(K, V)> for RevMoveBuckets<'a, K, V> {\n }\n \n /// Iterator over shared references to entries in a table.\n-pub struct Entries<'a, K: 'a, V: 'a> {\n+pub struct Iter<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n     elems_left: uint,\n }\n@@ -793,7 +793,7 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'static, K, V>,\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;"}, {"sha": "a405627aecc45a9be9e9a1ea705bf8c4524c428e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -181,7 +181,7 @@\n // senders. Under the hood, however, there are actually three flavors of\n // channels in play.\n //\n-// * Oneshots - these channels are highly optimized for the one-send use case.\n+// * Flavor::Oneshots - these channels are highly optimized for the one-send use case.\n //              They contain as few atomics as possible and involve one and\n //              exactly one allocation.\n // * Streams - these channels are optimized for the non-shared use case. They\n@@ -316,7 +316,6 @@ use core::prelude::*;\n \n pub use self::TryRecvError::*;\n pub use self::TrySendError::*;\n-use self::Flavor::*;\n \n use alloc::arc::Arc;\n use core::kinds;\n@@ -337,7 +336,8 @@ macro_rules! test {\n             use super::*;\n             use comm::*;\n             use thread::Thread;\n-            use prelude::*;\n+            use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option};\n+            use prelude::{Vec, Buffer, from_str, Clone};\n \n             $(#[$a])* #[test] fn f() { $b }\n         }\n@@ -478,7 +478,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n #[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n-    (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n+    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -518,7 +518,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n               of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n-    (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n+    (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -592,15 +592,15 @@ impl<T: Send> Sender<T> {\n     #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 unsafe {\n                     let p = p.get();\n                     if !(*p).sent() {\n                         return (*p).send(t);\n                     } else {\n                         let a =\n                             Arc::new(RacyCell::new(stream::Packet::new()));\n-                        match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n+                        match (*p).upgrade(Receiver::new(Flavor::Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n                                 (a, ret)\n@@ -618,13 +618,13 @@ impl<T: Send> Sender<T> {\n                     }\n                 }\n             }\n-            Stream(ref p) => return unsafe { (*p.get()).send(t) },\n-            Shared(ref p) => return unsafe { (*p.get()).send(t) },\n-            Sync(..) => unreachable!(),\n+            Flavor::Stream(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Shared(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n-            let tmp = Sender::new(Stream(new_inner));\n+            let tmp = Sender::new(Flavor::Stream(new_inner));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n         return ret;\n@@ -635,53 +635,53 @@ impl<T: Send> Sender<T> {\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n-            Oneshot(ref p) => {\n+            Flavor::Oneshot(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         oneshot::UpSuccess |\n                         oneshot::UpDisconnected => (a, None, guard),\n                         oneshot::UpWoke(task) => (a, Some(task), guard)\n                     }\n                 }\n             }\n-            Stream(ref p) => {\n+            Flavor::Stream(ref p) => {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         stream::UpSuccess |\n                         stream::UpDisconnected => (a, None, guard),\n                         stream::UpWoke(task) => (a, Some(task), guard),\n                     }\n                 }\n             }\n-            Shared(ref p) => {\n+            Flavor::Shared(ref p) => {\n                 unsafe { (*p.get()).clone_chan(); }\n-                return Sender::new(Shared(p.clone()));\n+                return Sender::new(Flavor::Shared(p.clone()));\n             }\n-            Sync(..) => unreachable!(),\n+            Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper, guard);\n \n-            let tmp = Sender::new(Shared(packet.clone()));\n+            let tmp = Sender::new(Flavor::Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        Sender::new(Shared(packet))\n+        Sender::new(Flavor::Shared(packet))\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Sync(..) => unreachable!(),\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+            Flavor::Sync(..) => unreachable!(),\n         }\n     }\n }\n@@ -827,30 +827,30 @@ impl<T: Send> Receiver<T> {\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return Err(Empty),\n                         Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return Err(Empty),\n                         Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return Err(Empty),\n                         Err(shared::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Empty) => return Err(Empty),\n@@ -881,30 +881,30 @@ impl<T: Send> Receiver<T> {\n     pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n                         Err(oneshot::Disconnected) => return Err(()),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n                         Err(stream::Disconnected) => return Err(()),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n                         Err(shared::Disconnected) => return Err(()),\n                     }\n                 }\n-                Sync(ref p) => return unsafe { (*p.get()).recv() }\n+                Flavor::Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -924,22 +924,22 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).can_recv() } {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).can_recv() };\n                 }\n             };\n@@ -953,24 +953,24 @@ impl<T: Send> select::Packet for Receiver<T> {\n     fn start_selection(&self, mut token: SignalToken) -> StartResult {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => {\n+                Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         oneshot::SelSuccess => return Installed,\n                         oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Stream(ref p) => {\n+                Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).start_selection(token) } {\n                         stream::SelSuccess => return Installed,\n                         stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Shared(ref p) => {\n+                Flavor::Shared(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n-                Sync(ref p) => {\n+                Flavor::Sync(ref p) => {\n                     return unsafe { (*p.get()).start_selection(token) };\n                 }\n             };\n@@ -985,14 +985,14 @@ impl<T: Send> select::Packet for Receiver<T> {\n         let mut was_upgrade = false;\n         loop {\n             let result = match *unsafe { self.inner() } {\n-                Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n-                Stream(ref p) => unsafe {\n+                Flavor::Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n+                Flavor::Stream(ref p) => unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Shared(ref p) => return unsafe {\n+                Flavor::Shared(ref p) => return unsafe {\n                     (*p.get()).abort_selection(was_upgrade)\n                 },\n-                Sync(ref p) => return unsafe {\n+                Flavor::Sync(ref p) => return unsafe {\n                     (*p.get()).abort_selection()\n                 },\n             };\n@@ -1015,10 +1015,10 @@ impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n-            Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+            Flavor::Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n         }\n     }\n }\n@@ -1047,7 +1047,7 @@ unsafe impl<T> kinds::Sync for RacyCell<T> { } // Oh dear\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use prelude::*;\n+    use prelude::{spawn, range, Some, None, from_str, Clone, Str};\n     use os;\n \n     pub fn stress_factor() -> uint {"}, {"sha": "3f23ec5dc665966b5aa499a0696e3f3e5d7f9e34", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -86,7 +86,7 @@ impl<T: Send> Packet<T> {\n     // and that could cause problems on platforms where it is\n     // represented by opaque data structure\n     pub fn postinit_lock(&self) -> MutexGuard<()> {\n-        self.select_lock.lock()\n+        self.select_lock.lock().unwrap()\n     }\n \n     // This function is used at the creation of a shared packet to inherit a\n@@ -435,7 +435,7 @@ impl<T: Send> Packet<T> {\n         // about looking at and dealing with to_wake. Once we have acquired the\n         // lock, we are guaranteed that inherit_blocker is done.\n         {\n-            let _guard = self.select_lock.lock();\n+            let _guard = self.select_lock.lock().unwrap();\n         }\n \n         // Like the stream implementation, we want to make sure that the count"}, {"sha": "82ec1814ebde70e05ac4f957d702d55e6b91c7b8", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -121,9 +121,9 @@ fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n         NoneBlocked => {}\n         _ => unreachable!(),\n     }\n-    drop(guard);        // unlock\n-    wait_token.wait();  // block\n-    lock.lock()         // relock\n+    drop(guard);         // unlock\n+    wait_token.wait();   // block\n+    lock.lock().unwrap() // relock\n }\n \n /// Wakes up a thread, dropping the lock at the correct time\n@@ -161,7 +161,7 @@ impl<T: Send> Packet<T> {\n     fn acquire_send_slot(&self) -> MutexGuard<State<T>> {\n         let mut node = Node { token: None, next: 0 as *mut Node };\n         loop {\n-            let mut guard = self.lock.lock();\n+            let mut guard = self.lock.lock().unwrap();\n             // are we ready to go?\n             if guard.disconnected || guard.buf.size() < guard.buf.cap() {\n                 return guard;\n@@ -202,7 +202,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected {\n             Err(super::RecvDisconnected(t))\n         } else if guard.buf.size() == guard.buf.cap() {\n@@ -239,7 +239,7 @@ impl<T: Send> Packet<T> {\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n     pub fn recv(&self) -> Result<T, ()> {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n \n         // Wait for the buffer to have something in it. No need for a while loop\n         // because we're the only receiver.\n@@ -258,7 +258,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n \n         // Easy cases first\n         if guard.disconnected { return Err(Disconnected) }\n@@ -315,7 +315,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected { return }\n         guard.disconnected = true;\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n@@ -326,7 +326,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn drop_port(&self) {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n \n         if guard.disconnected { return }\n         guard.disconnected = true;\n@@ -372,14 +372,14 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&self) -> bool {\n-        let guard = self.lock.lock();\n+        let guard = self.lock.lock().unwrap();\n         guard.disconnected || guard.buf.size() > 0\n     }\n \n     // Attempts to start selection on this port. This can either succeed or fail\n     // because there is data waiting.\n     pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected || guard.buf.size() > 0 {\n             Abort\n         } else {\n@@ -397,7 +397,7 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => true,\n             BlockedSender(token) => {\n@@ -413,7 +413,7 @@ impl<T: Send> Packet<T> {\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(atomic::SeqCst), 0);\n-        let mut guard = self.lock.lock();\n+        let mut guard = self.lock.lock().unwrap();\n         assert!(guard.queue.dequeue().is_none());\n         assert!(guard.canceled.is_none());\n     }"}, {"sha": "9a46a500a4b4799199ccc73edbdaf75106aef405", "filename": "src/libstd/error.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -81,6 +81,7 @@\n use prelude::*;\n \n use str::Utf8Error;\n+use string::{FromUtf8Error, FromUtf16Error};\n \n /// Base functionality for all errors in Rust.\n pub trait Error: Send {\n@@ -117,3 +118,12 @@ impl Error for Utf8Error {\n \n     fn detail(&self) -> Option<String> { Some(self.to_string()) }\n }\n+\n+impl Error for FromUtf8Error {\n+    fn description(&self) -> &str { \"invalid utf-8\" }\n+    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n+}\n+\n+impl Error for FromUtf16Error {\n+    fn description(&self) -> &str { \"invalid utf-16\" }\n+}"}, {"sha": "737fef23c74668764b564c5e10add1858f912b43", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -79,7 +79,7 @@ impl RandomSipHasher {\n     /// Construct a new `RandomSipHasher` that is initialized with random keys.\n     #[inline]\n     pub fn new() -> RandomSipHasher {\n-        let mut r = rand::task_rng();\n+        let mut r = rand::thread_rng();\n         let r0 = r.gen();\n         let r1 = r.gen();\n         RandomSipHasher {"}, {"sha": "e8765e3c2317e5d87d1fa8a04fa3bf0572dcd840", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -22,7 +22,7 @@ use num::Int;\n use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::RawPtr;\n+use ptr::PtrExt;\n use result::Result::{Ok, Err};\n use slice::{SliceExt, AsSlice};\n "}, {"sha": "caa6590bb28212bd7cb8dc192d1c4bed0bbc0c56", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1148,6 +1148,19 @@ mod test {\n         check!(rmdir_recursive(dir));\n     }\n \n+    #[test]\n+    fn mkdir_path_already_exists_error() {\n+        use io::{IoError, PathAlreadyExists};\n+\n+        let tmpdir = tmpdir();\n+        let dir = &tmpdir.join(\"mkdir_error_twice\");\n+        check!(mkdir(dir, io::USER_RWX));\n+        match mkdir(dir, io::USER_RWX) {\n+            Err(IoError{kind:PathAlreadyExists,..}) => (),\n+            _ => assert!(false)\n+        };\n+    }\n+\n     #[test]\n     fn recursive_mkdir() {\n         let tmpdir = tmpdir();"}, {"sha": "79327a29615ae52e47fc09603b6e1926a1bfd5d0", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -400,8 +400,8 @@ impl<'a> Buffer for BufReader<'a> {\n mod test {\n     extern crate \"test\" as test_crate;\n     use super::*;\n-    use io::*;\n-    use prelude::*;\n+    use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n+    use prelude::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt, IteratorExt, CloneSliceExt};\n     use io;\n     use self::test_crate::Bencher;\n "}, {"sha": "7a25360e695e40575aa4ed1014a0ce031eb454b8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -935,7 +935,7 @@ impl<'a> Reader for &'a mut (Reader+'a) {\n // API yet. If so, it should be a method on Vec.\n unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] {\n     use raw::Slice;\n-    use ptr::RawPtr;\n+    use ptr::PtrExt;\n \n     assert!(start <= end);\n     assert!(end <= v.capacity());\n@@ -1724,7 +1724,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n /// A mode specifies how a file should be opened or created. These modes are\n /// passed to `File::open_mode` and are used to control where the file is\n /// positioned when it is initially opened.\n-#[deriving(Copy)]\n+#[deriving(Copy, Clone, PartialEq, Eq)]\n pub enum FileMode {\n     /// Opens a file positioned at the beginning.\n     Open,\n@@ -1736,7 +1736,7 @@ pub enum FileMode {\n \n /// Access permissions with which the file should be opened. `File`s\n /// opened with `Read` will return an error if written to.\n-#[deriving(Copy)]\n+#[deriving(Copy, Clone, PartialEq, Eq)]\n pub enum FileAccess {\n     /// Read-only access, requests to write will result in an error\n     Read,\n@@ -1959,8 +1959,8 @@ impl fmt::Show for FilePermission {\n #[cfg(test)]\n mod tests {\n     use self::BadReaderBehavior::*;\n-    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput};\n-    use prelude::*;\n+    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n+    use prelude::{Ok, Vec, Buffer, CloneSliceExt};\n     use uint;\n \n     #[deriving(Clone, PartialEq, Show)]"}, {"sha": "93f37a8c98ff86a6401b47eb8b21a2e88e7550aa", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -269,7 +269,7 @@ mod tests {\n     use super::*;\n     use io::*;\n     use io::test::*;\n-    use prelude::*;\n+    use prelude::{Ok, Err, spawn, range, drop,  Some, None, channel, Send, FnOnce, Clone};\n     use io::fs::PathExtensions;\n     use time::Duration;\n "}, {"sha": "24cf06973cc6939f982f6ce6725d42003dfe6557", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -484,9 +484,12 @@ impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n mod test {\n     use io::net::tcp::*;\n     use io::net::ip::*;\n-    use io::*;\n+    use io::{EndOfFile, TimedOut, IoError, ShortWrite, OtherIoError, ConnectionAborted};\n+    use io::{ConnectionRefused, ConnectionReset, BrokenPipe, NotConnected};\n+    use io::{PermissionDenied, Listener, Acceptor};\n     use io::test::*;\n-    use prelude::*;\n+    use prelude::{Ok, Err, spawn, range, drop, Some, None, channel, Clone};\n+    use prelude::{Reader, Writer, IteratorExt};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]"}, {"sha": "1431067d4c6a3879eb19997f735cb0b645287817", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -250,9 +250,9 @@ impl Writer for UdpStream {\n mod test {\n     use super::*;\n     use io::net::ip::*;\n-    use io::*;\n+    use io::{ShortWrite, IoError, TimedOut, PermissionDenied};\n     use io::test::*;\n-    use prelude::*;\n+    use prelude::{Ok, Err, spawn, range, drop, Some, None, channel, Clone, Reader, Writer};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]"}, {"sha": "b127507f048d22ff0d7751feb212277d075979f4", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -745,8 +745,10 @@ mod tests {\n \n     use super::*;\n     use io::timer::*;\n-    use io::*;\n-    use prelude::*;\n+    use io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n+    use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option, Vec, Buffer};\n+    use prelude::{from_str, Path, String, channel, Reader, Writer, Clone, Slice};\n+    use prelude::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n     use io::fs::PathExtensions;\n     use time::Duration;\n     use str;\n@@ -1205,6 +1207,7 @@ mod tests {\n     #[test]\n     #[cfg(windows)]\n     fn env_map_keys_ci() {\n+        use c_str::ToCStr;\n         use super::EnvKey;\n         let mut cmd = Command::new(\"\");\n         cmd.env(\"path\", \"foo\");"}, {"sha": "6c8e4eea40fdc442b5f799b2ceb140e83eedd500", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -146,7 +146,7 @@ impl StdinReader {\n     /// ```\n     pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> {\n         StdinReaderGuard {\n-            inner: self.inner.lock()\n+            inner: self.inner.lock().unwrap()\n         }\n     }\n \n@@ -155,53 +155,53 @@ impl StdinReader {\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_line(&mut self) -> IoResult<String> {\n-        self.inner.lock().0.read_line()\n+        self.inner.lock().unwrap().0.read_line()\n     }\n \n     /// Like `Buffer::read_until`.\n     ///\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        self.inner.lock().0.read_until(byte)\n+        self.inner.lock().unwrap().0.read_until(byte)\n     }\n \n     /// Like `Buffer::read_char`.\n     ///\n     /// The read is performed atomically - concurrent read calls in other\n     /// threads will not interleave with this one.\n     pub fn read_char(&mut self) -> IoResult<char> {\n-        self.inner.lock().0.read_char()\n+        self.inner.lock().unwrap().0.read_char()\n     }\n }\n \n impl Reader for StdinReader {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner.lock().0.read(buf)\n+        self.inner.lock().unwrap().0.read(buf)\n     }\n \n     // We have to manually delegate all of these because the default impls call\n     // read more than once and we don't want those calls to interleave (or\n     // incur the costs of repeated locking).\n \n     fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner.lock().0.read_at_least(min, buf)\n+        self.inner.lock().unwrap().0.read_at_least(min, buf)\n     }\n \n     fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n-        self.inner.lock().0.push_at_least(min, len, buf)\n+        self.inner.lock().unwrap().0.push_at_least(min, len, buf)\n     }\n \n     fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        self.inner.lock().0.read_to_end()\n+        self.inner.lock().unwrap().0.read_to_end()\n     }\n \n     fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n-        self.inner.lock().0.read_le_uint_n(nbytes)\n+        self.inner.lock().unwrap().0.read_le_uint_n(nbytes)\n     }\n \n     fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n-        self.inner.lock().0.read_be_uint_n(nbytes)\n+        self.inner.lock().unwrap().0.read_be_uint_n(nbytes)\n     }\n }\n "}, {"sha": "90d7c1388a196e56800786c23fa3d20627b8dede", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -280,7 +280,7 @@ mod test {\n     use io;\n     use boxed::Box;\n     use super::*;\n-    use prelude::*;\n+    use prelude::{Ok, range, Vec, Buffer, Writer, Reader, ToString, AsSlice};\n \n     #[test]\n     fn test_limit_reader_unlimited() {"}, {"sha": "48ff1a364e93c7d73f750df61d6597ca3a5bf27e", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -147,8 +147,10 @@ pub fn test_num<T>(ten: T, two: T) where\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n-    use super::*;\n+    use prelude::{range, Some, None, Option, IteratorExt};\n+    use super::{from_int, from_uint, from_i32, from_i64, from_u64, from_u32};\n+    use super::{from_f64, from_f32, from_u16, from_i16, from_u8, from_i8, Int};\n+    use super::{cast, NumCast, ToPrimitive, FromPrimitive, UnsignedInt};\n     use i8;\n     use i16;\n     use i32;"}, {"sha": "989f44f7b8e4239326adf25ac0ec1be2cf154474", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -46,7 +46,8 @@ use option::Option;\n use option::Option::{Some, None};\n use path::{Path, GenericPath, BytesContainer};\n use sys;\n-use ptr::RawPtr;\n+use sys::os as os_imp;\n+use ptr::PtrExt;\n use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n@@ -730,7 +731,7 @@ fn real_args() -> Vec<String> {\n         let ptr = ptr as *const u16;\n         let buf = slice::from_raw_buf(&ptr, len);\n         let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n-        opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n+        opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });\n \n     unsafe {\n@@ -1438,7 +1439,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> String {\n-        let mut rng = rand::task_rng();\n+        let mut rng = rand::thread_rng();\n         let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10u)\n                                      .collect::<String>());\n         assert!(getenv(n.as_slice()).is_none());"}, {"sha": "60f147eac9b2b490be0e4dc9086838f9065a8c65", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1239,7 +1239,7 @@ mod bench {\n     extern crate test;\n     use self::test::Bencher;\n     use super::*;\n-    use prelude::*;\n+    use prelude::{Clone, GenericPath};\n \n     #[bench]\n     fn join_home_dir(b: &mut Bencher) {"}, {"sha": "879a96e802643429170357e93a876ab822d54dc1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -21,7 +21,7 @@ use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIteratorExt, Extend};\n-use iter::{Iterator, IteratorExt, Map};\n+use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n@@ -777,7 +777,7 @@ impl Path {\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n-                        Some(String::from_char(1, SEP))\n+                        Some(repeat(SEP).take(1).collect())\n                     } else {\n                         let prefix_ = s[0..prefix_len(prefix)];\n                         let n = prefix_.len() +"}, {"sha": "fc59f06ae6cf3ef5d3b143d380c606fd148930a1", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -73,7 +73,7 @@\n #[doc(no_inline)] pub use option::Option;\n #[doc(no_inline)] pub use option::Option::{Some, None};\n #[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n-#[doc(no_inline)] pub use ptr::{RawPtr, RawMutPtr};\n+#[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[doc(no_inline)] pub use result::Result;\n #[doc(no_inline)] pub use result::Result::{Ok, Err};\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};"}, {"sha": "d4f72a53aec1b7651928ec72a4f26add13014bee", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -18,10 +18,10 @@\n //! See the `distributions` submodule for sampling random numbers from\n //! distributions like normal and exponential.\n //!\n-//! # Task-local RNG\n+//! # Thread-local RNG\n //!\n-//! There is built-in support for a RNG associated with each task stored\n-//! in task-local storage. This RNG can be accessed via `task_rng`, or\n+//! There is built-in support for a RNG associated with each thread stored\n+//! in thread-local storage. This RNG can be accessed via `thread_rng`, or\n //! used implicitly via `random`. This RNG is normally randomly seeded\n //! from an operating-system source of randomness, e.g. `/dev/urandom` on\n //! Unix systems, and will automatically reseed itself from this source\n@@ -61,7 +61,7 @@\n //! use std::rand;\n //! use std::rand::Rng;\n //!\n-//! let mut rng = rand::task_rng();\n+//! let mut rng = rand::thread_rng();\n //! if rng.gen() { // random bool\n //!     println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n //! }\n@@ -97,7 +97,7 @@\n //!\n //! fn main() {\n //!    let between = Range::new(-1f64, 1.);\n-//!    let mut rng = rand::task_rng();\n+//!    let mut rng = rand::thread_rng();\n //!\n //!    let total = 1_000_000u;\n //!    let mut in_circle = 0u;\n@@ -183,7 +183,7 @@\n //!     // The estimation will be more accurate with more simulations\n //!     let num_simulations = 10000u;\n //!\n-//!     let mut rng = rand::task_rng();\n+//!     let mut rng = rand::thread_rng();\n //!     let random_door = Range::new(0u, 3);\n //!\n //!     let (mut switch_wins, mut switch_losses) = (0u, 0u);\n@@ -257,7 +257,7 @@ impl StdRng {\n     /// randomness from the operating system and use this in an\n     /// expensive seeding operation. If one is only generating a small\n     /// number of random numbers, or doesn't need the utmost speed for\n-    /// generating each number, `task_rng` and/or `random` may be more\n+    /// generating each number, `thread_rng` and/or `random` may be more\n     /// appropriate.\n     ///\n     /// Reading the randomness from the OS may fail, and any error is\n@@ -307,28 +307,28 @@ pub fn weak_rng() -> XorShiftRng {\n     }\n }\n \n-/// Controls how the task-local RNG is reseeded.\n-struct TaskRngReseeder;\n+/// Controls how the thread-local RNG is reseeded.\n+struct ThreadRngReseeder;\n \n-impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n+impl reseeding::Reseeder<StdRng> for ThreadRngReseeder {\n     fn reseed(&mut self, rng: &mut StdRng) {\n         *rng = match StdRng::new() {\n             Ok(r) => r,\n-            Err(e) => panic!(\"could not reseed task_rng: {}\", e)\n+            Err(e) => panic!(\"could not reseed thread_rng: {}\", e)\n         }\n     }\n }\n-static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n-type TaskRngInner = reseeding::ReseedingRng<StdRng, TaskRngReseeder>;\n+static THREAD_RNG_RESEED_THRESHOLD: uint = 32_768;\n+type ThreadRngInner = reseeding::ReseedingRng<StdRng, ThreadRngReseeder>;\n \n-/// The task-local RNG.\n-pub struct TaskRng {\n-    rng: Rc<RefCell<TaskRngInner>>,\n+/// The thread-local RNG.\n+pub struct ThreadRng {\n+    rng: Rc<RefCell<ThreadRngInner>>,\n }\n \n-/// Retrieve the lazily-initialized task-local random number\n+/// Retrieve the lazily-initialized thread-local random number\n /// generator, seeded by the system. Intended to be used in method\n-/// chaining style, e.g. `task_rng().gen::<int>()`.\n+/// chaining style, e.g. `thread_rng().gen::<int>()`.\n ///\n /// The RNG provided will reseed itself from the operating system\n /// after generating a certain amount of randomness.\n@@ -337,23 +337,23 @@ pub struct TaskRng {\n /// if the operating system random number generator is rigged to give\n /// the same sequence always. If absolute consistency is required,\n /// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n-pub fn task_rng() -> TaskRng {\n+pub fn thread_rng() -> ThreadRng {\n     // used to make space in TLS for a random number generator\n-    thread_local!(static TASK_RNG_KEY: Rc<RefCell<TaskRngInner>> = {\n+    thread_local!(static THREAD_RNG_KEY: Rc<RefCell<ThreadRngInner>> = {\n         let r = match StdRng::new() {\n             Ok(r) => r,\n-            Err(e) => panic!(\"could not initialize task_rng: {}\", e)\n+            Err(e) => panic!(\"could not initialize thread_rng: {}\", e)\n         };\n         let rng = reseeding::ReseedingRng::new(r,\n-                                               TASK_RNG_RESEED_THRESHOLD,\n-                                               TaskRngReseeder);\n+                                               THREAD_RNG_RESEED_THRESHOLD,\n+                                               ThreadRngReseeder);\n         Rc::new(RefCell::new(rng))\n     });\n \n-    TaskRng { rng: TASK_RNG_KEY.with(|t| t.clone()) }\n+    ThreadRng { rng: THREAD_RNG_KEY.with(|t| t.clone()) }\n }\n \n-impl Rng for TaskRng {\n+impl Rng for ThreadRng {\n     fn next_u32(&mut self) -> u32 {\n         self.rng.borrow_mut().next_u32()\n     }\n@@ -368,7 +368,7 @@ impl Rng for TaskRng {\n     }\n }\n \n-/// Generates a random value using the task-local random number generator.\n+/// Generates a random value using the thread-local random number generator.\n ///\n /// `random()` can generate various types of random things, and so may require\n /// type hinting to generate the specific type you want.\n@@ -390,17 +390,17 @@ impl Rng for TaskRng {\n /// ```\n #[inline]\n pub fn random<T: Rand>() -> T {\n-    task_rng().gen()\n+    thread_rng().gen()\n }\n \n /// Randomly sample up to `amount` elements from an iterator.\n ///\n /// # Example\n ///\n /// ```rust\n-/// use std::rand::{task_rng, sample};\n+/// use std::rand::{thread_rng, sample};\n ///\n-/// let mut rng = task_rng();\n+/// let mut rng = thread_rng();\n /// let sample = sample(&mut rng, range(1i, 100), 5);\n /// println!(\"{}\", sample);\n /// ```\n@@ -420,7 +420,7 @@ pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use super::{Rng, task_rng, random, SeedableRng, StdRng, sample};\n+    use super::{Rng, thread_rng, random, SeedableRng, StdRng, sample};\n     use iter::order;\n \n     struct ConstRng { i: u64 }\n@@ -453,7 +453,7 @@ mod test {\n \n     #[test]\n     fn test_gen_range() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         for _ in range(0u, 1000) {\n             let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n@@ -473,51 +473,51 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_gen_range_panic_int() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         r.gen_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_gen_range_panic_uint() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         r.gen_range(5u, 2u);\n     }\n \n     #[test]\n     fn test_gen_f64() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         let a = r.gen::<f64>();\n         let b = r.gen::<f64>();\n         debug!(\"{}\", (a, b));\n     }\n \n     #[test]\n     fn test_gen_weighted_bool() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.gen_weighted_bool(0u), true);\n         assert_eq!(r.gen_weighted_bool(1u), true);\n     }\n \n     #[test]\n     fn test_gen_ascii_str() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.gen_ascii_chars().take(0).count(), 0u);\n         assert_eq!(r.gen_ascii_chars().take(10).count(), 10u);\n         assert_eq!(r.gen_ascii_chars().take(16).count(), 16u);\n     }\n \n     #[test]\n     fn test_gen_vec() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.gen_iter::<u8>().take(0).count(), 0u);\n         assert_eq!(r.gen_iter::<u8>().take(10).count(), 10u);\n         assert_eq!(r.gen_iter::<f64>().take(16).count(), 16u);\n     }\n \n     #[test]\n     fn test_choose() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         assert_eq!(r.choose(&[1i, 1, 1]).map(|&x|x), Some(1));\n \n         let v: &[int] = &[];\n@@ -526,7 +526,7 @@ mod test {\n \n     #[test]\n     fn test_shuffle() {\n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         let empty: &mut [int] = &mut [];\n         r.shuffle(empty);\n         let mut one = [1i];\n@@ -545,8 +545,8 @@ mod test {\n     }\n \n     #[test]\n-    fn test_task_rng() {\n-        let mut r = task_rng();\n+    fn test_thread_rng() {\n+        let mut r = thread_rng();\n         r.gen::<int>();\n         let mut v = [1i, 1, 1];\n         r.shuffle(&mut v);\n@@ -574,7 +574,7 @@ mod test {\n         let min_val = 1i;\n         let max_val = 100i;\n \n-        let mut r = task_rng();\n+        let mut r = thread_rng();\n         let vals = range(min_val, max_val).collect::<Vec<int>>();\n         let small_sample = sample(&mut r, vals.iter(), 5);\n         let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n@@ -589,7 +589,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_seeded() {\n-        let s = task_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n         let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -598,7 +598,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_reseed() {\n-        let s = task_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n         let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n "}, {"sha": "3eeb0ad3968fe9b091e77cc9f4154d5466a98c4a", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -60,19 +60,19 @@ mod test {\n         t!(\"_ZN4$UP$E\", \"Box\");\n         t!(\"_ZN8$UP$testE\", \"Boxtest\");\n         t!(\"_ZN8$UP$test4foobE\", \"Boxtest::foob\");\n-        t!(\"_ZN8$x20test4foobE\", \" test::foob\");\n+        t!(\"_ZN10$u{20}test4foobE\", \" test::foob\");\n     }\n \n     #[test]\n     fn demangle_many_dollars() {\n-        t!(\"_ZN12test$x20test4foobE\", \"test test::foob\");\n+        t!(\"_ZN14test$u{20}test4foobE\", \"test test::foob\");\n         t!(\"_ZN12test$UP$test4foobE\", \"testBoxtest::foob\");\n     }\n \n     #[test]\n     fn demangle_windows() {\n         t!(\"ZN4testE\", \"test\");\n-        t!(\"ZN12test$x20test4foobE\", \"test test::foob\");\n+        t!(\"ZN14test$u{20}test4foobE\", \"test test::foob\");\n         t!(\"ZN12test$UP$test4foobE\", \"testBoxtest::foob\");\n     }\n }"}, {"sha": "e877dd5c6aab813ba5689070940299b667d5df1a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -53,7 +53,7 @@ pub mod args;\n mod at_exit_imp;\n mod libunwind;\n \n-/// The default error code of the rust runtime if the main task panics instead\n+/// The default error code of the rust runtime if the main thread panics instead\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: int = 101;\n \n@@ -137,9 +137,9 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n ///\n /// The procedure passed to this function will be executed as part of the\n /// runtime cleanup phase. For normal rust programs, this means that it will run\n-/// after all other tasks have exited.\n+/// after all other threads have exited.\n ///\n-/// The procedure is *not* executed with a local `Task` available to it, so\n+/// The procedure is *not* executed with a local `Thread` available to it, so\n /// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n /// This is meant for \"bare bones\" usage to clean up runtime details, this is\n /// not meant as a general-purpose \"let's clean everything up\" function."}, {"sha": "773322e4f57f18d5850f3cede5896a037bb5d85b", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -36,7 +36,7 @@ use sys_common::stack;\n use rt::unwind;\n use rt::unwind::Unwinder;\n \n-/// State associated with Rust tasks.\n+/// State associated with Rust threads\n ///\n /// This structure is currently undergoing major changes, and is\n /// likely to be move/be merged with a `Thread` structure.\n@@ -50,14 +50,14 @@ pub struct Task {\n     awoken: bool,            // used to prevent spurious wakeups\n \n     // This field holds the known bounds of the stack in (lo, hi) form. Not all\n-    // native tasks necessarily know their precise bounds, hence this is\n+    // native threads necessarily know their precise bounds, hence this is\n     // optional.\n     stack_bounds: (uint, uint),\n \n     stack_guard: uint\n }\n \n-// Once a task has entered the `Armed` state it must be destroyed via `drop`,\n+// Once a thread has entered the `Armed` state it must be destroyed via `drop`,\n // and no other method. This state is used to track this transition.\n #[deriving(PartialEq)]\n enum TaskState {\n@@ -67,31 +67,31 @@ enum TaskState {\n }\n \n pub struct TaskOpts {\n-    /// Invoke this procedure with the result of the task when it finishes.\n+    /// Invoke this procedure with the result of the thread when it finishes.\n     pub on_exit: Option<Thunk<Result>>,\n-    /// A name for the task-to-be, for identification in panic messages\n+    /// A name for the thread-to-be, for identification in panic messages\n     pub name: Option<SendStr>,\n-    /// The size of the stack for the spawned task\n+    /// The size of the stack for the spawned thread\n     pub stack_size: Option<uint>,\n }\n \n-/// Indicates the manner in which a task exited.\n+/// Indicates the manner in which a thread exited.\n ///\n-/// A task that completes without panicking is considered to exit successfully.\n+/// A thread that completes without panicking is considered to exit successfully.\n ///\n /// If you wish for this result's delivery to block until all\n-/// children tasks complete, recommend using a result future.\n+/// children threads complete, recommend using a result future.\n pub type Result = ::core::result::Result<(), Box<Any + Send>>;\n \n-/// A handle to a blocked task. Usually this means having the Box<Task>\n-/// pointer by ownership, but if the task is killable, a killer can steal it\n+/// A handle to a blocked thread. Usually this means having the Box<Task>\n+/// pointer by ownership, but if the thread is killable, a killer can steal it\n /// at any time.\n pub enum BlockedTask {\n     Owned(Box<Task>),\n     Shared(Arc<AtomicUint>),\n }\n \n-/// Per-task state related to task death, killing, panic, etc.\n+/// Per-thread state related to thread death, killing, panic, etc.\n pub struct Death {\n     pub on_exit: Option<Thunk<Result>>,\n }\n@@ -101,7 +101,7 @@ pub struct BlockedTasks {\n }\n \n impl Task {\n-    /// Creates a new uninitialized task.\n+    /// Creates a new uninitialized thread.\n     pub fn new(stack_bounds: Option<(uint, uint)>, stack_guard: Option<uint>) -> Task {\n         Task {\n             unwinder: Unwinder::new(),\n@@ -153,17 +153,17 @@ impl Task {\n         })\n     }\n \n-    /// Consumes ownership of a task, runs some code, and returns the task back.\n+    /// Consumes ownership of a thread, runs some code, and returns the thread back.\n     ///\n     /// This function can be used as an emulated \"try/catch\" to interoperate\n     /// with the rust runtime at the outermost boundary. It is not possible to\n     /// use this function in a nested fashion (a try/catch inside of another\n     /// try/catch). Invoking this function is quite cheap.\n     ///\n-    /// If the closure `f` succeeds, then the returned task can be used again\n+    /// If the closure `f` succeeds, then the returned thread can be used again\n     /// for another invocation of `run`. If the closure `f` panics then `self`\n     /// will be internally destroyed along with all of the other associated\n-    /// resources of this task. The `on_exit` callback is invoked with the\n+    /// resources of this thread. The `on_exit` callback is invoked with the\n     /// cause of panic (not returned here). This can be discovered by querying\n     /// `is_destroyed()`.\n     ///\n@@ -172,44 +172,44 @@ impl Task {\n     /// guaranteed to return if it panicks. Care should be taken to ensure that\n     /// stack references made by `f` are handled appropriately.\n     ///\n-    /// It is invalid to call this function with a task that has been previously\n+    /// It is invalid to call this function with a thread that has been previously\n     /// destroyed via a failed call to `run`.\n     pub fn run(mut self: Box<Task>, f: ||) -> Box<Task> {\n-        assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n+        assert!(!self.is_destroyed(), \"cannot re-use a destroyed thread\");\n \n         // First, make sure that no one else is in TLS. This does not allow\n         // recursive invocations of run(). If there's no one else, then\n         // relinquish ownership of ourselves back into TLS.\n         if Local::exists(None::<Task>) {\n-            panic!(\"cannot run a task recursively inside another\");\n+            panic!(\"cannot run a thread recursively inside another\");\n         }\n         self.state = Armed;\n         Local::put(self);\n \n         // There are two primary reasons that general try/catch is unsafe. The\n         // first is that we do not support nested try/catch. The above check for\n-        // an existing task in TLS is sufficient for this invariant to be\n+        // an existing thread in TLS is sufficient for this invariant to be\n         // upheld. The second is that unwinding while unwinding is not defined.\n-        // We take care of that by having an 'unwinding' flag in the task\n+        // We take care of that by having an 'unwinding' flag in the thread\n         // itself. For these reasons, this unsafety should be ok.\n         let result = unsafe { unwind::try(f) };\n \n-        // After running the closure given return the task back out if it ran\n-        // successfully, or clean up the task if it panicked.\n+        // After running the closure given return the thread back out if it ran\n+        // successfully, or clean up the thread if it panicked.\n         let task: Box<Task> = Local::take();\n         match result {\n             Ok(()) => task,\n             Err(cause) => { task.cleanup(Err(cause)) }\n         }\n     }\n \n-    /// Destroy all associated resources of this task.\n+    /// Destroy all associated resources of this thread.\n     ///\n-    /// This function will perform any necessary clean up to prepare the task\n+    /// This function will perform any necessary clean up to prepare the thread\n     /// for destruction. It is required that this is called before a `Task`\n     /// falls out of scope.\n     ///\n-    /// The returned task cannot be used for running any more code, but it may\n+    /// The returned thread cannot be used for running any more code, but it may\n     /// be used to extract the runtime as necessary.\n     pub fn destroy(self: Box<Task>) -> Box<Task> {\n         if self.is_destroyed() {\n@@ -219,14 +219,14 @@ impl Task {\n         }\n     }\n \n-    /// Cleans up a task, processing the result of the task as appropriate.\n+    /// Cleans up a thread, processing the result of the thread as appropriate.\n     ///\n-    /// This function consumes ownership of the task, deallocating it once it's\n+    /// This function consumes ownership of the thread, deallocating it once it's\n     /// done being processed. It is assumed that TLD and the local heap have\n     /// already been destroyed and/or annihilated.\n     fn cleanup(mut self: Box<Task>, result: Result) -> Box<Task> {\n         // After taking care of the data above, we need to transmit the result\n-        // of this task.\n+        // of this thread.\n         let what_to_do = self.death.on_exit.take();\n         Local::put(self);\n \n@@ -235,15 +235,15 @@ impl Task {\n         //        if this panics, this will also likely abort the runtime.\n         //\n         //        This closure is currently limited to a channel send via the\n-        //        standard library's task interface, but this needs\n+        //        standard library's thread interface, but this needs\n         //        reconsideration to whether it's a reasonable thing to let a\n-        //        task to do or not.\n+        //        thread to do or not.\n         match what_to_do {\n             Some(f) => { f.invoke(result) }\n             None => { drop(result) }\n         }\n \n-        // Now that we're done, we remove the task from TLS and flag it for\n+        // Now that we're done, we remove the thread from TLS and flag it for\n         // destruction.\n         let mut task: Box<Task> = Local::take();\n         task.state = Destroyed;\n@@ -253,7 +253,7 @@ impl Task {\n     /// Queries whether this can be destroyed or not.\n     pub fn is_destroyed(&self) -> bool { self.state == Destroyed }\n \n-    /// Deschedules the current task, invoking `f` `amt` times. It is not\n+    /// Deschedules the current thread, invoking `f` `amt` times. It is not\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n     //\n@@ -262,31 +262,31 @@ impl Task {\n     // shared state. Additionally, all of the violations are protected with a\n     // mutex, so in theory there are no races.\n     //\n-    // The first thing we need to do is to get a pointer to the task's internal\n-    // mutex. This address will not be changing (because the task is allocated\n-    // on the heap). We must have this handle separately because the task will\n+    // The first thing we need to do is to get a pointer to the thread's internal\n+    // mutex. This address will not be changing (because the thread is allocated\n+    // on the heap). We must have this handle separately because the thread will\n     // have its ownership transferred to the given closure. We're guaranteed,\n     // however, that this memory will remain valid because *this* is the current\n-    // task's execution thread.\n+    // thread's execution thread.\n     //\n-    // The next weird part is where ownership of the task actually goes. We\n+    // The next weird part is where ownership of the thread actually goes. We\n     // relinquish it to the `f` blocking function, but upon returning this\n-    // function needs to replace the task back in TLS. There is no communication\n-    // from the wakeup thread back to this thread about the task pointer, and\n-    // there's really no need to. In order to get around this, we cast the task\n+    // function needs to replace the thread back in TLS. There is no communication\n+    // from the wakeup thread back to this thread about the thread pointer, and\n+    // there's really no need to. In order to get around this, we cast the thread\n     // to a `uint` which is then used at the end of this function to cast back\n     // to a `Box<Task>` object. Naturally, this looks like it violates\n     // ownership semantics in that there may be two `Box<Task>` objects.\n     //\n     // The fun part is that the wakeup half of this implementation knows to\n-    // \"forget\" the task on the other end. This means that the awakening half of\n+    // \"forget\" the thread on the other end. This means that the awakening half of\n     // things silently relinquishes ownership back to this thread, but not in a\n-    // way that the compiler can understand. The task's memory is always valid\n-    // for both tasks because these operations are all done inside of a mutex.\n+    // way that the compiler can understand. The thread's memory is always valid\n+    // for both threads because these operations are all done inside of a mutex.\n     //\n     // You'll also find that if blocking fails (the `f` function hands the\n     // BlockedTask back to us), we will `mem::forget` the handles. The\n-    // reasoning for this is the same logic as above in that the task silently\n+    // reasoning for this is the same logic as above in that the thread silently\n     // transfers ownership via the `uint`, not through normal compiler\n     // semantics.\n     //\n@@ -319,11 +319,11 @@ impl Task {\n                 let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n \n-                // Apply the given closure to all of the \"selectable tasks\",\n+                // Apply the given closure to all of the \"selectable threads\",\n                 // bailing on the first one that produces an error. Note that\n                 // care must be taken such that when an error is occurred, we\n-                // may not own the task, so we may still have to wait for the\n-                // task to become available. In other words, if task.wake()\n+                // may not own the thread, so we may still have to wait for the\n+                // thread to become available. In other words, if thread.wake()\n                 // returns `None`, then someone else has ownership and we must\n                 // wait for their signal.\n                 match iter.map(f).filter_map(|a| a.err()).next() {\n@@ -342,15 +342,15 @@ impl Task {\n                     guard.wait();\n                 }\n             }\n-            // put the task back in TLS, and everything is as it once was.\n+            // put the thread back in TLS, and everything is as it once was.\n             Local::put(mem::transmute(me));\n         }\n     }\n \n-    /// Wakes up a previously blocked task. This function can only be\n-    /// called on tasks that were previously blocked in `deschedule`.\n+    /// Wakes up a previously blocked thread. This function can only be\n+    /// called on threads that were previously blocked in `deschedule`.\n     //\n-    // See the comments on `deschedule` for why the task is forgotten here, and\n+    // See the comments on `deschedule` for why the thread is forgotten here, and\n     // why it's valid to do so.\n     pub fn reawaken(mut self: Box<Task>) {\n         unsafe {\n@@ -362,21 +362,21 @@ impl Task {\n         }\n     }\n \n-    /// Yields control of this task to another task. This function will\n+    /// Yields control of this thread to another thread. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n-    /// opportunity to allow other tasks a chance to run.\n+    /// opportunity to allow other threads a chance to run.\n     pub fn yield_now() {\n         Thread::yield_now();\n     }\n \n-    /// Returns the stack bounds for this task in (lo, hi) format. The stack\n-    /// bounds may not be known for all tasks, so the return value may be\n+    /// Returns the stack bounds for this thread in (lo, hi) format. The stack\n+    /// bounds may not be known for all threads, so the return value may be\n     /// `None`.\n     pub fn stack_bounds(&self) -> (uint, uint) {\n         self.stack_bounds\n     }\n \n-    /// Returns the stack guard for this task, if known.\n+    /// Returns the stack guard for this thread, if known.\n     pub fn stack_guard(&self) -> Option<uint> {\n         if self.stack_guard != 0 {\n             Some(self.stack_guard)\n@@ -385,9 +385,9 @@ impl Task {\n         }\n     }\n \n-    /// Consume this task, flagging it as a candidate for destruction.\n+    /// Consume this thread, flagging it as a candidate for destruction.\n     ///\n-    /// This function is required to be invoked to destroy a task. A task\n+    /// This function is required to be invoked to destroy a thread. A thread\n     /// destroyed through a normal drop will abort.\n     pub fn drop(mut self) {\n         self.state = Destroyed;\n@@ -396,7 +396,7 @@ impl Task {\n \n impl Drop for Task {\n     fn drop(&mut self) {\n-        rtdebug!(\"called drop for a task: {}\", self as *mut Task as uint);\n+        rtdebug!(\"called drop for a thread: {}\", self as *mut Task as uint);\n         rtassert!(self.state != Armed);\n     }\n }\n@@ -414,7 +414,7 @@ impl Iterator<BlockedTask> for BlockedTasks {\n }\n \n impl BlockedTask {\n-    /// Returns Some if the task was successfully woken; None if already killed.\n+    /// Returns Some if the thread was successfully woken; None if already killed.\n     pub fn wake(self) -> Option<Box<Task>> {\n         match self {\n             Owned(task) => Some(task),\n@@ -427,7 +427,7 @@ impl BlockedTask {\n         }\n     }\n \n-    /// Reawakens this task if ownership is acquired. If finer-grained control\n+    /// Reawakens this thread if ownership is acquired. If finer-grained control\n     /// is desired, use `wake` instead.\n     pub fn reawaken(self) {\n         self.wake().map(|t| t.reawaken());\n@@ -438,12 +438,12 @@ impl BlockedTask {\n     #[cfg(not(test))] pub fn trash(self) { }\n     #[cfg(test)]      pub fn trash(self) { assert!(self.wake().is_none()); }\n \n-    /// Create a blocked task, unless the task was already killed.\n+    /// Create a blocked thread, unless the thread was already killed.\n     pub fn block(task: Box<Task>) -> BlockedTask {\n         Owned(task)\n     }\n \n-    /// Converts one blocked task handle to a list of many handles to the same.\n+    /// Converts one blocked thread handle to a list of many handles to the same.\n     pub fn make_selectable(self, num_handles: uint) -> Take<BlockedTasks> {\n         let arc = match self {\n             Owned(task) => {\n@@ -543,7 +543,7 @@ mod test {\n         drop(Task::new(None, None));\n     }\n \n-    // Task blocking tests\n+    // Thread blocking tests\n \n     #[test]\n     fn block_and_wake() {"}, {"sha": "9b57dcc9e18bfc941cb4657cf198738ff620097d", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -79,7 +79,7 @@ struct Exception {\n \n pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n \n-// Variables used for invoking callbacks when a task starts to unwind.\n+// Variables used for invoking callbacks when a thread starts to unwind.\n //\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n@@ -106,14 +106,14 @@ thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n ///\n /// * This is not safe to call in a nested fashion. The unwinding\n ///   interface for Rust is designed to have at most one try/catch block per\n-///   task, not multiple. No runtime checking is currently performed to uphold\n+///   thread, not multiple. No runtime checking is currently performed to uphold\n ///   this invariant, so this function is not safe. A nested try/catch block\n ///   may result in corruption of the outer try/catch block's state, especially\n-///   if this is used within a task itself.\n+///   if this is used within a thread itself.\n ///\n-/// * It is not sound to trigger unwinding while already unwinding. Rust tasks\n+/// * It is not sound to trigger unwinding while already unwinding. Rust threads\n ///   have runtime checks in place to ensure this invariant, but it is not\n-///   guaranteed that a rust task is in place when invoking this function.\n+///   guaranteed that a rust thread is in place when invoking this function.\n ///   Unwinding twice can lead to resource leaks where some destructors are not\n ///   run.\n pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n@@ -203,7 +203,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n // _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n //\n // This is pretty close to Rust's exception handling approach, except that Rust\n-// does have a single \"catch-all\" handler at the bottom of each task's stack.\n+// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n // So we have two versions of the personality routine:\n // - rust_eh_personality, used by all cleanup landing pads, which never catches,\n //   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n@@ -570,7 +570,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n     // Currently this means that panic!() on OOM will invoke this code path,\n     // but then again we're not really ready for panic on OOM anyway. If\n     // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this task instead of the task that's\n+    // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n     // see below for why we do the `Any` coercion here.\n@@ -593,7 +593,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     static INIT: Once = ONCE_INIT;\n     INIT.doit(|| unsafe { register(failure::on_fail); });\n \n-    // First, invoke call the user-defined callbacks triggered on task panic.\n+    // First, invoke call the user-defined callbacks triggered on thread panic.\n     //\n     // By the time that we see a callback has been registered (by reading\n     // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n@@ -621,18 +621,18 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n         // just abort. In the future we may consider resuming\n-        // unwinding or otherwise exiting the task cleanly.\n+        // unwinding or otherwise exiting the thread cleanly.\n         rterrln!(\"thread panicked while panicking. aborting.\");\n         unsafe { intrinsics::abort() }\n     }\n     PANICKING.with(|s| s.set(true));\n     rust_panic(msg);\n }\n \n-/// Register a callback to be invoked when a task unwinds.\n+/// Register a callback to be invoked when a thread unwinds.\n ///\n /// This is an unsafe and experimental API which allows for an arbitrary\n-/// callback to be invoked when a task panics. This callback is invoked on both\n+/// callback to be invoked when a thread panics. This callback is invoked on both\n /// the initial unwinding and a double unwinding if one occurs. Additionally,\n /// the local `Task` will be in place for the duration of the callback, and\n /// the callback must ensure that it remains in place once the callback returns."}, {"sha": "bdf947438f36bd617093a36cf57868eab2a9e488", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -180,7 +180,7 @@ impl<T: Send> Drop for AtomicOption<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use prelude::{Some, None};\n     use super::*;\n \n     #[test]"}, {"sha": "4091f0df39597d2b7fc683f257baf197574e4877", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -69,15 +69,15 @@ impl Barrier {\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously.\n     pub fn wait(&self) {\n-        let mut lock = self.lock.lock();\n+        let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n         lock.count += 1;\n         if lock.count < self.num_threads {\n             // We need a while loop to guard against spurious wakeups.\n             // http://en.wikipedia.org/wiki/Spurious_wakeup\n             while local_gen == lock.generation_id &&\n                   lock.count < self.num_threads {\n-                self.cvar.wait(&lock);\n+                lock = self.cvar.wait(lock).unwrap();\n             }\n         } else {\n             lock.count = 0;"}, {"sha": "15faf5be258f594816a289fda4d0e9f9fe8104a1", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 70, "deletions": 51, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -11,10 +11,11 @@\n use prelude::*;\n \n use sync::atomic::{mod, AtomicUint};\n-use sync::{mutex, StaticMutexGuard};\n+use sync::poison::{mod, LockResult};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use time::Duration;\n+use sync::{mutex, MutexGuard};\n \n /// A Condition Variable\n ///\n@@ -44,18 +45,19 @@ use time::Duration;\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n /// Thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n-///     let mut started = lock.lock();\n+///     let mut started = lock.lock().unwrap();\n ///     *started = true;\n ///     cvar.notify_one();\n /// }).detach();\n ///\n /// // wait for the thread to start up\n /// let &(ref lock, ref cvar) = &*pair;\n-/// let started = lock.lock();\n+/// let mut started = lock.lock().unwrap();\n /// while !*started {\n-///     cvar.wait(&started);\n+///     started = cvar.wait(started).unwrap();\n /// }\n /// ```\n+#[stable]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n unsafe impl Send for Condvar {}\n@@ -73,6 +75,7 @@ unsafe impl Sync for Condvar {}\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n+#[unstable = \"may be merged with Condvar in the future\"]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUint,\n@@ -82,24 +85,16 @@ unsafe impl Send for StaticCondvar {}\n unsafe impl Sync for StaticCondvar {}\n \n /// Constant initializer for a statically allocated condition variable.\n+#[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n     mutex: atomic::INIT_ATOMIC_UINT,\n };\n \n-/// A trait for vaules which can be passed to the waiting methods of condition\n-/// variables. This is implemented by the mutex guards in this module.\n-///\n-/// Note that this trait should likely not be implemented manually unless you\n-/// really know what you're doing.\n-pub trait AsMutexGuard {\n-    #[allow(missing_docs)]\n-    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard;\n-}\n-\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n+    #[stable]\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n@@ -113,8 +108,8 @@ impl Condvar {\n     /// notification.\n     ///\n     /// This function will atomically unlock the mutex specified (represented by\n-    /// `guard`) and block the current thread. This means that any calls to\n-    /// `notify_*()` which happen logically after the mutex is unlocked are\n+    /// `mutex_guard`) and block the current thread. This means that any calls\n+    /// to `notify_*()` which happen logically after the mutex is unlocked are\n     /// candidates to wake this thread up. When this function call returns, the\n     /// lock specified will have been re-acquired.\n     ///\n@@ -123,16 +118,24 @@ impl Condvar {\n     /// the predicate must always be checked each time this function returns to\n     /// protect against spurious wakeups.\n     ///\n+    /// # Failure\n+    ///\n+    /// This function will return an error if the mutex being waited on is\n+    /// poisoned when this thread re-acquires the lock. For more information,\n+    /// see information about poisoning on the Mutex type.\n+    ///\n     /// # Panics\n     ///\n     /// This function will `panic!()` if it is used with more than one mutex\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n-    pub fn wait<T: AsMutexGuard>(&self, mutex_guard: &T) {\n+    #[stable]\n+    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n+                       -> LockResult<MutexGuard<'a, T>> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait(mutex_guard)\n+            me.inner.wait(guard)\n         }\n     }\n \n@@ -156,11 +159,11 @@ impl Condvar {\n     // provide. There are also additional concerns about the unix-specific\n     // implementation which may need to be addressed.\n     #[allow(dead_code)]\n-    fn wait_timeout<T: AsMutexGuard>(&self, mutex_guard: &T,\n-                                     dur: Duration) -> bool {\n+    fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n+                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout(mutex_guard, dur)\n+            me.inner.wait_timeout(guard, dur)\n         }\n     }\n \n@@ -171,6 +174,7 @@ impl Condvar {\n     /// `notify_one` are not buffered in any way.\n     ///\n     /// To wake up all threads, see `notify_one()`.\n+    #[stable]\n     pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n@@ -180,6 +184,7 @@ impl Condvar {\n     /// way.\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n+    #[stable]\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n@@ -194,13 +199,19 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    pub fn wait<T: AsMutexGuard>(&'static self, mutex_guard: &T) {\n-        unsafe {\n-            let lock = mutex_guard.as_mutex_guard();\n-            let sys = mutex::guard_lock(lock);\n-            self.verify(sys);\n-            self.inner.wait(sys);\n-            (*mutex::guard_poison(lock)).check(\"mutex\");\n+    #[unstable = \"may be merged with Condvar in the future\"]\n+    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n+                       -> LockResult<MutexGuard<'a, T>> {\n+        let poisoned = unsafe {\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            self.inner.wait(lock);\n+            mutex::guard_poison(&guard).get()\n+        };\n+        if poisoned {\n+            Err(poison::new_poison_error(guard))\n+        } else {\n+            Ok(guard)\n         }\n     }\n \n@@ -209,26 +220,31 @@ impl StaticCondvar {\n     ///\n     /// See `Condvar::wait_timeout`.\n     #[allow(dead_code)] // may want to stabilize this later, see wait_timeout above\n-    fn wait_timeout<T: AsMutexGuard>(&'static self, mutex_guard: &T,\n-                                     dur: Duration) -> bool {\n-        unsafe {\n-            let lock = mutex_guard.as_mutex_guard();\n-            let sys = mutex::guard_lock(lock);\n-            self.verify(sys);\n-            let ret = self.inner.wait_timeout(sys, dur);\n-            (*mutex::guard_poison(lock)).check(\"mutex\");\n-            return ret;\n+    fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n+                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        let (poisoned, success) = unsafe {\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            let success = self.inner.wait_timeout(lock, dur);\n+            (mutex::guard_poison(&guard).get(), success)\n+        };\n+        if poisoned {\n+            Err(poison::new_poison_error((guard, success)))\n+        } else {\n+            Ok((guard, success))\n         }\n     }\n \n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n     /// Deallocate all resources associated with this static condvar.\n@@ -237,6 +253,7 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()\n     }\n@@ -288,12 +305,12 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n         static M: StaticMutex = MUTEX_INIT;\n \n-        let g = M.lock();\n+        let g = M.lock().unwrap();\n         spawn(move|| {\n-            let _g = M.lock();\n+            let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n-        C.wait(&g);\n+        let g = C.wait(g).unwrap();\n         drop(g);\n         unsafe { C.destroy(); M.destroy(); }\n     }\n@@ -309,13 +326,13 @@ mod tests {\n             let tx = tx.clone();\n             spawn(move|| {\n                 let &(ref lock, ref cond) = &*data;\n-                let mut cnt = lock.lock();\n+                let mut cnt = lock.lock().unwrap();\n                 *cnt += 1;\n                 if *cnt == N {\n                     tx.send(());\n                 }\n                 while *cnt != 0 {\n-                    cond.wait(&cnt);\n+                    cnt = cond.wait(cnt).unwrap();\n                 }\n                 tx.send(());\n             });\n@@ -324,7 +341,7 @@ mod tests {\n \n         let &(ref lock, ref cond) = &*data;\n         rx.recv();\n-        let mut cnt = lock.lock();\n+        let mut cnt = lock.lock().unwrap();\n         *cnt = 0;\n         cond.notify_all();\n         drop(cnt);\n@@ -339,13 +356,15 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n         static M: StaticMutex = MUTEX_INIT;\n \n-        let g = M.lock();\n-        assert!(!C.wait_timeout(&g, Duration::nanoseconds(1000)));\n+        let g = M.lock().unwrap();\n+        let (g, success) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n+        assert!(!success);\n         spawn(move|| {\n-            let _g = M.lock();\n+            let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n-        assert!(C.wait_timeout(&g, Duration::days(1)));\n+        let (g, success) = C.wait_timeout(g, Duration::days(1)).unwrap();\n+        assert!(success);\n         drop(g);\n         unsafe { C.destroy(); M.destroy(); }\n     }\n@@ -357,15 +376,15 @@ mod tests {\n         static M2: StaticMutex = MUTEX_INIT;\n         static C: StaticCondvar = CONDVAR_INIT;\n \n-        let g = M1.lock();\n+        let mut g = M1.lock().unwrap();\n         spawn(move|| {\n-            let _g = M1.lock();\n+            let _g = M1.lock().unwrap();\n             C.notify_one();\n         });\n-        C.wait(&g);\n+        g = C.wait(g).unwrap();\n         drop(g);\n \n-        C.wait(&M2.lock());\n+        C.wait(M2.lock().unwrap()).unwrap();\n \n     }\n }"}, {"sha": "092acc7ff25698fc1e33b0a0ed362add32665856", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -19,14 +19,15 @@\n \n pub use alloc::arc::{Arc, Weak};\n \n-pub use self::mutex::{Mutex, MutexGuard, StaticMutex, StaticMutexGuard, MUTEX_INIT};\n+pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n+pub use self::mutex::MUTEX_INIT;\n pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n-pub use self::rwlock::{StaticRWLockReadGuard, StaticRWLockWriteGuard};\n-pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT, AsMutexGuard};\n+pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n pub use self::barrier::Barrier;\n+pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n pub use self::task_pool::TaskPool;"}, {"sha": "52004bb4a8f5f4a99f59658424c13ed59af0cb91", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 140, "deletions": 96, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -12,7 +12,7 @@ use prelude::*;\n \n use cell::UnsafeCell;\n use kinds::marker;\n-use sync::{poison, AsMutexGuard};\n+use sync::poison::{mod, TryLockError, TryLockResult, LockResult};\n use sys_common::mutex as sys;\n \n /// A mutual exclusion primitive useful for protecting shared data\n@@ -26,12 +26,23 @@ use sys_common::mutex as sys;\n ///\n /// # Poisoning\n ///\n-/// In order to prevent access to otherwise invalid data, each mutex will\n-/// propagate any panics which occur while the lock is held. Once a thread has\n-/// panicked while holding the lock, then all other threads will immediately\n-/// panic as well once they hold the lock.\n+/// The mutexes in this module implement a strategy called \"poisoning\" where a\n+/// mutex is considered poisoned whenever a thread panics while holding the\n+/// lock. Once a mutex is poisoned, all other tasks are unable to access the\n+/// data by default as it is likely tainted (some invariant is not being\n+/// upheld).\n ///\n-/// # Example\n+/// For a mutex, this means that the `lock` and `try_lock` methods return a\n+/// `Result` which indicates whether a mutex has been poisoned or not. Most\n+/// usage of a mutex will simply `unwrap()` these results, propagating panics\n+/// among threads to ensure that a possibly invalid invariant is not witnessed.\n+///\n+/// A poisoned mutex, however, does not prevent all access to the underlying\n+/// data. The `PoisonError` type has an `into_guard` method which will return\n+/// the guard that would have otherwise been returned on a successful lock. This\n+/// allows access to the data, despite the lock being poisoned.\n+///\n+/// # Examples\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n@@ -48,11 +59,14 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in range(0u, 10) {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     Thread::spawn(move|| {\n+///     Thread::spawn(move || {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n-///         let mut data = data.lock();\n+///         //\n+///         // We unwrap() the return value to assert that we are not expecting\n+///         // tasks to ever fail while holding the lock.\n+///         let mut data = data.lock().unwrap();\n ///         *data += 1;\n ///         if *data == N {\n ///             tx.send(());\n@@ -63,6 +77,36 @@ use sys_common::mutex as sys;\n ///\n /// rx.recv();\n /// ```\n+///\n+/// To recover from a poisoned mutex:\n+///\n+/// ```rust\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread::Thread;\n+///\n+/// let lock = Arc::new(Mutex::new(0u));\n+/// let lock2 = lock.clone();\n+///\n+/// let _ = Thread::spawn(move || -> () {\n+///     // This thread will acquire the mutex first, unwrapping the result of\n+///     // `lock` because the lock has not been poisoned.\n+///     let _lock = lock2.lock().unwrap();\n+///\n+///     // This panic while holding the lock (`_guard` is in scope) will poison\n+///     // the mutex.\n+///     panic!();\n+/// }).join();\n+///\n+/// // The lock is poisoned by this point, but the returned result can be\n+/// // pattern matched on to return the underlying guard on both branches.\n+/// let mut guard = match lock.lock() {\n+///     Ok(guard) => guard,\n+///     Err(poisoned) => poisoned.into_guard(),\n+/// };\n+///\n+/// *guard += 1;\n+/// ```\n+#[stable]\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -93,14 +137,15 @@ unsafe impl<T:Send> Sync for Mutex<T> { }\n /// static LOCK: StaticMutex = MUTEX_INIT;\n ///\n /// {\n-///     let _g = LOCK.lock();\n+///     let _g = LOCK.lock().unwrap();\n ///     // do some productive work\n /// }\n /// // lock is unlocked here.\n /// ```\n+#[unstable = \"may be merged with Mutex in the future\"]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n-    poison: UnsafeCell<poison::Flag>,\n+    poison: poison::Flag,\n }\n \n unsafe impl Sync for StaticMutex {}\n@@ -111,31 +156,27 @@ unsafe impl Sync for StaticMutex {}\n /// The data protected by the mutex can be access through this guard via its\n /// Deref and DerefMut implementations\n #[must_use]\n+#[stable]\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n-    __lock: &'a Mutex<T>,\n-    __guard: StaticMutexGuard,\n-}\n-\n-/// An RAII implementation of a \"scoped lock\" of a static mutex. When this\n-/// structure is dropped (falls out of scope), the lock will be unlocked.\n-#[must_use]\n-pub struct StaticMutexGuard {\n-    lock: &'static sys::Mutex,\n-    marker: marker::NoSend,\n-    poison: poison::Guard<'static>,\n+    __lock: &'a StaticMutex,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+    __marker: marker::NoSend,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n+#[unstable = \"may be merged with Mutex in the future\"]\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n-    poison: UnsafeCell { value: poison::Flag { failed: false } },\n+    poison: poison::FLAG_INIT,\n };\n \n impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n+    #[stable]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n             inner: box MUTEX_INIT,\n@@ -150,15 +191,14 @@ impl<T: Send> Mutex<T> {\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n-    /// this call will immediately panic once the mutex is acquired.\n-    pub fn lock(&self) -> MutexGuard<T> {\n-        unsafe {\n-            let lock: &'static StaticMutex = &*(&*self.inner as *const _);\n-            MutexGuard::new(self, lock.lock())\n-        }\n+    /// this call will return an error once the mutex is acquired.\n+    #[stable]\n+    pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n+        unsafe { self.inner.lock.lock() }\n+        MutexGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempts to acquire this lock.\n@@ -169,17 +209,17 @@ impl<T: Send> Mutex<T> {\n     ///\n     /// This function does not block.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n-    /// this call will immediately panic if the mutex would otherwise be\n+    /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(&self) -> Option<MutexGuard<T>> {\n-        unsafe {\n-            let lock: &'static StaticMutex = &*(&*self.inner as *const _);\n-            lock.try_lock().map(|guard| {\n-                MutexGuard::new(self, guard)\n-            })\n+    #[stable]\n+    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n+        if unsafe { self.inner.lock.try_lock() } {\n+            Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n }\n@@ -194,19 +234,27 @@ impl<T: Send> Drop for Mutex<T> {\n     }\n }\n \n+struct Dummy(UnsafeCell<()>);\n+unsafe impl Sync for Dummy {}\n+static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n+\n impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n-    pub fn lock(&'static self) -> StaticMutexGuard {\n+    #[inline]\n+    #[unstable = \"may be merged with Mutex in the future\"]\n+    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n-        StaticMutexGuard::new(self)\n+        MutexGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n-    pub fn try_lock(&'static self) -> Option<StaticMutexGuard> {\n+    #[inline]\n+    #[unstable = \"may be merged with Mutex in the future\"]\n+    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n-            Some(StaticMutexGuard::new(self))\n+            Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n         } else {\n-            None\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -220,61 +268,54 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n+    #[unstable = \"may be merged with Mutex in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n }\n \n impl<'mutex, T> MutexGuard<'mutex, T> {\n-    fn new(lock: &Mutex<T>, guard: StaticMutexGuard) -> MutexGuard<T> {\n-        MutexGuard { __lock: lock, __guard: guard }\n+    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n+           -> LockResult<MutexGuard<'mutex, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            MutexGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+                __marker: marker::NoSend,\n+            }\n+        })\n     }\n }\n \n-impl<'mutex, T> AsMutexGuard for MutexGuard<'mutex, T> {\n-    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard { &self.__guard }\n-}\n-\n impl<'mutex, T> Deref<T> for MutexGuard<'mutex, T> {\n-    fn deref<'a>(&'a self) -> &'a T { unsafe { &*self.__lock.data.get() } }\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.__data.get() }\n+    }\n }\n impl<'mutex, T> DerefMut<T> for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *self.__lock.data.get() }\n+        unsafe { &mut *self.__data.get() }\n     }\n }\n \n-impl StaticMutexGuard {\n-    fn new(lock: &'static StaticMutex) -> StaticMutexGuard {\n+#[unsafe_destructor]\n+impl<'a, T> Drop for MutexGuard<'a, T> {\n+    #[inline]\n+    fn drop(&mut self) {\n         unsafe {\n-            let guard = StaticMutexGuard {\n-                lock: &lock.lock,\n-                marker: marker::NoSend,\n-                poison: (*lock.poison.get()).borrow(),\n-            };\n-            guard.poison.check(\"mutex\");\n-            return guard;\n+            self.__lock.poison.done(&self.__poison);\n+            self.__lock.lock.unlock();\n         }\n     }\n }\n \n-pub fn guard_lock(guard: &StaticMutexGuard) -> &sys::Mutex { guard.lock }\n-pub fn guard_poison(guard: &StaticMutexGuard) -> &poison::Guard {\n-    &guard.poison\n+pub fn guard_lock<'a, T>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+    &guard.__lock.lock\n }\n \n-impl AsMutexGuard for StaticMutexGuard {\n-    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard { self }\n-}\n-\n-#[unsafe_destructor]\n-impl Drop for StaticMutexGuard {\n-    fn drop(&mut self) {\n-        unsafe {\n-            self.poison.done();\n-            self.lock.unlock();\n-        }\n-    }\n+pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n+    &guard.__lock.poison\n }\n \n #[cfg(test)]\n@@ -292,16 +333,16 @@ mod test {\n     #[test]\n     fn smoke() {\n         let m = Mutex::new(());\n-        drop(m.lock());\n-        drop(m.lock());\n+        drop(m.lock().unwrap());\n+        drop(m.lock().unwrap());\n     }\n \n     #[test]\n     fn smoke_static() {\n         static M: StaticMutex = MUTEX_INIT;\n         unsafe {\n-            drop(M.lock());\n-            drop(M.lock());\n+            drop(M.lock().unwrap());\n+            drop(M.lock().unwrap());\n             M.destroy();\n         }\n     }\n@@ -316,7 +357,7 @@ mod test {\n         fn inc() {\n             for _ in range(0, J) {\n                 unsafe {\n-                    let _g = M.lock();\n+                    let _g = M.lock().unwrap();\n                     CNT += 1;\n                 }\n             }\n@@ -343,7 +384,7 @@ mod test {\n     #[test]\n     fn try_lock() {\n         let m = Mutex::new(());\n-        assert!(m.try_lock().is_some());\n+        *m.try_lock().unwrap() = ();\n     }\n \n     #[test]\n@@ -355,22 +396,21 @@ mod test {\n             // wait until parent gets in\n             rx.recv();\n             let &(ref lock, ref cvar) = &*packet2.0;\n-            let mut lock = lock.lock();\n+            let mut lock = lock.lock().unwrap();\n             *lock = true;\n             cvar.notify_one();\n         });\n \n         let &(ref lock, ref cvar) = &*packet.0;\n-        let lock = lock.lock();\n+        let mut lock = lock.lock().unwrap();\n         tx.send(());\n         assert!(!*lock);\n         while !*lock {\n-            cvar.wait(&lock);\n+            lock = cvar.wait(lock).unwrap();\n         }\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_arc_condvar_poison() {\n         let packet = Packet(Arc::new((Mutex::new(1i), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n@@ -379,31 +419,35 @@ mod test {\n         spawn(move|| {\n             rx.recv();\n             let &(ref lock, ref cvar) = &*packet2.0;\n-            let _g = lock.lock();\n+            let _g = lock.lock().unwrap();\n             cvar.notify_one();\n             // Parent should fail when it wakes up.\n             panic!();\n         });\n \n         let &(ref lock, ref cvar) = &*packet.0;\n-        let lock = lock.lock();\n+        let mut lock = lock.lock().unwrap();\n         tx.send(());\n         while *lock == 1 {\n-            cvar.wait(&lock);\n+            match cvar.wait(lock) {\n+                Ok(l) => {\n+                    lock = l;\n+                    assert_eq!(*lock, 1);\n+                }\n+                Err(..) => break,\n+            }\n         }\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.lock();\n+        Thread::spawn(move|| {\n+            let lock = arc2.lock().unwrap();\n             assert_eq!(*lock, 2);\n         }).join();\n-        let lock = arc.lock();\n-        assert_eq!(*lock, 1);\n+        assert!(arc.lock().is_err());\n     }\n \n     #[test]\n@@ -414,8 +458,8 @@ mod test {\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n         spawn(move|| {\n-            let lock = arc2.lock();\n-            let lock2 = lock.deref().lock();\n+            let lock = arc2.lock().unwrap();\n+            let lock2 = lock.deref().lock().unwrap();\n             assert_eq!(*lock2, 1);\n             tx.send(());\n         });\n@@ -432,13 +476,13 @@ mod test {\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {\n-                    *self.i.lock() += 1;\n+                    *self.i.lock().unwrap() += 1;\n                 }\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n         }).join();\n-        let lock = arc.lock();\n+        let lock = arc.lock().unwrap();\n         assert_eq!(*lock, 2);\n     }\n }"}, {"sha": "edf16d99f4966d1e7e6a02462524fc5730f4aa4f", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 109, "deletions": 13, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,31 +8,127 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+\n+use cell::UnsafeCell;\n+use error::FromError;\n+use fmt;\n use thread::Thread;\n \n-pub struct Flag { pub failed: bool }\n+pub struct Flag { failed: UnsafeCell<bool> }\n+pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n \n impl Flag {\n-    pub fn borrow(&mut self) -> Guard {\n-        Guard { flag: &mut self.failed, panicking: Thread::panicking() }\n+    #[inline]\n+    pub fn borrow(&self) -> LockResult<Guard> {\n+        let ret = Guard { panicking: Thread::panicking() };\n+        if unsafe { *self.failed.get() } {\n+            Err(new_poison_error(ret))\n+        } else {\n+            Ok(ret)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn done(&self, guard: &Guard) {\n+        if !guard.panicking && Thread::panicking() {\n+            unsafe { *self.failed.get() = true; }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> bool {\n+        unsafe { *self.failed.get() }\n     }\n }\n \n-pub struct Guard<'a> {\n-    flag: &'a mut bool,\n+#[allow(missing_copy_implementations)]\n+pub struct Guard {\n     panicking: bool,\n }\n \n-impl<'a> Guard<'a> {\n-    pub fn check(&self, name: &str) {\n-        if *self.flag {\n-            panic!(\"poisoned {} - another task failed inside\", name);\n-        }\n+/// A type of error which can be returned whenever a lock is acquired.\n+///\n+/// Both Mutexes and RWLocks are poisoned whenever a task fails while the lock\n+/// is held. The precise semantics for when a lock is poisoned is documented on\n+/// each lock, but once a lock is poisoned then all future acquisitions will\n+/// return this error.\n+#[stable]\n+pub struct PoisonError<T> {\n+    guard: T,\n+}\n+\n+/// An enumeration of possible errors which can occur while calling the\n+/// `try_lock` method.\n+#[stable]\n+pub enum TryLockError<T> {\n+    /// The lock could not be acquired because another task failed while holding\n+    /// the lock.\n+    #[stable]\n+    Poisoned(PoisonError<T>),\n+    /// The lock could not be acquired at this time because the operation would\n+    /// otherwise block.\n+    #[stable]\n+    WouldBlock,\n+}\n+\n+/// A type alias for the result of a lock method which can be poisoned.\n+///\n+/// The `Ok` variant of this result indicates that the primitive was not\n+/// poisoned, and the `Guard` is contained within. The `Err` variant indicates\n+/// that the primitive was poisoned. Note that the `Err` variant *also* carries\n+/// the associated guard, and it can be acquired through the `into_inner`\n+/// method.\n+#[stable]\n+pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n+\n+/// A type alias for the result of a nonblocking locking method.\n+///\n+/// For more information, see `LockResult`. A `TryLockResult` doesn't\n+/// necessarily hold the associated guard in the `Err` type as the lock may not\n+/// have been acquired for other reasons.\n+#[stable]\n+pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n+\n+impl<T> fmt::Show for PoisonError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"poisoned lock: another task failed inside\".fmt(f)\n+    }\n+}\n+\n+impl<T> PoisonError<T> {\n+    /// Consumes this error indicating that a lock is poisoned, returning the\n+    /// underlying guard to allow access regardless.\n+    #[stable]\n+    pub fn into_guard(self) -> T { self.guard }\n+}\n+\n+impl<T> FromError<PoisonError<T>> for TryLockError<T> {\n+    fn from_error(err: PoisonError<T>) -> TryLockError<T> {\n+        TryLockError::Poisoned(err)\n     }\n+}\n \n-    pub fn done(&mut self) {\n-        if !self.panicking && Thread::panicking() {\n-            *self.flag = true;\n+impl<T> fmt::Show for TryLockError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            TryLockError::Poisoned(ref p) => p.fmt(f),\n+            TryLockError::WouldBlock => {\n+                \"try_lock failed because the operation would block\".fmt(f)\n+            }\n         }\n     }\n }\n+\n+pub fn new_poison_error<T>(guard: T) -> PoisonError<T> {\n+    PoisonError { guard: guard }\n+}\n+\n+pub fn map_result<T, U, F>(result: LockResult<T>, f: F)\n+                           -> LockResult<U>\n+                           where F: FnOnce(T) -> U {\n+    match result {\n+        Ok(t) => Ok(f(t)),\n+        Err(PoisonError { guard }) => Err(new_poison_error(f(guard)))\n+    }\n+}"}, {"sha": "7f3c77c97adefdeb10c055ca31d74de7c5d9eaf7", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 152, "deletions": 160, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -10,10 +10,10 @@\n \n use prelude::*;\n \n-use kinds::marker;\n use cell::UnsafeCell;\n+use kinds::marker;\n+use sync::poison::{mod, LockResult, TryLockError, TryLockResult};\n use sys_common::rwlock as sys;\n-use sync::poison;\n \n /// A reader-writer lock\n ///\n@@ -28,12 +28,14 @@ use sync::poison;\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n ///\n+/// # Poisoning\n+///\n /// RWLocks, like Mutexes, will become poisoned on panics. Note, however, that\n /// an RWLock may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::sync::RWLock;\n@@ -42,19 +44,20 @@ use sync::poison;\n ///\n /// // many reader locks can be held at once\n /// {\n-///     let r1 = lock.read();\n-///     let r2 = lock.read();\n+///     let r1 = lock.read().unwrap();\n+///     let r2 = lock.read().unwrap();\n ///     assert_eq!(*r1, 5);\n ///     assert_eq!(*r2, 5);\n /// } // read locks are dropped at this point\n ///\n /// // only one write lock may be held, however\n /// {\n-///     let mut w = lock.write();\n+///     let mut w = lock.write().unwrap();\n ///     *w += 1;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n+#[stable]\n pub struct RWLock<T> {\n     inner: Box<StaticRWLock>,\n     data: UnsafeCell<T>,\n@@ -77,64 +80,55 @@ unsafe impl<T> Sync for RWLock<T> {}\n /// static LOCK: StaticRWLock = RWLOCK_INIT;\n ///\n /// {\n-///     let _g = LOCK.read();\n+///     let _g = LOCK.read().unwrap();\n ///     // ... shared read access\n /// }\n /// {\n-///     let _g = LOCK.write();\n+///     let _g = LOCK.write().unwrap();\n ///     // ... exclusive write access\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n+#[unstable = \"may be merged with RWLock in the future\"]\n pub struct StaticRWLock {\n-    inner: sys::RWLock,\n-    poison: UnsafeCell<poison::Flag>,\n+    lock: sys::RWLock,\n+    poison: poison::Flag,\n }\n \n unsafe impl Send for StaticRWLock {}\n unsafe impl Sync for StaticRWLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n+#[unstable = \"may be merged with RWLock in the future\"]\n pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n-    inner: sys::RWLOCK_INIT,\n-    poison: UnsafeCell { value: poison::Flag { failed: false } },\n+    lock: sys::RWLOCK_INIT,\n+    poison: poison::FLAG_INIT,\n };\n \n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n+#[stable]\n pub struct RWLockReadGuard<'a, T: 'a> {\n-    __lock: &'a RWLock<T>,\n-    __guard: StaticRWLockReadGuard,\n+    __lock: &'a StaticRWLock,\n+    __data: &'a UnsafeCell<T>,\n+    __marker: marker::NoSend,\n }\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n+#[stable]\n pub struct RWLockWriteGuard<'a, T: 'a> {\n-    __lock: &'a RWLock<T>,\n-    __guard: StaticRWLockWriteGuard,\n-}\n-\n-/// RAII structure used to release the shared read access of a lock when\n-/// dropped.\n-#[must_use]\n-pub struct StaticRWLockReadGuard {\n-    lock: &'static sys::RWLock,\n-    marker: marker::NoSend,\n-}\n-\n-/// RAII structure used to release the exclusive write access of a lock when\n-/// dropped.\n-#[must_use]\n-pub struct StaticRWLockWriteGuard {\n-    lock: &'static sys::RWLock,\n-    marker: marker::NoSend,\n-    poison: poison::Guard<'static>,\n+    __lock: &'a StaticRWLock,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+    __marker: marker::NoSend,\n }\n \n impl<T: Send + Sync> RWLock<T> {\n     /// Creates a new instance of an RWLock which is unlocked and read to go.\n+    #[stable]\n     pub fn new(t: T) -> RWLock<T> {\n         RWLock { inner: box RWLOCK_INIT, data: UnsafeCell::new(t) }\n     }\n@@ -151,17 +145,16 @@ impl<T: Send + Sync> RWLock<T> {\n     /// Returns an RAII guard which will release this thread's shared access\n     /// once it is dropped.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. The\n-    /// panic will occur immediately after the lock has been acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock.\n+    /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n-    pub fn read(&self) -> RWLockReadGuard<T> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            RWLockReadGuard::new(self, lock.read())\n-        }\n+    #[stable]\n+    pub fn read(&self) -> LockResult<RWLockReadGuard<T>> {\n+        unsafe { self.inner.lock.read() }\n+        RWLockReadGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n@@ -173,18 +166,19 @@ impl<T: Send + Sync> RWLock<T> {\n     /// guarantees with respect to the ordering of whether contentious readers\n     /// or writers will acquire the lock first.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. A\n-    /// panic will only occur if the lock is acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n     #[inline]\n-    pub fn try_read(&self) -> Option<RWLockReadGuard<T>> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            lock.try_read().map(|guard| {\n-                RWLockReadGuard::new(self, guard)\n-            })\n+    #[stable]\n+    pub fn try_read(&self) -> TryLockResult<RWLockReadGuard<T>> {\n+        if unsafe { self.inner.lock.try_read() } {\n+            Ok(try!(RWLockReadGuard::new(&*self.inner, &self.data)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -197,17 +191,16 @@ impl<T: Send + Sync> RWLock<T> {\n     /// Returns an RAII guard which will drop the write access of this rwlock\n     /// when dropped.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. The\n-    /// panic will occur when the lock is acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock.\n+    /// An error will be returned when the lock is acquired.\n     #[inline]\n-    pub fn write(&self) -> RWLockWriteGuard<T> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            RWLockWriteGuard::new(self, lock.write())\n-        }\n+    #[stable]\n+    pub fn write(&self) -> LockResult<RWLockWriteGuard<T>> {\n+        unsafe { self.inner.lock.write() }\n+        RWLockWriteGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -216,49 +209,57 @@ impl<T: Send + Sync> RWLock<T> {\n     /// to `write` would otherwise block. If successful, an RAII guard is\n     /// returned.\n     ///\n-    /// # Panics\n+    /// # Failure\n     ///\n-    /// This function will panic if the RWLock is poisoned. An RWLock is\n-    /// poisoned whenever a writer panics while holding an exclusive lock. A\n-    /// panic will only occur if the lock is acquired.\n+    /// This function will return an error if the RWLock is poisoned. An RWLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n     #[inline]\n-    pub fn try_write(&self) -> Option<RWLockWriteGuard<T>> {\n-        unsafe {\n-            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n-            lock.try_write().map(|guard| {\n-                RWLockWriteGuard::new(self, guard)\n-            })\n+    #[stable]\n+    pub fn try_write(&self) -> TryLockResult<RWLockWriteGuard<T>> {\n+        if unsafe { self.inner.lock.try_read() } {\n+            Ok(try!(RWLockWriteGuard::new(&*self.inner, &self.data)))\n+        } else {\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n }\n \n #[unsafe_destructor]\n impl<T> Drop for RWLock<T> {\n     fn drop(&mut self) {\n-        unsafe { self.inner.inner.destroy() }\n+        unsafe { self.inner.lock.destroy() }\n     }\n }\n \n+struct Dummy(UnsafeCell<()>);\n+unsafe impl Sync for Dummy {}\n+static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n+\n impl StaticRWLock {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n     /// See `RWLock::read`.\n     #[inline]\n-    pub fn read(&'static self) -> StaticRWLockReadGuard {\n-        unsafe { self.inner.read() }\n-        StaticRWLockReadGuard::new(self)\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn read(&'static self) -> LockResult<RWLockReadGuard<'static, ()>> {\n+        unsafe { self.lock.read() }\n+        RWLockReadGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n     ///\n     /// See `RWLock::try_read`.\n     #[inline]\n-    pub fn try_read(&'static self) -> Option<StaticRWLockReadGuard> {\n-        if unsafe { self.inner.try_read() } {\n-            Some(StaticRWLockReadGuard::new(self))\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn try_read(&'static self)\n+                    -> TryLockResult<RWLockReadGuard<'static, ()>> {\n+        if unsafe { self.lock.try_read() } {\n+            Ok(try!(RWLockReadGuard::new(self, &DUMMY.0)))\n         } else {\n-            None\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -267,20 +268,23 @@ impl StaticRWLock {\n     ///\n     /// See `RWLock::write`.\n     #[inline]\n-    pub fn write(&'static self) -> StaticRWLockWriteGuard {\n-        unsafe { self.inner.write() }\n-        StaticRWLockWriteGuard::new(self)\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn write(&'static self) -> LockResult<RWLockWriteGuard<'static, ()>> {\n+        unsafe { self.lock.write() }\n+        RWLockWriteGuard::new(self, &DUMMY.0)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n     ///\n     /// See `RWLock::try_write`.\n     #[inline]\n-    pub fn try_write(&'static self) -> Option<StaticRWLockWriteGuard> {\n-        if unsafe { self.inner.try_write() } {\n-            Some(StaticRWLockWriteGuard::new(self))\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn try_write(&'static self)\n+                     -> TryLockResult<RWLockWriteGuard<'static, ()>> {\n+        if unsafe { self.lock.try_write() } {\n+            Ok(try!(RWLockWriteGuard::new(self, &DUMMY.0)))\n         } else {\n-            None\n+            Err(TryLockError::WouldBlock)\n         }\n     }\n \n@@ -290,70 +294,62 @@ impl StaticRWLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n+    #[unstable = \"may be merged with RWLock in the future\"]\n     pub unsafe fn destroy(&'static self) {\n-        self.inner.destroy()\n+        self.lock.destroy()\n     }\n }\n \n impl<'rwlock, T> RWLockReadGuard<'rwlock, T> {\n-    fn new(lock: &RWLock<T>, guard: StaticRWLockReadGuard)\n-           -> RWLockReadGuard<T> {\n-        RWLockReadGuard { __lock: lock, __guard: guard }\n+    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RWLockReadGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |_| {\n+            RWLockReadGuard {\n+                __lock: lock,\n+                __data: data,\n+                __marker: marker::NoSend,\n+            }\n+        })\n     }\n }\n impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &RWLock<T>, guard: StaticRWLockWriteGuard)\n-           -> RWLockWriteGuard<T> {\n-        RWLockWriteGuard { __lock: lock, __guard: guard }\n+    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RWLockWriteGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            RWLockWriteGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+                __marker: marker::NoSend,\n+            }\n+        })\n     }\n }\n \n impl<'rwlock, T> Deref<T> for RWLockReadGuard<'rwlock, T> {\n-    fn deref(&self) -> &T { unsafe { &*self.__lock.data.get() } }\n+    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n impl<'rwlock, T> Deref<T> for RWLockWriteGuard<'rwlock, T> {\n-    fn deref(&self) -> &T { unsafe { &*self.__lock.data.get() } }\n+    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n impl<'rwlock, T> DerefMut<T> for RWLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T { unsafe { &mut *self.__lock.data.get() } }\n-}\n-\n-impl StaticRWLockReadGuard {\n-    fn new(lock: &'static StaticRWLock) -> StaticRWLockReadGuard {\n-        let guard = StaticRWLockReadGuard {\n-            lock: &lock.inner,\n-            marker: marker::NoSend,\n-        };\n-        unsafe { (*lock.poison.get()).borrow().check(\"rwlock\"); }\n-        return guard;\n-    }\n-}\n-impl StaticRWLockWriteGuard {\n-    fn new(lock: &'static StaticRWLock) -> StaticRWLockWriteGuard {\n-        unsafe {\n-            let guard = StaticRWLockWriteGuard {\n-                lock: &lock.inner,\n-                marker: marker::NoSend,\n-                poison: (*lock.poison.get()).borrow(),\n-            };\n-            guard.poison.check(\"rwlock\");\n-            return guard;\n-        }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-impl Drop for StaticRWLockReadGuard {\n+impl<'a, T> Drop for RWLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n-        unsafe { self.lock.read_unlock(); }\n+        unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-impl Drop for StaticRWLockWriteGuard {\n+impl<'a, T> Drop for RWLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n-        self.poison.done();\n-        unsafe { self.lock.write_unlock(); }\n+        self.__lock.poison.done(&self.__poison);\n+        unsafe { self.__lock.lock.write_unlock(); }\n     }\n }\n \n@@ -368,19 +364,19 @@ mod tests {\n     #[test]\n     fn smoke() {\n         let l = RWLock::new(());\n-        drop(l.read());\n-        drop(l.write());\n-        drop((l.read(), l.read()));\n-        drop(l.write());\n+        drop(l.read().unwrap());\n+        drop(l.write().unwrap());\n+        drop((l.read().unwrap(), l.read().unwrap()));\n+        drop(l.write().unwrap());\n     }\n \n     #[test]\n     fn static_smoke() {\n         static R: StaticRWLock = RWLOCK_INIT;\n-        drop(R.read());\n-        drop(R.write());\n-        drop((R.read(), R.read()));\n-        drop(R.write());\n+        drop(R.read().unwrap());\n+        drop(R.write().unwrap());\n+        drop((R.read().unwrap(), R.read().unwrap()));\n+        drop(R.write().unwrap());\n         unsafe { R.destroy(); }\n     }\n \n@@ -394,12 +390,12 @@ mod tests {\n         for _ in range(0, N) {\n             let tx = tx.clone();\n             spawn(move|| {\n-                let mut rng = rand::task_rng();\n+                let mut rng = rand::thread_rng();\n                 for _ in range(0, M) {\n                     if rng.gen_weighted_bool(N) {\n-                        drop(R.write());\n+                        drop(R.write().unwrap());\n                     } else {\n-                        drop(R.read());\n+                        drop(R.read().unwrap());\n                     }\n                 }\n                 drop(tx);\n@@ -411,51 +407,47 @@ mod tests {\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.write();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.write().unwrap();\n+            panic!();\n         }).join();\n-        let lock = arc.read();\n-        assert_eq!(*lock, 1);\n+        assert!(arc.read().is_err());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.write();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.write().unwrap();\n+            panic!();\n         }).join();\n-        let lock = arc.write();\n-        assert_eq!(*lock, 1);\n+        assert!(arc.write().is_err());\n     }\n \n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.read();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.read().unwrap();\n+            panic!();\n         }).join();\n-        let lock = arc.read();\n+        let lock = arc.read().unwrap();\n         assert_eq!(*lock, 1);\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = Thread::spawn(move|| {\n-            let lock = arc2.read();\n-            assert_eq!(*lock, 2);\n+        let _: Result<uint, _> = Thread::spawn(move|| {\n+            let _lock = arc2.read().unwrap();\n+            panic!()\n         }).join();\n-        let lock = arc.write();\n+        let lock = arc.write().unwrap();\n         assert_eq!(*lock, 1);\n     }\n \n@@ -466,7 +458,7 @@ mod tests {\n         let (tx, rx) = channel();\n \n         Thread::spawn(move|| {\n-            let mut lock = arc2.write();\n+            let mut lock = arc2.write().unwrap();\n             for _ in range(0u, 10) {\n                 let tmp = *lock;\n                 *lock = -1;\n@@ -481,7 +473,7 @@ mod tests {\n         for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n             children.push(Thread::spawn(move|| {\n-                let lock = arc3.read();\n+                let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n         }\n@@ -493,7 +485,7 @@ mod tests {\n \n         // Wait for writer to finish\n         rx.recv();\n-        let lock = arc.read();\n+        let lock = arc.read().unwrap();\n         assert_eq!(*lock, 10);\n     }\n \n@@ -507,14 +499,14 @@ mod tests {\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {\n-                    let mut lock = self.i.write();\n+                    let mut lock = self.i.write().unwrap();\n                     *lock += 1;\n                 }\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n         }).join();\n-        let lock = arc.read();\n+        let lock = arc.read().unwrap();\n         assert_eq!(*lock, 2);\n     }\n }"}, {"sha": "e3b683a6ccb380786588fd57930197e9e2efb3c5", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -68,9 +68,9 @@ impl Semaphore {\n     /// This method will block until the internal count of the semaphore is at\n     /// least 1.\n     pub fn acquire(&self) {\n-        let mut count = self.lock.lock();\n+        let mut count = self.lock.lock().unwrap();\n         while *count <= 0 {\n-            self.cvar.wait(&count);\n+            count = self.cvar.wait(count).unwrap();\n         }\n         *count -= 1;\n     }\n@@ -80,7 +80,7 @@ impl Semaphore {\n     /// This will increment the number of resources in this semaphore by 1 and\n     /// will notify any pending waiters in `acquire` or `access` if necessary.\n     pub fn release(&self) {\n-        *self.lock.lock() += 1;\n+        *self.lock.lock().unwrap() += 1;\n         self.cvar.notify_one();\n     }\n "}, {"sha": "ee534f6cdde3ecf135ad0e2590d597448cd88f1d", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Abstraction of a task pool for basic parallelism.\n+//! Abstraction of a thread pool for basic parallelism.\n \n use core::prelude::*;\n \n@@ -45,9 +45,9 @@ impl<'a> Drop for Sentinel<'a> {\n     }\n }\n \n-/// A task pool used to execute functions in parallel.\n+/// A thread pool used to execute functions in parallel.\n ///\n-/// Spawns `n` worker tasks and replenishes the pool if any worker tasks\n+/// Spawns `n` worker threads and replenishes the pool if any worker threads\n /// panic.\n ///\n /// # Example\n@@ -69,34 +69,34 @@ impl<'a> Drop for Sentinel<'a> {\n /// assert_eq!(rx.iter().take(8u).sum(), 8u);\n /// ```\n pub struct TaskPool {\n-    // How the taskpool communicates with subtasks.\n+    // How the threadpool communicates with subthreads.\n     //\n-    // This is the only such Sender, so when it is dropped all subtasks will\n+    // This is the only such Sender, so when it is dropped all subthreads will\n     // quit.\n     jobs: Sender<Thunk>\n }\n \n impl TaskPool {\n-    /// Spawns a new task pool with `tasks` tasks.\n+    /// Spawns a new thread pool with `threads` threads.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `tasks` is 0.\n-    pub fn new(tasks: uint) -> TaskPool {\n-        assert!(tasks >= 1);\n+    /// This function will panic if `threads` is 0.\n+    pub fn new(threads: uint) -> TaskPool {\n+        assert!(threads >= 1);\n \n         let (tx, rx) = channel::<Thunk>();\n         let rx = Arc::new(Mutex::new(rx));\n \n-        // Taskpool tasks.\n-        for _ in range(0, tasks) {\n+        // Threadpool threads\n+        for _ in range(0, threads) {\n             spawn_in_pool(rx.clone());\n         }\n \n         TaskPool { jobs: tx }\n     }\n \n-    /// Executes the function `job` on a task in the pool.\n+    /// Executes the function `job` on a thread in the pool.\n     pub fn execute<F>(&self, job: F)\n         where F : FnOnce(), F : Send\n     {\n@@ -106,14 +106,14 @@ impl TaskPool {\n \n fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n     Thread::spawn(move |:| {\n-        // Will spawn a new task on panic unless it is cancelled.\n+        // Will spawn a new thread on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n \n         loop {\n             let message = {\n                 // Only lock jobs for the time it takes\n                 // to get a job, not run it.\n-                let lock = jobs.lock();\n+                let lock = jobs.lock().unwrap();\n                 lock.recv_opt()\n             };\n \n@@ -165,12 +165,12 @@ mod test {\n \n         let pool = TaskPool::new(TEST_TASKS);\n \n-        // Panic all the existing tasks.\n+        // Panic all the existing threads.\n         for _ in range(0, TEST_TASKS) {\n             pool.execute(move|| -> () { panic!() });\n         }\n \n-        // Ensure new tasks were spawned to compensate.\n+        // Ensure new threads were spawned to compensate.\n         let (tx, rx) = channel();\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n@@ -189,7 +189,7 @@ mod test {\n         let pool = TaskPool::new(TEST_TASKS);\n         let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n \n-        // Panic all the existing tasks in a bit.\n+        // Panic all the existing threads in a bit.\n         for _ in range(0, TEST_TASKS) {\n             let waiter = waiter.clone();\n             pool.execute(move|| {"}, {"sha": "866bf1d8a7d63ebc7812489a1c61cdf1e7886f2d", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -115,10 +115,10 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n \n                         // in theory we can demangle any Unicode code point, but\n                         // for simplicity we just catch the common ones.\n-                        \"$x20\" => \" \",\n-                        \"$x27\" => \"'\",\n-                        \"$x5b\" => \"[\",\n-                        \"$x5d\" => \"]\"\n+                        \"$u{20}\" => \" \",\n+                        \"$u{27}\" => \"'\",\n+                        \"$u{5b}\" => \"[\",\n+                        \"$u{5d}\" => \"]\"\n                     )\n                 } else {\n                     let idx = match rest.find('$') {"}, {"sha": "9ef1c33312fc8b4ac6c5a6e354ce0caa12bcc0b2", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -83,7 +83,7 @@ impl<M: Send> Helper<M> {\n         F: FnOnce() -> T,\n     {\n         unsafe {\n-            let _guard = self.lock.lock();\n+            let _guard = self.lock.lock().unwrap();\n             if !*self.initialized.get() {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = mem::transmute(box tx);\n@@ -95,7 +95,7 @@ impl<M: Send> Helper<M> {\n                 let t = f();\n                 Thread::spawn(move |:| {\n                     helper(receive.0, rx, t);\n-                    let _g = self.lock.lock();\n+                    let _g = self.lock.lock().unwrap();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n                 }).detach();\n@@ -111,7 +111,7 @@ impl<M: Send> Helper<M> {\n     /// This is only valid if the worker thread has previously booted\n     pub fn send(&'static self, msg: M) {\n         unsafe {\n-            let _guard = self.lock.lock();\n+            let _guard = self.lock.lock().unwrap();\n \n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n@@ -127,7 +127,7 @@ impl<M: Send> Helper<M> {\n             // Shut down, but make sure this is done inside our lock to ensure\n             // that we'll always receive the exit signal when the thread\n             // returns.\n-            let guard = self.lock.lock();\n+            let mut guard = self.lock.lock().unwrap();\n \n             // Close the channel by destroying it\n             let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n@@ -137,7 +137,7 @@ impl<M: Send> Helper<M> {\n \n             // Wait for the child to exit\n             while !*self.shutdown.get() {\n-                self.cond.wait(&guard);\n+                guard = self.cond.wait(guard).unwrap();\n             }\n             drop(guard);\n "}, {"sha": "7a09137a225dca5e21dc6d68994a9c71ee947e63", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -269,7 +269,7 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n     // Collect all the results we found\n     let mut addrs = Vec::new();\n     let mut rp = res;\n-    while rp.is_not_null() {\n+    while !rp.is_null() {\n         unsafe {\n             let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n                                              (*rp).ai_addrlen as uint));\n@@ -669,7 +669,7 @@ impl TcpStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: self.inner.lock.lock(),\n+            guard: self.inner.lock.lock().unwrap(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n@@ -808,7 +808,7 @@ impl UdpSocket {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: self.inner.lock.lock(),\n+            guard: self.inner.lock.lock().unwrap(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "ddae9a132c31483a88b79286e6d3c1c747a872df", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -244,7 +244,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n     use iter::{Iterator, IteratorExt};\n     use os;\n     use path::GenericPath;\n-    use ptr::RawPtr;\n+    use ptr::PtrExt;\n     use ptr;\n     use slice::SliceExt;\n "}, {"sha": "4b7ac8ff4d3a962e3f3c33dce1e784f0cd1e93d6", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -109,6 +109,8 @@ pub fn decode_error(errno: i32) -> IoError {\n              \"file descriptor is not a TTY\"),\n         libc::ETIMEDOUT => (io::TimedOut, \"operation timed out\"),\n         libc::ECANCELED => (io::TimedOut, \"operation aborted\"),\n+        libc::consts::os::posix88::EEXIST =>\n+            (io::PathAlreadyExists, \"path already exists\"),\n \n         // These two constants can have the same value on some systems,\n         // but different values on others, so we can't use a match"}, {"sha": "868b460aa5ed3897e807bc667aaf05babd764949", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -145,7 +145,7 @@ impl UnixStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { self.inner.lock.lock() },\n+            guard: unsafe { self.inner.lock.lock().unwrap() },\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "06259d61fcb8413bfa24b78e6cd36ed7352b7a87", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -131,7 +131,6 @@ extern \"system\" {\n \n pub mod compat {\n     use intrinsics::{atomic_store_relaxed, transmute};\n-    use iter::IteratorExt;\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n     use prelude::*;\n "}, {"sha": "3ad439078b9a146767660b3469ca6d93586add35", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -265,8 +265,8 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n                 {\n                     let filename = os::truncate_utf16_at_nul(&wfd.cFileName);\n                     match String::from_utf16(filename) {\n-                        Some(filename) => paths.push(Path::new(filename)),\n-                        None => {\n+                        Ok(filename) => paths.push(Path::new(filename)),\n+                        Err(..) => {\n                             assert!(libc::FindClose(find_handle) != 0);\n                             return Err(IoError {\n                                 kind: io::InvalidInput,"}, {"sha": "aee98e22836be89280114a9260ebb6376e8955c3", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -121,6 +121,8 @@ pub fn decode_error(errno: i32) -> IoError {\n              \"invalid handle provided to function\"),\n         libc::ERROR_NOTHING_TO_TERMINATE =>\n             (io::InvalidInput, \"no process to kill\"),\n+        libc::ERROR_ALREADY_EXISTS =>\n+            (io::PathAlreadyExists, \"path already exists\"),\n \n         // libuv maps this error code to EISDIR. we do too. if it is found\n         // to be incorrect, we can add in some more machinery to only"}, {"sha": "fa08290a888e9f3a2f86d1dcc303eec09aae1e2e", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -99,8 +99,9 @@ pub fn error_string(errnum: i32) -> String {\n \n         let msg = String::from_utf16(truncate_utf16_at_nul(&buf));\n         match msg {\n-            Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n-            None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n+            Ok(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+            Err(..) => format!(\"OS Error {} (FormatMessageW() returned \\\n+                                invalid UTF-16)\", errnum),\n         }\n     }\n }\n@@ -147,7 +148,7 @@ pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String\n                 // We want to explicitly catch the case when the\n                 // closure returned invalid UTF-16, rather than\n                 // set `res` to None and continue.\n-                let s = String::from_utf16(sub)\n+                let s = String::from_utf16(sub).ok()\n                     .expect(\"fill_utf16_buf_and_decode: closure created invalid UTF-16\");\n                 res = Some(s)\n             }\n@@ -169,8 +170,8 @@ pub fn getcwd() -> IoResult<Path> {\n     }\n \n     match String::from_utf16(truncate_utf16_at_nul(&buf)) {\n-        Some(ref cwd) => Ok(Path::new(cwd)),\n-        None => Err(IoError {\n+        Ok(ref cwd) => Ok(Path::new(cwd)),\n+        Err(..) => Err(IoError {\n             kind: OtherIoError,\n             desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n             detail: None,"}, {"sha": "99292b3b44bd1749b3b84ca51e3d1c4d06fdd97c", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -101,8 +101,8 @@ impl TTY {\n             };\n             utf16.truncate(num as uint);\n             let utf8 = match String::from_utf16(utf16.as_slice()) {\n-                Some(utf8) => utf8.into_bytes(),\n-                None => return Err(invalid_encoding()),\n+                Ok(utf8) => utf8.into_bytes(),\n+                Err(..) => return Err(invalid_encoding()),\n             };\n             self.utf8 = MemReader::new(utf8);\n         }"}, {"sha": "a7b3ee996a34dc428bf77bb827feceb2ba5742ef", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -313,7 +313,7 @@ impl Thread {\n \n     /// Spawn a new joinable thread, returning a `JoinGuard` for it.\n     ///\n-    /// The join guard can be used to explicitly join the child thead (via\n+    /// The join guard can be used to explicitly join the child thread (via\n     /// `join`), returning `Result<T>`, or it will implicitly join the child\n     /// upon being dropped. To detach the child, allowing it to outlive the\n     /// current thread, use `detach`.  See the module documentation for additional details.\n@@ -334,6 +334,7 @@ impl Thread {\n     }\n \n     /// Determines whether the current thread is panicking.\n+    #[inline]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n@@ -349,9 +350,9 @@ impl Thread {\n     // or futuxes, and in either case may allow spurious wakeups.\n     pub fn park() {\n         let thread = Thread::current();\n-        let mut guard = thread.inner.lock.lock();\n+        let mut guard = thread.inner.lock.lock().unwrap();\n         while !*guard {\n-            thread.inner.cvar.wait(&guard);\n+            guard = thread.inner.cvar.wait(guard).unwrap();\n         }\n         *guard = false;\n     }\n@@ -360,7 +361,7 @@ impl Thread {\n     ///\n     /// See the module doc for more detail.\n     pub fn unpark(&self) {\n-        let mut guard = self.inner.lock.lock();\n+        let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n             *guard = true;\n             self.inner.cvar.notify_one();"}, {"sha": "4cfa27093527a81720182f5692377a642458baeb", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -240,13 +240,18 @@ impl<T: 'static> Key<T> {\n         unsafe {\n             let slot = slot.get().expect(\"cannot access a TLS value during or \\\n                                           after it is destroyed\");\n-            if (*slot.get()).is_none() {\n-                *slot.get() = Some((self.init)());\n-            }\n-            f((*slot.get()).as_ref().unwrap())\n+            f(match *slot.get() {\n+                Some(ref inner) => inner,\n+                None => self.init(slot),\n+            })\n         }\n     }\n \n+    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n+        *slot.get() = Some((self.init)());\n+        (*slot.get()).as_ref().unwrap()\n+    }\n+\n     /// Test this TLS key to determine whether its value has been destroyed for\n     /// the current thread or not.\n     ///"}, {"sha": "5f96548c0530ac63badbeef3a827a5ddbc702b07", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -62,10 +62,10 @@ pub struct Key<T> { #[doc(hidden)] pub inner: KeyInner<T> }\n #[macro_export]\n macro_rules! scoped_thread_local {\n     (static $name:ident: $t:ty) => (\n-        __scoped_thread_local_inner!(static $name: $t)\n+        __scoped_thread_local_inner!(static $name: $t);\n     );\n     (pub static $name:ident: $t:ty) => (\n-        __scoped_thread_local_inner!(pub static $name: $t)\n+        __scoped_thread_local_inner!(pub static $name: $t);\n     );\n }\n \n@@ -240,6 +240,8 @@ mod tests {\n     use cell::Cell;\n     use prelude::*;\n \n+    scoped_thread_local!(static FOO: uint);\n+\n     #[test]\n     fn smoke() {\n         scoped_thread_local!(static BAR: uint);\n@@ -264,4 +266,16 @@ mod tests {\n             });\n         });\n     }\n+\n+    #[test]\n+    fn scope_item_allowed() {\n+        assert!(!FOO.is_set());\n+        FOO.set(&1, || {\n+            assert!(FOO.is_set());\n+            FOO.with(|slot| {\n+                assert_eq!(*slot, 1);\n+            });\n+        });\n+        assert!(!FOO.is_set());\n+    }\n }"}, {"sha": "f253943943dcce0334a0cfbf39f335be377a5d78", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -371,18 +371,25 @@ pub const DUMMY_NODE_ID: NodeId = -1;\n /// detects Copy, Send and Sync.\n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum TyParamBound {\n-    TraitTyParamBound(PolyTraitRef),\n+    TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n     RegionTyParamBound(Lifetime)\n }\n \n+/// A modifier on a bound, currently this is only used for `?Sized`, where the\n+/// modifier is `Maybe`. Negative bounds should also be handled here.\n+#[deriving(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+}\n+\n pub type TyParamBounds = OwnedSlice<TyParamBound>;\n \n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n-    pub unbound: Option<TraitRef>,\n     pub default: Option<P<Ty>>,\n     pub span: Span\n }\n@@ -1488,7 +1495,7 @@ pub struct PolyTraitRef {\n     pub bound_lifetimes: Vec<LifetimeDef>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n-    pub trait_ref: TraitRef\n+    pub trait_ref: TraitRef,\n }\n \n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n@@ -1577,8 +1584,6 @@ pub enum Item_ {\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety,\n               Generics,\n-              Option<TraitRef>, // (optional) default bound not required for Self.\n-                                // Currently, only Sized makes sense here.\n               TyParamBounds,\n               Vec<TraitItem>),\n     ItemImpl(Unsafety,"}, {"sha": "5a4f5731be50d9267c4ab672682f4f8cbc47b9ca", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -780,9 +780,9 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                     None => {}\n                 }\n             }\n-            ItemTrait(_, _, _, ref bounds, ref trait_items) => {\n+            ItemTrait(_, _, ref bounds, ref trait_items) => {\n                 for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t) = *b {\n+                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n                         self.insert(t.trait_ref.ref_id, NodeItem(i));\n                     }\n                 }"}, {"sha": "94a3784291d0bc595f56482a40a5c380a09f7de9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -139,11 +139,11 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n                                        .collect();\n             ast::ItemImpl(u, a, b, c, impl_items)\n         }\n-        ast::ItemTrait(u, a, b, c, methods) => {\n+        ast::ItemTrait(u, a, b, methods) => {\n             let methods = methods.into_iter()\n                                  .filter(|m| trait_method_in_cfg(cx, m))\n                                  .collect();\n-            ast::ItemTrait(u, a, b, c, methods)\n+            ast::ItemTrait(u, a, b, methods)\n         }\n         ast::ItemStruct(def, generics) => {\n             ast::ItemStruct(fold_struct(cx, def), generics)"}, {"sha": "239af1889090983b654ce639a698084142a21a60", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -68,7 +68,6 @@ pub trait AstBuilder {\n                span: Span,\n                id: ast::Ident,\n                bounds: OwnedSlice<ast::TyParamBound>,\n-               unbound: Option<ast::TraitRef>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n@@ -414,13 +413,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                span: Span,\n                id: ast::Ident,\n                bounds: OwnedSlice<ast::TyParamBound>,\n-               unbound: Option<ast::TraitRef>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n             id: ast::DUMMY_NODE_ID,\n             bounds: bounds,\n-            unbound: unbound,\n             default: default,\n             span: span\n         }\n@@ -455,7 +452,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.poly_trait_ref(path))\n+        ast::TraitTyParamBound(self.poly_trait_ref(path), ast::TraitBoundModifier::None)\n     }\n \n     fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {"}, {"sha": "3c8d74c14ee6393a8b918cd8ed2f7f586cc2f2ff", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -58,10 +58,10 @@ fn expand_deriving_decodable_imp<F>(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n-            bounds: vec!((\"__D\", None, vec!(Path::new_(\n+            bounds: vec!((\"__D\", vec!(Path::new_(\n                             vec!(krate, \"Decoder\"), None,\n                             vec!(box Literal(Path::new_local(\"__E\"))), true))),\n-                         (\"__E\", None, vec!()))\n+                         (\"__E\", vec!()))\n         },\n         methods: vec!(\n             MethodDef {"}, {"sha": "5829f34bccc5dac280e2223700933e197f986b61", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -134,10 +134,10 @@ fn expand_deriving_encodable_imp<F>(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n-            bounds: vec!((\"__S\", None, vec!(Path::new_(\n+            bounds: vec!((\"__S\", vec!(Path::new_(\n                             vec!(krate, \"Encoder\"), None,\n                             vec!(box Literal(Path::new_local(\"__E\"))), true))),\n-                         (\"__E\", None, vec!()))\n+                         (\"__E\", vec!()))\n         },\n         methods: vec!(\n             MethodDef {"}, {"sha": "e4e31139d82f48925941cf6da93dc5f4bcb79c81", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -417,7 +417,6 @@ impl<'a> TraitDef<'a> {\n             cx.typaram(self.span,\n                        ty_param.ident,\n                        OwnedSlice::from_vec(bounds),\n-                       ty_param.unbound.clone(),\n                        None)\n         }));\n "}, {"sha": "95bdd8b9ffd2fb71116d47dfeb1efd5400c028da", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -189,15 +189,19 @@ impl<'a> Ty<'a> {\n }\n \n \n-fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str,\n-               bounds: &[Path], unbound: Option<ast::TraitRef>,\n-               self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n+fn mk_ty_param(cx: &ExtCtxt,\n+               span: Span,\n+               name: &str,\n+               bounds: &[Path],\n+               self_ident: Ident,\n+               self_generics: &Generics)\n+               -> ast::TyParam {\n     let bounds =\n         bounds.iter().map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n         }).collect();\n-    cx.typaram(span, cx.ident_of(name), bounds, unbound, None)\n+    cx.typaram(span, cx.ident_of(name), bounds, None)\n }\n \n fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n@@ -216,7 +220,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n #[deriving(Clone)]\n pub struct LifetimeBounds<'a> {\n     pub lifetimes: Vec<(&'a str, Vec<&'a str>)>,\n-    pub bounds: Vec<(&'a str, Option<ast::TraitRef>, Vec<Path<'a>>)>,\n+    pub bounds: Vec<(&'a str, Vec<Path<'a>>)>,\n }\n \n impl<'a> LifetimeBounds<'a> {\n@@ -239,12 +243,11 @@ impl<'a> LifetimeBounds<'a> {\n         }).collect();\n         let ty_params = self.bounds.iter().map(|t| {\n             match t {\n-                &(ref name, ref unbound, ref bounds) => {\n+                &(ref name, ref bounds) => {\n                     mk_ty_param(cx,\n                                 span,\n                                 *name,\n                                 bounds.as_slice(),\n-                                unbound.clone(),\n                                 self_ty,\n                                 self_generics)\n                 }"}, {"sha": "72e3b45dc91b7b8217619deea64da07cc1f63c0a", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n                     vec!(box Literal(Path::new_local(\"__S\"))), true),\n          LifetimeBounds {\n              lifetimes: Vec::new(),\n-             bounds: vec!((\"__S\", None,\n+             bounds: vec!((\"__S\",\n                            vec!(Path::new(vec!(\"std\", \"hash\", \"Writer\"))))),\n          },\n          Path::new_local(\"__S\"))"}, {"sha": "1ddf5b2a5c31eef8106680a72b9491e4143ba059", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -36,7 +36,6 @@ pub fn expand_deriving_rand<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds {\n                     lifetimes: Vec::new(),\n                     bounds: vec!((\"R\",\n-                                  None,\n                                   vec!( Path::new(vec!(\"std\", \"rand\", \"Rng\")) )))\n                 },\n                 explicit_self: None,"}, {"sha": "4f0169e31f2293ff65c26e55a845a8d80b612813", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -736,18 +736,17 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n                                    -> TyParamBound\n                                    where T: Folder {\n     match tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_poly_trait_ref(ty)),\n+        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n     }\n }\n \n pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {id, ident, bounds, unbound, default, span} = tp;\n+    let TyParam {id, ident, bounds, default, span} = tp;\n     TyParam {\n         id: fld.new_id(id),\n         ident: ident,\n         bounds: fld.fold_bounds(bounds),\n-        unbound: unbound.map(|x| fld.fold_trait_ref(x)),\n         default: default.map(|x| fld.fold_ty(x)),\n         span: span\n     }\n@@ -1043,7 +1042,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                      folder.fold_ty(ty),\n                      new_impl_items)\n         }\n-        ItemTrait(unsafety, generics, unbound, bounds, methods) => {\n+        ItemTrait(unsafety, generics, bounds, methods) => {\n             let bounds = folder.fold_bounds(bounds);\n             let methods = methods.into_iter().flat_map(|method| {\n                 let r = match method {\n@@ -1073,7 +1072,6 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             }).collect();\n             ItemTrait(unsafety,\n                       folder.fold_generics(generics),\n-                      unbound,\n                       bounds,\n                       methods)\n         }"}, {"sha": "e88aabb044cc66a9296294b7deb4a1ac14869908", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -15,7 +15,7 @@ use self::ItemOrViewItem::*;\n \n use abi;\n use ast::{AssociatedType, BareFnTy, ClosureTy};\n-use ast::{RegionTyParamBound, TraitTyParamBound};\n+use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{ProvidedMethod, Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, Block};\n@@ -117,6 +117,13 @@ pub enum PathParsingMode {\n     LifetimeAndTypesWithColons,\n }\n \n+/// How to parse a bound, whether to allow bound modifiers such as `?`.\n+#[deriving(Copy, PartialEq)]\n+pub enum BoundParsingMode {\n+    Bare,\n+    Modified,\n+}\n+\n enum ItemOrViewItem {\n     /// Indicates a failure to parse any kind of item. The attributes are\n     /// returned.\n@@ -1087,12 +1094,12 @@ impl<'a> Parser<'a> {\n             let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n                                                      trait_ref: trait_ref };\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n-                self.parse_ty_param_bounds()\n+                self.parse_ty_param_bounds(BoundParsingMode::Bare)\n             } else {\n                 OwnedSlice::empty()\n             };\n             let all_bounds =\n-                Some(TraitTyParamBound(poly_trait_ref)).into_iter()\n+                Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n                 .chain(other_bounds.into_vec().into_iter())\n                 .collect();\n             ast::TyPolyTraitRef(all_bounds)\n@@ -1165,7 +1172,7 @@ impl<'a> Parser<'a> {\n         // To be helpful, parse the proc as ever\n         let _ = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let _ = self.parse_fn_args(false, false);\n-        let _ = self.parse_colon_then_ty_param_bounds();\n+        let _ = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n         let _ = self.parse_ret_ty();\n \n         self.obsolete(proc_span, ObsoleteProcType);\n@@ -1255,7 +1262,7 @@ impl<'a> Parser<'a> {\n             inputs\n         };\n \n-        let bounds = self.parse_colon_then_ty_param_bounds();\n+        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n \n         let output = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1481,7 +1488,7 @@ impl<'a> Parser<'a> {\n             return lhs;\n         }\n \n-        let bounds = self.parse_ty_param_bounds();\n+        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare);\n \n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n@@ -4029,28 +4036,35 @@ impl<'a> Parser<'a> {\n \n     // Parses a sequence of bounds if a `:` is found,\n     // otherwise returns empty list.\n-    fn parse_colon_then_ty_param_bounds(&mut self)\n+    fn parse_colon_then_ty_param_bounds(&mut self,\n+                                        mode: BoundParsingMode)\n                                         -> OwnedSlice<TyParamBound>\n     {\n         if !self.eat(&token::Colon) {\n             OwnedSlice::empty()\n         } else {\n-            self.parse_ty_param_bounds()\n+            self.parse_ty_param_bounds(mode)\n         }\n     }\n \n     // matches bounds    = ( boundseq )?\n     // where   boundseq  = ( polybound + boundseq ) | polybound\n     // and     polybound = ( 'for' '<' 'region '>' )? bound\n     // and     bound     = 'region | trait_ref\n-    // NB: The None/Some distinction is important for issue #7264.\n-    fn parse_ty_param_bounds(&mut self)\n+    fn parse_ty_param_bounds(&mut self,\n+                             mode: BoundParsingMode)\n                              -> OwnedSlice<TyParamBound>\n     {\n         let mut result = vec!();\n         loop {\n+            let question_span = self.span;\n+            let ate_question = self.eat(&token::Question);\n             match self.token {\n                 token::Lifetime(lifetime) => {\n+                    if ate_question {\n+                        self.span_err(question_span,\n+                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n+                    }\n                     result.push(RegionTyParamBound(ast::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: self.span,\n@@ -4060,7 +4074,18 @@ impl<'a> Parser<'a> {\n                 }\n                 token::ModSep | token::Ident(..) => {\n                     let poly_trait_ref = self.parse_poly_trait_ref();\n-                    result.push(TraitTyParamBound(poly_trait_ref))\n+                    let modifier = if ate_question {\n+                        if mode == BoundParsingMode::Modified {\n+                            TraitBoundModifier::Maybe\n+                        } else {\n+                            self.span_err(question_span,\n+                                          \"unexpected `?`\");\n+                            TraitBoundModifier::None\n+                        }\n+                    } else {\n+                        TraitBoundModifier::None\n+                    };\n+                    result.push(TraitTyParamBound(poly_trait_ref, modifier))\n                 }\n                 _ => break,\n             }\n@@ -4089,13 +4114,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Matches typaram = (unbound`?`)? IDENT optbounds ( EQ ty )?\n+    /// Matches typaram = (unbound `?`)? IDENT (`?` unbound)? optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n         // This is a bit hacky. Currently we are only interested in a single\n         // unbound, and it may only be `Sized`. To avoid backtracking and other\n         // complications, we parse an ident, then check for `?`. If we find it,\n         // we use the ident as the unbound, otherwise, we use it as the name of\n-        // type param.\n+        // type param. Even worse, for now, we need to check for `?` before or\n+        // after the bound.\n         let mut span = self.span;\n         let mut ident = self.parse_ident();\n         let mut unbound = None;\n@@ -4106,7 +4132,14 @@ impl<'a> Parser<'a> {\n             ident = self.parse_ident();\n         }\n \n-        let bounds = self.parse_colon_then_ty_param_bounds();\n+        let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n+        if let Some(unbound) = unbound {\n+            let mut bounds_as_vec = bounds.into_vec();\n+            bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n+                                                                trait_ref: unbound },\n+                                                 TraitBoundModifier::Maybe));\n+            bounds = OwnedSlice::from_vec(bounds_as_vec);\n+        };\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n@@ -4118,7 +4151,6 @@ impl<'a> Parser<'a> {\n             ident: ident,\n             id: ast::DUMMY_NODE_ID,\n             bounds: bounds,\n-            unbound: unbound,\n             default: default,\n             span: span,\n         }\n@@ -4260,7 +4292,7 @@ impl<'a> Parser<'a> {\n                     let bounded_ty = self.parse_ty();\n \n                     if self.eat(&token::Colon) {\n-                        let bounds = self.parse_ty_param_bounds();\n+                        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare);\n                         let hi = self.span.hi;\n                         let span = mk_sp(lo, hi);\n \n@@ -4747,15 +4779,23 @@ impl<'a> Parser<'a> {\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> ItemInfo {\n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n-        let sized = self.parse_for_sized();\n+        let unbound = self.parse_for_sized();\n \n         // Parse supertrait bounds.\n-        let bounds = self.parse_colon_then_ty_param_bounds();\n+        let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n+\n+        if let Some(unbound) = unbound {\n+            let mut bounds_as_vec = bounds.into_vec();\n+            bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n+                                                                trait_ref: unbound },\n+                                                 TraitBoundModifier::Maybe));\n+            bounds = OwnedSlice::from_vec(bounds_as_vec);\n+        };\n \n         self.parse_where_clause(&mut tps);\n \n         let meths = self.parse_trait_items();\n-        (ident, ItemTrait(unsafety, tps, sized, bounds, meths), None)\n+        (ident, ItemTrait(unsafety, tps, bounds, meths), None)\n     }\n \n     fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n@@ -4974,12 +5014,25 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_for_sized(&mut self) -> Option<ast::TraitRef> {\n+        // FIXME, this should really use TraitBoundModifier, but it will get\n+        // re-jigged shortly in any case, so leaving the hacky version for now.\n         if self.eat_keyword(keywords::For) {\n             let span = self.span;\n+            let mut ate_question = false;\n+            if self.eat(&token::Question) {\n+                ate_question = true;\n+            }\n             let ident = self.parse_ident();\n-            if !self.eat(&token::Question) {\n+            if self.eat(&token::Question) {\n+                if ate_question {\n+                    self.span_err(span,\n+                        \"unexpected `?`\");\n+                }\n+                ate_question = true;\n+            }\n+            if !ate_question {\n                 self.span_err(span,\n-                    \"expected 'Sized?' after `for` in trait item\");\n+                    \"expected `?Sized` after `for` in trait item\");\n                 return None;\n             }\n             let tref = Parser::trait_ref_from_ident(ident, span);\n@@ -5924,7 +5977,7 @@ impl<'a> Parser<'a> {\n     }\n \n \n-    /// Matches view_path : MOD? IDENT EQ non_global_path\n+    /// Matches view_path : MOD? non_global_path as IDENT\n     /// | MOD? non_global_path MOD_SEP LBRACE RBRACE\n     /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     /// | MOD? non_global_path MOD_SEP STAR\n@@ -6036,7 +6089,7 @@ impl<'a> Parser<'a> {\n         }\n         let mut rename_to = path[path.len() - 1u];\n         let path = ast::Path {\n-            span: mk_sp(lo, self.span.hi),\n+            span: mk_sp(lo, self.last_span.hi),\n             global: false,\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n@@ -6048,7 +6101,8 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::As) {\n             rename_to = self.parse_ident()\n         }\n-        P(spanned(lo, self.last_span.hi,\n+        P(spanned(lo,\n+                  self.last_span.hi,\n                   ViewPathSimple(rename_to, path, ast::DUMMY_NODE_ID)))\n     }\n "}, {"sha": "f22a4b5c6ed10b30e09a85824afe5ad703e4f161", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -724,7 +724,7 @@ pub fn fresh_name(src: &ast::Ident) -> ast::Name {\n     // following: debug version. Could work in final except that it's incompatible with\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq.\n-    /*let num = rand::task_rng().gen_uint_range(0,0xffff);\n+    /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n     gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n }\n "}, {"sha": "02a03285d3b86df9e5a7d8909d77edf40688bef6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use abi;\n use ast::{mod, FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n-use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound};\n+use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n use ast::{UnboxedClosureKind};\n use ast_util;\n@@ -958,20 +958,25 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(unsafety, ref generics, ref unbound, ref bounds, ref methods) => {\n+            ast::ItemTrait(unsafety, ref generics, ref bounds, ref methods) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n                 try!(self.word_nbsp(\"trait\"));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(generics));\n-                if let &Some(ref tref) = unbound {\n-                    try!(space(&mut self.s));\n-                    try!(self.word_space(\"for\"));\n-                    try!(self.print_trait_ref(tref));\n-                    try!(word(&mut self.s, \"?\"));\n+                let bounds: Vec<_> = bounds.iter().map(|b| b.clone()).collect();\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                for b in bounds.into_iter() {\n+                    if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = b {\n+                        try!(space(&mut self.s));\n+                        try!(self.word_space(\"for ?\"));\n+                        try!(self.print_trait_ref(&ptr.trait_ref));\n+                    } else {\n+                        real_bounds.push(b);\n+                    }\n                 }\n-                try!(self.print_bounds(\":\", bounds[]));\n+                try!(self.print_bounds(\":\", real_bounds[]));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -2345,7 +2350,11 @@ impl<'a> State<'a> {\n                 }\n \n                 try!(match *bound {\n-                    TraitTyParamBound(ref tref) => {\n+                    TraitTyParamBound(ref tref, TraitBoundModifier::None) => {\n+                        self.print_poly_trait_ref(tref)\n+                    }\n+                    TraitTyParamBound(ref tref, TraitBoundModifier::Maybe) => {\n+                        try!(word(&mut self.s, \"?\"));\n                         self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n@@ -2412,10 +2421,6 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n-        if let Some(ref tref) = param.unbound {\n-            try!(self.print_trait_ref(tref));\n-            try!(self.word_space(\"?\"));\n-        }\n         try!(self.print_ident(param.ident));\n         try!(self.print_bounds(\":\", param.bounds[]));\n         match param.default {"}, {"sha": "1cd21ccac7a0ef41b7d757b3ee2cb51b65333c0f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -85,8 +85,8 @@ pub trait Visitor<'v> {\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef) {\n-        walk_poly_trait_ref(self, t)\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+        walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_struct_def(&mut self, s: &'v StructDef, _: Ident, _: &'v Generics, _: NodeId) {\n         walk_struct_def(self, s)\n@@ -244,7 +244,8 @@ pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n /// Like with walk_method_helper this doesn't correspond to a method\n /// in Visitor, and so it gets a _helper suffix.\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n-                                         trait_ref: &'v PolyTraitRef)\n+                                  trait_ref: &'v PolyTraitRef,\n+                                  _modifier: &'v TraitBoundModifier)\n     where V: Visitor<'v>\n {\n     walk_lifetime_decls_helper(visitor, &trait_ref.bound_lifetimes);\n@@ -324,7 +325,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                      generics,\n                                      item.id)\n         }\n-        ItemTrait(_, ref generics, _, ref bounds, ref methods) => {\n+        ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n             walk_ty_param_bounds_helper(visitor, bounds);\n             for method in methods.iter() {\n@@ -558,8 +559,8 @@ pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                bound: &'v TyParamBound) {\n     match *bound {\n-        TraitTyParamBound(ref typ) => {\n-            visitor.visit_poly_trait_ref(typ);\n+        TraitTyParamBound(ref typ, ref modifier) => {\n+            visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {\n             visitor.visit_lifetime_bound(lifetime);"}, {"sha": "420b1100ec1cd2013aaa8e20e0c44e21af30cbba", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -39,7 +39,7 @@\n //! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![crate_name = \"term\"]\n-#![experimental]\n+#![experimental = \"use the crates.io `term` library instead\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "3a37981744a5af2433fed551f742465c78c9af7f", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1 +1 @@\n-Subproject commit aed73472416064642911af790b25d57c9390b6c7\n+Subproject commit 3a37981744a5af2433fed551f742465c78c9af7f"}, {"sha": "d9a4aede7d7d910b5f0c703ee07b8bb6ea962351", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -83,7 +83,7 @@ fn read_line() {\n }\n \n fn vec_plus() {\n-    let mut r = rand::task_rng();\n+    let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n     let mut i = 0;\n@@ -101,7 +101,7 @@ fn vec_plus() {\n }\n \n fn vec_append() {\n-    let mut r = rand::task_rng();\n+    let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n     let mut i = 0;\n@@ -122,7 +122,7 @@ fn vec_append() {\n }\n \n fn vec_push_all() {\n-    let mut r = rand::task_rng();\n+    let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n     for i in range(0u, 1500) {"}, {"sha": "8ec44b2dd3c1405e896d54f95232083fd9389359", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -28,15 +28,15 @@ type pipe = Arc<(Mutex<Vec<uint>>, Condvar)>;\n \n fn send(p: &pipe, msg: uint) {\n     let &(ref lock, ref cond) = &**p;\n-    let mut arr = lock.lock();\n+    let mut arr = lock.lock().unwrap();\n     arr.push(msg);\n     cond.notify_one();\n }\n fn recv(p: &pipe) -> uint {\n     let &(ref lock, ref cond) = &**p;\n-    let mut arr = lock.lock();\n+    let mut arr = lock.lock().unwrap();\n     while arr.is_empty() {\n-        cond.wait(&arr);\n+        arr = cond.wait(arr).unwrap();\n     }\n     arr.pop().unwrap()\n }"}, {"sha": "923f95e69d122bb417f7361c34126658c10ffcc2", "filename": "src/test/compile-fail/double-type-import.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub use self::bar::X;\n+    use self::bar::X;\n+    //~^ ERROR a value named `X` has already been imported in this module\n+    //~| ERROR a type named `X` has already been imported in this module\n+\n+    mod bar {\n+        pub struct X;\n+    }\n+}\n+\n+fn main() {\n+    let _ = foo::X;\n+}"}, {"sha": "d9aa9d9dfccc73d7575c5c2c66ee031e998bdc3c", "filename": "src/test/compile-fail/duplicate-trait-bounds.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fduplicate-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fduplicate-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-trait-bounds.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {}\n+\n+fn foo<T: Foo + Foo>() {} //~ ERROR `Foo` already appears in the list of bounds\n+\n+fn main() {}"}, {"sha": "007b28b6924e45cd893a53bdb63a99ecf439bb8a", "filename": "src/test/compile-fail/import-shadow-1.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-1.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use bar::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "e597b557383866cc344b0cde275fc1bbd32475f2", "filename": "src/test/compile-fail/import-shadow-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-2.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "68222fa3fd727e2a03d99107d3aa4a870982a8dd", "filename": "src/test/compile-fail/import-shadow-3.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-3.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::Baz;\n+use bar::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "c698004bda0e48b2e73caf1cb1ec84c22190a2b6", "filename": "src/test/compile-fail/import-shadow-4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-4.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use bar::Baz; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "6ad7e5ec3e260b5cea826f30468d7199b4ff3137", "filename": "src/test/compile-fail/import-shadow-5.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-5.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::Baz;\n+use bar::Baz; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "1864251e71b4212dd58a6ce847a7a33747f45dc5", "filename": "src/test/compile-fail/import-shadow-6.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-6.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use qux::*;\n+use foo::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "a2df266fb74f3b912593cdc5fe3c2e467c54cb82", "filename": "src/test/compile-fail/import-shadow-7.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-shadow-7.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that import shadowing using globs causes errors\n+\n+#![no_implicit_prelude]\n+#![feature(globs)]\n+\n+use foo::*;\n+use qux::*; //~ERROR a type named `Baz` has already been imported in this module\n+\n+mod foo {\n+    pub type Baz = int;\n+}\n+\n+mod bar {\n+    pub type Baz = int;\n+}\n+\n+mod qux {\n+    pub use bar::Baz;\n+}\n+\n+fn main() {}"}, {"sha": "ea0d880f4a1cc6a04f9da5415257a3a780e97379", "filename": "src/test/compile-fail/issue-13853-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait FromStructReader<'a> { }\n+trait ResponseHook {\n+     fn get<'a, T: FromStructReader<'a>>(&'a self);\n+}\n+fn foo(res : Box<ResponseHook>) { res.get } //~ ERROR attempted to take value of method\n+fn main() {}"}, {"sha": "f10c47b594ea2c9edaa98b1f2191578d7256e583", "filename": "src/test/compile-fail/issue-13853-3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-3.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+enum NodeContents<'a> {\n+    Children(Vec<Node<'a>>),\n+}\n+\n+impl<'a> Drop for NodeContents<'a> {\n+    //~^ ERROR cannot implement a destructor on a structure with type parameters\n+    fn drop( &mut self ) {\n+    }\n+}\n+\n+struct Node<'a> {\n+    contents: NodeContents<'a>,\n+}\n+\n+impl<'a> Node<'a> {\n+    fn noName(contents: NodeContents<'a>) -> Node<'a> {\n+        Node{  contents: contents,}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7d653f5ab9e29ad5e8cc25a83c1476a779ecfd6f", "filename": "src/test/compile-fail/issue-13853-4.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-4.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct AutoBuilder<'a> {\n+    context: &'a int\n+}\n+\n+impl<'a> Drop for AutoBuilder<'a> {\n+    //~^ ERROR cannot implement a destructor on a structure with type parameters\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b3a4f341f8448f30aa6b76221d14fb31dbd23b39", "filename": "src/test/compile-fail/issue-13853-5.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-5.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Deserializer<'a> { }\n+\n+trait Deserializable {\n+    fn deserialize_token<'a, D: Deserializer<'a>>(D, &'a str) -> Self;\n+}\n+\n+impl<'a, T: Deserializable> Deserializable for &'a str {\n+    //~^ ERROR unable to infer enough type information\n+    fn deserialize_token<D: Deserializer<'a>>(_x: D, _y: &'a str) -> &'a str {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "868836a4bbd0a936dedfa09cd625843ab3d3abab", "filename": "src/test/compile-fail/issue-13853.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Node {\n+    fn zomg();\n+}\n+\n+trait Graph<N: Node> {\n+    fn nodes<'a, I: Iterator<&'a N>>(&'a self) -> I;\n+}\n+\n+impl<N: Node> Graph<N> for Vec<N> {\n+    fn nodes<'a, I: Iterator<&'a N>>(&self) -> I {\n+        self.iter() //~ ERROR mismatched types\n+    }\n+}\n+\n+struct Stuff;\n+\n+impl Node for Stuff {\n+    fn zomg() {\n+        println!(\"zomg\");\n+    }\n+}\n+\n+fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n+    for node in graph.iter() { //~ ERROR does not implement any method in scope named\n+        node.zomg();\n+    }\n+}\n+\n+pub fn main() {\n+    let graph = Vec::new();\n+\n+    graph.push(Stuff);\n+\n+    iterate(graph); //~ ERROR mismatched types\n+}"}, {"sha": "c4846a64f29be2b6a2c3ae2e075157f4ed8c5f70", "filename": "src/test/compile-fail/issue-14227.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    pub static symbol: ();\n+}\n+static CRASH: () = symbol; //~ cannot refer to other statics by value\n+\n+fn main() {}"}, {"sha": "13d27e7152b037d99a492de24cd5d01eddacaea9", "filename": "src/test/compile-fail/issue-15034.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Lexer<'a> {\n+    input: &'a str,\n+}\n+\n+impl<'a> Lexer<'a> {\n+    pub fn new(input: &'a str) -> Lexer<'a> {\n+        Lexer { input: input }\n+    }\n+}\n+\n+struct Parser<'a> {\n+    lexer: &'a mut Lexer<'a>,\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub fn new(lexer: &'a mut Lexer) -> Parser<'a> {\n+        Parser { lexer: lexer }\n+        //~^ ERROR cannot infer an appropriate lifetime for lifetime parameter\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0e022834bacf2fae3bd8103b25199791ee4aeec2", "filename": "src/test/compile-fail/issue-16538.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod Y {\n+    type X = uint;\n+    extern {\n+        static x: *const uint;\n+    }\n+    fn foo(value: *const X) -> *const X {\n+        value\n+    }\n+}\n+\n+static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n+//~^ ERROR cannot refer to other statics by value\n+//~| ERROR: the trait `core::kinds::Sync` is not implemented for the type\n+\n+fn main() {}"}, {"sha": "50b0a1a20c24c2e238acc7c7036a4fb0fc399c23", "filename": "src/test/compile-fail/issue-17728.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::{Show, Formatter, Error};\n+use std::collections::HashMap;\n+\n+trait HasInventory {\n+    fn getInventory<'s>(&'s self) -> &'s mut Inventory;\n+    fn addToInventory(&self, item: &Item);\n+    fn removeFromInventory(&self, itemName: &str) -> bool;\n+}\n+\n+trait TraversesWorld {\n+    fn attemptTraverse(&self, room: &Room, directionStr: &str) -> Result<&Room, &str> {\n+        let direction = str_to_direction(directionStr);\n+        let maybe_room = room.direction_to_room.find(&direction);\n+        //~^ ERROR cannot infer an appropriate lifetime for autoref due to conflicting requirements\n+        match maybe_room {\n+            Some(entry) => Ok(entry),\n+            _ => Err(\"Direction does not exist in room.\")\n+        }\n+    }\n+}\n+\n+\n+#[deriving(Show, Eq, PartialEq, Hash)]\n+enum RoomDirection {\n+    West,\n+    East,\n+    North,\n+    South,\n+    Up,\n+    Down,\n+    In,\n+    Out,\n+\n+    None\n+}\n+\n+struct Room {\n+    description: String,\n+    items: Vec<Item>,\n+    direction_to_room: HashMap<RoomDirection, Room>,\n+}\n+\n+impl Room {\n+    fn new(description: &'static str) -> Room {\n+        Room {\n+            description: description.to_string(),\n+            items: Vec::new(),\n+            direction_to_room: HashMap::new()\n+        }\n+    }\n+\n+    fn add_direction(&mut self, direction: RoomDirection, room: Room) {\n+        self.direction_to_room.insert(direction, room);\n+    }\n+}\n+\n+struct Item {\n+    name: String,\n+}\n+\n+struct Inventory {\n+    items: Vec<Item>,\n+}\n+\n+impl Inventory {\n+    fn new() -> Inventory {\n+        Inventory {\n+            items: Vec::new()\n+        }\n+    }\n+}\n+\n+struct Player {\n+    name: String,\n+    inventory: Inventory,\n+}\n+\n+impl Player {\n+    fn new(name: &'static str) -> Player {\n+        Player {\n+            name: name.to_string(),\n+            inventory: Inventory::new()\n+        }\n+    }\n+}\n+\n+impl TraversesWorld for Player {\n+}\n+\n+impl Show for Player {\n+    fn fmt(&self, formatter: &mut Formatter) -> Result<(), Error> {\n+        formatter.write_str(\"Player{ name:\");\n+        formatter.write_str(self.name.as_slice());\n+        formatter.write_str(\" }\");\n+        Ok(())\n+    }\n+}\n+\n+fn str_to_direction(to_parse: &str) -> RoomDirection {\n+    match to_parse {\n+        \"w\" | \"west\" => RoomDirection::West,\n+        \"e\" | \"east\" => RoomDirection::East,\n+        \"n\" | \"north\" => RoomDirection::North,\n+        \"s\" | \"south\" => RoomDirection::South,\n+        \"in\" => RoomDirection::In,\n+        \"out\" => RoomDirection::Out,\n+        \"up\" => RoomDirection::Up,\n+        \"down\" => RoomDirection::Down,\n+        _ => None //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {\n+    let mut player = Player::new(\"Test player\");\n+    let mut room = Room::new(\"A test room\");\n+    println!(\"Made a player: {}\", player);\n+    println!(\"Direction parse: {}\", str_to_direction(\"east\"));\n+    match player.attemptTraverse(&room, \"west\") {\n+        Ok(_) => println!(\"Was able to move west\"),\n+        Err(msg) => println!(\"Not able to move west: {}\", msg)\n+    };\n+}"}, {"sha": "73f86fee903e5b7bfe910ef8d4aeeb7daff99108", "filename": "src/test/compile-fail/issue-17740.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'a> {\n+    data: &'a[u8],\n+}\n+\n+impl <'a> Foo<'a>{\n+    fn bar(self: &mut Foo) {\n+    //~^ mismatched types: expected `Foo<'a>`, found `Foo<'_>` (lifetime mismatch)\n+    //~| mismatched types: expected `Foo<'a>`, found `Foo<'_>` (lifetime mismatch)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9affb44b7445c7d07736851368efa81e3e7ddc9d", "filename": "src/test/compile-fail/issue-19707.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-19707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-19707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19707.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+#![allow(dead_code)]\n+\n+type foo = fn(&u8, &u8) -> &u8; //~ ERROR missing lifetime specifier\n+//~^ HELP the signature does not say whether it is borrowed from argument 1 or argument 2\n+\n+fn bar<F: Fn(&u8, &u8) -> &u8>(f: &F) {} //~ ERROR missing lifetime specifier\n+//~^ HELP the signature does not say whether it is borrowed from argument 1 or argument 2\n+\n+fn main() {}"}, {"sha": "bbd41b28f03616a83da48c484031df58d3ff64de", "filename": "src/test/compile-fail/issue-5543.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test\n-\n-use std::io::ReaderUtil;\n-use std::io::Reader;\n-\n-fn bar(r:@ReaderUtil) -> String { r.read_line() }\n+trait Foo {}\n+impl Foo for u8 {}\n \n fn main() {\n-    let r : @Reader = io::stdin();\n-    let _m = bar(r as @ReaderUtil);\n+    let r: Box<Foo> = box 5;\n+    let _m: Box<Foo> = r as Box<Foo>;\n+    //~^ ERROR `core::kinds::Sized` is not implemented for the type `Foo`\n+    //~| ERROR `Foo` is not implemented for the type `Foo`\n }"}, {"sha": "77836143f27dd8824c8d91c7831d44f8d3b7cb64", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -14,8 +14,7 @@ use std::cell::RefCell;\n // Regresion test for issue 7364\n static boxed: Box<RefCell<int>> = box RefCell::new(0);\n //~^ ERROR statics are not allowed to have custom pointers\n-//~^^ ERROR: the trait `core::kinds::Sync` is not implemented for the type\n-//~^^^ ERROR: the trait `core::kinds::Sync` is not implemented for the type\n-//~^^^^ ERROR: the trait `core::kinds::Sync` is not implemented for the type\n+//~| ERROR: the trait `core::kinds::Sync` is not implemented for the type\n+//~| ERROR: the trait `core::kinds::Sync` is not implemented for the type\n \n fn main() { }"}, {"sha": "95ebb8bd882215524fe298fbe46989142cba7c91", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -17,5 +17,4 @@ fn main() {\n     f(x);\n     //~^ ERROR `core::kinds::Sync` is not implemented\n     //~^^ ERROR `core::kinds::Sync` is not implemented\n-    //~^^^ ERROR `core::kinds::Sync` is not implemented\n }"}, {"sha": "398b4f5859e656faf22c1ffec05473a80e56ddee", "filename": "src/test/compile-fail/resolve-label.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    'l: loop {\n+        fn g() {\n+            loop {\n+                break 'l; //~ ERROR use of undeclared label\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f673c3b797809803e0d1d7c5bb3bc57e0ded9f87", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ensure that the TaskRng isn't/doesn't become accidentally sendable.\n+// ensure that the ThreadRng isn't/doesn't become accidentally sendable.\n \n use std::rand;\n \n fn test_send<S: Send>() {}\n \n pub fn main() {\n-    test_send::<rand::TaskRng>();\n+    test_send::<rand::ThreadRng>();\n     //~^ ERROR `core::kinds::Send` is not implemented\n     //~^^ ERROR `core::kinds::Send` is not implemented\n }"}, {"sha": "88d8f10e7094d9f60561c613ed05b8a0ab379239", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -10,7 +10,7 @@\n \n use std::{char, os};\n use std::io::{File, Command};\n-use std::rand::{task_rng, Rng};\n+use std::rand::{thread_rng, Rng};\n \n // creates unicode_input_multiple_files_{main,chars}.rs, where the\n // former imports the latter. `_chars` just contains an identifier\n@@ -19,7 +19,7 @@ use std::rand::{task_rng, Rng};\n // this span used to upset the compiler).\n \n fn random_char() -> char {\n-    let mut rng = task_rng();\n+    let mut rng = thread_rng();\n     // a subset of the XID_start Unicode table (ensuring that the\n     // compiler doesn't fail with an \"unrecognised token\" error)\n     let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {"}, {"sha": "f83734b1502eb61426eb194afc83680bca85aa63", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -10,15 +10,15 @@\n \n use std::{char, os};\n use std::io::{File, Command};\n-use std::rand::{task_rng, Rng};\n+use std::rand::{thread_rng, Rng};\n \n // creates a file with `fn main() { <random ident> }` and checks the\n // compiler emits a span of the appropriate length (for the\n // \"unresolved name\" message); currently just using the number of code\n // points, but should be the number of graphemes (FIXME #7043)\n \n fn random_char() -> char {\n-    let mut rng = task_rng();\n+    let mut rng = thread_rng();\n     // a subset of the XID_start Unicode table (ensuring that the\n     // compiler doesn't fail with an \"unrecognised token\" error)\n     let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n@@ -38,7 +38,7 @@ fn main() {\n     let main_file = tmpdir.join(\"span_main.rs\");\n \n     for _ in range(0u, 100) {\n-        let n = task_rng().gen_range(3u, 20);\n+        let n = thread_rng().gen_range(3u, 20);\n \n         {\n             let _ = write!(&mut File::create(&main_file).unwrap(),"}, {"sha": "d3d2e3581aaf7e08ac4f9f7008ea0b2a7c17966d", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -23,7 +23,7 @@ impl Trait for A {\n     }\n }\n \n-struct Foo<Sized? T> {\n+struct Foo<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "47547bb7e5a27958859a5a4ad068f41cc448f56c", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -10,7 +10,7 @@\n \n // As dst-struct.rs, but the unsized field is the only field in the struct.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "fb536904ac80f4d197d483fb632f72890d1e1a1e", "filename": "src/test/run-pass/dst-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "abe55d78ac69a4bb00f9b7f99b7d4ead00694929", "filename": "src/test/run-pass/dst-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "b30583c666888bc7358074541915c49548e5c8cb", "filename": "src/test/run-pass/inconsistent-lifetime-mismatch.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Finconsistent-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Finconsistent-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finconsistent-lifetime-mismatch.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(_: &[&str]) {}\n+\n+fn bad(a: &str, b: &str) {\n+    foo(&[a, b]);\n+}\n+\n+fn good(a: &str, b: &str) {\n+    foo(&[a.as_slice(), b.as_slice()]);\n+}\n+\n+fn main() {}"}, {"sha": "6fdaac992047f09b0103a54f4f7191a03b1a964f", "filename": "src/test/run-pass/issue-13655.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13655.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+use std::ops::Fn;\n+\n+struct Foo<T>(T);\n+\n+impl<T: Copy> Fn<(), T> for Foo<T> {\n+    extern \"rust-call\" fn call(&self, _: ()) -> T {\n+      match *self {\n+        Foo(t) => t\n+      }\n+    }\n+}\n+\n+fn main() {\n+  let t: u8 = 1;\n+  println!(\"{}\", Foo(t)());\n+}"}, {"sha": "5ccbe9a7980e8a04bcef5082cb63c5eb0eb1a3f8", "filename": "src/test/run-pass/issue-13665.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-13665.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-13665.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13665.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'r>() {\n+  let maybe_value_ref: Option<&'r u8> = None;\n+\n+  let _ = maybe_value_ref.map(|& ref v| v);\n+  let _ = maybe_value_ref.map(|& ref v| -> &'r u8 {v});\n+  let _ = maybe_value_ref.map(|& ref v: &'r u8| -> &'r u8 {v});\n+  let _ = maybe_value_ref.map(|& ref v: &'r u8| {v});\n+}\n+\n+fn main() {\n+  foo();\n+}"}, {"sha": "e20090adcf6134ac18c1cd065cde2a8ebfbf5a53", "filename": "src/test/run-pass/issue-13808.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-13808.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-13808.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13808.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'a> {\n+    listener: ||: 'a\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn new(listener: ||: 'a) -> Foo<'a> {\n+        Foo { listener: listener }\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo::new(|| {});\n+}"}, {"sha": "3a63e63355cd09b0eda51acee61a0bd6dd8d7f28", "filename": "src/test/run-pass/issue-15155.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-15155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-15155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15155.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -22,7 +22,7 @@ struct IndirectBlah { x: Box<IndirectTraitWithSend> }\n impl TraitWithSend for IndirectBlah {}\n impl IndirectTraitWithSend for IndirectBlah {}\n \n-fn test_trait<Sized? T: Send>() { println!(\"got here!\") }\n+fn test_trait<T: Send + ?Sized>() { println!(\"got here!\") }\n \n fn main() {\n     test_trait::<TraitWithSend>();"}, {"sha": "092bcf661a76a2b5e2ecd7a4cef68790f0fd4196", "filename": "src/test/run-pass/issue-17361.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-17361.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-17361.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17361.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -11,6 +11,6 @@\n // Test that astconv doesn't forget about mutability of &mut str\n \n fn main() {\n-    fn foo<Sized? T>(_: &mut T) {}\n+    fn foo<T: ?Sized>(_: &mut T) {}\n     let _f: fn(&mut str) = foo;\n }"}, {"sha": "e82359bc168e671f12e584cc156fce55293c4c16", "filename": "src/test/run-pass/issue-18906.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-18906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-18906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18906.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Borrow<Sized? Borrowed> {\n+        fn borrow(&self) -> &Borrowed;\n+}\n+\n+impl<T: Sized> Borrow<T> for T {\n+        fn borrow(&self) -> &T { self }\n+}\n+\n+trait Foo {\n+        fn foo(&self, other: &Self);\n+}\n+\n+fn bar<K, Q>(k: &K, q: &Q) where K: Borrow<Q>, Q: Foo {\n+    q.foo(k.borrow())\n+}\n+\n+struct MyTree<K>;\n+\n+impl<K> MyTree<K> {\n+    // This caused a failure in #18906\n+    fn bar<Q>(k: &K, q: &Q) where K: Borrow<Q>, Q: Foo {\n+        q.foo(k.borrow())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "39b0711721b54a5abccfadd47447c0d7b28f8503", "filename": "src/test/run-pass/issue-7663.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fissue-7663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7663.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -17,8 +17,7 @@ mod test1 {\n     mod bar { pub fn p() -> int { 2 } }\n \n     pub mod baz {\n-        use test1::foo::*;\n-        use test1::bar::*;\n+        use test1::bar::p;\n \n         pub fn my_main() { assert!(p() == 2); }\n     }\n@@ -36,20 +35,7 @@ mod test2 {\n     }\n }\n \n-mod test3 {\n-\n-    mod foo { pub fn p() -> int { 1 } }\n-    mod bar { pub fn p() -> int { 2 } }\n-\n-    pub mod baz {\n-        use test3::bar::p;\n-\n-        pub fn my_main() { assert!(p() == 2); }\n-    }\n-}\n-\n fn main() {\n     test1::baz::my_main();\n     test2::baz::my_main();\n-    test3::baz::my_main();\n }"}, {"sha": "a83bc73457e020b4bdac0682be4294f22cdff004", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -11,13 +11,11 @@\n use std::sync::Mutex;\n \n pub fn main() {\n-    unsafe {\n-        let x = Some(Mutex::new(true));\n-        match x {\n-            Some(ref z) if *z.lock() => {\n-                assert!(*z.lock());\n-            },\n-            _ => panic!()\n-        }\n+    let x = Some(Mutex::new(true));\n+    match x {\n+        Some(ref z) if *z.lock().unwrap() => {\n+            assert!(*z.lock().unwrap());\n+        },\n+        _ => panic!()\n     }\n }"}, {"sha": "4e4fb75b428cc84f055a3a59a953b86f9771b488", "filename": "src/test/run-pass/method-recursive-blanket-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fmethod-recursive-blanket-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fmethod-recursive-blanket-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-recursive-blanket-impl.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -16,7 +16,7 @@\n use std::kinds::Sized;\n \n // Note: this must be generic for the problem to show up\n-trait Foo<A> for Sized? {\n+trait Foo<A> for ?Sized {\n     fn foo(&self);\n }\n "}, {"sha": "2d087406fd6f77a2d31eed60be0227d4646f8c12", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -23,7 +23,6 @@\n #![allow(unused_imports)]\n \n use std::io::*;\n-use std::io::net::tcp::*;\n use std::io::test::*;\n use std::io;\n use std::time::Duration;"}, {"sha": "4151ad6530ef40d86bbb51c257cdcea6ef5991ec", "filename": "src/test/run-pass/trait-static-method-generic-inference.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Ftrait-static-method-generic-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Ftrait-static-method-generic-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-generic-inference.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod base {\n+    pub trait HasNew<T> {\n+        fn new() -> T;\n+    }\n+\n+    pub struct Foo {\n+        dummy: (),\n+    }\n+\n+    impl HasNew<Foo> for Foo {\n+        fn new() -> Foo {\n+            Foo { dummy: () }\n+        }\n+    }\n+\n+    pub struct Bar {\n+        dummy: (),\n+    }\n+\n+    impl HasNew<Bar> for Bar {\n+        fn new() -> Bar {\n+            Bar { dummy: () }\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let _f: base::Foo = base::HasNew::new();\n+    let _b: base::Bar = base::HasNew::new();\n+}"}, {"sha": "07b9fac66554e0730ba063c5fe9f924ce4e07539", "filename": "src/test/run-pass/unsized.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -10,21 +10,22 @@\n //\n // ignore-lexer-test FIXME #15879\n \n-// Test syntax checks for `Sized?` syntax.\n+// Test syntax checks for `?Sized` syntax.\n \n-trait T1 for Sized? {}\n-pub trait T2 for Sized? {}\n-trait T3<X: T1> for Sized?: T2 {}\n-trait T4<Sized? X> {}\n-trait T5<Sized? X, Y> {}\n-trait T6<Y, Sized? X> {}\n-trait T7<Sized? X, Sized? Y> {}\n-trait T8<Sized? X: T2> {}\n-struct S1<Sized? X>;\n-enum E<Sized? X> {}\n-impl <Sized? X> T1 for S1<X> {}\n-fn f<Sized? X>() {}\n-type TT<Sized? T> = T;\n+trait T1 for ?Sized {}\n+pub trait T2 for ?Sized {}\n+trait T3<X: T1> for ?Sized: T2 {}\n+trait T4<X: ?Sized> {}\n+trait T5<X: ?Sized, Y> {}\n+trait T6<Y, X: ?Sized> {}\n+trait T7<X: ?Sized, Y: ?Sized> {}\n+trait T8<X: ?Sized+T2> {}\n+trait T9<X: T2 + ?Sized> {}\n+struct S1<X: ?Sized>;\n+enum E<X: ?Sized> {}\n+impl <X: ?Sized> T1 for S1<X> {}\n+fn f<X: ?Sized>() {}\n+type TT<T: ?Sized> = T;\n \n pub fn main() {\n }"}, {"sha": "8d2c99d4414c9921bf2110f15c86ac1a7ba3ceaf", "filename": "src/test/run-pass/unsized2.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized2.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -13,7 +13,7 @@\n // Test sized-ness checking in substitution.\n \n // Unbounded.\n-fn f1<Sized? X>(x: &X) {\n+fn f1<X: ?Sized>(x: &X) {\n     f1::<X>(x);\n }\n fn f2<X>(x: &X) {\n@@ -22,8 +22,8 @@ fn f2<X>(x: &X) {\n }\n \n // Bounded.\n-trait T for Sized? {}\n-fn f3<Sized? X: T>(x: &X) {\n+trait T for ?Sized {}\n+fn f3<X: T+?Sized>(x: &X) {\n     f3::<X>(x);\n }\n fn f4<X: T>(x: &X) {\n@@ -32,7 +32,7 @@ fn f4<X: T>(x: &X) {\n }\n \n // Self type.\n-trait T2 for Sized? {\n+trait T2 for ?Sized {\n     fn f() -> Box<Self>;\n }\n struct S;\n@@ -41,22 +41,22 @@ impl T2 for S {\n         box S\n     }\n }\n-fn f5<Sized? X: T2>(x: &X) {\n+fn f5<X: ?Sized+T2>(x: &X) {\n     let _: Box<X> = T2::f();\n }\n fn f6<X: T2>(x: &X) {\n     let _: Box<X> = T2::f();\n }\n \n-trait T3 for Sized? {\n+trait T3 for ?Sized {\n     fn f() -> Box<Self>;\n }\n impl T3 for S {\n     fn f() -> Box<S> {\n         box S\n     }\n }\n-fn f7<Sized? X: T3>(x: &X) {\n+fn f7<X: ?Sized+T3>(x: &X) {\n     // This is valid, but the unsized bound on X is irrelevant because any type\n     // which implements T3 must have statically known size.\n     let _: Box<X> = T3::f();\n@@ -66,7 +66,7 @@ trait T4<X> {\n     fn m1(x: &T4<X>);\n     fn m2(x: &T5<X>);\n }\n-trait T5<Sized? X> {\n+trait T5<X: ?Sized> {\n     // not an error (for now)\n     fn m1(x: &T4<X>);\n     fn m2(x: &T5<X>);\n@@ -76,21 +76,21 @@ trait T6<X: T> {\n     fn m1(x: &T4<X>);\n     fn m2(x: &T5<X>);\n }\n-trait T7<Sized? X: T> {\n+trait T7<X: ?Sized+T> {\n     // not an error (for now)\n     fn m1(x: &T4<X>);\n     fn m2(x: &T5<X>);\n }\n \n // The last field in a struct or variant may be unsized\n-struct S2<Sized? X> {\n+struct S2<X: ?Sized> {\n     f: X,\n }\n-struct S3<Sized? X> {\n+struct S3<X: ?Sized> {\n     f1: int,\n     f2: X,\n }\n-enum E<Sized? X> {\n+enum E<X: ?Sized> {\n     V1(X),\n     V2{x: X},\n     V3(int, X),"}, {"sha": "6ff1cffb4a42f448bf9fda4a3d7cc8e98fdbf4de", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -10,7 +10,7 @@\n \n use std::task;\n use std::sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n-use std::rand::{task_rng, Rng, Rand};\n+use std::rand::{thread_rng, Rng, Rand};\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n@@ -59,7 +59,7 @@ pub fn main() {\n             // IDs start from 0.\n             creation_count.store(0, Relaxed);\n \n-            let main = task_rng().gen_iter::<DropCounter>()\n+            let main = thread_rng().gen_iter::<DropCounter>()\n                                  .take(len)\n                                  .collect::<Vec<DropCounter>>();\n "}, {"sha": "dacfeb0081925ab0bcd6d4fc617cc60c70d0a53f", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2368c3c11ddab9d812c4ddec2e44579326ad347/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=d2368c3c11ddab9d812c4ddec2e44579326ad347", "patch": "@@ -15,13 +15,11 @@ struct Point {x: int, y: int, z: int}\n fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n-    unsafe {\n-        let x = Some(Mutex::new(true));\n-        match x {\n-            Some(ref z) if *z.lock() => {\n-                assert!(*z.lock());\n-            },\n-            _ => panic!()\n-        }\n+    let x = Some(Mutex::new(true));\n+    match x {\n+        Some(ref z) if *z.lock().unwrap() => {\n+            assert!(*z.lock().unwrap());\n+        },\n+        _ => panic!()\n     }\n }"}]}