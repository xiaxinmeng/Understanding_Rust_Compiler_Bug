{"sha": "6d81307a9b9f29e262164f9e358f50c186c76d76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkODEzMDdhOWI5ZjI5ZTI2MjE2NGY5ZTM1OGY1MGMxODZjNzZkNzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T22:52:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-23T05:24:35Z"}, "message": "librustc: Add explicit lifetime binders and new lifetime notation in core/std/syntax/rustc", "tree": {"sha": "620e4467c21651281114dfad71d36636eb4ff51b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/620e4467c21651281114dfad71d36636eb4ff51b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d81307a9b9f29e262164f9e358f50c186c76d76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d81307a9b9f29e262164f9e358f50c186c76d76", "html_url": "https://github.com/rust-lang/rust/commit/6d81307a9b9f29e262164f9e358f50c186c76d76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d81307a9b9f29e262164f9e358f50c186c76d76/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68cb53672b74e8b4352453e181667848cd63a183", "url": "https://api.github.com/repos/rust-lang/rust/commits/68cb53672b74e8b4352453e181667848cd63a183", "html_url": "https://github.com/rust-lang/rust/commit/68cb53672b74e8b4352453e181667848cd63a183"}], "stats": {"total": 251, "additions": 135, "deletions": 116}, "files": [{"sha": "767b6ecfad4b8dd3efcbb71fdb8b0bc2059fb60b", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -22,11 +22,11 @@ pub struct Handler<T, U> {\n \n pub struct Condition<T, U> {\n     name: &'static str,\n-    key: task::local_data::LocalDataKey/&self<Handler<T, U>>\n+    key: task::local_data::LocalDataKey<'self, Handler<T, U>>\n }\n \n-pub impl<T, U> Condition/&self<T, U> {\n-    fn trap(&self, h: &'self fn(T) -> U) -> Trap/&self<T, U> {\n+pub impl<T, U> Condition<'self, T, U> {\n+    fn trap(&self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = task::local_data::local_data_get(self.key);\n@@ -65,11 +65,11 @@ pub impl<T, U> Condition/&self<T, U> {\n }\n \n struct Trap<T, U> {\n-    cond: &'self Condition/&self<T, U>,\n+    cond: &'self Condition<'self, T, U>,\n     handler: @Handler<T, U>\n }\n \n-pub impl<T, U> Trap/&self<T, U> {\n+pub impl<T, U> Trap<'self, T, U> {\n     fn in<V>(&self, inner: &'self fn() -> V) -> V {\n         unsafe {\n             let _g = Guard { cond: self.cond };\n@@ -81,11 +81,11 @@ pub impl<T, U> Trap/&self<T, U> {\n }\n \n struct Guard<T, U> {\n-    cond: &'self Condition/&self<T, U>\n+    cond: &'self Condition<'self, T, U>\n }\n \n #[unsafe_destructor]\n-impl<T, U> Drop for Guard/&self<T, U> {\n+impl<T, U> Drop for Guard<'self, T, U> {\n     fn finalize(&self) {\n         unsafe {\n             debug!(\"Guard: popping handler from TLS\");"}, {"sha": "04d1d6f11b929caed14380e53a1847da4a8e1a8c", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -41,12 +41,12 @@ impl<T> Finally<T> for &'self fn() -> T {\n     }\n }\n \n-struct Finallyalizer {\n+struct Finallyalizer<'self> {\n     dtor: &'self fn()\n }\n \n #[unsafe_destructor]\n-impl Drop for Finallyalizer/&self {\n+impl<'self> Drop for Finallyalizer<'self> {\n     fn finalize(&self) {\n         (self.dtor)();\n     }"}, {"sha": "0440f4525ff36c2a0fcce9d1f2f150f5285cbe81", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -79,7 +79,7 @@ struct PreserveCtxt {\n     root_managed_data: bool\n }\n \n-pub impl PreserveCtxt/&self {\n+pub impl<'self> PreserveCtxt<'self> {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     fn preserve(&self, cmt: cmt) -> bckres<PreserveCondition> {"}, {"sha": "02b0e17a346b8d03c7b728f460fa083785024900", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -481,7 +481,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n }\n \n /// This is rather subtle.  When we are casting a value to a\n-/// instantiated trait like `a as trait/&r`, regionck already ensures\n+/// instantiated trait like `a as trait<'r>`, regionck already ensures\n /// that any borrowed pointers that appear in the type of `a` are\n /// bounded by `&r`.  However, it is possible that there are *type\n /// parameters* in the type of `a`, and those *type parameters* may"}, {"sha": "669587205d546f2e39600443c6971c6a4e6ef8e1", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -255,10 +255,10 @@ pub impl LanguageItems {\n     }\n }\n \n-fn LanguageItemCollector(crate: @crate,\n-                         session: Session,\n-                         items: &'r mut LanguageItems)\n-                      -> LanguageItemCollector/&r {\n+fn LanguageItemCollector<'r>(crate: @crate,\n+                             session: Session,\n+                             items: &'r mut LanguageItems)\n+                          -> LanguageItemCollector<'r> {\n     let item_refs = HashMap();\n \n     item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n@@ -320,7 +320,7 @@ struct LanguageItemCollector {\n     item_refs: HashMap<@~str, uint>,\n }\n \n-pub impl LanguageItemCollector/&self {\n+pub impl<'self> LanguageItemCollector<'self> {\n     fn match_and_collect_meta_item(&self, item_def_id: def_id,\n                                    meta_item: @meta_item) {\n         match meta_item.node {"}, {"sha": "7529b2132fd9edef8d6c3fd2cf36a6feaa8626c9", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -331,9 +331,9 @@ pub struct ArmData {\n     bindings_map: BindingsMap\n }\n \n-pub struct Match {\n+pub struct Match<'self> {\n     pats: ~[@ast::pat],\n-    data: @ArmData/&self\n+    data: @ArmData<'self>\n }\n \n pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n@@ -359,9 +359,11 @@ pub fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n     return false;\n }\n \n-pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n-                              col: uint, val: ValueRef)\n-                           -> ~[@Match/&r] {\n+pub fn expand_nested_bindings<'r>(bcx: block,\n+                                  m: &[@Match<'r>],\n+                                  col: uint,\n+                                  val: ValueRef)\n+                              -> ~[@Match<'r>] {\n     debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -402,9 +404,13 @@ pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     }\n }\n \n-pub fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n-                   col: uint, val: ValueRef, e: enter_pat)\n-                -> ~[@Match/&r] {\n+pub fn enter_match<'r>(bcx: block,\n+                       dm: DefMap,\n+                       m: &[@Match<'r>],\n+                       col: uint,\n+                       val: ValueRef,\n+                       e: enter_pat)\n+                    -> ~[@Match<'r>] {\n     debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -445,9 +451,12 @@ pub fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n     return result;\n }\n \n-pub fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n-                     col: uint, val: ValueRef)\n-                  -> ~[@Match/&r] {\n+pub fn enter_default<'r>(bcx: block,\n+                         dm: DefMap,\n+                         m: &[@Match<'r>],\n+                         col: uint,\n+                         val: ValueRef)\n+                      -> ~[@Match<'r>] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -488,9 +497,13 @@ pub fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n-                 variant_size: uint, val: ValueRef)\n-              -> ~[@Match/&r] {\n+pub fn enter_opt<'r>(bcx: block,\n+                     m: &[@Match<'r>],\n+                     opt: &Opt,\n+                     col: uint,\n+                     variant_size: uint,\n+                     val: ValueRef)\n+                  -> ~[@Match<'r>] {\n     debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -599,11 +612,11 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n \n pub fn enter_rec_or_struct(bcx: block,\n                            dm: DefMap,\n-                           m: &[@Match/&r],\n+                           m: &[@Match<'r>],\n                            col: uint,\n                            fields: &[ast::ident],\n                            val: ValueRef)\n-                        -> ~[@Match/&r] {\n+                        -> ~[@Match<'r>] {\n     debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -632,9 +645,13 @@ pub fn enter_rec_or_struct(bcx: block,\n     }\n }\n \n-pub fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n-                 col: uint, val: ValueRef, n_elts: uint)\n-              -> ~[@Match/&r] {\n+pub fn enter_tup<'r>(bcx: block,\n+                     dm: DefMap,\n+                     m: &[@Match<'r>],\n+                     col: uint,\n+                     val: ValueRef,\n+                     n_elts: uint)\n+                  -> ~[@Match<'r>] {\n     debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -656,13 +673,13 @@ pub fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-pub fn enter_tuple_struct(bcx: block,\n-                          dm: DefMap,\n-                          m: &[@Match/&r],\n-                          col: uint,\n-                          val: ValueRef,\n-                          n_elts: uint)\n-                       -> ~[@Match/&r] {\n+pub fn enter_tuple_struct<'r>(bcx: block,\n+                              dm: DefMap,\n+                              m: &[@Match<'r>],\n+                              col: uint,\n+                              val: ValueRef,\n+                              n_elts: uint)\n+                          -> ~[@Match<'r>] {\n     debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -682,12 +699,12 @@ pub fn enter_tuple_struct(bcx: block,\n     }\n }\n \n-pub fn enter_box(bcx: block,\n-                 dm: DefMap,\n-                 m: &[@Match/&r],\n-                 col: uint,\n-                 val: ValueRef)\n-              -> ~[@Match/&r] {\n+pub fn enter_box<'r>(bcx: block,\n+                     dm: DefMap,\n+                     m: &[@Match<'r>],\n+                     col: uint,\n+                     val: ValueRef)\n+                 -> ~[@Match<'r>] {\n     debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -709,12 +726,12 @@ pub fn enter_box(bcx: block,\n     }\n }\n \n-pub fn enter_uniq(bcx: block,\n-                  dm: DefMap,\n-                  m: &[@Match/&r],\n-                  col: uint,\n-                  val: ValueRef)\n-               -> ~[@Match/&r] {\n+pub fn enter_uniq<'r>(bcx: block,\n+                      dm: DefMap,\n+                      m: &[@Match<'r>],\n+                      col: uint,\n+                      val: ValueRef)\n+                  -> ~[@Match<'r>] {\n     debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -736,12 +753,12 @@ pub fn enter_uniq(bcx: block,\n     }\n }\n \n-pub fn enter_region(bcx: block,\n-                    dm: DefMap,\n-                    m: &[@Match/&r],\n-                    col: uint,\n-                    val: ValueRef)\n-                 -> ~[@Match/&r] {\n+pub fn enter_region<'r>(bcx: block,\n+                        dm: DefMap,\n+                        m: &[@Match<'r>],\n+                        col: uint,\n+                        val: ValueRef)\n+                    -> ~[@Match<'r>] {\n     debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),"}, {"sha": "c550e5c71e491aa684f03531a8ed1374584edb00", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -192,7 +192,7 @@ pub enum TransformTypeFlag {\n     TransformTypeForObject,\n }\n \n-pub impl LookupContext/&self {\n+pub impl<'self> LookupContext<'self> {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let mut self_ty = structurally_resolved_type(self.fcx,\n                                                      self.self_expr.span,"}, {"sha": "d037acff0ede71369d8dbf18e71dc653949d6c59", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -25,13 +25,13 @@ use core::ptr;\n use core::task;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n-pub struct Condvar {\n+pub struct Condvar<'self> {\n     is_mutex: bool,\n     failed: &'self mut bool,\n-    cond: &'self sync::Condvar/&self\n+    cond: &'self sync::Condvar<'self>\n }\n \n-pub impl Condvar/&self {\n+pub impl<'self> Condvar<'self> {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n     #[inline(always)]\n     fn wait(&self) { self.wait_on(0) }\n@@ -375,7 +375,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(&self, token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n+    fn downgrade(&self, token: RWWriteMode<'a, T>) -> RWReadMode<'a, T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n         let RWWriteMode {\n@@ -420,7 +420,7 @@ pub struct RWReadMode<'self, T> {\n     token: sync::RWlockReadMode<'self>,\n }\n \n-pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n+pub impl<T:Const + Owned> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n@@ -458,7 +458,7 @@ pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n     }\n }\n \n-pub impl<T:Const + Owned> RWReadMode/&self<T> {\n+pub impl<T:Const + Owned> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {"}, {"sha": "587509af9fa84168ebd41a2ececb2737dded0780", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -466,8 +466,8 @@ pub mod flatteners {\n         fn from_writer(w: @Writer) -> Self;\n     }\n \n-    impl FromReader for json::Decoder/&self {\n-        fn from_reader(r: @Reader) -> json::Decoder/&self {\n+    impl FromReader for json::Decoder<'self> {\n+        fn from_reader(r: @Reader) -> json::Decoder<'self> {\n             match json::from_reader(r) {\n                 Ok(json) => {\n                     json::Decoder(json)"}, {"sha": "f1f736e01a162d04a6ad2e48c97c9d43c6134291", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -749,7 +749,7 @@ pub fn Decoder(json: Json) -> Decoder {\n     Decoder { json: json, stack: ~[] }\n }\n \n-priv impl Decoder/&self {\n+priv impl Decoder<'self> {\n     fn peek(&self) -> &'self Json {\n         if vec::uniq_len(&const self.stack) == 0 {\n             self.stack.push(&self.json);\n@@ -765,7 +765,7 @@ priv impl Decoder/&self {\n     }\n }\n \n-impl serialize::Decoder for Decoder/&self {\n+impl serialize::Decoder for Decoder<'self> {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n         match *self.pop() {"}, {"sha": "1dc990526f0b64692360b5a20e1aa14bb046ba80", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -1191,7 +1191,7 @@ mod big_tests {\n     }\n \n     #[unsafe_destructor]\n-    impl Drop for LVal/&self {\n+    impl<'self> Drop for LVal<'self> {\n         fn finalize(&self) {\n             let x = unsafe { task::local_data::local_data_get(self.key) };\n             match x {\n@@ -1205,17 +1205,17 @@ mod big_tests {\n         }\n     }\n \n-    impl Ord for LVal/&self {\n-        fn lt(&self, other: &'a LVal/&self) -> bool {\n+    impl<'self> Ord for LVal<'self> {\n+        fn lt(&self, other: &'a LVal<'self>) -> bool {\n             (*self).val < other.val\n         }\n-        fn le(&self, other: &'a LVal/&self) -> bool {\n+        fn le(&self, other: &'a LVal<'self>) -> bool {\n             (*self).val <= other.val\n         }\n-        fn gt(&self, other: &'a LVal/&self) -> bool {\n+        fn gt(&self, other: &'a LVal<'self>) -> bool {\n             (*self).val > other.val\n         }\n-        fn ge(&self, other: &'a LVal/&self) -> bool {\n+        fn ge(&self, other: &'a LVal<'self>) -> bool {\n             (*self).val >= other.val\n         }\n     }"}, {"sha": "569c67eac93fb5a933ffb128792aa1f163229d2a", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -168,34 +168,34 @@ type SemAndSignalRelease = SemReleaseGeneric<'self, ~[Waitqueue]>;\n struct SemReleaseGeneric<Q> { sem: &'self Sem<Q> }\n \n #[unsafe_destructor]\n-impl<Q:Owned> Drop for SemReleaseGeneric/&self<Q> {\n+impl<Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n     fn finalize(&self) {\n         unsafe {\n             self.sem.release();\n         }\n     }\n }\n \n-fn SemRelease(sem: &'r Sem<()>) -> SemRelease/&r {\n+fn SemRelease(sem: &'r Sem<()>) -> SemRelease<'r> {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n fn SemAndSignalRelease(sem: &'r Sem<~[Waitqueue]>)\n-    -> SemAndSignalRelease/&r {\n+                    -> SemAndSignalRelease<'r> {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar { priv sem: &'self Sem<~[Waitqueue]> }\n+pub struct Condvar<'self> { priv sem: &'self Sem<~[Waitqueue]> }\n \n #[unsafe_destructor]\n-impl Drop for Condvar/&self { fn finalize(&self) {} }\n+impl<'self> Drop for Condvar<'self> { fn finalize(&self) {} }\n \n-pub impl Condvar/&self {\n+pub impl Condvar<'self> {\n     /**\n      * Atomically drop the associated lock, and block until a signal is sent.\n      *\n@@ -266,7 +266,7 @@ pub impl Condvar/&self {\n         }\n \n         #[unsafe_destructor]\n-        impl Drop for SemAndSignalReacquire/&self {\n+        impl<'self> Drop for SemAndSignalReacquire<'self> {\n             fn finalize(&self) {\n                 unsafe {\n                     // Needs to succeed, instead of itself dying.\n@@ -278,7 +278,7 @@ pub impl Condvar/&self {\n         }\n \n         fn SemAndSignalReacquire(sem: &'r Sem<~[Waitqueue]>)\n-            -> SemAndSignalReacquire/&r {\n+                              -> SemAndSignalReacquire<'r> {\n             SemAndSignalReacquire {\n                 sem: sem\n             }\n@@ -586,7 +586,9 @@ pub impl RWlock {\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(&self, token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n+    fn downgrade<'a>(&self,\n+                     token: RWlockWriteMode<'a>)\n+                  -> RWlockReadMode<'a> {\n         if !ptr::ref_eq(self, token.lock) {\n             fail!(~\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n@@ -619,7 +621,7 @@ struct RWlockReleaseRead {\n }\n \n #[unsafe_destructor]\n-impl Drop for RWlockReleaseRead/&self {\n+impl<'self> Drop for RWlockReleaseRead<'self> {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n@@ -641,7 +643,7 @@ impl Drop for RWlockReleaseRead/&self {\n     }\n }\n \n-fn RWlockReleaseRead(lock: &'r RWlock) -> RWlockReleaseRead/&r {\n+fn RWlockReleaseRead<'r>(lock: &'r RWlock) -> RWlockReleaseRead<'r> {\n     RWlockReleaseRead {\n         lock: lock\n     }\n@@ -655,7 +657,7 @@ struct RWlockReleaseDowngrade {\n }\n \n #[unsafe_destructor]\n-impl Drop for RWlockReleaseDowngrade/&self {\n+impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n@@ -685,23 +687,24 @@ impl Drop for RWlockReleaseDowngrade/&self {\n     }\n }\n \n-fn RWlockReleaseDowngrade(lock: &'r RWlock) -> RWlockReleaseDowngrade/&r {\n+fn RWlockReleaseDowngrade<'r>(lock: &'r RWlock)\n+                           -> RWlockReleaseDowngrade<'r> {\n     RWlockReleaseDowngrade {\n         lock: lock\n     }\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockWriteMode { priv lock: &'self RWlock }\n+pub struct RWlockWriteMode<'self> { priv lock: &'self RWlock }\n #[unsafe_destructor]\n-impl Drop for RWlockWriteMode/&self { fn finalize(&self) {} }\n+impl<'self> Drop for RWlockWriteMode<'self> { fn finalize(&self) {} }\n \n /// The \"read permission\" token used for rwlock.write_downgrade().\n pub struct RWlockReadMode  { priv lock: &'self RWlock }\n #[unsafe_destructor]\n-impl Drop for RWlockReadMode/&self { fn finalize(&self) {} }\n+impl<'self> Drop for RWlockReadMode<'self> { fn finalize(&self) {} }\n \n-pub impl RWlockWriteMode/&self {\n+pub impl<'self> RWlockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n     fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n@@ -710,7 +713,7 @@ pub impl RWlockWriteMode/&self {\n     }\n }\n \n-pub impl RWlockReadMode/&self {\n+pub impl<'self> RWlockReadMode<'self> {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n }"}, {"sha": "1da1edae7d245dff554584700043c32e7c708972", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -186,7 +186,7 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    fn iter(&self) -> TreeMapIterator/&self<K, V> {\n+    fn iter(&self) -> TreeMapIterator<'self, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n@@ -200,8 +200,8 @@ pub struct TreeMapIterator<K, V> {\n /// Advance the iterator to the next node (in order) and return a\n /// tuple with a reference to the key and value. If there are no\n /// more nodes, return `None`.\n-pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n-                        -> Option<(&'r K, &'r V)> {\n+pub fn map_next<'r, K, V>(iter: &mut TreeMapIterator<'r, K, V>)\n+                       -> Option<(&'r K, &'r V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n           Some(ref x) => {\n@@ -219,8 +219,8 @@ pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n }\n \n /// Advance the iterator through the map\n-pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                         f: &fn((&'r K, &'r V)) -> bool) {\n+pub fn map_advance<'r, K, V>(iter: &mut TreeMapIterator<'r, K, V>,\n+                             f: &fn((&'r K, &'r V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -490,27 +490,27 @@ pub impl <T: TotalOrd> TreeSet<T> {\n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n-    fn iter(&self) -> TreeSetIterator/&self<T> {\n+    fn iter(&self) -> TreeSetIterator<'self, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n }\n \n /// Lazy forward iterator over a set\n-pub struct TreeSetIterator<T> {\n-    priv iter: TreeMapIterator/&self<T, ()>\n+pub struct TreeSetIterator<'self, T> {\n+    priv iter: TreeMapIterator<'self, T, ()>\n }\n \n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n #[inline(always)]\n-pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&'r T> {\n+pub fn set_next<'r, T>(iter: &mut TreeSetIterator<'r, T>) -> Option<&'r T> {\n     do map_next(&mut iter.iter).map |&(value, _)| { value }\n }\n \n /// Advance the iterator through the set\n #[inline(always)]\n-pub fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n-                      f: &fn(&'r T) -> bool) {\n+pub fn set_advance<'r, T>(iter: &mut TreeSetIterator<'r, T>,\n+                          f: &fn(&'r T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n "}, {"sha": "f477a8c9f910b5cb5c53d63c6e623eef6a0448c8", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -234,9 +234,8 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n     }\n }\n \n-fn json_decode<T:Decodable<json::Decoder/&static>>( // FIXME(#5121)\n-    s: &str) -> T\n-{\n+// FIXME(#5121)\n+fn json_decode<T:Decodable<json::Decoder<'static>>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n         Decodable::decode(&json::Decoder(j))\n@@ -266,7 +265,7 @@ pub impl Context {\n \n     fn prep<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder/&static>>( // FIXME(#5121)\n+              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n                   blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n@@ -284,7 +283,7 @@ trait TPrep {\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n     fn exec<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder/&static>>( // FIXME(#5121)\n+              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n@@ -325,7 +324,7 @@ impl TPrep for @Mut<Prep> {\n \n     fn exec<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder/&static>>( // FIXME(#5121)\n+              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n         let mut bo = Some(blk);\n \n@@ -366,7 +365,7 @@ impl TPrep for @Mut<Prep> {\n \n pub impl<T:Owned +\n          Encodable<json::Encoder> +\n-         Decodable<json::Decoder/&static>> Work<T> { // FIXME(#5121)\n+         Decodable<json::Decoder<'static>>> Work<T> { // FIXME(#5121)\n     fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n@@ -375,7 +374,7 @@ pub impl<T:Owned +\n // FIXME (#3724): movable self. This should be in impl Work.\n fn unwrap<T:Owned +\n             Encodable<json::Encoder> +\n-            Decodable<json::Decoder/&static>>( // FIXME(#5121)\n+            Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n     let mut ww = w;\n     let mut s = None;"}, {"sha": "fb9d96a783174142f5bcfe2634054bb194687fa7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -494,7 +494,7 @@ pub fn core_macros() -> ~str {\n                 fn key(_x: @::core::condition::Handler<$in,$out>) { }\n \n                 pub static cond :\n-                    ::core::condition::Condition/&static<$in,$out> =\n+                    ::core::condition::Condition<'static,$in,$out> =\n                     ::core::condition::Condition {\n                         name: stringify!($c),\n                         key: key"}, {"sha": "688d7a57d91a5040c841c3d4a7e1256621e624f6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d81307a9b9f29e262164f9e358f50c186c76d76/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6d81307a9b9f29e262164f9e358f50c186c76d76", "patch": "@@ -109,7 +109,7 @@ pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n }\n \n pub struct MatcherPos {\n-    elts: ~[ast::matcher], // maybe should be /&? Need to understand regions.\n+    elts: ~[ast::matcher], // maybe should be <'>? Need to understand regions.\n     sep: Option<Token>,\n     idx: uint,\n     up: matcher_pos_up, // mutable for swapping only"}]}