{"sha": "87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YWU2OGMxZDZlNTVhNjJlMWZhZjRjZWNjYjVlODg0YWE2YTk1ZDU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-20T07:26:26Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-01T22:29:27Z"}, "message": "Refactor `binding.def()` to return a `Def` instead of an `Option<Def>`.", "tree": {"sha": "3ad5e4c0e067234956640fe8cfd43b4ab90689f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ad5e4c0e067234956640fe8cfd43b4ab90689f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5", "html_url": "https://github.com/rust-lang/rust/commit/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "691d10c3c947761ea00df87bd1b1fd532da248e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/691d10c3c947761ea00df87bd1b1fd532da248e0", "html_url": "https://github.com/rust-lang/rust/commit/691d10c3c947761ea00df87bd1b1fd532da248e0"}], "stats": {"total": 42, "additions": 20, "deletions": 22}, "files": [{"sha": "8a7a22988cb5f5b3f2ad6443e9f948136433e726", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5", "patch": "@@ -459,7 +459,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err\n         }\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n-            let shadows_what = PathResolution::new(binding.def().unwrap()).kind_name();\n+            let shadows_what = PathResolution::new(binding.def()).kind_name();\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0530,\n@@ -739,7 +739,7 @@ impl<'a> LexicalScopeBinding<'a> {\n     fn local_def(self) -> LocalDef {\n         match self {\n             LexicalScopeBinding::LocalDef(local_def) => local_def,\n-            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def().unwrap()),\n+            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def()),\n         }\n     }\n \n@@ -877,10 +877,10 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn def(&self) -> Option<Def> {\n+    fn def(&self) -> Def {\n         match self.kind {\n-            NameBindingKind::Def(def) => Some(def),\n-            NameBindingKind::Module(module) => module.def,\n+            NameBindingKind::Def(def) => def,\n+            NameBindingKind::Module(module) => module.def.unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.def(),\n         }\n     }\n@@ -916,7 +916,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_importable(&self) -> bool {\n-        match self.def().unwrap() {\n+        match self.def() {\n             Def::AssociatedConst(..) | Def::Method(..) | Def::AssociatedTy(..) => false,\n             _ => true,\n         }\n@@ -1097,7 +1097,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n-            Ok(binding) => binding.def().unwrap(),\n+            Ok(binding) => binding.def(),\n             Err(true) => Def::Err,\n             Err(false) => {\n                 let path_name = &format!(\"{}\", path);\n@@ -1693,7 +1693,7 @@ impl<'a> Resolver<'a> {\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n                                 Ok(binding) => {\n-                                    let def = binding.def().unwrap();\n+                                    let def = binding.def();\n                                     self.record_def(item.id, PathResolution::new(def));\n                                 }\n                                 Err(true) => self.record_def(item.id, err_path_resolution()),\n@@ -2309,7 +2309,7 @@ impl<'a> Resolver<'a> {\n                     // entity, then fall back to a fresh binding.\n                     let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n                                       .and_then(LexicalScopeBinding::item);\n-                    let resolution = binding.and_then(NameBinding::def).and_then(|def| {\n+                    let resolution = binding.map(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n                         match def {\n@@ -2443,7 +2443,7 @@ impl<'a> Resolver<'a> {\n \n         if path.global {\n             let binding = self.resolve_crate_relative_path(span, segments, namespace);\n-            return binding.map(|binding| mk_res(binding.def().unwrap()));\n+            return binding.map(|binding| mk_res(binding.def()));\n         }\n \n         // Try to find a path to an item in a module.\n@@ -2481,7 +2481,7 @@ impl<'a> Resolver<'a> {\n         let unqualified_def = resolve_identifier_with_fallback(self, None);\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n-            (Ok(binding), Some(ref ud)) if binding.def().unwrap() == ud.def => {\n+            (Ok(binding), Some(ref ud)) if binding.def() == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2491,7 +2491,7 @@ impl<'a> Resolver<'a> {\n             _ => {}\n         }\n \n-        qualified_binding.map(|binding| mk_res(binding.def().unwrap()))\n+        qualified_binding.map(|binding| mk_res(binding.def()))\n     }\n \n     // Resolve a single identifier\n@@ -3114,15 +3114,15 @@ impl<'a> Resolver<'a> {\n                     let mut collected_traits = Vec::new();\n                     module.for_each_child(|name, ns, binding| {\n                         if ns != TypeNS { return }\n-                        if let Some(Def::Trait(_)) = binding.def() {\n+                        if let Def::Trait(_) = binding.def() {\n                             collected_traits.push((name, binding));\n                         }\n                     });\n                     *traits = Some(collected_traits.into_boxed_slice());\n                 }\n \n                 for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-                    let trait_def_id = binding.def().unwrap().def_id();\n+                    let trait_def_id = binding.def().def_id();\n                     if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         let mut import_id = None;\n                         if let NameBindingKind::Import { directive, .. } = binding.kind {\n@@ -3181,8 +3181,8 @@ impl<'a> Resolver<'a> {\n                 if name_binding.is_import() { return; }\n \n                 // collect results based on the filter function\n-                if let Some(def) = name_binding.def() {\n-                    if name == lookup_name && ns == namespace && filter_fn(def) {\n+                if name == lookup_name && ns == namespace {\n+                    if filter_fn(name_binding.def()) {\n                         // create the path\n                         let ident = ast::Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n@@ -3302,7 +3302,7 @@ impl<'a> Resolver<'a> {\n                 let msg = format!(\"extern crate `{}` is private\", name);\n                 self.session.add_lint(lint::builtin::INACCESSIBLE_EXTERN_CRATE, node_id, span, msg);\n             } else {\n-                let def = binding.def().unwrap();\n+                let def = binding.def();\n                 self.session.span_err(span, &format!(\"{} `{}` is private\", def.kind_name(), name));\n             }\n         }"}, {"sha": "e00c736138d3bff87d50cdfc87e981f455fb3343", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=87ae68c1d6e55a62e1faf4ceccb5e884aa6a95d5", "patch": "@@ -639,9 +639,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.ok().and_then(NameBinding::def) {\n+        let def = match type_result.ok().map(NameBinding::def) {\n             Some(def) => def,\n-            None => value_result.ok().and_then(NameBinding::def).unwrap(),\n+            None => value_result.ok().map(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution::new(def);\n         self.def_map.insert(directive.id, path_resolution);\n@@ -714,9 +714,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n             if binding.vis == ty::Visibility::Public &&\n                (binding.is_import() || binding.is_extern_crate()) {\n-                if let Some(def) = binding.def() {\n-                    reexports.push(Export { name: name, def_id: def.def_id() });\n-                }\n+                reexports.push(Export { name: name, def_id: binding.def().def_id() });\n             }\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {"}]}