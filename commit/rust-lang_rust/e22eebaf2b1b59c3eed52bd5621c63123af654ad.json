{"sha": "e22eebaf2b1b59c3eed52bd5621c63123af654ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMmVlYmFmMmIxYjU5YzNlZWQ1MmJkNTYyMWM2MzEyM2FmNjU0YWQ=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-17T11:17:47Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T17:10:38Z"}, "message": "rustc_codegen_llvm: use safe references for PassManager.", "tree": {"sha": "cc9cc80ae428facd880b2de93343bfe2a500ec4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc9cc80ae428facd880b2de93343bfe2a500ec4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e22eebaf2b1b59c3eed52bd5621c63123af654ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e22eebaf2b1b59c3eed52bd5621c63123af654ad", "html_url": "https://github.com/rust-lang/rust/commit/e22eebaf2b1b59c3eed52bd5621c63123af654ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e22eebaf2b1b59c3eed52bd5621c63123af654ad/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab344454047966a8cca64d0e55c372534ed866b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab344454047966a8cca64d0e55c372534ed866b", "html_url": "https://github.com/rust-lang/rust/commit/0ab344454047966a8cca64d0e55c372534ed866b"}], "stats": {"total": 129, "additions": 65, "deletions": 64}, "files": [{"sha": "b3ef98b26cb1285f652741c7d9676fb063c4a415", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e22eebaf2b1b59c3eed52bd5621c63123af654ad/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22eebaf2b1b59c3eed52bd5621c63123af654ad/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=e22eebaf2b1b59c3eed52bd5621c63123af654ad", "patch": "@@ -25,7 +25,7 @@ use rustc::session::config::{self, OutputFilenames, OutputType, Passes, SomePass\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph, Timeline};\n-use llvm::{self, DiagnosticInfo, PassManagerRef, SMDiagnostic};\n+use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use {CodegenResults, ModuleSource, ModuleCodegen, CompiledModule, ModuleKind};\n use CrateInfo;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n@@ -92,9 +92,9 @@ pub fn llvm_err(handler: &errors::Handler, msg: String) -> FatalError {\n \n pub fn write_output_file(\n         handler: &errors::Handler,\n-        target: &llvm::TargetMachine,\n-        pm: llvm::PassManagerRef,\n-        m: &llvm::Module,\n+        target: &'ll llvm::TargetMachine,\n+        pm: &llvm::PassManager<'ll>,\n+        m: &'ll llvm::Module,\n         output: &Path,\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n@@ -516,50 +516,52 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n         let mpm = llvm::LLVMCreatePassManager();\n \n-        // If we're verifying or linting, add them to the function pass\n-        // manager.\n-        let addpass = |pass_name: &str| {\n-            let pass_name = CString::new(pass_name).unwrap();\n-            let pass = match llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr()) {\n-                Some(pass) => pass,\n-                None => return false,\n-            };\n-            let pass_manager = match llvm::LLVMRustPassKind(pass) {\n-                llvm::PassKind::Function => fpm,\n-                llvm::PassKind::Module => mpm,\n-                llvm::PassKind::Other => {\n-                    diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n-                    return true\n-                },\n+        {\n+            // If we're verifying or linting, add them to the function pass\n+            // manager.\n+            let addpass = |pass_name: &str| {\n+                let pass_name = CString::new(pass_name).unwrap();\n+                let pass = match llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr()) {\n+                    Some(pass) => pass,\n+                    None => return false,\n+                };\n+                let pass_manager = match llvm::LLVMRustPassKind(pass) {\n+                    llvm::PassKind::Function => &*fpm,\n+                    llvm::PassKind::Module => &*mpm,\n+                    llvm::PassKind::Other => {\n+                        diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n+                        return true\n+                    },\n+                };\n+                llvm::LLVMRustAddPass(pass_manager, pass);\n+                true\n             };\n-            llvm::LLVMRustAddPass(pass_manager, pass);\n-            true\n-        };\n \n-        if config.verify_llvm_ir { assert!(addpass(\"verify\")); }\n-        if !config.no_prepopulate_passes {\n-            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-            let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n-            let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal;\n-            with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n-                llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n-            })\n-        }\n+            if config.verify_llvm_ir { assert!(addpass(\"verify\")); }\n+            if !config.no_prepopulate_passes {\n+                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+                let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+                let prepare_for_thin_lto = cgcx.lto == Lto::Thin || cgcx.lto == Lto::ThinLocal;\n+                with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n+                    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n+                    llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n+                })\n+            }\n \n-        for pass in &config.passes {\n-            if !addpass(pass) {\n-                diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n-                                           pass));\n+            for pass in &config.passes {\n+                if !addpass(pass) {\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n+                                            pass));\n+                }\n             }\n-        }\n \n-        for pass in &cgcx.plugin_passes {\n-            if !addpass(pass) {\n-                diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                           `{}` but LLVM does not \\\n-                                           recognize it\", pass));\n+            for pass in &cgcx.plugin_passes {\n+                if !addpass(pass) {\n+                    diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                                            `{}` but LLVM does not \\\n+                                            recognize it\", pass));\n+                }\n             }\n         }\n \n@@ -636,11 +638,11 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         // pass manager passed to the closure should be ensured to not\n         // escape the closure itself, and the manager should only be\n         // used once.\n-        unsafe fn with_codegen<F, R>(tm: &llvm::TargetMachine,\n-                                    llmod: &llvm::Module,\n+        unsafe fn with_codegen<'ll, F, R>(tm: &'ll llvm::TargetMachine,\n+                                    llmod: &'ll llvm::Module,\n                                     no_builtins: bool,\n                                     f: F) -> R\n-            where F: FnOnce(PassManagerRef) -> R,\n+            where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n         {\n             let cpm = llvm::LLVMCreatePassManager();\n             llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);"}, {"sha": "7883315a5dec50b51d996e7a0e798b00ce66784f", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e22eebaf2b1b59c3eed52bd5621c63123af654ad/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22eebaf2b1b59c3eed52bd5621c63123af654ad/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=e22eebaf2b1b59c3eed52bd5621c63123af654ad", "patch": "@@ -397,8 +397,7 @@ extern { pub type Metadata; }\n extern { pub type BasicBlock; }\n extern { pub type Builder; }\n extern { pub type MemoryBuffer; }\n-extern { pub type PassManager; }\n-pub type PassManagerRef = *mut PassManager;\n+pub struct PassManager<'a>(InvariantOpaque<'a>);\n extern { pub type PassManagerBuilder; }\n extern { pub type ObjectFile; }\n extern { pub type SectionIterator; }\n@@ -1105,16 +1104,16 @@ extern \"C\" {\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n     /// Creates a pass manager.\n-    pub fn LLVMCreatePassManager() -> PassManagerRef;\n+    pub fn LLVMCreatePassManager() -> &'a mut PassManager<'a>;\n \n     /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> PassManagerRef;\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: &'a Module) -> &'a mut PassManager<'a>;\n \n     /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n+    pub fn LLVMDisposePassManager(PM: &'a mut PassManager<'a>);\n \n     /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager(PM: PassManagerRef, M: &Module) -> Bool;\n+    pub fn LLVMRunPassManager(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n \n     pub fn LLVMInitializePasses();\n \n@@ -1125,17 +1124,17 @@ extern \"C\" {\n     pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(PMB: &PassManagerBuilder,\n                                                          threshold: c_uint);\n     pub fn LLVMPassManagerBuilderPopulateModulePassManager(PMB: &PassManagerBuilder,\n-                                                           PM: PassManagerRef);\n+                                                           PM: &PassManager);\n \n     pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB: &PassManagerBuilder,\n-                                                             PM: PassManagerRef);\n+                                                             PM: &PassManager);\n     pub fn LLVMPassManagerBuilderPopulateLTOPassManager(PMB: &PassManagerBuilder,\n-                                                        PM: PassManagerRef,\n+                                                        PM: &PassManager,\n                                                         Internalize: Bool,\n                                                         RunInliner: Bool);\n     pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n         PMB: &PassManagerBuilder,\n-        PM: PassManagerRef) -> bool;\n+        PM: &PassManager) -> bool;\n \n     // Stuff that's in rustllvm/ because it's not upstream yet.\n \n@@ -1416,7 +1415,7 @@ extern \"C\" {\n \n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n-    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: &'static mut Pass);\n+    pub fn LLVMRustAddPass(PM: &PassManager, Pass: &'static mut Pass);\n \n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n@@ -1437,7 +1436,7 @@ extern \"C\" {\n                                        Singlethread: bool)\n                                        -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n-    pub fn LLVMRustAddAnalysisPasses(T: &TargetMachine, PM: PassManagerRef, M: &Module);\n+    pub fn LLVMRustAddAnalysisPasses(T: &'a TargetMachine, PM: &PassManager<'a>, M: &'a Module);\n     pub fn LLVMRustAddBuilderLibraryInfo(PMB: &'a PassManagerBuilder,\n                                          M: &'a Module,\n                                          DisableSimplifyLibCalls: bool);\n@@ -1449,18 +1448,18 @@ extern \"C\" {\n                                                PrepareForThinLTO: bool,\n                                                PGOGenPath: *const c_char,\n                                                PGOUsePath: *const c_char);\n-    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef,\n-                                  M: &Module,\n+    pub fn LLVMRustAddLibraryInfo(PM: &PassManager<'a>,\n+                                  M: &'a Module,\n                                   DisableSimplifyLibCalls: bool);\n-    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: &Module);\n+    pub fn LLVMRustRunFunctionPassManager(PM: &PassManager<'a>, M: &'a Module);\n     pub fn LLVMRustWriteOutputFile(T: &'a TargetMachine,\n-                                   PM: PassManagerRef,\n+                                   PM: &PassManager<'a>,\n                                    M: &'a Module,\n                                    Output: *const c_char,\n                                    FileType: FileType)\n                                    -> LLVMRustResult;\n-    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                               M: &Module,\n+    pub fn LLVMRustPrintModule(PM: &PassManager<'a>,\n+                               M: &'a Module,\n                                Output: *const c_char,\n                                Demangle: extern fn(*const c_char,\n                                                    size_t,"}]}