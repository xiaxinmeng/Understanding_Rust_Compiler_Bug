{"sha": "28ab8b841a3551c0493c56a5df163e12a03da680", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YWI4Yjg0MWEzNTUxYzA0OTNjNTZhNWRmMTYzZTEyYTAzZGE2ODA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-07T23:42:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: add buffered wrapper to tcp_socket + io::reader impl. no tests, yet.\n\nneed to do some other work, in the subsequent commit, to add io::writer,\nthen tests.", "tree": {"sha": "d0deaf410795cd6bfdc2d336ff9a9f857fe08a9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0deaf410795cd6bfdc2d336ff9a9f857fe08a9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ab8b841a3551c0493c56a5df163e12a03da680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ab8b841a3551c0493c56a5df163e12a03da680", "html_url": "https://github.com/rust-lang/rust/commit/28ab8b841a3551c0493c56a5df163e12a03da680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ab8b841a3551c0493c56a5df163e12a03da680/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ec68ac482ffbd9277b8c9018f9829add4b3dfca", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec68ac482ffbd9277b8c9018f9829add4b3dfca", "html_url": "https://github.com/rust-lang/rust/commit/5ec68ac482ffbd9277b8c9018f9829add4b3dfca"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "692f73467b4bf93acafb52b6dc311b5b6e2dcb8d", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/28ab8b841a3551c0493c56a5df163e12a03da680/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ab8b841a3551c0493c56a5df163e12a03da680/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=28ab8b841a3551c0493c56a5df163e12a03da680", "patch": "@@ -18,6 +18,8 @@ export tcp_socket;\n export tcp_err_data, tcp_connect_err_data;\n // operations on a tcp_socket\n export write, write_future, read_start, read_stop;\n+// buffered socket\n+export socket_buf;\n // tcp server stuff\n export listen, accept;\n // tcp client stuff\n@@ -49,6 +51,16 @@ class tcp_socket {\n   }\n }\n \n+#[doc=\"\n+A buffered wrapper for `net::tcp::tcp_socket`\n+\n+It is created with a call to `net::tcp::socket_buf()` and has impls that\n+satisfy both the `io::reader` and `io::writer` ifaces.\n+\"]\n+resource tcp_socket_buf(data: @tcp_buffered_socket_data) {\n+    log(debug, #fmt(\"dtor for tcp_socket_buf.. %?\", data));\n+}\n+\n #[doc=\"\n Contains raw, string-based, error information returned from libuv\n \"]\n@@ -670,6 +682,25 @@ fn listen_common(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     }\n }\n \n+#[doc=\"\n+Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n+\n+This function takes ownership of a `net::tcp::tcp_socket`, returning it\n+stored within a buffered wrapper, which can be converted to a `io::reader`\n+or `io::writer`\n+\n+# Arguments\n+\n+* `sock` -- a `net::tcp::tcp_socket` that you want to buffer\n+\n+# Returns\n+\n+A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n+\"]\n+fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n+    tcp_socket_buf(@{ sock: sock, mut buf: [] })\n+}\n+\n #[doc=\"\n Convenience methods extending `net::tcp::tcp_socket`\n \"]\n@@ -700,6 +731,74 @@ impl methods_tcp_socket for tcp_socket {\n         write_future(self, raw_write_data)\n     }\n }\n+\n+#[doc=\"\n+Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n+\"]\n+impl tcp_socket_buf of io::reader for tcp_socket_buf {\n+    fn read_bytes(amt: uint) -> [u8] {\n+        let has_amt_available =\n+            vec::len((*self).buf) >= amt;\n+        if has_amt_available {\n+            // no arbitrary-length shift in vec::?\n+            let mut ret_buf = [];\n+            while vec::len(ret_buf) < amt {\n+                ret_buf += [vec::shift((*self).buf)];\n+            }\n+            ret_buf\n+        }\n+        else {\n+            let read_result = read((*self).sock, 0u);\n+            if read_result.is_failure() {\n+                // failure case.. no good answer, yet.\n+                []\n+            }\n+            else {\n+                let new_chunk = result::unwrap(read_result);\n+                (*self).buf += new_chunk;\n+                self.read_bytes(amt)\n+            }\n+        }\n+    }\n+    fn read_byte() -> int {\n+        self.read_bytes(1u)[0] as int\n+    }\n+    fn unread_byte(amt: int) {\n+        vec::unshift((*self).buf, amt as u8);\n+    }\n+    fn eof() -> bool {\n+        false // noop\n+    }\n+    fn seek(dist: int, seek: io::seek_style) {\n+        log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+        // noop\n+    }\n+    fn tell() -> uint {\n+        0u // noop\n+    }\n+}\n+\n+/*\n+#[doc=\"\n+Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n+\"]\n+impl tcp_socket_buf of io::writer for tcp_socket_buf {\n+    fn write(data: [const u8]/&) {\n+        (*self).sock.write(iter::to_vec(data as [u8]/&));\n+    }\n+    fn seek(dist: int, seek: io::seek_style) {\n+      log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+        // noop\n+    }\n+    fn tell() -> uint {\n+        0u\n+    }\n+    fn flush() -> int {\n+        0\n+    }\n+}\n+*/\n+\n // INTERNAL API\n \n fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n@@ -826,6 +925,8 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     }\n }\n \n+// helper to convert a \"class\" vector of [u8] to a *[uv::ll::uv_buf_t]\n+\n // shared implementation used by write and write_future\n fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n                      raw_write_data: [u8]/~)\n@@ -1083,6 +1184,11 @@ type tcp_socket_data = {\n     iotask: iotask\n };\n \n+type tcp_buffered_socket_data = {\n+    sock: tcp_socket,\n+    mut buf: [u8]\n+};\n+\n // convert rust ip_addr to libuv's native representation\n fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n                                port: uint) -> uv::ll::sockaddr_in unsafe {"}]}