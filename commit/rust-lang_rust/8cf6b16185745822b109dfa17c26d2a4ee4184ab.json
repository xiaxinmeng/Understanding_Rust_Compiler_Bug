{"sha": "8cf6b16185745822b109dfa17c26d2a4ee4184ab", "node_id": "C_kwDOAAsO6NoAKDhjZjZiMTYxODU3NDU4MjJiMTA5ZGZhMTdjMjZkMmE0ZWU0MTg0YWI", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-07T18:59:23Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:47:38Z"}, "message": "add coretests for const `align_offset`", "tree": {"sha": "35ed8cc2d44387f2a3c4f5c73ea5d50ebb149adb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35ed8cc2d44387f2a3c4f5c73ea5d50ebb149adb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf6b16185745822b109dfa17c26d2a4ee4184ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6b16185745822b109dfa17c26d2a4ee4184ab", "html_url": "https://github.com/rust-lang/rust/commit/8cf6b16185745822b109dfa17c26d2a4ee4184ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6b16185745822b109dfa17c26d2a4ee4184ab/comments", "author": null, "committer": null, "parents": [{"sha": "211743b2c88e40f43b7e2174bc19920c05b08936", "url": "https://api.github.com/repos/rust-lang/rust/commits/211743b2c88e40f43b7e2174bc19920c05b08936", "html_url": "https://github.com/rust-lang/rust/commit/211743b2c88e40f43b7e2174bc19920c05b08936"}], "stats": {"total": 166, "additions": 166, "deletions": 0}, "files": [{"sha": "7447123253adb4589ac4d5254ffa333f87491548", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6b16185745822b109dfa17c26d2a4ee4184ab/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6b16185745822b109dfa17c26d2a4ee4184ab/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=8cf6b16185745822b109dfa17c26d2a4ee4184ab", "patch": "@@ -4,6 +4,7 @@\n #![feature(array_windows)]\n #![feature(bigint_helper_methods)]\n #![feature(cell_update)]\n+#![feature(const_align_offset)]\n #![feature(const_assume)]\n #![feature(const_align_of_val_raw)]\n #![feature(const_black_box)]"}, {"sha": "186e83d50b6cae2dd950d5ecfee7c5c7049578a0", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/8cf6b16185745822b109dfa17c26d2a4ee4184ab/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf6b16185745822b109dfa17c26d2a4ee4184ab/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=8cf6b16185745822b109dfa17c26d2a4ee4184ab", "patch": "@@ -358,6 +358,23 @@ fn align_offset_zst() {\n     }\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_zst_const() {\n+    const {\n+        // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n+        // all, because no amount of elements will align the pointer.\n+        let mut p = 1;\n+        while p < 1024 {\n+            assert!(ptr::invalid::<()>(p).align_offset(p) == 0);\n+            if p != 1 {\n+                assert!(ptr::invalid::<()>(p + 1).align_offset(p) == !0);\n+            }\n+            p = (p + 1).next_power_of_two();\n+        }\n+    }\n+}\n+\n #[test]\n fn align_offset_stride_one() {\n     // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n@@ -379,6 +396,26 @@ fn align_offset_stride_one() {\n     }\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_stride_one_const() {\n+    const {\n+        // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n+        // number of bytes.\n+        let mut align = 1;\n+        while align < 1024 {\n+            let mut ptr = 1;\n+            while ptr < 2 * align {\n+                let expected = ptr % align;\n+                let offset = if expected == 0 { 0 } else { align - expected };\n+                assert!(ptr::invalid::<u8>(ptr).align_offset(align) == offset);\n+                ptr += 1;\n+            }\n+            align = (align + 1).next_power_of_two();\n+        }\n+    }\n+}\n+\n #[test]\n fn align_offset_various_strides() {\n     unsafe fn test_stride<T>(ptr: *const T, align: usize) -> bool {\n@@ -455,6 +492,134 @@ fn align_offset_various_strides() {\n     assert!(!x);\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_various_strides_const() {\n+    const unsafe fn test_stride<T>(ptr: *const T, numptr: usize, align: usize) {\n+        let mut expected = usize::MAX;\n+        // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n+        let mut el = 0;\n+        while el < align {\n+            if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {\n+                expected = el;\n+                break;\n+            }\n+            el += 1;\n+        }\n+        let got = ptr.align_offset(align);\n+        assert!(got == expected);\n+    }\n+\n+    // For pointers of stride != 1, we verify the algorithm against the naivest possible\n+    // implementation\n+    let mut align = 1;\n+    let limit = 1024;\n+    while align < limit {\n+        for ptr in 1usize..4 * align {\n+            unsafe {\n+                #[repr(packed)]\n+                struct A3(u16, u8);\n+                test_stride::<A3>(ptr::invalid::<A3>(ptr), ptr, align);\n+\n+                struct A4(u32);\n+                test_stride::<A4>(ptr::invalid::<A4>(ptr), ptr, align);\n+\n+                #[repr(packed)]\n+                struct A5(u32, u8);\n+                test_stride::<A5>(ptr::invalid::<A5>(ptr), ptr, align);\n+\n+                #[repr(packed)]\n+                struct A6(u32, u16);\n+                test_stride::<A6>(ptr::invalid::<A6>(ptr), ptr, align);\n+\n+                #[repr(packed)]\n+                struct A7(u32, u16, u8);\n+                test_stride::<A7>(ptr::invalid::<A7>(ptr), ptr, align);\n+\n+                #[repr(packed)]\n+                struct A8(u32, u32);\n+                test_stride::<A8>(ptr::invalid::<A8>(ptr), ptr, align);\n+\n+                #[repr(packed)]\n+                struct A9(u32, u32, u8);\n+                test_stride::<A9>(ptr::invalid::<A9>(ptr), ptr, align);\n+\n+                #[repr(packed)]\n+                struct A10(u32, u32, u16);\n+                test_stride::<A10>(ptr::invalid::<A10>(ptr), ptr, align);\n+\n+                test_stride::<u32>(ptr::invalid::<u32>(ptr), ptr, align);\n+                test_stride::<u128>(ptr::invalid::<u128>(ptr), ptr, align);\n+            }\n+        }\n+        align = (align + 1).next_power_of_two();\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_with_provenance_const() {\n+    const {\n+        let data = 42;\n+\n+        let ptr: *const i32 = &data;\n+        assert!(ptr.align_offset(1) == 0);\n+        assert!(ptr.align_offset(2) == 0);\n+        assert!(ptr.align_offset(4) == 0);\n+        assert!(ptr.align_offset(8) == usize::MAX);\n+        assert!(ptr.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr.wrapping_byte_add(1).align_offset(2) == usize::MAX);\n+        assert!(ptr.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr.wrapping_byte_add(2).align_offset(4) == usize::MAX);\n+        assert!(ptr.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr.wrapping_byte_add(3).align_offset(2) == usize::MAX);\n+\n+        assert!(ptr.wrapping_add(42).align_offset(4) == 0);\n+        assert!(ptr.wrapping_add(42).align_offset(8) == usize::MAX);\n+\n+        let ptr1: *const i8 = ptr.cast();\n+        assert!(ptr1.align_offset(1) == 0);\n+        assert!(ptr1.align_offset(2) == 0);\n+        assert!(ptr1.align_offset(4) == 0);\n+        assert!(ptr1.align_offset(8) == usize::MAX);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(2) == 1);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(4) == 3);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(8) == usize::MAX);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(4) == 2);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(8) == usize::MAX);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(2) == 1);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(4) == 1);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(8) == usize::MAX);\n+\n+        let ptr2: *const i16 = ptr.cast();\n+        assert!(ptr2.align_offset(1) == 0);\n+        assert!(ptr2.align_offset(2) == 0);\n+        assert!(ptr2.align_offset(4) == 0);\n+        assert!(ptr2.align_offset(8) == usize::MAX);\n+        assert!(ptr2.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr2.wrapping_byte_add(1).align_offset(2) == usize::MAX);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(4) == 1);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(8) == usize::MAX);\n+        assert!(ptr2.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr2.wrapping_byte_add(3).align_offset(2) == usize::MAX);\n+\n+        let ptr3: *const i64 = ptr.cast();\n+        assert!(ptr3.align_offset(1) == 0);\n+        assert!(ptr3.align_offset(2) == 0);\n+        assert!(ptr3.align_offset(4) == 0);\n+        assert!(ptr3.align_offset(8) == usize::MAX);\n+        assert!(ptr3.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr3.wrapping_byte_add(1).align_offset(2) == usize::MAX);\n+    }\n+}\n+\n #[test]\n fn align_offset_issue_103361() {\n     #[cfg(target_pointer_width = \"64\")]"}]}