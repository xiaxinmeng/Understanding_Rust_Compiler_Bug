{"sha": "96a3cd06796fe6a486c01ff238dd88104954433b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YTNjZDA2Nzk2ZmU2YTQ4NmMwMWZmMjM4ZGQ4ODEwNDk1NDQzM2I=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-29T14:49:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-05T01:19:32Z"}, "message": "rather than just passing the block around, track the candidate's index,\nand track which arms are reached (though in fact we don't make use of\nthis right now -- we might later if we absorb the checking of patterns\ninto MIR, as I would like)", "tree": {"sha": "03f18fda822d5f5e24bbe48e60259a4d9f555b50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f18fda822d5f5e24bbe48e60259a4d9f555b50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96a3cd06796fe6a486c01ff238dd88104954433b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96a3cd06796fe6a486c01ff238dd88104954433b", "html_url": "https://github.com/rust-lang/rust/commit/96a3cd06796fe6a486c01ff238dd88104954433b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96a3cd06796fe6a486c01ff238dd88104954433b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "html_url": "https://github.com/rust-lang/rust/commit/1f4acfa691a79ab28af497a59f33ccb5cb6934dd"}], "stats": {"total": 50, "additions": 31, "deletions": 19}, "files": [{"sha": "ea415c21cd94bc0b8247d4ef89696ad2495f280b", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/96a3cd06796fe6a486c01ff238dd88104954433b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3cd06796fe6a486c01ff238dd88104954433b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=96a3cd06796fe6a486c01ff238dd88104954433b", "patch": "@@ -34,10 +34,11 @@ impl<H:Hair> Builder<H> {\n         let discriminant_lvalue =\n             unpack!(block = self.as_lvalue(block, discriminant));\n \n-        let arm_blocks: Vec<BasicBlock> =\n-            arms.iter()\n-                .map(|_| self.cfg.start_new_block())\n-                .collect();\n+        let mut arm_blocks = ArmBlocks {\n+            blocks: arms.iter()\n+                        .map(|_| self.cfg.start_new_block())\n+                        .collect(),\n+        };\n \n         let arm_bodies: Vec<ExprRef<H>> =\n             arms.iter()\n@@ -52,34 +53,34 @@ impl<H:Hair> Builder<H> {\n         // source.\n         let candidates: Vec<Candidate<H>> =\n             arms.into_iter()\n-                .zip(arm_blocks.iter())\n+                .enumerate()\n                 .rev() // highest priority comes last\n-                .flat_map(|(arm, &arm_block)| {\n+                .flat_map(|(arm_index, arm)| {\n                     let guard = arm.guard;\n                     arm.patterns.into_iter()\n                                 .rev()\n-                                .map(move |pat| (arm_block, pat, guard.clone()))\n+                                .map(move |pat| (arm_index, pat, guard.clone()))\n                 })\n-                .map(|(arm_block, pattern, guard)| {\n+                .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n                         match_pairs: vec![self.match_pair(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n                         guard: guard,\n-                        arm_block: arm_block,\n+                        arm_index: arm_index,\n                     }\n                 })\n                 .collect();\n \n         // this will generate code to test discriminant_lvalue and\n         // branch to the appropriate arm block\n         let var_extent = self.extent_of_innermost_scope().unwrap();\n-        self.match_candidates(span, var_extent, candidates, block);\n+        self.match_candidates(span, var_extent, &mut arm_blocks, candidates, block);\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n-        for (arm_body, &arm_block) in arm_bodies.into_iter().zip(arm_blocks.iter()) {\n-            let mut arm_block = arm_block;\n+        for (arm_index, arm_body) in arm_bodies.into_iter().enumerate() {\n+            let mut arm_block = arm_blocks.blocks[arm_index];\n             unpack!(arm_block = self.into(destination, arm_block, arm_body));\n             self.cfg.terminate(arm_block, Terminator::Goto { target: end_block });\n         }\n@@ -127,7 +128,7 @@ impl<H:Hair> Builder<H> {\n             match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat)],\n             bindings: vec![],\n             guard: None,\n-            arm_block: block\n+            arm_index: 0, // since we don't call `match_candidates`, this field is unused\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n@@ -180,6 +181,12 @@ impl<H:Hair> Builder<H> {\n     }\n }\n \n+/// List of blocks for each arm (and potentially other metadata in the\n+/// future).\n+struct ArmBlocks {\n+    blocks: Vec<BasicBlock>,\n+}\n+\n #[derive(Clone, Debug)]\n struct Candidate<H:Hair> {\n     // all of these must be satisfied...\n@@ -191,8 +198,8 @@ struct Candidate<H:Hair> {\n     // ...and the guard must be evaluated...\n     guard: Option<ExprRef<H>>,\n \n-    // ...and then we branch here.\n-    arm_block: BasicBlock,\n+    // ...and then we branch to arm with this index.\n+    arm_index: usize,\n }\n \n #[derive(Clone, Debug)]\n@@ -243,6 +250,7 @@ impl<H:Hair> Builder<H> {\n     fn match_candidates(&mut self,\n                         span: H::Span,\n                         var_extent: H::CodeExtent,\n+                        arm_blocks: &mut ArmBlocks,\n                         mut candidates: Vec<Candidate<H>>,\n                         mut block: BasicBlock)\n     {\n@@ -267,7 +275,8 @@ impl<H:Hair> Builder<H> {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n             let candidate = candidates.pop().unwrap();\n-            if let Some(b) = self.bind_and_guard_matched_candidate(block, var_extent, candidate) {\n+            if let Some(b) = self.bind_and_guard_matched_candidate(block, var_extent,\n+                                                                   arm_blocks, candidate) {\n                 block = b;\n             } else {\n                 // if None is returned, then any remaining candidates\n@@ -300,7 +309,7 @@ impl<H:Hair> Builder<H> {\n                                                                       candidate))\n                           })\n                           .collect();\n-            self.match_candidates(span, var_extent, applicable_candidates, target_block);\n+            self.match_candidates(span, var_extent, arm_blocks, applicable_candidates, target_block);\n         }\n     }\n \n@@ -319,6 +328,7 @@ impl<H:Hair> Builder<H> {\n     fn bind_and_guard_matched_candidate(&mut self,\n                                         mut block: BasicBlock,\n                                         var_extent: H::CodeExtent,\n+                                        arm_blocks: &mut ArmBlocks,\n                                         candidate: Candidate<H>)\n                                         -> Option<BasicBlock> {\n         debug!(\"bind_and_guard_matched_candidate(block={:?}, var_extent={:?}, candidate={:?})\",\n@@ -328,16 +338,18 @@ impl<H:Hair> Builder<H> {\n \n         self.bind_matched_candidate(block, var_extent, candidate.bindings);\n \n+        let arm_block = arm_blocks.blocks[candidate.arm_index];\n+\n         if let Some(guard) = candidate.guard {\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n             self.cfg.terminate(block, Terminator::If { cond: cond,\n-                                                       targets: [candidate.arm_block, otherwise]});\n+                                                       targets: [arm_block, otherwise]});\n             Some(otherwise)\n         } else {\n-            self.cfg.terminate(block, Terminator::Goto { target: candidate.arm_block });\n+            self.cfg.terminate(block, Terminator::Goto { target: arm_block });\n             None\n         }\n     }"}]}