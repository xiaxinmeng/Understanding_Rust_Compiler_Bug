{"sha": "3fd6f451417fee0e8d95d06fb298c94b22bca917", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZDZmNDUxNDE3ZmVlMGU4ZDk1ZDA2ZmIyOThjOTRiMjJiY2E5MTc=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-07T18:39:23Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-09-09T22:42:20Z"}, "message": "Properly handle nested submodules in the same file", "tree": {"sha": "3a360dfbd93ea0a6111a7a0ea339da6a462d2a8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a360dfbd93ea0a6111a7a0ea339da6a462d2a8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fd6f451417fee0e8d95d06fb298c94b22bca917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd6f451417fee0e8d95d06fb298c94b22bca917", "html_url": "https://github.com/rust-lang/rust/commit/3fd6f451417fee0e8d95d06fb298c94b22bca917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fd6f451417fee0e8d95d06fb298c94b22bca917/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c14ac7204c38633e70b3efd47a5b1f9056afd0", "html_url": "https://github.com/rust-lang/rust/commit/f9c14ac7204c38633e70b3efd47a5b1f9056afd0"}], "stats": {"total": 149, "additions": 79, "deletions": 70}, "files": [{"sha": "def8b8968dccdf332944e003cca0e23ab8b28dcd", "filename": "crates/ide/src/completion/complete_mod.rs", "status": "modified", "additions": 79, "deletions": 70, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/3fd6f451417fee0e8d95d06fb298c94b22bca917/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fd6f451417fee0e8d95d06fb298c94b22bca917/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_mod.rs?ref=3fd6f451417fee0e8d95d06fb298c94b22bca917", "patch": "@@ -7,87 +7,66 @@ use ide_db::RootDatabase;\n use super::{completion_context::CompletionContext, completion_item::Completions};\n \n /// Complete mod declaration, i.e. `mod <|> ;`\n-pub(super) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) {\n-    let module_names_for_import = ctx\n-        .scope\n-        .module()\n-        .and_then(|current_module| {\n-            let module_path = path_to_closest_containing_module_file(current_module, ctx.db);\n-            // TODO kb filter out declarations in possible_sudmobule_names\n-            // let declaration_source = current_module.declaration_source(ctx.db);\n-            let module_definition_source_file =\n-                current_module.definition_source(ctx.db).file_id.original_file(ctx.db);\n+pub(super) fn complete_mod(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+    let current_module = ctx.scope.module()?;\n \n-            let source_root_id = ctx.db.file_source_root(module_definition_source_file);\n-            let source_root = ctx.db.source_root(source_root_id);\n-            let directory_to_look_for_submodules = source_root\n-                .path_for_file(&module_definition_source_file)\n-                .and_then(|module_file_path| get_directory_with_submodules(module_file_path))?;\n+    // TODO kb filter out declarations in possible_sudmobule_names\n+    // let declaration_source = current_module.declaration_source(ctx.db);\n+    let module_definition_source_file =\n+        current_module.definition_source(ctx.db).file_id.original_file(ctx.db);\n+    let source_root = ctx.db.source_root(ctx.db.file_source_root(module_definition_source_file));\n+    let directory_to_look_for_submodules = directory_to_look_for_submodules(\n+        current_module,\n+        ctx.db,\n+        source_root.path_for_file(&module_definition_source_file)?,\n+    )?;\n \n-            let mod_declaration_candidates = source_root\n-                .iter()\n-                .filter(|submodule_file| submodule_file != &module_definition_source_file)\n-                .filter_map(|submodule_file| {\n-                    let submodule_path = source_root.path_for_file(&submodule_file)?;\n-                    if submodule_path.parent()? == directory_to_look_for_submodules {\n-                        submodule_path.file_name_and_extension()\n+    let mod_declaration_candidates = source_root\n+        .iter()\n+        .filter(|submodule_file| submodule_file != &module_definition_source_file)\n+        .filter_map(|submodule_file| {\n+            let submodule_path = source_root.path_for_file(&submodule_file)?;\n+            if submodule_path.parent()? == directory_to_look_for_submodules {\n+                submodule_path.file_name_and_extension()\n+            } else {\n+                None\n+            }\n+        })\n+        .filter_map(|file_name_and_extension| {\n+            match file_name_and_extension {\n+                // TODO kb in src/bin when a module is included into another,\n+                // the included file gets \"moved\" into a directory below and now cannot add any other modules\n+                (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n+                (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n+                (subdirectory_name, None) => {\n+                    let mod_rs_path =\n+                        directory_to_look_for_submodules.join(subdirectory_name)?.join(\"mod.rs\")?;\n+                    if source_root.file_for_path(&mod_rs_path).is_some() {\n+                        Some(subdirectory_name.to_owned())\n                     } else {\n                         None\n                     }\n-                })\n-                .filter_map(|file_name_and_extension| {\n-                    match file_name_and_extension {\n-                        // TODO kb wrong resolution for nested non-file modules (mod tests { mod <|> })\n-                        // TODO kb in src/bin when a module is included into another,\n-                        // the included file gets \"moved\" into a directory below and now cannot add any other modules\n-                        (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => None,\n-                        (file_name, Some(\"rs\")) => Some(file_name.to_owned()),\n-                        (subdirectory_name, None) => {\n-                            let mod_rs_path = directory_to_look_for_submodules\n-                                .join(subdirectory_name)?\n-                                .join(\"mod.rs\")?;\n-                            if source_root.file_for_path(&mod_rs_path).is_some() {\n-                                Some(subdirectory_name.to_owned())\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-                .collect::<Vec<_>>();\n-            dbg!(mod_declaration_candidates);\n-            // TODO kb exlude existing children from the candidates\n-            let existing_children = current_module.children(ctx.db).collect::<Vec<_>>();\n-            None::<Vec<String>>\n+                }\n+                _ => None,\n+            }\n         })\n-        .unwrap_or_default();\n-}\n+        .collect::<Vec<_>>();\n+    dbg!(mod_declaration_candidates);\n \n-fn path_to_closest_containing_module_file(\n-    current_module: Module,\n-    db: &RootDatabase,\n-) -> Vec<Module> {\n-    let mut path = Vec::new();\n-\n-    let mut current_module = Some(current_module);\n-    while let Some(ModuleSource::Module(_)) =\n-        current_module.map(|module| module.definition_source(db).value)\n-    {\n-        if let Some(module) = current_module {\n-            path.insert(0, module);\n-            current_module = module.parent(db);\n-        } else {\n-            current_module = None;\n-        }\n-    }\n+    // TODO kb exlude existing children from the candidates\n+    let existing_children = current_module.children(ctx.db).collect::<Vec<_>>();\n \n-    path\n+    Some(())\n }\n \n-fn get_directory_with_submodules(module_file_path: &VfsPath) -> Option<VfsPath> {\n+fn directory_to_look_for_submodules(\n+    module: Module,\n+    db: &RootDatabase,\n+    module_file_path: &VfsPath,\n+) -> Option<VfsPath> {\n     let module_directory_path = module_file_path.parent()?;\n-    match module_file_path.file_name_and_extension()? {\n+\n+    let base_directory = match module_file_path.file_name_and_extension()? {\n         (\"mod\", Some(\"rs\")) | (\"lib\", Some(\"rs\")) | (\"main\", Some(\"rs\")) => {\n             Some(module_directory_path)\n         }\n@@ -109,5 +88,35 @@ fn get_directory_with_submodules(module_file_path: &VfsPath) -> Option<VfsPath>\n             }\n         }\n         _ => None,\n+    }?;\n+\n+    let mut resulting_path = base_directory;\n+    for module in module_chain_to_containing_module_file(module, db) {\n+        if let Some(name) = module.name(db) {\n+            resulting_path = resulting_path.join(&name.to_string())?;\n+        }\n+    }\n+\n+    Some(resulting_path)\n+}\n+\n+fn module_chain_to_containing_module_file(\n+    current_module: Module,\n+    db: &RootDatabase,\n+) -> Vec<Module> {\n+    let mut path = Vec::new();\n+\n+    let mut current_module = Some(current_module);\n+    while let Some(ModuleSource::Module(_)) =\n+        current_module.map(|module| module.definition_source(db).value)\n+    {\n+        if let Some(module) = current_module {\n+            path.insert(0, module);\n+            current_module = module.parent(db);\n+        } else {\n+            current_module = None;\n+        }\n     }\n+\n+    path\n }"}]}