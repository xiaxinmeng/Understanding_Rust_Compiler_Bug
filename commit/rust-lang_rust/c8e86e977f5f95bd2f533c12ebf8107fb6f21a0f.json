{"sha": "c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZTg2ZTk3N2Y1Zjk1YmQyZjUzM2MxMmViZjgxMDdmYjZmMjFhMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-30T04:01:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-30T04:01:24Z"}, "message": "auto merge of #16322 : michaelwoerister/rust/gdb-pretty, r=alexcrichton\n\nAlso extends the autotest framework to let a test case choose if pretty printing should be enabled.", "tree": {"sha": "12e10399d982fca7a5633917f55bc0a2da3c899c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12e10399d982fca7a5633917f55bc0a2da3c899c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "html_url": "https://github.com/rust-lang/rust/commit/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5419b2ca2c27b4745fa1f2773719350420542c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/5419b2ca2c27b4745fa1f2773719350420542c76", "html_url": "https://github.com/rust-lang/rust/commit/5419b2ca2c27b4745fa1f2773719350420542c76"}, {"sha": "e72e4dfc74ca65d6b3e0d821b94a34764ab2c63d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72e4dfc74ca65d6b3e0d821b94a34764ab2c63d", "html_url": "https://github.com/rust-lang/rust/commit/e72e4dfc74ca65d6b3e0d821b94a34764ab2c63d"}], "stats": {"total": 727, "additions": 697, "deletions": 30}, "files": [{"sha": "1d6c387caa7c669811a7fa936bd4dd3b2840728d", "filename": "configure", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/configure", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -515,6 +515,13 @@ probe CFG_LUALATEX         lualatex\n probe CFG_GDB              gdb\n probe CFG_LLDB             lldb\n \n+if [ ! -z \"$CFG_GDB\" ]\n+then\n+    # Extract the version\n+    CFG_GDB_VERSION=$($CFG_GDB --version 2>/dev/null | head -1)\n+    putvar CFG_GDB_VERSION\n+fi\n+\n if [ ! -z \"$CFG_LLDB\" ]\n then\n     # If CFG_LLDB_PYTHON_DIR is not already set from the outside and valid, try to read it from"}, {"sha": "d95f886e078896cb4649f3905883310401bcbe62", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -623,6 +623,7 @@ CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) := \\\n         --stage-id stage$(1)-$(2) \\\n         --target $(2) \\\n         --host $(3) \\\n+        --gdb-version=\"$(CFG_GDB_VERSION)\" \\\n         --android-cross-path=$(CFG_ANDROID_CROSS_PATH) \\\n         --adb-path=$(CFG_ADB) \\\n         --adb-test-dir=$(CFG_ADB_TEST_DIR) \\"}, {"sha": "afe2d071461a0317356c811f443b8f803e5bb8a8", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -130,6 +130,9 @@ pub struct Config {\n     // Host triple for the compiler being invoked\n     pub host: String,\n \n+    // Version of GDB\n+    pub gdb_version: Option<String>,\n+\n     // Path to the android tools\n     pub android_cross_path: Path,\n "}, {"sha": "6c6cd6f610f5be970f07e4f7faa8c58c6df52b5f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -81,6 +81,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optflag(\"\", \"jit\", \"run tests under the JIT\"),\n           optopt(\"\", \"target\", \"the target to build for\", \"TARGET\"),\n           optopt(\"\", \"host\", \"the host to build for\", \"HOST\"),\n+          optopt(\"\", \"gdb-version\", \"the version of GDB used\", \"MAJOR.MINOR\"),\n           optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\"),\n           optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\"),\n           optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\"),\n@@ -157,6 +158,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         jit: matches.opt_present(\"jit\"),\n         target: opt_str2(matches.opt_str(\"target\")),\n         host: opt_str2(matches.opt_str(\"host\")),\n+        gdb_version: extract_gdb_version(matches.opt_str(\"gdb-version\")),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n@@ -376,3 +378,26 @@ pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::Test\n         runtest::run_metrics(config, testfile, mm)\n     })\n }\n+\n+fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n+    match full_version_line {\n+        Some(ref full_version_line)\n+          if full_version_line.as_slice().trim().len() > 0 => {\n+            let full_version_line = full_version_line.as_slice().trim();\n+\n+            let re = Regex::new(r\"(^|[^0-9])([0-9]\\.[0-9])([^0-9]|$)\").unwrap();\n+\n+            match re.captures(full_version_line) {\n+                Some(captures) => {\n+                    Some(captures.at(2).to_string())\n+                }\n+                None => {\n+                    println!(\"Could not extract GDB version from line '{}'\",\n+                             full_version_line);\n+                    None\n+                }\n+            }\n+        },\n+        _ => None\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9ad2582dec8456d60c6d52d4aaf2534a6f6f1e8e", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -12,6 +12,8 @@ use common::Config;\n use common;\n use util;\n \n+use std::from_str::FromStr;\n+\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     pub error_patterns: Vec<String> ,\n@@ -142,23 +144,42 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n         format!(\"ignore-{}\",\n                 config.stage_id.as_slice().split('-').next().unwrap())\n     }\n+    fn ignore_gdb(config: &Config, line: &str) -> bool {\n+        if config.mode != common::DebugInfoGdb {\n+            return false;\n+        }\n \n-    let val = iter_header(testfile, |ln| {\n-        if parse_name_directive(ln, \"ignore-test\") {\n-            false\n-        } else if parse_name_directive(ln, ignore_target(config).as_slice()) {\n-            false\n-        } else if parse_name_directive(ln, ignore_stage(config).as_slice()) {\n-            false\n-        } else if config.mode == common::Pretty &&\n-                parse_name_directive(ln, \"ignore-pretty\") {\n-            false\n-        } else if config.target != config.host &&\n-                parse_name_directive(ln, \"ignore-cross-compile\") {\n-            false\n-        } else {\n-            true\n+        if parse_name_directive(line, \"ignore-gdb\") {\n+            return true;\n         }\n+\n+        match config.gdb_version {\n+            Some(ref actual_version) => {\n+                if line.contains(\"min-gdb-version\") {\n+                    let min_version = line.trim()\n+                                          .split(' ')\n+                                          .last()\n+                                          .expect(\"Malformed GDB version directive\");\n+                    // Ignore if actual version is smaller the minimum required\n+                    // version\n+                    gdb_version_to_int(actual_version.as_slice()) <\n+                        gdb_version_to_int(min_version.as_slice())\n+                } else {\n+                    false\n+                }\n+            }\n+            None => false\n+        }\n+    }\n+\n+    let val = iter_header(testfile, |ln| {\n+        !parse_name_directive(ln, \"ignore-test\") &&\n+        !parse_name_directive(ln, ignore_target(config).as_slice()) &&\n+        !parse_name_directive(ln, ignore_stage(config).as_slice()) &&\n+        !(config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) &&\n+        !(config.target != config.host && parse_name_directive(ln, \"ignore-cross-compile\")) &&\n+        !ignore_gdb(config, ln) &&\n+        !(config.mode == common::DebugInfoLldb && parse_name_directive(ln, \"ignore-lldb\"))\n     });\n \n     !val\n@@ -278,3 +299,21 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n         None => None\n     }\n }\n+\n+pub fn gdb_version_to_int(version_string: &str) -> int {\n+    let error_string = format!(\n+        \"Encountered GDB version string with unexpected format: {}\",\n+        version_string);\n+    let error_string = error_string.as_slice();\n+\n+    let components: Vec<&str> = version_string.trim().split('.').collect();\n+\n+    if components.len() != 2 {\n+        fail!(\"{}\", error_string);\n+    }\n+\n+    let major: int = FromStr::from_str(components[0]).expect(error_string);\n+    let minor: int = FromStr::from_str(components[1]).expect(error_string);\n+\n+    return major * 1000 + minor;\n+}"}, {"sha": "ee787a5f0a9bf223e62ea6bb2e3c0d838369b07a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 101, "deletions": 13, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -323,7 +323,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     };\n \n     let config = &mut config;\n-    let DebuggerCommands { commands, check_lines, .. } = parse_debugger_commands(testfile, \"gdb\");\n+    let DebuggerCommands {\n+        commands,\n+        check_lines,\n+        use_gdb_pretty_printer,\n+        ..\n+    } = parse_debugger_commands(testfile, \"gdb\");\n     let mut cmds = commands.connect(\"\\n\");\n \n     // compile test file (it should have 'compile-flags:-g' in the header)\n@@ -334,7 +339,6 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let exe_file = make_exe_name(config, testfile);\n \n-    let mut proc_args;\n     let debugger_run_result;\n     match config.target.as_slice() {\n         \"arm-linux-androideabi\" => {\n@@ -454,18 +458,65 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n         }\n \n         _=> {\n+            let rust_src_root = find_rust_src_root(config)\n+                .expect(\"Could not find Rust source root\");\n+            let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n+            let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n+                                                       .as_str()\n+                                                       .unwrap()\n+                                                       .to_string();\n             // write debugger script\n-            let script_str = [\n-                \"set charset UTF-8\".to_string(),\n-                cmds,\n-                \"quit\\n\".to_string()\n-            ].connect(\"\\n\");\n+            let mut script_str = String::with_capacity(2048);\n+\n+            script_str.push_str(\"set charset UTF-8\\n\");\n+            script_str.push_str(\"show version\\n\");\n+\n+            match config.gdb_version {\n+                Some(ref version) => {\n+                    println!(\"NOTE: compiletest thinks it is using GDB version {}\",\n+                             version.as_slice());\n+\n+                    if header::gdb_version_to_int(version.as_slice()) >\n+                        header::gdb_version_to_int(\"7.4\") {\n+                        // Add the directory containing the pretty printers to\n+                        // GDB's script auto loading safe path ...\n+                        script_str.push_str(\n+                            format!(\"add-auto-load-safe-path {}\\n\",\n+                                    rust_pp_module_abs_path.as_slice())\n+                                .as_slice());\n+                        // ... and also the test directory\n+                        script_str.push_str(\n+                            format!(\"add-auto-load-safe-path {}\\n\",\n+                                    config.build_base.as_str().unwrap())\n+                                .as_slice());\n+                    }\n+                }\n+                _ => {\n+                    println!(\"NOTE: compiletest does not know which version of \\\n+                              GDB it is using\");\n+                }\n+            }\n+\n+            // Load the target executable\n+            script_str.push_str(format!(\"file {}\\n\",\n+                                        exe_file.as_str().unwrap())\n+                                    .as_slice());\n+\n+            script_str.push_str(cmds.as_slice());\n+            script_str.push_str(\"quit\\n\");\n+\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config,\n                              testfile,\n                              script_str.as_slice(),\n                              \"debugger.script\");\n \n+            if use_gdb_pretty_printer {\n+                // Only emit the gdb auto-loading script if pretty printers\n+                // should actually be loaded\n+                dump_gdb_autoload_script(config, testfile);\n+            }\n+\n             // run debugger script with gdb\n             #[cfg(windows)]\n             fn debugger() -> String {\n@@ -483,16 +534,19 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 vec!(\"-quiet\".to_string(),\n                      \"-batch\".to_string(),\n                      \"-nx\".to_string(),\n-                     format!(\"-command={}\", debugger_script.as_str().unwrap()),\n-                     exe_file.as_str().unwrap().to_string());\n-            proc_args = ProcArgs {\n+                     format!(\"-command={}\", debugger_script.as_str().unwrap()));\n+\n+            let proc_args = ProcArgs {\n                 prog: debugger(),\n                 args: debugger_opts,\n             };\n+\n+            let environment = vec![(\"PYTHONPATH\".to_string(), rust_pp_module_abs_path)];\n+\n             debugger_run_result = compose_and_run(config,\n                                                   testfile,\n                                                   proc_args,\n-                                                  Vec::new(),\n+                                                  environment,\n                                                   config.run_lib_path.as_slice(),\n                                                   None,\n                                                   None);\n@@ -504,6 +558,32 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n+\n+    fn dump_gdb_autoload_script(config: &Config, testfile: &Path) {\n+        let mut script_path = output_base_name(config, testfile);\n+        let mut script_file_name = script_path.filename().unwrap().to_vec();\n+        script_file_name.push_all(\"-gdb.py\".as_bytes());\n+        script_path.set_filename(script_file_name.as_slice());\n+\n+        let script_content = \"import gdb_rust_pretty_printing\\n\\\n+                              gdb_rust_pretty_printing.register_printers(gdb.current_objfile())\\n\"\n+                             .as_bytes();\n+\n+        File::create(&script_path).write(script_content).unwrap();\n+    }\n+}\n+\n+fn find_rust_src_root(config: &Config) -> Option<Path> {\n+    let mut path = config.src_base.clone();\n+    let path_postfix = Path::new(\"src/etc/lldb_batchmode.py\");\n+\n+    while path.pop() {\n+        if path.join(path_postfix.clone()).is_file() {\n+            return Some(path);\n+        }\n+    }\n+\n+    return None;\n }\n \n fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path) {\n@@ -533,7 +613,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let DebuggerCommands {\n         commands,\n         check_lines,\n-        breakpoint_lines\n+        breakpoint_lines,\n+        ..\n     } = parse_debugger_commands(testfile, \"lldb\");\n \n     // Write debugger script:\n@@ -619,6 +700,7 @@ struct DebuggerCommands {\n     commands: Vec<String>,\n     check_lines: Vec<String>,\n     breakpoint_lines: Vec<uint>,\n+    use_gdb_pretty_printer: bool\n }\n \n fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n@@ -631,6 +713,7 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n     let mut breakpoint_lines = vec!();\n     let mut commands = vec!();\n     let mut check_lines = vec!();\n+    let mut use_gdb_pretty_printer = false;\n     let mut counter = 1;\n     let mut reader = BufferedReader::new(File::open(file_path).unwrap());\n     for line in reader.lines() {\n@@ -640,6 +723,10 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n                     breakpoint_lines.push(counter);\n                 }\n \n+                if line.as_slice().contains(\"gdb-use-pretty-printer\") {\n+                    use_gdb_pretty_printer = true;\n+                }\n+\n                 header::parse_name_value_directive(\n                         line.as_slice(),\n                         command_directive.as_slice()).map(|cmd| {\n@@ -663,7 +750,8 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n     DebuggerCommands {\n         commands: commands,\n         check_lines: check_lines,\n-        breakpoint_lines: breakpoint_lines\n+        breakpoint_lines: breakpoint_lines,\n+        use_gdb_pretty_printer: use_gdb_pretty_printer,\n     }\n }\n "}, {"sha": "e8a6427c1d7317cb6590835cc1e2347e1a7d7f1c", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -0,0 +1,231 @@\n+# Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import gdb\n+\n+#===============================================================================\n+# GDB Pretty Printing Module for Rust\n+#===============================================================================\n+\n+def register_printers(objfile):\n+  \"Registers Rust pretty printers for the given objfile\"\n+  objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+\n+def rust_pretty_printer_lookup_function(val):\n+  \"Returns the correct Rust pretty printer for the given value if there is one\"\n+  type_code = val.type.code\n+\n+  if type_code == gdb.TYPE_CODE_STRUCT:\n+    struct_kind = classify_struct(val.type)\n+\n+    if struct_kind == STRUCT_KIND_STR_SLICE:\n+      return RustStringSlicePrinter(val)\n+\n+    if struct_kind == STRUCT_KIND_TUPLE:\n+      return RustTuplePrinter(val)\n+\n+    if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n+      return RustTupleStructPrinter(val, False)\n+\n+    if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n+      return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n+\n+    if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n+      return RustTupleStructPrinter(val, True)\n+\n+    if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n+      return RustStructPrinter(val, True)\n+\n+    return RustStructPrinter(val, False)\n+\n+  # Enum handling\n+  if type_code == gdb.TYPE_CODE_UNION:\n+    enum_members = list(val.type.fields())\n+    enum_member_count = len(enum_members)\n+\n+    if enum_member_count == 0:\n+      return RustStructPrinter(val, false)\n+\n+    if enum_member_count == 1:\n+      if enum_members[0].name == None:\n+        # This is a singleton enum\n+        return rust_pretty_printer_lookup_function(val[enum_members[0]])\n+      else:\n+        assert enum_members[0].name.startswith(\"RUST$ENCODED$ENUM$\")\n+        # This is a space-optimized enum\n+        last_separator_index = enum_members[0].name.rfind(\"$\")\n+        second_last_separator_index = first_variant_name.rfind(\"$\", 0, last_separator_index)\n+        disr_field_index = first_variant_name[second_last_separator_index + 1 :\n+                                              last_separator_index]\n+        disr_field_index = int(disr_field_index)\n+\n+        sole_variant_val = val[enum_members[0]]\n+        disr_field = get_field_at_index(sole_variant_val, disr_field_index)\n+        discriminant = int(sole_variant_val[disr_field])\n+\n+        if discriminant == 0:\n+          null_variant_name = first_variant_name[last_separator_index + 1:]\n+          return IdentityPrinter(null_variant_name)\n+\n+        return rust_pretty_printer_lookup_function(sole_variant_val)\n+\n+    # This is a regular enum, extract the discriminant\n+    discriminant_name, discriminant_val = extract_discriminant_value(val)\n+    return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n+\n+  # No pretty printer has been found\n+  return None\n+\n+#=------------------------------------------------------------------------------\n+# Pretty Printer Classes\n+#=------------------------------------------------------------------------------\n+\n+class RustStructPrinter:\n+  def __init__(self, val, hide_first_field):\n+    self.val = val\n+    self.hide_first_field = hide_first_field\n+\n+  def to_string(self):\n+    return self.val.type.tag\n+\n+  def children(self):\n+    cs = []\n+    for field in self.val.type.fields():\n+      field_name = field.name\n+      # Normally the field name is used as a key to access the field value,\n+      # because that's also supported in older versions of GDB...\n+      field_key = field_name\n+      if field_name == None:\n+        field_name = \"\"\n+        # ... but for fields without a name (as in tuples), we have to fall back\n+        # to the newer method of using the field object directly as key. In\n+        # older versions of GDB, this will just fail.\n+        field_key = field\n+      name_value_tuple = ( field_name, self.val[field_key] )\n+      cs.append( name_value_tuple )\n+\n+    if self.hide_first_field:\n+      cs = cs[1:]\n+\n+    return cs\n+\n+class RustTuplePrinter:\n+  def __init__(self, val):\n+    self.val = val\n+\n+  def to_string(self):\n+    return None\n+\n+  def children(self):\n+    cs = []\n+    for field in self.val.type.fields():\n+      cs.append( (\"\", self.val[field]) )\n+\n+    return cs\n+\n+  def display_hint(self):\n+    return \"array\"\n+\n+class RustTupleStructPrinter:\n+  def __init__(self, val, hide_first_field):\n+    self.val = val\n+    self.hide_first_field = hide_first_field\n+\n+  def to_string(self):\n+    return self.val.type.tag\n+\n+  def children(self):\n+    cs = []\n+    for field in self.val.type.fields():\n+      cs.append( (\"\", self.val[field]) )\n+\n+    if self.hide_first_field:\n+      cs = cs[1:]\n+\n+    return cs\n+\n+  def display_hint(self):\n+    return \"array\"\n+\n+class RustStringSlicePrinter:\n+  def __init__(self, val):\n+    self.val = val\n+\n+  def to_string(self):\n+    slice_byte_len = self.val[\"length\"]\n+    return '\"%s\"' % self.val[\"data_ptr\"].string(encoding = \"utf-8\",\n+                                                length = slice_byte_len)\n+\n+class RustCStyleEnumPrinter:\n+  def __init__(self, val):\n+    assert val.type.code == gdb.TYPE_CODE_ENUM\n+    self.val = val\n+\n+  def to_string(self):\n+    return str(self.val)\n+\n+class IdentityPrinter:\n+  def __init__(self, string):\n+    self.string\n+\n+  def to_string(self):\n+    return self.string\n+\n+STRUCT_KIND_REGULAR_STRUCT  = 0\n+STRUCT_KIND_TUPLE_STRUCT    = 1\n+STRUCT_KIND_TUPLE           = 2\n+STRUCT_KIND_TUPLE_VARIANT   = 3\n+STRUCT_KIND_STRUCT_VARIANT  = 4\n+STRUCT_KIND_CSTYLE_VARIANT  = 5\n+STRUCT_KIND_STR_SLICE       = 6\n+\n+def classify_struct(type):\n+  if type.tag == \"&str\":\n+    return STRUCT_KIND_STR_SLICE\n+\n+  fields = list(type.fields())\n+  field_count = len(fields)\n+\n+  if field_count == 0:\n+    return STRUCT_KIND_REGULAR_STRUCT\n+\n+  if fields[0].artificial:\n+    if field_count == 1:\n+      return STRUCT_KIND_CSTYLE_VARIANT\n+    elif fields[1].name == None:\n+      return STRUCT_KIND_TUPLE_VARIANT\n+    else:\n+      return STRUCT_KIND_STRUCT_VARIANT\n+\n+  if fields[0].name == None:\n+    if type.tag.startswith(\"(\"):\n+      return STRUCT_KIND_TUPLE\n+    else:\n+      return STRUCT_KIND_TUPLE_STRUCT\n+\n+  return STRUCT_KIND_REGULAR_STRUCT\n+\n+def extract_discriminant_value(enum_val):\n+  assert enum_val.type.code == gdb.TYPE_CODE_UNION\n+  for variant_descriptor in enum_val.type.fields():\n+    variant_val = enum_val[variant_descriptor]\n+    for field in variant_val.type.fields():\n+      return (field.name, int(variant_val[field]))\n+\n+def first_field(val):\n+  for field in val.type.fields():\n+    return field\n+\n+def get_field_at_index(val, index):\n+  i = 0\n+  for field in val.type.fields():\n+    if i == index:\n+      return field\n+  return None"}, {"sha": "222cd92742f44670a9a02359c7a66b28c53947d7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -235,6 +235,9 @@ static UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n static UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n static UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n+static FLAGS_NONE: c_uint = 0;\n+static FLAGS_ARTIFICAL: c_uint = llvm::debuginfo::FlagArtificial as c_uint;\n+\n //=-----------------------------------------------------------------------------\n //  Public Interface of debuginfo module\n //=-----------------------------------------------------------------------------\n@@ -1732,6 +1735,7 @@ struct MemberDescription {\n     llvm_type: Type,\n     type_metadata: DIType,\n     offset: MemberOffset,\n+    flags: c_uint\n }\n \n // A factory for MemberDescriptions. It produces a list of member descriptions\n@@ -1890,6 +1894,7 @@ impl StructMemberDescriptionFactory {\n                 llvm_type: type_of::type_of(cx, field.mt.ty),\n                 type_metadata: type_metadata(cx, field.mt.ty, self.span),\n                 offset: offset,\n+                flags: FLAGS_NONE,\n             }\n         }).collect()\n     }\n@@ -1950,6 +1955,7 @@ impl TupleMemberDescriptionFactory {\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n+                flags: FLAGS_NONE,\n             }\n         }).collect()\n     }\n@@ -2035,6 +2041,7 @@ impl EnumMemberDescriptionFactory {\n                             llvm_type: variant_llvm_type,\n                             type_metadata: variant_type_metadata,\n                             offset: FixedMemberOffset { bytes: 0 },\n+                            flags: FLAGS_NONE\n                         }\n                     }).collect()\n             },\n@@ -2068,6 +2075,7 @@ impl EnumMemberDescriptionFactory {\n                             llvm_type: variant_llvm_type,\n                             type_metadata: variant_type_metadata,\n                             offset: FixedMemberOffset { bytes: 0 },\n+                            flags: FLAGS_NONE\n                         }\n                     ]\n                 }\n@@ -2101,6 +2109,7 @@ impl EnumMemberDescriptionFactory {\n                     llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n+                    flags: FLAGS_NONE\n                 };\n \n                 let unique_type_id = debug_context(cx).type_map\n@@ -2138,6 +2147,7 @@ impl EnumMemberDescriptionFactory {\n                         llvm_type: artificial_struct_llvm_type,\n                         type_metadata: artificial_struct_metadata,\n                         offset: FixedMemberOffset { bytes: 0 },\n+                        flags: FLAGS_NONE\n                     }\n                 ]\n             },\n@@ -2182,6 +2192,7 @@ impl EnumMemberDescriptionFactory {\n                         llvm_type: variant_llvm_type,\n                         type_metadata: variant_type_metadata,\n                         offset: FixedMemberOffset { bytes: 0 },\n+                        flags: FLAGS_NONE\n                     }\n                 ]\n             },\n@@ -2208,6 +2219,11 @@ impl VariantMemberDescriptionFactory {\n                     _ => type_metadata(cx, ty, self.span)\n                 },\n                 offset: ComputedMemberOffset,\n+                flags: if self.discriminant_type_metadata.is_some() &&  i == 0 {\n+                    FLAGS_ARTIFICAL\n+                } else {\n+                    FLAGS_NONE\n+                }\n             }\n         }).collect()\n     }\n@@ -2523,7 +2539,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                         bytes_to_bits(member_size),\n                         bytes_to_bits(member_align),\n                         bytes_to_bits(member_offset),\n-                        0,\n+                        member_description.flags,\n                         member_description.type_metadata)\n                 }\n             })\n@@ -2610,30 +2626,35 @@ fn at_box_metadata(cx: &CrateContext,\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL,\n         },\n         MemberDescription {\n             name: \"drop_glue\".to_string(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL,\n         },\n         MemberDescription {\n             name: \"prev\".to_string(),\n             llvm_type: *member_llvm_types.get(2),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL,\n         },\n         MemberDescription {\n             name: \"next\".to_string(),\n             llvm_type: *member_llvm_types.get(3),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL,\n         },\n         MemberDescription {\n             name: \"val\".to_string(),\n             llvm_type: *member_llvm_types.get(4),\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL,\n         }\n     ];\n \n@@ -2734,12 +2755,14 @@ fn vec_slice_metadata(cx: &CrateContext,\n             llvm_type: *member_llvm_types.get(0),\n             type_metadata: element_type_metadata,\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n             llvm_type: *member_llvm_types.get(1),\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n+            flags: FLAGS_ARTIFICAL\n         },\n     ];\n "}, {"sha": "12d10ec66302ab9cc706a240dbdce3ffb70c4f51", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -428,7 +428,10 @@ pub mod debuginfo {\n       FlagObjcClassComplete  = 1 << 9,\n       FlagObjectPointer      = 1 << 10,\n       FlagVector             = 1 << 11,\n-      FlagStaticMember       = 1 << 12\n+      FlagStaticMember       = 1 << 12,\n+      FlagIndirectVariable   = 1 << 13,\n+      FlagLValueReference    = 1 << 14,\n+      FlagRValueReference    = 1 << 15\n     }\n }\n "}, {"sha": "e9daf31be2cd2515be84fc1dc5a655d45bbe3d02", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test uses only GDB Python API features which should be available in\n+// older versions of GDB too. A more extensive test can be found in\n+// gdb-pretty-struct-and-enums.rs\n+\n+// ignore-tidy-linelength\n+// ignore-lldb\n+// ignore-android: FIXME(#10381)\n+// compile-flags:-g\n+// gdb-use-pretty-printer\n+\n+// The following line actually doesn't have to do anything with pretty printing,\n+// it just tells GDB to print values on one line:\n+// gdb-command: set print pretty off\n+\n+// gdb-command: rbreak zzz\n+// gdb-command: run\n+// gdb-command: finish\n+\n+// gdb-command: print regular_struct\n+// gdb-check:$1 = RegularStruct = {the_first_field = 101, the_second_field = 102.5, the_third_field = false}\n+\n+// gdb-command: print empty_struct\n+// gdb-check:$2 = EmptyStruct\n+\n+// gdb-command: print c_style_enum1\n+// gdb-check:$3 = CStyleEnumVar1\n+\n+// gdb-command: print c_style_enum2\n+// gdb-check:$4 = CStyleEnumVar2\n+\n+// gdb-command: print c_style_enum3\n+// gdb-check:$5 = CStyleEnumVar3\n+\n+struct RegularStruct {\n+    the_first_field: int,\n+    the_second_field: f64,\n+    the_third_field: bool,\n+}\n+\n+struct EmptyStruct;\n+\n+enum CStyleEnum {\n+    CStyleEnumVar1,\n+    CStyleEnumVar2,\n+    CStyleEnumVar3,\n+}\n+\n+fn main() {\n+\n+    let regular_struct = RegularStruct {\n+        the_first_field: 101,\n+        the_second_field: 102.5,\n+        the_third_field: false\n+    };\n+\n+    let empty_struct = EmptyStruct;\n+\n+    let c_style_enum1 = CStyleEnumVar1;\n+    let c_style_enum2 = CStyleEnumVar2;\n+    let c_style_enum3 = CStyleEnumVar3;\n+\n+    zzz();\n+}\n+\n+fn zzz() { () }"}, {"sha": "5ef63da71af8cf2ce2a894466824d6d1835d6132", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs?ref=c8e86e977f5f95bd2f533c12ebf8107fb6f21a0f", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// ignore-lldb\n+// ignore-android: FIXME(#10381)\n+// compile-flags:-g\n+// gdb-use-pretty-printer\n+\n+// This test uses some GDB Python API features (e.g. accessing anonymous fields)\n+// which are only available in newer GDB version. The following directive will\n+// case the test runner to ignore this test if an older GDB version is used:\n+// min-gdb-version 7.7\n+\n+// The following line actually doesn't have to do anything with pretty printing,\n+// it just tells GDB to print values on one line:\n+// gdb-command: set print pretty off\n+\n+// gdb-command: rbreak zzz\n+// gdb-command: run\n+// gdb-command: finish\n+\n+// gdb-command: print regular_struct\n+// gdb-check:$1 = RegularStruct = {the_first_field = 101, the_second_field = 102.5, the_third_field = false, the_fourth_field = \"I'm so pretty, oh so pretty...\"}\n+\n+// gdb-command: print tuple\n+// gdb-check:$2 = {true, 103, \"blub\"}\n+\n+// gdb-command: print tuple_struct\n+// gdb-check:$3 = TupleStruct = {-104.5, 105}\n+\n+// gdb-command: print empty_struct\n+// gdb-check:$4 = EmptyStruct\n+\n+// gdb-command: print c_style_enum1\n+// gdb-check:$5 = CStyleEnumVar1\n+\n+// gdb-command: print c_style_enum2\n+// gdb-check:$6 = CStyleEnumVar2\n+\n+// gdb-command: print c_style_enum3\n+// gdb-check:$7 = CStyleEnumVar3\n+\n+// gdb-command: print mixed_enum_c_style_var\n+// gdb-check:$8 = MixedEnumCStyleVar\n+\n+// gdb-command: print mixed_enum_tuple_var\n+// gdb-check:$9 = MixedEnumTupleVar = {106, 107, false}\n+\n+// gdb-command: print mixed_enum_struct_var\n+// gdb-check:$10 = MixedEnumStructVar = {field1 = 108.5, field2 = 109}\n+\n+// gdb-command: print some\n+// gdb-check:$11 = Some = {110}\n+\n+// gdb-command: print none\n+// gdb-check:$12 = None\n+\n+// gdb-command: print nested_variant1\n+// gdb-check:$13 = NestedVariant1 = {NestedStruct = {regular_struct = RegularStruct = {the_first_field = 111, the_second_field = 112.5, the_third_field = true, the_fourth_field = \"NestedStructString1\"}, tuple_struct = TupleStruct = {113.5, 114}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar2, mixed_enum = MixedEnumTupleVar = {115, 116, false}}}\n+\n+// gdb-command: print nested_variant2\n+// gdb-check:$14 = NestedVariant2 = {abc = NestedStruct = {regular_struct = RegularStruct = {the_first_field = 117, the_second_field = 118.5, the_third_field = false, the_fourth_field = \"NestedStructString10\"}, tuple_struct = TupleStruct = {119.5, 120}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar3, mixed_enum = MixedEnumStructVar = {field1 = 121.5, field2 = -122}}}\n+\n+#![feature(struct_variant)]\n+\n+struct RegularStruct {\n+    the_first_field: int,\n+    the_second_field: f64,\n+    the_third_field: bool,\n+    the_fourth_field: &'static str,\n+}\n+\n+struct TupleStruct(f64, i16);\n+\n+struct EmptyStruct;\n+\n+enum CStyleEnum {\n+    CStyleEnumVar1,\n+    CStyleEnumVar2,\n+    CStyleEnumVar3,\n+}\n+\n+enum MixedEnum {\n+    MixedEnumCStyleVar,\n+    MixedEnumTupleVar(u32, u16, bool),\n+    MixedEnumStructVar { field1: f64, field2: i32 }\n+}\n+\n+struct NestedStruct {\n+    regular_struct: RegularStruct,\n+    tuple_struct: TupleStruct,\n+    empty_struct: EmptyStruct,\n+    c_style_enum: CStyleEnum,\n+    mixed_enum: MixedEnum,\n+}\n+\n+enum NestedEnum {\n+    NestedVariant1(NestedStruct),\n+    NestedVariant2 { abc: NestedStruct }\n+}\n+\n+fn main() {\n+\n+    let regular_struct = RegularStruct {\n+        the_first_field: 101,\n+        the_second_field: 102.5,\n+        the_third_field: false,\n+        the_fourth_field: \"I'm so pretty, oh so pretty...\"\n+    };\n+\n+    let tuple = ( true, 103u32, \"blub\" );\n+\n+    let tuple_struct = TupleStruct(-104.5, 105);\n+\n+    let empty_struct = EmptyStruct;\n+\n+    let c_style_enum1 = CStyleEnumVar1;\n+    let c_style_enum2 = CStyleEnumVar2;\n+    let c_style_enum3 = CStyleEnumVar3;\n+\n+    let mixed_enum_c_style_var = MixedEnumCStyleVar;\n+    let mixed_enum_tuple_var = MixedEnumTupleVar(106, 107, false);\n+    let mixed_enum_struct_var = MixedEnumStructVar { field1: 108.5, field2: 109 };\n+\n+    let some = Some(110u);\n+    let none: Option<int> = None;\n+\n+    let nested_variant1 = NestedVariant1(\n+        NestedStruct {\n+            regular_struct: RegularStruct {\n+                the_first_field: 111,\n+                the_second_field: 112.5,\n+                the_third_field: true,\n+                the_fourth_field: \"NestedStructString1\",\n+            },\n+            tuple_struct: TupleStruct(113.5, 114),\n+            empty_struct: EmptyStruct,\n+            c_style_enum: CStyleEnumVar2,\n+            mixed_enum: MixedEnumTupleVar(115, 116, false)\n+        }\n+    );\n+\n+    let nested_variant2 = NestedVariant2 {\n+        abc: NestedStruct {\n+            regular_struct: RegularStruct {\n+                the_first_field: 117,\n+                the_second_field: 118.5,\n+                the_third_field: false,\n+                the_fourth_field: \"NestedStructString10\",\n+            },\n+            tuple_struct: TupleStruct(119.5, 120),\n+            empty_struct: EmptyStruct,\n+            c_style_enum: CStyleEnumVar3,\n+            mixed_enum: MixedEnumStructVar {\n+                field1: 121.5,\n+                field2: -122\n+            }\n+        }\n+    };\n+\n+    zzz();\n+}\n+\n+fn zzz() { () }"}]}