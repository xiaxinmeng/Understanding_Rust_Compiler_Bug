{"sha": "f9781fd071ce8f47fd451d0b4c3a3d6c67054da1", "node_id": "C_kwDOAAsO6NoAKGY5NzgxZmQwNzFjZThmNDdmZDQ1MWQwYjRjM2EzZDZjNjcwNTRkYTE", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-07T23:59:02Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-08T16:00:23Z"}, "message": "remove ItemLikeVisitor impls from monomorphize and rustc_typeck crates\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "2c8ace9ecdf3d90c29b6dfe85f4108d260944a93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c8ace9ecdf3d90c29b6dfe85f4108d260944a93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1", "html_url": "https://github.com/rust-lang/rust/commit/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2840d237c98531bcb15453ff1b40e401c5335e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2840d237c98531bcb15453ff1b40e401c5335e0", "html_url": "https://github.com/rust-lang/rust/commit/d2840d237c98531bcb15453ff1b40e401c5335e0"}], "stats": {"total": 224, "additions": 97, "deletions": 127}, "files": [{"sha": "bdeae1659dde2f4d843eaeb558ea1f54c3a9936e", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=f9781fd071ce8f47fd451d0b4c3a3d6c67054da1", "patch": "@@ -181,8 +181,8 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n@@ -327,11 +327,19 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n \n         debug!(\"collect_roots: entry_fn = {:?}\", entry_fn);\n \n-        let mut visitor = RootCollector { tcx, mode, entry_fn, output: &mut roots };\n+        let mut collector = RootCollector { tcx, mode, entry_fn, output: &mut roots };\n \n-        tcx.hir().visit_all_item_likes(&mut visitor);\n+        let crate_items = tcx.hir_crate_items(());\n \n-        visitor.push_extra_entry_roots();\n+        for id in crate_items.items() {\n+            collector.process_item(id);\n+        }\n+\n+        for id in crate_items.impl_items() {\n+            collector.process_impl_item(id);\n+        }\n+\n+        collector.push_extra_entry_roots();\n     }\n \n     // We can only codegen items that are instantiable - items all of\n@@ -1139,87 +1147,74 @@ struct RootCollector<'a, 'tcx> {\n     entry_fn: Option<(DefId, EntryFnType)>,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n-    fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n-        match item.kind {\n-            hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::Macro(..)\n-            | hir::ItemKind::ForeignMod { .. }\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Mod(..) => {\n-                // Nothing to do, just keep recursing.\n-            }\n-\n-            hir::ItemKind::Impl { .. } => {\n-                if self.mode == MonoItemCollectionMode::Eager {\n-                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n-                }\n-            }\n-\n-            hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Struct(_, ref generics)\n-            | hir::ItemKind::Union(_, ref generics) => {\n-                if generics.params.is_empty() {\n-                    if self.mode == MonoItemCollectionMode::Eager {\n-                        debug!(\n-                            \"RootCollector: ADT drop-glue for {}\",\n-                            self.tcx.def_path_str(item.def_id.to_def_id())\n-                        );\n-\n-                        let ty = Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n-                            .ty(self.tcx, ty::ParamEnv::reveal_all());\n-                        visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n+impl<'v> RootCollector<'_, 'v> {\n+    fn process_item(&mut self, id: hir::ItemId) {\n+        match self.tcx.hir().def_kind(id.def_id) {\n+            DefKind::Enum | DefKind::Struct | DefKind::Union => {\n+                let item = self.tcx.hir().item(id);\n+                match item.kind {\n+                    hir::ItemKind::Enum(_, ref generics)\n+                    | hir::ItemKind::Struct(_, ref generics)\n+                    | hir::ItemKind::Union(_, ref generics) => {\n+                        if generics.params.is_empty() {\n+                            if self.mode == MonoItemCollectionMode::Eager {\n+                                debug!(\n+                                    \"RootCollector: ADT drop-glue for {}\",\n+                                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                                );\n+\n+                                let ty =\n+                                    Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n+                                        .ty(self.tcx, ty::ParamEnv::reveal_all());\n+                                visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n+                            }\n+                        }\n                     }\n+                    _ => {}\n                 }\n             }\n-            hir::ItemKind::GlobalAsm(..) => {\n+            DefKind::GlobalAsm => {\n                 debug!(\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n-                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.def_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.item_id())));\n+                self.output.push(dummy_spanned(MonoItem::GlobalAsm(id)));\n             }\n-            hir::ItemKind::Static(..) => {\n+            DefKind::Static(..) => {\n                 debug!(\n                     \"RootCollector: ItemKind::Static({})\",\n-                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.def_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::Static(item.def_id.to_def_id())));\n+                self.output.push(dummy_spanned(MonoItem::Static(id.def_id.to_def_id())));\n             }\n-            hir::ItemKind::Const(..) => {\n+            DefKind::Const => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                if let Ok(val) = self.tcx.const_eval_poly(item.def_id.to_def_id()) {\n+                if let Ok(val) = self.tcx.const_eval_poly(id.def_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n-            hir::ItemKind::Fn(..) => {\n-                self.push_if_root(item.def_id);\n+            DefKind::Impl => {\n+                let item = self.tcx.hir().item(id);\n+                if self.mode == MonoItemCollectionMode::Eager {\n+                    create_mono_items_for_default_impls(self.tcx, item, self.output);\n+                }\n+            }\n+            DefKind::Fn => {\n+                self.push_if_root(id.def_id);\n             }\n+            _ => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'v hir::TraitItem<'v>) {\n-        // Even if there's a default body with no explicit generics,\n-        // it's still generic over some `Self: Trait`, so not a root.\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n-        if let hir::ImplItemKind::Fn(hir::FnSig { .. }, _) = ii.kind {\n-            self.push_if_root(ii.def_id);\n+    fn process_impl_item(&mut self, id: hir::ImplItemId) {\n+        if matches!(self.tcx.hir().def_kind(id.def_id), DefKind::AssocFn) {\n+            self.push_if_root(id.def_id);\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, _foreign_item: &'v hir::ForeignItem<'v>) {}\n-}\n-\n-impl<'v> RootCollector<'_, 'v> {\n     fn is_root(&self, def_id: LocalDefId) -> bool {\n         !item_requires_monomorphization(self.tcx, def_id)\n             && match self.mode {"}, {"sha": "6f842c6e71a5b5aaf399f55a6a240f90f3e40cb8", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 42, "deletions": 67, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9781fd071ce8f47fd451d0b4c3a3d6c67054da1/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=f9781fd071ce8f47fd451d0b4c3a3d6c67054da1", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n@@ -29,81 +28,57 @@ pub fn infer_predicates<'tcx>(\n     while predicates_added {\n         predicates_added = false;\n \n-        let mut visitor = InferVisitor {\n-            tcx,\n-            global_inferred_outlives: &mut global_inferred_outlives,\n-            predicates_added: &mut predicates_added,\n-            explicit_map,\n-        };\n-\n         // Visit all the crates and infer predicates\n-        tcx.hir().visit_all_item_likes(&mut visitor);\n-    }\n+        for id in tcx.hir().items() {\n+            let item_did = id.def_id;\n \n-    global_inferred_outlives\n-}\n+            debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-pub struct InferVisitor<'cx, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n-    predicates_added: &'cx mut bool,\n-    explicit_map: &'cx mut ExplicitPredicatesMap<'tcx>,\n-}\n-\n-impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let item_did = item.def_id;\n-\n-        debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n+            let mut item_required_predicates = RequiredPredicates::default();\n+            match tcx.hir().def_kind(item_did) {\n+                DefKind::Union | DefKind::Enum | DefKind::Struct => {\n+                    let adt_def = tcx.adt_def(item_did.to_def_id());\n \n-        let mut item_required_predicates = RequiredPredicates::default();\n-        match item.kind {\n-            hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(item_did.to_def_id());\n-\n-                // Iterate over all fields in item_did\n-                for field_def in adt_def.all_fields() {\n-                    // Calculating the predicate requirements necessary\n-                    // for item_did.\n-                    //\n-                    // For field of type &'a T (reference) or Adt\n-                    // (struct/enum/union) there will be outlive\n-                    // requirements for adt_def.\n-                    let field_ty = self.tcx.type_of(field_def.did);\n-                    let field_span = self.tcx.def_span(field_def.did);\n-                    insert_required_predicates_to_be_wf(\n-                        self.tcx,\n-                        field_ty,\n-                        field_span,\n-                        self.global_inferred_outlives,\n-                        &mut item_required_predicates,\n-                        &mut self.explicit_map,\n-                    );\n+                    // Iterate over all fields in item_did\n+                    for field_def in adt_def.all_fields() {\n+                        // Calculating the predicate requirements necessary\n+                        // for item_did.\n+                        //\n+                        // For field of type &'a T (reference) or Adt\n+                        // (struct/enum/union) there will be outlive\n+                        // requirements for adt_def.\n+                        let field_ty = tcx.type_of(field_def.did);\n+                        let field_span = tcx.def_span(field_def.did);\n+                        insert_required_predicates_to_be_wf(\n+                            tcx,\n+                            field_ty,\n+                            field_span,\n+                            &mut global_inferred_outlives,\n+                            &mut item_required_predicates,\n+                            explicit_map,\n+                        );\n+                    }\n                 }\n-            }\n \n-            _ => {}\n-        };\n+                _ => {}\n+            };\n \n-        // If new predicates were added (`local_predicate_map` has more\n-        // predicates than the `global_inferred_outlives`), the new predicates\n-        // might result in implied predicates for their parent types.\n-        // Therefore mark `predicates_added` as true and which will ensure\n-        // we walk the crates again and re-calculate predicates for all\n-        // items.\n-        let item_predicates_len: usize =\n-            self.global_inferred_outlives.get(&item_did.to_def_id()).map_or(0, |p| p.len());\n-        if item_required_predicates.len() > item_predicates_len {\n-            *self.predicates_added = true;\n-            self.global_inferred_outlives.insert(item_did.to_def_id(), item_required_predicates);\n+            // If new predicates were added (`local_predicate_map` has more\n+            // predicates than the `global_inferred_outlives`), the new predicates\n+            // might result in implied predicates for their parent types.\n+            // Therefore mark `predicates_added` as true and which will ensure\n+            // we walk the crates again and re-calculate predicates for all\n+            // items.\n+            let item_predicates_len: usize =\n+                global_inferred_outlives.get(&item_did.to_def_id()).map_or(0, |p| p.len());\n+            if item_required_predicates.len() > item_predicates_len {\n+                predicates_added = true;\n+                global_inferred_outlives.insert(item_did.to_def_id(), item_required_predicates);\n+            }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem<'tcx>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem<'tcx>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &'tcx hir::ForeignItem<'tcx>) {}\n+    global_inferred_outlives\n }\n \n fn insert_required_predicates_to_be_wf<'tcx>("}]}