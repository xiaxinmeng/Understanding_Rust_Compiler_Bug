{"sha": "9c418e5170a2fb125ae260af1fd94e538201888d", "node_id": "C_kwDOAAsO6NoAKDljNDE4ZTUxNzBhMmZiMTI1YWUyNjBhZjFmZDk0ZTUzODIwMTg4OGQ", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2023-05-12T17:31:37Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2023-05-12T22:00:51Z"}, "message": "allow mutating function args through `&raw const`", "tree": {"sha": "963907052f65243d3bcb1027500142e1284f5c46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/963907052f65243d3bcb1027500142e1284f5c46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c418e5170a2fb125ae260af1fd94e538201888d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c418e5170a2fb125ae260af1fd94e538201888d", "html_url": "https://github.com/rust-lang/rust/commit/9c418e5170a2fb125ae260af1fd94e538201888d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c418e5170a2fb125ae260af1fd94e538201888d/comments", "author": null, "committer": null, "parents": [{"sha": "97ed8083220f0924434f9c3863a78faa69035a7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ed8083220f0924434f9c3863a78faa69035a7a", "html_url": "https://github.com/rust-lang/rust/commit/97ed8083220f0924434f9c3863a78faa69035a7a"}], "stats": {"total": 55, "additions": 50, "deletions": 5}, "files": [{"sha": "a133c9d4782c8bc2f0f61010b58d1b2eff2ea27e", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c418e5170a2fb125ae260af1fd94e538201888d/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c418e5170a2fb125ae260af1fd94e538201888d/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=9c418e5170a2fb125ae260af1fd94e538201888d", "patch": "@@ -8,7 +8,7 @@\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n-use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n+use rustc_middle::mir::{Body, Location, Operand, Place, Terminator, TerminatorKind, RETURN_PLACE};\n use rustc_middle::ty::{self, DeducedParamAttrs, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n \n@@ -29,20 +29,31 @@ impl DeduceReadOnly {\n }\n \n impl<'tcx> Visitor<'tcx> for DeduceReadOnly {\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _location: Location) {\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         // We're only interested in arguments.\n-        if local == RETURN_PLACE || local.index() > self.mutable_args.domain_size() {\n+        if place.local == RETURN_PLACE || place.local.index() > self.mutable_args.domain_size() {\n             return;\n         }\n \n-        match context {\n+        let mark_as_mutable = match context {\n             PlaceContext::MutatingUse(..) => {\n                 // This is a mutation, so mark it as such.\n-                self.mutable_args.insert(local.index() - 1);\n+                true\n+            }\n+            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) => {\n+                // Whether mutating though a `&raw const` is allowed is still undecided, so we\n+                // disable any sketchy `readonly` optimizations for now.\n+                // But we only need to do this if the pointer would point into the argument.\n+                !place.is_indirect()\n             }\n             PlaceContext::NonMutatingUse(..) | PlaceContext::NonUse(..) => {\n                 // Not mutating, so it's fine.\n+                false\n             }\n+        };\n+\n+        if mark_as_mutable {\n+            self.mutable_args.insert(place.local.index() - 1);\n         }\n     }\n "}, {"sha": "bea1aad235242575af515452dac19ea26c1250bb", "filename": "tests/codegen/addr-of-mutate.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9c418e5170a2fb125ae260af1fd94e538201888d/tests%2Fcodegen%2Faddr-of-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c418e5170a2fb125ae260af1fd94e538201888d/tests%2Fcodegen%2Faddr-of-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Faddr-of-mutate.rs?ref=9c418e5170a2fb125ae260af1fd94e538201888d", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -C opt-level=3 -C no-prepopulate-passes\n+// min-llvm-version: 15.0 (for opaque pointers)\n+\n+#![crate_type = \"lib\"]\n+\n+// Test for the absence of `readonly` on the argument when it is mutated via `&raw const`.\n+// See <https://github.com/rust-lang/rust/issues/111502>.\n+\n+// CHECK: i8 @foo(ptr noalias nocapture noundef dereferenceable(128) %x)\n+#[no_mangle]\n+pub fn foo(x: [u8; 128]) -> u8 {\n+    let ptr = core::ptr::addr_of!(x).cast_mut();\n+    unsafe {\n+        (*ptr)[0] = 1;\n+    }\n+    x[0]\n+}\n+\n+// CHECK: i1 @second(ptr noalias nocapture noundef dereferenceable({{[0-9]+}}) %a_ptr_and_b)\n+#[no_mangle]\n+pub unsafe fn second(a_ptr_and_b: (*mut (i32, bool), (i64, bool))) -> bool {\n+    let b_bool_ptr = core::ptr::addr_of!(a_ptr_and_b.1.1).cast_mut();\n+    (*b_bool_ptr) = true;\n+    a_ptr_and_b.1.1\n+}\n+\n+// If going through a deref (and there are no other mutating accesses), then `readonly` is fine.\n+// CHECK: i1 @third(ptr noalias nocapture noundef readonly dereferenceable({{[0-9]+}}) %a_ptr_and_b)\n+#[no_mangle]\n+pub unsafe fn third(a_ptr_and_b: (*mut (i32, bool), (i64, bool))) -> bool {\n+    let b_bool_ptr = core::ptr::addr_of!((*a_ptr_and_b.0).1).cast_mut();\n+    (*b_bool_ptr) = true;\n+    a_ptr_and_b.1.1\n+}"}]}