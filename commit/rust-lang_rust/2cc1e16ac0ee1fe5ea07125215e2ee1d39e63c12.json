{"sha": "2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYzFlMTZhYzBlZTFmZTVlYTA3MTI1MjE1ZTJlZTFkMzllNjNjMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-25T05:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-25T05:32:13Z"}, "message": "auto merge of #10603 : alexcrichton/rust/no-linked-failure, r=brson\n\nThe reasons for doing this are:\r\n\r\n* The model on which linked failure is based is inherently complex\r\n* The implementation is also very complex, and there are few remaining who\r\n  fully understand the implementation\r\n* There are existing race conditions in the core context switching function of\r\n  the scheduler, and possibly others.\r\n* It's unclear whether this model of linked failure maps well to a 1:1 threading\r\n  model\r\n\r\nLinked failure is often a desired aspect of tasks, but we would like to take a\r\nmuch more conservative approach in re-implementing linked failure if at all.\r\n\r\nCloses #8674\r\nCloses #8318\r\nCloses #8863", "tree": {"sha": "456081dd6cdf57c5e1b7cc14e509e89d8a184fea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/456081dd6cdf57c5e1b7cc14e509e89d8a184fea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "html_url": "https://github.com/rust-lang/rust/commit/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3274336e9d61b29f6862b4706a2a105a208f0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3274336e9d61b29f6862b4706a2a105a208f0a", "html_url": "https://github.com/rust-lang/rust/commit/ca3274336e9d61b29f6862b4706a2a105a208f0a"}, {"sha": "acca9e3834842ee8d8104abe9b8b9bb88861793c", "url": "https://api.github.com/repos/rust-lang/rust/commits/acca9e3834842ee8d8104abe9b8b9bb88861793c", "html_url": "https://github.com/rust-lang/rust/commit/acca9e3834842ee8d8104abe9b8b9bb88861793c"}], "stats": {"total": 2934, "additions": 403, "deletions": 2531}, "files": [{"sha": "2eb5ee7dbc999d59eab65dbc74125e92ea1bd5bc", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -2349,9 +2349,9 @@ Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n task in a _failing state_.\n \n-~~~~\n+~~~~ {.xfail-test}\n # use std::task;\n-# do task::spawn_unlinked {\n+# do task::spawn {\n \n ([1, 2, 3, 4])[0];\n ([\"a\", \"b\"])[10]; // fails"}, {"sha": "04a3bfe9c2a4e885142e9bcf09a0b18dc100bea4", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 111, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -402,22 +402,6 @@ freeing memory along the way---and then exits. Unlike exceptions in C++,\n exceptions in Rust are unrecoverable within a single task: once a task fails,\n there is no way to \"catch\" the exception.\n \n-All tasks are, by default, _linked_ to each other. That means that the fates\n-of all tasks are intertwined: if one fails, so do all the others.\n-\n-~~~{.xfail-test .linked-failure}\n-# use std::task::spawn;\n-# use std::task;\n-# fn do_some_work() { loop { task::yield() } }\n-# do task::try {\n-// Create a child task that fails\n-do spawn { fail!() }\n-\n-// This will also fail because the task we spawned failed\n-do_some_work();\n-# };\n-~~~\n-\n While it isn't possible for a task to recover from failure, tasks may notify\n each other of failure. The simplest way of handling task failure is with the\n `try` function, which is similar to `spawn`, but immediately blocks waiting\n@@ -464,101 +448,7 @@ it trips, indicates an unrecoverable logic error); in other cases you\n might want to contain the failure at a certain boundary (perhaps a\n small piece of input from the outside world, which you happen to be\n processing in parallel, is malformed and its processing task can't\n-proceed). Hence, you will need different _linked failure modes_.\n-\n-## Failure modes\n-\n-By default, task failure is _bidirectionally linked_, which means that if\n-either task fails, it kills the other one.\n-\n-~~~{.xfail-test .linked-failure}\n-# use std::task;\n-# use std::comm::oneshot;\n-# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\n-# do task::try {\n-do spawn {\n-    do spawn {\n-        fail!();  // All three tasks will fail.\n-    }\n-    sleep_forever();  // Will get woken up by force, then fail\n-}\n-sleep_forever();  // Will get woken up by force, then fail\n-# };\n-~~~\n-\n-If you want parent tasks to be able to kill their children, but do not want a\n-parent to fail automatically if one of its child task fails, you can call\n-`task::spawn_supervised` for _unidirectionally linked_ failure. The\n-function `task::try`, which we saw previously, uses `spawn_supervised`\n-internally, with additional logic to wait for the child task to finish\n-before returning. Hence:\n-\n-~~~{.xfail-test .linked-failure}\n-# use std::comm::{stream, Chan, Port};\n-# use std::comm::oneshot;\n-# use std::task::{spawn, try};\n-# use std::task;\n-# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\n-# do task::try {\n-let (receiver, sender): (Port<int>, Chan<int>) = stream();\n-do spawn {  // Bidirectionally linked\n-    // Wait for the supervised child task to exist.\n-    let message = receiver.recv();\n-    // Kill both it and the parent task.\n-    assert!(message != 42);\n-}\n-do try {  // Unidirectionally linked\n-    sender.send(42);\n-    sleep_forever();  // Will get woken up by force\n-}\n-// Flow never reaches here -- parent task was killed too.\n-# };\n-~~~\n-\n-Supervised failure is useful in any situation where one task manages\n-multiple fallible child tasks, and the parent task can recover\n-if any child fails. On the other hand, if the _parent_ (supervisor) fails,\n-then there is nothing the children can do to recover, so they should\n-also fail.\n-\n-Supervised task failure propagates across multiple generations even if\n-an intermediate generation has already exited:\n-\n-~~~{.xfail-test .linked-failure}\n-# use std::task;\n-# use std::comm::oneshot;\n-# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\n-# fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\n-# do task::try::<int> {\n-do task::spawn_supervised {\n-    do task::spawn_supervised {\n-        sleep_forever();  // Will get woken up by force, then fail\n-    }\n-    // Intermediate task immediately exits\n-}\n-wait_for_a_while();\n-fail!();  // Will kill grandchild even if child has already exited\n-# };\n-~~~\n-\n-Finally, tasks can be configured to not propagate failure to each\n-other at all, using `task::spawn_unlinked` for _isolated failure_.\n-\n-~~~{.xfail-test .linked-failure}\n-# use std::task;\n-# fn random() -> uint { 100 }\n-# fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\n-# do task::try::<()> {\n-let (time1, time2) = (random(), random());\n-do task::spawn_unlinked {\n-    sleep_for(time2);  // Won't get forced awake\n-    fail!();\n-}\n-sleep_for(time1);  // Won't get forced awake\n-fail!();\n-// It will take MAX(time1,time2) for the program to finish.\n-# };\n-~~~\n+proceed).\n \n ## Creating a task with a bi-directional communication path\n "}, {"sha": "0752b9d9a7f4f293e287e134506b9de7c90b00ff", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -655,7 +655,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p, c) = comm::stream();\n \n-        do task::spawn_unlinked || {\n+        do spawn {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();"}, {"sha": "5321a6288f435d968ac1d4c0adaccca3530f68aa", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -137,7 +137,6 @@ pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n mod test {\n     use comm::{DuplexStream, rendezvous};\n     use std::rt::test::run_in_uv_task;\n-    use std::task::spawn_unlinked;\n \n \n     #[test]\n@@ -177,7 +176,7 @@ mod test {\n     #[test]\n     fn send_and_fail_and_try_recv() {\n         let (port, chan) = rendezvous();\n-        do spawn_unlinked {\n+        do spawn {\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n             fail!()\n         }\n@@ -187,7 +186,7 @@ mod test {\n     #[test]\n     fn try_send_and_recv_then_fail_before_ack() {\n         let (port, chan) = rendezvous();\n-        do spawn_unlinked {\n+        do spawn {\n             port.duplex_stream.recv();\n             fail!()\n         }\n@@ -198,7 +197,7 @@ mod test {\n     #[should_fail]\n     fn send_and_recv_then_fail_before_ack() {\n         let (port, chan) = rendezvous();\n-        do spawn_unlinked {\n+        do spawn {\n             port.duplex_stream.recv();\n             fail!()\n         }"}, {"sha": "8d365c5a5204c4c6f2399069f476afe8e7a67553", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -27,7 +27,6 @@\n \n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n-use std::task;\n use std::util::replace;\n \n /// A type encapsulating the result of a computation which may not be complete\n@@ -130,29 +129,12 @@ impl<A:Send> Future<A> {\n \n         let (port, chan) = oneshot();\n \n-        do task::spawn_with(chan) |chan| {\n+        do spawn {\n             chan.send(blk());\n         }\n \n         Future::from_port(port)\n     }\n-\n-    pub fn spawn_with<B: Send>(v: B, blk: proc(B) -> A) -> Future<A> {\n-        /*!\n-         * Create a future from a unique closure taking one argument.\n-         *\n-         * The closure and its argument will be moved into a new task. The\n-         * closure will be run and its result used as the value of the future.\n-         */\n-\n-         let (port, chan) = oneshot();\n-\n-         do task::spawn_with((v, chan)) |(v, chan)| {\n-            chan.send(blk(v));\n-         }\n-\n-         Future::from_port(port)\n-    }\n }\n \n #[cfg(test)]\n@@ -207,12 +189,6 @@ mod test {\n         assert_eq!(f.get(), ~\"bale\");\n     }\n \n-    #[test]\n-    fn test_spawn_with() {\n-        let mut f = Future::spawn_with(~\"gale\", |s| { s });\n-        assert_eq!(f.get(), ~\"gale\");\n-    }\n-\n     #[test]\n     #[should_fail]\n     fn test_futurefail() {"}, {"sha": "d7b2d5ea4d6705319fab32f2d57819d26fbf98e4", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 109, "deletions": 135, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -22,7 +22,6 @@ use std::borrow;\n use std::comm;\n use std::comm::SendDeferred;\n use std::comm::{GenericPort, Peekable};\n-use std::task;\n use std::unstable::sync::{Exclusive, UnsafeArc};\n use std::unstable::atomics;\n use std::unstable::finally::Finally;\n@@ -134,13 +133,11 @@ impl<Q:Send> Sem<Q> {\n     }\n \n     pub fn access<U>(&self, blk: || -> U) -> U {\n-        do task::unkillable {\n-            do (|| {\n-                self.acquire();\n-                do task::rekillable { blk() }\n-            }).finally {\n-                self.release();\n-            }\n+        do (|| {\n+            self.acquire();\n+            blk()\n+        }).finally {\n+            self.release();\n         }\n     }\n }\n@@ -206,48 +203,41 @@ impl<'self> Condvar<'self> {\n     pub fn wait_on(&self, condvar_id: uint) {\n         let mut WaitEnd = None;\n         let mut out_of_bounds = None;\n-        do task::unkillable {\n-            // Release lock, 'atomically' enqueuing ourselves in so doing.\n-            unsafe {\n-                do (**self.sem).with |state| {\n-                    if condvar_id < state.blocked.len() {\n-                        // Drop the lock.\n-                        state.count += 1;\n-                        if state.count <= 0 {\n-                            state.waiters.signal();\n-                        }\n-                        // Create waiter nobe, and enqueue ourself to\n-                        // be woken up by a signaller.\n-                        WaitEnd = Some(state.blocked[condvar_id].wait_end());\n-                    } else {\n-                        out_of_bounds = Some(state.blocked.len());\n+        // Release lock, 'atomically' enqueuing ourselves in so doing.\n+        unsafe {\n+            do (**self.sem).with |state| {\n+                if condvar_id < state.blocked.len() {\n+                    // Drop the lock.\n+                    state.count += 1;\n+                    if state.count <= 0 {\n+                        state.waiters.signal();\n                     }\n+                    // Create waiter nobe, and enqueue ourself to\n+                    // be woken up by a signaller.\n+                    WaitEnd = Some(state.blocked[condvar_id].wait_end());\n+                } else {\n+                    out_of_bounds = Some(state.blocked.len());\n                 }\n             }\n+        }\n \n-            // If deschedule checks start getting inserted anywhere, we can be\n-            // killed before or after enqueueing. Deciding whether to\n-            // unkillably reacquire the lock needs to happen atomically\n-            // wrt enqueuing.\n-            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\") {\n-                // Unconditionally \"block\". (Might not actually block if a\n-                // signaller already sent -- I mean 'unconditionally' in contrast\n-                // with acquire().)\n-                do (|| {\n-                    do task::rekillable {\n-                        let _ = WaitEnd.take_unwrap().recv();\n-                    }\n-                }).finally {\n-                    // Reacquire the condvar. Note this is back in the unkillable\n-                    // section; it needs to succeed, instead of itself dying.\n-                    match self.order {\n-                        Just(lock) => do lock.access {\n-                            self.sem.acquire();\n-                        },\n-                        Nothing => {\n-                            self.sem.acquire();\n-                        },\n-                    }\n+        // If deschedule checks start getting inserted anywhere, we can be\n+        // killed before or after enqueueing.\n+        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\") {\n+            // Unconditionally \"block\". (Might not actually block if a\n+            // signaller already sent -- I mean 'unconditionally' in contrast\n+            // with acquire().)\n+            do (|| {\n+                let _ = WaitEnd.take_unwrap().recv();\n+            }).finally {\n+                // Reacquire the condvar.\n+                match self.order {\n+                    Just(lock) => do lock.access {\n+                        self.sem.acquire();\n+                    },\n+                    Nothing => {\n+                        self.sem.acquire();\n+                    },\n                 }\n             }\n         }\n@@ -484,30 +474,28 @@ impl RWLock {\n      */\n     pub fn read<U>(&self, blk: || -> U) -> U {\n         unsafe {\n-            do task::unkillable {\n-                do (&self.order_lock).access {\n-                    let state = &mut *self.state.get();\n-                    let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n-                    if old_count == 0 {\n-                        (&self.access_lock).acquire();\n-                        state.read_mode = true;\n-                    }\n+            do (&self.order_lock).access {\n+                let state = &mut *self.state.get();\n+                let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n+                if old_count == 0 {\n+                    (&self.access_lock).acquire();\n+                    state.read_mode = true;\n                 }\n-                do (|| {\n-                    do task::rekillable { blk() }\n-                }).finally {\n-                    let state = &mut *self.state.get();\n-                    assert!(state.read_mode);\n-                    let old_count = state.read_count.fetch_sub(1, atomics::Release);\n-                    assert!(old_count > 0);\n-                    if old_count == 1 {\n-                        state.read_mode = false;\n-                        // Note: this release used to be outside of a locked access\n-                        // to exclusive-protected state. If this code is ever\n-                        // converted back to such (instead of using atomic ops),\n-                        // this access MUST NOT go inside the exclusive access.\n-                        (&self.access_lock).release();\n-                    }\n+            }\n+            do (|| {\n+                blk()\n+            }).finally {\n+                let state = &mut *self.state.get();\n+                assert!(state.read_mode);\n+                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n+                assert!(old_count > 0);\n+                if old_count == 1 {\n+                    state.read_mode = false;\n+                    // Note: this release used to be outside of a locked access\n+                    // to exclusive-protected state. If this code is ever\n+                    // converted back to such (instead of using atomic ops),\n+                    // this access MUST NOT go inside the exclusive access.\n+                    (&self.access_lock).release();\n                 }\n             }\n         }\n@@ -518,14 +506,10 @@ impl RWLock {\n      * 'write' from other tasks will run concurrently with this one.\n      */\n     pub fn write<U>(&self, blk: || -> U) -> U {\n-        do task::unkillable {\n-            (&self.order_lock).acquire();\n-            do (&self.access_lock).access {\n-                (&self.order_lock).release();\n-                do task::rekillable {\n-                    blk()\n-                }\n-            }\n+        (&self.order_lock).acquire();\n+        do (&self.access_lock).access {\n+            (&self.order_lock).release();\n+            blk()\n         }\n     }\n \n@@ -562,16 +546,12 @@ impl RWLock {\n         // which can't happen until T2 finishes the downgrade-read entirely.\n         // The astute reader will also note that making waking writers use the\n         // order_lock is better for not starving readers.\n-        do task::unkillable {\n-            (&self.order_lock).acquire();\n-            do (&self.access_lock).access_cond |cond| {\n-                (&self.order_lock).release();\n-                do task::rekillable {\n-                    let opt_lock = Just(&self.order_lock);\n-                    blk(&Condvar { sem: cond.sem, order: opt_lock,\n-                                   token: NonCopyable })\n-                }\n-            }\n+        (&self.order_lock).acquire();\n+        do (&self.access_lock).access_cond |cond| {\n+            (&self.order_lock).release();\n+            let opt_lock = Just(&self.order_lock);\n+            blk(&Condvar { sem: cond.sem, order: opt_lock,\n+                           token: NonCopyable })\n         }\n     }\n \n@@ -599,39 +579,35 @@ impl RWLock {\n     pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n-        do task::unkillable {\n-            (&self.order_lock).acquire();\n-            (&self.access_lock).acquire();\n-            (&self.order_lock).release();\n-            do (|| {\n-                do task::rekillable {\n-                    blk(RWLockWriteMode { lock: self, token: NonCopyable })\n-                }\n-            }).finally {\n-                let writer_or_last_reader;\n-                // Check if we're releasing from read mode or from write mode.\n-                let state = unsafe { &mut *self.state.get() };\n-                if state.read_mode {\n-                    // Releasing from read mode.\n-                    let old_count = state.read_count.fetch_sub(1, atomics::Release);\n-                    assert!(old_count > 0);\n-                    // Check if other readers remain.\n-                    if old_count == 1 {\n-                        // Case 1: Writer downgraded & was the last reader\n-                        writer_or_last_reader = true;\n-                        state.read_mode = false;\n-                    } else {\n-                        // Case 2: Writer downgraded & was not the last reader\n-                        writer_or_last_reader = false;\n-                    }\n-                } else {\n-                    // Case 3: Writer did not downgrade\n+        (&self.order_lock).acquire();\n+        (&self.access_lock).acquire();\n+        (&self.order_lock).release();\n+        do (|| {\n+            blk(RWLockWriteMode { lock: self, token: NonCopyable })\n+        }).finally {\n+            let writer_or_last_reader;\n+            // Check if we're releasing from read mode or from write mode.\n+            let state = unsafe { &mut *self.state.get() };\n+            if state.read_mode {\n+                // Releasing from read mode.\n+                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n+                assert!(old_count > 0);\n+                // Check if other readers remain.\n+                if old_count == 1 {\n+                    // Case 1: Writer downgraded & was the last reader\n                     writer_or_last_reader = true;\n+                    state.read_mode = false;\n+                } else {\n+                    // Case 2: Writer downgraded & was not the last reader\n+                    writer_or_last_reader = false;\n                 }\n-                if writer_or_last_reader {\n-                    // Nobody left inside; release the \"reader cloud\" lock.\n-                    (&self.access_lock).release();\n-                }\n+            } else {\n+                // Case 3: Writer did not downgrade\n+                writer_or_last_reader = true;\n+            }\n+            if writer_or_last_reader {\n+                // Nobody left inside; release the \"reader cloud\" lock.\n+                (&self.access_lock).release();\n             }\n         }\n     }\n@@ -643,23 +619,21 @@ impl RWLock {\n             fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n         unsafe {\n-            do task::unkillable {\n-                let state = &mut *self.state.get();\n-                assert!(!state.read_mode);\n-                state.read_mode = true;\n-                // If a reader attempts to enter at this point, both the\n-                // downgrader and reader will set the mode flag. This is fine.\n-                let old_count = state.read_count.fetch_add(1, atomics::Release);\n-                // If another reader was already blocking, we need to hand-off\n-                // the \"reader cloud\" access lock to them.\n-                if old_count != 0 {\n-                    // Guaranteed not to let another writer in, because\n-                    // another reader was holding the order_lock. Hence they\n-                    // must be the one to get the access_lock (because all\n-                    // access_locks are acquired with order_lock held). See\n-                    // the comment in write_cond for more justification.\n-                    (&self.access_lock).release();\n-                }\n+            let state = &mut *self.state.get();\n+            assert!(!state.read_mode);\n+            state.read_mode = true;\n+            // If a reader attempts to enter at this point, both the\n+            // downgrader and reader will set the mode flag. This is fine.\n+            let old_count = state.read_count.fetch_add(1, atomics::Release);\n+            // If another reader was already blocking, we need to hand-off\n+            // the \"reader cloud\" access lock to them.\n+            if old_count != 0 {\n+                // Guaranteed not to let another writer in, because\n+                // another reader was holding the order_lock. Hence they\n+                // must be the one to get the access_lock (because all\n+                // access_locks are acquired with order_lock held). See\n+                // the comment in write_cond for more justification.\n+                (&self.access_lock).release();\n             }\n         }\n         RWLockReadMode { lock: token.lock, token: NonCopyable }"}, {"sha": "561231967a120223e3134a50378033224abd4740", "filename": "src/libextra/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -875,7 +875,6 @@ pub fn run_test(force_ignore: bool,\n         let testfn_cell = ::std::cell::Cell::new(testfn);\n         do task::spawn {\n             let mut task = task::task();\n-            task.unlinked();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n                 StaticTestName(name) => SendStrStatic(name),"}, {"sha": "bfdb3b1e89942cb8f928461e6d622ef2d497613b", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -954,10 +954,10 @@ mod tests {\n \n     use std::f64;\n     use std::result::{Err, Ok};\n-    use std::libc;\n \n     #[cfg(windows)]\n     fn set_time_zone() {\n+        use std::libc;\n         // Windows crt doesn't see any environment variable set by\n         // `SetEnvironmentVariable`, which `os::setenv` internally uses.\n         // It is why we use `putenv` here."}, {"sha": "f6c3d5fa4ad7fca465057fe1209577f080a94105", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -338,7 +338,6 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n     let ch_capture = ch.clone();\n     let mut task_builder = task::task();\n     task_builder.name(\"rustc\");\n-    task_builder.supervised();\n \n     // XXX: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly."}, {"sha": "3ec66123c23af741426f090e41013b6e3d70e894", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -709,10 +709,11 @@ impl Context {\n             let prog_chan = prog_chan.clone();\n \n             let mut task = task::task();\n-            task.unlinked(); // we kill things manually\n             task.name(format!(\"worker{}\", i));\n-            task.spawn_with(cache.clone(),\n-                            |cache| worker(cache, &port, &chan, &prog_chan));\n+            let cache = cache.clone();\n+            do task.spawn {\n+                worker(cache, &port, &chan, &prog_chan);\n+            }\n \n             fn worker(cache: RWArc<Cache>,\n                       port: &SharedPort<Work>,"}, {"sha": "ceda5f22adb1b71eff7c35e8b7aff7c35cf5f70d", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -20,7 +20,6 @@ use std::io;\n use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n-use std::task;\n use std::vec;\n \n use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n@@ -298,26 +297,24 @@ impl Drop for FsRequest {\n fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n     -> Result<FsRequest, UvError>\n {\n-    return do task::unkillable {\n-        let mut req = FsRequest {\n-            fired: false,\n-            req: unsafe { uvll::malloc_req(uvll::UV_FS) }\n-        };\n-        match f(req.req, fs_cb) {\n-            0 => {\n-                req.fired = true;\n-                let mut slot = None;\n-                do wait_until_woken_after(&mut slot) {\n-                    unsafe { uvll::set_data_for_req(req.req, &slot) }\n-                }\n-                match req.get_result() {\n-                    n if n < 0 => Err(UvError(n)),\n-                    _ => Ok(req),\n-                }\n+    let mut req = FsRequest {\n+        fired: false,\n+        req: unsafe { uvll::malloc_req(uvll::UV_FS) }\n+    };\n+    return match f(req.req, fs_cb) {\n+        0 => {\n+            req.fired = true;\n+            let mut slot = None;\n+            do wait_until_woken_after(&mut slot) {\n+                unsafe { uvll::set_data_for_req(req.req, &slot) }\n+            }\n+            match req.get_result() {\n+                n if n < 0 => Err(UvError(n)),\n+                _ => Ok(req),\n             }\n-            n => Err(UvError(n))\n-\n         }\n+        n => Err(UvError(n))\n+\n     };\n \n     extern fn fs_cb(req: *uvll::uv_fs_t) {"}, {"sha": "c009cc3998cab3bd21dd147d5676a42a92b30b87", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 63, "deletions": 72, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -20,7 +20,6 @@ use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::str;\n-use std::task;\n use std::vec;\n \n use stream::StreamWatcher;\n@@ -176,36 +175,34 @@ impl TcpWatcher {\n     {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n-        return do task::unkillable {\n-            let tcp = TcpWatcher::new(loop_);\n-            let ret = do socket_addr_as_sockaddr(address) |addr| {\n-                let mut req = Request::new(uvll::UV_CONNECT);\n-                let result = unsafe {\n-                    uvll::uv_tcp_connect(req.handle, tcp.handle, addr,\n-                                         connect_cb)\n-                };\n-                match result {\n-                    0 => {\n-                        req.defuse(); // uv callback now owns this request\n-                        let mut cx = Ctx { status: 0, task: None };\n-                        do wait_until_woken_after(&mut cx.task) {\n-                            req.set_data(&cx);\n-                        }\n-                        match cx.status {\n-                            0 => Ok(()),\n-                            n => Err(UvError(n)),\n-                        }\n+        let tcp = TcpWatcher::new(loop_);\n+        let ret = do socket_addr_as_sockaddr(address) |addr| {\n+            let mut req = Request::new(uvll::UV_CONNECT);\n+            let result = unsafe {\n+                uvll::uv_tcp_connect(req.handle, tcp.handle, addr,\n+                                     connect_cb)\n+            };\n+            match result {\n+                0 => {\n+                    req.defuse(); // uv callback now owns this request\n+                    let mut cx = Ctx { status: 0, task: None };\n+                    do wait_until_woken_after(&mut cx.task) {\n+                        req.set_data(&cx);\n+                    }\n+                    match cx.status {\n+                        0 => Ok(()),\n+                        n => Err(UvError(n)),\n                     }\n-                    n => Err(UvError(n))\n                 }\n-            };\n-\n-            match ret {\n-                Ok(()) => Ok(tcp),\n-                Err(e) => Err(e),\n+                n => Err(UvError(n))\n             }\n         };\n \n+        return match ret {\n+            Ok(()) => Ok(tcp),\n+            Err(e) => Err(e),\n+        };\n+\n         extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n             let req = Request::wrap(req);\n             assert!(status != uvll::ECANCELED);\n@@ -291,25 +288,23 @@ impl TcpListener {\n     pub fn bind(loop_: &mut Loop, address: SocketAddr)\n         -> Result<~TcpListener, UvError>\n     {\n-        do task::unkillable {\n-            let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n-            assert_eq!(unsafe {\n-                uvll::uv_tcp_init(loop_.handle, handle)\n-            }, 0);\n-            let l = ~TcpListener {\n-                home: get_handle_to_current_scheduler!(),\n-                handle: handle,\n-                closing_task: None,\n-                outgoing: Tube::new(),\n-            };\n-            let res = socket_addr_as_sockaddr(address, |addr| unsafe {\n-                uvll::uv_tcp_bind(l.handle, addr)\n-            });\n-            match res {\n-                0 => Ok(l.install()),\n-                n => Err(UvError(n))\n-            }\n-        }\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n+        assert_eq!(unsafe {\n+            uvll::uv_tcp_init(loop_.handle, handle)\n+        }, 0);\n+        let l = ~TcpListener {\n+            home: get_handle_to_current_scheduler!(),\n+            handle: handle,\n+            closing_task: None,\n+            outgoing: Tube::new(),\n+        };\n+        let res = socket_addr_as_sockaddr(address, |addr| unsafe {\n+            uvll::uv_tcp_bind(l.handle, addr)\n+        });\n+        return match res {\n+            0 => Ok(l.install()),\n+            n => Err(UvError(n))\n+        };\n     }\n }\n \n@@ -426,22 +421,20 @@ impl UdpWatcher {\n     pub fn bind(loop_: &Loop, address: SocketAddr)\n         -> Result<UdpWatcher, UvError>\n     {\n-        do task::unkillable {\n-            let udp = UdpWatcher {\n-                handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n-                home: get_handle_to_current_scheduler!(),\n-            };\n-            assert_eq!(unsafe {\n-                uvll::uv_udp_init(loop_.handle, udp.handle)\n-            }, 0);\n-            let result = socket_addr_as_sockaddr(address, |addr| unsafe {\n-                uvll::uv_udp_bind(udp.handle, addr, 0u32)\n-            });\n-            match result {\n-                0 => Ok(udp),\n-                n => Err(UvError(n)),\n-            }\n-        }\n+        let udp = UdpWatcher {\n+            handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n+            home: get_handle_to_current_scheduler!(),\n+        };\n+        assert_eq!(unsafe {\n+            uvll::uv_udp_init(loop_.handle, udp.handle)\n+        }, 0);\n+        let result = socket_addr_as_sockaddr(address, |addr| unsafe {\n+            uvll::uv_udp_bind(udp.handle, addr, 0u32)\n+        });\n+        return match result {\n+            0 => Ok(udp),\n+            n => Err(UvError(n)),\n+        };\n     }\n }\n \n@@ -1123,16 +1116,14 @@ mod test {\n                 assert!(maybe_socket.is_ok());\n \n                 // block self on sched1\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        // unblock task\n-                        do task.wake().map |task| {\n-                            // send self to sched2\n-                            tasksFriendHandle.take().send(TaskFromFriend(task));\n-                        };\n-                        // sched1 should now sleep since it has nothing else to do\n-                    }\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    // unblock task\n+                    do task.wake().map |task| {\n+                        // send self to sched2\n+                        tasksFriendHandle.take().send(TaskFromFriend(task));\n+                    };\n+                    // sched1 should now sleep since it has nothing else to do\n                 }\n                 // sched2 will wake up and get the task as we do nothing else,\n                 // the function ends and the socket goes out of scope sched2\n@@ -1180,7 +1171,7 @@ mod test {\n         let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n-        do task::spawn_unlinked { // please no linked failure\n+        do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n             chan.take().send(());"}, {"sha": "3bce635aa9b4de4ad851450d2a2a669183b3ab89", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -16,7 +16,6 @@ use std::rt::local::Local;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n-use std::task;\n \n use stream::StreamWatcher;\n use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error,\n@@ -74,26 +73,23 @@ impl PipeWatcher {\n     pub fn connect(loop_: &Loop, name: &CString) -> Result<PipeWatcher, UvError>\n     {\n         struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }\n-        return do task::unkillable {\n-            let mut cx = Ctx { task: None, result: 0 };\n-            let mut req = Request::new(uvll::UV_CONNECT);\n-            let pipe = PipeWatcher::new(loop_, false);\n-\n-            do wait_until_woken_after(&mut cx.task) {\n-                unsafe {\n-                    uvll::uv_pipe_connect(req.handle,\n-                                          pipe.handle(),\n-                                          name.with_ref(|p| p),\n-                                          connect_cb)\n-                }\n-                req.set_data(&cx);\n-                req.defuse(); // uv callback now owns this request\n-            }\n-            match cx.result {\n-                0 => Ok(pipe),\n-                n => Err(UvError(n))\n-            }\n+        let mut cx = Ctx { task: None, result: 0 };\n+        let mut req = Request::new(uvll::UV_CONNECT);\n+        let pipe = PipeWatcher::new(loop_, false);\n \n+        do wait_until_woken_after(&mut cx.task) {\n+            unsafe {\n+                uvll::uv_pipe_connect(req.handle,\n+                                      pipe.handle(),\n+                                      name.with_ref(|p| p),\n+                                      connect_cb)\n+            }\n+            req.set_data(&cx);\n+            req.defuse(); // uv callback now owns this request\n+        }\n+        return match cx.result {\n+            0 => Ok(pipe),\n+            n => Err(UvError(n))\n         };\n \n         extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {;\n@@ -153,24 +149,22 @@ extern fn pipe_close_cb(handle: *uvll::uv_handle_t) {\n \n impl PipeListener {\n     pub fn bind(loop_: &Loop, name: &CString) -> Result<~PipeListener, UvError> {\n-        do task::unkillable {\n-            let pipe = PipeWatcher::new(loop_, false);\n-            match unsafe {\n-                uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p))\n-            } {\n-                0 => {\n-                    // If successful, unwrap the PipeWatcher because we control how\n-                    // we close the pipe differently. We can't rely on\n-                    // StreamWatcher's default close method.\n-                    let p = ~PipeListener {\n-                        home: get_handle_to_current_scheduler!(),\n-                        pipe: pipe.unwrap(),\n-                        outgoing: Tube::new(),\n-                    };\n-                    Ok(p.install())\n-                }\n-                n => Err(UvError(n))\n+        let pipe = PipeWatcher::new(loop_, false);\n+        match unsafe {\n+            uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p))\n+        } {\n+            0 => {\n+                // If successful, unwrap the PipeWatcher because we control how\n+                // we close the pipe differently. We can't rely on\n+                // StreamWatcher's default close method.\n+                let p = ~PipeListener {\n+                    home: get_handle_to_current_scheduler!(),\n+                    pipe: pipe.unwrap(),\n+                    outgoing: Tube::new(),\n+                };\n+                Ok(p.install())\n             }\n+            n => Err(UvError(n))\n         }\n     }\n }\n@@ -245,7 +239,6 @@ mod tests {\n     use std::comm::oneshot;\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n     use std::rt::test::next_test_unix;\n-    use std::task;\n \n     use super::*;\n     use super::super::local_loop;\n@@ -314,7 +307,7 @@ mod tests {\n         let (port, chan) = oneshot();\n         let chan = Cell::new(chan);\n \n-        do task::spawn_unlinked { // plz no linked failure\n+        do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n             chan.take().send(());"}, {"sha": "0ce3e56c29dfcc94bbc421fe0dfd0dfe1aa78b3f", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -44,11 +44,6 @@ pub trait HomingIO {\n     fn go_to_IO_home(&mut self) -> uint {\n         use std::rt::sched::RunOnce;\n \n-        unsafe {\n-            let task: *mut Task = Local::unsafe_borrow();\n-            (*task).death.inhibit_kill((*task).unwinder.unwinding);\n-        }\n-\n         let _f = ForbidUnwind::new(\"going home\");\n \n         let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n@@ -127,11 +122,6 @@ impl Drop for HomingMissile {\n         }\n \n         util::ignore(f);\n-\n-        unsafe {\n-            let task: *mut Task = Local::unsafe_borrow();\n-            (*task).death.allow_kill((*task).unwinder.unwinding);\n-        }\n     }\n }\n "}, {"sha": "37329a3cfbd547655707402c789e71bbd4f9d4b0", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -565,7 +565,6 @@ mod tests {\n             ($name:expr => $code:block) => (\n                 {\n                     let mut t = task::task();\n-                    t.supervised();\n                     t.name($name);\n                     let res = do t.try $code;\n                     assert!(res.is_err());"}, {"sha": "4ee490a303b4e294aa1b429581ebdc8bca0a8312", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -1290,7 +1290,6 @@ mod tests {\n             ($name:expr => $code:block) => (\n                 {\n                     let mut t = task::task();\n-                    t.supervised();\n                     t.name($name);\n                     let res = do t.try $code;\n                     assert!(res.is_err());"}, {"sha": "cd90af113ec6172e285cfa84f55fe65bcb31a456", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -162,7 +162,7 @@ mod test {\n         for _ in range(0, 20) {\n             let (p, c) = comm::stream();\n             chans.push(c);\n-            do task::spawn_with(p) |p| {\n+            do task::spawn {\n                 // wait until all the tasks are ready to go.\n                 p.recv();\n "}, {"sha": "ac13b12c9addd0c28d35d7e948ec3ad0c08199a4", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 30, "deletions": 713, "changes": 743, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -155,176 +155,59 @@ use cell::Cell;\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n-use rt::task::{UnwindResult, Failure};\n-use task::spawn::Taskgroup;\n-use task::LinkedFailure;\n-use to_bytes::IterBytes;\n-use unstable::atomics::{AtomicUint, Relaxed};\n-use unstable::sync::{UnsafeArc, UnsafeArcSelf, UnsafeArcT, LittleLock};\n-use util;\n-\n-static KILLED_MSG: &'static str = \"killed by linked failure\";\n-\n-// State values for the 'killed' and 'unkillable' atomic flags below.\n-static KILL_RUNNING:    uint = 0;\n-static KILL_KILLED:     uint = 1;\n-static KILL_UNKILLABLE: uint = 2;\n-\n-struct KillFlag(AtomicUint);\n-type KillFlagHandle = UnsafeArc<KillFlag>;\n+use rt::task::UnwindResult;\n+use unstable::atomics::{AtomicUint, SeqCst};\n+use unstable::sync::UnsafeArc;\n \n /// A handle to a blocked task. Usually this means having the ~Task pointer by\n /// ownership, but if the task is killable, a killer can steal it at any time.\n pub enum BlockedTask {\n-    Unkillable(~Task),\n-    Killable(KillFlagHandle),\n-}\n-\n-// FIXME(#7544)(bblum): think about the cache efficiency of this\n-struct KillHandleInner {\n-    // Is the task running, blocked, or killed? Possible values:\n-    // * KILL_RUNNING    - Not unkillable, no kill pending.\n-    // * KILL_KILLED     - Kill pending.\n-    // * <ptr>           - A transmuted blocked ~Task pointer.\n-    // This flag is refcounted because it may also be referenced by a blocking\n-    // concurrency primitive, used to wake the task normally, whose reference\n-    // may outlive the handle's if the task is killed.\n-    killed: KillFlagHandle,\n-    // Has the task deferred kill signals? This flag guards the above one.\n-    // Possible values:\n-    // * KILL_RUNNING    - Not unkillable, no kill pending.\n-    // * KILL_KILLED     - Kill pending.\n-    // * KILL_UNKILLABLE - Kill signals deferred.\n-    unkillable: AtomicUint,\n-\n-    // Shared state between task and children for exit code propagation. These\n-    // are here so we can re-use the kill handle to implement watched children\n-    // tasks. Using a separate Arc-like would introduce extra atomic adds/subs\n-    // into common spawn paths, so this is just for speed.\n-\n-    // Locklessly accessed; protected by the enclosing refcount's barriers.\n-    any_child_failed: bool,\n-    // A lazy list, consuming which may unwrap() many child tombstones.\n-    child_tombstones: Option<proc() -> bool>,\n-    // Protects multiple children simultaneously creating tombstones.\n-    graveyard_lock: LittleLock,\n+    Owned(~Task),\n+    Shared(UnsafeArc<AtomicUint>),\n }\n \n-/// State shared between tasks used for task killing during linked failure.\n-#[deriving(Clone)]\n-pub struct KillHandle(UnsafeArc<KillHandleInner>);\n-\n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n-    // Shared among this task, its watched children, and any linked tasks who\n-    // might kill it. This is optional so we can take it by-value at exit time.\n-    kill_handle:     Option<KillHandle>,\n-    // Handle to a watching parent, if we have one, for exit code propagation.\n-    priv watching_parent: Option<KillHandle>,\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n     on_exit:         Option<proc(UnwindResult)>,\n-    // nesting level counter for task::unkillable calls (0 == killable).\n-    priv unkillable:      int,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n     priv wont_sleep:      int,\n-    // A \"spare\" handle to the kill flag inside the kill handle. Used during\n-    // blocking/waking as an optimization to avoid two xadds on the refcount.\n-    priv spare_kill_flag: Option<KillFlagHandle>,\n-}\n-\n-impl Drop for KillFlag {\n-    // Letting a KillFlag with a task inside get dropped would leak the task.\n-    // We could free it here, but the task should get awoken by hand somehow.\n-    fn drop(&mut self) {\n-        match self.load(Relaxed) {\n-            KILL_RUNNING | KILL_KILLED => { },\n-            _ => rtabort!(\"can't drop kill flag with a blocked task inside!\"),\n-        }\n-    }\n-}\n-\n-// Whenever a task blocks, it swaps out its spare kill flag to use as the\n-// blocked task handle. So unblocking a task must restore that spare.\n-unsafe fn revive_task_ptr(task_ptr: uint, spare_flag: Option<KillFlagHandle>) -> ~Task {\n-    let mut task: ~Task = cast::transmute(task_ptr);\n-    if task.death.spare_kill_flag.is_none() {\n-        task.death.spare_kill_flag = spare_flag;\n-    } else {\n-        // A task's spare kill flag is not used for blocking in one case:\n-        // when an unkillable task blocks on select. In this case, a separate\n-        // one was created, which we now discard.\n-        rtassert!(task.death.unkillable > 0);\n-    }\n-    task\n }\n \n impl BlockedTask {\n     /// Returns Some if the task was successfully woken; None if already killed.\n     pub fn wake(self) -> Option<~Task> {\n         match self {\n-            Unkillable(task) => Some(task),\n-            Killable(flag_arc) => {\n-                let flag = unsafe { &mut **flag_arc.get() };\n-                match flag.swap(KILL_RUNNING, Relaxed) {\n-                    KILL_RUNNING => None, // woken from select(), perhaps\n-                    KILL_KILLED  => None, // a killer stole it already\n-                    task_ptr     =>\n-                        Some(unsafe { revive_task_ptr(task_ptr, Some(flag_arc)) })\n+            Owned(task) => Some(task),\n+            Shared(arc) => unsafe {\n+                match (*arc.get()).swap(0, SeqCst) {\n+                    0 => None,\n+                    n => cast::transmute(n),\n                 }\n             }\n         }\n     }\n \n     /// Create a blocked task, unless the task was already killed.\n-    pub fn try_block(mut task: ~Task) -> Either<~Task, BlockedTask> {\n-        // NB: As an optimization, we could give a free pass to being unkillable\n-        // to tasks whose taskgroups haven't been initialized yet, but that\n-        // introduces complications with select() and with the test cases below,\n-        // and it's not clear the uncommon performance boost is worth it.\n-        if task.death.unkillable > 0 {\n-            Right(Unkillable(task))\n-        } else {\n-            rtassert!(task.death.kill_handle.is_some());\n-            unsafe {\n-                // The inverse of 'revive', above, occurs here.\n-                // The spare kill flag will usually be Some, unless the task was\n-                // already killed, in which case the killer will have deferred\n-                // creating a new one until whenever it blocks during unwinding.\n-                let flag_arc = match task.death.spare_kill_flag.take() {\n-                    Some(spare_flag) => spare_flag,\n-                    None => {\n-                        // A task that kills us won't have a spare kill flag to\n-                        // give back to us, so we restore it ourselves here. This\n-                        // situation should only arise when we're already failing.\n-                        rtassert!(task.unwinder.unwinding);\n-                        (*task.death.kill_handle.get_ref().get()).killed.clone()\n-                    }\n-                };\n-                let flag     = &mut **flag_arc.get();\n-                let task_ptr = cast::transmute(task);\n-                // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n-                match flag.compare_and_swap(KILL_RUNNING, task_ptr, Relaxed) {\n-                    KILL_RUNNING => Right(Killable(flag_arc)),\n-                    KILL_KILLED  => Left(revive_task_ptr(task_ptr, Some(flag_arc))),\n-                    x            => rtabort!(\"can't block task! kill flag = {}\", x),\n-                }\n-            }\n-        }\n+    pub fn block(task: ~Task) -> BlockedTask {\n+        Owned(task)\n     }\n \n     /// Converts one blocked task handle to a list of many handles to the same.\n     pub fn make_selectable(self, num_handles: uint) -> ~[BlockedTask] {\n         let handles = match self {\n-            Unkillable(task) => {\n-                let flag = unsafe { KillFlag(AtomicUint::new(cast::transmute(task))) };\n+            Owned(task) => {\n+                let flag = unsafe {\n+                    AtomicUint::new(cast::transmute(task))\n+                };\n                 UnsafeArc::newN(flag, num_handles)\n             }\n-            Killable(flag_arc) => flag_arc.cloneN(num_handles),\n+            Shared(arc) => arc.cloneN(num_handles),\n         };\n         // Even if the task was unkillable before, we use 'Killable' because\n         // multiple pipes will have handles. It does not really mean killable.\n-        handles.move_iter().map(|x| Killable(x)).collect()\n+        handles.move_iter().map(|x| Shared(x)).collect()\n     }\n \n     // This assertion has two flavours because the wake involves an atomic op.\n@@ -337,16 +220,14 @@ impl BlockedTask {\n     /// Convert to an unsafe uint value. Useful for storing in a pipe's state flag.\n     #[inline]\n     pub unsafe fn cast_to_uint(self) -> uint {\n-        // Use the low bit to distinguish the enum variants, to save a second\n-        // allocation in the indestructible case.\n         match self {\n-            Unkillable(task) => {\n+            Owned(task) => {\n                 let blocked_task_ptr: uint = cast::transmute(task);\n                 rtassert!(blocked_task_ptr & 0x1 == 0);\n                 blocked_task_ptr\n-            },\n-            Killable(flag_arc) => {\n-                let blocked_task_ptr: uint = cast::transmute(~flag_arc);\n+            }\n+            Shared(arc) => {\n+                let blocked_task_ptr: uint = cast::transmute(~arc);\n                 rtassert!(blocked_task_ptr & 0x1 == 0);\n                 blocked_task_ptr | 0x1\n             }\n@@ -357,318 +238,29 @@ impl BlockedTask {\n     #[inline]\n     pub unsafe fn cast_from_uint(blocked_task_ptr: uint) -> BlockedTask {\n         if blocked_task_ptr & 0x1 == 0 {\n-            Unkillable(cast::transmute(blocked_task_ptr))\n-        } else {\n-            let ptr: ~KillFlagHandle = cast::transmute(blocked_task_ptr & !0x1);\n-            match ptr {\n-                ~flag_arc => Killable(flag_arc)\n-            }\n-        }\n-    }\n-}\n-\n-// So that KillHandle can be hashed in the taskgroup bookkeeping code.\n-impl IterBytes for KillHandle {\n-    fn iter_bytes(&self, lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n-        self.data.iter_bytes(lsb0, f)\n-    }\n-}\n-impl Eq for KillHandle {\n-    #[inline] fn eq(&self, other: &KillHandle) -> bool { self.data.eq(&other.data) }\n-    #[inline] fn ne(&self, other: &KillHandle) -> bool { self.data.ne(&other.data) }\n-}\n-\n-impl KillHandle {\n-    pub fn new() -> (KillHandle, KillFlagHandle) {\n-        let (flag, flag_clone) =\n-            UnsafeArc::new2(KillFlag(AtomicUint::new(KILL_RUNNING)));\n-        let handle = KillHandle(UnsafeArc::new(KillHandleInner {\n-            // Linked failure fields\n-            killed:     flag,\n-            unkillable: AtomicUint::new(KILL_RUNNING),\n-            // Exit code propagation fields\n-            any_child_failed: false,\n-            child_tombstones: None,\n-            graveyard_lock:   LittleLock::new(),\n-        }));\n-        (handle, flag_clone)\n-    }\n-\n-    // Will begin unwinding if a kill signal was received, unless already_failing.\n-    // This can't be used recursively, because a task which sees a KILLED\n-    // signal must fail immediately, which an already-unkillable task can't do.\n-    #[inline]\n-    pub fn inhibit_kill(&mut self, already_failing: bool) {\n-        let inner = unsafe { &mut *self.get() };\n-        // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n-        // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n-        match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, Relaxed) {\n-            KILL_RUNNING    => { }, // normal case\n-            KILL_KILLED     => if !already_failing { fail!(\"{}\", KILLED_MSG) },\n-            _               => rtabort!(\"inhibit_kill: task already unkillable\"),\n-        }\n-    }\n-\n-    // Will begin unwinding if a kill signal was received, unless already_failing.\n-    #[inline]\n-    pub fn allow_kill(&mut self, already_failing: bool) {\n-        let inner = unsafe { &mut *self.get() };\n-        // Expect flag to contain UNKILLABLE. If KILLED, it should stay KILLED.\n-        // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n-        match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, Relaxed) {\n-            KILL_UNKILLABLE => { }, // normal case\n-            KILL_KILLED     => if !already_failing { fail!(\"{}\", KILLED_MSG) },\n-            _               => rtabort!(\"allow_kill: task already killable\"),\n-        }\n-    }\n-\n-    // Send a kill signal to the handle's owning task. Returns the task itself\n-    // if it was blocked and needs punted awake. To be called by other tasks.\n-    pub fn kill(&mut self) -> Option<~Task> {\n-        let inner = unsafe { &mut *self.get() };\n-        if inner.unkillable.swap(KILL_KILLED, Relaxed) == KILL_RUNNING {\n-            // Got in. Allowed to try to punt the task awake.\n-            let flag = unsafe { &mut *inner.killed.get() };\n-            match flag.swap(KILL_KILLED, Relaxed) {\n-                // Task either not blocked or already taken care of.\n-                KILL_RUNNING | KILL_KILLED => None,\n-                // Got ownership of the blocked task.\n-                // While the usual 'wake' path can just pass back the flag\n-                // handle, we (the slower kill path) haven't an extra one lying\n-                // around. The task will wake up without a spare.\n-                task_ptr => Some(unsafe { revive_task_ptr(task_ptr, None) }),\n-            }\n+            Owned(cast::transmute(blocked_task_ptr))\n         } else {\n-            // Otherwise it was either unkillable or already killed. Somebody\n-            // else was here first who will deal with the kill signal.\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn killed(&self) -> bool {\n-        // Called every context switch, so shouldn't report true if the task\n-        // is unkillable with a kill signal pending.\n-        let inner = unsafe { &*self.get() };\n-        let flag  = unsafe { &*inner.killed.get() };\n-        // A barrier-related concern here is that a task that gets killed\n-        // awake needs to see the killer's write of KILLED to this flag. This\n-        // is analogous to receiving a pipe payload; the appropriate barrier\n-        // should happen when enqueueing the task.\n-        flag.load(Relaxed) == KILL_KILLED\n-    }\n-\n-    pub fn notify_immediate_failure(&mut self) {\n-        // A benign data race may happen here if there are failing sibling\n-        // tasks that were also spawned-watched. The refcount's write barriers\n-        // in UnsafeArc ensure that this write will be seen by the\n-        // unwrapper/destructor, whichever task may unwrap it.\n-        unsafe { (*self.get()).any_child_failed = true; }\n-    }\n-\n-    // For use when a task does not need to collect its children's exit\n-    // statuses, but the task has a parent which might want them.\n-    pub fn reparent_children_to(self, parent: &mut KillHandle) {\n-        // Optimistic path: If another child of the parent's already failed,\n-        // we don't need to worry about any of this.\n-        if unsafe { (*parent.get()).any_child_failed } {\n-            return;\n-        }\n-\n-        // Try to see if all our children are gone already.\n-        match self.try_unwrap() {\n-            // Couldn't unwrap; children still alive. Reparent entire handle as\n-            // our own tombstone, to be unwrapped later.\n-            UnsafeArcSelf(this) => {\n-                let this = Cell::new(this); // :(\n-                do add_lazy_tombstone(parent) |other_tombstones| {\n-                    let this = Cell::new(this.take()); // :(\n-                    let others = Cell::new(other_tombstones); // :(\n-                    || {\n-                        // Prefer to check tombstones that were there first,\n-                        // being \"more fair\" at the expense of tail-recursion.\n-                        others.take().map_default(true, |f| f()) && {\n-                            let mut inner = this.take().unwrap();\n-                            (!inner.any_child_failed) &&\n-                                inner.child_tombstones.take().map_default(true, |f| f())\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Whether or not all children exited, one or more already failed.\n-            UnsafeArcT(KillHandleInner { any_child_failed: true, _ }) => {\n-                parent.notify_immediate_failure();\n-            }\n-\n-            // All children exited, but some left behind tombstones that we\n-            // don't want to wait on now. Give them to our parent.\n-            UnsafeArcT(KillHandleInner { any_child_failed: false,\n-                                         child_tombstones: Some(f), _ }) => {\n-                let f = Cell::new(f); // :(\n-                do add_lazy_tombstone(parent) |other_tombstones| {\n-                    let f = Cell::new(f.take()); // :(\n-                    let others = Cell::new(other_tombstones); // :(\n-                    || {\n-                        // Prefer fairness to tail-recursion, as in above case.\n-                        others.take().map_default(true, |f| f()) &&\n-                            f.take()()\n-                    }\n-                }\n-            }\n-\n-            // All children exited, none failed. Nothing to do!\n-            UnsafeArcT(KillHandleInner { any_child_failed: false,\n-                                         child_tombstones: None, _ }) => { }\n-        }\n-\n-        // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n-        #[inline]\n-        fn add_lazy_tombstone(parent: &mut KillHandle,\n-                              blk: |Option<proc() -> bool>| -> proc() -> bool)\n-                              {\n-            let inner: &mut KillHandleInner = unsafe { &mut *parent.get() };\n-            unsafe {\n-                do inner.graveyard_lock.lock {\n-                    // Update the current \"head node\" of the lazy list.\n-                    inner.child_tombstones =\n-                        Some(blk(util::replace(&mut inner.child_tombstones, None)));\n-                }\n-            }\n+            let ptr: ~UnsafeArc<AtomicUint> = cast::transmute(blocked_task_ptr & !1);\n+            Shared(*ptr)\n         }\n     }\n }\n \n impl Death {\n     pub fn new() -> Death {\n-        let (handle, spare) = KillHandle::new();\n-        Death {\n-            kill_handle:     Some(handle),\n-            watching_parent: None,\n-            on_exit:         None,\n-            unkillable:      0,\n-            wont_sleep:      0,\n-            spare_kill_flag: Some(spare),\n-        }\n-    }\n-\n-    pub fn new_child(&self) -> Death {\n-        // FIXME(#7327)\n-        let (handle, spare) = KillHandle::new();\n         Death {\n-            kill_handle:     Some(handle),\n-            watching_parent: self.kill_handle.clone(),\n             on_exit:         None,\n-            unkillable:      0,\n             wont_sleep:      0,\n-            spare_kill_flag: Some(spare),\n         }\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: UnwindResult, group: Option<Taskgroup>) {\n-        // This may run after the task has already failed, so even though the\n-        // task appears to need to be killed, the scheduler should not fail us\n-        // when we block to unwrap.\n-        // (XXX: Another less-elegant reason for doing this is so that the use\n-        // of the LittleLock in reparent_children_to doesn't need to access the\n-        // unkillable flag in the kill_handle, since we'll have removed it.)\n-        rtassert!(self.unkillable == 0);\n-        self.unkillable = 1;\n-\n-        // NB. See corresponding comment at the callsite in task.rs.\n-        // FIXME(#8192): Doesn't work with \"let _ = ...\"\n-        { use util; util::ignore(group); }\n-\n-        let mut success = result.is_success();\n-        let mut result = Cell::new(result);\n-\n-        // Step 1. Decide if we need to collect child failures synchronously.\n-        do self.on_exit.take().map |on_exit| {\n-            if success {\n-                // We succeeded, but our children might not. Need to wait for them.\n-                let mut inner = self.kill_handle.take_unwrap().unwrap();\n-\n-                if inner.any_child_failed {\n-                    success = false;\n-                } else {\n-                    // Lockless access to tombstones protected by unwrap barrier.\n-                    success = inner.child_tombstones.take().map_default(true, |f| f());\n-                }\n+    pub fn collect_failure(&mut self, result: UnwindResult) {\n+        let result = Cell::new(result);\n \n-                if !success {\n-                    result = Cell::new(Failure(~LinkedFailure as ~Any));\n-                }\n-            }\n+        do self.on_exit.take().map |on_exit| {\n             on_exit(result.take());\n         };\n-\n-        // Step 2. Possibly alert possibly-watching parent to failure status.\n-        // Note that as soon as parent_handle goes out of scope, the parent\n-        // can successfully unwrap its handle and collect our reported status.\n-        do self.watching_parent.take().map |mut parent_handle| {\n-            if success {\n-                // Our handle might be None if we had an exit callback, and\n-                // already unwrapped it. But 'success' being true means no\n-                // child failed, so there's nothing to do (see below case).\n-                do self.kill_handle.take().map |own_handle| {\n-                    own_handle.reparent_children_to(&mut parent_handle);\n-                };\n-            } else {\n-                // Can inform watching parent immediately that we failed.\n-                // (Note the importance of non-failing tasks NOT writing\n-                // 'false', which could obscure another task's failure.)\n-                parent_handle.notify_immediate_failure();\n-            }\n-        };\n-\n-        // Can't use allow_kill directly; that would require the kill handle.\n-        rtassert!(self.unkillable == 1);\n-        self.unkillable = 0;\n-    }\n-\n-    /// Fails if a kill signal was received.\n-    #[inline]\n-    pub fn check_killed(&self, already_failing: bool) {\n-        match self.kill_handle {\n-            Some(ref kill_handle) =>\n-                // The task may be both unkillable and killed if it does some\n-                // synchronization during unwinding or cleanup (for example,\n-                // sending on a notify port). In that case failing won't help.\n-                if self.unkillable == 0 && (!already_failing) && kill_handle.killed() {\n-                    fail!(\"{}\", KILLED_MSG);\n-                },\n-            // This may happen during task death (see comments in collect_failure).\n-            None => rtassert!(self.unkillable > 0),\n-        }\n-    }\n-\n-    /// Enter a possibly-nested unkillable section of code.\n-    /// All calls must be paired with a subsequent call to allow_kill.\n-    #[inline]\n-    pub fn inhibit_kill(&mut self, already_failing: bool) {\n-        self.unkillable += 1;\n-        // May fail, hence must happen *after* incrementing the counter\n-        if self.unkillable == 1 {\n-            rtassert!(self.kill_handle.is_some());\n-            self.kill_handle.get_mut_ref().inhibit_kill(already_failing);\n-        }\n-    }\n-\n-    /// Exit a possibly-nested unkillable section of code.\n-    /// All calls must be paired with a preceding call to inhibit_kill.\n-    #[inline]\n-    pub fn allow_kill(&mut self, already_failing: bool) {\n-        if self.unkillable == 0 {\n-            // we need to decrement the counter before failing.\n-            self.unkillable -= 1;\n-            fail!(\"Cannot enter a rekillable() block without a surrounding unkillable()\");\n-        }\n-        self.unkillable -= 1;\n-        if self.unkillable == 0 {\n-            rtassert!(self.kill_handle.is_some());\n-            self.kill_handle.get_mut_ref().allow_kill(already_failing);\n-        }\n     }\n \n     /// Enter a possibly-nested \"atomic\" section of code. Just for assertions.\n@@ -699,296 +291,21 @@ impl Death {\n impl Drop for Death {\n     fn drop(&mut self) {\n         // Mustn't be in an atomic or unkillable section at task death.\n-        rtassert!(self.unkillable == 0);\n         rtassert!(self.wont_sleep == 0);\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    #[allow(unused_mut)];\n-    use cell::Cell;\n     use rt::test::*;\n     use super::*;\n-    use util;\n-\n-    // Test cases don't care about the spare killed flag.\n-    fn make_kill_handle() -> KillHandle { let (h,_) = KillHandle::new(); h }\n-\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn no_tombstone_success() {\n-        do run_in_newsched_task {\n-            // Tests case 4 of the 4-way match in reparent_children.\n-            let mut parent = make_kill_handle();\n-            let mut child  = make_kill_handle();\n-\n-            // Without another handle to child, the try unwrap should succeed.\n-            child.reparent_children_to(&mut parent);\n-            let mut parent_inner = parent.unwrap();\n-            assert!(parent_inner.child_tombstones.is_none());\n-            assert!(parent_inner.any_child_failed == false);\n-        }\n-    }\n-    #[test]\n-    fn no_tombstone_failure() {\n-        do run_in_newsched_task {\n-            // Tests case 2 of the 4-way match in reparent_children.\n-            let mut parent = make_kill_handle();\n-            let mut child  = make_kill_handle();\n-\n-            child.notify_immediate_failure();\n-            // Without another handle to child, the try unwrap should succeed.\n-            child.reparent_children_to(&mut parent);\n-            let mut parent_inner = parent.unwrap();\n-            assert!(parent_inner.child_tombstones.is_none());\n-            // Immediate failure should have been propagated.\n-            assert!(parent_inner.any_child_failed);\n-        }\n-    }\n-    #[test]\n-    fn no_tombstone_because_sibling_already_failed() {\n-        do run_in_newsched_task {\n-            // Tests \"case 0, the optimistic path in reparent_children.\n-            let mut parent = make_kill_handle();\n-            let mut child1 = make_kill_handle();\n-            let mut child2 = make_kill_handle();\n-            let mut link   = child2.clone();\n-\n-            // Should set parent's child_failed flag\n-            child1.notify_immediate_failure();\n-            child1.reparent_children_to(&mut parent);\n-            // Should bypass trying to unwrap child2 entirely.\n-            // Otherwise, due to 'link', it would try to tombstone.\n-            child2.reparent_children_to(&mut parent);\n-            // Should successfully unwrap even though 'link' is still alive.\n-            let mut parent_inner = parent.unwrap();\n-            assert!(parent_inner.child_tombstones.is_none());\n-            // Immediate failure should have been propagated by first child.\n-            assert!(parent_inner.any_child_failed);\n-            util::ignore(link);\n-        }\n-    }\n-    #[test]\n-    fn one_tombstone_success() {\n-        do run_in_newsched_task {\n-            let mut parent = make_kill_handle();\n-            let mut child  = make_kill_handle();\n-            let mut link   = child.clone();\n-\n-            // Creates 1 tombstone. Existence of 'link' makes try-unwrap fail.\n-            child.reparent_children_to(&mut parent);\n-            // Let parent collect tombstones.\n-            util::ignore(link);\n-            // Must have created a tombstone\n-            let mut parent_inner = parent.unwrap();\n-            assert!(parent_inner.child_tombstones.take_unwrap()());\n-            assert!(parent_inner.any_child_failed == false);\n-        }\n-    }\n-    #[test]\n-    fn one_tombstone_failure() {\n-        do run_in_newsched_task {\n-            let mut parent = make_kill_handle();\n-            let mut child  = make_kill_handle();\n-            let mut link   = child.clone();\n-\n-            // Creates 1 tombstone. Existence of 'link' makes try-unwrap fail.\n-            child.reparent_children_to(&mut parent);\n-            // Must happen after tombstone to not be immediately propagated.\n-            link.notify_immediate_failure();\n-            // Let parent collect tombstones.\n-            util::ignore(link);\n-            // Must have created a tombstone\n-            let mut parent_inner = parent.unwrap();\n-            // Failure must be seen in the tombstone.\n-            assert!(parent_inner.child_tombstones.take_unwrap()() == false);\n-            assert!(parent_inner.any_child_failed == false);\n-        }\n-    }\n-    #[test]\n-    fn two_tombstones_success() {\n-        do run_in_newsched_task {\n-            let mut parent = make_kill_handle();\n-            let mut middle = make_kill_handle();\n-            let mut child  = make_kill_handle();\n-            let mut link   = child.clone();\n-\n-            child.reparent_children_to(&mut middle); // case 1 tombstone\n-            // 'middle' should try-unwrap okay, but still have to reparent.\n-            middle.reparent_children_to(&mut parent); // case 3 tombston\n-            // Let parent collect tombstones.\n-            util::ignore(link);\n-            // Must have created a tombstone\n-            let mut parent_inner = parent.unwrap();\n-            assert!(parent_inner.child_tombstones.take_unwrap()());\n-            assert!(parent_inner.any_child_failed == false);\n-        }\n-    }\n-    #[test]\n-    fn two_tombstones_failure() {\n-        do run_in_newsched_task {\n-            let mut parent = make_kill_handle();\n-            let mut middle = make_kill_handle();\n-            let mut child  = make_kill_handle();\n-            let mut link   = child.clone();\n-\n-            child.reparent_children_to(&mut middle); // case 1 tombstone\n-            // Must happen after tombstone to not be immediately propagated.\n-            link.notify_immediate_failure();\n-            // 'middle' should try-unwrap okay, but still have to reparent.\n-            middle.reparent_children_to(&mut parent); // case 3 tombstone\n-            // Let parent collect tombstones.\n-            util::ignore(link);\n-            // Must have created a tombstone\n-            let mut parent_inner = parent.unwrap();\n-            // Failure must be seen in the tombstone.\n-            assert!(parent_inner.child_tombstones.take_unwrap()() == false);\n-            assert!(parent_inner.any_child_failed == false);\n-        }\n-    }\n-\n-    // Task killing tests\n-\n-    #[test]\n-    fn kill_basic() {\n-        do run_in_newsched_task {\n-            let mut handle = make_kill_handle();\n-            assert!(!handle.killed());\n-            assert!(handle.kill().is_none());\n-            assert!(handle.killed());\n-        }\n-    }\n-\n-    #[test]\n-    fn double_kill() {\n-        do run_in_newsched_task {\n-            let mut handle = make_kill_handle();\n-            assert!(!handle.killed());\n-            assert!(handle.kill().is_none());\n-            assert!(handle.killed());\n-            assert!(handle.kill().is_none());\n-            assert!(handle.killed());\n-        }\n-    }\n-\n-    #[test]\n-    fn unkillable_after_kill() {\n-        do run_in_newsched_task {\n-            let mut handle = make_kill_handle();\n-            assert!(handle.kill().is_none());\n-            assert!(handle.killed());\n-            let handle_cell = Cell::new(handle);\n-            let result = do spawntask_try {\n-                handle_cell.take().inhibit_kill(false);\n-            };\n-            assert!(result.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn unkillable_during_kill() {\n-        do run_in_newsched_task {\n-            let mut handle = make_kill_handle();\n-            handle.inhibit_kill(false);\n-            assert!(handle.kill().is_none());\n-            assert!(!handle.killed());\n-            let handle_cell = Cell::new(handle);\n-            let result = do spawntask_try {\n-                handle_cell.take().allow_kill(false);\n-            };\n-            assert!(result.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn unkillable_before_kill() {\n-        do run_in_newsched_task {\n-            let mut handle = make_kill_handle();\n-            handle.inhibit_kill(false);\n-            handle.allow_kill(false);\n-            assert!(handle.kill().is_none());\n-            assert!(handle.killed());\n-        }\n-    }\n \n     // Task blocking tests\n \n     #[test]\n     fn block_and_wake() {\n-        do with_test_task |mut task| {\n-            BlockedTask::try_block(task).unwrap_right().wake().unwrap()\n-        }\n-    }\n-\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn block_and_get_killed() {\n-        do with_test_task |mut task| {\n-            let mut handle = task.death.kill_handle.get_ref().clone();\n-            let result = BlockedTask::try_block(task).unwrap_right();\n-            let task = handle.kill().unwrap();\n-            assert!(result.wake().is_none());\n-            task\n-        }\n-    }\n-\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn block_already_killed() {\n-        do with_test_task |mut task| {\n-            let mut handle = task.death.kill_handle.get_ref().clone();\n-            assert!(handle.kill().is_none());\n-            BlockedTask::try_block(task).unwrap_left()\n-        }\n-    }\n-\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn block_unkillably_and_get_killed() {\n-        do with_test_task |mut task| {\n-            let mut handle = task.death.kill_handle.get_ref().clone();\n-            task.death.inhibit_kill(false);\n-            let result = BlockedTask::try_block(task).unwrap_right();\n-            assert!(handle.kill().is_none());\n-            let mut task = result.wake().unwrap();\n-            // This call wants to fail, but we can't have that happen since\n-            // we're not running in a newsched task, so we can't even use\n-            // spawntask_try. But the failing behaviour is already tested\n-            // above, in unkillable_during_kill(), so we punt on it here.\n-            task.death.allow_kill(true);\n-            task\n-        }\n-    }\n-\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn block_on_pipe() {\n-        // Tests the \"killable\" path of casting to/from uint.\n-        do run_in_newsched_task {\n-            do with_test_task |mut task| {\n-                let result = BlockedTask::try_block(task).unwrap_right();\n-                let result = unsafe { result.cast_to_uint() };\n-                let result = unsafe { BlockedTask::cast_from_uint(result) };\n-                result.wake().unwrap()\n-            }\n-        }\n-    }\n-\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn block_unkillably_on_pipe() {\n-        // Tests the \"indestructible\" path of casting to/from uint.\n-        do run_in_newsched_task {\n-            do with_test_task |mut task| {\n-                task.death.inhibit_kill(false);\n-                let result = BlockedTask::try_block(task).unwrap_right();\n-                let result = unsafe { result.cast_to_uint() };\n-                let result = unsafe { BlockedTask::cast_from_uint(result) };\n-                let mut task = result.wake().unwrap();\n-                task.death.allow_kill(false);\n-                task\n-            }\n+        do with_test_task |task| {\n+            BlockedTask::block(task).wake().unwrap()\n         }\n     }\n }"}, {"sha": "ad5c69e9a0c2bf2b6a187481d41e31e20614a187", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -88,7 +88,7 @@ pub use self::util::set_exit_status;\n pub use self::util::default_sched_threads;\n \n // Re-export of the functionality in the kill module\n-pub use self::kill::{KillHandle, BlockedTask};\n+pub use self::kill::BlockedTask;\n \n // XXX: these probably shouldn't be public...\n #[doc(hidden)]"}, {"sha": "1caaf77bd9671cfe74ce7ff27c08d4bb2e63d359", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use either::{Left, Right};\n use option::{Option, Some, None};\n use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n use clone::Clone;\n@@ -621,9 +620,6 @@ impl Scheduler {\n         unsafe {\n             let task: *mut Task = Local::unsafe_borrow();\n             (*task).sched.get_mut_ref().run_cleanup_job();\n-\n-            // Must happen after running the cleanup job (of course).\n-            (*task).death.check_killed((*task).unwinder.unwinding);\n         }\n     }\n \n@@ -689,14 +685,9 @@ impl Scheduler {\n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n                                          f: |&mut Scheduler, BlockedTask|) {\n         // This is where we convert the BlockedTask-taking closure into one\n-        // that takes just a Task, and is aware of the block-or-killed protocol.\n+        // that takes just a Task\n         do self.change_task_context(next_task) |sched, task| {\n-            // Task might need to receive a kill signal instead of blocking.\n-            // We can call the \"and_then\" only if it blocks successfully.\n-            match BlockedTask::try_block(task) {\n-                Left(killed_task) => sched.enqueue_task(killed_task),\n-                Right(blocked_task) => f(sched, blocked_task),\n-            }\n+            f(sched, BlockedTask::block(task))\n         }\n     }\n "}, {"sha": "bc9496b16cde19a1700c65f1348df52c4446acca", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -36,8 +36,6 @@ use rt::logging::StdErrLogger;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n use send_str::SendStr;\n-use task::LinkedFailure;\n-use task::spawn::Taskgroup;\n use unstable::finally::Finally;\n \n // The Task struct represents all state associated with a rust\n@@ -52,7 +50,6 @@ pub struct Task {\n     storage: LocalStorage,\n     logger: Option<StdErrLogger>,\n     unwinder: Unwinder,\n-    taskgroup: Option<Taskgroup>,\n     death: Death,\n     destroyed: bool,\n     name: Option<SendStr>,\n@@ -188,7 +185,6 @@ impl Task {\n             storage: LocalStorage(None),\n             logger: None,\n             unwinder: Unwinder { unwinding: false, cause: None },\n-            taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n             coroutine: Some(Coroutine::empty()),\n@@ -223,7 +219,6 @@ impl Task {\n             storage: LocalStorage(None),\n             logger: None,\n             unwinder: Unwinder { unwinding: false, cause: None },\n-            taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n             name: None,\n@@ -246,9 +241,7 @@ impl Task {\n             storage: LocalStorage(None),\n             logger: None,\n             unwinder: Unwinder { unwinding: false, cause: None },\n-            taskgroup: None,\n-            // FIXME(#7544) make watching optional\n-            death: self.death.new_child(),\n+            death: Death::new(),\n             destroyed: false,\n             name: None,\n             coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n@@ -333,11 +326,7 @@ impl Task {\n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n \n-        // NB. We pass the taskgroup into death so that it can be dropped while\n-        // the unkillable counter is set. This is necessary for when the\n-        // taskgroup destruction code drops references on KillHandles, which\n-        // might require using unkillable (to synchronize with an unwrapper).\n-        self.death.collect_failure(self.unwinder.to_unwind_result(), self.taskgroup.take());\n+        self.death.collect_failure(self.unwinder.to_unwind_result());\n         self.destroyed = true;\n     }\n \n@@ -660,10 +649,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n                 Some(s) => *s,\n                 None => match msg.as_ref::<~str>() {\n                     Some(s) => s.as_slice(),\n-                    None => match msg.as_ref::<LinkedFailure>() {\n-                        Some(*) => \"linked failure\",\n-                        None => \"~Any\",\n-                    }\n+                    None => \"~Any\",\n                 }\n             };\n \n@@ -785,16 +771,6 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    fn linked_failure() {\n-        do run_in_newsched_task() {\n-            let res = do spawntask_try {\n-                spawntask_random(|| fail!());\n-            };\n-            assert!(res.is_err());\n-        }\n-    }\n-\n     #[test]\n     fn heap_cycles() {\n         use option::{Option, Some, None};"}, {"sha": "5b3ba1e6f97f827370d6aecfe6759a8347e76909", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -21,7 +21,6 @@ use io;\n use libc::{pid_t, c_int};\n use libc;\n use prelude::*;\n-use task;\n \n /**\n  * A value representing a child process.\n@@ -221,21 +220,15 @@ impl Process {\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n \n-        // FIXME(#910, #8674): right now I/O is incredibly brittle when it comes\n-        //      to linked failure, so these tasks must be spawn so they're not\n-        //      affected by linked failure. If these are removed, then the\n-        //      runtime may never exit because linked failure will cause some\n-        //      SchedHandle structures to not get destroyed, meaning that\n-        //      there's always an async watcher available.\n-        do task::spawn_unlinked {\n+        do spawn {\n             do io::ignore_io_error {\n                 match error.take() {\n                     Some(ref mut e) => ch.send((2, e.read_to_end())),\n                     None => ch.send((2, ~[]))\n                 }\n             }\n         }\n-        do task::spawn_unlinked {\n+        do spawn {\n             do io::ignore_io_error {\n                 match output.take() {\n                     Some(ref mut e) => ch_clone.send((1, e.read_to_end())),"}, {"sha": "25f8c5a2875143e598e5d7612dbcb9ef33c66123", "filename": "src/libstd/select.rs", "status": "modified", "additions": 29, "deletions": 79, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -21,7 +21,6 @@ use rt::local::Local;\n use rt::rtio::EventLoop;\n use rt::sched::Scheduler;\n use rt::shouldnt_be_public::{SelectInner, SelectPortInner};\n-use task;\n use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};\n \n@@ -79,11 +78,10 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n             do sched.event_loop.callback { c.take().send_deferred(()) }\n         }\n     }).finally {\n-        let p = Cell::new(p.take());\n         // Unkillable is necessary not because getting killed is dangerous here,\n         // but to force the recv not to use the same kill-flag that we used for\n         // selecting. Otherwise a user-sender could spuriously wakeup us here.\n-        do task::unkillable { p.take().recv(); }\n+        p.take().recv();\n     }\n \n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n@@ -230,63 +228,50 @@ mod test {\n     }\n \n     #[test]\n-    fn select_unkillable() {\n+    fn select_simple() {\n         do run_in_uv_task {\n-            do task::unkillable { select_helper(2, [1]) }\n+            select_helper(2, [1])\n         }\n     }\n \n     /* blocking select tests */\n \n     #[test]\n     fn select_blocking() {\n-        select_blocking_helper(true);\n-        select_blocking_helper(false);\n-\n-        fn select_blocking_helper(killable: bool) {\n-            do run_in_uv_task {\n-                let (p1,_c) = oneshot();\n-                let (p2,c2) = oneshot();\n-                let mut ports = [p1,p2];\n-\n-                let (p3,c3) = oneshot();\n-                let (p4,c4) = oneshot();\n-\n-                let x = Cell::new((c2, p3, c4));\n-                do task::spawn {\n-                    let (c2, p3, c4) = x.take();\n-                    p3.recv();   // handshake parent\n-                    c4.send(()); // normal receive\n-                    task::deschedule();\n-                    c2.send(()); // select receive\n-                }\n-\n-                // Try to block before child sends on c2.\n-                c3.send(());\n-                p4.recv();\n-                if killable {\n-                    assert!(select(ports) == 1);\n-                } else {\n-                    do task::unkillable { assert!(select(ports) == 1); }\n-                }\n+        do run_in_uv_task {\n+            let (p1,_c) = oneshot();\n+            let (p2,c2) = oneshot();\n+            let mut ports = [p1,p2];\n+\n+            let (p3,c3) = oneshot();\n+            let (p4,c4) = oneshot();\n+\n+            let x = Cell::new((c2, p3, c4));\n+            do task::spawn {\n+                let (c2, p3, c4) = x.take();\n+                p3.recv();   // handshake parent\n+                c4.send(()); // normal receive\n+                task::deschedule();\n+                c2.send(()); // select receive\n             }\n+\n+            // Try to block before child sends on c2.\n+            c3.send(());\n+            p4.recv();\n+            assert!(select(ports) == 1);\n         }\n     }\n \n     #[test]\n     fn select_racing_senders() {\n         static NUM_CHANS: uint = 10;\n \n-        select_racing_senders_helper(true,  ~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(false, ~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(true,  ~[0,1,2]);\n-        select_racing_senders_helper(false, ~[0,1,2]);\n-        select_racing_senders_helper(true,  ~[3,4,5,6]);\n-        select_racing_senders_helper(false, ~[3,4,5,6]);\n-        select_racing_senders_helper(true,  ~[7,8,9]);\n-        select_racing_senders_helper(false, ~[7,8,9]);\n+        select_racing_senders_helper(~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(~[0,1,2]);\n+        select_racing_senders_helper(~[3,4,5,6]);\n+        select_racing_senders_helper(~[7,8,9]);\n \n-        fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n+        fn select_racing_senders_helper(send_on_chans: ~[uint]) {\n             use rt::test::spawntask_random;\n \n             do run_in_uv_task {\n@@ -307,45 +292,10 @@ mod test {\n                             }\n                         }\n                         // nondeterministic result, but should succeed\n-                        if killable {\n-                            select(ports);\n-                        } else {\n-                            do task::unkillable { select(ports); }\n-                        }\n+                        select(ports);\n                     }\n                 }\n             }\n         }\n     }\n-\n-    #[test]\n-    fn select_killed() {\n-        do run_in_uv_task {\n-            let (success_p, success_c) = oneshot::<bool>();\n-            let success_c = Cell::new(success_c);\n-            do task::try {\n-                let success_c = Cell::new(success_c.take());\n-                do task::unkillable {\n-                    let (p,c) = oneshot();\n-                    let c = Cell::new(c);\n-                    do task::spawn {\n-                        let (dead_ps, dead_cs) = unzip(range(0u, 5).map(|_| oneshot::<()>()));\n-                        let mut ports = dead_ps;\n-                        select(ports); // should get killed; nothing should leak\n-                        c.take().send(()); // must not happen\n-                        // Make sure dead_cs doesn't get closed until after select.\n-                        let _ = dead_cs;\n-                    }\n-                    do task::spawn {\n-                        fail!(); // should kill sibling awake\n-                    }\n-\n-                    // wait for killed selector to close (NOT send on) its c.\n-                    // hope to send 'true'.\n-                    success_c.take().send(p.try_recv().is_none());\n-                }\n-            };\n-            assert!(success_p.recv());\n-        }\n-    }\n }"}, {"sha": "485fe9edf0eefc4e71a33f96de09404b8502fe25", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 7, "deletions": 642, "changes": 649, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -62,16 +62,12 @@ use rt::in_green_task_context;\n use rt::local::Local;\n use rt::task::{UnwindResult, Success, Failure};\n use send_str::{SendStr, IntoSendStr};\n-use unstable::finally::Finally;\n use util;\n \n #[cfg(test)] use any::Any;\n-#[cfg(test)] use cast;\n #[cfg(test)] use comm::SharedChan;\n-#[cfg(test)] use comm;\n #[cfg(test)] use ptr;\n #[cfg(test)] use result;\n-#[cfg(test)] use task;\n \n pub mod spawn;\n \n@@ -86,8 +82,6 @@ pub mod spawn;\n /// children tasks complete, recommend using a result future.\n pub type TaskResult = Result<(), ~Any>;\n \n-pub struct LinkedFailure;\n-\n pub struct TaskResultPort {\n     priv port: Port<UnwindResult>\n }\n@@ -141,24 +135,11 @@ pub struct SchedOpts {\n  *\n  * # Fields\n  *\n- * * linked - Propagate failure bidirectionally between child and parent.\n- *            True by default. If both this and 'supervised' are false, then\n- *            either task's failure will not affect the other (\"unlinked\").\n- *\n- * * supervised - Propagate failure unidirectionally from parent to child,\n- *                but not from child to parent. False by default.\n- *\n  * * watched - Make parent task collect exit status notifications from child\n  *             before reporting its own exit status. (This delays the parent\n  *             task's death and cleanup until after all transitively watched\n  *             children also exit.) True by default.\n  *\n- * * indestructible - Configures the task to ignore kill signals received from\n- *                    linked failure. This may cause process hangs during\n- *                    failure if not used carefully, but causes task blocking\n- *                    code paths (e.g. port recv() calls) to be faster by 2\n- *                    atomic operations. False by default.\n- *\n  * * notify_chan - Enable lifecycle notifications on the given channel\n  *\n  * * name - A name for the task-to-be, for identification in failure messages.\n@@ -169,10 +150,7 @@ pub struct SchedOpts {\n  *           scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n pub struct TaskOpts {\n-    priv linked: bool,\n-    priv supervised: bool,\n     priv watched: bool,\n-    priv indestructible: bool,\n     priv notify_chan: Option<Chan<UnwindResult>>,\n     name: Option<SendStr>,\n     sched: SchedOpts,\n@@ -191,13 +169,10 @@ pub struct TaskOpts {\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n-\n-// FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n     priv gen_body: Option<proc(v: proc()) -> proc()>,\n     priv can_not_copy: Option<util::NonCopyable>,\n-    priv consumed: bool,\n }\n \n /**\n@@ -210,60 +185,27 @@ pub fn task() -> TaskBuilder {\n         opts: default_task_opts(),\n         gen_body: None,\n         can_not_copy: None,\n-        consumed: false,\n     }\n }\n \n impl TaskBuilder {\n-    fn consume(&mut self) -> TaskBuilder {\n-        if self.consumed {\n-            fail!(\"Cannot copy a task_builder\"); // Fake move mode on self\n-        }\n-        self.consumed = true;\n+    fn consume(mut self) -> TaskBuilder {\n         let gen_body = self.gen_body.take();\n         let notify_chan = self.opts.notify_chan.take();\n         let name = self.opts.name.take();\n         TaskBuilder {\n             opts: TaskOpts {\n-                linked: self.opts.linked,\n-                supervised: self.opts.supervised,\n                 watched: self.opts.watched,\n-                indestructible: self.opts.indestructible,\n                 notify_chan: notify_chan,\n                 name: name,\n                 sched: self.opts.sched,\n                 stack_size: self.opts.stack_size\n             },\n             gen_body: gen_body,\n             can_not_copy: None,\n-            consumed: false\n         }\n     }\n \n-    /// Decouple the child task's failure from the parent's. If either fails,\n-    /// the other will not be killed.\n-    pub fn unlinked(&mut self) {\n-        self.opts.linked = false;\n-        self.opts.watched = false;\n-    }\n-\n-    /// Unidirectionally link the child task's failure with the parent's. The\n-    /// child's failure will not kill the parent, but the parent's will kill\n-    /// the child.\n-    pub fn supervised(&mut self) {\n-        self.opts.supervised = true;\n-        self.opts.linked = false;\n-        self.opts.watched = false;\n-    }\n-\n-    /// Link the child task's and parent task's failures. If either fails, the\n-    /// other will be killed.\n-    pub fn linked(&mut self) {\n-        self.opts.linked = true;\n-        self.opts.supervised = false;\n-        self.opts.watched = true;\n-    }\n-\n     /// Cause the parent task to collect the child's exit status (and that of\n     /// all transitively-watched grandchildren) before reporting its own.\n     pub fn watched(&mut self) {\n@@ -276,13 +218,6 @@ impl TaskBuilder {\n         self.opts.watched = false;\n     }\n \n-    /// Cause the child task to ignore any kill signals received from linked\n-    /// failure. This optimizes context switching, at the possible expense of\n-    /// process hangs in the case of unexpected failure.\n-    pub fn indestructible(&mut self) {\n-        self.opts.indestructible = true;\n-    }\n-\n     /// Get a future representing the exit status of the task.\n     ///\n     /// Taking the value of the future will block until the child task\n@@ -372,16 +307,13 @@ impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    pub fn spawn(&mut self, f: proc()) {\n+    pub fn spawn(mut self, f: proc()) {\n         let gen_body = self.gen_body.take();\n         let notify_chan = self.opts.notify_chan.take();\n         let name = self.opts.name.take();\n         let x = self.consume();\n         let opts = TaskOpts {\n-            linked: x.opts.linked,\n-            supervised: x.opts.supervised,\n             watched: x.opts.watched,\n-            indestructible: x.opts.indestructible,\n             notify_chan: notify_chan,\n             name: name,\n             sched: x.opts.sched,\n@@ -398,14 +330,6 @@ impl TaskBuilder {\n         spawn::spawn_raw(opts, f);\n     }\n \n-    /// Runs a task, while transferring ownership of one argument to the child.\n-    pub fn spawn_with<A:Send>(&mut self, arg: A, f: proc(v: A)) {\n-        let arg = Cell::new(arg);\n-        do self.spawn {\n-            f(arg.take());\n-        }\n-    }\n-\n     /**\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -419,7 +343,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Send>(&mut self, f: proc() -> T) -> Result<T, ~Any> {\n+    pub fn try<T:Send>(mut self, f: proc() -> T) -> Result<T, ~Any> {\n         let (po, ch) = stream::<T>();\n \n         let result = self.future_result();\n@@ -447,10 +371,7 @@ pub fn default_task_opts() -> TaskOpts {\n      */\n \n     TaskOpts {\n-        linked: true,\n-        supervised: false,\n         watched: true,\n-        indestructible: false,\n         notify_chan: None,\n         name: None,\n         sched: SchedOpts {\n@@ -469,56 +390,10 @@ pub fn default_task_opts() -> TaskOpts {\n ///\n /// This function is equivalent to `task().spawn(f)`.\n pub fn spawn(f: proc()) {\n-    let mut task = task();\n+    let task = task();\n     task.spawn(f)\n }\n \n-/// Creates a child task unlinked from the current one. If either this\n-/// task or the child task fails, the other will not be killed.\n-pub fn spawn_unlinked(f: proc()) {\n-    let mut task = task();\n-    task.unlinked();\n-    task.spawn(f)\n-}\n-\n-pub fn spawn_supervised(f: proc()) {\n-    /*!\n-     * Creates a child task supervised by the current one. If the child\n-     * task fails, the parent will not be killed, but if the parent fails,\n-     * the child will be killed.\n-     */\n-\n-    let mut task = task();\n-    task.supervised();\n-    task.spawn(f)\n-}\n-\n-/// Creates a child task that cannot be killed by linked failure. This causes\n-/// its context-switch path to be faster by 2 atomic swap operations.\n-/// (Note that this convenience wrapper still uses linked-failure, so the\n-/// child's children will still be killable by the parent. For the fastest\n-/// possible spawn mode, use task::task().unlinked().indestructible().spawn.)\n-pub fn spawn_indestructible(f: proc()) {\n-    let mut task = task();\n-    task.indestructible();\n-    task.spawn(f)\n-}\n-\n-pub fn spawn_with<A:Send>(arg: A, f: proc(v: A)) {\n-    /*!\n-     * Runs a task, while transferring ownership of one argument to the\n-     * child.\n-     *\n-     * This is useful for transferring ownership of noncopyables to\n-     * another task.\n-     *\n-     * This function is equivalent to `task().spawn_with(arg, f)`.\n-     */\n-\n-    let mut task = task();\n-    task.spawn_with(arg, f)\n-}\n-\n pub fn spawn_sched(mode: SchedMode, f: proc()) {\n     /*!\n      * Creates a new task on a new or existing scheduler.\n@@ -545,8 +420,7 @@ pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n      * This is equivalent to task().supervised().try.\n      */\n \n-    let mut task = task();\n-    task.supervised();\n+    let task = task();\n     task.try(f)\n }\n \n@@ -590,159 +464,6 @@ pub fn failing() -> bool {\n     }\n }\n \n-/**\n- * Temporarily make the task unkillable\n- *\n- * # Example\n- *\n- * ```\n- * do task::unkillable {\n- *     // detach / deschedule / destroy must all be called together\n- *     rustrt::rust_port_detach(po);\n- *     // This must not result in the current task being killed\n- *     task::deschedule();\n- *     rustrt::rust_port_destroy(po);\n- * }\n- * ```\n- */\n-pub fn unkillable<U>(f: || -> U) -> U {\n-    use rt::task::Task;\n-\n-    unsafe {\n-        if in_green_task_context() {\n-            // The inhibits/allows might fail and need to borrow the task.\n-            let t: *mut Task = Local::unsafe_borrow();\n-            do (|| {\n-                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n-                f()\n-            }).finally {\n-                (*t).death.allow_kill((*t).unwinder.unwinding);\n-            }\n-        } else {\n-            // FIXME(#3095): This should be an rtabort as soon as the scheduler\n-            // no longer uses a workqueue implemented with an Exclusive.\n-            f()\n-        }\n-    }\n-}\n-\n-/**\n- * Makes killable a task marked as unkillable. This\n- * is meant to be used only nested in unkillable.\n- *\n- * # Example\n- *\n- * ```\n- * do task::unkillable {\n- *     do task::rekillable {\n- *          // Task is killable\n- *     }\n- *    // Task is unkillable again\n- * }\n- */\n-pub fn rekillable<U>(f: || -> U) -> U {\n-    use rt::task::Task;\n-\n-    unsafe {\n-        if in_green_task_context() {\n-            let t: *mut Task = Local::unsafe_borrow();\n-            do (|| {\n-                (*t).death.allow_kill((*t).unwinder.unwinding);\n-                f()\n-            }).finally {\n-                (*t).death.inhibit_kill((*t).unwinder.unwinding);\n-            }\n-        } else {\n-            // FIXME(#3095): As in unkillable().\n-            f()\n-        }\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_kill_unkillable_task() {\n-    use rt::test::*;\n-\n-    // Attempt to test that when a kill signal is received at the start of an\n-    // unkillable section, 'unkillable' unwinds correctly. This is actually\n-    // quite a difficult race to expose, as the kill has to happen on a second\n-    // CPU, *after* the spawner is already switched-back-to (and passes the\n-    // killed check at the start of its timeslice). As far as I know, it's not\n-    // possible to make this race deterministic, or even more likely to happen.\n-    do run_in_uv_task {\n-        do task::try {\n-            do task::spawn {\n-                fail!();\n-            }\n-            do task::unkillable { }\n-        };\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_kill_rekillable_task() {\n-    use rt::test::*;\n-\n-    // Tests that when a kill signal is received, 'rekillable' and\n-    // 'unkillable' unwind correctly in conjunction with each other.\n-    do run_in_uv_task {\n-        do task::try {\n-            do task::unkillable {\n-                do task::rekillable {\n-                    do task::spawn {\n-                        fail!();\n-                    }\n-                }\n-            }\n-        };\n-    }\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_rekillable_not_nested() {\n-    do rekillable {\n-        // This should fail before\n-        // receiving anything since\n-        // this block should be nested\n-        // into a unkillable block.\n-        deschedule();\n-    }\n-}\n-\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_rekillable_nested_failure() {\n-\n-    let result = do task::try {\n-        do unkillable {\n-            do rekillable {\n-                let (port,chan) = comm::stream();\n-                do task::spawn { chan.send(()); fail!(); }\n-                port.recv(); // wait for child to exist\n-                port.recv(); // block forever, expect to get killed.\n-            }\n-        }\n-    };\n-    assert!(result.is_err());\n-}\n-\n-\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_cant_dup_task_builder() {\n-    let mut builder = task();\n-    builder.unlinked();\n-    do builder.spawn {}\n-    // FIXME(#3724): For now, this is a -runtime- failure, because we haven't\n-    // got move mode on self. When 3724 is fixed, this test should fail to\n-    // compile instead, and should go in tests/compile-fail.\n-    do builder.spawn {} // b should have been consumed by the previous call\n-}\n-\n // The following 8 tests test the following 2^3 combinations:\n // {un,}linked {un,}supervised failure propagation {up,down}wards.\n \n@@ -752,207 +473,6 @@ fn test_cant_dup_task_builder() {\n #[cfg(test)]\n fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n \n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let (po, ch) = stream();\n-        let ch = SharedChan::new(ch);\n-        do spawn_unlinked {\n-            let ch = ch.clone();\n-            do spawn_unlinked {\n-                // Give middle task a chance to fail-but-not-kill-us.\n-                do 16.times { task::deschedule(); }\n-                ch.send(()); // If killed first, grandparent hangs.\n-            }\n-            fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n-        }\n-        po.recv();\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        do spawn_unlinked { fail!(); }\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        do spawn_supervised { fail!(); }\n-        // Give child a chance to fail-but-not-kill-us.\n-        do 16.times { task::deschedule(); }\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_unlinked_sup_fail_down() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            do spawn_supervised { block_forever(); }\n-            fail!(); // Shouldn't leave a child hanging around.\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n-            // We have to cheat with opts - the interface doesn't support them because\n-            // they don't make sense (redundant with task().supervised()).\n-            let mut b0 = task();\n-            b0.opts.linked = true;\n-            b0.opts.supervised = true;\n-\n-            do b0.spawn {\n-                fail!();\n-            }\n-            block_forever(); // We should get punted awake\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // We have to cheat with opts - the interface doesn't support them because\n-            // they don't make sense (redundant with task().supervised()).\n-            let mut b0 = task();\n-            b0.opts.linked = true;\n-            b0.opts.supervised = true;\n-            do b0.spawn { block_forever(); }\n-            fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Default options are to spawn linked & unsupervised.\n-            do spawn { fail!(); }\n-            block_forever(); // We should get punted awake\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Default options are to spawn linked & unsupervised.\n-            do spawn { block_forever(); }\n-            fail!();\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Make sure the above test is the same as this one.\n-            let mut builder = task();\n-            builder.linked();\n-            do builder.spawn { block_forever(); }\n-            fail!();\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n-// A couple bonus linked failure tests - testing for failure propagation even\n-// when the middle task exits successfully early before kill signals are sent.\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_failure_propagate_grandchild() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Middle task exits; does grandparent's failure propagate across the gap?\n-            do spawn_supervised {\n-                do spawn_supervised { block_forever(); }\n-            }\n-            do 16.times { task::deschedule(); }\n-            fail!();\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_failure_propagate_secondborn() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // First-born child exits; does parent's failure propagate to sibling?\n-            do spawn_supervised {\n-                do spawn { block_forever(); } // linked\n-            }\n-            do 16.times { task::deschedule(); }\n-            fail!();\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_failure_propagate_nephew_or_niece() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Our sibling exits; does our failure propagate to sibling's child?\n-            do spawn { // linked\n-                do spawn_supervised { block_forever(); }\n-            }\n-            do 16.times { task::deschedule(); }\n-            fail!();\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_linked_sup_propagate_sibling() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result: Result<(), ~Any> = do try {\n-            // Middle sibling exits - does eldest's failure propagate to youngest?\n-            do spawn { // linked\n-                do spawn { block_forever(); } // linked\n-            }\n-            do 16.times { task::deschedule(); }\n-            fail!();\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n #[test]\n fn test_unnamed_task() {\n     use rt::test::run_in_uv_task;\n@@ -1014,7 +534,7 @@ fn test_send_named_task() {\n #[test]\n fn test_run_basic() {\n     let (po, ch) = stream::<()>();\n-    let mut builder = task();\n+    let builder = task();\n     do builder.spawn {\n         ch.send(());\n     }\n@@ -1053,7 +573,6 @@ fn test_future_result() {\n \n     let mut builder = task();\n     let result = builder.future_result();\n-    builder.unlinked();\n     do builder.spawn {\n         fail!();\n     }\n@@ -1224,7 +743,7 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        let mut builder = task();\n+        let builder = task();\n         do builder.spawn || {\n             f();\n         }\n@@ -1240,86 +759,6 @@ fn test_avoid_copying_the_body_try() {\n     }\n }\n \n-#[test]\n-fn test_avoid_copying_the_body_unlinked() {\n-    do avoid_copying_the_body |f| {\n-        do spawn_unlinked || {\n-            f();\n-        }\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-#[should_fail]\n-fn test_unkillable() {\n-    let (po, ch) = stream();\n-\n-    // We want to do this after failing\n-    do spawn_unlinked {\n-        do 10.times { deschedule() }\n-        ch.send(());\n-    }\n-\n-    do spawn {\n-        deschedule();\n-        // We want to fail after the unkillable task\n-        // blocks on recv\n-        fail!();\n-    }\n-\n-    unsafe {\n-        do unkillable {\n-            let p = ~0;\n-            let pp: *uint = cast::transmute(p);\n-\n-            // If we are killed here then the box will leak\n-            po.recv();\n-\n-            let _p: ~int = cast::transmute(pp);\n-        }\n-    }\n-\n-    // Now we can be killed\n-    po.recv();\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-#[should_fail]\n-fn test_unkillable_nested() {\n-    let (po, ch) = comm::stream();\n-\n-    // We want to do this after failing\n-    do spawn_unlinked || {\n-        do 10.times { deschedule() }\n-        ch.send(());\n-    }\n-\n-    do spawn {\n-        deschedule();\n-        // We want to fail after the unkillable task\n-        // blocks on recv\n-        fail!();\n-    }\n-\n-    unsafe {\n-        do unkillable {\n-            do unkillable {} // Here's the difference from the previous test.\n-            let p = ~0;\n-            let pp: *uint = cast::transmute(p);\n-\n-            // If we are killed here then the box will leak\n-            po.recv();\n-\n-            let _p: ~int = cast::transmute(pp);\n-        }\n-    }\n-\n-    // Now we can be killed\n-    po.recv();\n-}\n-\n #[test]\n fn test_child_doesnt_ref_parent() {\n     // If the child refcounts the parent task, this will stack overflow when\n@@ -1350,67 +789,6 @@ fn test_simple_newsched_spawn() {\n     }\n }\n \n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_spawn_watched() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result = do try {\n-            let mut t = task();\n-            t.unlinked();\n-            t.watched();\n-            do t.spawn {\n-                let mut t = task();\n-                t.unlinked();\n-                t.watched();\n-                do t.spawn {\n-                    task::deschedule();\n-                    fail!();\n-                }\n-            }\n-        };\n-        assert!(result.is_err());\n-    }\n-}\n-\n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_indestructible() {\n-    use rt::test::run_in_uv_task;\n-    do run_in_uv_task {\n-        let result = do try {\n-            let mut t = task();\n-            t.watched();\n-            t.supervised();\n-            t.indestructible();\n-            do t.spawn {\n-                let (p1, _c1) = stream::<()>();\n-                let (p2, c2) = stream::<()>();\n-                let (p3, c3) = stream::<()>();\n-                let mut t = task();\n-                t.unwatched();\n-                do t.spawn {\n-                    do (|| {\n-                        p1.recv(); // would deadlock if not killed\n-                    }).finally {\n-                        c2.send(());\n-                    };\n-                }\n-                let mut t = task();\n-                t.unwatched();\n-                do t.spawn {\n-                    p3.recv();\n-                    task::deschedule();\n-                    fail!();\n-                }\n-                c3.send(());\n-                p2.recv();\n-            }\n-        };\n-        assert!(result.is_ok());\n-    }\n-}\n-\n #[test]\n fn test_try_fail_message_static_str() {\n     match do try {\n@@ -1455,19 +833,6 @@ fn test_try_fail_message_any() {\n     }\n }\n \n-#[ignore(reason = \"linked failure\")]\n-#[test]\n-fn test_try_fail_message_linked() {\n-    match do try {\n-        do spawn {\n-            fail!()\n-        }\n-    } {\n-        Err(ref e) if e.is::<LinkedFailure>() => {}\n-        Err(_) | Ok(()) => fail!()\n-    }\n-}\n-\n #[test]\n fn test_try_fail_message_unit_struct() {\n     struct Juju;"}, {"sha": "578839d4542ff119eab23f2fe55d1979bd81325a", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 11, "deletions": 520, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -9,6 +9,10 @@\n // except according to those terms.\n \n /*!**************************************************************************\n+ *\n+ * WARNING: linked failure has been removed since this doc comment was written,\n+ *          but it was so pretty that I didn't want to remove it.\n+ *\n  * Spawning & linked failure\n  *\n  * Several data structures are involved in task management to allow properly\n@@ -73,541 +77,30 @@\n \n use prelude::*;\n \n-use cast::transmute;\n-use cast;\n use cell::Cell;\n-use comm::{Chan, GenericChan, oneshot};\n-use container::MutableMap;\n-use hashmap::{HashSet, HashSetMoveIterator};\n-use local_data;\n+use comm::{GenericChan, oneshot};\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n-use rt::task::{UnwindResult, Success, Failure};\n+use rt::task::UnwindResult;\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n-use rt::{in_green_task_context, new_event_loop, KillHandle};\n-use task::LinkedFailure;\n+use rt::{in_green_task_context, new_event_loop};\n use task::SingleThreaded;\n use task::TaskOpts;\n-use task::unkillable;\n-use uint;\n-use unstable::sync::Exclusive;\n-use util;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n-struct TaskSet(HashSet<KillHandle>);\n-\n-impl TaskSet {\n-    #[inline]\n-    fn new() -> TaskSet {\n-        TaskSet(HashSet::new())\n-    }\n-    #[inline]\n-    fn insert(&mut self, task: KillHandle) {\n-        let didnt_overwrite = (**self).insert(task);\n-        assert!(didnt_overwrite);\n-    }\n-    #[inline]\n-    fn remove(&mut self, task: &KillHandle) {\n-        let was_present = (**self).remove(task);\n-        assert!(was_present);\n-    }\n-    #[inline]\n-    fn move_iter(self) -> HashSetMoveIterator<KillHandle> {\n-        (*self).move_iter()\n-    }\n-}\n-\n-// One of these per group of linked-failure tasks.\n-struct TaskGroupData {\n-    // All tasks which might kill this group. When this is empty, the group\n-    // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n-    members:     TaskSet,\n-    // All tasks unidirectionally supervised by (directly or transitively)\n-    // tasks in this group.\n-    descendants: TaskSet,\n-}\n-type TaskGroupArc = Exclusive<Option<TaskGroupData>>;\n-\n-type TaskGroupInner<'self> = &'self mut Option<TaskGroupData>;\n-\n-// A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n-    tg.members.is_empty()\n-}\n-\n-// A list-like structure by which taskgroups keep track of all ancestor groups\n-// which may kill them. Needed for tasks to be able to remove themselves from\n-// ancestor groups upon exit. The list has a node for each \"generation\", and\n-// ends either at the root taskgroup (which has no ancestors) or at a\n-// taskgroup which was spawned-unlinked. Tasks from intermediate generations\n-// have references to the middle of the list; when intermediate generations\n-// die, their node in the list will be collected at a descendant's spawn-time.\n-struct AncestorNode {\n-    // Since the ancestor list is recursive, we end up with references to\n-    // exclusives within other exclusives. This is dangerous business (if\n-    // circular references arise, deadlock and memory leaks are imminent).\n-    // Hence we assert that this counter monotonically decreases as we\n-    // approach the tail of the list.\n-    generation:     uint,\n-    // Handle to the tasks in the group of the current generation.\n-    parent_group:   TaskGroupArc,\n-    // Recursive rest of the list.\n-    ancestors:      AncestorList,\n-}\n-\n-struct AncestorList(Option<Exclusive<AncestorNode>>);\n-\n-// Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n-#[inline]\n-fn access_group<U>(x: &TaskGroupArc, blk: |TaskGroupInner| -> U) -> U {\n-    unsafe {\n-        x.with(blk)\n-    }\n-}\n-\n-#[inline]\n-fn access_ancestors<U>(\n-                    x: &Exclusive<AncestorNode>,\n-                    blk: |x: &mut AncestorNode| -> U)\n-                    -> U {\n-    unsafe {\n-        x.with(blk)\n-    }\n-}\n-\n-#[inline] #[cfg(test)]\n-fn check_generation(younger: uint, older: uint) { assert!(younger > older); }\n-#[inline] #[cfg(not(test))]\n-fn check_generation(_younger: uint, _older: uint) { }\n-\n-#[inline] #[cfg(test)]\n-fn incr_generation(ancestors: &AncestorList) -> uint {\n-    ancestors.as_ref().map_default(0, |arc| access_ancestors(arc, |a| a.generation+1))\n-}\n-#[inline] #[cfg(not(test))]\n-fn incr_generation(_ancestors: &AncestorList) -> uint { 0 }\n-\n-// Iterates over an ancestor list.\n-// (1) Runs forward_blk on each ancestral taskgroup in the list\n-// (2) If forward_blk \"break\"s, runs optional bail_blk on all ancestral\n-//     taskgroups that forward_blk already ran on successfully (Note: bail_blk\n-//     is NOT called on the block that forward_blk broke on!).\n-// (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n-fn each_ancestor(list:        &mut AncestorList,\n-                 bail_blk:    |TaskGroupInner|,\n-                 forward_blk: |TaskGroupInner| -> bool)\n-                 -> bool {\n-    // \"Kickoff\" call - there was no last generation.\n-    return !coalesce(list, bail_blk, forward_blk, uint::max_value);\n-\n-    // Recursively iterates, and coalesces afterwards if needed. Returns\n-    // whether or not unwinding is needed (i.e., !successful iteration).\n-    fn coalesce(list:            &mut AncestorList,\n-                bail_blk:        |TaskGroupInner|,\n-                forward_blk:     |TaskGroupInner| -> bool,\n-                last_generation: uint) -> bool {\n-        let (coalesce_this, early_break) =\n-            iterate(list, bail_blk, forward_blk, last_generation);\n-        // What should our next ancestor end up being?\n-        if coalesce_this.is_some() {\n-            // Needed coalesce. Our next ancestor becomes our old\n-            // ancestor's next ancestor. (\"next = old_next->next;\")\n-            *list = coalesce_this.unwrap();\n-        }\n-        return early_break;\n-    }\n-\n-    // Returns an optional list-to-coalesce and whether unwinding is needed.\n-    // Option<ancestor_list>:\n-    //     Whether or not the ancestor taskgroup being iterated over is\n-    //     dead or not; i.e., it has no more tasks left in it, whether or not\n-    //     it has descendants. If dead, the caller shall coalesce it away.\n-    // bool:\n-    //     True if the supplied block did 'break', here or in any recursive\n-    //     calls. If so, must call the unwinder on all previous nodes.\n-    fn iterate(ancestors:       &mut AncestorList,\n-               bail_blk:        |TaskGroupInner|,\n-               forward_blk:     |TaskGroupInner| -> bool,\n-               last_generation: uint)\n-            -> (Option<AncestorList>, bool) {\n-        // At each step of iteration, three booleans are at play which govern\n-        // how the iteration should behave.\n-        // 'nobe_is_dead' - Should the list should be coalesced at this point?\n-        //                  Largely unrelated to the other two.\n-        // 'need_unwind'  - Should we run the bail_blk at this point? (i.e.,\n-        //                  do_continue was false not here, but down the line)\n-        // 'do_continue'  - Did the forward_blk succeed at this point? (i.e.,\n-        //                  should we recurse? or should our callers unwind?)\n-\n-        let forward_blk = Cell::new(forward_blk);\n-\n-        // The map defaults to None, because if ancestors is None, we're at\n-        // the end of the list, which doesn't make sense to coalesce.\n-        do ancestors.as_ref().map_default((None,false)) |ancestor_arc| {\n-            // NB: Takes a lock! (this ancestor node)\n-            do access_ancestors(ancestor_arc) |nobe| {\n-                // Argh, but we couldn't give it to coalesce() otherwise.\n-                let forward_blk = forward_blk.take();\n-                // Check monotonicity\n-                check_generation(last_generation, nobe.generation);\n-                /*##########################################################*\n-                 * Step 1: Look at this ancestor group (call iterator block).\n-                 *##########################################################*/\n-                let mut nobe_is_dead = false;\n-                let do_continue =\n-                    // NB: Takes a lock! (this ancestor node's parent group)\n-                    do access_group(&nobe.parent_group) |tg_opt| {\n-                        // Decide whether this group is dead. Note that the\n-                        // group being *dead* is disjoint from it *failing*.\n-                        nobe_is_dead = match *tg_opt {\n-                            Some(ref tg) => taskgroup_is_dead(tg),\n-                            None => nobe_is_dead\n-                        };\n-                        // Call iterator block. (If the group is dead, it's\n-                        // safe to skip it. This will leave our KillHandle\n-                        // hanging around in the group even after it's freed,\n-                        // but that's ok because, by virtue of the group being\n-                        // dead, nobody will ever kill-all (for) over it.)\n-                        if nobe_is_dead { true } else { forward_blk(tg_opt) }\n-                    };\n-                /*##########################################################*\n-                 * Step 2: Recurse on the rest of the list; maybe coalescing.\n-                 *##########################################################*/\n-                // 'need_unwind' is only set if blk returned true above, *and*\n-                // the recursive call early-broke.\n-                let mut need_unwind = false;\n-                if do_continue {\n-                    // NB: Takes many locks! (ancestor nodes & parent groups)\n-                    need_unwind = coalesce(&mut nobe.ancestors, |tg| bail_blk(tg),\n-                                           forward_blk, nobe.generation);\n-                }\n-                /*##########################################################*\n-                 * Step 3: Maybe unwind; compute return info for our caller.\n-                 *##########################################################*/\n-                if need_unwind && !nobe_is_dead {\n-                    do access_group(&nobe.parent_group) |tg_opt| {\n-                        bail_blk(tg_opt)\n-                    }\n-                }\n-                // Decide whether our caller should unwind.\n-                need_unwind = need_unwind || !do_continue;\n-                // Tell caller whether or not to coalesce and/or unwind\n-                if nobe_is_dead {\n-                    // Swap the list out here; the caller replaces us with it.\n-                    let rest = util::replace(&mut nobe.ancestors,\n-                                             AncestorList(None));\n-                    (Some(rest), need_unwind)\n-                } else {\n-                    (None, need_unwind)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// One of these per task.\n-pub struct Taskgroup {\n-    // List of tasks with whose fates this one's is intertwined.\n-    priv tasks:      TaskGroupArc, // 'none' means the group has failed.\n-    // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    priv ancestors:  AncestorList,\n-    priv notifier:   Option<AutoNotify>,\n-}\n-\n-impl Drop for Taskgroup {\n-    // Runs on task exit.\n-    fn drop(&mut self) {\n-        // If we are failing, the whole taskgroup needs to die.\n-        do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n-            if failing {\n-                for x in self.notifier.mut_iter() {\n-                    x.task_result = Some(Failure(~LinkedFailure as ~Any));\n-                }\n-                // Take everybody down with us. After this point, every\n-                // other task in the group will see 'tg' as none, which\n-                // indicates the whole taskgroup is failing (and forbids\n-                // new spawns from succeeding).\n-                let tg = do access_group(&self.tasks) |tg| { tg.take() };\n-                // It's safe to send kill signals outside the lock, because\n-                // we have a refcount on all kill-handles in the group.\n-                kill_taskgroup(tg, me);\n-            } else {\n-                // Remove ourselves from the group(s).\n-                do access_group(&self.tasks) |tg| {\n-                    leave_taskgroup(tg, me, true);\n-                }\n-            }\n-            // It doesn't matter whether this happens before or after dealing\n-            // with our own taskgroup, so long as both happen before we die.\n-            // We remove ourself from every ancestor we can, so no cleanup; no\n-            // break.\n-            do each_ancestor(&mut self.ancestors, |_| {}) |ancestor_group| {\n-                leave_taskgroup(ancestor_group, me, false);\n-                true\n-            };\n-        }\n-    }\n-}\n-\n-pub fn Taskgroup(tasks: TaskGroupArc,\n-       ancestors: AncestorList,\n-       mut notifier: Option<AutoNotify>) -> Taskgroup {\n-    for x in notifier.mut_iter() {\n-        x.task_result = Some(Success);\n-    }\n-\n-    Taskgroup {\n-        tasks: tasks,\n-        ancestors: ancestors,\n-        notifier: notifier\n-    }\n-}\n-\n-struct AutoNotify {\n-    notify_chan: Chan<UnwindResult>,\n-\n-    // XXX: By value self drop would allow this to be a plain UnwindResult\n-    task_result: Option<UnwindResult>,\n-}\n-\n-impl AutoNotify {\n-    pub fn new(chan: Chan<UnwindResult>) -> AutoNotify {\n-        AutoNotify {\n-            notify_chan: chan,\n-\n-            // Un-set above when taskgroup successfully made.\n-            task_result: Some(Failure(~(\"AutoNotify::new()\") as ~Any))\n-        }\n-    }\n-}\n-\n-impl Drop for AutoNotify {\n-    fn drop(&mut self) {\n-        let result = self.task_result.take_unwrap();\n-\n-        self.notify_chan.send(result);\n-    }\n-}\n-\n-fn enlist_in_taskgroup(state: TaskGroupInner, me: KillHandle,\n-                           is_member: bool) -> bool {\n-    let me = Cell::new(me); // :(\n-    // If 'None', the group was failing. Can't enlist.\n-    do state.as_mut().map_default(false) |group| {\n-        (if is_member {\n-            &mut group.members\n-        } else {\n-            &mut group.descendants\n-        }).insert(me.take());\n-        true\n-    }\n-}\n-\n-// NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(state: TaskGroupInner, me: &KillHandle, is_member: bool) {\n-    let me = Cell::new(me); // :(\n-    // If 'None', already failing and we've already gotten a kill signal.\n-    do state.as_mut().map |group| {\n-        (if is_member {\n-            &mut group.members\n-        } else {\n-            &mut group.descendants\n-        }).remove(me.take());\n-    };\n-}\n-\n-// NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(state: Option<TaskGroupData>, me: &KillHandle) {\n-    // Might already be None, if somebody is failing simultaneously.\n-    // That's ok; only one task needs to do the dirty work. (Might also\n-    // see 'None' if somebody already failed and we got a kill signal.)\n-    do state.map |TaskGroupData { members: members, descendants: descendants }| {\n-        for sibling in members.move_iter() {\n-            // Skip self - killing ourself won't do much good.\n-            if &sibling != me {\n-                RuntimeGlue::kill_task(sibling);\n-            }\n-        }\n-        for child in descendants.move_iter() {\n-            assert!(&child != me);\n-            RuntimeGlue::kill_task(child);\n-        }\n-    };\n-    // (note: multiple tasks may reach this point)\n-}\n-\n-// FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n-// a proper closure because the #[test]s won't understand. Have to fake it.\n-fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n-    unsafe { cast::transmute(-2) }\n-}\n-\n-// Transitionary.\n-struct RuntimeGlue;\n-impl RuntimeGlue {\n-    fn kill_task(mut handle: KillHandle) {\n-        do handle.kill().map |killed_task| {\n-            let killed_task = Cell::new(killed_task);\n-            do Local::borrow |sched: &mut Scheduler| {\n-                sched.enqueue_task(killed_task.take());\n-            }\n-        };\n-    }\n-\n-    fn with_task_handle_and_failing(blk: |&KillHandle, bool|) {\n-        assert!(in_green_task_context());\n-        unsafe {\n-            // Can't use safe borrow, because the taskgroup destructor needs to\n-            // access the scheduler again to send kill signals to other tasks.\n-            let me: *mut Task = Local::unsafe_borrow();\n-            blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n-        }\n-    }\n-\n-    fn with_my_taskgroup<U>(blk: |&Taskgroup| -> U) -> U {\n-        assert!(in_green_task_context());\n-        unsafe {\n-            // Can't use safe borrow, because creating new hashmaps for the\n-            // tasksets requires an rng, which needs to borrow the sched.\n-            let me: *mut Task = Local::unsafe_borrow();\n-            blk(match (*me).taskgroup {\n-                None => {\n-                    // First task in its (unlinked/unsupervised) taskgroup.\n-                    // Lazily initialize.\n-                    let mut members = TaskSet::new();\n-                    let my_handle = (*me).death.kill_handle.get_ref().clone();\n-                    members.insert(my_handle);\n-                    let tasks = Exclusive::new(Some(TaskGroupData {\n-                        members: members,\n-                        descendants: TaskSet::new(),\n-                    }));\n-                    let group = Taskgroup(tasks, AncestorList(None), None);\n-                    (*me).taskgroup = Some(group);\n-                    (*me).taskgroup.get_ref()\n-                }\n-                Some(ref group) => group,\n-            })\n-        }\n-    }\n-}\n-\n-// Returns 'None' in the case where the child's TG should be lazily initialized.\n-fn gen_child_taskgroup(linked: bool, supervised: bool)\n-    -> Option<(TaskGroupArc, AncestorList)> {\n-    if linked || supervised {\n-        // with_my_taskgroup will lazily initialize the parent's taskgroup if\n-        // it doesn't yet exist. We don't want to call it in the unlinked case.\n-        do RuntimeGlue::with_my_taskgroup |spawner_group| {\n-            let ancestors = AncestorList(spawner_group.ancestors.as_ref().map(|x| x.clone()));\n-            if linked {\n-                // Child is in the same group as spawner.\n-                // Child's ancestors are spawner's ancestors.\n-                Some((spawner_group.tasks.clone(), ancestors))\n-            } else {\n-                // Child is in a separate group from spawner.\n-                let g = Exclusive::new(Some(TaskGroupData {\n-                    members:     TaskSet::new(),\n-                    descendants: TaskSet::new(),\n-                }));\n-                let a = if supervised {\n-                    let new_generation = incr_generation(&ancestors);\n-                    assert!(new_generation < uint::max_value);\n-                    // Child's ancestors start with the spawner.\n-                    // Build a new node in the ancestor list.\n-                    AncestorList(Some(Exclusive::new(AncestorNode {\n-                        generation: new_generation,\n-                        parent_group: spawner_group.tasks.clone(),\n-                        ancestors: ancestors,\n-                    })))\n-                } else {\n-                    // Child has no ancestors.\n-                    AncestorList(None)\n-                };\n-                Some((g, a))\n-            }\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-// Set up membership in taskgroup and descendantship in all ancestor\n-// groups. If any enlistment fails, Some task was already failing, so\n-// don't let the child task run, and undo every successful enlistment.\n-fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n-               ancestors: &mut AncestorList) -> bool {\n-    // Join this taskgroup.\n-    let mut result = do access_group(child_arc) |child_tg| {\n-        enlist_in_taskgroup(child_tg, child.clone(), true) // member\n-    };\n-    if result {\n-        // Unwinding function in case any ancestral enlisting fails\n-        let bail: |TaskGroupInner| = |tg| { leave_taskgroup(tg, child, false) };\n-        // Attempt to join every ancestor group.\n-        result = do each_ancestor(ancestors, bail) |ancestor_tg| {\n-            // Enlist as a descendant, not as an actual member.\n-            // Descendants don't kill ancestor groups on failure.\n-            enlist_in_taskgroup(ancestor_tg, child.clone(), false)\n-        };\n-        // If any ancestor group fails, need to exit this group too.\n-        if !result {\n-            do access_group(child_arc) |child_tg| {\n-                leave_taskgroup(child_tg, child, true); // member\n-            }\n-        }\n-    }\n-    result\n-}\n-\n pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n     assert!(in_green_task_context());\n \n-    let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n-    let indestructible = opts.indestructible;\n-\n-    let child_wrapper: proc() = || {\n-        // Child task runs this code.\n-\n-        // If child data is 'None', the enlist is vacuously successful.\n-        let enlist_success = do child_data.take().map_default(true) |child_data| {\n-            let child_data = Cell::new(child_data); // :(\n-            do Local::borrow |me: &mut Task| {\n-                let (child_tg, ancestors) = child_data.take();\n-                let mut ancestors = ancestors;\n-                let handle = me.death.kill_handle.get_ref();\n-                // Atomically try to get into all of our taskgroups.\n-                if enlist_many(handle, &child_tg, &mut ancestors) {\n-                    // Got in. We can run the provided child body, and can also run\n-                    // the taskgroup's exit-time-destructor afterward.\n-                    me.taskgroup = Some(Taskgroup(child_tg, ancestors, None));\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-        };\n-\n-        // Should be run after the local-borrowed task is returned.\n-        let f_cell = Cell::new(f);\n-        if enlist_success {\n-            if indestructible {\n-                do unkillable { f_cell.take()() }\n-            } else {\n-                f_cell.take()()\n-            }\n-        }\n-    };\n-\n     let mut task = if opts.sched.mode != SingleThreaded {\n         if opts.watched {\n-            Task::build_child(opts.stack_size, child_wrapper)\n+            Task::build_child(opts.stack_size, f)\n         } else {\n-            Task::build_root(opts.stack_size, child_wrapper)\n+            Task::build_root(opts.stack_size, f)\n         }\n     } else {\n         unsafe {\n@@ -634,9 +127,9 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n             // Pin the new task to the new scheduler\n             let new_task = if opts.watched {\n-                Task::build_homed_child(opts.stack_size, child_wrapper, Sched(new_sched_handle))\n+                Task::build_homed_child(opts.stack_size, f, Sched(new_sched_handle))\n             } else {\n-                Task::build_homed_root(opts.stack_size, child_wrapper, Sched(new_sched_handle))\n+                Task::build_homed_root(opts.stack_size, f, Sched(new_sched_handle))\n             };\n \n             // Create a task that will later be used to join with the new scheduler\n@@ -711,7 +204,6 @@ fn test_spawn_raw_simple() {\n #[test]\n fn test_spawn_raw_unsupervise() {\n     let opts = task::TaskOpts {\n-        linked: false,\n         watched: false,\n         notify_chan: None,\n         .. default_task_opts()\n@@ -740,7 +232,6 @@ fn test_spawn_raw_notify_failure() {\n     let (notify_po, notify_ch) = comm::stream();\n \n     let opts = task::TaskOpts {\n-        linked: false,\n         watched: false,\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()"}, {"sha": "58504832b2d6922081f2e081b91bc4880a1f372b", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -25,7 +25,7 @@ do || {\n \n use ops::Drop;\n \n-#[cfg(test)] use task::{failing, spawn};\n+#[cfg(test)] use task::failing;\n \n pub trait Finally<T> {\n     fn finally(&self, dtor: ||) -> T;"}, {"sha": "f22a707fef6ce5ca50b617cec1a3db7cf066d172", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 58, "deletions": 82, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -135,65 +135,63 @@ impl<T: Send> UnsafeArc<T> {\n     /// block; otherwise, an unwrapping task can be killed by linked failure.\n     pub fn unwrap(self) -> T {\n         let this = Cell::new(self); // argh\n-        do task::unkillable {\n-            unsafe {\n-                let mut this = this.take();\n-                // The ~ dtor needs to run if this code succeeds.\n-                let mut data: ~ArcData<T> = cast::transmute(this.data);\n-                // Set up the unwrap protocol.\n-                let (p1,c1) = comm::oneshot(); // ()\n-                let (p2,c2) = comm::oneshot(); // bool\n-                // Try to put our server end in the unwrapper slot.\n-                // This needs no barrier -- it's protected by the release barrier on\n-                // the xadd, and the acquire+release barrier in the destructor's xadd.\n-                if data.unwrapper.fill(~(c1,p2), Relaxed).is_none() {\n-                    // Got in. Tell this handle's destructor not to run (we are now it).\n-                    this.data = ptr::mut_null();\n-                    // Drop our own reference.\n-                    let old_count = data.count.fetch_sub(1, Release);\n-                    assert!(old_count >= 1);\n-                    if old_count == 1 {\n-                        // We were the last owner. Can unwrap immediately.\n-                        // AtomicOption's destructor will free the server endpoint.\n+        unsafe {\n+            let mut this = this.take();\n+            // The ~ dtor needs to run if this code succeeds.\n+            let mut data: ~ArcData<T> = cast::transmute(this.data);\n+            // Set up the unwrap protocol.\n+            let (p1,c1) = comm::oneshot(); // ()\n+            let (p2,c2) = comm::oneshot(); // bool\n+            // Try to put our server end in the unwrapper slot.\n+            // This needs no barrier -- it's protected by the release barrier on\n+            // the xadd, and the acquire+release barrier in the destructor's xadd.\n+            if data.unwrapper.fill(~(c1,p2), Relaxed).is_none() {\n+                // Got in. Tell this handle's destructor not to run (we are now it).\n+                this.data = ptr::mut_null();\n+                // Drop our own reference.\n+                let old_count = data.count.fetch_sub(1, Release);\n+                assert!(old_count >= 1);\n+                if old_count == 1 {\n+                    // We were the last owner. Can unwrap immediately.\n+                    // AtomicOption's destructor will free the server endpoint.\n+                    // FIXME(#3224): it should be like this\n+                    // let ~ArcData { data: user_data, _ } = data;\n+                    // user_data\n+                    data.data.take_unwrap()\n+                } else {\n+                    // The *next* person who sees the refcount hit 0 will wake us.\n+                    let p1 = Cell::new(p1); // argh\n+                    // Unlike the above one, this cell is necessary. It will get\n+                    // taken either in the do block or in the finally block.\n+                    let c2_and_data = Cell::new((c2,data));\n+                    do (|| {\n+                        p1.take().recv();\n+                        // Got here. Back in the 'unkillable' without getting killed.\n+                        let (c2, data) = c2_and_data.take();\n+                        c2.send(true);\n                         // FIXME(#3224): it should be like this\n                         // let ~ArcData { data: user_data, _ } = data;\n                         // user_data\n+                        let mut data = data;\n                         data.data.take_unwrap()\n-                    } else {\n-                        // The *next* person who sees the refcount hit 0 will wake us.\n-                        let p1 = Cell::new(p1); // argh\n-                        // Unlike the above one, this cell is necessary. It will get\n-                        // taken either in the do block or in the finally block.\n-                        let c2_and_data = Cell::new((c2,data));\n-                        do (|| {\n-                            do task::rekillable { p1.take().recv(); }\n-                            // Got here. Back in the 'unkillable' without getting killed.\n+                    }).finally {\n+                        if task::failing() {\n+                            // Killed during wait. Because this might happen while\n+                            // someone else still holds a reference, we can't free\n+                            // the data now; the \"other\" last refcount will free it.\n                             let (c2, data) = c2_and_data.take();\n-                            c2.send(true);\n-                            // FIXME(#3224): it should be like this\n-                            // let ~ArcData { data: user_data, _ } = data;\n-                            // user_data\n-                            let mut data = data;\n-                            data.data.take_unwrap()\n-                        }).finally {\n-                            if task::failing() {\n-                                // Killed during wait. Because this might happen while\n-                                // someone else still holds a reference, we can't free\n-                                // the data now; the \"other\" last refcount will free it.\n-                                let (c2, data) = c2_and_data.take();\n-                                c2.send(false);\n-                                cast::forget(data);\n-                            } else {\n-                                assert!(c2_and_data.is_empty());\n-                            }\n+                            c2.send(false);\n+                            cast::forget(data);\n+                        } else {\n+                            assert!(c2_and_data.is_empty());\n                         }\n                     }\n-                } else {\n-                    // If 'put' returns the server end back to us, we were rejected;\n-                    // someone else was trying to unwrap. Avoid guaranteed deadlock.\n-                    cast::forget(data);\n-                    fail!(\"Another task is already unwrapping this Arc!\");\n                 }\n+            } else {\n+                // If 'put' returns the server end back to us, we were rejected;\n+                // someone else was trying to unwrap. Avoid guaranteed deadlock.\n+                cast::forget(data);\n+                fail!(\"Another task is already unwrapping this Arc!\");\n             }\n         }\n     }\n@@ -259,17 +257,15 @@ impl<T> Drop for UnsafeArc<T>{\n                 match data.unwrapper.take(Acquire) {\n                     Some(~(message,response)) => {\n                         let cell = Cell::new((message, response, data));\n-                        do task::unkillable {\n-                            let (message, response, data) = cell.take();\n-                            // Send 'ready' and wait for a response.\n-                            message.send(());\n-                            // Unkillable wait. Message guaranteed to come.\n-                            if response.recv() {\n-                                // Other task got the data.\n-                                cast::forget(data);\n-                            } else {\n-                                // Other task was killed. drop glue takes over.\n-                            }\n+                        let (message, response, data) = cell.take();\n+                        // Send 'ready' and wait for a response.\n+                        message.send(());\n+                        // Unkillable wait. Message guaranteed to come.\n+                        if response.recv() {\n+                            // Other task got the data.\n+                            cast::forget(data);\n+                        } else {\n+                            // Other task was killed. drop glue takes over.\n                         }\n                     }\n                     None => {\n@@ -678,24 +674,4 @@ mod tests {\n         assert!(x.unwrap() == ~~\"hello\");\n         assert!(res.recv().is_ok());\n     }\n-\n-    #[test]\n-    fn exclusive_new_unwrap_deadlock() {\n-        // This is not guaranteed to get to the deadlock before being killed,\n-        // but it will show up sometimes, and if the deadlock were not there,\n-        // the test would nondeterministically fail.\n-        let result = do task::try {\n-            // a task that has two references to the same Exclusive::new will\n-            // deadlock when it unwraps. nothing to be done about that.\n-            let x = Exclusive::new(~~\"hello\");\n-            let x2 = x.clone();\n-            do task::spawn {\n-                do 10.times { task::deschedule(); } // try to let the unwrapper go\n-                fail!(); // punt it awake from its deadlock\n-            }\n-            let _z = x.unwrap();\n-            unsafe { do x2.with |_hello| { } }\n-        };\n-        assert!(result.is_err());\n-    }\n }"}, {"sha": "7becdee43a4ab26a865f0d26d16e3e78448302c1", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -179,9 +179,9 @@ fn main() {\n \n         let (from_parent, to_child) = comm::stream();\n \n-        do task::spawn_with(from_parent) |from_parent| {\n+        do spawn {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n-        };\n+        }\n \n         to_child\n     }.collect::<~[Chan<~[u8]>]>();"}, {"sha": "889885c338869f37bae8f247b9baf284a9ae64a1", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -28,7 +28,7 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n     let c = Cell::new(c);\n-    do task::spawn_supervised {\n+    do spawn {\n         let c = c.take();\n         if gens_left & 1 == 1 {\n             task::deschedule(); // shake things up a bit"}, {"sha": "eb0e64268f351fece2d7215a7d99c67bc3ca3848", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -1,4 +1,5 @@\n // xfail-pretty\n+// xfail-test linked failure\n \n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -35,8 +36,6 @@ fn grandchild_group(num_tasks: uint) {\n     for _ in range(0, num_tasks) {\n         let ch = ch.clone();\n         let mut t = task::task();\n-        t.linked();\n-        t.unwatched();\n         do t.spawn { // linked\n             ch.send(());\n             let (p, _c) = stream::<()>();"}, {"sha": "9d58c1820087631da317e5c22b10a54d2f070ec0", "filename": "src/test/run-fail/fail-task-name-none.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-none.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -10,8 +10,11 @@\n \n // error-pattern:task '<unnamed>' failed at 'test'\n \n+use std::task;\n+\n fn main() {\n-    do spawn {\n+    do task::try {\n         fail!(\"test\");\n-    }\n+        1\n+    }.unwrap()\n }"}, {"sha": "9e87b59db64940216aac261d0c161e4d7988dfd3", "filename": "src/test/run-fail/fail-task-name-owned.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -10,10 +10,13 @@\n \n // error-pattern:task 'owned name' failed at 'test'\n \n+use std::task;\n+\n fn main() {\n-    let mut t = ::std::task::task();\n+    let mut t = task::task();\n     t.name(~\"owned name\");\n-    do t.spawn {\n+    do t.try {\n         fail!(\"test\");\n-    }\n+        1\n+    }.unwrap()\n }"}, {"sha": "0e3ef39cd1db347589ca4a534e060549fc445685", "filename": "src/test/run-fail/fail-task-name-send-str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -13,7 +13,8 @@\n fn main() {\n     let mut t = ::std::task::task();\n     t.name(\"send name\".to_send_str());\n-    do t.spawn {\n+    do t.try {\n         fail!(\"test\");\n-    }\n+        3\n+    }.unwrap()\n }"}, {"sha": "4fd19fb2a6f22c05751664c54c24d41fb9c269a6", "filename": "src/test/run-fail/fail-task-name-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ffail-task-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-static.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let mut t = ::std::task::task();\n     t.name(\"static name\");\n-    do t.spawn {\n+    do t.try {\n         fail!(\"test\");\n-    }\n+    }.unwrap()\n }"}, {"sha": "ae189889967f74ce3c9daf10acf77f365c4d3548", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -15,7 +15,7 @@ use std::task;\n fn main() {\n     // the purpose of this test is to make sure that task::spawn()\n     // works when provided with a bare function:\n-    task::spawn(startfn);\n+    task::try(startfn).unwrap();\n }\n \n fn startfn() {"}, {"sha": "2b3e44a65290f61e36e99545ef5ad73a21be29fe", "filename": "src/test/run-pass/unwind-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-box.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -18,5 +18,5 @@ fn f() {\n }\n \n pub fn main() {\n-    task::spawn_unlinked(f);\n+    task::spawn(f);\n }"}, {"sha": "e2460ba6b04885e1baa22cfda6cd1722931d067c", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -42,7 +42,7 @@ fn f(c: SharedChan<bool>) {\n pub fn main() {\n     let (p, c) = stream();\n     let c = SharedChan::new(c);\n-    task::spawn_unlinked(|| f(c.clone()) );\n+    task::spawn(|| f(c.clone()) );\n     error!(\"hiiiiiiiii\");\n     assert!(p.recv());\n }"}, {"sha": "38e5a122a12ac832303ef310edd66cda4735f448", "filename": "src/test/run-pass/unwind-resource2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-resource2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource2.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -35,5 +35,5 @@ fn f() {\n }\n \n pub fn main() {\n-    task::spawn_unlinked(f);\n+    task::spawn(f);\n }"}, {"sha": "e2e64d72575966d2bba62c84c8c8471f8d98167a", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=2cc1e16ac0ee1fe5ea07125215e2ee1d39e63c12", "patch": "@@ -18,5 +18,5 @@ fn f() {\n }\n \n pub fn main() {\n-    task::spawn_unlinked(f);\n+    task::spawn(f);\n }"}]}