{"sha": "f2de221b0063261140a336c448bf1421170c9a74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZGUyMjFiMDA2MzI2MTE0MGEzMzZjNDQ4YmYxNDIxMTcwYzlhNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-22T13:10:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-22T13:10:48Z"}, "message": "Auto merge of #81101 - tmiasko:combine-now, r=nagisa\n\nCombine instructions immediately", "tree": {"sha": "c753ce0cde9a0338e4aa73bde3e1255ccb76725b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c753ce0cde9a0338e4aa73bde3e1255ccb76725b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2de221b0063261140a336c448bf1421170c9a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2de221b0063261140a336c448bf1421170c9a74", "html_url": "https://github.com/rust-lang/rust/commit/f2de221b0063261140a336c448bf1421170c9a74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2de221b0063261140a336c448bf1421170c9a74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc01bb624a960533e049fdb98d0489ff2a8de06", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc01bb624a960533e049fdb98d0489ff2a8de06", "html_url": "https://github.com/rust-lang/rust/commit/bbc01bb624a960533e049fdb98d0489ff2a8de06"}, {"sha": "508eec49e91ef14936800cd56ada6d674b8c6fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/508eec49e91ef14936800cd56ada6d674b8c6fd4", "html_url": "https://github.com/rust-lang/rust/commit/508eec49e91ef14936800cd56ada6d674b8c6fd4"}], "stats": {"total": 434, "additions": 79, "deletions": 355}, "files": [{"sha": "cd2bea86ea1a73f776948382077c327900b03417", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2de221b0063261140a336c448bf1421170c9a74/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2de221b0063261140a336c448bf1421170c9a74/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f2de221b0063261140a336c448bf1421170c9a74", "patch": "@@ -54,7 +54,7 @@ mod type_foldable;\n pub mod visit;\n \n /// Types for locals\n-type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n+pub type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n \n pub trait HasLocalDecls<'tcx> {\n     fn local_decls(&self) -> &LocalDecls<'tcx>;"}, {"sha": "74dadb25725650af345b33374b96139ddf38e646", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 77, "deletions": 284, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/f2de221b0063261140a336c448bf1421170c9a74/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2de221b0063261140a336c448bf1421170c9a74/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=f2de221b0063261140a336c448bf1421170c9a74", "patch": "@@ -1,329 +1,122 @@\n //! Performs various peephole optimizations.\n \n use crate::transform::MirPass;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::{\n-    visit::PlaceContext,\n-    visit::{MutVisitor, Visitor},\n-    Statement,\n-};\n-use rustc_middle::mir::{\n-    BinOp, Body, BorrowKind, Constant, Local, Location, Operand, Place, PlaceRef, ProjectionElem,\n-    Rvalue,\n+    BinOp, Body, Constant, LocalDecls, Operand, Place, ProjectionElem, Rvalue, SourceInfo,\n+    StatementKind,\n };\n use rustc_middle::ty::{self, TyCtxt};\n-use std::mem;\n \n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        // First, find optimization opportunities. This is done in a pre-pass to keep the MIR\n-        // read-only so that we can do global analyses on the MIR in the process (e.g.\n-        // `Place::ty()`).\n-        let optimizations = {\n-            let mut optimization_finder = OptimizationFinder::new(body, tcx);\n-            optimization_finder.visit_body(body);\n-            optimization_finder.optimizations\n-        };\n-\n-        if !optimizations.is_empty() {\n-            // Then carry out those optimizations.\n-            MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let ctx = InstCombineContext { tcx, local_decls };\n+        for block in basic_blocks.iter_mut() {\n+            for statement in block.statements.iter_mut() {\n+                match statement.kind {\n+                    StatementKind::Assign(box (_place, ref mut rvalue)) => {\n+                        ctx.combine_bool_cmp(&statement.source_info, rvalue);\n+                        ctx.combine_ref_deref(&statement.source_info, rvalue);\n+                        ctx.combine_len(&statement.source_info, rvalue);\n+                    }\n+                    _ => {}\n+                }\n+            }\n         }\n     }\n }\n \n-pub struct InstCombineVisitor<'tcx> {\n-    optimizations: OptimizationList<'tcx>,\n+struct InstCombineContext<'tcx, 'a> {\n     tcx: TyCtxt<'tcx>,\n+    local_decls: &'a LocalDecls<'tcx>,\n }\n \n-impl<'tcx> InstCombineVisitor<'tcx> {\n-    fn should_combine(&self, rvalue: &Rvalue<'tcx>, location: Location) -> bool {\n+impl<'tcx, 'a> InstCombineContext<'tcx, 'a> {\n+    fn should_combine(&self, source_info: &SourceInfo, rvalue: &Rvalue<'tcx>) -> bool {\n         self.tcx.consider_optimizing(|| {\n-            format!(\"InstCombine - Rvalue: {:?} Location: {:?}\", rvalue, location)\n+            format!(\"InstCombine - Rvalue: {:?} SourceInfo: {:?}\", rvalue, source_info)\n         })\n     }\n-}\n-\n-impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        if self.optimizations.and_stars.remove(&location) && self.should_combine(rvalue, location) {\n-            debug!(\"replacing `&*`: {:?}\", rvalue);\n-            let new_place = match rvalue {\n-                Rvalue::Ref(_, _, place) => {\n-                    if let &[ref proj_l @ .., proj_r] = place.projection.as_ref() {\n-                        place.projection = self.tcx().intern_place_elems(&[proj_r]);\n-\n-                        Place {\n-                            // Replace with dummy\n-                            local: mem::replace(&mut place.local, Local::new(0)),\n-                            projection: self.tcx().intern_place_elems(proj_l),\n-                        }\n-                    } else {\n-                        unreachable!();\n+    /// Transform boolean comparisons into logical operations.\n+    fn combine_bool_cmp(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+        match rvalue {\n+            Rvalue::BinaryOp(op @ (BinOp::Eq | BinOp::Ne), a, b) => {\n+                let new = match (op, self.try_eval_bool(a), self.try_eval_bool(b)) {\n+                    // Transform \"Eq(a, true)\" ==> \"a\"\n+                    (BinOp::Eq, _, Some(true)) => Some(a.clone()),\n+\n+                    // Transform \"Ne(a, false)\" ==> \"a\"\n+                    (BinOp::Ne, _, Some(false)) => Some(a.clone()),\n+\n+                    // Transform \"Eq(true, b)\" ==> \"b\"\n+                    (BinOp::Eq, Some(true), _) => Some(b.clone()),\n+\n+                    // Transform \"Ne(false, b)\" ==> \"b\"\n+                    (BinOp::Ne, Some(false), _) => Some(b.clone()),\n+\n+                    // FIXME: Consider combining remaining comparisons into logical operations:\n+                    // Transform \"Eq(false, b)\" ==> \"Not(b)\"\n+                    // Transform \"Ne(true, b)\" ==> \"Not(b)\"\n+                    // Transform \"Eq(a, false)\" ==> \"Not(a)\"\n+                    // Transform \"Ne(a, true)\" ==> \"Not(a)\"\n+                    _ => None,\n+                };\n+\n+                if let Some(new) = new {\n+                    if self.should_combine(source_info, rvalue) {\n+                        *rvalue = Rvalue::Use(new);\n                     }\n                 }\n-                _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n-            };\n-            *rvalue = Rvalue::Use(Operand::Copy(new_place))\n-        }\n-\n-        if let Some(constant) = self.optimizations.arrays_lengths.remove(&location) {\n-            if self.should_combine(rvalue, location) {\n-                debug!(\"replacing `Len([_; N])`: {:?}\", rvalue);\n-                *rvalue = Rvalue::Use(Operand::Constant(box constant));\n-            }\n-        }\n-\n-        if let Some(operand) = self.optimizations.unneeded_equality_comparison.remove(&location) {\n-            if self.should_combine(rvalue, location) {\n-                debug!(\"replacing {:?} with {:?}\", rvalue, operand);\n-                *rvalue = Rvalue::Use(operand);\n-            }\n-        }\n-\n-        if let Some(place) = self.optimizations.unneeded_deref.remove(&location) {\n-            if self.should_combine(rvalue, location) {\n-                debug!(\"unneeded_deref: replacing {:?} with {:?}\", rvalue, place);\n-                *rvalue = Rvalue::Use(Operand::Copy(place));\n             }\n-        }\n-\n-        // We do not call super_rvalue as we are not interested in any other parts of the tree\n-    }\n-}\n-\n-struct MutatingUseVisitor {\n-    has_mutating_use: bool,\n-    local_to_look_for: Local,\n-}\n-\n-impl MutatingUseVisitor {\n-    fn has_mutating_use_in_stmt(local: Local, stmt: &Statement<'tcx>, location: Location) -> bool {\n-        let mut _self = Self { has_mutating_use: false, local_to_look_for: local };\n-        _self.visit_statement(stmt, location);\n-        _self.has_mutating_use\n-    }\n-}\n \n-impl<'tcx> Visitor<'tcx> for MutatingUseVisitor {\n-    fn visit_local(&mut self, local: &Local, context: PlaceContext, _: Location) {\n-        if *local == self.local_to_look_for {\n-            self.has_mutating_use |= context.is_mutating_use();\n+            _ => {}\n         }\n     }\n-}\n-\n-/// Finds optimization opportunities on the MIR.\n-struct OptimizationFinder<'b, 'tcx> {\n-    body: &'b Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    optimizations: OptimizationList<'tcx>,\n-}\n \n-impl OptimizationFinder<'b, 'tcx> {\n-    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'tcx>) -> OptimizationFinder<'b, 'tcx> {\n-        OptimizationFinder { body, tcx, optimizations: OptimizationList::default() }\n+    fn try_eval_bool(&self, a: &Operand<'_>) -> Option<bool> {\n+        let a = a.constant()?;\n+        if a.literal.ty.is_bool() { a.literal.val.try_to_bool() } else { None }\n     }\n \n-    fn find_deref_of_address(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n-        // FIXME(#78192): This optimization can result in unsoundness.\n-        if !self.tcx.sess.opts.debugging_opts.unsound_mir_opts {\n-            return None;\n-        }\n-\n-        // Look for the sequence\n-        //\n-        // _2 = &_1;\n-        // ...\n-        // _5 = (*_2);\n-        //\n-        // which we can replace the last statement with `_5 = _1;` to avoid the load of `_2`.\n-        if let Rvalue::Use(op) = rvalue {\n-            let local_being_derefed = match op.place()?.as_ref() {\n-                PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(local),\n-                _ => None,\n-            }?;\n-\n-            let mut dead_locals_seen = vec![];\n-\n-            let stmt_index = location.statement_index;\n-            // Look behind for statement that assigns the local from a address of operator.\n-            // 6 is chosen as a heuristic determined by seeing the number of times\n-            // the optimization kicked in compiling rust std.\n-            let lower_index = stmt_index.saturating_sub(6);\n-            let statements_to_look_in = self.body.basic_blocks()[location.block].statements\n-                [lower_index..stmt_index]\n-                .iter()\n-                .rev();\n-            for stmt in statements_to_look_in {\n-                match &stmt.kind {\n-                    // Exhaustive match on statements to detect conditions that warrant we bail out of the optimization.\n-                    rustc_middle::mir::StatementKind::Assign(box (l, r))\n-                        if l.local == local_being_derefed =>\n-                    {\n-                        match r {\n-                            // Looking for immutable reference e.g _local_being_deref = &_1;\n-                            Rvalue::Ref(\n-                                _,\n-                                // Only apply the optimization if it is an immutable borrow.\n-                                BorrowKind::Shared,\n-                                place_taken_address_of,\n-                            ) => {\n-                                // Make sure that the place has not been marked dead\n-                                if dead_locals_seen.contains(&place_taken_address_of.local) {\n-                                    return None;\n-                                }\n-\n-                                self.optimizations\n-                                    .unneeded_deref\n-                                    .insert(location, *place_taken_address_of);\n-                                return Some(());\n-                            }\n-\n-                            // We found an assignment of `local_being_deref` that is not an immutable ref, e.g the following sequence\n-                            // _2 = &_1;\n-                            // _3 = &5\n-                            // _2 = _3;  <-- this means it is no longer valid to replace the last statement with `_5 = _1;`\n-                            // _5 = (*_2);\n-                            _ => return None,\n-                        }\n-                    }\n-\n-                    // Inline asm can do anything, so bail out of the optimization.\n-                    rustc_middle::mir::StatementKind::LlvmInlineAsm(_) => return None,\n-\n-                    // Remember `StorageDead`s, as the local being marked dead could be the\n-                    // place RHS we are looking for, in which case we need to abort to avoid UB\n-                    // using an uninitialized place\n-                    rustc_middle::mir::StatementKind::StorageDead(dead) => {\n-                        dead_locals_seen.push(*dead)\n-                    }\n+    /// Transform \"&(*a)\" ==> \"a\".\n+    fn combine_ref_deref(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+        if let Rvalue::Ref(_, _, place) = rvalue {\n+            if let Some((base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n+                if let ty::Ref(_, _, Mutability::Not) =\n+                    base.ty(self.local_decls, self.tcx).ty.kind()\n+                {\n+                    // The dereferenced place must have type `&_`, so that we don't copy `&mut _`.\n+                } else {\n+                    return;\n+                }\n \n-                    // Check that `local_being_deref` is not being used in a mutating way which can cause misoptimization.\n-                    rustc_middle::mir::StatementKind::Assign(box (_, _))\n-                    | rustc_middle::mir::StatementKind::Coverage(_)\n-                    | rustc_middle::mir::StatementKind::Nop\n-                    | rustc_middle::mir::StatementKind::FakeRead(_, _)\n-                    | rustc_middle::mir::StatementKind::StorageLive(_)\n-                    | rustc_middle::mir::StatementKind::Retag(_, _)\n-                    | rustc_middle::mir::StatementKind::AscribeUserType(_, _)\n-                    | rustc_middle::mir::StatementKind::SetDiscriminant { .. } => {\n-                        if MutatingUseVisitor::has_mutating_use_in_stmt(\n-                            local_being_derefed,\n-                            stmt,\n-                            location,\n-                        ) {\n-                            return None;\n-                        }\n-                    }\n+                if !self.should_combine(source_info, rvalue) {\n+                    return;\n                 }\n-            }\n-        }\n-        Some(())\n-    }\n \n-    fn find_unneeded_equality_comparison(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        // find Ne(_place, false) or Ne(false, _place)\n-        // or   Eq(_place, true) or Eq(true, _place)\n-        if let Rvalue::BinaryOp(op, l, r) = rvalue {\n-            let const_to_find = if *op == BinOp::Ne {\n-                false\n-            } else if *op == BinOp::Eq {\n-                true\n-            } else {\n-                return;\n-            };\n-            // (const, _place)\n-            if let Some(o) = self.find_operand_in_equality_comparison_pattern(l, r, const_to_find) {\n-                self.optimizations.unneeded_equality_comparison.insert(location, o.clone());\n-            }\n-            // (_place, const)\n-            else if let Some(o) =\n-                self.find_operand_in_equality_comparison_pattern(r, l, const_to_find)\n-            {\n-                self.optimizations.unneeded_equality_comparison.insert(location, o.clone());\n+                *rvalue = Rvalue::Use(Operand::Copy(Place {\n+                    local: base.local,\n+                    projection: self.tcx.intern_place_elems(base.projection),\n+                }));\n             }\n         }\n     }\n \n-    fn find_operand_in_equality_comparison_pattern(\n-        &self,\n-        l: &Operand<'tcx>,\n-        r: &'a Operand<'tcx>,\n-        const_to_find: bool,\n-    ) -> Option<&'a Operand<'tcx>> {\n-        let const_ = l.constant()?;\n-        if const_.literal.ty == self.tcx.types.bool\n-            && const_.literal.val.try_to_bool() == Some(const_to_find)\n-        {\n-            if r.place().is_some() {\n-                return Some(r);\n-            }\n-        }\n-\n-        None\n-    }\n-}\n-\n-impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, place) = rvalue {\n-            if let Some((place_base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n-                // The dereferenced place must have type `&_`.\n-                let ty = place_base.ty(self.body, self.tcx).ty;\n-                if let ty::Ref(_, _, Mutability::Not) = ty.kind() {\n-                    self.optimizations.and_stars.insert(location);\n-                }\n-            }\n-        }\n-\n+    /// Transform \"Len([_; N])\" ==> \"N\".\n+    fn combine_len(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Len(ref place) = *rvalue {\n-            let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n+            let place_ty = place.ty(self.local_decls, self.tcx).ty;\n             if let ty::Array(_, len) = place_ty.kind() {\n-                let span = self.body.source_info(location).span;\n-                let constant = Constant { span, literal: len, user_ty: None };\n-                self.optimizations.arrays_lengths.insert(location, constant);\n-            }\n-        }\n-\n-        let _ = self.find_deref_of_address(rvalue, location);\n-\n-        self.find_unneeded_equality_comparison(rvalue, location);\n-\n-        // We do not call super_rvalue as we are not interested in any other parts of the tree\n-    }\n-}\n-\n-#[derive(Default)]\n-struct OptimizationList<'tcx> {\n-    and_stars: FxHashSet<Location>,\n-    arrays_lengths: FxHashMap<Location, Constant<'tcx>>,\n-    unneeded_equality_comparison: FxHashMap<Location, Operand<'tcx>>,\n-    unneeded_deref: FxHashMap<Location, Place<'tcx>>,\n-}\n+                if !self.should_combine(source_info, rvalue) {\n+                    return;\n+                }\n \n-impl<'tcx> OptimizationList<'tcx> {\n-    fn is_empty(&self) -> bool {\n-        match self {\n-            OptimizationList {\n-                and_stars,\n-                arrays_lengths,\n-                unneeded_equality_comparison,\n-                unneeded_deref,\n-            } => {\n-                and_stars.is_empty()\n-                    && arrays_lengths.is_empty()\n-                    && unneeded_equality_comparison.is_empty()\n-                    && unneeded_deref.is_empty()\n+                let constant = Constant { span: source_info.span, literal: len, user_ty: None };\n+                *rvalue = Rvalue::Use(Operand::Constant(box constant));\n             }\n         }\n     }"}, {"sha": "4bda9ae383c228b48220f9aeb3ab18863af32a53", "filename": "src/test/mir-opt/inline/inline_closure_borrows_arg.foo.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2de221b0063261140a336c448bf1421170c9a74/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f2de221b0063261140a336c448bf1421170c9a74/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir?ref=f2de221b0063261140a336c448bf1421170c9a74", "patch": "@@ -40,7 +40,7 @@ fn foo(_1: T, _2: &i32) -> i32 {\n         _9 = move (_5.1: &i32);          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageLive(_10);                // scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         _10 = _8;                        // scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-        _0 = (*_8);                      // scope 3 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        _0 = (*_10);                     // scope 3 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_10);                // scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_9);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_8);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12"}, {"sha": "78361c336607c671b5f9635101d6edc54ef9468b", "filename": "src/test/mir-opt/inst_combine_deref.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bbc01bb624a960533e049fdb98d0489ff2a8de06/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc01bb624a960533e049fdb98d0489ff2a8de06/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs?ref=bbc01bb624a960533e049fdb98d0489ff2a8de06", "patch": "@@ -1,69 +0,0 @@\n-// compile-flags: -O -Zunsound-mir-opts\n-// EMIT_MIR inst_combine_deref.simple_opt.InstCombine.diff\n-fn simple_opt() -> u64 {\n-    let x = 5;\n-    let y = &x;\n-    let z = *y;\n-    z\n-}\n-\n-// EMIT_MIR inst_combine_deref.deep_opt.InstCombine.diff\n-fn deep_opt() -> (u64, u64, u64) {\n-    let x1 = 1;\n-    let x2 = 2;\n-    let x3 = 3;\n-    let y1 = &x1;\n-    let y2 = &x2;\n-    let y3 = &x3;\n-    let z1 = *y1;\n-    let z2 = *y2;\n-    let z3 = *y3;\n-    (z1, z2, z3)\n-}\n-\n-struct S {\n-    a: u64,\n-    b: u64,\n-}\n-\n-// EMIT_MIR inst_combine_deref.opt_struct.InstCombine.diff\n-fn opt_struct(s: S) -> u64 {\n-    let a = &s.a;\n-    let b = &s.b;\n-    let x = *a;\n-    *b + x\n-}\n-\n-// EMIT_MIR inst_combine_deref.dont_opt.InstCombine.diff\n-// do not optimize a sequence looking like this:\n-// _1 = &_2;\n-// _1 = _3;\n-// _4 = *_1;\n-// as the _1 = _3 assignment makes it not legal to replace the last statement with _4 = _2\n-fn dont_opt() -> u64 {\n-    let y = 5;\n-    let _ref = &y;\n-    let x = 5;\n-    let mut _1 = &x;\n-    _1 = _ref;\n-    let _4 = *_1;\n-    0\n-}\n-\n-// EMIT_MIR inst_combine_deref.do_not_miscompile.InstCombine.diff\n-fn do_not_miscompile() {\n-    let x = 42;\n-    let a = 99;\n-    let mut y = &x;\n-    let z = &mut y;\n-    *z = &a;\n-    assert!(*y == 99);\n-}\n-\n-fn main() {\n-    simple_opt();\n-    deep_opt();\n-    opt_struct(S { a: 0, b: 1 });\n-    dont_opt();\n-    do_not_miscompile();\n-}"}]}