{"sha": "6267d8a94a7a215be446f5a431a1aae029a4e357", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNjdkOGE5NGE3YTIxNWJlNDQ2ZjVhNDMxYTFhYWUwMjlhNGUzNTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T01:38:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T01:49:22Z"}, "message": "core: De-export at_vec and extfmt", "tree": {"sha": "d1d50f6f3f08a48d5d51defd5c8aa69217b7066b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1d50f6f3f08a48d5d51defd5c8aa69217b7066b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6267d8a94a7a215be446f5a431a1aae029a4e357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6267d8a94a7a215be446f5a431a1aae029a4e357", "html_url": "https://github.com/rust-lang/rust/commit/6267d8a94a7a215be446f5a431a1aae029a4e357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6267d8a94a7a215be446f5a431a1aae029a4e357/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3d6c506a4c614dfd7ecf6c119f13107719cc6b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d6c506a4c614dfd7ecf6c119f13107719cc6b1", "html_url": "https://github.com/rust-lang/rust/commit/f3d6c506a4c614dfd7ecf6c119f13107719cc6b1"}], "stats": {"total": 153, "additions": 73, "deletions": 80}, "files": [{"sha": "9c348b9f90f26ac01ae3e4d62f3ba9bc16b08243", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6267d8a94a7a215be446f5a431a1aae029a4e357/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267d8a94a7a215be446f5a431a1aae029a4e357/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=6267d8a94a7a215be446f5a431a1aae029a4e357", "patch": "@@ -2,34 +2,24 @@\n \n use ptr::addr_of;\n \n-export init_op;\n-export capacity;\n-export build_sized, build, build_sized_opt;\n-export map;\n-export from_fn, from_elem;\n-export raw;\n-export traits;\n-\n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n-    fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+    pub fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n                                  ++v: **vec::raw::VecRepr,\n                                  ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n-    fn move_val_init<T>(&dst: T, -src: T);\n+    pub fn move_val_init<T>(&dst: T, -src: T);\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pure fn capacity<T>(&&v: @[const T]) -> uint {\n+pub pure fn capacity<T>(&&v: @[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n             ::cast::reinterpret_cast(&addr_of(v));\n@@ -50,7 +40,8 @@ pure fn capacity<T>(&&v: @[const T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> @[A] {\n+pub pure fn build_sized<A>(size: uint,\n+                           builder: fn(push: pure fn(+A))) -> @[A] {\n     let mut vec = @[];\n     unsafe { raw::reserve(vec, size); }\n     builder(|+x| unsafe { raw::push(vec, move x) });\n@@ -68,7 +59,7 @@ pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n+pub pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -85,7 +76,7 @@ pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A>(size: Option<uint>,\n+pub pure fn build_sized_opt<A>(size: Option<uint>,\n                            builder: fn(push: pure fn(+A))) -> @[A] {\n     build_sized(size.get_default(4), builder)\n }\n@@ -101,7 +92,7 @@ pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n+pub pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n         for vec::each(v) |elem| {\n             push(f(*elem));\n@@ -115,7 +106,7 @@ pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n+pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -128,7 +119,7 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n+pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(t); i += 1u; }\n@@ -137,7 +128,6 @@ pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n \n #[cfg(notest)]\n mod traits {\n-    #[legacy_exports];\n     #[cfg(stage0)]\n     impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n         #[inline(always)]\n@@ -159,10 +149,9 @@ mod traits {\n mod traits {\n     #[legacy_exports];}\n \n-mod raw {\n-    #[legacy_exports];\n-    type VecRepr = vec::raw::VecRepr;\n-    type SliceRepr = vec::raw::SliceRepr;\n+pub mod raw {\n+    pub type VecRepr = vec::raw::VecRepr;\n+    pub type SliceRepr = vec::raw::SliceRepr;\n \n     /**\n      * Sets the length of a vector\n@@ -172,13 +161,13 @@ mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n+    pub unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n-    unsafe fn push<T>(&v: @[const T], +initval: T) {\n+    pub unsafe fn push<T>(&v: @[const T], +initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n@@ -215,7 +204,7 @@ mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    unsafe fn reserve<T>(&v: @[const T], n: uint) {\n+    pub unsafe fn reserve<T>(&v: @[const T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(v) < n {\n             let ptr = addr_of(v) as **VecRepr;\n@@ -239,7 +228,7 @@ mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    unsafe fn reserve_at_least<T>(&v: @[const T], n: uint) {\n+    pub unsafe fn reserve_at_least<T>(&v: @[const T], n: uint) {\n         reserve(v, uint::next_power_of_two(n));\n     }\n "}, {"sha": "8cf097c9e834b2fdeebfc2488820400520bb7431", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6267d8a94a7a215be446f5a431a1aae029a4e357/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267d8a94a7a215be446f5a431a1aae029a4e357/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=6267d8a94a7a215be446f5a431a1aae029a4e357", "patch": "@@ -41,37 +41,36 @@ use option::{Some, None};\n  */\n \n // Functions used by the fmt extension at compile time\n-mod ct {\n-    #[legacy_exports];\n-    enum Signedness { Signed, Unsigned, }\n-    enum Caseness { CaseUpper, CaseLower, }\n-    enum Ty {\n-        TyBool,\n-        TyStr,\n-        TyChar,\n-        TyInt(Signedness),\n-        TyBits,\n-        TyHex(Caseness),\n-        TyOctal,\n-        TyFloat,\n-        TyPoly,\n-    }\n-    enum Flag {\n-        FlagLeftJustify,\n-        FlagLeftZeroPad,\n-        FlagSpaceForSign,\n-        FlagSignAlways,\n-        FlagAlternate,\n-    }\n-    enum Count {\n-        CountIs(int),\n-        CountIsParam(int),\n-        CountIsNextParam,\n-        CountImplied,\n+pub mod ct {\n+    pub enum Signedness { pub Signed, pub Unsigned, }\n+    pub enum Caseness { pub CaseUpper, pub CaseLower, }\n+    pub enum Ty {\n+        pub TyBool,\n+        pub TyStr,\n+        pub TyChar,\n+        pub TyInt(Signedness),\n+        pub TyBits,\n+        pub TyHex(Caseness),\n+        pub TyOctal,\n+        pub TyFloat,\n+        pub TyPoly,\n+    }\n+    pub enum Flag {\n+        pub FlagLeftJustify,\n+        pub FlagLeftZeroPad,\n+        pub FlagSpaceForSign,\n+        pub FlagSignAlways,\n+        pub FlagAlternate,\n+    }\n+    pub enum Count {\n+        pub CountIs(int),\n+        pub CountIsParam(int),\n+        pub CountIsNextParam,\n+        pub CountImplied,\n     }\n \n     // A formatted conversion from an expression to a string\n-    type Conv =\n+    pub type Conv =\n         {param: Option<int>,\n          flags: ~[Flag],\n          width: Count,\n@@ -80,10 +79,10 @@ mod ct {\n \n \n     // A fragment of the output sequence\n-    enum Piece { PieceString(~str), PieceConv(Conv), }\n-    type ErrorFn = fn@(~str) -> ! ;\n+    pub enum Piece { PieceString(~str), PieceConv(Conv), }\n+    pub type ErrorFn = fn@(~str) -> ! ;\n \n-    fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n+    pub fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n@@ -273,21 +272,26 @@ mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n-mod rt {\n-    #[legacy_exports];\n-    const flag_none : u32 = 0u32;\n-    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n-    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n-    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n-    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n-    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n-\n-    enum Count { CountIs(int), CountImplied, }\n-    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n-\n-    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n-\n-    pure fn conv_int(cv: Conv, i: int) -> ~str {\n+pub mod rt {\n+    pub const flag_none: u32 = 0u32;\n+    pub const flag_left_justify : u32 = 0b00000000000000000000000000000001u32;\n+    pub const flag_left_zero_pad: u32 = 0b00000000000000000000000000000010u32;\n+    pub const flag_space_for_sign:u32 = 0b00000000000000000000000000000100u32;\n+    pub const flag_sign_always  : u32 = 0b00000000000000000000000000001000u32;\n+    pub const flag_alternate    : u32 = 0b00000000000000000000000000010000u32;\n+\n+    pub enum Count { pub CountIs(int), pub CountImplied, }\n+    pub enum Ty {\n+        pub TyDefault,\n+        pub TyBits,\n+        pub TyHexUpper,\n+        pub TyHexLower,\n+        pub TyOctal\n+    }\n+\n+    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+\n+    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -300,7 +304,7 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -312,17 +316,17 @@ mod rt {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -335,7 +339,7 @@ mod rt {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n@@ -350,7 +354,7 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n+    pub pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n         let s = sys::log_str(&v);\n         return conv_str(cv, s);\n     }"}]}