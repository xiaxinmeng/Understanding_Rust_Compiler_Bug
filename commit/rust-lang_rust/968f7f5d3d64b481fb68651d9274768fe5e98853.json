{"sha": "968f7f5d3d64b481fb68651d9274768fe5e98853", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2OGY3ZjVkM2Q2NGI0ODFmYjY4NjUxZDkyNzQ3NjhmZTVlOTg4NTM=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-07-17T22:16:44Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-07-19T20:04:03Z"}, "message": "Changed methods on UDP sockets and TCP/UDP watchers to &mut self to reflect that libuv may change the underlying handle.", "tree": {"sha": "8c0ea1cca0c2ba8983eee8e4015d1aeff0f48387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c0ea1cca0c2ba8983eee8e4015d1aeff0f48387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/968f7f5d3d64b481fb68651d9274768fe5e98853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/968f7f5d3d64b481fb68651d9274768fe5e98853", "html_url": "https://github.com/rust-lang/rust/commit/968f7f5d3d64b481fb68651d9274768fe5e98853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/968f7f5d3d64b481fb68651d9274768fe5e98853/comments", "author": null, "committer": null, "parents": [{"sha": "0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "html_url": "https://github.com/rust-lang/rust/commit/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee"}], "stats": {"total": 129, "additions": 65, "deletions": 64}, "files": [{"sha": "59649dee5b914f2cc302e4869736d50b59497dff", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/968f7f5d3d64b481fb68651d9274768fe5e98853/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968f7f5d3d64b481fb68651d9274768fe5e98853/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=968f7f5d3d64b481fb68651d9274768fe5e98853", "patch": "@@ -30,7 +30,7 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn recvfrom(&self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n+    pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n         match (**self).recvfrom(buf) {\n             Ok((nread, src)) => Some((nread, src)),\n             Err(ioerr) => {\n@@ -43,7 +43,7 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn sendto(&self, buf: &[u8], dst: IpAddr) {\n+    pub fn sendto(&mut self, buf: &[u8], dst: IpAddr) {\n         match (**self).sendto(buf, dst) {\n             Ok(_) => (),\n             Err(ioerr) => io_error::cond.raise(ioerr),\n@@ -61,16 +61,17 @@ pub struct UdpStream {\n }\n \n impl UdpStream {\n-    pub fn as_socket<T>(&self, f: &fn(&UdpSocket) -> T) -> T { f(&self.socket) }\n+    pub fn as_socket<T>(&mut self, f: &fn(&mut UdpSocket) -> T) -> T { f(&mut self.socket) }\n \n     pub fn disconnect(self) -> UdpSocket { self.socket }\n }\n \n impl Reader for UdpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let peer = self.connectedTo;\n         do self.as_socket |sock| {\n             match sock.recvfrom(buf) {\n-                Some((_nread, src)) if src != self.connectedTo => Some(0),\n+                Some((_nread, src)) if src != peer => Some(0),\n                 Some((nread, _src)) => Some(nread),\n                 None => None,\n             }\n@@ -122,7 +123,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n+                    Some(ref mut server) => {\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -139,7 +140,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(client_ip) {\n-                    Some(client) => client.sendto([99], server_ip),\n+                    Some(ref mut client) => client.sendto([99], server_ip),\n                     None => fail!()\n                 }\n             }\n@@ -154,7 +155,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n+                    Some(ref mut server) => {\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -171,7 +172,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(client_ip) {\n-                    Some(client) => client.sendto([99], server_ip),\n+                    Some(ref mut client) => client.sendto([99], server_ip),\n                     None => fail!()\n                 }\n             }"}, {"sha": "10eba85188ef0aea153dd80a0809a54ebb4e24c8", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/968f7f5d3d64b481fb68651d9274768fe5e98853/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968f7f5d3d64b481fb68651d9274768fe5e98853/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=968f7f5d3d64b481fb68651d9274768fe5e98853", "patch": "@@ -50,37 +50,37 @@ pub trait IoFactory {\n \n pub trait RtioTcpListener : RtioSocket {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n-    fn accept_simultaneously(&self);\n-    fn dont_accept_simultaneously(&self);\n+    fn accept_simultaneously(&mut self);\n+    fn dont_accept_simultaneously(&mut self);\n }\n \n pub trait RtioTcpStream : RtioSocket {\n-    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&self, buf: &[u8]) -> Result<(), IoError>;\n-    fn peer_name(&self) -> IpAddr;\n-    fn control_congestion(&self);\n-    fn nodelay(&self);\n-    fn keepalive(&self, delay_in_seconds: uint);\n-    fn letdie(&self);\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn peer_name(&mut self) -> IpAddr;\n+    fn control_congestion(&mut self);\n+    fn nodelay(&mut self);\n+    fn keepalive(&mut self, delay_in_seconds: uint);\n+    fn letdie(&mut self);\n }\n \n pub trait RtioSocket {\n-    fn socket_name(&self) -> IpAddr;\n+    fn socket_name(&mut self) -> IpAddr;\n }\n \n pub trait RtioUdpSocket : RtioSocket {\n-    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n-    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n+    fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n \n-    fn join_multicast(&self, multi: IpAddr);\n-    fn leave_multicast(&self, multi: IpAddr);\n+    fn join_multicast(&mut self, multi: IpAddr);\n+    fn leave_multicast(&mut self, multi: IpAddr);\n \n-    fn loop_multicast_locally(&self);\n-    fn dont_loop_multicast_locally(&self);\n+    fn loop_multicast_locally(&mut self);\n+    fn dont_loop_multicast_locally(&mut self);\n \n-    fn multicast_time_to_live(&self, ttl: int);\n-    fn time_to_live(&self, ttl: int);\n+    fn multicast_time_to_live(&mut self, ttl: int);\n+    fn time_to_live(&mut self, ttl: int);\n \n-    fn hear_broadcasts(&self);\n-    fn ignore_broadcasts(&self);\n+    fn hear_broadcasts(&mut self);\n+    fn ignore_broadcasts(&mut self);\n }"}, {"sha": "2e0806ea38e362debb8c50be78641fa4493b1340", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/968f7f5d3d64b481fb68651d9274768fe5e98853/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968f7f5d3d64b481fb68651d9274768fe5e98853/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=968f7f5d3d64b481fb68651d9274768fe5e98853", "patch": "@@ -317,7 +317,7 @@ impl Drop for UvTcpListener {\n \n impl RtioSocket for UvTcpListener {\n     // XXX implement\n-    fn socket_name(&self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> IpAddr { fail!(); }\n }\n \n impl RtioTcpListener for UvTcpListener {\n@@ -357,8 +357,8 @@ impl RtioTcpListener for UvTcpListener {\n     }\n \n     // XXX implement\n-    fn accept_simultaneously(&self) { fail!(); }\n-    fn dont_accept_simultaneously(&self) { fail!(); }\n+    fn accept_simultaneously(&mut self) { fail!(); }\n+    fn dont_accept_simultaneously(&mut self) { fail!(); }\n }\n \n // FIXME #6090: Prefer newtype structs but Drop doesn't work\n@@ -380,11 +380,11 @@ impl Drop for UvTcpStream {\n \n impl RtioSocket for UvTcpStream {\n     // XXX implement\n-    fn socket_name(&self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> IpAddr { fail!(); }\n }\n \n impl RtioTcpStream for UvTcpStream {\n-    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n@@ -427,7 +427,7 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n-    fn write(&self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n@@ -456,11 +456,11 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     // XXX implement\n-    fn peer_name(&self) -> IpAddr { fail!(); }\n-    fn control_congestion(&self) { fail!(); }\n-    fn nodelay(&self) { fail!(); }\n-    fn keepalive(&self, _delay_in_seconds: uint) { fail!(); }\n-    fn letdie(&self) { fail!(); }\n+    fn peer_name(&mut self) -> IpAddr { fail!(); }\n+    fn control_congestion(&mut self) { fail!(); }\n+    fn nodelay(&mut self) { fail!(); }\n+    fn keepalive(&mut self, _delay_in_seconds: uint) { fail!(); }\n+    fn letdie(&mut self) { fail!(); }\n }\n \n pub struct UvUdpSocket(UdpWatcher);\n@@ -481,11 +481,11 @@ impl Drop for UvUdpSocket {\n \n impl RtioSocket for UvUdpSocket {\n     // XXX implement\n-    fn socket_name(&self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> IpAddr { fail!(); }\n }\n \n impl RtioUdpSocket for UvUdpSocket {\n-    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(uint, IpAddr), IoError>> = &result_cell;\n \n@@ -521,7 +521,7 @@ impl RtioUdpSocket for UvUdpSocket {\n         return result_cell.take();\n     }\n \n-    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n+    fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n@@ -549,17 +549,17 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n \n     // XXX implement\n-    fn join_multicast(&self, _multi: IpAddr) { fail!(); }\n-    fn leave_multicast(&self, _multi: IpAddr) { fail!(); }\n+    fn join_multicast(&mut self, _multi: IpAddr) { fail!(); }\n+    fn leave_multicast(&mut self, _multi: IpAddr) { fail!(); }\n \n-    fn loop_multicast_locally(&self) { fail!(); }\n-    fn dont_loop_multicast_locally(&self) { fail!(); }\n+    fn loop_multicast_locally(&mut self) { fail!(); }\n+    fn dont_loop_multicast_locally(&mut self) { fail!(); }\n \n-    fn multicast_time_to_live(&self, _ttl: int) { fail!(); }\n-    fn time_to_live(&self, _ttl: int) { fail!(); }\n+    fn multicast_time_to_live(&mut self, _ttl: int) { fail!(); }\n+    fn time_to_live(&mut self, _ttl: int) { fail!(); }\n \n-    fn hear_broadcasts(&self) { fail!(); }\n-    fn ignore_broadcasts(&self) { fail!(); }\n+    fn hear_broadcasts(&mut self) { fail!(); }\n+    fn ignore_broadcasts(&mut self) { fail!(); }\n }\n \n #[test]\n@@ -596,7 +596,7 @@ fn test_simple_tcp_server_and_client() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let stream = listener.accept().unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -610,7 +610,7 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let stream = (*io).tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n         }\n@@ -626,7 +626,7 @@ fn test_simple_udp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let server_socket = (*io).udp_bind(server_addr).unwrap();\n+                let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -641,7 +641,7 @@ fn test_simple_udp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let client_socket = (*io).udp_bind(client_addr).unwrap();\n+                let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n                 client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n             }\n         }\n@@ -656,7 +656,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n-            let stream = listener.accept().unwrap();\n+            let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -689,7 +689,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let stream = (*io).tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -710,7 +710,7 @@ fn test_read_read_read() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let stream = listener.accept().unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n@@ -723,7 +723,7 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let stream = (*io).tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {\n@@ -749,7 +749,7 @@ fn test_udp_twice() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let client = (*io).udp_bind(client_addr).unwrap();\n+                let mut client = (*io).udp_bind(client_addr).unwrap();\n                 assert!(client.sendto([1], server_addr).is_ok());\n                 assert!(client.sendto([2], server_addr).is_ok());\n             }\n@@ -758,7 +758,7 @@ fn test_udp_twice() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let server = (*io).udp_bind(server_addr).unwrap();\n+                let mut server = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf1 = [0];\n                 let mut buf2 = [0];\n                 let (nread1, src1) = server.recvfrom(buf1).unwrap();\n@@ -786,8 +786,8 @@ fn test_udp_many_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let server_out = (*io).udp_bind(server_out_addr).unwrap();\n-                let server_in = (*io).udp_bind(server_in_addr).unwrap();\n+                let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n+                let mut server_in = (*io).udp_bind(server_in_addr).unwrap();\n                 let msg = [1, .. 2048];\n                 let mut total_bytes_sent = 0;\n                 let mut buf = [1];\n@@ -809,8 +809,8 @@ fn test_udp_many_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let client_out = (*io).udp_bind(client_out_addr).unwrap();\n-                let client_in = (*io).udp_bind(client_in_addr).unwrap();\n+                let mut client_out = (*io).udp_bind(client_out_addr).unwrap();\n+                let mut client_in = (*io).udp_bind(client_in_addr).unwrap();\n                 let mut total_bytes_recv = 0;\n                 let mut buf = [0, .. 2048];\n                 while total_bytes_recv < MAX {"}]}