{"sha": "c9620dc0528866bda3a0d70036af082f45c78e96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NjIwZGMwNTI4ODY2YmRhM2EwZDcwMDM2YWYwODJmNDVjNzhlOTY=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-29T05:33:55Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-29T05:33:55Z"}, "message": "Move appropriate functions out of Real and into separate Algebraic, Trigonometric, Exponential and Hyperbolic traits", "tree": {"sha": "d2cf26036f74b9dc8b505bc74873150a351b7938", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2cf26036f74b9dc8b505bc74873150a351b7938"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9620dc0528866bda3a0d70036af082f45c78e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9620dc0528866bda3a0d70036af082f45c78e96", "html_url": "https://github.com/rust-lang/rust/commit/c9620dc0528866bda3a0d70036af082f45c78e96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9620dc0528866bda3a0d70036af082f45c78e96/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f03d45c56b37b36912c16bd5b4fb4723fd91cb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f03d45c56b37b36912c16bd5b4fb4723fd91cb7", "html_url": "https://github.com/rust-lang/rust/commit/9f03d45c56b37b36912c16bd5b4fb4723fd91cb7"}], "stats": {"total": 544, "additions": 293, "deletions": 251}, "files": [{"sha": "bf92a30f7ce20bd3040f531586449a48c15fb6af", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c9620dc0528866bda3a0d70036af082f45c78e96", "patch": "@@ -104,8 +104,9 @@ pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};\n \n pub use num::{Num, NumCast};\n-pub use num::{Orderable, Signed, Unsigned, Integer};\n-pub use num::{Round, Fractional, Real, RealExt};\n+pub use num::{Orderable, Signed, Unsigned, Round};\n+pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n+pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n pub use num::{Primitive, Int, Float};\n "}, {"sha": "e687f482fa98c1bfcb0f5ebfa52b5d835db445ee", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c9620dc0528866bda3a0d70036af082f45c78e96", "patch": "@@ -11,7 +11,6 @@\n //! Operations and constants for `f32`\n \n use from_str;\n-use libc::c_int;\n use num::{Zero, One, strconv};\n use prelude::*;\n \n@@ -102,8 +101,8 @@ delegate!(\n     fn sinh(n: c_float) -> c_float = c_float_utils::sinh,\n     fn tan(n: c_float) -> c_float = c_float_utils::tan,\n     fn tanh(n: c_float) -> c_float = c_float_utils::tanh,\n-    fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma)\n-\n+    fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma\n+)\n \n // These are not defined inside consts:: for consistency with\n // the integer types\n@@ -368,154 +367,153 @@ impl Fractional for f32 {\n     fn recip(&self) -> f32 { 1.0 / *self }\n }\n \n-impl Real for f32 {\n-    /// Archimedes' constant\n+impl Algebraic for f32 {\n     #[inline(always)]\n-    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline(always)]\n-    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline(always)]\n-    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n-\n-    /// pi / 3.0\n-    #[inline(always)]\n-    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n \n-    /// pi / 4.0\n     #[inline(always)]\n-    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+    fn sqrt(&self) -> f32 { sqrt(*self) }\n \n-    /// pi / 6.0\n     #[inline(always)]\n-    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n \n-    /// pi / 8.0\n     #[inline(always)]\n-    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+    fn cbrt(&self) -> f32 { cbrt(*self) }\n \n-    /// 1 .0/ pi\n     #[inline(always)]\n-    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+}\n \n-    /// 2.0 / pi\n+impl Trigonometric for f32 {\n     #[inline(always)]\n-    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+    fn sin(&self) -> f32 { sin(*self) }\n \n-    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+    fn cos(&self) -> f32 { cos(*self) }\n \n-    /// sqrt(2.0)\n     #[inline(always)]\n-    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n+    fn tan(&self) -> f32 { tan(*self) }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n+    fn asin(&self) -> f32 { asin(*self) }\n \n-    /// Euler's number\n     #[inline(always)]\n-    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+    fn acos(&self) -> f32 { acos(*self) }\n \n-    /// log2(e)\n     #[inline(always)]\n-    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+    fn atan(&self) -> f32 { atan(*self) }\n \n-    /// log10(e)\n     #[inline(always)]\n-    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+}\n \n-    /// log(2.0)\n+impl Exponential for f32 {\n     #[inline(always)]\n-    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n+    fn exp(&self) -> f32 { exp(*self) }\n \n-    /// log(10.0)\n     #[inline(always)]\n-    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n+    fn exp2(&self) -> f32 { exp2(*self) }\n \n     #[inline(always)]\n-    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n+    fn expm1(&self) -> f32 { expm1(*self) }\n \n     #[inline(always)]\n-    fn exp(&self) -> f32 { exp(*self) }\n+    fn log(&self) -> f32 { ln(*self) }\n \n     #[inline(always)]\n-    fn exp2(&self) -> f32 { exp2(*self) }\n+    fn log2(&self) -> f32 { log2(*self) }\n \n     #[inline(always)]\n-    fn expm1(&self) -> f32 { expm1(*self) }\n+    fn log10(&self) -> f32 { log10(*self) }\n+}\n \n+impl Hyperbolic for f32 {\n     #[inline(always)]\n-    fn ldexp(&self, n: int) -> f32 { ldexp(*self, n as c_int) }\n+    fn sinh(&self) -> f32 { sinh(*self) }\n \n     #[inline(always)]\n-    fn log(&self) -> f32 { ln(*self) }\n+    fn cosh(&self) -> f32 { cosh(*self) }\n \n     #[inline(always)]\n-    fn log2(&self) -> f32 { log2(*self) }\n+    fn tanh(&self) -> f32 { tanh(*self) }\n+}\n \n+impl Real for f32 {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn log10(&self) -> f32 { log10(*self) }\n+    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n \n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn log_radix(&self) -> f32 { log_radix(*self) as f32 }\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline(always)]\n-    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline(always)]\n-    fn sqrt(&self) -> f32 { sqrt(*self) }\n+    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline(always)]\n-    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n+    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline(always)]\n-    fn cbrt(&self) -> f32 { cbrt(*self) }\n+    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// pi / 8.0\n     #[inline(always)]\n-    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n+    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// 1 .0/ pi\n     #[inline(always)]\n-    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n+    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline(always)]\n-    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn sin(&self) -> f32 { sin(*self) }\n+    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n \n+    /// sqrt(2.0)\n     #[inline(always)]\n-    fn cos(&self) -> f32 { cos(*self) }\n+    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n \n+    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn tan(&self) -> f32 { tan(*self) }\n+    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n \n+    /// Euler's number\n     #[inline(always)]\n-    fn asin(&self) -> f32 { asin(*self) }\n+    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n \n+    /// log2(e)\n     #[inline(always)]\n-    fn acos(&self) -> f32 { acos(*self) }\n+    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n \n+    /// log10(e)\n     #[inline(always)]\n-    fn atan(&self) -> f32 { atan(*self) }\n+    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n \n+    /// log(2.0)\n     #[inline(always)]\n-    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n \n+    /// log(10.0)\n     #[inline(always)]\n-    fn sinh(&self) -> f32 { sinh(*self) }\n+    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n+    /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n-    fn cosh(&self) -> f32 { cosh(*self) }\n+    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n \n+    /// Converts to radians, assuming the number is in degrees\n     #[inline(always)]\n-    fn tanh(&self) -> f32 { tanh(*self) }\n+    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n }\n \n impl Bounded for f32 {"}, {"sha": "d00e6ae2c0d7936032aa8a761a83c1dbc24bd9d1", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c9620dc0528866bda3a0d70036af082f45c78e96", "patch": "@@ -109,7 +109,8 @@ delegate!(\n     fn jn(i: c_int, n: c_double) -> c_double = c_double_utils::jn,\n     fn y0(n: c_double) -> c_double = c_double_utils::y0,\n     fn y1(n: c_double) -> c_double = c_double_utils::y1,\n-    fn yn(i: c_int, n: c_double) -> c_double = c_double_utils::yn)\n+    fn yn(i: c_int, n: c_double) -> c_double = c_double_utils::yn\n+)\n \n // FIXME (#1433): obtain these in a different way\n \n@@ -378,154 +379,153 @@ impl Fractional for f64 {\n     fn recip(&self) -> f64 { 1.0 / *self }\n }\n \n-impl Real for f64 {\n-    /// Archimedes' constant\n+impl Algebraic for f64 {\n     #[inline(always)]\n-    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline(always)]\n-    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline(always)]\n-    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n+    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n \n-    /// pi / 3.0\n     #[inline(always)]\n-    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n-\n-    /// pi / 4.0\n-    #[inline(always)]\n-    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+    fn sqrt(&self) -> f64 { sqrt(*self) }\n \n-    /// pi / 6.0\n     #[inline(always)]\n-    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n \n-    /// pi / 8.0\n     #[inline(always)]\n-    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+    fn cbrt(&self) -> f64 { cbrt(*self) }\n \n-    /// 1.0 / pi\n     #[inline(always)]\n-    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+}\n \n-    /// 2.0 / pi\n+impl Trigonometric for f64 {\n     #[inline(always)]\n-    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+    fn sin(&self) -> f64 { sin(*self) }\n \n-    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+    fn cos(&self) -> f64 { cos(*self) }\n \n-    /// sqrt(2.0)\n     #[inline(always)]\n-    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n+    fn tan(&self) -> f64 { tan(*self) }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n+    fn asin(&self) -> f64 { asin(*self) }\n \n-    /// Euler's number\n     #[inline(always)]\n-    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+    fn acos(&self) -> f64 { acos(*self) }\n \n-    /// log2(e)\n     #[inline(always)]\n-    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+    fn atan(&self) -> f64 { atan(*self) }\n \n-    /// log10(e)\n     #[inline(always)]\n-    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+}\n \n-    /// log(2.0)\n+impl Exponential for f64 {\n     #[inline(always)]\n-    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n+    fn exp(&self) -> f64 { exp(*self) }\n \n-    /// log(10.0)\n     #[inline(always)]\n-    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n+    fn exp2(&self) -> f64 { exp2(*self) }\n \n     #[inline(always)]\n-    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n+    fn expm1(&self) -> f64 { expm1(*self) }\n \n     #[inline(always)]\n-    fn exp(&self) -> f64 { exp(*self) }\n+    fn log(&self) -> f64 { ln(*self) }\n \n     #[inline(always)]\n-    fn exp2(&self) -> f64 { exp2(*self) }\n+    fn log2(&self) -> f64 { log2(*self) }\n \n     #[inline(always)]\n-    fn expm1(&self) -> f64 { expm1(*self) }\n+    fn log10(&self) -> f64 { log10(*self) }\n+}\n \n+impl Hyperbolic for f64 {\n     #[inline(always)]\n-    fn ldexp(&self, n: int) -> f64 { ldexp(*self, n as c_int) }\n+    fn sinh(&self) -> f64 { sinh(*self) }\n \n     #[inline(always)]\n-    fn log(&self) -> f64 { ln(*self) }\n+    fn cosh(&self) -> f64 { cosh(*self) }\n \n     #[inline(always)]\n-    fn log2(&self) -> f64 { log2(*self) }\n+    fn tanh(&self) -> f64 { tanh(*self) }\n+}\n \n+impl Real for f64 {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn log10(&self) -> f64 { log10(*self) }\n+    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n \n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn log_radix(&self) -> f64 { log_radix(*self) }\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline(always)]\n-    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline(always)]\n-    fn sqrt(&self) -> f64 { sqrt(*self) }\n+    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline(always)]\n-    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n+    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline(always)]\n-    fn cbrt(&self) -> f64 { cbrt(*self) }\n+    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// pi / 8.0\n     #[inline(always)]\n-    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n+    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// 1.0 / pi\n     #[inline(always)]\n-    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n+    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline(always)]\n-    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline(always)]\n-    fn sin(&self) -> f64 { sin(*self) }\n+    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n \n+    /// sqrt(2.0)\n     #[inline(always)]\n-    fn cos(&self) -> f64 { cos(*self) }\n+    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n \n+    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn tan(&self) -> f64 { tan(*self) }\n+    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n \n+    /// Euler's number\n     #[inline(always)]\n-    fn asin(&self) -> f64 { asin(*self) }\n+    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n \n+    /// log2(e)\n     #[inline(always)]\n-    fn acos(&self) -> f64 { acos(*self) }\n+    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n \n+    /// log10(e)\n     #[inline(always)]\n-    fn atan(&self) -> f64 { atan(*self) }\n+    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n \n+    /// log(2.0)\n     #[inline(always)]\n-    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n \n+    /// log(10.0)\n     #[inline(always)]\n-    fn sinh(&self) -> f64 { sinh(*self) }\n+    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n+    /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n-    fn cosh(&self) -> f64 { cosh(*self) }\n+    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n \n+    /// Converts to radians, assuming the number is in degrees\n     #[inline(always)]\n-    fn tanh(&self) -> f64 { tanh(*self) }\n+    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n }\n \n impl RealExt for f64 {"}, {"sha": "3aa8848cdbed24be2d28062db49477b8bb5708d9", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 110, "deletions": 69, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=c9620dc0528866bda3a0d70036af082f45c78e96", "patch": "@@ -453,154 +453,195 @@ impl Fractional for float {\n     fn recip(&self) -> float { 1.0 / *self }\n }\n \n-impl Real for float {\n-    /// Archimedes' constant\n-    #[inline(always)]\n-    fn pi() -> float { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline(always)]\n-    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline(always)]\n-    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n-\n-    /// pi / 3.0\n+impl Algebraic for float {\n     #[inline(always)]\n-    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n+    fn pow(&self, n: float) -> float {\n+        (*self as f64).pow(n as f64) as float\n+    }\n \n-    /// pi / 4.0\n     #[inline(always)]\n-    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n+    fn sqrt(&self) -> float {\n+        (*self as f64).sqrt() as float\n+    }\n \n-    /// pi / 6.0\n     #[inline(always)]\n-    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n+    fn rsqrt(&self) -> float {\n+        (*self as f64).rsqrt() as float\n+    }\n \n-    /// pi / 8.0\n     #[inline(always)]\n-    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n+    fn cbrt(&self) -> float {\n+        (*self as f64).cbrt() as float\n+    }\n \n-    /// 1.0 / pi\n     #[inline(always)]\n-    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n+    fn hypot(&self, other: float) -> float {\n+        (*self as f64).hypot(other as f64) as float\n+    }\n+}\n \n-    /// 2.0 / pi\n+impl Trigonometric for float {\n     #[inline(always)]\n-    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n+    fn sin(&self) -> float {\n+        (*self as f64).sin() as float\n+    }\n \n-    /// 2 .0/ sqrt(pi)\n     #[inline(always)]\n-    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n+    fn cos(&self) -> float {\n+        (*self as f64).cos() as float\n+    }\n \n-    /// sqrt(2.0)\n     #[inline(always)]\n-    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n+    fn tan(&self) -> float {\n+        (*self as f64).tan() as float\n+    }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n+    fn asin(&self) -> float {\n+        (*self as f64).asin() as float\n+    }\n \n-    /// Euler's number\n     #[inline(always)]\n-    fn e() -> float { 2.71828182845904523536028747135266250 }\n+    fn acos(&self) -> float {\n+        (*self as f64).acos() as float\n+    }\n \n-    /// log2(e)\n     #[inline(always)]\n-    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n+    fn atan(&self) -> float {\n+        (*self as f64).atan() as float\n+    }\n \n-    /// log10(e)\n     #[inline(always)]\n-    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n+    fn atan2(&self, other: float) -> float {\n+        (*self as f64).atan2(other as f64) as float\n+    }\n+}\n \n-    /// log(2.0)\n+impl Exponential for float {\n     #[inline(always)]\n-    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n+    fn exp(&self) -> float {\n+        (*self as f64).exp() as float\n+    }\n \n-    /// log(10.0)\n     #[inline(always)]\n-    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n+    fn exp2(&self) -> float {\n+        (*self as f64).exp2() as float\n+    }\n \n     #[inline(always)]\n-    fn pow(&self, n: float) -> float { pow(*self as f64, n as f64) as float }\n+    fn expm1(&self) -> float {\n+        (*self as f64).expm1() as float\n+    }\n \n     #[inline(always)]\n-    fn exp(&self) -> float { exp(*self as f64) as float }\n+    fn log(&self) -> float {\n+        (*self as f64).log() as float\n+    }\n \n     #[inline(always)]\n-    fn exp2(&self) -> float { exp2(*self as f64) as float }\n+    fn log2(&self) -> float {\n+        (*self as f64).log2() as float\n+    }\n \n     #[inline(always)]\n-    fn expm1(&self) -> float { expm1(*self as f64) as float }\n+    fn log10(&self) -> float {\n+        (*self as f64).log10() as float\n+    }\n+}\n \n+impl Hyperbolic for float {\n     #[inline(always)]\n-    fn ldexp(&self, n: int) -> float { ldexp(*self as f64, n as c_int) as float }\n+    fn sinh(&self) -> float {\n+        (*self as f64).sinh() as float\n+    }\n \n     #[inline(always)]\n-    fn log(&self) -> float { ln(*self as f64) as float }\n+    fn cosh(&self) -> float {\n+        (*self as f64).cosh() as float\n+    }\n \n     #[inline(always)]\n-    fn log2(&self) -> float { log2(*self as f64) as float }\n+    fn tanh(&self) -> float {\n+        (*self as f64).tanh() as float\n+    }\n+}\n \n+impl Real for float {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn log10(&self) -> float { log10(*self as f64) as float }\n+    fn pi() -> float { 3.14159265358979323846264338327950288 }\n \n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn log_radix(&self) -> float { log_radix(*self as f64) as float }\n+    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline(always)]\n-    fn ilog_radix(&self) -> int { ilog_radix(*self as f64) as int }\n+    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline(always)]\n-    fn sqrt(&self) -> float { sqrt(*self) }\n+    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline(always)]\n-    fn rsqrt(&self) -> float { self.sqrt().recip() }\n+    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline(always)]\n-    fn cbrt(&self) -> float { cbrt(*self as f64) as float }\n+    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// pi / 8.0\n     #[inline(always)]\n-    fn to_degrees(&self) -> float { *self * (180.0 / Real::pi::<float>()) }\n+    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// 1.0 / pi\n     #[inline(always)]\n-    fn to_radians(&self) -> float { *self * (Real::pi::<float>() / 180.0) }\n+    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline(always)]\n-    fn hypot(&self, other: float) -> float { hypot(*self as f64, other as f64) as float }\n+    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n \n+    /// 2 .0/ sqrt(pi)\n     #[inline(always)]\n-    fn sin(&self) -> float { sin(*self) }\n+    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n \n+    /// sqrt(2.0)\n     #[inline(always)]\n-    fn cos(&self) -> float { cos(*self) }\n+    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n \n+    /// 1.0 / sqrt(2.0)\n     #[inline(always)]\n-    fn tan(&self) -> float { tan(*self) }\n+    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n \n+    /// Euler's number\n     #[inline(always)]\n-    fn asin(&self) -> float { asin(*self as f64) as float }\n+    fn e() -> float { 2.71828182845904523536028747135266250 }\n \n+    /// log2(e)\n     #[inline(always)]\n-    fn acos(&self) -> float { acos(*self as f64) as float }\n+    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n \n+    /// log10(e)\n     #[inline(always)]\n-    fn atan(&self) -> float { atan(*self) }\n+    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n \n+    /// log(2.0)\n     #[inline(always)]\n-    fn atan2(&self, other: float) -> float { atan2(*self as f64, other as f64) as float }\n+    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n \n+    /// log(10.0)\n     #[inline(always)]\n-    fn sinh(&self) -> float { sinh(*self as f64) as float }\n+    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n \n+    /// Converts to degrees, assuming the number is in radians\n     #[inline(always)]\n-    fn cosh(&self) -> float { cosh(*self as f64) as float }\n+    fn to_degrees(&self) -> float { (*self as f64).to_degrees() as float }\n \n+    /// Converts to radians, assuming the number is in degrees\n     #[inline(always)]\n-    fn tanh(&self) -> float { tanh(*self as f64) as float }\n+    fn to_radians(&self) -> float { (*self as f64).to_radians() as float }\n }\n \n impl RealExt for float {"}, {"sha": "6fbc2985952670ae4902ec4c06352cdf54be2834", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=c9620dc0528866bda3a0d70036af082f45c78e96", "patch": "@@ -105,14 +105,47 @@ pub trait Fractional: Num\n     fn recip(&self) -> Self;\n }\n \n+pub trait Algebraic {\n+    fn pow(&self, n: Self) -> Self;\n+    fn sqrt(&self) -> Self;\n+    fn rsqrt(&self) -> Self;\n+    fn cbrt(&self) -> Self;\n+    fn hypot(&self, other: Self) -> Self;\n+}\n+\n+pub trait Trigonometric {\n+    fn sin(&self) -> Self;\n+    fn cos(&self) -> Self;\n+    fn tan(&self) -> Self;\n+    fn asin(&self) -> Self;\n+    fn acos(&self) -> Self;\n+    fn atan(&self) -> Self;\n+    fn atan2(&self, other: Self) -> Self;\n+}\n+\n+pub trait Exponential {\n+    fn exp(&self) -> Self;\n+    fn exp2(&self) -> Self;\n+    fn expm1(&self) -> Self;\n+    fn log(&self) -> Self;\n+    fn log2(&self) -> Self;\n+    fn log10(&self) -> Self;\n+}\n+\n+pub trait Hyperbolic: Exponential {\n+    fn sinh(&self) -> Self;\n+    fn cosh(&self) -> Self;\n+    fn tanh(&self) -> Self;\n+}\n+\n ///\n /// Defines constants and methods common to real numbers\n ///\n pub trait Real: Signed\n-              + Fractional {\n-    // FIXME (#5527): usages of `int` should be replaced with an associated\n-    // integer type once these are implemented\n-\n+              + Fractional\n+              + Algebraic\n+              + Trigonometric\n+              + Hyperbolic {\n     // Common Constants\n     // FIXME (#5527): These should be associated constants\n     fn pi() -> Self;\n@@ -133,41 +166,9 @@ pub trait Real: Signed\n     fn log_2() -> Self;\n     fn log_10() -> Self;\n \n-    // Exponential functions\n-    fn pow(&self, n: Self) -> Self;\n-    fn exp(&self) -> Self;\n-    fn exp2(&self) -> Self;\n-    fn expm1(&self) -> Self;\n-    fn ldexp(&self, n: int) -> Self;\n-    fn log(&self) -> Self;\n-    fn log2(&self) -> Self;\n-    fn log10(&self) -> Self;\n-    fn log_radix(&self) -> Self;\n-    fn ilog_radix(&self) -> int;\n-    fn sqrt(&self) -> Self;\n-    fn rsqrt(&self) -> Self;\n-    fn cbrt(&self) -> Self;\n-\n     // Angular conversions\n     fn to_degrees(&self) -> Self;\n     fn to_radians(&self) -> Self;\n-\n-    // Triganomic functions\n-    fn hypot(&self, other: Self) -> Self;\n-    fn sin(&self) -> Self;\n-    fn cos(&self) -> Self;\n-    fn tan(&self) -> Self;\n-\n-    // Inverse triganomic functions\n-    fn asin(&self) -> Self;\n-    fn acos(&self) -> Self;\n-    fn atan(&self) -> Self;\n-    fn atan2(&self, other: Self) -> Self;\n-\n-    // Hyperbolic triganomic functions\n-    fn sinh(&self) -> Self;\n-    fn cosh(&self) -> Self;\n-    fn tanh(&self) -> Self;\n }\n \n ///"}, {"sha": "5fef01e65de866f02595b83ba962eca13d934dd4", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9620dc0528866bda3a0d70036af082f45c78e96/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c9620dc0528866bda3a0d70036af082f45c78e96", "patch": "@@ -38,8 +38,9 @@ pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n pub use num::{Num, NumCast};\n-pub use num::{Orderable, Signed, Unsigned, Integer};\n-pub use num::{Round, Fractional, Real, RealExt};\n+pub use num::{Orderable, Signed, Unsigned, Round};\n+pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n+pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n pub use num::{Primitive, Int, Float};\n pub use path::GenericPath;"}]}