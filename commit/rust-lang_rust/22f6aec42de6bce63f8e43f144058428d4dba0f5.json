{"sha": "22f6aec42de6bce63f8e43f144058428d4dba0f5", "node_id": "C_kwDOAAsO6NoAKDIyZjZhZWM0MmRlNmJjZTYzZjhlNDNmMTQ0MDU4NDI4ZDRkYmEwZjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T07:14:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T07:14:29Z"}, "message": "Auto merge of #101882 - Dylan-DPC:rollup-9lxwuwj, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #101722 (Rustdoc-Json: Fix Type docs.)\n - #101738 (Fix `#[link kind=\"raw-dylib\"]` to respect `#[link_name]`)\n - #101753 (Prefer explict closure sig types over expected ones)\n - #101787 (cache `collect_trait_impl_trait_tys`)\n - #101802 (Constify impl Fn* &(mut) Fn*)\n - #101809 (Replace `check_missing_items.py` with `jsondoclint`)\n - #101864 (rustdoc: remove no-op CSS `h1-4 { color: --main-color }`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c70186b88f31e6f1e97a8b30995e774ba46b9983", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c70186b88f31e6f1e97a8b30995e774ba46b9983"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f6aec42de6bce63f8e43f144058428d4dba0f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f6aec42de6bce63f8e43f144058428d4dba0f5", "html_url": "https://github.com/rust-lang/rust/commit/22f6aec42de6bce63f8e43f144058428d4dba0f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f6aec42de6bce63f8e43f144058428d4dba0f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ee5a1ac19133ecce34665c90257d4133e260fdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee5a1ac19133ecce34665c90257d4133e260fdc", "html_url": "https://github.com/rust-lang/rust/commit/0ee5a1ac19133ecce34665c90257d4133e260fdc"}, {"sha": "18d3063350809de08f98fb74479a28d7149a3d14", "url": "https://api.github.com/repos/rust-lang/rust/commits/18d3063350809de08f98fb74479a28d7149a3d14", "html_url": "https://github.com/rust-lang/rust/commit/18d3063350809de08f98fb74479a28d7149a3d14"}], "stats": {"total": 1332, "additions": 1069, "deletions": 263}, "files": [{"sha": "69f96bcbe63b43353df462f657f9f01c52b543af", "filename": "Cargo.lock", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -103,9 +103,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.60\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n+checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"array_tool\"\n@@ -1362,9 +1362,9 @@ dependencies = [\n \n [[package]]\n name = \"fs-err\"\n-version = \"2.5.0\"\n+version = \"2.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bcd1163ae48bda72a20ae26d66a04d3094135cadab911cff418ae5e33f253431\"\n+checksum = \"64db3e262960f0662f43a6366788d5f10f7f244b8f7d7d987f560baf5ded5c50\"\n \n [[package]]\n name = \"fs_extra\"\n@@ -1891,6 +1891,16 @@ dependencies = [\n  \"shlex\",\n ]\n \n+[[package]]\n+name = \"jsondoclint\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"fs-err\",\n+ \"rustdoc-json-types\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"jsonpath_lib\"\n version = \"0.2.6\"\n@@ -4445,9 +4455,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.83\"\n+version = \"1.0.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n+checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\","}, {"sha": "e49fe5e2f6356b302552384d5b0b7a3d7e8aa8e0", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -33,6 +33,7 @@ members = [\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\",\n   \"src/tools/jsondocck\",\n+  \"src/tools/jsondoclint\",\n   \"src/tools/html-checker\",\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\","}, {"sha": "257741c13f59496cbc6b58d4bacd4833764b48d1", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -560,14 +560,13 @@ impl<'tcx> Collector<'tcx> {\n             }\n         };\n \n-        let import_name_type = self\n-            .tcx\n-            .codegen_fn_attrs(item.id.def_id)\n+        let codegen_fn_attrs = self.tcx.codegen_fn_attrs(item.id.def_id);\n+        let import_name_type = codegen_fn_attrs\n             .link_ordinal\n             .map_or(import_name_type, |ord| Some(PeImportNameType::Ordinal(ord)));\n \n         DllImport {\n-            name: item.ident.name,\n+            name: codegen_fn_attrs.link_name.unwrap_or(item.ident.name),\n             import_name_type,\n             calling_convention,\n             span: item.span,"}, {"sha": "6bdf5a023b6c39cd795dae1b0b422f021177f7f1", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -102,7 +102,7 @@ macro_rules! arena_types {\n \n             [] dep_kind: rustc_middle::dep_graph::DepKindStruct<'tcx>,\n \n-            [] trait_impl_trait_tys: rustc_data_structures::fx::FxHashMap<rustc_hir::def_id::DefId, rustc_middle::ty::Ty<'tcx>>,\n+            [decode] trait_impl_trait_tys: rustc_data_structures::fx::FxHashMap<rustc_hir::def_id::DefId, rustc_middle::ty::Ty<'tcx>>,\n         ]);\n     )\n }"}, {"sha": "53c254119f436fe586eda306cf63f4f82d1dc75f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -164,7 +164,8 @@ rustc_queries! {\n     query collect_trait_impl_trait_tys(key: DefId)\n         -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>\n     {\n-        desc { \"better description please\" }\n+        desc { \"compare an impl and trait method signature, inferring any hidden `impl Trait` types in the process\" }\n+        cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n "}, {"sha": "0e93f3ce1d646d7510eabef8aa7e3f42cf2e0d87", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -798,6 +798,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId>\n     }\n }\n \n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashMap<DefId, Ty<'tcx>> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     for &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>>\n {"}, {"sha": "9b943b160f39344d589af2f44bdd6298b6adcc41", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -30,7 +30,12 @@ struct ExpectedSig<'tcx> {\n }\n \n struct ClosureSignatures<'tcx> {\n+    /// The signature users of the closure see.\n     bound_sig: ty::PolyFnSig<'tcx>,\n+    /// The signature within the function body.\n+    /// This mostly differs in the sense that lifetimes are now early bound and any\n+    /// opaque types from the signature expectation are overriden in case there are\n+    /// explicit hidden types written by the user in the closure signature.\n     liberated_sig: ty::FnSig<'tcx>,\n }\n \n@@ -444,18 +449,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Along the way, it also writes out entries for types that the user\n         // wrote into our typeck results, which are then later used by the privacy\n         // check.\n-        match self.check_supplied_sig_against_expectation(\n+        match self.merge_supplied_sig_with_expectation(\n             hir_id,\n             expr_def_id,\n             decl,\n             body,\n-            &closure_sigs,\n+            closure_sigs,\n         ) {\n             Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n-            Err(_) => return self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body),\n+            Err(_) => self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body),\n         }\n-\n-        closure_sigs\n     }\n \n     fn sig_of_closure_with_mismatched_number_of_arguments(\n@@ -497,21 +500,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Enforce the user's types against the expectation. See\n     /// `sig_of_closure_with_expectation` for details on the overall\n     /// strategy.\n-    fn check_supplied_sig_against_expectation(\n+    #[instrument(level = \"debug\", skip(self, hir_id, expr_def_id, decl, body, expected_sigs))]\n+    fn merge_supplied_sig_with_expectation(\n         &self,\n         hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n-        expected_sigs: &ClosureSignatures<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n+        mut expected_sigs: ClosureSignatures<'tcx>,\n+    ) -> InferResult<'tcx, ClosureSignatures<'tcx>> {\n         // Get the signature S that the user gave.\n         //\n         // (See comment on `sig_of_closure_with_expectation` for the\n         // meaning of these letters.)\n         let supplied_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n \n-        debug!(\"check_supplied_sig_against_expectation: supplied_sig={:?}\", supplied_sig);\n+        debug!(?supplied_sig);\n \n         // FIXME(#45727): As discussed in [this comment][c1], naively\n         // forcing equality here actually results in suboptimal error\n@@ -529,23 +533,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796\n         self.commit_if_ok(|_| {\n             let mut all_obligations = vec![];\n+            let inputs: Vec<_> = iter::zip(\n+                decl.inputs,\n+                supplied_sig.inputs().skip_binder(), // binder moved to (*) below\n+            )\n+            .map(|(hir_ty, &supplied_ty)| {\n+                // Instantiate (this part of..) S to S', i.e., with fresh variables.\n+                self.replace_bound_vars_with_fresh_vars(\n+                    hir_ty.span,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    // (*) binder moved to here\n+                    supplied_sig.inputs().rebind(supplied_ty),\n+                )\n+            })\n+            .collect();\n \n             // The liberated version of this signature should be a subtype\n             // of the liberated form of the expectation.\n             for ((hir_ty, &supplied_ty), expected_ty) in iter::zip(\n-                iter::zip(\n-                    decl.inputs,\n-                    supplied_sig.inputs().skip_binder(), // binder moved to (*) below\n-                ),\n+                iter::zip(decl.inputs, &inputs),\n                 expected_sigs.liberated_sig.inputs(), // `liberated_sig` is E'.\n             ) {\n-                // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                let supplied_ty = self.replace_bound_vars_with_fresh_vars(\n-                    hir_ty.span,\n-                    LateBoundRegionConversionTime::FnCall,\n-                    supplied_sig.inputs().rebind(supplied_ty),\n-                ); // recreated from (*) above\n-\n                 // Check that E' = S'.\n                 let cause = self.misc(hir_ty.span);\n                 let InferOk { value: (), obligations } =\n@@ -564,7 +572,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n             all_obligations.extend(obligations);\n \n-            Ok(InferOk { value: (), obligations: all_obligations })\n+            let inputs = inputs.into_iter().map(|ty| self.resolve_vars_if_possible(ty));\n+\n+            expected_sigs.liberated_sig = self.tcx.mk_fn_sig(\n+                inputs,\n+                supplied_output_ty,\n+                expected_sigs.liberated_sig.c_variadic,\n+                hir::Unsafety::Normal,\n+                Abi::RustCall,\n+            );\n+\n+            Ok(InferOk { value: expected_sigs, obligations: all_obligations })\n         })\n     }\n "}, {"sha": "8fdf22cf6f2c873a46c5681528519d2ca73e7acc", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -250,29 +250,32 @@ pub trait FnOnce<Args> {\n \n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A, F: ?Sized> Fn<A> for &F\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A, F: ?Sized> const Fn<A> for &F\n     where\n-        F: Fn<A>,\n+        F: ~const Fn<A>,\n     {\n         extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A, F: ?Sized> FnMut<A> for &F\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A, F: ?Sized> const FnMut<A> for &F\n     where\n-        F: Fn<A>,\n+        F: ~const Fn<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A, F: ?Sized> FnOnce<A> for &F\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A, F: ?Sized> const FnOnce<A> for &F\n     where\n-        F: Fn<A>,\n+        F: ~const Fn<A>,\n     {\n         type Output = F::Output;\n \n@@ -282,19 +285,21 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A, F: ?Sized> FnMut<A> for &mut F\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A, F: ?Sized> const FnMut<A> for &mut F\n     where\n-        F: FnMut<A>,\n+        F: ~const FnMut<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A, F: ?Sized> FnOnce<A> for &mut F\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A, F: ?Sized> const FnOnce<A> for &mut F\n     where\n-        F: FnMut<A>,\n+        F: ~const FnMut<A>,\n     {\n         type Output = F::Output;\n         extern \"rust-call\" fn call_once(self, args: A) -> F::Output {"}, {"sha": "9d286ddd6d1646e107643f83c9c19e8af07c96c2", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -1341,6 +1341,8 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             let json_compiler = compiler.with_stage(0);\n             cmd.arg(\"--jsondocck-path\")\n                 .arg(builder.ensure(tool::JsonDocCk { compiler: json_compiler, target }));\n+            cmd.arg(\"--jsondoclint-path\")\n+                .arg(builder.ensure(tool::JsonDocLint { compiler: json_compiler, target }));\n         }\n \n         if mode == \"run-make\" {"}, {"sha": "7d4ed24b64850c6422e9f5566d70b5278ced0c6b", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -376,6 +376,7 @@ bootstrap_tool!(\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n     LintDocs, \"src/tools/lint-docs\", \"lint-docs\";\n     JsonDocCk, \"src/tools/jsondocck\", \"jsondocck\";\n+    JsonDocLint, \"src/tools/jsondoclint\", \"jsondoclint\";\n     HtmlChecker, \"src/tools/html-checker\", \"html-checker\";\n     BumpStage0, \"src/tools/bump-stage0\", \"bump-stage0\";\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";"}, {"sha": "0026c4cbdca2ce609a64d5df04f02c3680bb1d33", "filename": "src/etc/check_missing_items.py", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/0ee5a1ac19133ecce34665c90257d4133e260fdc/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/0ee5a1ac19133ecce34665c90257d4133e260fdc/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=0ee5a1ac19133ecce34665c90257d4133e260fdc", "patch": "@@ -1,202 +0,0 @@\n-#!/usr/bin/env python\n-\n-# This test ensures that every ID in the produced json actually resolves to an item either in\n-# `index` or `paths`. It DOES NOT check that the structure of the produced json is actually in\n-# any way correct, for example an empty map would pass.\n-\n-# FIXME: Better error output\n-\n-import sys\n-import json\n-\n-crate = json.load(open(sys.argv[1], encoding=\"utf-8\"))\n-\n-\n-def get_local_item(item_id):\n-    if item_id in crate[\"index\"]:\n-        return crate[\"index\"][item_id]\n-    print(\"Missing local ID:\", item_id)\n-    sys.exit(1)\n-\n-\n-# local IDs have to be in `index`, external ones can sometimes be in `index` but otherwise have\n-# to be in `paths`\n-def valid_id(item_id):\n-    return item_id in crate[\"index\"] or item_id[0] != \"0\" and item_id in crate[\"paths\"]\n-\n-\n-def check_generics(generics):\n-    for param in generics[\"params\"]:\n-        check_generic_param(param)\n-    for where_predicate in generics[\"where_predicates\"]:\n-        if \"bound_predicate\" in where_predicate:\n-            pred = where_predicate[\"bound_predicate\"]\n-            check_type(pred[\"type\"])\n-            for bound in pred[\"bounds\"]:\n-                check_generic_bound(bound)\n-        elif \"region_predicate\" in where_predicate:\n-            pred = where_predicate[\"region_predicate\"]\n-            for bound in pred[\"bounds\"]:\n-                check_generic_bound(bound)\n-        elif \"eq_predicate\" in where_predicate:\n-            pred = where_predicate[\"eq_predicate\"]\n-            check_type(pred[\"rhs\"])\n-            check_type(pred[\"lhs\"])\n-\n-\n-def check_generic_param(param):\n-    if \"type\" in param[\"kind\"]:\n-        ty = param[\"kind\"][\"type\"]\n-        if ty[\"default\"]:\n-            check_type(ty[\"default\"])\n-        for bound in ty[\"bounds\"]:\n-            check_generic_bound(bound)\n-    elif \"const\" in param[\"kind\"]:\n-        check_type(param[\"kind\"][\"const\"])\n-\n-\n-def check_generic_bound(bound):\n-    if \"trait_bound\" in bound:\n-        for param in bound[\"trait_bound\"][\"generic_params\"]:\n-            check_generic_param(param)\n-        check_path(bound[\"trait_bound\"][\"trait\"])\n-\n-\n-def check_decl(decl):\n-    for (_name, ty) in decl[\"inputs\"]:\n-        check_type(ty)\n-    if decl[\"output\"]:\n-        check_type(decl[\"output\"])\n-\n-def check_path(path):\n-    args = path[\"args\"]\n-    if args:\n-        if \"angle_bracketed\" in args:\n-            for arg in args[\"angle_bracketed\"][\"args\"]:\n-                if \"type\" in arg:\n-                    check_type(arg[\"type\"])\n-                elif \"const\" in arg:\n-                    check_type(arg[\"const\"][\"type\"])\n-            for binding in args[\"angle_bracketed\"][\"bindings\"]:\n-                if \"equality\" in binding[\"binding\"]:\n-                    term = binding[\"binding\"][\"equality\"]\n-                    if \"type\" in term: check_type(term[\"type\"])\n-                    elif \"const\" in term: check_type(term[\"const\"])\n-                elif \"constraint\" in binding[\"binding\"]:\n-                    for bound in binding[\"binding\"][\"constraint\"]:\n-                        check_generic_bound(bound)\n-        elif \"parenthesized\" in args:\n-            for input_ty in args[\"parenthesized\"][\"inputs\"]:\n-                check_type(input_ty)\n-            if args[\"parenthesized\"][\"output\"]:\n-                check_type(args[\"parenthesized\"][\"output\"])\n-\n-    if path[\"id\"] in crate[\"index\"]:\n-        work_list.add(path[\"id\"])\n-    elif path[\"id\"] not in crate[\"paths\"]:\n-        print(\"Id not in index or paths:\", path[\"id\"])\n-        sys.exit(1)\n-\n-def check_type(ty):\n-    if ty[\"kind\"] == \"resolved_path\":\n-        check_path(ty[\"inner\"])\n-    elif ty[\"kind\"] == \"tuple\":\n-        for ty in ty[\"inner\"]:\n-            check_type(ty)\n-    elif ty[\"kind\"] == \"slice\":\n-        check_type(ty[\"inner\"])\n-    elif ty[\"kind\"] == \"impl_trait\":\n-        for bound in ty[\"inner\"]:\n-            check_generic_bound(bound)\n-    elif ty[\"kind\"] in (\"raw_pointer\", \"borrowed_ref\", \"array\"):\n-        check_type(ty[\"inner\"][\"type\"])\n-    elif ty[\"kind\"] == \"function_pointer\":\n-        for param in ty[\"inner\"][\"generic_params\"]:\n-            check_generic_param(param)\n-        check_decl(ty[\"inner\"][\"decl\"])\n-    elif ty[\"kind\"] == \"qualified_path\":\n-        check_type(ty[\"inner\"][\"self_type\"])\n-        check_path(ty[\"inner\"][\"trait\"])\n-\n-\n-work_list = set([crate[\"root\"]])\n-visited = work_list.copy()\n-\n-while work_list:\n-    current = work_list.pop()\n-    visited.add(current)\n-    item = get_local_item(current)\n-    # check intradoc links\n-    for (_name, link) in item[\"links\"].items():\n-        if not valid_id(link):\n-            print(\"Intra-doc link contains invalid ID:\", link)\n-\n-    # check all fields that reference types such as generics as well as nested items\n-    # (modules, structs, traits, and enums)\n-    if item[\"kind\"] == \"module\":\n-        work_list |= set(item[\"inner\"][\"items\"]) - visited\n-    elif item[\"kind\"] == \"struct\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        work_list |= set(item[\"inner\"][\"impls\"]) - visited\n-        if \"tuple\" in item[\"inner\"][\"kind\"]:\n-            work_list |= set(filter(None, item[\"inner\"][\"kind\"][\"tuple\"])) - visited\n-        elif \"plain\" in item[\"inner\"][\"kind\"]:\n-            work_list |= set(item[\"inner\"][\"kind\"][\"plain\"][\"fields\"]) - visited\n-    elif item[\"kind\"] == \"struct_field\":\n-        check_type(item[\"inner\"])\n-    elif item[\"kind\"] == \"enum\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        work_list |= (\n-            set(item[\"inner\"][\"variants\"]) | set(item[\"inner\"][\"impls\"])\n-        ) - visited\n-    elif item[\"kind\"] == \"variant\":\n-        if item[\"inner\"][\"variant_kind\"] == \"tuple\":\n-            for field_id in filter(None, item[\"inner\"][\"variant_inner\"]):\n-                work_list.add(field_id)\n-        elif item[\"inner\"][\"variant_kind\"] == \"struct\":\n-            work_list |= set(item[\"inner\"][\"variant_inner\"][\"fields\"]) - visited\n-    elif item[\"kind\"] in (\"function\", \"method\"):\n-        check_generics(item[\"inner\"][\"generics\"])\n-        check_decl(item[\"inner\"][\"decl\"])\n-    elif item[\"kind\"] in (\"static\", \"constant\", \"assoc_const\"):\n-        check_type(item[\"inner\"][\"type\"])\n-    elif item[\"kind\"] == \"typedef\":\n-        check_type(item[\"inner\"][\"type\"])\n-        check_generics(item[\"inner\"][\"generics\"])\n-    elif item[\"kind\"] == \"opaque_ty\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-    elif item[\"kind\"] == \"trait_alias\":\n-        check_generics(item[\"inner\"][\"params\"])\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-    elif item[\"kind\"] == \"trait\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-        work_list |= (\n-            set(item[\"inner\"][\"items\"]) | set(item[\"inner\"][\"implementations\"])\n-        ) - visited\n-    elif item[\"kind\"] == \"impl\":\n-        check_generics(item[\"inner\"][\"generics\"])\n-        if item[\"inner\"][\"trait\"]:\n-            check_path(item[\"inner\"][\"trait\"])\n-        if item[\"inner\"][\"blanket_impl\"]:\n-            check_type(item[\"inner\"][\"blanket_impl\"])\n-        check_type(item[\"inner\"][\"for\"])\n-        for assoc_item in item[\"inner\"][\"items\"]:\n-            if not valid_id(assoc_item):\n-                print(\"Impl block referenced a missing ID:\", assoc_item)\n-                sys.exit(1)\n-    elif item[\"kind\"] == \"assoc_type\":\n-        for bound in item[\"inner\"][\"bounds\"]:\n-            check_generic_bound(bound)\n-        if item[\"inner\"][\"default\"]:\n-            check_type(item[\"inner\"][\"default\"])\n-    elif item[\"kind\"] == \"import\":\n-        if item[\"inner\"][\"id\"]:\n-            inner_id = item[\"inner\"][\"id\"]\n-            assert valid_id(inner_id)\n-            if inner_id in crate[\"index\"] and inner_id not in visited:\n-                work_list.add(inner_id)"}, {"sha": "b0dcd36d6b344e4f83e463946d79906e82826bc1", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -222,7 +222,6 @@ details.rustdoc-toggle.non-exhaustive > summary::before,\n \tfont-family: \"Fira Sans\", Arial, NanumBarunGothic, sans-serif;\n }\n \n-h1, h2, h3, h4,\n a#toggle-all-docs,\n a.anchor,\n .small-section-header a,"}, {"sha": "be1ff286efd10aaceffd2c8c99f427114a106b35", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -542,12 +542,12 @@ pub enum Term {\n #[serde(rename_all = \"snake_case\")]\n #[serde(tag = \"kind\", content = \"inner\")]\n pub enum Type {\n-    /// Structs, enums, and traits\n+    /// Structs and enums\n     ResolvedPath(Path),\n     DynTrait(DynTrait),\n     /// Parameterized types\n     Generic(String),\n-    /// Fixed-size numeric types (plus int/usize/float), char, arrays, slices, and tuples\n+    /// Built in numberic (i*, u*, f*) types, bool, and char\n     Primitive(String),\n     /// `extern \"ABI\" fn`\n     FunctionPointer(Box<FunctionPointer>),"}, {"sha": "96fc7e6493ab94dc7e19a5e503c4bcd87791ef01", "filename": "src/test/mir-opt/retag.main-{closure#0}.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -14,7 +14,7 @@ fn main::{closure#0}(_1: &[closure@main::{closure#0}], _2: &i32) -> &i32 {\n         StorageLive(_3);                 // scope 0 at $DIR/retag.rs:+1:13: +1:15\n         _3 = _2;                         // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:18: +1:19\n-        _0 = _2;                         // scope 1 at $DIR/retag.rs:+2:9: +2:10\n+        _0 = &(*_2);                     // scope 1 at $DIR/retag.rs:+2:9: +2:10\n         Retag(_0);                       // scope 1 at $DIR/retag.rs:+2:9: +2:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+3:5: +3:6\n         return;                          // scope 0 at $DIR/retag.rs:+3:6: +3:6"}, {"sha": "344d4a6bf5a8d0394f890700404c4939e815932c", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/extern.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Fextern.c", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Fextern.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Fextern.c?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -70,6 +70,11 @@ __declspec(dllexport) void __stdcall stdcall_fn_9(uint8_t x, double y) {\n     fflush(stdout);\n }\n \n+__declspec(dllexport) void __stdcall stdcall_fn_10(int i) {\n+    printf(\"stdcall_fn_10(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n __declspec(dllexport) void __fastcall fastcall_fn_1(int i) {\n     printf(\"fastcall_fn_1(%d)\\n\", i);\n     fflush(stdout);\n@@ -122,6 +127,11 @@ __declspec(dllexport) void __fastcall fastcall_fn_9(uint8_t x, double y) {\n     fflush(stdout);\n }\n \n+__declspec(dllexport) void __fastcall fastcall_fn_10(int i) {\n+    printf(\"fastcall_fn_10(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n // GCC doesn't support vectorcall: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89485\n #ifdef _MSC_VER\n __declspec(dllexport) void __vectorcall vectorcall_fn_1(int i) {\n@@ -175,4 +185,9 @@ __declspec(dllexport) void __vectorcall vectorcall_fn_9(uint8_t x, double y) {\n     printf(\"vectorcall_fn_9(%d, %.1f)\\n\", x, y);\n     fflush(stdout);\n }\n+\n+__declspec(dllexport) void __vectorcall vectorcall_fn_10(int i) {\n+    printf(\"vectorcall_fn_10(%d)\\n\", i);\n+    fflush(stdout);\n+}\n #endif"}, {"sha": "22f222c12c39bfd6e620f3a5f659dc9f7a662706", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Flib.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -32,6 +32,8 @@ extern \"stdcall\" {\n     fn stdcall_fn_7(a: S2, b: i32);\n     fn stdcall_fn_8(a: S3, b: S3);\n     fn stdcall_fn_9(x: u8, y: f64);\n+    #[link_name = \"stdcall_fn_10\"]\n+    fn stdcall_fn_10_renamed(i: i32);\n }\n \n #[link(name = \"extern\", kind = \"raw-dylib\")]\n@@ -45,6 +47,8 @@ extern \"fastcall\" {\n     fn fastcall_fn_7(a: S2, b: i32);\n     fn fastcall_fn_8(a: S3, b: S3);\n     fn fastcall_fn_9(x: u8, y: f64);\n+    #[link_name = \"fastcall_fn_10\"]\n+    fn fastcall_fn_10_renamed(i: i32);\n }\n \n #[cfg(target_env = \"msvc\")]\n@@ -59,6 +63,8 @@ extern \"vectorcall\" {\n     fn vectorcall_fn_7(a: S2, b: i32);\n     fn vectorcall_fn_8(a: S3, b: S3);\n     fn vectorcall_fn_9(x: u8, y: f64);\n+    #[link_name = \"vectorcall_fn_10\"]\n+    fn vectorcall_fn_10_renamed(i: i32);\n }\n \n pub fn library_function(run_msvc_only: bool) {\n@@ -73,6 +79,7 @@ pub fn library_function(run_msvc_only: bool) {\n             stdcall_fn_7(S2 { x: 15, y: 16 }, 3);\n             stdcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] });\n             stdcall_fn_9(1, 3.0);\n+            stdcall_fn_10_renamed(19);\n \n             fastcall_fn_1(14);\n             fastcall_fn_2(16, 3.5);\n@@ -81,6 +88,7 @@ pub fn library_function(run_msvc_only: bool) {\n             fastcall_fn_6(Some(&S { x: 10, y: 12 }));\n             fastcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] });\n             fastcall_fn_9(1, 3.0);\n+            fastcall_fn_10_renamed(19);\n         } else {\n             // FIXME: 91167\n             // rustc generates incorrect code for the calls to fastcall_fn_5 and fastcall_fn_7\n@@ -100,6 +108,7 @@ pub fn library_function(run_msvc_only: bool) {\n                 vectorcall_fn_7(S2 { x: 15, y: 16 }, 3);\n                 vectorcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] });\n                 vectorcall_fn_9(1, 3.0);\n+                vectorcall_fn_10_renamed(19);\n             }\n         }\n     }"}, {"sha": "a216835c4b62f8dbb96592b5f83056ea200daaf9", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/output.msvc.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.msvc.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.msvc.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.msvc.txt?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -9,3 +9,4 @@ vectorcall_fn_6(S { x: 10, y: 12 })\n vectorcall_fn_7(S2 { x: 15, y: 16 }, 3)\n vectorcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\n vectorcall_fn_9(1, 3.0)\n+vectorcall_fn_10(19)"}, {"sha": "7622d31618b8061a6dd01e3003b031f2de4372e6", "filename": "src/test/run-make/raw-dylib-alt-calling-convention/output.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-alt-calling-convention%2Foutput.txt?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -7,10 +7,12 @@ stdcall_fn_6(S { x: 10, y: 12 })\n stdcall_fn_7(S2 { x: 15, y: 16 }, 3)\n stdcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\n stdcall_fn_9(1, 3.0)\n+stdcall_fn_10(19)\n fastcall_fn_1(14)\n fastcall_fn_2(16, 3.5)\n fastcall_fn_3(3.5)\n fastcall_fn_4(1, 2, 3.0)\n fastcall_fn_6(S { x: 10, y: 12 })\n fastcall_fn_8(S3 { x: [1, 2, 3, 4, 5] }, S3 { x: [6, 7, 8, 9, 10] })\n fastcall_fn_9(1, 3.0)\n+fastcall_fn_10(19)"}, {"sha": "5d695547d0f5e01693cf6d6b0cbd80adf1c186ae", "filename": "src/test/run-make/raw-dylib-c/extern_1.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Fextern_1.c", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Fextern_1.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Fextern_1.c?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -21,3 +21,8 @@ __declspec(dllexport) void extern_fn_with_long_name() {\n     printf(\"extern_fn_with_long_name; got the rename\\n\");\n     fflush(stdout);\n }\n+\n+__declspec(dllexport) void extern_fn_4() {\n+    printf(\"extern_fn_4\\n\");\n+    fflush(stdout);\n+}"}, {"sha": "005ffcdda5c2ed84b76a5c32109a17c6fe9ff0e5", "filename": "src/test/run-make/raw-dylib-c/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Flib.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -16,12 +16,15 @@ pub fn library_function() {\n         fn extern_fn_2();\n         fn print_extern_variable();\n         static mut extern_variable: i32;\n+        #[link_name = \"extern_fn_4\"]\n+        fn extern_fn_4_renamed();\n     }\n \n     unsafe {\n         extern_fn_1();\n         extern_fn_2();\n         extern_fn_3();\n+        extern_fn_4_renamed();\n         extern_variable = 42;\n         print_extern_variable();\n         extern_variable = -42;"}, {"sha": "cc970cef7bcaa63766ae39057c3c70631d0e8c98", "filename": "src/test/run-make/raw-dylib-c/output.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Foutput.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Foutput.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-c%2Foutput.txt?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -1,5 +1,6 @@\n extern_fn_1\n extern_fn_2; didn't get the rename\n extern_fn_3\n+extern_fn_4\n extern_variable value: 42\n extern_variable value: -42"}, {"sha": "a38849fc8130a3d3c186dcecca2e1eb4c133dbe0", "filename": "src/test/run-make/raw-dylib-import-name-type/driver.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fdriver.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -1,8 +1,11 @@\n #![feature(raw_dylib)]\n+#![feature(abi_vectorcall)]\n \n #[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"undecorated\")]\n extern \"C\" {\n     fn cdecl_fn_undecorated(i: i32);\n+    #[link_name = \"cdecl_fn_undecorated2\"]\n+    fn cdecl_fn_undecorated_renamed(i: i32);\n     static mut extern_variable_undecorated: i32;\n }\n \n@@ -21,6 +24,8 @@ extern \"C\" {\n #[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"undecorated\")]\n extern \"stdcall\" {\n     fn stdcall_fn_undecorated(i: i32);\n+    #[link_name = \"stdcall_fn_undecorated2\"]\n+    fn stdcall_fn_undecorated_renamed(i: i32);\n }\n \n #[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"noprefix\")]\n@@ -36,6 +41,8 @@ extern \"stdcall\" {\n #[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"undecorated\")]\n extern \"fastcall\" {\n     fn fastcall_fn_undecorated(i: i32);\n+    #[link_name = \"fastcall_fn_undecorated2\"]\n+    fn fastcall_fn_undecorated_renamed(i: i32);\n }\n \n #[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"noprefix\")]\n@@ -48,6 +55,26 @@ extern \"fastcall\" {\n     fn fastcall_fn_decorated(i: i32);\n }\n \n+#[cfg(target_env = \"msvc\")]\n+#[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"undecorated\")]\n+extern \"vectorcall\" {\n+    fn vectorcall_fn_undecorated(i: i32);\n+    #[link_name = \"vectorcall_fn_undecorated2\"]\n+    fn vectorcall_fn_undecorated_renamed(i: i32);\n+}\n+\n+#[cfg(target_env = \"msvc\")]\n+#[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"noprefix\")]\n+extern \"vectorcall\" {\n+    fn vectorcall_fn_noprefix(i: i32);\n+}\n+\n+#[cfg(target_env = \"msvc\")]\n+#[link(name = \"extern\", kind = \"raw-dylib\", import_name_type = \"decorated\")]\n+extern \"vectorcall\" {\n+    fn vectorcall_fn_decorated(i: i32);\n+}\n+\n #[link(name = \"extern\", kind = \"raw-dylib\")]\n extern {\n     fn print_extern_variable_undecorated();\n@@ -58,14 +85,17 @@ extern {\n pub fn main() {\n     unsafe {\n         cdecl_fn_undecorated(1);\n+        cdecl_fn_undecorated_renamed(10);\n         cdecl_fn_noprefix(2);\n         cdecl_fn_decorated(3);\n \n         stdcall_fn_undecorated(4);\n+        stdcall_fn_undecorated_renamed(14);\n         stdcall_fn_noprefix(5);\n         stdcall_fn_decorated(6);\n \n         fastcall_fn_undecorated(7);\n+        fastcall_fn_undecorated_renamed(17);\n         fastcall_fn_noprefix(8);\n         fastcall_fn_decorated(9);\n \n@@ -75,5 +105,21 @@ pub fn main() {\n         print_extern_variable_noprefix();\n         extern_variable_decorated = 44;\n         print_extern_variable_decorated();\n+\n+        // GCC doesn't support vectorcall: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89485\n+        #[cfg(target_env = \"msvc\")]\n+        {\n+            vectorcall_fn_undecorated(10);\n+            vectorcall_fn_undecorated_renamed(20);\n+            vectorcall_fn_noprefix(11);\n+            vectorcall_fn_decorated(12);\n+        }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        {\n+            println!(\"vectorcall_fn_undecorated(10)\");\n+            println!(\"vectorcall_fn_undecorated2(20)\");\n+            println!(\"vectorcall_fn_noprefix(11)\");\n+            println!(\"vectorcall_fn_decorated(12)\");\n+        }\n     }\n }"}, {"sha": "195126d51294ccb58d47eb8d894286b06723fe12", "filename": "src/test/run-make/raw-dylib-import-name-type/extern.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.c", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.c?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -6,6 +6,11 @@ void _cdecl cdecl_fn_undecorated(int i) {\n     fflush(stdout);\n }\n \n+void _cdecl cdecl_fn_undecorated2(int i) {\n+    printf(\"cdecl_fn_undecorated2(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n void _cdecl cdecl_fn_noprefix(int i) {\n     printf(\"cdecl_fn_noprefix(%d)\\n\", i);\n     fflush(stdout);\n@@ -21,6 +26,11 @@ void __stdcall stdcall_fn_undecorated(int i) {\n     fflush(stdout);\n }\n \n+void __stdcall stdcall_fn_undecorated2(int i) {\n+    printf(\"stdcall_fn_undecorated2(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n void __stdcall stdcall_fn_noprefix(int i) {\n     printf(\"stdcall_fn_noprefix(%d)\\n\", i);\n     fflush(stdout);\n@@ -36,6 +46,11 @@ void __fastcall fastcall_fn_undecorated(int i) {\n     fflush(stdout);\n }\n \n+void __fastcall fastcall_fn_undecorated2(int i) {\n+    printf(\"fastcall_fn_undecorated2(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n void __fastcall fastcall_fn_noprefix(int i) {\n     printf(\"fastcall_fn_noprefix(%d)\\n\", i);\n     fflush(stdout);\n@@ -63,3 +78,26 @@ __declspec(dllexport) void print_extern_variable_decorated() {\n     printf(\"extern_variable_decorated value: %d\\n\", extern_variable_decorated);\n     fflush(stdout);\n }\n+\n+// GCC doesn't support vectorcall: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89485\n+#ifdef _MSC_VER\n+void __vectorcall vectorcall_fn_undecorated(int i) {\n+    printf(\"vectorcall_fn_undecorated(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n+void __vectorcall vectorcall_fn_undecorated2(int i) {\n+    printf(\"vectorcall_fn_undecorated2(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n+void __vectorcall vectorcall_fn_noprefix(int i) {\n+    printf(\"vectorcall_fn_noprefix(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+\n+void __vectorcall vectorcall_fn_decorated(int i) {\n+    printf(\"vectorcall_fn_decorated(%d)\\n\", i);\n+    fflush(stdout);\n+}\n+#endif"}, {"sha": "a523c959a4744c1d218642eb0863559331136e32", "filename": "src/test/run-make/raw-dylib-import-name-type/extern.gnu.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.gnu.def", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.gnu.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.gnu.def?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -1,11 +1,14 @@\n LIBRARY extern\n EXPORTS\n     cdecl_fn_undecorated\n+    cdecl_fn_undecorated2\n     cdecl_fn_noprefix\n     cdecl_fn_decorated\n     stdcall_fn_undecorated\n+    stdcall_fn_undecorated2\n     stdcall_fn_noprefix@4\n     fastcall_fn_undecorated\n+    fastcall_fn_undecorated2\n     @fastcall_fn_decorated@4\n \n     ;ld doesn't handle fully-decorated stdcall, or no-prefix fastcall"}, {"sha": "dbff32d4c90b0a68dede31c0181892e3df9aabd4", "filename": "src/test/run-make/raw-dylib-import-name-type/extern.msvc.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.msvc.def", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.msvc.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Fextern.msvc.def?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -1,12 +1,19 @@\n LIBRARY extern\n EXPORTS\n     cdecl_fn_undecorated\n+    cdecl_fn_undecorated2\n     cdecl_fn_noprefix\n     cdecl_fn_decorated\n     stdcall_fn_undecorated\n+    stdcall_fn_undecorated2\n     _stdcall_fn_decorated@4\n     fastcall_fn_undecorated\n+    fastcall_fn_undecorated2\n     @fastcall_fn_decorated@4\n+    vectorcall_fn_undecorated\n+    vectorcall_fn_undecorated2\n+    vectorcall_fn_decorated@@4\n+    vectorcall_fn_noprefix@@4\n \n     ;MSVC doesn't seem to recognize the \"no prefix\" syntax.\n     stdcall_fn_noprefix@4=_stdcall_fn_noprefix@4"}, {"sha": "707faf403aecab506d2a0f4ae428212b8b26518c", "filename": "src/test/run-make/raw-dylib-import-name-type/output.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Foutput.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Foutput.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fraw-dylib-import-name-type%2Foutput.txt?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -1,12 +1,19 @@\n cdecl_fn_undecorated(1)\n+cdecl_fn_undecorated2(10)\n cdecl_fn_noprefix(2)\n cdecl_fn_decorated(3)\n stdcall_fn_undecorated(4)\n+stdcall_fn_undecorated2(14)\n stdcall_fn_noprefix(5)\n stdcall_fn_decorated(6)\n fastcall_fn_undecorated(7)\n+fastcall_fn_undecorated2(17)\n fastcall_fn_noprefix(8)\n fastcall_fn_decorated(9)\n extern_variable_undecorated value: 42\n extern_variable_noprefix value: 43\n extern_variable_decorated value: 44\n+vectorcall_fn_undecorated(10)\n+vectorcall_fn_undecorated2(20)\n+vectorcall_fn_noprefix(11)\n+vectorcall_fn_decorated(12)"}, {"sha": "d287d5ebec5436b88e37e3bd3bbeed9cb7374c86", "filename": "src/test/rustdoc-json/type/extern.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frustdoc-json%2Ftype%2Fextern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Frustdoc-json%2Ftype%2Fextern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ftype%2Fextern.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,10 @@\n+#![feature(extern_types)]\n+\n+extern {\n+    /// No inner information\n+    pub type Foo;\n+}\n+\n+// @is \"$.index[*][?(@.docs=='No inner information')].name\" '\"Foo\"'\n+// @is \"$.index[*][?(@.docs=='No inner information')].kind\" '\"foreign_type\"'\n+// @!has \"$.index[*][?(@.docs=='No inner information')].inner\""}, {"sha": "284fc1c21f5f9ac64c6be7eec1032005ee0db01a", "filename": "src/test/ui/closure-expected-type/expect-fn-supply-fn.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-fn-supply-fn.stderr?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -25,26 +25,26 @@ error[E0308]: mismatched types\n LL |     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n    |                                                 ^ one type is more general than the other\n    |\n-   = note: expected fn pointer `for<'r> fn(&'r u32)`\n-              found fn pointer `fn(&u32)`\n+   = note: expected fn pointer `fn(&u32)`\n+              found fn pointer `for<'r> fn(&'r u32)`\n \n error[E0308]: mismatched types\n   --> $DIR/expect-fn-supply-fn.rs:39:50\n    |\n LL |     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n    |                                                  ^ one type is more general than the other\n    |\n-   = note: expected fn pointer `fn(&'x u32)`\n-              found fn pointer `for<'r> fn(&'r u32)`\n+   = note: expected fn pointer `for<'r> fn(&'r u32)`\n+              found fn pointer `fn(&u32)`\n \n error[E0308]: mismatched types\n   --> $DIR/expect-fn-supply-fn.rs:48:50\n    |\n LL |     with_closure_expecting_fn_with_bound_region(|x: Foo<'_>, y| {\n    |                                                  ^ one type is more general than the other\n    |\n-   = note: expected fn pointer `fn(&u32)`\n-              found fn pointer `for<'r> fn(&'r u32)`\n+   = note: expected fn pointer `for<'r> fn(&'r u32)`\n+              found fn pointer `fn(&u32)`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "d5432755cfed3fd2981c31270e6effbfacd50fec", "filename": "src/test/ui/closure-expected-type/expect-two-infer-vars-supply-ty-with-bound-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -6,7 +6,7 @@ LL |     with_closure(|x: u32, y| {});\n    |\n help: consider giving this closure parameter an explicit type\n    |\n-LL |     with_closure(|x: u32, y: B| {});\n+LL |     with_closure(|x: u32, y: _| {});\n    |                            +++\n \n error: aborting due to previous error"}, {"sha": "c5e7af81d3dd0948dfc95d3b101e7ea4216a62e3", "filename": "src/test/ui/type-alias-impl-trait/closure_args.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosure_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosure_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosure_args.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+// regression test for https://github.com/rust-lang/rust/issues/100800\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Anything {}\n+impl<T> Anything for T {}\n+type Input = impl Anything;\n+fn run<F: FnOnce(Input) -> ()>(f: F, i: Input) {\n+    f(i);\n+}\n+\n+fn main() {\n+    run(|x: u32| {println!(\"{x}\");}, 0);\n+}"}, {"sha": "82386c280a8e3182f47592809847c85eee056b37", "filename": "src/test/ui/type-alias-impl-trait/closure_args2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosure_args2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosure_args2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosure_args2.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Foo {\n+    // This was reachable in https://github.com/rust-lang/rust/issues/100800\n+    fn foo(&self) { unreachable!() }\n+}\n+impl<T> Foo for T {}\n+\n+struct B;\n+impl B {\n+    fn foo(&self) {}\n+}\n+\n+type Input = impl Foo;\n+fn run1<F: FnOnce(Input)>(f: F, i: Input) {f(i)}\n+fn run2<F: FnOnce(B)>(f: F, i: B) {f(i)}\n+\n+fn main() {\n+    run1(|x: B| {x.foo()}, B);\n+    run2(|x: B| {x.foo()}, B);\n+}"}, {"sha": "d0c04371bd793faa8926a8a7404c1a8126a3e321", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -11,7 +11,7 @@ error[E0277]: the trait bound `(): Bug` is not satisfied\n   --> $DIR/issue-60371.rs:10:40\n    |\n LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                        ^ the trait `Bug` is not implemented for `()`\n+   |                                        ^^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the trait `Bug` is implemented for `&()`\n "}, {"sha": "64df76e27720d319e2153afd611874d75680d0aa", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -203,6 +203,9 @@ pub struct Config {\n     /// The jsondocck executable.\n     pub jsondocck_path: Option<String>,\n \n+    /// The jsondoclint executable.\n+    pub jsondoclint_path: Option<String>,\n+\n     /// The LLVM `FileCheck` binary path.\n     pub llvm_filecheck: Option<PathBuf>,\n "}, {"sha": "38c7b87fc0d9d85ddd5405b9c57eb3120e5b1bbd", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -64,6 +64,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n         .reqopt(\"\", \"python\", \"path to python to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondoclint-path\", \"path to jsondoclint to use for doc tests\", \"PATH\")\n         .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n         .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n         .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n@@ -226,6 +227,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n         python: matches.opt_str(\"python\").unwrap(),\n         jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n+        jsondoclint_path: matches.opt_str(\"jsondoclint-path\"),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n         force_valgrind: matches.opt_present(\"force-valgrind\"),\n         run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),"}, {"sha": "8f289876f7307b391525979598dbbef6a8b8e37a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -2563,14 +2563,13 @@ impl<'test> TestCx<'test> {\n \n         let mut json_out = out_dir.join(self.testpaths.file.file_stem().unwrap());\n         json_out.set_extension(\"json\");\n+\n         let res = self.cmd2procres(\n-            Command::new(&self.config.python)\n-                .arg(root.join(\"src/etc/check_missing_items.py\"))\n-                .arg(&json_out),\n+            Command::new(self.config.jsondoclint_path.as_ref().unwrap()).arg(&json_out),\n         );\n \n         if !res.status.success() {\n-            self.fatal_proc_rec(\"check_missing_items failed!\", &res);\n+            self.fatal_proc_rec(\"jsondoclint failed!\", &res);\n         }\n     }\n "}, {"sha": "84a6c7f96c4644631e66c51070b9c4720af472f8", "filename": "src/tools/jsondoclint/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2FCargo.toml?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+name = \"jsondoclint\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+anyhow = \"1.0.62\"\n+fs-err = \"2.8.1\"\n+rustdoc-json-types = { version = \"0.1.0\", path = \"../../rustdoc-json-types\" }\n+serde_json = \"1.0.85\""}, {"sha": "ad8e96a0bd81d850d4d36ae73dc987204a23e8fb", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,184 @@\n+use rustdoc_json_types::{Item, ItemEnum, ItemKind, ItemSummary};\n+\n+/// A univeral way to represent an [`ItemEnum`] or [`ItemKind`]\n+#[derive(Debug)]\n+pub(crate) enum Kind {\n+    Module,\n+    ExternCrate,\n+    Import,\n+    Struct,\n+    StructField,\n+    Union,\n+    Enum,\n+    Variant,\n+    Function,\n+    Typedef,\n+    OpaqueTy,\n+    Constant,\n+    Trait,\n+    TraitAlias,\n+    Method,\n+    Impl,\n+    Static,\n+    ForeignType,\n+    Macro,\n+    ProcAttribute,\n+    ProcDerive,\n+    AssocConst,\n+    AssocType,\n+    Primitive,\n+    Keyword,\n+    // Not in ItemKind\n+    ProcMacro,\n+}\n+\n+impl Kind {\n+    pub fn can_appear_in_mod(self) -> bool {\n+        use Kind::*;\n+        match self {\n+            Module => true,\n+            ExternCrate => true,\n+            Import => true,\n+            Union => true,\n+            Struct => true,\n+            Enum => true,\n+            Function => true,\n+            Trait => true,\n+            TraitAlias => true,\n+            Impl => true,\n+            Typedef => true,\n+            Constant => true,\n+            Static => true,\n+            Macro => true,\n+            ProcMacro => true,\n+            Primitive => true,\n+            ForeignType => true,\n+\n+            // FIXME(adotinthevoid): I'm not sure if these are corrent\n+            Keyword => false,\n+            OpaqueTy => false,\n+            ProcAttribute => false,\n+            ProcDerive => false,\n+\n+            // Only in traits\n+            AssocConst => false,\n+            AssocType => false,\n+            Method => false,\n+\n+            StructField => false, // Only in structs or variants\n+            Variant => false,     // Only in enums\n+        }\n+    }\n+\n+    pub fn can_appear_in_trait(self) -> bool {\n+        match self {\n+            Kind::AssocConst => true,\n+            Kind::AssocType => true,\n+            Kind::Method => true,\n+\n+            Kind::Module => false,\n+            Kind::ExternCrate => false,\n+            Kind::Import => false,\n+            Kind::Struct => false,\n+            Kind::StructField => false,\n+            Kind::Union => false,\n+            Kind::Enum => false,\n+            Kind::Variant => false,\n+            Kind::Function => false,\n+            Kind::Typedef => false,\n+            Kind::OpaqueTy => false,\n+            Kind::Constant => false,\n+            Kind::Trait => false,\n+            Kind::TraitAlias => false,\n+            Kind::Impl => false,\n+            Kind::Static => false,\n+            Kind::ForeignType => false,\n+            Kind::Macro => false,\n+            Kind::ProcAttribute => false,\n+            Kind::ProcDerive => false,\n+            Kind::Primitive => false,\n+            Kind::Keyword => false,\n+            Kind::ProcMacro => false,\n+        }\n+    }\n+\n+    pub fn is_struct_field(self) -> bool {\n+        matches!(self, Kind::StructField)\n+    }\n+    pub fn is_module(self) -> bool {\n+        matches!(self, Kind::Module)\n+    }\n+    pub fn is_impl(self) -> bool {\n+        matches!(self, Kind::Impl)\n+    }\n+    pub fn is_variant(self) -> bool {\n+        matches!(self, Kind::Variant)\n+    }\n+    pub fn is_trait(self) -> bool {\n+        matches!(self, Kind::Trait)\n+    }\n+    pub fn is_struct_enum_union(self) -> bool {\n+        matches!(self, Kind::Struct | Kind::Enum | Kind::Union)\n+    }\n+\n+    pub fn from_item(i: &Item) -> Self {\n+        use Kind::*;\n+        match i.inner {\n+            ItemEnum::Module(_) => Module,\n+            ItemEnum::Import(_) => Import,\n+            ItemEnum::Union(_) => Union,\n+            ItemEnum::Struct(_) => Struct,\n+            ItemEnum::StructField(_) => StructField,\n+            ItemEnum::Enum(_) => Enum,\n+            ItemEnum::Variant(_) => Variant,\n+            ItemEnum::Function(_) => Function,\n+            ItemEnum::Trait(_) => Trait,\n+            ItemEnum::TraitAlias(_) => TraitAlias,\n+            ItemEnum::Method(_) => Method,\n+            ItemEnum::Impl(_) => Impl,\n+            ItemEnum::Typedef(_) => Typedef,\n+            ItemEnum::OpaqueTy(_) => OpaqueTy,\n+            ItemEnum::Constant(_) => Constant,\n+            ItemEnum::Static(_) => Static,\n+            ItemEnum::Macro(_) => Macro,\n+            ItemEnum::ProcMacro(_) => ProcMacro,\n+            // https://github.com/rust-lang/rust/issues/100961\n+            ItemEnum::PrimitiveType(_) => Primitive,\n+            ItemEnum::ForeignType => ForeignType,\n+            ItemEnum::ExternCrate { .. } => ExternCrate,\n+            ItemEnum::AssocConst { .. } => AssocConst,\n+            ItemEnum::AssocType { .. } => AssocType,\n+        }\n+    }\n+\n+    pub fn from_summary(s: &ItemSummary) -> Self {\n+        use Kind::*;\n+        match s.kind {\n+            ItemKind::AssocConst => AssocConst,\n+            ItemKind::AssocType => AssocType,\n+            ItemKind::Constant => Constant,\n+            ItemKind::Enum => Enum,\n+            ItemKind::ExternCrate => ExternCrate,\n+            ItemKind::ForeignType => ForeignType,\n+            ItemKind::Function => Function,\n+            ItemKind::Impl => Impl,\n+            ItemKind::Import => Import,\n+            ItemKind::Keyword => Keyword,\n+            ItemKind::Macro => Macro,\n+            ItemKind::Method => Method,\n+            ItemKind::Module => Module,\n+            ItemKind::OpaqueTy => OpaqueTy,\n+            ItemKind::Primitive => Primitive,\n+            ItemKind::ProcAttribute => ProcAttribute,\n+            ItemKind::ProcDerive => ProcDerive,\n+            ItemKind::Static => Static,\n+            ItemKind::Struct => Struct,\n+            ItemKind::StructField => StructField,\n+            ItemKind::Trait => Trait,\n+            ItemKind::TraitAlias => TraitAlias,\n+            ItemKind::Typedef => Typedef,\n+            ItemKind::Union => Union,\n+            ItemKind::Variant => Variant,\n+        }\n+    }\n+}"}, {"sha": "95ea8866609d09689e969d33fb47dc3b1245bffb", "filename": "src/tools/jsondoclint/src/json_find.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,74 @@\n+use std::fmt::Write;\n+\n+use serde_json::Value;\n+\n+#[derive(Debug, Clone)]\n+pub enum SelectorPart {\n+    Field(String),\n+    Index(usize),\n+}\n+\n+pub type Selector = Vec<SelectorPart>;\n+\n+pub fn to_jsonpath(sel: &Selector) -> String {\n+    let mut s = String::from(\"$\");\n+    for part in sel {\n+        match part {\n+            SelectorPart::Field(name) => {\n+                if is_jsonpath_safe(name) {\n+                    write!(&mut s, \".{}\", name).unwrap();\n+                } else {\n+                    // This is probably wrong in edge cases, but all Id's are\n+                    // just ascii alphanumerics, `-` `_`, and `:`\n+                    write!(&mut s, \"[{name:?}]\").unwrap();\n+                }\n+            }\n+            SelectorPart::Index(idx) => write!(&mut s, \"[{idx}]\").unwrap(),\n+        }\n+    }\n+    s\n+}\n+\n+fn is_jsonpath_safe(s: &str) -> bool {\n+    s.chars().all(|c| c.is_ascii_alphanumeric() || c == '_')\n+}\n+\n+pub fn find_selector(haystack: &Value, needle: &Value) -> Vec<Selector> {\n+    let mut result = Vec::new();\n+    let mut sel = Selector::new();\n+    find_selector_recursive(haystack, needle, &mut result, &mut sel);\n+    result\n+}\n+\n+fn find_selector_recursive(\n+    haystack: &Value,\n+    needle: &Value,\n+    result: &mut Vec<Selector>,\n+    pos: &mut Selector,\n+) {\n+    if needle == haystack {\n+        result.push(pos.clone());\n+        // Haystack cant both contain needle and be needle\n+    } else {\n+        match haystack {\n+            Value::Null => {}\n+            Value::Bool(_) => {}\n+            Value::Number(_) => {}\n+            Value::String(_) => {}\n+            Value::Array(arr) => {\n+                for (idx, subhaystack) in arr.iter().enumerate() {\n+                    pos.push(SelectorPart::Index(idx));\n+                    find_selector_recursive(subhaystack, needle, result, pos);\n+                    pos.pop().unwrap();\n+                }\n+            }\n+            Value::Object(obj) => {\n+                for (key, subhaystack) in obj {\n+                    pos.push(SelectorPart::Field(key.clone()));\n+                    find_selector_recursive(subhaystack, needle, result, pos);\n+                    pos.pop().unwrap();\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "70d7a82a576059e21a0ddac5ba311634b997c21a", "filename": "src/tools/jsondoclint/src/main.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,64 @@\n+use std::env;\n+\n+use anyhow::{anyhow, bail, Result};\n+use fs_err as fs;\n+use rustdoc_json_types::{Crate, Id, FORMAT_VERSION};\n+use serde_json::Value;\n+\n+pub(crate) mod item_kind;\n+mod json_find;\n+mod validator;\n+\n+#[derive(Debug)]\n+struct Error {\n+    kind: ErrorKind,\n+    id: Id,\n+}\n+\n+#[derive(Debug)]\n+enum ErrorKind {\n+    NotFound,\n+    Custom(String),\n+}\n+\n+fn main() -> Result<()> {\n+    let path = env::args().nth(1).ok_or_else(|| anyhow!(\"no path given\"))?;\n+    let contents = fs::read_to_string(&path)?;\n+    let krate: Crate = serde_json::from_str(&contents)?;\n+    assert_eq!(krate.format_version, FORMAT_VERSION);\n+\n+    let mut validator = validator::Validator::new(&krate);\n+    validator.check_crate();\n+\n+    if !validator.errs.is_empty() {\n+        for err in validator.errs {\n+            match err.kind {\n+                ErrorKind::NotFound => {\n+                    let krate_json: Value = serde_json::from_str(&contents)?;\n+\n+                    let sels =\n+                        json_find::find_selector(&krate_json, &Value::String(err.id.0.clone()));\n+                    match &sels[..] {\n+                        [] => unreachable!(\n+                            \"id must be in crate, or it wouldn't be reported as not found\"\n+                        ),\n+                        [sel] => eprintln!(\n+                            \"{} not in index or paths, but refered to at '{}'\",\n+                            err.id.0,\n+                            json_find::to_jsonpath(&sel)\n+                        ),\n+                        [sel, ..] => eprintln!(\n+                            \"{} not in index or paths, but refered to at '{}' and more\",\n+                            err.id.0,\n+                            json_find::to_jsonpath(&sel)\n+                        ),\n+                    }\n+                }\n+                ErrorKind::Custom(msg) => eprintln!(\"{}: {}\", err.id.0, msg),\n+            }\n+        }\n+        bail!(\"Errors validating json {path}\");\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "a0e77127dc2ca15091be88c3b99cb06c23971ff7", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -0,0 +1,442 @@\n+use std::collections::HashSet;\n+use std::hash::Hash;\n+\n+use rustdoc_json_types::{\n+    Constant, Crate, DynTrait, Enum, FnDecl, Function, FunctionPointer, GenericArg, GenericArgs,\n+    GenericBound, GenericParamDef, Generics, Id, Impl, Import, ItemEnum, Method, Module, OpaqueTy,\n+    Path, ProcMacro, Static, Struct, StructKind, Term, Trait, TraitAlias, Type, TypeBinding,\n+    TypeBindingKind, Typedef, Union, Variant, WherePredicate,\n+};\n+\n+use crate::{item_kind::Kind, Error, ErrorKind};\n+\n+/// The Validator walks over the JSON tree, and ensures it is well formed.\n+/// It is made of several parts.\n+///\n+/// - `check_*`: These take a type from [`rustdoc_json_types`], and check that\n+///              it is well formed. This involves calling `check_*` functions on\n+///              fields of that item, and `add_*` functions on [`Id`]s.\n+/// - `add_*`: These add an [`Id`] to the worklist, after validating it to check if\n+///            the `Id` is a kind expected in this suituation.\n+#[derive(Debug)]\n+pub struct Validator<'a> {\n+    pub(crate) errs: Vec<Error>,\n+    krate: &'a Crate,\n+    /// Worklist of Ids to check.\n+    todo: HashSet<&'a Id>,\n+    /// Ids that have already been visited, so don't need to be checked again.\n+    seen_ids: HashSet<&'a Id>,\n+    /// Ids that have already been reported missing.\n+    missing_ids: HashSet<&'a Id>,\n+}\n+\n+enum PathKind {\n+    Trait,\n+    StructEnumUnion,\n+}\n+\n+impl<'a> Validator<'a> {\n+    pub fn new(krate: &'a Crate) -> Self {\n+        Self {\n+            krate,\n+            errs: Vec::new(),\n+            seen_ids: HashSet::new(),\n+            todo: HashSet::new(),\n+            missing_ids: HashSet::new(),\n+        }\n+    }\n+\n+    pub fn check_crate(&mut self) {\n+        let root = &self.krate.root;\n+        self.add_mod_id(root);\n+        while let Some(id) = set_remove(&mut self.todo) {\n+            self.seen_ids.insert(id);\n+            self.check_item(id);\n+        }\n+    }\n+\n+    fn check_item(&mut self, id: &'a Id) {\n+        if let Some(item) = &self.krate.index.get(id) {\n+            match &item.inner {\n+                ItemEnum::Import(x) => self.check_import(x),\n+                ItemEnum::Union(x) => self.check_union(x),\n+                ItemEnum::Struct(x) => self.check_struct(x),\n+                ItemEnum::StructField(x) => self.check_struct_field(x),\n+                ItemEnum::Enum(x) => self.check_enum(x),\n+                ItemEnum::Variant(x) => self.check_variant(x, id),\n+                ItemEnum::Function(x) => self.check_function(x),\n+                ItemEnum::Trait(x) => self.check_trait(x),\n+                ItemEnum::TraitAlias(x) => self.check_trait_alias(x),\n+                ItemEnum::Method(x) => self.check_method(x),\n+                ItemEnum::Impl(x) => self.check_impl(x),\n+                ItemEnum::Typedef(x) => self.check_typedef(x),\n+                ItemEnum::OpaqueTy(x) => self.check_opaque_ty(x),\n+                ItemEnum::Constant(x) => self.check_constant(x),\n+                ItemEnum::Static(x) => self.check_static(x),\n+                ItemEnum::ForeignType => {} // nop\n+                ItemEnum::Macro(x) => self.check_macro(x),\n+                ItemEnum::ProcMacro(x) => self.check_proc_macro(x),\n+                ItemEnum::PrimitiveType(x) => self.check_primitive_type(x),\n+                ItemEnum::Module(x) => self.check_module(x),\n+                // FIXME: Why don't these have their own structs?\n+                ItemEnum::ExternCrate { .. } => {}\n+                ItemEnum::AssocConst { type_, default: _ } => self.check_type(type_),\n+                ItemEnum::AssocType { generics, bounds, default } => {\n+                    self.check_generics(generics);\n+                    bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                    if let Some(ty) = default {\n+                        self.check_type(ty);\n+                    }\n+                }\n+            }\n+        } else {\n+            assert!(self.krate.paths.contains_key(id));\n+        }\n+    }\n+\n+    // Core checkers\n+    fn check_module(&mut self, module: &'a Module) {\n+        module.items.iter().for_each(|i| self.add_mod_item_id(i));\n+    }\n+\n+    fn check_import(&mut self, x: &'a Import) {\n+        if x.glob {\n+            self.add_mod_id(x.id.as_ref().unwrap());\n+        } else if let Some(id) = &x.id {\n+            self.add_mod_item_id(id);\n+        }\n+    }\n+\n+    fn check_union(&mut self, x: &'a Union) {\n+        self.check_generics(&x.generics);\n+        x.fields.iter().for_each(|i| self.add_field_id(i));\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_struct(&mut self, x: &'a Struct) {\n+        self.check_generics(&x.generics);\n+        match &x.kind {\n+            StructKind::Unit => {}\n+            StructKind::Tuple(fields) => fields.iter().flatten().for_each(|f| self.add_field_id(f)),\n+            StructKind::Plain { fields, fields_stripped: _ } => {\n+                fields.iter().for_each(|f| self.add_field_id(f))\n+            }\n+        }\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_struct_field(&mut self, x: &'a Type) {\n+        self.check_type(x);\n+    }\n+\n+    fn check_enum(&mut self, x: &'a Enum) {\n+        self.check_generics(&x.generics);\n+        x.variants.iter().for_each(|i| self.add_variant_id(i));\n+        x.impls.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_variant(&mut self, x: &'a Variant, id: &'a Id) {\n+        match x {\n+            Variant::Plain(discr) => {\n+                if let Some(discr) = discr {\n+                    if let (Err(_), Err(_)) =\n+                        (discr.value.parse::<i128>(), discr.value.parse::<u128>())\n+                    {\n+                        self.fail(\n+                            id,\n+                            ErrorKind::Custom(format!(\n+                                \"Failed to parse discriminant value `{}`\",\n+                                discr.value\n+                            )),\n+                        );\n+                    }\n+                }\n+            }\n+            Variant::Tuple(tys) => tys.iter().flatten().for_each(|t| self.add_field_id(t)),\n+            Variant::Struct { fields, fields_stripped: _ } => {\n+                fields.iter().for_each(|f| self.add_field_id(f))\n+            }\n+        }\n+    }\n+\n+    fn check_function(&mut self, x: &'a Function) {\n+        self.check_generics(&x.generics);\n+        self.check_fn_decl(&x.decl);\n+    }\n+\n+    fn check_trait(&mut self, x: &'a Trait) {\n+        self.check_generics(&x.generics);\n+        x.items.iter().for_each(|i| self.add_trait_item_id(i));\n+        x.bounds.iter().for_each(|i| self.check_generic_bound(i));\n+        x.implementations.iter().for_each(|i| self.add_impl_id(i));\n+    }\n+\n+    fn check_trait_alias(&mut self, x: &'a TraitAlias) {\n+        self.check_generics(&x.generics);\n+        x.params.iter().for_each(|i| self.check_generic_bound(i));\n+    }\n+\n+    fn check_method(&mut self, x: &'a Method) {\n+        self.check_fn_decl(&x.decl);\n+        self.check_generics(&x.generics);\n+    }\n+\n+    fn check_impl(&mut self, x: &'a Impl) {\n+        self.check_generics(&x.generics);\n+        if let Some(path) = &x.trait_ {\n+            self.check_path(path, PathKind::Trait);\n+        }\n+        self.check_type(&x.for_);\n+        x.items.iter().for_each(|i| self.add_trait_item_id(i));\n+        if let Some(blanket_impl) = &x.blanket_impl {\n+            self.check_type(blanket_impl)\n+        }\n+    }\n+\n+    fn check_typedef(&mut self, x: &'a Typedef) {\n+        self.check_generics(&x.generics);\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_opaque_ty(&mut self, x: &'a OpaqueTy) {\n+        x.bounds.iter().for_each(|b| self.check_generic_bound(b));\n+        self.check_generics(&x.generics);\n+    }\n+\n+    fn check_constant(&mut self, x: &'a Constant) {\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_static(&mut self, x: &'a Static) {\n+        self.check_type(&x.type_);\n+    }\n+\n+    fn check_macro(&mut self, _: &'a str) {\n+        // nop\n+    }\n+\n+    fn check_proc_macro(&mut self, _: &'a ProcMacro) {\n+        // nop\n+    }\n+\n+    fn check_primitive_type(&mut self, _: &'a str) {\n+        // nop\n+    }\n+\n+    fn check_generics(&mut self, x: &'a Generics) {\n+        x.params.iter().for_each(|p| self.check_generic_param_def(p));\n+        x.where_predicates.iter().for_each(|w| self.check_where_predicate(w));\n+    }\n+\n+    fn check_type(&mut self, x: &'a Type) {\n+        match x {\n+            Type::ResolvedPath(path) => self.check_path(path, PathKind::StructEnumUnion),\n+            Type::DynTrait(dyn_trait) => self.check_dyn_trait(dyn_trait),\n+            Type::Generic(_) => {}\n+            Type::Primitive(_) => {}\n+            Type::FunctionPointer(fp) => self.check_function_pointer(&**fp),\n+            Type::Tuple(tys) => tys.iter().for_each(|ty| self.check_type(ty)),\n+            Type::Slice(inner) => self.check_type(&**inner),\n+            Type::Array { type_, len: _ } => self.check_type(&**type_),\n+            Type::ImplTrait(bounds) => bounds.iter().for_each(|b| self.check_generic_bound(b)),\n+            Type::Infer => {}\n+            Type::RawPointer { mutable: _, type_ } => self.check_type(&**type_),\n+            Type::BorrowedRef { lifetime: _, mutable: _, type_ } => self.check_type(&**type_),\n+            Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n+                self.check_generic_args(&**args);\n+                self.check_type(&**self_type);\n+                self.check_path(trait_, PathKind::Trait);\n+            }\n+        }\n+    }\n+\n+    fn check_fn_decl(&mut self, x: &'a FnDecl) {\n+        x.inputs.iter().for_each(|(_name, ty)| self.check_type(ty));\n+        if let Some(output) = &x.output {\n+            self.check_type(output);\n+        }\n+    }\n+\n+    fn check_generic_bound(&mut self, x: &'a GenericBound) {\n+        match x {\n+            GenericBound::TraitBound { trait_, generic_params, modifier: _ } => {\n+                self.check_path(trait_, PathKind::Trait);\n+                generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+            }\n+            GenericBound::Outlives(_) => {}\n+        }\n+    }\n+\n+    fn check_path(&mut self, x: &'a Path, kind: PathKind) {\n+        match kind {\n+            PathKind::Trait => self.add_trait_id(&x.id),\n+            PathKind::StructEnumUnion => self.add_struct_enum_union_id(&x.id),\n+        }\n+        if let Some(args) = &x.args {\n+            self.check_generic_args(&**args);\n+        }\n+    }\n+\n+    fn check_generic_args(&mut self, x: &'a GenericArgs) {\n+        match x {\n+            GenericArgs::AngleBracketed { args, bindings } => {\n+                args.iter().for_each(|arg| self.check_generic_arg(arg));\n+                bindings.iter().for_each(|bind| self.check_type_binding(bind));\n+            }\n+            GenericArgs::Parenthesized { inputs, output } => {\n+                inputs.iter().for_each(|ty| self.check_type(ty));\n+                if let Some(o) = output {\n+                    self.check_type(o);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_generic_param_def(&mut self, gpd: &'a GenericParamDef) {\n+        match &gpd.kind {\n+            rustdoc_json_types::GenericParamDefKind::Lifetime { outlives: _ } => {}\n+            rustdoc_json_types::GenericParamDefKind::Type { bounds, default, synthetic: _ } => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                if let Some(ty) = default {\n+                    self.check_type(ty);\n+                }\n+            }\n+            rustdoc_json_types::GenericParamDefKind::Const { type_, default: _ } => {\n+                self.check_type(type_)\n+            }\n+        }\n+    }\n+\n+    fn check_generic_arg(&mut self, arg: &'a GenericArg) {\n+        match arg {\n+            GenericArg::Lifetime(_) => {}\n+            GenericArg::Type(ty) => self.check_type(ty),\n+            GenericArg::Const(c) => self.check_constant(c),\n+            GenericArg::Infer => {}\n+        }\n+    }\n+\n+    fn check_type_binding(&mut self, bind: &'a TypeBinding) {\n+        self.check_generic_args(&bind.args);\n+        match &bind.binding {\n+            TypeBindingKind::Equality(term) => self.check_term(term),\n+            TypeBindingKind::Constraint(bounds) => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b))\n+            }\n+        }\n+    }\n+\n+    fn check_term(&mut self, term: &'a Term) {\n+        match term {\n+            Term::Type(ty) => self.check_type(ty),\n+            Term::Constant(con) => self.check_constant(con),\n+        }\n+    }\n+\n+    fn check_where_predicate(&mut self, w: &'a WherePredicate) {\n+        match w {\n+            WherePredicate::BoundPredicate { type_, bounds, generic_params } => {\n+                self.check_type(type_);\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+                generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+            }\n+            WherePredicate::RegionPredicate { lifetime: _, bounds } => {\n+                bounds.iter().for_each(|b| self.check_generic_bound(b));\n+            }\n+            WherePredicate::EqPredicate { lhs, rhs } => {\n+                self.check_type(lhs);\n+                self.check_term(rhs);\n+            }\n+        }\n+    }\n+\n+    fn check_dyn_trait(&mut self, dyn_trait: &'a DynTrait) {\n+        for pt in &dyn_trait.traits {\n+            self.check_path(&pt.trait_, PathKind::Trait);\n+            pt.generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+        }\n+    }\n+\n+    fn check_function_pointer(&mut self, fp: &'a FunctionPointer) {\n+        self.check_fn_decl(&fp.decl);\n+        fp.generic_params.iter().for_each(|gpd| self.check_generic_param_def(gpd));\n+    }\n+\n+    fn add_id_checked(&mut self, id: &'a Id, valid: fn(Kind) -> bool, expected: &str) {\n+        if let Some(kind) = self.kind_of(id) {\n+            if valid(kind) {\n+                if !self.seen_ids.contains(id) {\n+                    self.todo.insert(id);\n+                }\n+            } else {\n+                self.fail_expecting(id, expected);\n+            }\n+        } else {\n+            if !self.missing_ids.contains(id) {\n+                self.missing_ids.insert(id);\n+                self.fail(id, ErrorKind::NotFound)\n+            }\n+        }\n+    }\n+\n+    fn add_field_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_struct_field, \"StructField\");\n+    }\n+\n+    fn add_mod_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_module, \"Module\");\n+    }\n+    fn add_impl_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_impl, \"Impl\");\n+    }\n+\n+    fn add_variant_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_variant, \"Variant\");\n+    }\n+\n+    fn add_trait_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_trait, \"Trait\");\n+    }\n+\n+    fn add_struct_enum_union_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_struct_enum_union, \"Struct or Enum or Union\");\n+    }\n+\n+    /// Add an Id that appeared in a trait\n+    fn add_trait_item_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::can_appear_in_trait, \"Trait inner item\");\n+    }\n+\n+    /// Add an Id that appeared in a mod\n+    fn add_mod_item_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::can_appear_in_mod, \"Module inner item\")\n+    }\n+\n+    fn fail_expecting(&mut self, id: &Id, expected: &str) {\n+        let kind = self.kind_of(id).unwrap(); // We know it has a kind, as it's wrong.\n+        self.fail(id, ErrorKind::Custom(format!(\"Expected {expected} but found {kind:?}\")));\n+    }\n+\n+    fn fail(&mut self, id: &Id, kind: ErrorKind) {\n+        self.errs.push(Error { id: id.clone(), kind });\n+    }\n+\n+    fn kind_of(&mut self, id: &Id) -> Option<Kind> {\n+        if let Some(item) = self.krate.index.get(id) {\n+            Some(Kind::from_item(item))\n+        } else if let Some(summary) = self.krate.paths.get(id) {\n+            Some(Kind::from_summary(summary))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn set_remove<T: Hash + Eq + Clone>(set: &mut HashSet<T>) -> Option<T> {\n+    if let Some(id) = set.iter().next() {\n+        let id = id.clone();\n+        set.take(&id)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "12a55fda7ef4d5ed4bf482812a80a27432cf8842", "filename": "triagebot.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22f6aec42de6bce63f8e43f144058428d4dba0f5/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/22f6aec42de6bce63f8e43f144058428d4dba0f5/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=22f6aec42de6bce63f8e43f144058428d4dba0f5", "patch": "@@ -130,8 +130,8 @@ trigger_files = [\n \n     # Internal tooling\n     \"src/etc/htmldocck.py\",\n-    \"src/etc/check_missing_items.py\",\n     \"src/tools/jsondocck\",\n+    \"src/tools/jsondoclint\",\n     \"src/tools/rustdoc-gui\",\n     \"src/tools/rustdoc-js\",\n     \"src/tools/rustdoc-themes\",\n@@ -142,11 +142,11 @@ exclude_labels = [\n \n [autolabel.\"A-rustdoc-json\"]\n trigger_files = [\n-    \"src/etc/check_missing_items.py\",\n     \"src/librustdoc/json/\",\n     \"src/rustdoc-json-types\",\n     \"src/test/rustdoc-json\",\n     \"src/tools/jsondocck\",\n+    \"src/tools/jsondoclint\",\n ]\n \n [autolabel.\"T-compiler\"]"}]}