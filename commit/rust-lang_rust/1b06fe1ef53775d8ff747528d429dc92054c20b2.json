{"sha": "1b06fe1ef53775d8ff747528d429dc92054c20b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMDZmZTFlZjUzNzc1ZDhmZjc0NzUyOGQ0MjlkYzkyMDU0YzIwYjI=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2018-04-05T16:22:40Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2018-04-05T16:22:40Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust into e0389", "tree": {"sha": "fe6cb06792c90c44f0a4f5b3c8ec3d0ab914dfcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe6cb06792c90c44f0a4f5b3c8ec3d0ab914dfcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b06fe1ef53775d8ff747528d429dc92054c20b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b06fe1ef53775d8ff747528d429dc92054c20b2", "html_url": "https://github.com/rust-lang/rust/commit/1b06fe1ef53775d8ff747528d429dc92054c20b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b06fe1ef53775d8ff747528d429dc92054c20b2/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c649fbed4d4d86aed16dff8c0245b4871353cd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c649fbed4d4d86aed16dff8c0245b4871353cd1", "html_url": "https://github.com/rust-lang/rust/commit/6c649fbed4d4d86aed16dff8c0245b4871353cd1"}, {"sha": "56714acc5eb0687ed9a7566fdebe5528657fc5b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/56714acc5eb0687ed9a7566fdebe5528657fc5b3", "html_url": "https://github.com/rust-lang/rust/commit/56714acc5eb0687ed9a7566fdebe5528657fc5b3"}], "stats": {"total": 55494, "additions": 33691, "deletions": 21803}, "files": [{"sha": "36329ab91143c46e116609163e843124e5998e79", "filename": ".travis.yml", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -30,7 +30,6 @@ matrix:\n         SRC=.\n         DEPLOY_ALT=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n@@ -50,27 +49,25 @@ matrix:\n         RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler\"\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.8\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode9.2\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     - env: >\n         RUST_CHECK_TARGET=check\n         RUST_CONFIGURE_ARGS=--build=i686-apple-darwin\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.8\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode9.2\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and\n@@ -85,7 +82,6 @@ matrix:\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n@@ -99,7 +95,6 @@ matrix:\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n@@ -176,14 +171,11 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-distcheck\n       if: branch = auto\n-    - env: IMAGE=x86_64-gnu-incremental\n-      if: branch = auto\n \n     - stage: publish toolstate\n       if: branch = master AND type = push\n       before_install: []\n       install: []\n-      cache: false\n       sudo: false\n       script:\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n@@ -201,7 +193,12 @@ env:\n     - secure: \"cFh8thThqEJLC98XKI5pfqflUzOlxsYPRW20AWRaYOOgYHPTiGWypTXiPbGSKaeAXTZoOA+DpQtEmefc0U6lt9dHc7a/MIaK6isFurjlnKYiLOeTruzyu1z7PWCeZ/jKXsU2RK/88DBtlNwfMdaMIeuKj14IVfpepPPL71ETbuk=\"\n \n before_install:\n-  - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n+  # We'll use the AWS cli to download/upload cached docker layers, so install\n+  # that here.\n+  - if [ \"$TRAVIS_OS_NAME\" = linux ]; then\n+      pip install --user awscli;\n+      export PATH=$PATH:$HOME/.local/bin;\n+    fi\n   - mkdir -p $HOME/rustsrc\n   # FIXME(#46924): these two commands are required to enable IPv6,\n   # they shouldn't exist, please revert once more official solutions appeared.\n@@ -223,7 +220,7 @@ install:\n             travis_retry brew update &&\n             travis_retry brew install xz;\n           fi &&\n-          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-apple-darwin &&\n+          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/sccache &&\n           travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/stamp\n@@ -264,44 +261,25 @@ after_failure:\n       df -h;\n       du . | sort -nr | head -n100\n \n-  # One of these is the linux sccache log, one is the OSX sccache log. Instead\n-  # of worrying about what system we are just cat both. One of these commands\n-  # will fail but that's ok, they'll both get executed.\n-  - cat obj/tmp/sccache.log\n-  - cat /tmp/sccache.log\n-\n   # Random attempt at debugging currently. Just poking around in here to see if\n   # anything shows up.\n   - ls -lat $HOME/Library/Logs/DiagnosticReports/\n   - find $HOME/Library/Logs/DiagnosticReports\n       -type f\n+      -name '*.crash'\n       -not -name '*.stage2-*.crash'\n       -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n       -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n       -exec head -750 {} \\;\n-      -exec echo travis_fold\":\"end:crashlog \\;\n+      -exec echo travis_fold\":\"end:crashlog \\; || true\n \n   # attempt to debug anything killed by the oom killer on linux, just to see if\n   # it happened\n   - dmesg | grep -i kill\n \n-# Save tagged docker images we created and load them if they're available\n-# Travis saves caches whether the build failed or not, nuke rustsrc if\n-# the failure was while updating it (as it may be in a bad state)\n-# https://github.com/travis-ci/travis-ci/issues/4472\n-before_cache:\n-  - docker history -q rust-ci |\n-    grep -v missing |\n-    xargs docker save |\n-    gzip > $HOME/docker/rust-ci.tar.gz\n-\n notifications:\n   email: false\n \n-cache:\n-  directories:\n-    - $HOME/docker\n-\n before_deploy:\n   - mkdir -p deploy/$TRAVIS_COMMIT\n   - >"}, {"sha": "d70b2b52aca1b136d70617a03d04b5c7bccd9969", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -11,9 +11,9 @@ A version of this document [can be found online](https://www.rust-lang.org/condu\n * Please be kind and courteous. There's no need to be mean or rude.\n * Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n * Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n * Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behaviour is not welcome.\n+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n \n ## Moderation\n "}, {"sha": "7a62405f059677affac001298e8f5fd2f9dbe515", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -26,10 +26,10 @@ As a reminder, all contributors are expected to follow our [Code of Conduct][coc\n ## Feature Requests\n [feature-requests]: #feature-requests\n \n-To request a change to the way that the Rust language works, please open an\n-issue in the [RFCs repository](https://github.com/rust-lang/rfcs/issues/new)\n-rather than this one. New features and other significant language changes\n-must go through the RFC process.\n+To request a change to the way the Rust language works, please head over\n+to the [RFCs repository](https://github.com/rust-lang/rfcs) and view the \n+[README](https://github.com/rust-lang/rfcs/blob/master/README.md)\n+for instructions.\n \n ## Bug Reports\n [bug-reports]: #bug-reports\n@@ -594,7 +594,7 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [inom]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-nominated\n [eeasy]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy\n [lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n-[rfcbot]: https://github.com/dikaiosune/rust-dashboard/blob/master/RFCBOT.md\n+[rfcbot]: https://github.com/anp/rfcbot-rs/\n \n ## Out-of-tree Contributions\n [out-of-tree-contributions]: #out-of-tree-contributions"}, {"sha": "39cef1e2a57703a9a2b95cf70f9909a4d7dc9699", "filename": "RELEASES.md", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1,3 +1,115 @@\n+Version 1.25.0 (2018-03-29)\n+==========================\n+\n+Language\n+--------\n+- [Stabilised `#[repr(align(x))]`.][47006] [RFC 1358]\n+- [You can now use nested groups of imports.][47948]\n+  e.g. `use std::{fs::File, io::Read, path::{Path, PathBuf}};`\n+- [You can now have `|` at the start of a match arm.][47947] e.g.\n+```rust\n+enum Foo { A, B, C }\n+\n+fn main() {\n+    let x = Foo::A;\n+    match x {\n+        | Foo::A\n+        | Foo::B => println!(\"AB\"),\n+        | Foo::C => println!(\"C\"),\n+    }\n+}\n+```\n+\n+Compiler\n+--------\n+- [Upgraded to LLVM 6.][47828]\n+- [Added `-C lto=val` option.][47521]\n+- [Added `i586-unknown-linux-musl` target][47282]\n+\n+Libraries\n+---------\n+- [Impl Send for `process::Command` on Unix.][47760]\n+- [Impl PartialEq and Eq for `ParseCharError`.][47790]\n+- [`UnsafeCell::into_inner` is now safe.][47204]\n+- [Implement libstd for CloudABI.][47268]\n+- [`Float::{from_bits, to_bits}` is now available in libcore.][46931]\n+- [Implement `AsRef<Path>` for Component][46985]\n+- [Implemented `Write` for `Cursor<&mut Vec<u8>>`][46830]\n+- [Moved `Duration` to libcore.][46666]\n+\n+Stabilized APIs\n+---------------\n+- [`Location::column`]\n+- [`ptr::NonNull`]\n+\n+The following functions can now be used in a constant expression.\n+eg. `static MINUTE: Duration = Duration::from_secs(60);`\n+- [`Duration::new`][47300]\n+- [`Duration::from_secs`][47300]\n+- [`Duration::from_millis`][47300]\n+\n+Cargo\n+-----\n+- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` now defaults to creating a binary crate, instead of a\n+  library crate.][cargo/5029]\n+\n+Misc\n+----\n+- [Rust by example is now shipped with new releases][46196]\n+\n+Compatibility Notes\n+-------------------\n+- [Deprecated `net::lookup_host`.][47510]\n+- [`rustdoc` has switched to pulldown as the default markdown renderer.][47398]\n+- The borrow checker was sometimes incorrectly permitting overlapping borrows\n+  around indexing operations (see [#47349][47349]). This has been fixed (which also\n+  enabled some correct code that used to cause errors (e.g. [#33903][33903] and [#46095][46095]).\n+- [Removed deprecated unstable attribute `#[simd]`.][47251]\n+\n+[33903]: https://github.com/rust-lang/rust/pull/33903\n+[47947]: https://github.com/rust-lang/rust/pull/47947\n+[47948]: https://github.com/rust-lang/rust/pull/47948\n+[47760]: https://github.com/rust-lang/rust/pull/47760\n+[47790]: https://github.com/rust-lang/rust/pull/47790\n+[47828]: https://github.com/rust-lang/rust/pull/47828\n+[47398]: https://github.com/rust-lang/rust/pull/47398\n+[47510]: https://github.com/rust-lang/rust/pull/47510\n+[47521]: https://github.com/rust-lang/rust/pull/47521\n+[47204]: https://github.com/rust-lang/rust/pull/47204\n+[47251]: https://github.com/rust-lang/rust/pull/47251\n+[47268]: https://github.com/rust-lang/rust/pull/47268\n+[47282]: https://github.com/rust-lang/rust/pull/47282\n+[47300]: https://github.com/rust-lang/rust/pull/47300\n+[47349]: https://github.com/rust-lang/rust/pull/47349\n+[46931]: https://github.com/rust-lang/rust/pull/46931\n+[46985]: https://github.com/rust-lang/rust/pull/46985\n+[47006]: https://github.com/rust-lang/rust/pull/47006\n+[46830]: https://github.com/rust-lang/rust/pull/46830\n+[46095]: https://github.com/rust-lang/rust/pull/46095\n+[46666]: https://github.com/rust-lang/rust/pull/46666\n+[46196]: https://github.com/rust-lang/rust/pull/46196\n+[cargo/5013]: https://github.com/rust-lang/cargo/pull/5013\n+[cargo/5029]: https://github.com/rust-lang/cargo/pull/5029\n+[RFC 1358]: https://github.com/rust-lang/rfcs/pull/1358\n+[`Location::column`]: https://doc.rust-lang.org/std/panic/struct.Location.html#method.column\n+[`ptr::NonNull`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html\n+\n+\n+Version 1.24.1 (2018-03-01)\n+==========================\n+\n+ - [Do not abort when unwinding through FFI][48251]\n+ - [Emit UTF-16 files for linker arguments on Windows][48318]\n+ - [Make the error index generator work again][48308]\n+ - [Cargo will warn on Windows 7 if an update is needed][cargo/5069].\n+\n+[48251]: https://github.com/rust-lang/rust/issues/48251\n+[48308]: https://github.com/rust-lang/rust/issues/48308\n+[48318]: https://github.com/rust-lang/rust/issues/48318\n+[cargo/5069]: https://github.com/rust-lang/cargo/pull/5069\n+\n+\n Version 1.24.0 (2018-02-15)\n ==========================\n "}, {"sha": "09c6fca5d02afc8f3f46bf8b4ea46eb5c9f2a958", "filename": "appveyor.yml", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -20,10 +20,10 @@ environment:\n     SCRIPT: python x.py test\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+    SCRIPT: make appveyor-subset-1\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n+    SCRIPT: make appveyor-subset-2\n \n   # MSVC aux tests\n   - MSYS_BITS: 64\n@@ -53,13 +53,13 @@ environment:\n   # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+    SCRIPT: make appveyor-subset-1\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n+    SCRIPT: make appveyor-subset-2\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n@@ -152,8 +152,8 @@ install:\n   - set PATH=C:\\Python27;%PATH%\n \n   # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-pc-windows-msvc\n-  - mv 2017-05-12-sccache-x86_64-pc-windows-msvc sccache.exe\n+  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-pc-windows-msvc\n+  - mv 2018-04-02-sccache-x86_64-pc-windows-msvc sccache.exe\n   - set PATH=%PATH%;%CD%\n \n   # Download and install ninja\n@@ -176,19 +176,13 @@ install:\n   - set PATH=%PATH%;%CD%\\handle\n   - handle.exe -accepteula -help\n \n-  # Attempt to debug sccache failures\n-  - set SCCACHE_ERROR_LOG=%CD%/sccache.log\n-\n test_script:\n   - if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n   - sh src/ci/init_repo.sh . /c/cache/rustsrc\n   - set SRC=.\n   - set NO_CCACHE=1\n   - sh src/ci/run.sh\n \n-on_failure:\n-  - cat %CD%\\sccache.log || exit 0\n-\n branches:\n   only:\n     - auto"}, {"sha": "9dd3002506e41cbe333d4cc8051dcf9d62071eb7", "filename": "config.toml.example", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -118,6 +118,10 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n+# Update submodules only when the checked out commit in the submodules differs\n+# from what is committed in the main rustc repo.\n+#fast-submodules = true\n+\n # The path to (or name of) the GDB executable to use. This is only used for\n # executing the debuginfo test suite.\n #gdb = \"gdb\"\n@@ -182,6 +186,10 @@\n # essentially skipping stage0 as the local compiler is recompiling itself again.\n #local-rebuild = false\n \n+# Print out how long each rustbuild step took (mostly intended for CI and\n+# tracking over time)\n+#print-step-timings = false\n+\n # =============================================================================\n # General install configuration options\n # =============================================================================\n@@ -239,11 +247,6 @@\n # compiler.\n #codegen-units = 1\n \n-# Whether to enable ThinLTO (and increase the codegen units to either a default\n-# or the configured value). On by default. If we want the fastest possible\n-# compiler, we should disable this.\n-#thinlto = true\n-\n # Whether or not debug assertions are enabled for the compiler and standard\n # library. Also enables compilation of debug! and trace! logging macros.\n #debug-assertions = false\n@@ -268,6 +271,9 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n+# Build rustc with experimental parallelization\n+#experimental-parallel-queries = false\n+\n # The default linker that will be hard-coded into the generated compiler for\n # targets that don't specify linker explicitly in their target specifications.\n # Note that this is not the linker used to link said compiler."}, {"sha": "2f77d4125ab0e758cdd34e7e7111debcec200613", "filename": "src/Cargo.lock", "status": "modified", "additions": 599, "deletions": 793, "changes": 1392, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "814c054c51e41eaff3c6b155110474f8a252c3e8", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -72,3 +72,4 @@ cargo = { path = \"tools/cargo\" }\n # RLS depends on `rustfmt` from crates.io, so we put this in a `[patch]` section\n # for crates.io\n rustfmt-nightly = { path = \"tools/rustfmt\" }\n+clippy_lints = { path = \"tools/clippy/clippy_lints\" }"}, {"sha": "2f9c4e148a6bad72cc2c5be24ad9ae0a976122ea", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -42,3 +42,7 @@ serde_json = \"1.0.2\"\n toml = \"0.4\"\n lazy_static = \"0.2\"\n time = \"0.1\"\n+petgraph = \"0.4.12\"\n+\n+[dev-dependencies]\n+pretty_assertions = \"0.5\""}, {"sha": "6701f58ba8e92593589679caf6772aeb6c1d9395", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -31,9 +31,11 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::str::FromStr;\n+use std::io;\n use std::path::PathBuf;\n-use std::process::{Command, ExitStatus};\n+use std::process::Command;\n+use std::str::FromStr;\n+use std::time::Instant;\n \n fn main() {\n     let mut args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -90,24 +92,25 @@ fn main() {\n     };\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n-    let mut on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n+    let on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n \n     let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n     let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n     let mut dylib_path = bootstrap::util::dylib_path();\n-    dylib_path.insert(0, PathBuf::from(libdir));\n+    dylib_path.insert(0, PathBuf::from(&libdir));\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n         .arg(\"--cfg\")\n         .arg(format!(\"stage{}\", stage))\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n+    let mut maybe_crate = None;\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n         // actually downloaded, so we just always pass the `--sysroot` option.\n-        cmd.arg(\"--sysroot\").arg(sysroot);\n+        cmd.arg(\"--sysroot\").arg(&sysroot);\n \n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n@@ -134,6 +137,7 @@ fn main() {\n             .find(|a| &*a[0] == \"--crate-name\")\n             .unwrap();\n         let crate_name = &*crate_name[1];\n+        maybe_crate = Some(crate_name);\n \n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n@@ -175,9 +179,6 @@ fn main() {\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }\n-        if env::var(\"RUSTC_THINLTO\").is_ok() {\n-            cmd.arg(\"-Ccodegen-units=16\").arg(\"-Zthinlto\");\n-        }\n \n         // Emit save-analysis info.\n         if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n@@ -280,33 +281,56 @@ fn main() {\n \n     if verbose > 1 {\n         eprintln!(\"rustc command: {:?}\", cmd);\n+        eprintln!(\"sysroot: {:?}\", sysroot);\n+        eprintln!(\"libdir: {:?}\", libdir);\n+    }\n+\n+    if let Some(mut on_fail) = on_fail {\n+        let e = match cmd.status() {\n+            Ok(s) if s.success() => std::process::exit(0),\n+            e => e,\n+        };\n+        println!(\"\\nDid not run successfully: {:?}\\n{:?}\\n-------------\", e, cmd);\n+        exec_cmd(&mut on_fail).expect(\"could not run the backup command\");\n+        std::process::exit(1);\n     }\n \n-    // Actually run the compiler!\n-    std::process::exit(if let Some(ref mut on_fail) = on_fail {\n-        match cmd.status() {\n-            Ok(s) if s.success() => 0,\n-            _ => {\n-                println!(\"\\nDid not run successfully:\\n{:?}\\n-------------\", cmd);\n-                exec_cmd(on_fail).expect(\"could not run the backup command\");\n-                1\n+    if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n+        if let Some(krate) = maybe_crate {\n+            let start = Instant::now();\n+            let status = cmd\n+                .status()\n+                .expect(&format!(\"\\n\\n failed to run {:?}\", cmd));\n+            let dur = start.elapsed();\n+\n+            let is_test = args.iter().any(|a| a == \"--test\");\n+            eprintln!(\"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n+                      krate.to_string_lossy(),\n+                      is_test,\n+                      dur.as_secs(),\n+                      dur.subsec_nanos() / 1_000_000);\n+\n+            match status.code() {\n+                Some(i) => std::process::exit(i),\n+                None => {\n+                    eprintln!(\"rustc exited with {}\", status);\n+                    std::process::exit(0xfe);\n+                }\n             }\n         }\n-    } else {\n-        std::process::exit(match exec_cmd(&mut cmd) {\n-            Ok(s) => s.code().unwrap_or(0xfe),\n-            Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n-        })\n-    })\n+    }\n+\n+    let code = exec_cmd(&mut cmd).expect(&format!(\"\\n\\n failed to run {:?}\", cmd));\n+    std::process::exit(code);\n }\n \n #[cfg(unix)]\n-fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n     use std::os::unix::process::CommandExt;\n     Err(cmd.exec())\n }\n \n #[cfg(not(unix))]\n-fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n-    cmd.status()\n+fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n+    cmd.status().map(|status| status.code().unwrap())\n }"}, {"sha": "cf54591f25cd576cd62fa204f939a95bfec1d40e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 59, "deletions": 21, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -314,7 +314,7 @@ def __init__(self):\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n         self.config_toml = ''\n-        self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+        self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n@@ -597,10 +597,8 @@ def build_bootstrap(self):\n                 self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n-        if self.verbose:\n+        for _ in range(1, self.verbose):\n             args.append(\"--verbose\")\n-            if self.verbose > 1:\n-                args.append(\"--verbose\")\n         if self.use_locked_deps:\n             args.append(\"--locked\")\n         if self.use_vendored_sources:\n@@ -614,20 +612,55 @@ def build_triple(self):\n             return config\n         return default_build_triple()\n \n+    def check_submodule(self, module, slow_submodules):\n+        if not slow_submodules:\n+            checked_out = subprocess.Popen([\"git\", \"rev-parse\", \"HEAD\"],\n+                                           cwd=os.path.join(self.rust_root, module),\n+                                           stdout=subprocess.PIPE)\n+            return checked_out\n+        else:\n+            return None\n+\n+    def update_submodule(self, module, checked_out, recorded_submodules):\n+        module_path = os.path.join(self.rust_root, module)\n+\n+        if checked_out != None:\n+            default_encoding = sys.getdefaultencoding()\n+            checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n+            if recorded_submodules[module] == checked_out:\n+                return\n+\n+        print(\"Updating submodule\", module)\n+\n+        run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"submodule\", \"update\",\n+            \"--init\", \"--recursive\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"reset\", \"-q\", \"--hard\"],\n+            cwd=module_path, verbose=self.verbose)\n+        run([\"git\", \"clean\", \"-qdfx\"],\n+            cwd=module_path, verbose=self.verbose)\n+\n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n-        print('Updating submodules')\n+        slow_submodules = self.get_toml('fast-submodules') == \"false\"\n+        start_time = time()\n+        if slow_submodules:\n+            print('Unconditionally updating all submodules')\n+        else:\n+            print('Updating only changed submodules')\n         default_encoding = sys.getdefaultencoding()\n-        run([\"git\", \"submodule\", \"-q\", \"sync\"], cwd=self.rust_root, verbose=self.verbose)\n         submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n             [\"git\", \"config\", \"--file\",\n              os.path.join(self.rust_root, \".gitmodules\"),\n              \"--get-regexp\", \"path\"]\n         ).decode(default_encoding).splitlines()]\n         filtered_submodules = []\n+        submodules_names = []\n         for module in submodules:\n             if module.endswith(\"llvm\"):\n                 if self.get_toml('llvm-config'):\n@@ -645,16 +678,19 @@ def update_submodules(self):\n                 config = self.get_toml('lld')\n                 if config is None or config == 'false':\n                     continue\n-            filtered_submodules.append(module)\n-        run([\"git\", \"submodule\", \"update\",\n-             \"--init\", \"--recursive\"] + filtered_submodules,\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"reset\", \"-q\", \"--hard\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"clean\", \"-qdfx\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n+            check = self.check_submodule(module, slow_submodules)\n+            filtered_submodules.append((module, check))\n+            submodules_names.append(module)\n+        recorded = subprocess.Popen([\"git\", \"ls-tree\", \"HEAD\"] + submodules_names,\n+                                    cwd=self.rust_root, stdout=subprocess.PIPE)\n+        recorded = recorded.communicate()[0].decode(default_encoding).strip().splitlines()\n+        recorded_submodules = {}\n+        for data in recorded:\n+            data = data.split()\n+            recorded_submodules[data[3]] = data[2]\n+        for module in filtered_submodules:\n+            self.update_submodule(module[0], module[1], recorded_submodules)\n+        print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n@@ -674,14 +710,16 @@ def bootstrap(help_triggered):\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n+    parser.add_argument('--src')\n     parser.add_argument('--clean', action='store_true')\n-    parser.add_argument('-v', '--verbose', action='store_true')\n+    parser.add_argument('-v', '--verbose', action='count', default=0)\n \n     args = [a for a in sys.argv if a != '-h' and a != '--help']\n     args, _ = parser.parse_known_args(args)\n \n     # Configure initial bootstrap\n     build = RustBuild()\n+    build.rust_root = args.src or os.path.abspath(os.path.join(__file__, '../../..'))\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n@@ -691,10 +729,9 @@ def bootstrap(help_triggered):\n     except (OSError, IOError):\n         pass\n \n-    if '\\nverbose = 2' in build.config_toml:\n-        build.verbose = 2\n-    elif '\\nverbose = 1' in build.config_toml:\n-        build.verbose = 1\n+    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n+    if match is not None:\n+        build.verbose = max(build.verbose, int(match.group(1)))\n \n     build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n \n@@ -753,6 +790,7 @@ def bootstrap(help_triggered):\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n+    env[\"BUILD_DIR\"] = build.build_dir\n     run(args, env=env, verbose=build.verbose)\n \n "}, {"sha": "3f5ec4933d02b23d31469b3ea022b46fb1f0b323", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 587, "deletions": 54, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::any::Any;\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::env;\n use std::fmt::Debug;\n@@ -18,6 +18,8 @@ use std::hash::Hash;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::time::{Instant, Duration};\n+use std::collections::HashMap;\n \n use compile;\n use install;\n@@ -34,12 +36,20 @@ use native;\n \n pub use Compiler;\n \n+use petgraph::Graph;\n+use petgraph::graph::NodeIndex;\n+\n pub struct Builder<'a> {\n     pub build: &'a Build,\n     pub top_stage: u32,\n     pub kind: Kind,\n     cache: Cache,\n     stack: RefCell<Vec<Box<Any>>>,\n+    time_spent_on_dependencies: Cell<Duration>,\n+    pub paths: Vec<PathBuf>,\n+    graph_nodes: RefCell<HashMap<String, NodeIndex>>,\n+    graph: RefCell<Graph<String, bool>>,\n+    parent: Cell<Option<NodeIndex>>,\n }\n \n impl<'a> Deref for Builder<'a> {\n@@ -60,12 +70,6 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// Run this rule for all hosts without cross compiling.\n     const ONLY_HOSTS: bool = false;\n \n-    /// Run this rule for all targets, but only with the native host.\n-    const ONLY_BUILD_TARGETS: bool = false;\n-\n-    /// Only run this step with the build triple as host and target.\n-    const ONLY_BUILD: bool = false;\n-\n     /// Primary function to execute this rule. Can call `builder.ensure(...)`\n     /// with other steps to run those.\n     fn run(self, builder: &Builder) -> Self::Output;\n@@ -101,8 +105,6 @@ pub struct RunConfig<'a> {\n struct StepDescription {\n     default: bool,\n     only_hosts: bool,\n-    only_build_targets: bool,\n-    only_build: bool,\n     should_run: fn(ShouldRun) -> ShouldRun,\n     make_run: fn(RunConfig),\n     name: &'static str,\n@@ -138,8 +140,6 @@ impl StepDescription {\n         StepDescription {\n             default: S::DEFAULT,\n             only_hosts: S::ONLY_HOSTS,\n-            only_build_targets: S::ONLY_BUILD_TARGETS,\n-            only_build: S::ONLY_BUILD,\n             should_run: S::should_run,\n             make_run: S::make_run,\n             name: unsafe { ::std::intrinsics::type_name::<S>() },\n@@ -155,18 +155,12 @@ impl StepDescription {\n                 self.name, builder.config.exclude);\n         }\n         let build = builder.build;\n-        let hosts = if self.only_build_targets || self.only_build {\n-            build.build_triple()\n-        } else {\n-            &build.hosts\n-        };\n+        let hosts = &build.hosts;\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if build.config.run_host_only {\n-                &[]\n-            } else if self.only_build {\n-                build.build_triple()\n+            if !build.config.run_host_only {\n+                return; // don't run anything\n             } else {\n                 &build.hosts\n             }\n@@ -324,19 +318,24 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n                 test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n                 test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n-                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n-                test::Crate, test::CrateLibrustc, test::Rustdoc, test::Linkcheck, test::Cargotest,\n-                test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty,\n+                test::Crate, test::CrateLibrustc, test::CrateRustdoc, test::Linkcheck,\n+                test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+                test::RunMakeFullDeps,\n                 test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n                 test::TheBook, test::UnstableBook,\n-                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n+                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme,\n+                // Run run-make last, since these won't pass without make on Windows\n+                test::RunMake),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n-                doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n-                doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n-            Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n-                dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign),\n+                doc::Standalone, doc::Std, doc::Test, doc::WhitelistedRustc, doc::Rustc,\n+                doc::ErrorIndex, doc::Nomicon, doc::Reference, doc::Rustdoc, doc::RustByExample,\n+                doc::CargoBook),\n+            Kind::Dist => describe!(dist::Docs, dist::RustcDocs, dist::Mingw, dist::Rustc,\n+                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n+                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Rustfmt, dist::Extended,\n+                dist::HashSign),\n             Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n                 install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n         }\n@@ -359,6 +358,11 @@ impl<'a> Builder<'a> {\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: vec![],\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         let builder = &builder;\n@@ -375,7 +379,7 @@ impl<'a> Builder<'a> {\n         Some(help)\n     }\n \n-    pub fn run(build: &Build) {\n+    pub fn new(build: &Build) -> Builder {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n@@ -387,32 +391,40 @@ impl<'a> Builder<'a> {\n             Subcommand::Clean { .. } => panic!(),\n         };\n \n-        if let Some(path) = paths.get(0) {\n-            if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n-                return;\n-            }\n-        }\n-\n         let builder = Builder {\n             build,\n             top_stage: build.config.stage.unwrap_or(2),\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: paths.to_owned(),\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         if kind == Kind::Dist {\n-            assert!(!build.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+            assert!(!builder.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n                 The distributed libraries would include all MIR (increasing binary size).\n                 The distributed MIR would include validation statements.\");\n         }\n \n-        StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n+        builder\n+    }\n+\n+    pub fn execute_cli(&self) -> Graph<String, bool> {\n+        self.run_step_descriptions(&Builder::get_step_descriptions(self.kind), &self.paths);\n+        self.graph.borrow().clone()\n     }\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n         let paths = paths.unwrap_or(&[]);\n-        StepDescription::run(&Builder::get_step_descriptions(Kind::Doc), self, paths);\n+        self.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), paths);\n+    }\n+\n+    fn run_step_descriptions(&self, v: &[StepDescription], paths: &[PathBuf]) {\n+        StepDescription::run(v, self, paths);\n     }\n \n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n@@ -562,7 +574,9 @@ impl<'a> Builder<'a> {\n         let mut extra_args = env::var(&format!(\"RUSTFLAGS_STAGE_{}\", stage)).unwrap_or_default();\n         if stage != 0 {\n             let s = env::var(\"RUSTFLAGS_STAGE_NOT_0\").unwrap_or_default();\n-            extra_args.push_str(\" \");\n+            if !extra_args.is_empty() {\n+                extra_args.push_str(\" \");\n+            }\n             extra_args.push_str(&s);\n         }\n \n@@ -678,6 +692,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n \n+        if self.config.print_step_timings {\n+            cargo.env(\"RUSTC_PRINT_STEP_TIMINGS\", \"1\");\n+        }\n+\n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n         // Throughout the build Cargo can execute a number of build scripts\n@@ -775,9 +793,11 @@ impl<'a> Builder<'a> {\n         // be resolved because MinGW has the import library. The downside is we\n         // don't get newer functions from Windows, but we don't use any of them\n         // anyway.\n-        cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        if mode != Mode::Tool {\n+            cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        }\n \n-        if self.is_very_verbose() {\n+        for _ in 1..self.verbosity {\n             cargo.arg(\"-v\");\n         }\n \n@@ -792,17 +812,6 @@ impl<'a> Builder<'a> {\n             if cmd != \"bench\" {\n                 cargo.arg(\"--release\");\n             }\n-\n-            if self.config.rust_codegen_units.is_none() &&\n-               self.build.is_rust_llvm(compiler.host) &&\n-               self.config.rust_thinlto {\n-                cargo.env(\"RUSTC_THINLTO\", \"1\");\n-            } else if self.config.rust_codegen_units.is_none() {\n-                // Generally, if ThinLTO has been disabled for some reason, we\n-                // want to set the codegen units to 1. However, we shouldn't do\n-                // this if the option was specifically set by the user.\n-                cargo.env(\"RUSTC_CODEGEN_UNITS\", \"1\");\n-            }\n         }\n \n         if self.config.locked_deps {\n@@ -838,12 +847,56 @@ impl<'a> Builder<'a> {\n             if let Some(out) = self.cache.get(&step) {\n                 self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n \n+                {\n+                    let mut graph = self.graph.borrow_mut();\n+                    let parent = self.parent.get();\n+                    let us = *self.graph_nodes.borrow_mut()\n+                        .entry(format!(\"{:?}\", step))\n+                        .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+                    if let Some(parent) = parent {\n+                        graph.add_edge(parent, us, false);\n+                    }\n+                }\n+\n                 return out;\n             }\n             self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n             stack.push(Box::new(step.clone()));\n         }\n-        let out = step.clone().run(self);\n+\n+        let prev_parent = self.parent.get();\n+\n+        {\n+            let mut graph = self.graph.borrow_mut();\n+            let parent = self.parent.get();\n+            let us = *self.graph_nodes.borrow_mut()\n+                .entry(format!(\"{:?}\", step))\n+                .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+            self.parent.set(Some(us));\n+            if let Some(parent) = parent {\n+                graph.add_edge(parent, us, true);\n+            }\n+        }\n+\n+        let (out, dur) = {\n+            let start = Instant::now();\n+            let zero = Duration::new(0, 0);\n+            let parent = self.time_spent_on_dependencies.replace(zero);\n+            let out = step.clone().run(self);\n+            let dur = start.elapsed();\n+            let deps = self.time_spent_on_dependencies.replace(parent + dur);\n+            (out, dur - deps)\n+        };\n+\n+        self.parent.set(prev_parent);\n+\n+        if self.build.config.print_step_timings && dur > Duration::from_millis(100) {\n+            println!(\"[TIMING] {:?} -- {}.{:03}\",\n+                     step,\n+                     dur.as_secs(),\n+                     dur.subsec_nanos() / 1_000_000);\n+        }\n+\n         {\n             let mut stack = self.stack.borrow_mut();\n             let cur_step = stack.pop().expect(\"step stack empty\");\n@@ -854,3 +907,483 @@ impl<'a> Builder<'a> {\n         out\n     }\n }\n+\n+#[cfg(test)]\n+mod __test {\n+    use config::Config;\n+    use std::thread;\n+    use super::*;\n+\n+    fn configure(host: &[&str], target: &[&str]) -> Config {\n+        let mut config = Config::default_opts();\n+        // don't save toolstates\n+        config.save_toolstates = None;\n+        config.run_host_only = true;\n+        config.dry_run = true;\n+        // try to avoid spurious failures in dist where we create/delete each others file\n+        let dir = config.out.join(\"tmp-rustbuild-tests\")\n+            .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n+        t!(fs::create_dir_all(&dir));\n+        config.out = dir;\n+        config.build = INTERNER.intern_str(\"A\");\n+        config.hosts = vec![config.build].clone().into_iter()\n+            .chain(host.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config.targets = config.hosts.clone().into_iter()\n+            .chain(target.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config\n+    }\n+\n+    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+    }\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = Build::new(configure(&[], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+            dist::Docs { stage: 2, host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false; // as-if --target=C was passed\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+            dist::Docs { stage: 2, host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+    }\n+\n+    #[test]\n+    fn dist_with_same_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(builder.cache.all::<compile::Std>()), &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]);\n+    }\n+\n+    #[test]\n+    fn build_default() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+    }\n+\n+    #[test]\n+    fn build_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false;\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]);\n+\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+    }\n+}"}, {"sha": "d81c6bc28e52705f06c463ad55b0b137eb7fa2e6", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -21,6 +21,7 @@ use std::mem;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n+use std::cmp::{PartialOrd, Ord, Ordering};\n \n use builder::Step;\n \n@@ -154,6 +155,19 @@ impl AsRef<OsStr> for Interned<String> {\n     }\n }\n \n+impl PartialOrd<Interned<String>> for Interned<String> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).partial_cmp(l.get(*other))\n+    }\n+}\n+\n+impl Ord for Interned<String> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).cmp(l.get(*other))\n+    }\n+}\n \n struct TyIntern<T> {\n     items: Vec<T>,\n@@ -264,4 +278,16 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+\n+    #[cfg(test)]\n+    pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n+        let cache = self.0.get_mut();\n+        let type_id = TypeId::of::<S>();\n+        let mut v = cache.remove(&type_id)\n+            .map(|b| b.downcast::<HashMap<S, S::Output>>().expect(\"correct type\"))\n+            .map(|m| m.into_iter().collect::<Vec<_>>())\n+            .unwrap_or_default();\n+        v.sort_by_key(|&(a, _)| a);\n+        v\n+    }\n }"}, {"sha": "8f393a4c573716e38eecc660f4a412a1a0ed1a1c", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -77,7 +77,7 @@ pub fn find(build: &mut Build) {\n                                .collect::<HashSet<_>>();\n     for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n+        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n         if target.contains(\"msvc\") {\n             cfg.static_crt(true);\n@@ -109,7 +109,7 @@ pub fn find(build: &mut Build) {\n     let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n     for host in hosts.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n+        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);\n         let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {"}, {"sha": "3453933a9652c0881188919706c5db4799ab43e2", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.26.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.27.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "a39fad67ebea4ac967bffe828dd8d39c7375b624", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -40,19 +40,20 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, build.build);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n-\n         let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n     }\n }\n \n@@ -86,21 +87,22 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, build.build);\n         let target = self.target;\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n-\n         let stage_out = builder.stage_out(compiler, Mode::Librustc);\n         build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n         build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n         rustc_cargo(build, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &librustc_stamp(build, compiler, target));\n     }\n }\n \n@@ -128,18 +130,20 @@ impl Step for Test {\n         let target = self.target;\n         let compiler = builder.compiler(0, build.build);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n         let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n         test_cargo(build, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libtest_stamp(build, compiler, target));\n     }\n }\n "}, {"sha": "9cc18464fea094668f1c716c74cffe340e233827", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 186, "deletions": 137, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -16,6 +16,7 @@\n //! compiler. This module is also responsible for assembling the sysroot as it\n //! goes along from the output of the previous stage.\n \n+use std::borrow::Cow;\n use std::env;\n use std::fs::{self, File};\n use std::io::BufReader;\n@@ -29,15 +30,15 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n+use util::{exe, libdir, is_dylib, CiEnv};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n \n use cache::{INTERNER, Interned};\n use builder::{Step, RunConfig, ShouldRun, Builder};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n     pub target: Interned<String>,\n     pub compiler: Compiler,\n@@ -76,7 +77,7 @@ impl Step for Std {\n                 compiler: from,\n                 target,\n             });\n-            println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the musl startup objects.\n@@ -93,19 +94,19 @@ impl Step for Std {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-\n         if target.contains(\"musl\") {\n             let libdir = builder.sysroot_libdir(compiler, target);\n             copy_musl_third_party_objects(build, target, &libdir);\n         }\n \n-        let out_dir = build.stage_out(compiler, Mode::Libstd);\n+        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        build.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n@@ -129,7 +130,7 @@ fn copy_musl_third_party_objects(build: &Build,\n                                  target: Interned<String>,\n                                  into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        build.copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n@@ -139,48 +140,58 @@ pub fn std_cargo(build: &Builder,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n-    let mut features = build.std_features();\n-\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n-    // When doing a local rebuild we tell cargo that we're stage1 rather than\n-    // stage0. This works fine if the local rust and being-built rust have the\n-    // same view of what the default allocator is, but fails otherwise. Since\n-    // we don't have a way to express an allocator preference yet, work\n-    // around the issue in the case of a local rebuild with jemalloc disabled.\n-    if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n-        features.push_str(\" force_alloc_system\");\n-    }\n+    if build.no_std(target) == Some(true) {\n+        // for no-std targets we only compile a few no_std crates\n+        cargo.arg(\"--features\").arg(\"c mem\")\n+            .args(&[\"-p\", \"alloc\"])\n+            .args(&[\"-p\", \"compiler_builtins\"])\n+            .args(&[\"-p\", \"std_unicode\"])\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n+    } else {\n+        let mut features = build.std_features();\n+\n+        // When doing a local rebuild we tell cargo that we're stage1 rather than\n+        // stage0. This works fine if the local rust and being-built rust have the\n+        // same view of what the default allocator is, but fails otherwise. Since\n+        // we don't have a way to express an allocator preference yet, work\n+        // around the issue in the case of a local rebuild with jemalloc disabled.\n+        if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n+            features.push_str(\" force_alloc_system\");\n+        }\n \n-    if compiler.stage != 0 && build.config.sanitizers {\n-        // This variable is used by the sanitizer runtime crates, e.g.\n-        // rustc_lsan, to build the sanitizer runtime from C code\n-        // When this variable is missing, those crates won't compile the C code,\n-        // so we don't set this variable during stage0 where llvm-config is\n-        // missing\n-        // We also only build the runtimes when --enable-sanitizers (or its\n-        // config.toml equivalent) is used\n-        let llvm_config = build.ensure(native::Llvm {\n-            target: build.config.build,\n-            emscripten: false,\n-        });\n-        cargo.env(\"LLVM_CONFIG\", llvm_config);\n-    }\n+        if compiler.stage != 0 && build.config.sanitizers {\n+            // This variable is used by the sanitizer runtime crates, e.g.\n+            // rustc_lsan, to build the sanitizer runtime from C code\n+            // When this variable is missing, those crates won't compile the C code,\n+            // so we don't set this variable during stage0 where llvm-config is\n+            // missing\n+            // We also only build the runtimes when --enable-sanitizers (or its\n+            // config.toml equivalent) is used\n+            let llvm_config = build.ensure(native::Llvm {\n+                target: build.config.build,\n+                emscripten: false,\n+            });\n+            cargo.env(\"LLVM_CONFIG\", llvm_config);\n+        }\n \n-    cargo.arg(\"--features\").arg(features)\n-        .arg(\"--manifest-path\")\n-        .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+        cargo.arg(\"--features\").arg(features)\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n \n-    if let Some(target) = build.config.target_config.get(&target) {\n-        if let Some(ref jemalloc) = target.jemalloc {\n-            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        if let Some(target) = build.config.target_config.get(&target) {\n+            if let Some(ref jemalloc) = target.jemalloc {\n+                cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+            }\n         }\n-    }\n-    if target.contains(\"musl\") {\n-        if let Some(p) = build.musl_root(target) {\n-            cargo.env(\"MUSL_ROOT\", p);\n+        if target.contains(\"musl\") {\n+            if let Some(p) = build.musl_root(target) {\n+                cargo.env(\"MUSL_ROOT\", p);\n+            }\n         }\n     }\n }\n@@ -212,20 +223,20 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n+                target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n \n         if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n             // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+            copy_apple_sanitizer_dylibs(&build, &build.native_dir(target), \"osx\", &libdir);\n         }\n \n         builder.ensure(tool::CleanTools {\n@@ -236,15 +247,15 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(build: &Build, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");\n         src_path.push(\"darwin\");\n         src_path.push(&filename);\n-        copy(&src_path, &into.join(filename));\n+        build.copy(&src_path, &into.join(filename));\n     }\n }\n \n@@ -300,23 +311,23 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            build.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(build,\n                                     build.cc(target),\n                                     target,\n                                     obj);\n-            copy(&src, &sysroot_dir.join(obj));\n+            build.copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Test {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Test {\n@@ -351,7 +362,7 @@ impl Step for Test {\n                 compiler: builder.compiler(1, build.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n+            build.info(&format!(\"Uplifting stage1 test ({} -> {})\", &build.build, target));\n             builder.ensure(TestLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n@@ -360,13 +371,14 @@ impl Step for Test {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-        let out_dir = build.stage_out(compiler, Mode::Libtest);\n+        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        build.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n@@ -412,13 +424,13 @@ impl Step for TestLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+                target));\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -428,10 +440,10 @@ impl Step for TestLink {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Rustc {\n@@ -467,7 +479,7 @@ impl Step for Rustc {\n                 compiler: builder.compiler(1, build.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n+            build.info(&format!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target));\n             builder.ensure(RustcLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n@@ -481,17 +493,16 @@ impl Step for Rustc {\n             compiler: builder.compiler(self.compiler.stage, build.build),\n             target: build.build,\n         });\n-\n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, &compiler.host, target);\n-\n-        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n-        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n-        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n+        let cargo_out = builder.cargo_out(compiler, Mode::Librustc, target);\n+        build.clear_if_dirty(&cargo_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&cargo_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         rustc_cargo(build, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        build.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n+                 compiler.stage, &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n@@ -568,13 +579,13 @@ impl Step for RustcLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n                  target_compiler.stage,\n                  compiler.stage,\n                  &compiler.host,\n                  target_compiler.host,\n-                 target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+                 target));\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -634,8 +645,6 @@ impl Step for CodegenBackend {\n             .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"));\n         rustc_cargo_env(build, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n-\n         match &*self.backend {\n             \"llvm\" | \"emscripten\" => {\n                 // Build LLVM for our target. This will implicitly build the\n@@ -649,8 +658,8 @@ impl Step for CodegenBackend {\n                     features.push_str(\" emscripten\");\n                 }\n \n-                println!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n-                         compiler.stage, &compiler.host, target, self.backend);\n+                build.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n+                         compiler.stage, &compiler.host, target, self.backend));\n \n                 // Pass down configuration from the LLVM build into the build of\n                 // librustc_llvm and librustc_trans.\n@@ -685,10 +694,15 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = build.cargo_out(compiler, Mode::Librustc, target)\n             .join(\".tmp.stamp\");\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n         let files = run_cargo(build,\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n                               false);\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let mut files = files.into_iter()\n             .filter(|f| {\n                 let filename = f.file_name().unwrap().to_str().unwrap();\n@@ -732,6 +746,10 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     let dst = builder.sysroot_codegen_backends(target_compiler);\n     t!(fs::create_dir_all(&dst));\n \n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n     for backend in builder.config.rust_codegen_backends.iter() {\n         let stamp = codegen_backend_stamp(build, compiler, target, *backend);\n         let mut dylib = String::new();\n@@ -747,7 +765,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n                     backend,\n                     &filename[dot..])\n         };\n-        copy(&file, &dst.join(target_filename));\n+        build.copy(&file, &dst.join(target_filename));\n     }\n }\n \n@@ -763,7 +781,7 @@ fn copy_lld_to_sysroot(builder: &Builder,\n     t!(fs::create_dir_all(&dst));\n \n     let exe = exe(\"lld\", &target);\n-    copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+    builder.copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n@@ -835,7 +853,7 @@ impl Step for Sysroot {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, PartialOrd, Ord, Clone, PartialEq, Eq, Hash)]\n pub struct Assemble {\n     /// The compiler which we will produce in this step. Assemble itself will\n     /// take care of ensuring that the necessary prerequisites to do so exist,\n@@ -915,7 +933,7 @@ impl Step for Assemble {\n             }\n         }\n \n-        let lld_install = if build.config.lld_enabled && target_compiler.stage > 0 {\n+        let lld_install = if build.config.lld_enabled {\n             Some(builder.ensure(native::Lld {\n                 target: target_compiler.host,\n             }))\n@@ -925,17 +943,17 @@ impl Step for Assemble {\n \n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        println!(\"Assembling stage{} compiler ({})\", stage, host);\n+        build.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n         let sysroot_libdir = sysroot.join(libdir(&*host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n-        for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n             }\n         }\n \n@@ -953,7 +971,7 @@ impl Step for Assemble {\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n         let _ = fs::remove_file(&compiler);\n-        copy(&rustc, &compiler);\n+        builder.copy(&rustc, &compiler);\n \n         target_compiler\n     }\n@@ -963,10 +981,10 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(build: &Build, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in read_stamp_file(stamp) {\n-        copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    for path in build.read_stamp_file(stamp) {\n+        build.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -996,24 +1014,10 @@ fn stderr_isatty() -> bool {\n pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool)\n     -> Vec<PathBuf>\n {\n-    // Instruct Cargo to give us json messages on stdout, critically leaving\n-    // stderr as piped so we can get those pretty colors.\n-    cargo.arg(\"--message-format\").arg(\"json\")\n-         .stdout(Stdio::piped());\n-\n-    if stderr_isatty() && build.ci_env == CiEnv::None {\n-        // since we pass message-format=json to cargo, we need to tell the rustc\n-        // wrapper to give us colored output if necessary. This is because we\n-        // only want Cargo's JSON output, not rustcs.\n-        cargo.env(\"RUSTC_COLOR\", \"1\");\n+    if build.config.dry_run {\n+        return Vec::new();\n     }\n \n-    build.verbose(&format!(\"running: {:?}\", cargo));\n-    let mut child = match cargo.spawn() {\n-        Ok(child) => child,\n-        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),\n-    };\n-\n     // `target_root_dir` looks like $dir/$target/release\n     let target_root_dir = stamp.parent().unwrap();\n     // `target_deps_dir` looks like $dir/$target/release/deps\n@@ -1028,46 +1032,33 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let stdout = BufReader::new(child.stdout.take().unwrap());\n-    for line in stdout.lines() {\n-        let line = t!(line);\n-        let json: serde_json::Value = if line.starts_with(\"{\") {\n-            t!(serde_json::from_str(&line))\n-        } else {\n-            // If this was informational, just print it out and continue\n-            println!(\"{}\", line);\n-            continue\n+    let ok = stream_cargo(build, cargo, &mut |msg| {\n+        let filenames = match msg {\n+            CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n+            _ => return,\n         };\n-        if json[\"reason\"].as_str() != Some(\"compiler-artifact\") {\n-            if build.config.rustc_error_format.as_ref().map_or(false, |e| e == \"json\") {\n-                // most likely not a cargo message, so let's send it out as well\n-                println!(\"{}\", line);\n-            }\n-            continue\n-        }\n-        for filename in json[\"filenames\"].as_array().unwrap() {\n-            let filename = filename.as_str().unwrap();\n+        for filename in filenames {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n                !is_dylib(&filename) &&\n                !(is_check && filename.ends_with(\".rmeta\")) {\n-                continue\n+                return;\n             }\n \n-            let filename = Path::new(filename);\n+            let filename = Path::new(&*filename);\n \n             // If this was an output file in the \"host dir\" we don't actually\n             // worry about it, it's not relevant for us.\n             if filename.starts_with(&host_root_dir) {\n-                continue;\n+                return;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n                 deps.push(filename.to_path_buf());\n-                continue;\n+                return;\n             }\n \n             // Otherwise this was a \"top level artifact\" which right now doesn't\n@@ -1088,15 +1079,10 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n \n             toplevel.push((file_stem, extension, expected_len));\n         }\n-    }\n+    });\n \n-    // Make sure Cargo actually succeeded after we read all of its stdout.\n-    let status = t!(child.wait());\n-    if !status.success() {\n-        panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\",\n-               cargo,\n-               status);\n+    if !ok {\n+        panic!(\"cargo must succeed\");\n     }\n \n     // Ok now we need to actually find all the files listed in `toplevel`. We've\n@@ -1155,7 +1141,7 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n-        build.verbose(&format!(\"not updating {:?}; contents equal and {} <= {}\",\n+        build.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n         return deps\n     }\n@@ -1167,3 +1153,66 @@ pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: boo\n     t!(t!(File::create(stamp)).write_all(&new_contents));\n     deps\n }\n+\n+pub fn stream_cargo(\n+    build: &Build,\n+    cargo: &mut Command,\n+    cb: &mut FnMut(CargoMessage),\n+) -> bool {\n+    if build.config.dry_run {\n+        return true;\n+    }\n+    // Instruct Cargo to give us json messages on stdout, critically leaving\n+    // stderr as piped so we can get those pretty colors.\n+    cargo.arg(\"--message-format\").arg(\"json\")\n+         .stdout(Stdio::piped());\n+\n+    if stderr_isatty() && build.ci_env == CiEnv::None {\n+        // since we pass message-format=json to cargo, we need to tell the rustc\n+        // wrapper to give us colored output if necessary. This is because we\n+        // only want Cargo's JSON output, not rustcs.\n+        cargo.env(\"RUSTC_COLOR\", \"1\");\n+    }\n+\n+    build.verbose(&format!(\"running: {:?}\", cargo));\n+    let mut child = match cargo.spawn() {\n+        Ok(child) => child,\n+        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),\n+    };\n+\n+    // Spawn Cargo slurping up its JSON output. We'll start building up the\n+    // `deps` array of all files it generated along with a `toplevel` array of\n+    // files we need to probe for later.\n+    let stdout = BufReader::new(child.stdout.take().unwrap());\n+    for line in stdout.lines() {\n+        let line = t!(line);\n+        match serde_json::from_str::<CargoMessage>(&line) {\n+            Ok(msg) => cb(msg),\n+            // If this was informational, just print it out and continue\n+            Err(_) => println!(\"{}\", line)\n+        }\n+    }\n+\n+    // Make sure Cargo actually succeeded after we read all of its stdout.\n+    let status = t!(child.wait());\n+    if !status.success() {\n+        eprintln!(\"command did not execute successfully: {:?}\\n\\\n+                  expected success, got: {}\",\n+                 cargo,\n+                 status);\n+    }\n+    status.success()\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(tag = \"reason\", rename_all = \"kebab-case\")]\n+pub enum CargoMessage<'a> {\n+    CompilerArtifact {\n+        package_id: Cow<'a, str>,\n+        features: Vec<Cow<'a, str>>,\n+        filenames: Vec<Cow<'a, str>>,\n+    },\n+    BuildScriptExecuted {\n+        package_id: Cow<'a, str>,\n+    }\n+}"}, {"sha": "863abd14935a8f3493b0994ac4314e8bce5cb804", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -15,7 +15,7 @@\n \n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process;\n@@ -45,6 +45,7 @@ pub struct Config {\n     pub ninja: bool,\n     pub verbose: usize,\n     pub submodules: bool,\n+    pub fast_submodules: bool,\n     pub compiler_docs: bool,\n     pub docs: bool,\n     pub locked_deps: bool,\n@@ -68,6 +69,7 @@ pub struct Config {\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub dry_run: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -86,7 +88,6 @@ pub struct Config {\n     // rust codegen options\n     pub rust_optimize: bool,\n     pub rust_codegen_units: Option<u32>,\n-    pub rust_thinlto: bool,\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n     pub rust_debuginfo_lines: bool,\n@@ -122,11 +123,13 @@ pub struct Config {\n     pub quiet_tests: bool,\n     pub test_miri: bool,\n     pub save_toolstates: Option<PathBuf>,\n+    pub print_step_timings: bool,\n \n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<PathBuf>,\n     pub sysconfdir: Option<PathBuf>,\n+    pub datadir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n     pub bindir: Option<PathBuf>,\n     pub libdir: Option<PathBuf>,\n@@ -141,6 +144,7 @@ pub struct Config {\n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n+    pub out: PathBuf,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -157,6 +161,7 @@ pub struct Target {\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n+    pub no_std: bool,\n }\n \n /// Structure of the `config.toml` file that configuration is read from.\n@@ -190,6 +195,7 @@ struct Build {\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n     submodules: Option<bool>,\n+    fast_submodules: Option<bool>,\n     gdb: Option<String>,\n     locked_deps: Option<bool>,\n     vendor: Option<bool>,\n@@ -204,6 +210,7 @@ struct Build {\n     openssl_static: Option<bool>,\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n+    print_step_timings: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -212,13 +219,13 @@ struct Build {\n struct Install {\n     prefix: Option<String>,\n     sysconfdir: Option<String>,\n+    datadir: Option<String>,\n     docdir: Option<String>,\n     bindir: Option<String>,\n     libdir: Option<String>,\n     mandir: Option<String>,\n \n     // standard paths, currently unused\n-    datadir: Option<String>,\n     infodir: Option<String>,\n     localstatedir: Option<String>,\n }\n@@ -269,7 +276,6 @@ impl Default for StringOrBool {\n struct Rust {\n     optimize: Option<bool>,\n     codegen_units: Option<u32>,\n-    thinlto: Option<bool>,\n     debug_assertions: Option<bool>,\n     debuginfo: Option<bool>,\n     debuginfo_lines: Option<bool>,\n@@ -314,11 +320,8 @@ struct TomlTarget {\n }\n \n impl Config {\n-    pub fn parse(args: &[String]) -> Config {\n-        let flags = Flags::parse(&args);\n-        let file = flags.config.clone();\n+    pub fn default_opts() -> Config {\n         let mut config = Config::default();\n-        config.exclude = flags.exclude;\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;\n@@ -327,6 +330,7 @@ impl Config {\n         config.rust_optimize = true;\n         config.rust_optimize_tests = true;\n         config.submodules = true;\n+        config.fast_submodules = true;\n         config.docs = true;\n         config.rust_rpath = true;\n         config.channel = \"dev\".to_string();\n@@ -337,17 +341,40 @@ impl Config {\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n \n+        // set by bootstrap.py\n+        config.src = env::var_os(\"SRC\").map(PathBuf::from).expect(\"'SRC' to be set\");\n+        config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n+        config.out = env::var_os(\"BUILD_DIR\").map(PathBuf::from).expect(\"'BUILD_DIR' set\");\n+\n+        let stage0_root = config.out.join(&config.build).join(\"stage0/bin\");\n+        config.initial_rustc = stage0_root.join(exe(\"rustc\", &config.build));\n+        config.initial_cargo = stage0_root.join(exe(\"cargo\", &config.build));\n+\n+        config\n+    }\n+\n+    pub fn parse(args: &[String]) -> Config {\n+        let flags = Flags::parse(&args);\n+        let file = flags.config.clone();\n+        let mut config = Config::default_opts();\n+        config.exclude = flags.exclude;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.src = flags.src;\n         config.jobs = flags.jobs;\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n+        config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n \n+        if config.dry_run {\n+            let dir = config.out.join(\"tmp-dry-run\");\n+            t!(fs::create_dir_all(&dir));\n+            config.out = dir;\n+        }\n+\n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n-        config.run_host_only = flags.host.is_empty() && !flags.target.is_empty();\n+        config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n         let toml = file.map(|file| {\n             let mut f = t!(File::open(&file));\n@@ -364,12 +391,7 @@ impl Config {\n         }).unwrap_or_else(|| TomlConfig::default());\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n-        set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n-        set(&mut config.build, flags.build);\n-        if config.build.is_empty() {\n-            // set by bootstrap.py\n-            config.build = INTERNER.intern_str(&env::var(\"BUILD\").unwrap());\n-        }\n+        // set by bootstrap.py\n         config.hosts.push(config.build.clone());\n         for host in build.host.iter() {\n             let host = INTERNER.intern_str(host);\n@@ -403,6 +425,7 @@ impl Config {\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n+        set(&mut config.fast_submodules, build.fast_submodules);\n         set(&mut config.locked_deps, build.locked_deps);\n         set(&mut config.vendor, build.vendor);\n         set(&mut config.full_bootstrap, build.full_bootstrap);\n@@ -414,11 +437,13 @@ impl Config {\n         set(&mut config.openssl_static, build.openssl_static);\n         set(&mut config.configure_args, build.configure_args);\n         set(&mut config.local_rebuild, build.local_rebuild);\n+        set(&mut config.print_step_timings, build.print_step_timings);\n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone().map(PathBuf::from);\n             config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n+            config.datadir = install.datadir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n             config.bindir = install.bindir.clone().map(PathBuf::from);\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n@@ -427,7 +452,6 @@ impl Config {\n \n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n-        let mut thinlto = None;\n         let mut llvm_assertions = None;\n         let mut debuginfo_lines = None;\n         let mut debuginfo_only_std = None;\n@@ -471,7 +495,6 @@ impl Config {\n             optimize = rust.optimize;\n             ignore_git = rust.ignore_git;\n             debug_jemalloc = rust.debug_jemalloc;\n-            thinlto = rust.thinlto;\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n@@ -509,13 +532,13 @@ impl Config {\n                 let mut target = Target::default();\n \n                 if let Some(ref s) = cfg.llvm_config {\n-                    target.llvm_config = Some(env::current_dir().unwrap().join(s));\n+                    target.llvm_config = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.jemalloc {\n-                    target.jemalloc = Some(env::current_dir().unwrap().join(s));\n+                    target.jemalloc = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.android_ndk {\n-                    target.ndk = Some(env::current_dir().unwrap().join(s));\n+                    target.ndk = Some(config.src.join(s));\n                 }\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n@@ -536,30 +559,19 @@ impl Config {\n             set(&mut config.rust_dist_src, t.src_tarball);\n         }\n \n-        let cwd = t!(env::current_dir());\n-        let out = cwd.join(\"build\");\n-\n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        config.initial_rustc = match build.rustc {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        config.initial_cargo = match build.cargo {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-\n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n \n+        set(&mut config.initial_rustc, build.rustc.map(PathBuf::from));\n+        set(&mut config.initial_rustc, build.cargo.map(PathBuf::from));\n+\n         let default = false;\n         config.llvm_assertions = llvm_assertions.unwrap_or(default);\n \n         let default = match &config.channel[..] {\n             \"stable\" | \"beta\" | \"nightly\" => true,\n             _ => false,\n         };\n-        config.rust_thinlto = thinlto.unwrap_or(true);\n         config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n         config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n "}, {"sha": "a5c373d5d5e7729ad118615fc0395f33641f1e2c", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -44,6 +44,7 @@ def v(*args):\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n+o(\"experimental-parallel-queries\", \"rust.experimental-parallel-queries\", \"build rustc with experimental parallelization\")\n o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")\n@@ -71,7 +72,6 @@ def v(*args):\n # Optimization and debugging options. These may be overridden by the release\n # channel, etc.\n o(\"optimize\", \"rust.optimize\", \"build optimized rust code\")\n-o(\"thinlto\", \"rust.thinlto\", \"build Rust with ThinLTO enabled\")\n o(\"optimize-llvm\", \"llvm.optimize\", \"build optimized LLVM\")\n o(\"llvm-assertions\", \"llvm.assertions\", \"build LLVM with assertions\")\n o(\"debug-assertions\", \"rust.debug-assertions\", \"build with debugging assertions\")"}, {"sha": "e1f5d34bf67235c5e2a58225e4e4903f5b6b55a4", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 216, "deletions": 196, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -20,15 +20,15 @@\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file, exe};\n+use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use native;\n@@ -61,7 +61,7 @@ fn rust_installer(builder: &Builder) -> Command {\n     builder.tool_cmd(Tool::RustInstaller)\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n     pub stage: u32,\n     pub host: Interned<String>,\n@@ -70,7 +70,6 @@ pub struct Docs {\n impl Step for Docs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/doc\")\n@@ -90,9 +89,9 @@ impl Step for Docs {\n \n         let name = pkgname(build, \"rust-docs\");\n \n-        println!(\"Dist docs ({})\", host);\n+        build.info(&format!(\"Dist docs ({})\", host));\n         if !build.config.docs {\n-            println!(\"\\tskipping - docs disabled\");\n+            build.info(&format!(\"\\tskipping - docs disabled\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n@@ -103,8 +102,8 @@ impl Step for Docs {\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.out.join(host).join(\"doc\");\n-        cp_r(&src, &dst);\n+        let src = build.doc_out(host);\n+        build.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -119,16 +118,71 @@ impl Step for Docs {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n \n-        // As part of this step, *also* copy the docs directory to a directory which\n-        // buildbot typically uploads.\n-        if host == build.build {\n-            let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&src, &dst);\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcDocs {\n+    pub stage: u32,\n+    pub host: Interned<String>,\n+}\n+\n+impl Step for RustcDocs {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustcDocs {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Builds the `rustc-docs` installer component.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        let name = pkgname(build, \"rustc-docs\");\n+\n+        build.info(&format!(\"Dist compiler docs ({})\", host));\n+        if !build.config.compiler_docs {\n+            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n+        builder.default_doc(None);\n+\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let dst = image.join(\"share/doc/rust/html\");\n+        t!(fs::create_dir_all(&dst));\n+        let src = build.compiler_doc_out(host);\n+        build.cp_r(&src, &dst);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rustc-Documentation\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rustc-documentation-is-installed.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rustc-docs\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+        build.run(&mut cmd);\n+        build.remove_dir(&image);\n+\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n@@ -204,20 +258,25 @@ fn make_win_dist(\n         \"libbcrypt.a\",\n         \"libcomctl32.a\",\n         \"libcomdlg32.a\",\n+        \"libcredui.a\",\n         \"libcrypt32.a\",\n+        \"libdbghelp.a\",\n         \"libgdi32.a\",\n         \"libimagehlp.a\",\n         \"libiphlpapi.a\",\n         \"libkernel32.a\",\n+        \"libmsimg32.a\",\n         \"libmsvcrt.a\",\n         \"libodbc32.a\",\n         \"libole32.a\",\n         \"liboleaut32.a\",\n         \"libopengl32.a\",\n         \"libpsapi.a\",\n         \"librpcrt4.a\",\n+        \"libsecur32.a\",\n         \"libsetupapi.a\",\n         \"libshell32.a\",\n+        \"libsynchronization.a\",\n         \"libuser32.a\",\n         \"libuserenv.a\",\n         \"libuuid.a\",\n@@ -226,52 +285,43 @@ fn make_win_dist(\n         \"libwinspool.a\",\n         \"libws2_32.a\",\n         \"libwsock32.a\",\n-        \"libdbghelp.a\",\n-        \"libmsimg32.a\",\n     ];\n \n     //Find mingw artifacts we want to bundle\n     let target_tools = find_files(&target_tools, &bin_path);\n     let rustc_dlls = find_files(&rustc_dlls, &bin_path);\n     let target_libs = find_files(&target_libs, &lib_path);\n \n-    fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap();\n-        let dest = dest_folder.join(file_name);\n-        copy(src, &dest);\n-    }\n-\n-    //Copy runtime dlls next to rustc.exe\n+    // Copy runtime dlls next to rustc.exe\n     let dist_bin_dir = rust_root.join(\"bin/\");\n     fs::create_dir_all(&dist_bin_dir).expect(\"creating dist_bin_dir failed\");\n     for src in rustc_dlls {\n-        copy_to_folder(&src, &dist_bin_dir);\n+        build.copy_to_folder(&src, &dist_bin_dir);\n     }\n \n     //Copy platform tools to platform-specific bin directory\n     let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n-        copy_to_folder(&src, &target_bin_dir);\n+        build.copy_to_folder(&src, &target_bin_dir);\n     }\n \n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n-        copy_to_folder(&src, &target_lib_dir);\n+        build.copy_to_folder(&src, &target_lib_dir);\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    host: Interned<String>,\n+    pub host: Interned<String>,\n }\n \n impl Step for Mingw {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -293,7 +343,7 @@ impl Step for Mingw {\n             return None;\n         }\n \n-        println!(\"Dist mingw ({})\", host);\n+        build.info(&format!(\"Dist mingw ({})\", host));\n         let name = pkgname(build, \"rust-mingw\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -322,7 +372,7 @@ impl Step for Mingw {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     pub compiler: Compiler,\n }\n@@ -331,7 +381,6 @@ impl Step for Rustc {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/librustc\")\n@@ -349,7 +398,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        println!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host);\n+        build.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host));\n         let name = pkgname(build, \"rustc\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -362,17 +411,17 @@ impl Step for Rustc {\n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n         let cp = |file: &str| {\n-            install(&build.src.join(file), &overlay, 0o644);\n+            build.install(&build.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n         // tiny morsel of metadata is used by rust-packaging\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n@@ -390,7 +439,7 @@ impl Step for Rustc {\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n-            cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+            build.cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n@@ -407,8 +456,8 @@ impl Step for Rustc {\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        t!(fs::remove_dir_all(&overlay));\n+        build.remove_dir(&image);\n+        build.remove_dir(&overlay);\n \n         return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n \n@@ -420,17 +469,17 @@ impl Step for Rustc {\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n-            cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+            build.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            build.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n-                for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n+                for entry in build.read_dir(&src.join(libdir)) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            install(&entry.path(), &image.join(libdir), 0o644);\n+                            build.install(&entry.path(), &image.join(libdir), 0o644);\n                         }\n                     }\n                 }\n@@ -441,7 +490,7 @@ impl Step for Rustc {\n             let backends_rel = backends_src.strip_prefix(&src).unwrap();\n             let backends_dst = image.join(&backends_rel);\n             t!(fs::create_dir_all(&backends_dst));\n-            cp_r(&backends_src, &backends_dst);\n+            build.cp_r(&backends_src, &backends_dst);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -456,7 +505,7 @@ impl Step for Rustc {\n                     .join(\"bin\")\n                     .join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n-                copy(&src, &dst);\n+                build.copy(&src, &dst);\n             }\n \n             // Man pages\n@@ -466,13 +515,12 @@ impl Step for Rustc {\n             let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n-            for entry_result in t!(fs::read_dir(man_src)) {\n-                let file_entry = t!(entry_result);\n+            for file_entry in build.read_dir(&man_src) {\n                 let page_src = file_entry.path();\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                replace_in_file(&page_dst,\n+                build.replace_in_file(&page_dst,\n                                 &[(\"<INSERT DATE HERE>\", &month_year),\n                                   (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n             }\n@@ -485,7 +533,7 @@ impl Step for Rustc {\n \n             // Misc license info\n             let cp = |file: &str| {\n-                install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+                build.install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n             };\n             cp(\"COPYRIGHT\");\n             cp(\"LICENSE-APACHE\");\n@@ -523,11 +571,11 @@ impl Step for DebuggerScripts {\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n-            install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+            build.install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n@@ -537,22 +585,22 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n@@ -561,15 +609,14 @@ pub struct Std {\n impl Step for Std {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/libstd\")\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n             target: run.target,\n         });\n     }\n@@ -580,12 +627,12 @@ impl Step for Std {\n         let target = self.target;\n \n         let name = pkgname(build, \"rust-std\");\n-        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target);\n+        build.info(&format!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target));\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n         if compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n+            build.info(&format!(\"\\tskipping, not a build host\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -595,7 +642,12 @@ impl Step for Std {\n         if build.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            builder.ensure(compile::Test { compiler, target });\n+            if build.no_std(target) == Some(true) {\n+                // the `test` doesn't compile for no-std targets\n+                builder.ensure(compile::Std { compiler, target });\n+            } else {\n+                builder.ensure(compile::Test { compiler, target });\n+            }\n         }\n \n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n@@ -605,7 +657,7 @@ impl Step for Std {\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        cp_filtered(&src, &dst, &|path| {\n+        build.cp_filtered(&src, &dst, &|path| {\n             let name = path.file_name().and_then(|s| s.to_str());\n             name != Some(build.config.rust_codegen_backends_dir.as_str()) &&\n                 name != Some(\"bin\")\n@@ -624,7 +676,7 @@ impl Step for Std {\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -638,7 +690,6 @@ pub struct Analysis {\n impl Step for Analysis {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n@@ -647,7 +698,7 @@ impl Step for Analysis {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n             target: run.target,\n         });\n     }\n@@ -658,11 +709,11 @@ impl Step for Analysis {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(build.config.extended);\n-        println!(\"Dist analysis\");\n+        build.info(&format!(\"Dist analysis\"));\n         let name = pkgname(build, \"rust-analysis\");\n \n         if &compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n+            build.info(&format!(\"\\tskipping, not a build host\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -684,8 +735,8 @@ impl Step for Analysis {\n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n-        println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n-        cp_r(&image_src, &dst);\n+        build.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n+        build.cp_r(&image_src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -699,7 +750,7 @@ impl Step for Analysis {\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -743,20 +794,18 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        build.cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Src;\n \n impl Step for Src {\n     /// The output path of the src installer tarball\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src\")\n@@ -769,7 +818,7 @@ impl Step for Src {\n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        println!(\"Dist src\");\n+        build.info(&format!(\"Dist src\"));\n \n         let name = pkgname(build, \"rust-src\");\n         let image = tmpdir(build).join(format!(\"{}-image\", name));\n@@ -819,7 +868,7 @@ impl Step for Src {\n \n         copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n         for file in src_files.iter() {\n-            copy(&build.src.join(file), &dst_src.join(file));\n+            build.copy(&build.src.join(file), &dst_src.join(file));\n         }\n \n         // Create source tarball in rust-installer format\n@@ -836,23 +885,21 @@ impl Step for Src {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n \n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n \n const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n impl Step for PlainSourceTarball {\n     /// Produces the location of the tarball generated\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n@@ -866,7 +913,7 @@ impl Step for PlainSourceTarball {\n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        println!(\"Create plain source tarball\");\n+        build.info(&format!(\"Create plain source tarball\"));\n \n         // Make sure that the root folder of tarball has the correct name\n         let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n@@ -894,13 +941,13 @@ impl Step for PlainSourceTarball {\n \n         // Copy the files normally\n         for item in &src_files {\n-            copy(&build.src.join(item), &plain_dst_src.join(item));\n+            build.copy(&build.src.join(item), &plain_dst_src.join(item));\n         }\n \n         // Create the version file\n-        write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+        build.create(&plain_dst_src.join(\"version\"), &build.rust_version());\n         if let Some(sha) = build.rust_sha() {\n-            write_file(&plain_dst_src.join(\"git-commit-hash\"), sha.as_bytes());\n+            build.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n@@ -941,9 +988,9 @@ impl Step for PlainSourceTarball {\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n         if let Some(dir) = tarball.parent() {\n-            t!(fs::create_dir_all(dir));\n+            build.create_dir(&dir);\n         }\n-        println!(\"running installer\");\n+        build.info(&format!(\"running installer\"));\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n            .arg(\"--input\").arg(&plain_name)\n@@ -955,26 +1002,6 @@ impl Step for PlainSourceTarball {\n     }\n }\n \n-fn install(src: &Path, dstdir: &Path, perms: u32) {\n-    let dst = dstdir.join(src.file_name().unwrap());\n-    t!(fs::create_dir_all(dstdir));\n-    drop(fs::remove_file(&dst));\n-    {\n-        let mut s = t!(fs::File::open(&src));\n-        let mut d = t!(fs::File::create(&dst));\n-        io::copy(&mut s, &mut d).expect(\"failed to copy\");\n-    }\n-    chmod(&dst, perms);\n-}\n-\n-#[cfg(unix)]\n-fn chmod(path: &Path, perms: u32) {\n-    use std::os::unix::fs::*;\n-    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n-}\n-#[cfg(windows)]\n-fn chmod(_path: &Path, _perms: u32) {}\n-\n // We have to run a few shell scripts, which choke quite a bit on both `\\`\n // characters and on `C:\\` paths, so normalize both of them away.\n pub fn sanitize_sh(path: &Path) -> String {\n@@ -994,20 +1021,14 @@ pub fn sanitize_sh(path: &Path) -> String {\n     }\n }\n \n-fn write_file(path: &Path, data: &[u8]) {\n-    let mut vf = t!(fs::File::create(path));\n-    t!(vf.write_all(data));\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub stage: u32,\n     pub target: Interned<String>,\n }\n \n impl Step for Cargo {\n     type Output = PathBuf;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1026,7 +1047,7 @@ impl Step for Cargo {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist cargo stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = build.release_num(\"cargo\");\n@@ -1036,38 +1057,38 @@ impl Step for Cargo {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"cargo-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n-        t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-        t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n+        build.create_dir(&image.join(\"share/zsh/site-functions\"));\n+        build.create_dir(&image.join(\"etc/bash_completion.d\"));\n         let cargo = builder.ensure(tool::Cargo {\n             compiler: builder.compiler(stage, build.build),\n             target\n         });\n-        install(&cargo, &image.join(\"bin\"), 0o755);\n+        build.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n-            install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+            build.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n-        install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        copy(&etc.join(\"cargo.bashcomp.sh\"),\n+        build.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        build.copy(&etc.join(\"cargo.bashcomp.sh\"),\n              &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"cargo-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1087,15 +1108,14 @@ impl Step for Cargo {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub stage: u32,\n     pub target: Interned<String>,\n }\n \n impl Step for Rls {\n     type Output = Option<PathBuf>;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1115,7 +1135,7 @@ impl Step for Rls {\n         let target = self.target;\n         assert!(build.config.extended);\n \n-        println!(\"Dist RLS stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n         let name = pkgname(build, \"rls\");\n@@ -1131,23 +1151,23 @@ impl Step for Rls {\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n             compiler: builder.compiler(stage, build.build),\n-            target\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n-        install(&rls, &image.join(\"bin\"), 0o755);\n+        build.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rls-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1169,15 +1189,14 @@ impl Step for Rls {\n }\n \n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n     pub stage: u32,\n     pub target: Interned<String>,\n }\n \n impl Step for Rustfmt {\n     type Output = Option<PathBuf>;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1195,9 +1214,8 @@ impl Step for Rustfmt {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        assert!(build.config.extended);\n \n-        println!(\"Dist Rustfmt stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/rustfmt\");\n         let release_num = build.release_num(\"rustfmt\");\n         let name = pkgname(build, \"rustfmt\");\n@@ -1206,33 +1224,33 @@ impl Step for Rustfmt {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"rustfmt-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n             compiler: builder.compiler(stage, build.build),\n-            target\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Rustfmt, skipping dist\"); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n             compiler: builder.compiler(stage, build.build),\n-            target\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n-        install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        build.install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        build.install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rustfmt-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1253,7 +1271,7 @@ impl Step for Rustfmt {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n     host: Interned<String>,\n@@ -1263,7 +1281,6 @@ pub struct Extended {\n impl Step for Extended {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1274,7 +1291,7 @@ impl Step for Extended {\n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n-            host: run.host,\n+            host: run.builder.build.build,\n             target: run.target,\n         });\n     }\n@@ -1285,7 +1302,7 @@ impl Step for Extended {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist extended stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n@@ -1311,15 +1328,15 @@ impl Step for Extended {\n         let work = tmp.join(\"work\");\n \n         let _ = fs::remove_dir_all(&overlay);\n-        install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n-        install(&etc.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1358,11 +1375,11 @@ impl Step for Extended {\n         build.run(&mut cmd);\n \n         let mut license = String::new();\n-        t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n+        license += &build.read(&build.src.join(\"COPYRIGHT\"));\n+        license += &build.read(&build.src.join(\"LICENSE-APACHE\"));\n+        license += &build.read(&build.src.join(\"LICENSE-MIT\"));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n \n         let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n         let mut rtf = rtf.to_string();\n@@ -1419,10 +1436,10 @@ impl Step for Extended {\n             };\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(pkg.join(name)));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                build.create_dir(&pkg.join(name));\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n                         &pkg.join(name));\n-                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n             prepare(\"rustc\");\n@@ -1436,12 +1453,12 @@ impl Step for Extended {\n             }\n \n             // create an 'uninstall' package\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n \n-            t!(fs::create_dir_all(pkg.join(\"res\")));\n-            t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n-            install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            build.create_dir(&pkg.join(\"res\"));\n+            build.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n+            build.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n             cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n@@ -1457,18 +1474,18 @@ impl Step for Extended {\n             let _ = fs::remove_dir_all(&exe);\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(exe.join(name)));\n+                build.create_dir(&exe.join(name));\n                 let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n                             .join(dir),\n                         &exe.join(name));\n-                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+                build.remove(&exe.join(name).join(\"manifest.in\"));\n             };\n             prepare(\"rustc\");\n             prepare(\"cargo\");\n@@ -1482,11 +1499,11 @@ impl Step for Extended {\n                 prepare(\"rust-mingw\");\n             }\n \n-            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n+            build.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n+            build.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            build.create(&exe.join(\"LICENSE.txt\"), &license);\n \n             // Generate exe installer\n             let mut cmd = Command::new(\"iscc\");\n@@ -1497,7 +1514,7 @@ impl Step for Extended {\n             }\n             add_env(build, &mut cmd, target);\n             build.run(&mut cmd);\n-            install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n+            build.install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n                     &distdir(build),\n                     0o755);\n \n@@ -1621,9 +1638,9 @@ impl Step for Extended {\n                 candle(\"GccGroup.wxs\".as_ref());\n             }\n \n-            t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n-            install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+            build.create(&exe.join(\"LICENSE.rtf\"), &rtf);\n+            build.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n             let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n@@ -1653,7 +1670,9 @@ impl Step for Extended {\n \n             build.run(&mut cmd);\n \n-            t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            if !build.config.dry_run {\n+                t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            }\n         }\n     }\n }\n@@ -1687,14 +1706,12 @@ fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct HashSign;\n \n impl Step for HashSign {\n     type Output = ();\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"hash-and-sign\")\n@@ -1707,6 +1724,9 @@ impl Step for HashSign {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n+        if build.config.dry_run {\n+            return;\n+        }\n         let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n         });\n@@ -1730,7 +1750,7 @@ impl Step for HashSign {\n         cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n         cmd.arg(addr);\n \n-        t!(fs::create_dir_all(distdir(build)));\n+        build.create_dir(&distdir(build));\n \n         let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n         t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));"}, {"sha": "4237ded2215c218e4fd8ed16e4d7d4a795fecc4b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 154, "deletions": 54, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -17,19 +17,21 @@\n //! Everything here is basically just a shim around calling either `rustbook` or\n //! `rustdoc`.\n \n+use std::collections::HashSet;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use Mode;\n+use {Build, Mode};\n use build_helper::up_to_date;\n \n-use util::{cp_r, symlink_dir};\n+use util::symlink_dir;\n use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n use tool::Tool;\n use compile;\n use cache::{INTERNER, Interned};\n+use config::Config;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -167,7 +169,7 @@ impl Step for CargoBook {\n \n         let out = out.join(name);\n \n-        println!(\"Cargo Book ({}) - {}\", target, name);\n+        build.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n \n         let _ = fs::remove_dir_all(&out);\n \n@@ -209,12 +211,13 @@ impl Step for RustbookSrc {\n         let src = src.join(name);\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n-        println!(\"Rustbook ({}) - {}\", target, name);\n+        build.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        build.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -280,11 +283,11 @@ impl Step for TheBook {\n \n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n-        println!(\"Documenting book index ({})\", target);\n+        build.info(&format!(\"Documenting book index ({})\", target));\n         invoke_rustdoc(builder, compiler, target, &index);\n \n         // build the redirect pages\n-        println!(\"Documenting book redirect pages ({})\", target);\n+        build.info(&format!(\"Documenting book redirect pages ({})\", target));\n         for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n             let file = t!(file);\n             let path = file.path();\n@@ -357,7 +360,7 @@ impl Step for Standalone {\n         let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n-        println!(\"Documenting standalone ({})\", target);\n+        build.info(&format!(\"Documenting standalone ({})\", target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n@@ -369,7 +372,7 @@ impl Step for Standalone {\n         let version_input = build.src.join(\"src/doc/version_info.html.template\");\n         let version_info = out.join(\"version_info.html\");\n \n-        if !up_to_date(&version_input, &version_info) {\n+        if !build.config.dry_run && !up_to_date(&version_input, &version_info) {\n             let mut info = String::new();\n             t!(t!(File::open(&version_input)).read_to_string(&mut info));\n             let info = info.replace(\"VERSION\", &build.rust_release())\n@@ -393,7 +396,7 @@ impl Step for Standalone {\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n                up_to_date(&version_info, &html) &&\n-               up_to_date(&rustdoc, &html) {\n+               (build.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n \n@@ -448,7 +451,7 @@ impl Step for Std {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} std ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -478,28 +481,24 @@ impl Step for Std {\n         // will also directly handle merging.\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&build.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n \n-        // We don't want to build docs for internal std dependencies unless\n-        // in compiler-docs mode. When not in that mode, we whitelist the crates\n-        // for which docs must be built.\n-        if !build.config.compiler_docs {\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-                // Create all crate output directories first to make sure rustdoc uses\n-                // relative links.\n-                // FIXME: Cargo should probably do this itself.\n-                t!(fs::create_dir_all(out_dir.join(krate)));\n-            }\n+        // Keep a whitelist so we do not build internal stdlib crates, these will be\n+        // build by the rustc step later if enabled.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n         }\n \n-\n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -533,7 +532,7 @@ impl Step for Test {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} test ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -554,22 +553,22 @@ impl Step for Test {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n         compile::test_cargo(build, &compiler, target, &mut cargo);\n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustc {\n+pub struct WhitelistedRustc {\n     stage: u32,\n     target: Interned<String>,\n }\n \n-impl Step for Rustc {\n+impl Step for WhitelistedRustc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -580,21 +579,26 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustc {\n+        run.builder.ensure(WhitelistedRustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    /// Generate all compiler documentation.\n+    /// Generate whitelisted compiler crate documentation.\n     ///\n-    /// This will generate all documentation for the compiler libraries and their\n-    /// dependencies. This is largely just a wrapper around `cargo doc`.\n+    /// This will generate all documentation for crates that are whitelisted\n+    /// to be included in the standard documentation. This documentation is\n+    /// included in the standard Rust documentation, so we should always\n+    /// document it and symlink to merge with the rest of the std and test\n+    /// documentation. We don't build other compiler documentation\n+    /// here as we want to be able to keep it separate from the standard\n+    /// documentation. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} compiler ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -615,26 +619,119 @@ impl Step for Rustc {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n \n-        if build.config.compiler_docs {\n-            // src/rustc/Cargo.toml contains a bin crate called rustc which\n-            // would otherwise overwrite the docs for the real rustc lib crate.\n-            cargo.arg(\"-p\").arg(\"rustc_driver\");\n+        // We don't want to build docs for internal compiler dependencies in this\n+        // step (there is another step for that). Therefore, we whitelist the crates\n+        // for which docs must be built.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"proc_macro\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n+        build.run(&mut cargo);\n+        build.cp_r(&my_out, &out);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustc {\n+    stage: u32,\n+    target: Interned<String>,\n+}\n+\n+impl Step for Rustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.krate(\"rustc-main\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Generate compiler documentation.\n+    ///\n+    /// This will generate all documentation for compiler and dependencies.\n+    /// Compiler documentation is distributed separately, so we make sure\n+    /// we do not merge it with the other documentation from std, test and\n+    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        build.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n+        let out = build.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = builder.compiler(stage, build.build);\n+        let rustdoc = builder.rustdoc(compiler.host);\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n         } else {\n-            // Like with libstd above if compiler docs aren't enabled then we're not\n-            // documenting internal dependencies, so we have a whitelist.\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"proc_macro\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n+            compiler\n+        };\n+\n+        if !build.config.compiler_docs {\n+            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+            return;\n+        }\n+\n+        // Build libstd docs so that we generate relative links\n+        builder.ensure(Std { stage, target });\n+\n+        builder.ensure(compile::Rustc { compiler, target });\n+        let out_dir = build.stage_out(compiler, Mode::Librustc)\n+                           .join(target).join(\"doc\");\n+        // We do not symlink to the same shared folder that already contains std library\n+        // documentation from previous steps as we do not want to include that.\n+        build.clear_if_dirty(&out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        compile::rustc_cargo(build, &mut cargo);\n+\n+        // Only include compiler crates, no dependencies of those, such as `libc`.\n+        cargo.arg(\"--no-deps\");\n+\n+        // Find dependencies for top level crates.\n+        let mut compiler_crates = HashSet::new();\n+        for root_crate in &[\"rustc\", \"rustc_driver\"] {\n+            let interned_root_crate = INTERNER.intern_str(root_crate);\n+            find_compiler_crates(&build, &interned_root_crate, &mut compiler_crates);\n+        }\n+\n+        for krate in &compiler_crates {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n \n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+    }\n+}\n+\n+fn find_compiler_crates(\n+    build: &Build,\n+    name: &Interned<String>,\n+    crates: &mut HashSet<Interned<String>>\n+) {\n+    // Add current crate.\n+    crates.insert(*name);\n+\n+    // Look for dependencies.\n+    for dep in build.crates.get(name).unwrap().deps.iter() {\n+        if build.crates.get(dep).unwrap().is_local(build) {\n+            find_compiler_crates(build, dep, crates);\n+        }\n     }\n }\n \n@@ -665,7 +762,7 @@ impl Step for ErrorIndex {\n         let build = builder.build;\n         let target = self.target;\n \n-        println!(\"Documenting error index ({})\", target);\n+        build.info(&format!(\"Documenting error index ({})\", target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let mut index = builder.tool_cmd(Tool::ErrorIndex);\n@@ -710,10 +807,10 @@ impl Step for UnstableBookGen {\n             target,\n         });\n \n-        println!(\"Generating unstable book md files ({})\", target);\n+        build.info(&format!(\"Generating unstable book md files ({})\", target));\n         let out = build.md_doc_out(target).join(\"unstable-book\");\n-        t!(fs::create_dir_all(&out));\n-        t!(fs::remove_dir_all(&out));\n+        build.create_dir(&out);\n+        build.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(out);\n@@ -722,7 +819,10 @@ impl Step for UnstableBookGen {\n     }\n }\n \n-fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n+fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()> {\n+    if config.dry_run {\n+        return Ok(());\n+    }\n     if let Ok(m) = fs::symlink_metadata(dst) {\n         if m.file_type().is_dir() {\n             try!(fs::remove_dir_all(dst));\n@@ -735,5 +835,5 @@ fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n         }\n     }\n \n-    symlink_dir(src, dst)\n+    symlink_dir(config, src, dst)\n }"}, {"sha": "cd304fb26e0bfcb939cf226951a19c58c170d4f3", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -13,7 +13,6 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n@@ -29,21 +28,20 @@ use cache::{Interned, INTERNER};\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n-    pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n+    pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n-    pub build: Option<Interned<String>>,\n \n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n-    pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub dry_run: bool,\n }\n \n pub enum Subcommand {\n@@ -114,6 +112,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n+        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n@@ -278,10 +277,6 @@ Arguments:\n             _ => { }\n         };\n         // Get any optional paths which occur after the subcommand\n-        let cwd = t!(env::current_dir());\n-        let src = matches.opt_str(\"src\").map(PathBuf::from)\n-            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n-            .unwrap_or(cwd.clone());\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n@@ -371,10 +366,10 @@ Arguments:\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n+            dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))\n@@ -385,7 +380,6 @@ Arguments:\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(matches.opt_strs(\"exclude\"))\n                 .into_iter().map(|p| p.into()).collect::<Vec<_>>(),\n-            src,\n         }\n     }\n }"}, {"sha": "4b05cac1ce6979123e0637c5169c9dd2a4b9dff4", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -63,22 +63,25 @@ fn install_sh(\n     host: Option<Interned<String>>\n ) {\n     let build = builder.build;\n-    println!(\"Install {} stage{} ({:?})\", package, stage, host);\n+    build.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n     let prefix_default = PathBuf::from(\"/usr/local\");\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n-    let docdir_default = PathBuf::from(\"share/doc/rust\");\n+    let datadir_default = PathBuf::from(\"share\");\n+    let docdir_default = datadir_default.join(\"doc/rust\");\n     let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n-    let mandir_default = PathBuf::from(\"share/man\");\n+    let mandir_default = datadir_default.join(\"man\");\n     let prefix = build.config.prefix.as_ref().unwrap_or(&prefix_default);\n     let sysconfdir = build.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n+    let datadir = build.config.datadir.as_ref().unwrap_or(&datadir_default);\n     let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n     let bindir = build.config.bindir.as_ref().unwrap_or(&bindir_default);\n     let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n     let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n \n     let sysconfdir = prefix.join(sysconfdir);\n+    let datadir = prefix.join(datadir);\n     let docdir = prefix.join(docdir);\n     let bindir = prefix.join(bindir);\n     let libdir = prefix.join(libdir);\n@@ -88,6 +91,7 @@ fn install_sh(\n \n     let prefix = add_destdir(&prefix, &destdir);\n     let sysconfdir = add_destdir(&sysconfdir, &destdir);\n+    let datadir = add_destdir(&datadir, &destdir);\n     let docdir = add_destdir(&docdir, &destdir);\n     let bindir = add_destdir(&bindir, &destdir);\n     let libdir = add_destdir(&libdir, &destdir);\n@@ -107,6 +111,7 @@ fn install_sh(\n         .arg(sanitize_sh(&tmpdir(build).join(&package_name).join(\"install.sh\")))\n         .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n         .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n+        .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n         .arg(format!(\"--docdir={}\", sanitize_sh(&docdir)))\n         .arg(format!(\"--bindir={}\", sanitize_sh(&bindir)))\n         .arg(format!(\"--libdir={}\", sanitize_sh(&libdir)))\n@@ -161,7 +166,6 @@ macro_rules! install {\n         impl Step for $name {\n             type Output = ();\n             const DEFAULT: bool = true;\n-            const ONLY_BUILD_TARGETS: bool = true;\n             const ONLY_HOSTS: bool = $only_hosts;\n             $(const $c: bool = true;)*\n \n@@ -174,7 +178,7 @@ macro_rules! install {\n                 run.builder.ensure($name {\n                     stage: run.builder.top_stage,\n                     target: run.target,\n-                    host: run.host,\n+                    host: run.builder.build.build,\n                 });\n             }\n \n@@ -208,15 +212,16 @@ install!((self, builder, _config),\n             Self::should_install(builder) {\n             install_rls(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install RLS stage{} ({})\", self.stage, self.target);\n+            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n         if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n             install_rustfmt(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target);\n+            builder.info(\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n@@ -226,14 +231,39 @@ install!((self, builder, _config),\n         });\n         install_analysis(builder, self.stage, self.target);\n     };\n-    Src, \"src\", Self::should_build(_config) , only_hosts: true, {\n-        builder.ensure(dist::Src);\n-        install_src(builder, self.stage);\n-    }, ONLY_BUILD;\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n             compiler: builder.compiler(self.stage, self.target),\n         });\n         install_rustc(builder, self.stage, self.target);\n     };\n );\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Src {\n+    pub stage: u32,\n+}\n+\n+impl Step for Src {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let config = &run.builder.config;\n+        let cond = config.extended &&\n+            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        run.path(\"src\").default_condition(cond)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Src {\n+            stage: run.builder.top_stage,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(dist::Src);\n+        install_src(builder, self.stage);\n+    }\n+}"}, {"sha": "ea4368c0323fbd761b127afd0e32a3a65222a869", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 249, "deletions": 30, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -113,8 +113,9 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-//#![deny(warnings)]\n-#![feature(core_intrinsics)]\n+#![deny(warnings)]\n+#![feature(conservative_impl_trait, fs_read_write, core_intrinsics)]\n+#![feature(slice_concat_ext)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -130,20 +131,27 @@ extern crate getopts;\n extern crate num_cpus;\n extern crate toml;\n extern crate time;\n+extern crate petgraph;\n+\n+#[cfg(test)]\n+#[macro_use]\n+extern crate pretty_assertions;\n \n #[cfg(unix)]\n extern crate libc;\n \n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs::{self, OpenOptions, File};\n+use std::io::{self, Seek, SeekFrom, Write, Read};\n use std::path::{PathBuf, Path};\n use std::process::{self, Command};\n use std::slice;\n+use std::str;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use filetime::FileTime;\n \n use util::{exe, libdir, OutputFolder, CiEnv};\n \n@@ -197,7 +205,7 @@ use toolstate::ToolState;\n /// Each compiler has a `stage` that it is associated with and a `host` that\n /// corresponds to the platform the compiler runs on. This structure is used as\n /// a parameter to many methods below.\n-#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+#[derive(Eq, PartialOrd, Ord, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler {\n     stage: u32,\n     host: Interned<String>,\n@@ -253,6 +261,10 @@ pub struct Build {\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n     prerelease_version: Cell<Option<u32>>,\n+    tool_artifacts: RefCell<HashMap<\n+        Interned<String>,\n+        HashMap<String, (&'static str, PathBuf, Vec<String>)>\n+    >>,\n }\n \n #[derive(Debug)]\n@@ -304,9 +316,8 @@ impl Build {\n     ///\n     /// By default all build output will be placed in the current directory.\n     pub fn new(config: Config) -> Build {\n-        let cwd = t!(env::current_dir());\n         let src = config.src.clone();\n-        let out = cwd.join(\"build\");\n+        let out = config.out.clone();\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n             Some(sudo_user) => {\n@@ -322,7 +333,7 @@ impl Build {\n         let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n \n-        Build {\n+        let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             local_rebuild: config.local_rebuild,\n@@ -352,7 +363,31 @@ impl Build {\n             ci_env: CiEnv::current(),\n             delayed_failures: RefCell::new(Vec::new()),\n             prerelease_version: Cell::new(None),\n+            tool_artifacts: Default::default(),\n+        };\n+\n+        build.verbose(\"finding compilers\");\n+        cc_detect::find(&mut build);\n+        build.verbose(\"running sanity check\");\n+        sanity::check(&mut build);\n+\n+        // If local-rust is the same major.minor as the current version, then force a\n+        // local-rebuild\n+        let local_version_verbose = output(\n+            Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n+        let local_release = local_version_verbose\n+            .lines().filter(|x| x.starts_with(\"release:\"))\n+            .next().unwrap().trim_left_matches(\"release:\").trim();\n+        let my_version = channel::CFG_RELEASE_NUM;\n+        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n+            build.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n+            build.local_rebuild = true;\n         }\n+\n+        build.verbose(\"learning about cargo\");\n+        metadata::build(&mut build);\n+\n+        build\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n@@ -371,25 +406,28 @@ impl Build {\n             return clean::clean(self, all);\n         }\n \n-        self.verbose(\"finding compilers\");\n-        cc_detect::find(self);\n-        self.verbose(\"running sanity check\");\n-        sanity::check(self);\n-        // If local-rust is the same major.minor as the current version, then force a local-rebuild\n-        let local_version_verbose = output(\n-            Command::new(&self.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n-        let local_release = local_version_verbose\n-            .lines().filter(|x| x.starts_with(\"release:\"))\n-            .next().unwrap().trim_left_matches(\"release:\").trim();\n-        let my_version = channel::CFG_RELEASE_NUM;\n-        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n-            self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n-            self.local_rebuild = true;\n+        {\n+            let builder = builder::Builder::new(&self);\n+            if let Some(path) = builder.paths.get(0) {\n+                if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n+                    return;\n+                }\n+            }\n         }\n-        self.verbose(\"learning about cargo\");\n-        metadata::build(self);\n \n-        builder::Builder::run(&self);\n+        if !self.config.dry_run {\n+            {\n+                self.config.dry_run = true;\n+                let builder = builder::Builder::new(&self);\n+                builder.execute_cli();\n+            }\n+            self.config.dry_run = false;\n+            let builder = builder::Builder::new(&self);\n+            builder.execute_cli();\n+        } else {\n+            let builder = builder::Builder::new(&self);\n+            let _ = builder.execute_cli();\n+        }\n \n         // Check for postponed failures from `test --no-fail-fast`.\n         let failures = self.delayed_failures.borrow();\n@@ -510,6 +548,11 @@ impl Build {\n         self.out.join(&*target).join(\"doc\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn compiler_doc_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"compiler-doc\")\n+    }\n+\n     /// Output directory for some generated md crate documentation for a target (temporary)\n     fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n         INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))\n@@ -575,12 +618,14 @@ impl Build {\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_silent(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run_quiet(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_suppressed(cmd)\n     }\n@@ -589,6 +634,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_silent(cmd)\n     }\n@@ -597,6 +643,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run_quiet(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_suppressed(cmd)\n     }\n@@ -605,17 +652,18 @@ impl Build {\n         self.verbosity > 0\n     }\n \n-    pub fn is_very_verbose(&self) -> bool {\n-        self.verbosity > 1\n-    }\n-\n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n         if self.is_verbose() {\n             println!(\"{}\", msg);\n         }\n     }\n \n+    fn info(&self, msg: &str) {\n+        if self.config.dry_run { return; }\n+        println!(\"{}\", msg);\n+    }\n+\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n@@ -702,6 +750,12 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns true if this is a no-std `target`, if defined\n+    fn no_std(&self, target: Interned<String>) -> Option<bool> {\n+        self.config.target_config.get(&target)\n+            .map(|t| t.no_std)\n+    }\n+\n     /// Returns whether the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n@@ -923,7 +977,7 @@ impl Build {\n     pub fn fold_output<D, F>(&self, name: F) -> Option<OutputFolder>\n         where D: Into<String>, F: FnOnce() -> D\n     {\n-        if self.ci_env == CiEnv::Travis {\n+        if !self.config.dry_run && self.ci_env == CiEnv::Travis {\n             Some(OutputFolder::new(name().into()))\n         } else {\n             None\n@@ -971,8 +1025,173 @@ impl Build {\n         }\n         ret\n     }\n+\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+        if self.config.dry_run {\n+            return Vec::new();\n+        }\n+\n+        let mut paths = Vec::new();\n+        let mut contents = Vec::new();\n+        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        // This is the method we use for extracting paths from the stamp file passed to us. See\n+        // run_cargo for more information (in compile.rs).\n+        for part in contents.split(|b| *b == 0) {\n+            if part.is_empty() {\n+                continue\n+            }\n+            let path = PathBuf::from(t!(str::from_utf8(part)));\n+            paths.push(path);\n+        }\n+        paths\n+    }\n+\n+    /// Copies a file from `src` to `dst`\n+    pub fn copy(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        let _ = fs::remove_file(&dst);\n+        // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n+        // windows), but if that fails just fall back to a slow `copy` operation.\n+        if let Ok(()) = fs::hard_link(src, dst) {\n+            return\n+        }\n+        if let Err(e) = fs::copy(src, dst) {\n+            panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n+                dst.display(), e)\n+        }\n+        let metadata = t!(src.metadata());\n+        t!(fs::set_permissions(dst, metadata.permissions()));\n+        let atime = FileTime::from_last_access_time(&metadata);\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        t!(filetime::set_file_times(dst, atime, mtime));\n+    }\n+\n+    /// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n+    /// new string for each replacement.)\n+    pub fn replace_in_file(&self, path: &Path, replacements: &[(&str, &str)]) {\n+        if self.config.dry_run { return; }\n+        let mut contents = String::new();\n+        let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n+        t!(file.read_to_string(&mut contents));\n+        for &(target, replacement) in replacements {\n+            contents = contents.replace(target, replacement);\n+        }\n+        t!(file.seek(SeekFrom::Start(0)));\n+        t!(file.set_len(0));\n+        t!(file.write_all(contents.as_bytes()));\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called.\n+    pub fn cp_r(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        for f in t!(fs::read_dir(src)) {\n+            let f = t!(f);\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            if t!(f.file_type()).is_dir() {\n+                t!(fs::create_dir_all(&dst));\n+                self.cp_r(&path, &dst);\n+            } else {\n+                let _ = fs::remove_file(&dst);\n+                self.copy(&path, &dst);\n+            }\n+        }\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called. Unwanted files or directories can be skipped\n+    /// by returning `false` from the filter function.\n+    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n+        // Immediately recurse with an empty relative path\n+        self.recurse_(src, dst, Path::new(\"\"), filter)\n+    }\n+\n+    // Inner function does the actual work\n+    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n+        for f in self.read_dir(src) {\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            let relative = relative.join(name);\n+            // Only copy file or directory if the filter function returns true\n+            if filter(&relative) {\n+                if t!(f.file_type()).is_dir() {\n+                    let _ = fs::remove_dir_all(&dst);\n+                    self.create_dir(&dst);\n+                    self.recurse_(&path, &dst, &relative, filter);\n+                } else {\n+                    let _ = fs::remove_file(&dst);\n+                    self.copy(&path, &dst);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn copy_to_folder(&self, src: &Path, dest_folder: &Path) {\n+        let file_name = src.file_name().unwrap();\n+        let dest = dest_folder.join(file_name);\n+        self.copy(src, &dest);\n+    }\n+\n+    fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n+        if self.config.dry_run { return; }\n+        let dst = dstdir.join(src.file_name().unwrap());\n+        t!(fs::create_dir_all(dstdir));\n+        drop(fs::remove_file(&dst));\n+        {\n+            let mut s = t!(fs::File::open(&src));\n+            let mut d = t!(fs::File::create(&dst));\n+            io::copy(&mut s, &mut d).expect(\"failed to copy\");\n+        }\n+        chmod(&dst, perms);\n+    }\n+\n+    fn create(&self, path: &Path, s: &str) {\n+        if self.config.dry_run { return; }\n+        t!(fs::write(path, s));\n+    }\n+\n+    fn read(&self, path: &Path) -> String {\n+        if self.config.dry_run { return String::new(); }\n+        t!(fs::read_string(path))\n+    }\n+\n+    fn create_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::create_dir_all(dir))\n+    }\n+\n+    fn remove_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::remove_dir_all(dir))\n+    }\n+\n+    fn read_dir(&self, dir: &Path) -> impl Iterator<Item=fs::DirEntry> {\n+        let iter = match fs::read_dir(dir) {\n+            Ok(v) => v,\n+            Err(_) if self.config.dry_run => return vec![].into_iter(),\n+            Err(err) => panic!(\"could not read dir {:?}: {:?}\", dir, err),\n+        };\n+        iter.map(|e| t!(e)).collect::<Vec<_>>().into_iter()\n+    }\n+\n+    fn remove(&self, f: &Path) {\n+        if self.config.dry_run { return; }\n+        fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n+    }\n }\n \n+#[cfg(unix)]\n+fn chmod(path: &Path, perms: u32) {\n+    use std::os::unix::fs::*;\n+    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n+}\n+#[cfg(windows)]\n+fn chmod(_path: &Path, _perms: u32) {}\n+\n+\n impl<'a> Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;"}, {"sha": "bcf2f6a675e02715340fcd22a0350c9d264703ef", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -85,5 +85,12 @@ check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n \t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-musl\n \n+TESTS_IN_2 := src/test/run-pass src/test/compile-fail src/test/run-pass-fulldeps\n+\n+appveyor-subset-1:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2:%=--exclude %)\n+appveyor-subset-2:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n+\n \n .PHONY: dist"}, {"sha": "db5891afd6b1fa59ac73c7c7a9590511d64299c4", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -106,8 +106,8 @@ impl Step for Llvm {\n \n         let _folder = build.fold_output(|| \"llvm\");\n         let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n-        println!(\"Building {}LLVM for {}\", descriptor, target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        let _time = util::timeit(&build);\n         t!(fs::create_dir_all(&out_dir));\n \n         // http://llvm.org/docs/CMake.html\n@@ -217,6 +217,11 @@ impl Step for Llvm {\n         //        libraries here, e.g. we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n+\n+        if builder.config.dry_run {\n+            return build_llvm_config;\n+        }\n+\n         cfg.build();\n \n         t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n@@ -230,6 +235,10 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n         return\n     }\n \n+    if build.config.dry_run {\n+        return;\n+    }\n+\n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2)\n@@ -336,6 +345,9 @@ impl Step for Lld {\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) -> PathBuf {\n+        if builder.config.dry_run {\n+            return PathBuf::from(\"lld-out-dir-test-gen\");\n+        }\n         let target = self.target;\n         let build = builder.build;\n \n@@ -351,8 +363,8 @@ impl Step for Lld {\n         }\n \n         let _folder = build.fold_output(|| \"lld\");\n-        println!(\"Building LLD for {}\", target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Building LLD for {}\", target));\n+        let _time = util::timeit(&build);\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(build.src.join(\"src/tools/lld\"));\n@@ -389,6 +401,9 @@ impl Step for TestHelpers {\n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n     fn run(self, builder: &Builder) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let build = builder.build;\n         let target = self.target;\n         let dst = build.test_helpers_out(target);\n@@ -398,7 +413,7 @@ impl Step for TestHelpers {\n         }\n \n         let _folder = build.fold_output(|| \"build_test_helpers\");\n-        println!(\"Building test helpers\");\n+        build.info(&format!(\"Building test helpers\"));\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n \n@@ -441,6 +456,9 @@ impl Step for Openssl {\n     }\n \n     fn run(self, builder: &Builder) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let build = builder.build;\n         let target = self.target;\n         let out = match build.openssl_dir(target) {\n@@ -591,11 +609,11 @@ impl Step for Openssl {\n             configure.arg(\"no-asm\");\n         }\n         configure.current_dir(&obj);\n-        println!(\"Configuring openssl for {}\", target);\n+        build.info(&format!(\"Configuring openssl for {}\", target));\n         build.run_quiet(&mut configure);\n-        println!(\"Building openssl for {}\", target);\n+        build.info(&format!(\"Building openssl for {}\", target));\n         build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n-        println!(\"Installing openssl for {}\", target);\n+        build.info(&format!(\"Installing openssl for {}\", target));\n         build.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n \n         let mut f = t!(File::create(&stamp));"}, {"sha": "1b1cec5f18c07d530795f35ee5df4d4faa8145e8", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -169,6 +169,19 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n+        if target.contains(\"-none-\") {\n+            if build.no_std(*target).is_none() {\n+                let target = build.config.target_config.entry(target.clone())\n+                    .or_insert(Default::default());\n+\n+                target.no_std = true;\n+            }\n+\n+            if build.no_std(*target) == Some(false) {\n+                panic!(\"All the *-none-* targets are no-std targets\")\n+            }\n+        }\n+\n         // Make sure musl-root is valid\n         if target.contains(\"musl\") {\n             // If this is a native target (host is also musl) and no musl-root is given,"}, {"sha": "c175d2c69016f926ff6d24cdc74e97eb408b7d67", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 100, "deletions": 71, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -109,11 +109,11 @@ impl Step for Linkcheck {\n         let build = builder.build;\n         let host = self.host;\n \n-        println!(\"Linkcheck ({})\", host);\n+        build.info(&format!(\"Linkcheck ({})\", host));\n \n         builder.default_doc(None);\n \n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         try_run(build, builder.tool_cmd(Tool::Linkchecker)\n                               .arg(build.out.join(host).join(\"doc\")));\n     }\n@@ -164,7 +164,7 @@ impl Step for Cargotest {\n         let out_dir = build.out.join(\"ct\");\n         t!(fs::create_dir_all(&out_dir));\n \n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n@@ -245,7 +245,7 @@ impl Step for Rls {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        builder.ensure(tool::Rls { compiler, target: self.host });\n+        builder.ensure(tool::Rls { compiler, target: self.host, extra_features: Vec::new() });\n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n                                                  host,\n@@ -291,7 +291,7 @@ impl Step for Rustfmt {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n+        builder.ensure(tool::Rustfmt { compiler, target: self.host, extra_features: Vec::new() });\n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n                                                  host,\n@@ -339,7 +339,12 @@ impl Step for Miri {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+        let miri = builder.ensure(tool::Miri {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let Some(miri) = miri {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n             cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n \n@@ -391,7 +396,12 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+        let clippy = builder.ensure(tool::Clippy {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let Some(clippy) = clippy {\n             let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n             cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n@@ -499,33 +509,27 @@ impl Step for RustdocJS {\n             });\n             builder.run(&mut command);\n         } else {\n-            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n+            builder.info(&format!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"));\n         }\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Tidy {\n-    host: Interned<String>,\n-}\n+pub struct Tidy;\n \n impl Step for Tidy {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n-    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n+    /// Runs the `tidy` tool.\n     ///\n     /// This tool in `src/tools` checks up on various bits and pieces of style and\n     /// otherwise just implements a few lint-like checks that are specific to the\n     /// compiler itself.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let host = self.host;\n \n-        let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check ({})\", host);\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(&build.initial_cargo);\n@@ -535,6 +539,9 @@ impl Step for Tidy {\n         if build.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n+\n+        let _folder = build.fold_output(|| \"tidy\");\n+        builder.info(&format!(\"tidy check\"));\n         try_run(build, &mut cmd);\n     }\n \n@@ -543,9 +550,7 @@ impl Step for Tidy {\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Tidy {\n-            host: run.builder.build.build,\n-        });\n+        run.builder.ensure(Tidy);\n     }\n }\n \n@@ -755,12 +760,18 @@ test!(RunFailFullDepsPretty {\n     host: true\n });\n \n-host_test!(RunMake {\n+default_test!(RunMake {\n     path: \"src/test/run-make\",\n     mode: \"run-make\",\n     suite: \"run-make\"\n });\n \n+host_test!(RunMakeFullDeps {\n+    path: \"src/test/run-make-fulldeps\",\n+    mode: \"run-make\",\n+    suite: \"run-make-fulldeps\"\n+});\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n@@ -823,18 +834,14 @@ impl Step for Compiletest {\n             // FIXME: Does pretty need librustc compiled? Note that there are\n             // fulldeps test suites with mode = pretty as well.\n             mode == \"pretty\" ||\n-            mode == \"rustdoc\" ||\n-            mode == \"run-make\" {\n+            mode == \"rustdoc\" {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n         builder.ensure(compile::Test { compiler, target });\n         builder.ensure(native::TestHelpers { target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n         let mut cmd = builder.tool_cmd(Tool::Compiletest);\n \n         // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -845,7 +852,7 @@ impl Step for Compiletest {\n         cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n \n         // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" || mode == \"run-make\" {\n+        if mode == \"rustdoc\" || (mode == \"run-make\" && suite.ends_with(\"fulldeps\")) {\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n         }\n \n@@ -919,15 +926,17 @@ impl Step for Compiletest {\n                 target: build.config.build,\n                 emscripten: false,\n             });\n-            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-            cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            if !build.config.dry_run {\n+                let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            }\n             if !build.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n-            if suite == \"run-make\" {\n+            if !build.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n                 cmd.arg(\"--cc\").arg(build.cc(target))\n@@ -940,12 +949,13 @@ impl Step for Compiletest {\n                 }\n             }\n         }\n-        if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n+        if suite == \"run-make-fulldeps\" && !build.config.llvm_enabled {\n+            builder.info(\n+                &format!(\"Ignoring run-make test suite as they generally don't work without LLVM\"));\n             return;\n         }\n \n-        if suite != \"run-make\" {\n+        if suite != \"run-make-fulldeps\" {\n             cmd.arg(\"--cc\").arg(\"\")\n                .arg(\"--cxx\").arg(\"\")\n                .arg(\"--cflags\").arg(\"\")\n@@ -994,7 +1004,10 @@ impl Step for Compiletest {\n \n         build.ci_env.force_coloring_in_ci(&mut cmd);\n \n-        let _time = util::timeit();\n+        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        builder.info(&format!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, &compiler.host, target));\n+        let _time = util::timeit(&build);\n         try_run(build, &mut cmd);\n     }\n }\n@@ -1029,9 +1042,10 @@ impl Step for DocTest {\n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n         let mut stack = vec![build.src.join(self.path)];\n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n \n+        let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n                 stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n@@ -1048,7 +1062,13 @@ impl Step for DocTest {\n                 continue;\n             }\n \n-            let test_result = markdown_test(builder, compiler, &p);\n+            files.push(p);\n+        }\n+\n+        files.sort();\n+\n+        for file in files {\n+            let test_result = markdown_test(builder, compiler, &file);\n             if self.is_ext_doc {\n                 let toolstate = if test_result {\n                     ToolState::TestPass\n@@ -1138,34 +1158,39 @@ impl Step for ErrorIndex {\n \n         builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-\n         let dir = testdir(build, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n-        let _time = util::timeit();\n-        build.run(builder.tool_cmd(Tool::ErrorIndex)\n-                    .arg(\"markdown\")\n-                    .arg(&output)\n-                    .env(\"CFG_BUILD\", &build.build)\n-                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n+        let mut tool = builder.tool_cmd(Tool::ErrorIndex);\n+        tool.arg(\"markdown\")\n+            .arg(&output)\n+            .env(\"CFG_BUILD\", &build.build)\n+            .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir());\n+\n \n+        let _folder = build.fold_output(|| \"test_error_index\");\n+        build.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        let _time = util::timeit(&build);\n+        build.run(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n \n fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n     let build = builder.build;\n-    let mut file = t!(File::open(markdown));\n-    let mut contents = String::new();\n-    t!(file.read_to_string(&mut contents));\n-    if !contents.contains(\"```\") {\n-        return true;\n+    match File::open(markdown) {\n+        Ok(mut file) => {\n+            let mut contents = String::new();\n+            t!(file.read_to_string(&mut contents));\n+            if !contents.contains(\"```\") {\n+                return true;\n+            }\n+        }\n+        Err(_) => {},\n     }\n \n-    println!(\"doc tests for: {}\", markdown.display());\n+    build.info(&format!(\"doc tests for: {}\", markdown.display()));\n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n@@ -1396,11 +1421,6 @@ impl Step for Crate {\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n-        });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n-                &compiler.host, target);\n \n         // Build up the base `cargo test` command.\n         //\n@@ -1432,8 +1452,6 @@ impl Step for Crate {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _time = util::timeit();\n-\n         if target.contains(\"emscripten\") {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n                       build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n@@ -1442,8 +1460,8 @@ impl Step for Crate {\n             // The javascript shim implements the syscall interface so that test\n             // output can be correctly reported.\n             if !build.config.wasm_syscall {\n-                println!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n-                          test output may not be visible.\");\n+                build.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n+                          test output may not be visible.\"));\n             }\n \n             // On the wasm32-unknown-unknown target we're using LTO which is\n@@ -1461,6 +1479,13 @@ impl Step for Crate {\n                       format!(\"{} run\",\n                               builder.tool_exe(Tool::RemoteTestClient).display()));\n         }\n+\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n+        });\n+        build.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n+                &compiler.host, target));\n+        let _time = util::timeit(&build);\n         try_run(build, &mut cargo);\n     }\n }\n@@ -1509,12 +1534,6 @@ impl Step for CrateRustdoc {\n                                                  target,\n                                                  test_kind.subcommand(),\n                                                  \"src/tools/rustdoc\");\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-\n         if test_kind.subcommand() == \"test\" && !build.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -1528,7 +1547,12 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _time = util::timeit();\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        });\n+        build.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target));\n+        let _time = util::timeit(&build);\n \n         try_run(build, &mut cargo);\n     }\n@@ -1575,7 +1599,7 @@ impl Step for RemoteCopyLibs {\n \n         builder.ensure(compile::Test { compiler, target });\n \n-        println!(\"REMOTE copy libs to emulator ({})\", target);\n+        build.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n         let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n@@ -1610,7 +1634,6 @@ pub struct Distcheck;\n \n impl Step for Distcheck {\n     type Output = ();\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"distcheck\")\n@@ -1624,7 +1647,7 @@ impl Step for Distcheck {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        println!(\"Distcheck\");\n+        build.info(&format!(\"Distcheck\"));\n         let dir = build.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n@@ -1648,7 +1671,7 @@ impl Step for Distcheck {\n                          .current_dir(&dir));\n \n         // Now make sure that rust-src has all of libstd's dependencies\n-        println!(\"Distcheck rust-src\");\n+        build.info(&format!(\"Distcheck rust-src\"));\n         let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n@@ -1676,17 +1699,23 @@ impl Step for Bootstrap {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     /// Test the build system itself\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let mut cmd = Command::new(&build.initial_cargo);\n         cmd.arg(\"test\")\n            .current_dir(build.src.join(\"src/bootstrap\"))\n+           .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n            .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n            .env(\"RUSTC\", &build.initial_rustc);\n+        if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n+            // Use the same rustc flags for testing as for \"normal\" compilation,\n+            // so that Cargo doesn\u2019t recompile the entire dependency graph every time:\n+            // https://github.com/rust-lang/rust/issues/49215\n+            cmd.env(\"RUSTFLAGS\", flags);\n+        }\n         if !build.fail_fast {\n             cmd.arg(\"--no-fail-fast\");\n         }"}, {"sha": "93b6153fcb2f8c58c2758f3a6284e54e5867df83", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 108, "deletions": 12, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,11 +12,12 @@ use std::fs;\n use std::env;\n use std::path::PathBuf;\n use std::process::{Command, exit};\n+use std::slice::SliceConcatExt;\n \n use Mode;\n use Compiler;\n use builder::{Step, RunConfig, ShouldRun, Builder};\n-use util::{copy, exe, add_lib_path};\n+use util::{exe, add_lib_path};\n use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp};\n use native;\n use channel::GitInfo;\n@@ -74,14 +75,15 @@ impl Step for CleanTools {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n struct ToolBuild {\n     compiler: Compiler,\n     target: Interned<String>,\n     tool: &'static str,\n     path: &'static str,\n     mode: Mode,\n     is_ext_tool: bool,\n+    extra_features: Vec<String>,\n }\n \n impl Step for ToolBuild {\n@@ -110,11 +112,85 @@ impl Step for ToolBuild {\n             Mode::Tool => panic!(\"unexpected Mode::Tool for tool build\")\n         }\n \n+        let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n+        cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n+\n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n-        println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n+        build.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n+        let mut duplicates = Vec::new();\n+        let is_expected = compile::stream_cargo(build, &mut cargo, &mut |msg| {\n+            // Only care about big things like the RLS/Cargo for now\n+            if tool != \"rls\" && tool != \"cargo\" {\n+                return\n+            }\n+            let (id, features, filenames) = match msg {\n+                compile::CargoMessage::CompilerArtifact {\n+                    package_id,\n+                    features,\n+                    filenames\n+                } => {\n+                    (package_id, features, filenames)\n+                }\n+                _ => return,\n+            };\n+            let features = features.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n+\n+            for path in filenames {\n+                let val = (tool, PathBuf::from(&*path), features.clone());\n+                // we're only interested in deduplicating rlibs for now\n+                if val.1.extension().and_then(|s| s.to_str()) != Some(\"rlib\") {\n+                    continue\n+                }\n+\n+                // Don't worry about libs that turn out to be host dependencies\n+                // or build scripts, we only care about target dependencies that\n+                // are in `deps`.\n+                if let Some(maybe_target) = val.1\n+                    .parent()                   // chop off file name\n+                    .and_then(|p| p.parent())   // chop off `deps`\n+                    .and_then(|p| p.parent())   // chop off `release`\n+                    .and_then(|p| p.file_name())\n+                    .and_then(|p| p.to_str())\n+                {\n+                    if maybe_target != &*target {\n+                        continue\n+                    }\n+                }\n+\n+                let mut artifacts = build.tool_artifacts.borrow_mut();\n+                let prev_artifacts = artifacts\n+                    .entry(target)\n+                    .or_insert_with(Default::default);\n+                if let Some(prev) = prev_artifacts.get(&*id) {\n+                    if prev.1 != val.1 {\n+                        duplicates.push((\n+                            id.to_string(),\n+                            val,\n+                            prev.clone(),\n+                        ));\n+                    }\n+                    return\n+                }\n+                prev_artifacts.insert(id.to_string(), val);\n+            }\n+        });\n+\n+        if is_expected && duplicates.len() != 0 {\n+            println!(\"duplicate artfacts found when compiling a tool, this \\\n+                      typically means that something was recompiled because \\\n+                      a transitive dependency has different features activated \\\n+                      than in a previous build:\\n\");\n+            for (id, cur, prev) in duplicates {\n+                println!(\"  {}\", id);\n+                println!(\"    `{}` enabled features {:?} at {:?}\",\n+                         cur.0, cur.2, cur.1);\n+                println!(\"    `{}` enabled features {:?} at {:?}\",\n+                         prev.0, prev.2, prev.1);\n+            }\n+            println!(\"\");\n+            panic!(\"tools should not compile multiple copies of the same crate\");\n+        }\n \n-        let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n-        let is_expected = build.try_run(&mut cargo);\n         build.save_toolstate(tool, if is_expected {\n             ToolState::TestFail\n         } else {\n@@ -131,7 +207,7 @@ impl Step for ToolBuild {\n             let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n                 .join(exe(tool, &compiler.host));\n             let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-            copy(&cargo_out, &bin);\n+            build.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n     }\n@@ -242,6 +318,7 @@ macro_rules! tool {\n                     mode: $mode,\n                     path: $path,\n                     is_ext_tool: false,\n+                    extra_features: Vec::new(),\n                 }).expect(\"expected to build -- essential tool\")\n             }\n         }\n@@ -291,6 +368,7 @@ impl Step for RemoteTestServer {\n             mode: Mode::Libstd,\n             path: \"src/tools/remote-test-server\",\n             is_ext_tool: false,\n+            extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n }\n@@ -333,9 +411,10 @@ impl Step for Rustdoc {\n         };\n \n         builder.ensure(compile::Rustc { compiler: build_compiler, target });\n-\n-        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n-        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n+        builder.ensure(compile::Rustc {\n+            compiler: build_compiler,\n+            target: builder.build.build,\n+        });\n \n         let mut cargo = prepare_tool_cargo(builder,\n                                            build_compiler,\n@@ -347,7 +426,11 @@ impl Step for Rustdoc {\n         cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n \n+        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        build.info(&format!(\"Building rustdoc for stage{} ({})\",\n+            target_compiler.stage, target_compiler.host));\n         build.run(&mut cargo);\n+\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name.\n@@ -361,7 +444,7 @@ impl Step for Rustdoc {\n             t!(fs::create_dir_all(&bindir));\n             let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n-            copy(&tool_rustdoc, &bin_rustdoc);\n+            build.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n         } else {\n             tool_rustdoc\n@@ -409,6 +492,7 @@ impl Step for Cargo {\n             mode: Mode::Librustc,\n             path: \"src/tools/cargo\",\n             is_ext_tool: false,\n+            extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n }\n@@ -421,10 +505,11 @@ macro_rules! tool_extended {\n        $tool_name:expr,\n        $extra_deps:block;)+) => {\n         $(\n-            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+            #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n             pub target: Interned<String>,\n+            pub extra_features: Vec<String>,\n         }\n \n         impl Step for $name {\n@@ -441,17 +526,20 @@ macro_rules! tool_extended {\n                 run.builder.ensure($name {\n                     compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n                     target: run.target,\n+                    extra_features: Vec::new(),\n                 });\n             }\n \n-            fn run($sel, $builder: &Builder) -> Option<PathBuf> {\n+            #[allow(unused_mut)]\n+            fn run(mut $sel, $builder: &Builder) -> Option<PathBuf> {\n                 $extra_deps\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n                     tool: $tool_name,\n                     mode: Mode::Librustc,\n                     path: $path,\n+                    extra_features: $sel.extra_features,\n                     is_ext_tool: true,\n                 })\n             }\n@@ -472,6 +560,14 @@ tool_extended!((self, builder),\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n+        let clippy = builder.ensure(Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+            extra_features: Vec::new(),\n+        });\n+        if clippy.is_some() {\n+            self.extra_features.push(\"clippy\".to_owned());\n+        }\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });"}, {"sha": "f8c7032369890b8472a66083dee9ae9b467d6abe", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 20, "deletions": 109, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -15,13 +15,14 @@\n \n use std::env;\n use std::str;\n-use std::fs::{self, File, OpenOptions};\n-use std::io::{self, Read, Write, Seek, SeekFrom};\n+use std::fs;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n-use filetime::{self, FileTime};\n+use config::Config;\n+use Build;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n@@ -32,102 +33,6 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`\n-pub fn copy(src: &Path, dst: &Path) {\n-    let _ = fs::remove_file(&dst);\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    if let Ok(()) = fs::hard_link(src, dst) {\n-        return\n-    }\n-    if let Err(e) = fs::copy(src, dst) {\n-        panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-               dst.display(), e)\n-    }\n-    let metadata = t!(src.metadata());\n-    t!(fs::set_permissions(dst, metadata.permissions()));\n-    let atime = FileTime::from_last_access_time(&metadata);\n-    let mtime = FileTime::from_last_modification_time(&metadata);\n-    t!(filetime::set_file_times(dst, atime, mtime));\n-}\n-\n-/// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n-/// new string for each replacement.)\n-pub fn replace_in_file(path: &Path, replacements: &[(&str, &str)]) {\n-    let mut contents = String::new();\n-    let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n-    t!(file.read_to_string(&mut contents));\n-    for &(target, replacement) in replacements {\n-        contents = contents.replace(target, replacement);\n-    }\n-    t!(file.seek(SeekFrom::Start(0)));\n-    t!(file.set_len(0));\n-    t!(file.write_all(contents.as_bytes()));\n-}\n-\n-pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n-    let mut paths = Vec::new();\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in compile.rs).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = PathBuf::from(t!(str::from_utf8(part)));\n-        paths.push(path);\n-    }\n-    paths\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called.\n-pub fn cp_r(src: &Path, dst: &Path) {\n-    for f in t!(fs::read_dir(src)) {\n-        let f = t!(f);\n-        let path = f.path();\n-        let name = path.file_name().unwrap();\n-        let dst = dst.join(name);\n-        if t!(f.file_type()).is_dir() {\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&path, &dst);\n-        } else {\n-            let _ = fs::remove_file(&dst);\n-            copy(&path, &dst);\n-        }\n-    }\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called. Unwanted files or directories can be skipped\n-/// by returning `false` from the filter function.\n-pub fn cp_filtered(src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n-    // Inner function does the actual work\n-    fn recurse(src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n-            let path = f.path();\n-            let name = path.file_name().unwrap();\n-            let dst = dst.join(name);\n-            let relative = relative.join(name);\n-            // Only copy file or directory if the filter function returns true\n-            if filter(&relative) {\n-                if t!(f.file_type()).is_dir() {\n-                    let _ = fs::remove_dir_all(&dst);\n-                    t!(fs::create_dir(&dst));\n-                    recurse(&path, &dst, &relative, filter);\n-                } else {\n-                    let _ = fs::remove_file(&dst);\n-                    copy(&path, &dst);\n-                }\n-            }\n-        }\n-    }\n-    // Immediately recurse with an empty relative path\n-    recurse(src, dst, Path::new(\"\"), filter)\n-}\n-\n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {\n@@ -196,25 +101,28 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n     buf\n }\n \n-pub struct TimeIt(Instant);\n+pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit() -> TimeIt {\n-    TimeIt(Instant::now())\n+pub fn timeit(build: &Build) -> TimeIt {\n+    TimeIt(build.config.dry_run, Instant::now())\n }\n \n impl Drop for TimeIt {\n     fn drop(&mut self) {\n-        let time = self.0.elapsed();\n-        println!(\"\\tfinished in {}.{:03}\",\n-                 time.as_secs(),\n-                 time.subsec_nanos() / 1_000_000);\n+        let time = self.1.elapsed();\n+        if !self.0 {\n+            println!(\"\\tfinished in {}.{:03}\",\n+                    time.as_secs(),\n+                    time.subsec_nanos() / 1_000_000);\n+        }\n     }\n }\n \n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n-pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n+pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n+    if config.dry_run { return Ok(()); }\n     let _ = fs::remove_dir(dest);\n     return symlink_dir_inner(src, dest);\n \n@@ -288,6 +196,7 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                nOutBufferSize: DWORD,\n                                lpBytesReturned: LPDWORD,\n                                lpOverlapped: LPOVERLAPPED) -> BOOL;\n+            fn CloseHandle(hObject: HANDLE) -> BOOL;\n         }\n \n         fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n@@ -341,11 +250,13 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                       &mut ret,\n                                       ptr::null_mut());\n \n-            if res == 0 {\n+            let out = if res == 0 {\n                 Err(io::Error::last_os_error())\n             } else {\n                 Ok(())\n-            }\n+            };\n+            CloseHandle(h);\n+            out\n         }\n     }\n }"}, {"sha": "01d704f816bbc8fc00813d2636f3fe44a847db35", "filename": "src/build_helper/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -6,6 +6,3 @@ authors = [\"The Rust Project Developers\"]\n [lib]\n name = \"build_helper\"\n path = \"lib.rs\"\n-\n-[dependencies]\n-filetime = \"0.1\""}, {"sha": "5a12afd03e13b820c891aec362d9b6f3c5683f70", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -10,14 +10,11 @@\n \n #![deny(warnings)]\n \n-extern crate filetime;\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::{fs, env};\n-\n-use filetime::FileTime;\n+use std::time::{SystemTime, UNIX_EPOCH};\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -137,10 +134,8 @@ pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n }\n \n /// Returns the last-modified time for `path`, or zero if it doesn't exist.\n-pub fn mtime(path: &Path) -> FileTime {\n-    fs::metadata(path).map(|f| {\n-        FileTime::from_last_modification_time(&f)\n-    }).unwrap_or(FileTime::zero())\n+pub fn mtime(path: &Path) -> SystemTime {\n+    fs::metadata(path).and_then(|f| f.modified()).unwrap_or(UNIX_EPOCH)\n }\n \n /// Returns whether `dst` is up to date given that the file or files in `src`\n@@ -157,9 +152,9 @@ pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n         Err(e) => panic!(\"source {:?} failed to get metadata: {}\", src, e),\n     };\n     if meta.is_dir() {\n-        dir_up_to_date(src, &threshold)\n+        dir_up_to_date(src, threshold)\n     } else {\n-        FileTime::from_last_modification_time(&meta) <= threshold\n+        meta.modified().unwrap_or(UNIX_EPOCH) <= threshold\n     }\n }\n \n@@ -226,13 +221,13 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str) -> Result<NativeLibBoiler\n                            search_path)\n }\n \n-fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n+fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {\n     t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n         let meta = t!(e.metadata());\n         if meta.is_dir() {\n             dir_up_to_date(&e.path(), threshold)\n         } else {\n-            FileTime::from_last_modification_time(&meta) < *threshold\n+            meta.modified().unwrap_or(UNIX_EPOCH) < threshold\n         }\n     })\n }"}, {"sha": "cb85cf3d9e9f094f87ba6617250e55ef68a7fd42", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -29,6 +29,11 @@ ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=asmjs-unknown-emscripten\n \n-ENV RUST_CONFIGURE_ARGS --enable-emscripten\n+ENV RUST_CONFIGURE_ARGS --enable-emscripten --disable-optimize-tests\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n+  src/test/run-pass \\\n+  src/test/run-fail \\\n+  src/libstd \\\n+  src/liballoc \\\n+  src/libcore"}, {"sha": "cddfa557f6aed7e43ac04c326cfe6509417e0c0d", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -32,5 +32,5 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=aarch64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e00c23dac89b087dd66edbec4e1ff6db704cb9fd", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -26,7 +26,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --i686-linux-android-ndk=/android/ndk/x86-14 \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n-      --x86_64-linux-android-ndk=/android/ndk/x86_64-21\n+      --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n+      --disable-docs\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n "}, {"sha": "6ddc5c1e04ae35223c38a6002ac6ef996f23a3e0", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e4d4b2feeec40270c84f97b3277bfc4dfd6bb911", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "99fe7bd7b8f7871fc5aa607f00ec2fb2103bfcb5", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -32,5 +32,5 @@ ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=armv7-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e12bed3abc5ad05dc401cb4d773cdb922bb32aac", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -32,7 +32,8 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-i586=/musl-i586 \\\n       --musl-root-i686=/musl-i686 \\\n-      --enable-extended\n+      --enable-extended \\\n+      --disable-docs\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our"}, {"sha": "6f6a663a3309387abf8ec5785f5f1df2f7687aa3", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=i686-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "08020e533ff191ca565868062cef8f7d5ab55967", "filename": "src/ci/docker/dist-i686-linux/build-gcc.sh", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -17,6 +17,23 @@ GCC=4.8.5\n \n curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n cd gcc-$GCC\n+\n+# FIXME(#49246): Remove the `sed` below.\n+#\n+# On 2018 March 21st, two Travis builders' cache for Docker are suddenly invalidated. Normally this\n+# is fine, because we just need to rebuild the Docker image. However, it reveals a network issue:\n+# downloading from `ftp://gcc.gnu.org/` from Travis (using passive mode) often leads to \"Connection\n+# timed out\" error, and even when the download completed, the file is usually corrupted. This causes\n+# nothing to be landed that day.\n+#\n+# We observed that the `gcc-4.8.5.tar.bz2` above can be downloaded successfully, so as a stability\n+# improvement we try to download from the HTTPS mirror instead. Turns out this uncovered the third\n+# bug: the host `gcc.gnu.org` and `cygwin.com` share the same IP, and the TLS certificate of the\n+# latter host is presented to `wget`! Therefore, we choose to download from the insecure HTTP server\n+# instead here.\n+#\n+sed -i'' 's|ftp://gcc\\.gnu\\.org/|http://gcc.gnu.org/|g' ./contrib/download_prerequisites\n+\n ./contrib/download_prerequisites\n mkdir ../gcc-build\n cd ../gcc-build"}, {"sha": "aa31f50ba0343134bfbece006ad3faf6c13afc72", "filename": "src/ci/docker/dist-i686-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,7 +12,7 @@\n set -ex\n source shared.sh\n \n-curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n+curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n \n cd git-2.10.0\n make configure"}, {"sha": "466def1f80fbfd9cbdbf6d86d5e4d98630f1bd1e", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "2205b733e99f1e5826fa92656fa68a94c509e30e", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f1d9dad46ea3f6dd58be2443f5caef48940cd3f6", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ee73e29c76e35926ee5389ecf998f47a29ce4c1a", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mipsel-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f03aff060c1034065c5361930ac2fdf917129320", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -34,7 +34,7 @@ ENV \\\n \n ENV HOSTS=powerpc-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # FIXME(#36150) this will fail the bootstrap. Probably means something bad is"}, {"sha": "bb30210c0563aa5433672b744fab108100aa4f1f", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -35,5 +35,5 @@ ENV \\\n \n ENV HOSTS=powerpc64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ee9e4550483525ada46d587e492b623b07129d6b", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -32,5 +32,5 @@ ENV \\\n \n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "7ba6fe643c2ae80b9f59bdcdf4197db18fa3c736", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -34,5 +34,5 @@ ENV \\\n \n ENV HOSTS=s390x-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "00366301aa17aba600cb8c4f112a220124daab0c", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -20,7 +20,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   bzip2 \\\n   patch \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  gcc-arm-none-eabi \\\n+  libnewlib-arm-none-eabi\n \n WORKDIR /build\n \n@@ -66,6 +68,14 @@ RUN env \\\n     bash musl.sh mipsel && \\\n     rm -rf /build/*\n \n+# FIXME(mozilla/sccache#235) this shouldn't be necessary but is currently\n+# necessary to disambiguate the mips compiler with the mipsel compiler. We want\n+# to give these two wrapper scripts (currently identical ones) different hashes\n+# to ensure that sccache understands that they're different compilers.\n+RUN \\\n+  echo \"# a\" >> /usr/local/mips-linux-musl/bin/mips-openwrt-linux-musl-wrapper.sh && \\\n+  echo \"# b\" >> /usr/local/mipsel-linux-musl/bin/mipsel-openwrt-linux-musl-wrapper.sh\n+\n ENV TARGETS=asmjs-unknown-emscripten\n ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n@@ -78,6 +88,10 @@ ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n \n # FIXME: remove armv5te vars after https://github.com/alexcrichton/cc-rs/issues/271\n #        get fixed and cc update\n@@ -95,7 +109,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\\n-      --enable-emscripten\n+      --enable-emscripten \\\n+      --disable-docs\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n "}, {"sha": "e8d6c12de4474284c529a8852863c81eb9ff317f", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -55,5 +55,5 @@ ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "698b81a92e935464724259a1e9b659c802351316", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "28c97e8c6dbf9b70987ca9b64c5c49d272add3ea", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -84,7 +84,8 @@ ENV HOSTS=x86_64-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler\n+      --enable-profiler \\\n+      --enable-compiler-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "08020e533ff191ca565868062cef8f7d5ab55967", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -17,6 +17,23 @@ GCC=4.8.5\n \n curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n cd gcc-$GCC\n+\n+# FIXME(#49246): Remove the `sed` below.\n+#\n+# On 2018 March 21st, two Travis builders' cache for Docker are suddenly invalidated. Normally this\n+# is fine, because we just need to rebuild the Docker image. However, it reveals a network issue:\n+# downloading from `ftp://gcc.gnu.org/` from Travis (using passive mode) often leads to \"Connection\n+# timed out\" error, and even when the download completed, the file is usually corrupted. This causes\n+# nothing to be landed that day.\n+#\n+# We observed that the `gcc-4.8.5.tar.bz2` above can be downloaded successfully, so as a stability\n+# improvement we try to download from the HTTPS mirror instead. Turns out this uncovered the third\n+# bug: the host `gcc.gnu.org` and `cygwin.com` share the same IP, and the TLS certificate of the\n+# latter host is presented to `wget`! Therefore, we choose to download from the insecure HTTP server\n+# instead here.\n+#\n+sed -i'' 's|ftp://gcc\\.gnu\\.org/|http://gcc.gnu.org/|g' ./contrib/download_prerequisites\n+\n ./contrib/download_prerequisites\n mkdir ../gcc-build\n cd ../gcc-build"}, {"sha": "aa31f50ba0343134bfbece006ad3faf6c13afc72", "filename": "src/ci/docker/dist-x86_64-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,7 +12,7 @@\n set -ex\n source shared.sh\n \n-curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n+curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n \n cd git-2.10.0\n make configure"}, {"sha": "06f8a2fbba836de9843927eb40b2392eb704cb0a", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -31,7 +31,8 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/musl-x86_64 \\\n-      --enable-extended\n+      --enable-extended \\\n+      --disable-docs\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our"}, {"sha": "a17a7ebc03dd165f92b588d2bf802d3b5d7ec754", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -33,5 +33,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-netbsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ea2387b67dbccf9379b5c017e383ef6f61b9c296", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -27,6 +27,21 @@ travis_fold start build_docker\n travis_time_start\n \n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      cksum=$(find $docker_dir/$image $docker_dir/scripts -type f | \\\n+        sort | \\\n+        xargs cat | \\\n+        sha512sum | \\\n+        awk '{print $1}')\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n+      echo \"Attempting to download $s3url\"\n+      set +e\n+      loaded_images=$(curl $url | docker load | sed 's/.* sha/sha/')\n+      set -e\n+      echo \"Downloaded containers:\\n$loaded_images\"\n+    fi\n+\n     dockerfile=\"$docker_dir/$image/Dockerfile\"\n     if [ -x /usr/bin/cygpath ]; then\n         context=\"`cygpath -w $docker_dir`\"\n@@ -40,6 +55,23 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -t rust-ci \\\n       -f \"$dockerfile\" \\\n       \"$context\"\n+\n+    if [ \"$s3url\" != \"\" ]; then\n+      digest=$(docker inspect rust-ci --format '{{.Id}}')\n+      echo \"Built container $digest\"\n+      if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then\n+        echo \"Uploading finished image to $s3url\"\n+        set +e\n+        docker history -q rust-ci | \\\n+          grep -v missing | \\\n+          xargs docker save | \\\n+          gzip | \\\n+          aws s3 cp - $s3url\n+        set -e\n+      else\n+        echo \"Looks like docker image is the same as before, not uploading\"\n+      fi\n+    fi\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n         echo Cannot run disabled images on travis!\n@@ -72,8 +104,6 @@ if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n     args=\"$args --env SCCACHE_REGION\"\n     args=\"$args --env AWS_ACCESS_KEY_ID\"\n     args=\"$args --env AWS_SECRET_ACCESS_KEY\"\n-    args=\"$args --env SCCACHE_ERROR_LOG=/tmp/sccache/sccache.log\"\n-    args=\"$args --volume $objdir/tmp:/tmp/sccache\"\n else\n     mkdir -p $HOME/.cache/sccache\n     args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\""}, {"sha": "da52d08318115eb80a7cc39bb3ffde8e8439dad3", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -13,6 +13,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl\n+  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "6c0ec1ad9d4e14879bf787dd3823a5a36d503539", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -26,6 +26,7 @@ ENV RUST_CONFIGURE_ARGS \\\n   --set rust.lld\n \n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n+  src/test/run-make \\\n   src/test/ui \\\n   src/test/run-pass \\\n   src/test/compile-fail \\"}, {"sha": "ff6ab1013b4c22352c7ef29673099d5ca2755663", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -16,6 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+ENV PARALLEL_CHECK 1\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "7304ed6015cc9042f5e552df3244d45f105d932e", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,22 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUSTFLAGS -Zincremental=/tmp/rust-incr-cache\n-ENV RUST_CHECK_TARGET check\n-ENV CARGO_INCREMENTAL 0"}, {"sha": "f2664e6d196c7afcab810ab0ee15f5e30b14eb64", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -17,6 +17,7 @@ ci_dir=$(cd $(dirname $0) && pwd)\n . \"$ci_dir/shared.sh\"\n \n travis_fold start init_repo\n+travis_time_start\n \n REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n@@ -42,54 +43,39 @@ if grep -q RUST_RELEASE_CHANNEL=beta src/ci/run.sh; then\n   git fetch origin --unshallow beta master\n fi\n \n-travis_fold start update_cache\n-travis_time_start\n-\n-# Update the cache (a pristine copy of the rust source master)\n-retry sh -c \"rm -rf $cache_src_dir && mkdir -p $cache_src_dir && \\\n-    git clone --depth 1 https://github.com/rust-lang/rust.git $cache_src_dir\"\n-if [ -d $cache_src_dir/src/llvm ]; then\n-  (cd $cache_src_dir && git rm src/llvm)\n-fi\n-if [ -d $cache_src_dir/src/llvm-emscripten ]; then\n-  (cd $cache_src_dir && git rm src/llvm-emscripten)\n-fi\n-retry sh -c \"cd $cache_src_dir && \\\n-    git submodule deinit -f . && git submodule sync && git submodule update --init\"\n-\n-travis_fold end update_cache\n-travis_time_finish\n+function fetch_submodule {\n+    local module=$1\n+    local cached=\"download-${module//\\//-}.tar.gz\"\n+    retry sh -c \"rm -f $cached && \\\n+        curl -sSL -o $cached $2\"\n+    mkdir $module\n+    touch \"$module/.git\"\n+    tar -C $module --strip-components=1 -xf $cached\n+    rm $cached\n+}\n \n-travis_fold start update_submodules\n-travis_time_start\n-\n-# Update the submodules of the repo we're in, using the pristine repo as\n-# a cache for any object files\n-# No, `git submodule foreach` won't work:\n-# http://stackoverflow.com/questions/12641469/list-submodules-in-a-git-repository\n+included=\"src/llvm src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n-for module in $modules; do\n-    if [ \"$module\" = src/llvm ] || [ \"$module\" = src/llvm-emscripten ]; then\n+modules=($modules)\n+use_git=\"\"\n+urls=\"$(git config --file .gitmodules --get-regexp '\\.url$' | cut -d' ' -f2)\"\n+urls=($urls)\n+for i in ${!modules[@]}; do\n+    module=${modules[$i]}\n+    if [[ \" $included \" = *\" $module \"* ]]; then\n         commit=\"$(git ls-tree HEAD $module | awk '{print $3}')\"\n         git rm $module\n-        retry sh -c \"rm -f $commit.tar.gz && \\\n-            curl -sSL -O https://github.com/rust-lang/llvm/archive/$commit.tar.gz\"\n-        tar -C src/ -xf \"$commit.tar.gz\"\n-        rm \"$commit.tar.gz\"\n-        mv \"src/llvm-$commit\" $module\n-        continue\n-    fi\n-    if [ ! -e \"$cache_src_dir/$module/.git\" ]; then\n-        echo \"WARNING: $module not found in pristine repo\"\n-        retry sh -c \"git submodule deinit -f $module && \\\n-            git submodule update --init --recursive $module\"\n+        url=${urls[$i]}\n+        url=${url/\\.git/}\n+        fetch_submodule $module \"$url/archive/$commit.tar.gz\" &\n         continue\n+    else\n+        use_git=\"$use_git $module\"\n     fi\n-    retry sh -c \"git submodule deinit -f $module && \\\n-        git submodule update --init --recursive --reference $cache_src_dir/$module $module\"\n done\n-\n-travis_fold end update_submodules\n-travis_time_finish\n-\n+retry sh -c \"git submodule deinit -f $use_git && \\\n+    git submodule sync && \\\n+    git submodule update -j 16 --init --recursive $use_git\"\n+wait\n travis_fold end init_repo\n+travis_time_finish"}, {"sha": "44eae0d1800472eb9eb16a2a979fbafaf8584a92", "filename": "src/ci/run.sh", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -25,6 +25,8 @@ source \"$ci_dir/shared.sh\"\n \n if [ \"$TRAVIS\" == \"true\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-quiet-tests\"\n+else\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings\"\n fi\n \n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-sccache\"\n@@ -46,7 +48,6 @@ export RUST_RELEASE_CHANNEL=nightly\n if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=$RUST_RELEASE_CHANNEL\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n-  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-thinlto\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n@@ -73,6 +74,13 @@ fi\n # sccache server at the start of the build, but no need to worry if this fails.\n SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n+if [ \"$PARALLEL_CHECK\" != \"\" ]; then\n+  $SRC/configure --enable-experimental-parallel-queries\n+  python2.7 ../x.py check\n+  rm -f config.toml\n+  rm -rf build\n+fi\n+\n travis_fold start configure\n travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS\n@@ -91,11 +99,19 @@ make check-bootstrap\n travis_fold end check-bootstrap\n travis_time_finish\n \n+# Display the CPU and memory information. This helps us know why the CI timing\n+# is fluctuating.\n+travis_fold start log-system-info\n if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+    system_profiler SPHardwareDataType || true\n+    sysctl hw || true\n     ncpus=$(sysctl -n hw.ncpu)\n else\n+    cat /proc/cpuinfo || true\n+    cat /proc/meminfo || true\n     ncpus=$(grep processor /proc/cpuinfo | wc -l)\n fi\n+travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n   sh -x -c \"$SCRIPT\""}, {"sha": "b889e1e30c5e9953834aa9fa6c982bb28df46ac9", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1 +1 @@\n-Subproject commit 98921e9de849acdaeaed08cfad6758bb89769b7d\n+Subproject commit b889e1e30c5e9953834aa9fa6c982bb28df46ac9"}, {"sha": "2e36831d7e86f9e7bcb022eb7f5ff0d3d03d0969", "filename": "src/doc/index.md", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -6,55 +6,72 @@ nav {\n }\n </style>\n \n-This page is an overview of the documentation included with your Rust install.\n-Other unofficial documentation may exist elsewhere; for example, the [Rust\n-Learning] project collects documentation from the community, and [Docs.rs]\n-builds documentation for individual Rust packages.\n+Welcome to an overview of the documentation provided by the Rust project.\n+All of these projects are managed by the Docs Team; there are other\n+unofficial documentation resources as well!\n \n-# API Documentation\n+Many of these resources take the form of \"books\"; we collectively call these\n+\"The Rust Bookshelf.\" Some are large, some are small.\n \n-Rust provides a standard library with a number of features; [we host its\n-documentation here][api].\n+## Learn Rust\n \n-# Extended Error Documentation\n+If you'd like to learn Rust, this is the spot for you! All of these resources\n+assume that you have programmed before, but not in any specific language:\n+\n+### The Rust Programming Language\n+\n+Affectionately nicknamed \"the book,\" [The Rust Programming\n+Language](book/index.html) will give you an overview of the language from\n+first principles. You'll build a few projects along the way, and by the end,\n+you'll have a solid grasp of the language.\n+\n+### Rust By Example\n+\n+If reading multiple hundreds of pages about a language isn't your style, then\n+[Rust By Example](rust-by-example/index.html) has you covered. While the book talks about code with\n+a lot of words, RBE shows off a bunch of code, and keeps the talking to a\n+minimum. It also includes exercises!\n+\n+## Use Rust\n+\n+Once you've gotten familliar with the language, these resources can help you\n+when you're actually using it day-to-day.\n+\n+### The Standard Library\n+\n+Rust's standard library has [extensive API documentation](std/index.html),\n+with explanations of how to use various things, as well as example code for\n+accomplishing various tasks.\n+\n+### The Cargo Book\n+\n+[The Cargo Book](cargo/index.html) is a guide to Cargo, Rust's build tool and dependency manager.\n+\n+### The Rustdoc Book\n+\n+[The Rustdoc Book](rustdoc/index.html) describes our documentation tool, `rustdoc`.\n+\n+### Extended Error Listing\n \n Many of Rust's errors come with error codes, and you can request extended\n-diagnostics from the compiler on those errors. We also [have the text of those\n-extended errors on the web][err], if you prefer to read them that way.\n-\n-# The Rust Bookshelf\n-\n-Rust provides a number of book-length sets of documentation, collectively\n-nicknamed 'The Rust Bookshelf.'\n-\n-* [The Rust Programming Language][book] teaches you how to program in Rust.\n-* [Rust By Example][rbe] teaches you how to program in Rust using editable examples.\n-* [The Cargo Book][cargo-book] is a guide to Cargo, Rust's build tool and dependency manager.\n-* [The Unstable Book][unstable-book] has documentation for unstable features.\n-* [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n-* [The Reference][ref] is not a formal spec, but is more detailed and comprehensive than the book.\n-* [The Rustdoc Book][rustdoc-book] describes our documentation tool, `rustdoc`.\n-\n-Initially, documentation lands in the Unstable Book, and then, as part of the\n-stabilization process, is moved into the Book, Nomicon, or Reference.\n-\n-Another few words about the reference: it is guaranteed to be accurate, but not\n-complete. We have a policy that features must have documentation to be stabilized,\n-but we did not always have this policy, and so there are some stable things that\n-are not yet in the reference. We're working on back-filling things that landed\n-before this policy was put into place. That work is being tracked\n-[here][refchecklist].\n-\n-[Rust Learning]: https://github.com/ctjhoa/rust-learning\n-[Docs.rs]: https://docs.rs/\n-[api]: std/index.html\n-[ref]: reference/index.html\n-[refchecklist]: https://github.com/rust-lang-nursery/reference/issues/9\n-[err]: error-index.html\n-[book]: book/index.html\n-[rbe]: rust-by-example/index.html\n-[nomicon]: nomicon/index.html\n-[unstable-book]: unstable-book/index.html\n-[rustdoc-book]: rustdoc/index.html\n-[cargo-book]: cargo/index.html\n+diagnostics from the compiler on those errors. You can also [read them\n+here](error-index.html), if you prefer to read them that way.\n+\n+## Master Rust\n+\n+Once you're quite familiar with the language, you may find these advanced\n+resources useful.\n+\n+### The Reference\n+\n+[The Reference](reference/index.html) is not a formal spec, but is more detailed and\n+comprehensive than the book.\n+\n+### The Rustonomicon\n+\n+[The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of unsafe\n+Rust. It's also sometimes called \"the 'nomicon.\"\n+\n+### The Unstable Book\n \n+[The Unstable Book](unstable-book/index.html) has documentation for unstable features."}, {"sha": "6a8f0a27e9a58c55c89d07bc43a176fdae5e051c", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1 +1 @@\n-Subproject commit ad5ddd62c098d5b424151beda574ae7df2154df1\n+Subproject commit 6a8f0a27e9a58c55c89d07bc43a176fdae5e051c"}, {"sha": "76296346e97c3702974d3398fdb94af9e10111a2", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1 +1 @@\n-Subproject commit 254df654a9b75abf6ca08806535dbe1fad41be3f\n+Subproject commit 76296346e97c3702974d3398fdb94af9e10111a2"}, {"sha": "d5ec87eabe5733cc2348c7dada89fc67c086f391", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1 +1 @@\n-Subproject commit ebb28c95b2ea68b96eddb9e71aff4d32eacc74f0\n+Subproject commit d5ec87eabe5733cc2348c7dada89fc67c086f391"}, {"sha": "46528187c11754eecbf2be1e59434bb2a3acaec5", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -5,3 +5,4 @@\n - [The `#[doc]` attribute](the-doc-attribute.md)\n - [Documentation tests](documentation-tests.md)\n - [Passes](passes.md)\n+- [Unstable features](unstable-features.md)"}, {"sha": "fea8685a605d6859b52fcd4a3806d016b5826e06", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -19,18 +19,38 @@ running `rustdoc --test foo.rs` will extract this example, and then run it as a\n Please note that by default, if no language is set for the block code, `rustdoc`\n assumes it is `Rust` code. So the following:\n \n+``````markdown\n ```rust\n let x = 5;\n ```\n+``````\n \n is strictly equivalent to:\n \n+``````markdown\n ```\n let x = 5;\n ```\n+``````\n \n There's some subtlety though! Read on for more details.\n \n+## Passing or failing a doctest\n+\n+Like regular unit tests, regular doctests are considered to \"pass\"\n+if they compile and run without panicking.\n+So if you want to demonstrate that some computation gives a certain result,\n+the `assert!` family of macros works the same as other Rust code:\n+\n+```rust\n+let foo = \"foo\";\n+\n+assert_eq!(foo, \"foo\");\n+```\n+\n+This way, if the computation ever returns something different,\n+the code panics and the doctest fails.\n+\n ## Pre-processing examples\n \n In the example above, you'll note something strange: there's no `main`"}, {"sha": "bf97fb4686180f981f7c9e4983606f9910455f1b", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -0,0 +1,375 @@\n+# Unstable features\n+\n+Rustdoc is under active developement, and like the Rust compiler, some features are only available\n+on the nightly releases. Some of these are new and need some more testing before they're able to get\n+released to the world at large, and some of them are tied to features in the Rust compiler that are\n+themselves unstable. Several features here require a matching `#![feature(...)]` attribute to\n+enable, and thus are more fully documented in the [Unstable Book]. Those sections will link over\n+there as necessary.\n+\n+[Unstable Book]: ../unstable-book/index.html\n+\n+## Nightly-gated functionality\n+\n+These features just require a nightly build to operate. Unlike the other features on this page,\n+these don't need to be \"turned on\" with a command-line flag or a `#![feature(...)]` attribute in\n+your crate. This can give them some subtle fallback modes when used on a stable release, so be\n+careful!\n+\n+### Error numbers for `compile-fail` doctests\n+\n+As detailed in [the chapter on documentation tests][doctest-attributes], you can add a\n+`compile_fail` attribute to a doctest to state that the test should fail to compile. However, on\n+nightly, you can optionally add an error number to state that a doctest should emit a specific error\n+number:\n+\n+[doctest-attributes]: documentation-tests.html#attributes\n+\n+``````markdown\n+```compile_fail,E0044\n+extern { fn some_func<T>(x: T); }\n+```\n+``````\n+\n+This is used by the error index to ensure that the samples that correspond to a given error number\n+properly emit that error code. However, these error codes aren't guaranteed to be the only thing\n+that a piece of code emits from version to version, so this is unlikely to be stabilized in the\n+future.\n+\n+Attempting to use these error numbers on stable will result in the code sample being interpreted as\n+plain text.\n+\n+### Linking to items by type\n+\n+As designed in [RFC 1946], Rustdoc can parse paths to items when you use them as links. To resolve\n+these type names, it uses the items currently in-scope, either by declaration or by `use` statement.\n+For modules, the \"active scope\" depends on whether the documentation is written outside the module\n+(as `///` comments on the `mod` statement) or inside the module (at `//!` comments inside the file\n+or block). For all other items, it uses the enclosing module's scope.\n+\n+[RFC 1946]: https://github.com/rust-lang/rfcs/pull/1946\n+\n+For example, in the following code:\n+\n+```rust\n+/// Does the thing.\n+pub fn do_the_thing(_: SomeType) {\n+\tprintln!(\"Let's do the thing!\");\n+}\n+\n+/// Token you use to [`do_the_thing`].\n+pub struct SomeType;\n+```\n+\n+The link to ``[`do_the_thing`]`` in `SomeType`'s docs will properly link to the page for `fn\n+do_the_thing`. Note that here, rustdoc will insert the link target for you, but manually writing the\n+target out also works:\n+\n+```rust\n+pub mod some_module {\n+\t/// Token you use to do the thing.\n+\tpub struct SomeStruct;\n+}\n+\n+/// Does the thing. Requires one [`SomeStruct`] for the thing to work.\n+///\n+/// [`SomeStruct`]: some_module::SomeStruct\n+pub fn do_the_thing(_: some_module::SomeStruct) {\n+\tprintln!(\"Let's do the thing!\");\n+}\n+```\n+\n+For more details, check out [the RFC][RFC 1946], and see [the tracking issue][43466] for more\n+information about what parts of the feature are available.\n+\n+[43466]: https://github.com/rust-lang/rust/issues/43466\n+\n+## Extensions to the `#[doc]` attribute\n+\n+These features operate by extending the `#[doc]` attribute, and thus can be caught by the compiler\n+and enabled with a `#![feature(...)]` attribute in your crate.\n+\n+### Documenting platform-/feature-specific information\n+\n+Because of the way Rustdoc documents a crate, the documentation it creates is specific to the target\n+rustc compiles for. Anything that's specific to any other target is dropped via `#[cfg]` attribute\n+processing early in the compilation process. However, Rustdoc has a trick up its sleeve to handle\n+platform-specific code if it *does* receive it.\n+\n+Because Rustdoc doesn't need to fully compile a crate to binary, it replaces function bodies with\n+`loop {}` to prevent having to process more than necessary. This means that any code within a\n+function that requires platform-specific pieces is ignored. Combined with a special attribute,\n+`#[doc(cfg(...))]`, you can tell Rustdoc exactly which platform something is supposed to run on,\n+ensuring that doctests are only run on the appropriate platforms.\n+\n+The `#[doc(cfg(...))]` attribute has another effect: When Rustdoc renders documentation for that\n+item, it will be accompanied by a banner explaining that the item is only available on certain\n+platforms.\n+\n+As mentioned earlier, getting the items to Rustdoc requires some extra preparation. The standard\n+library adds a `--cfg dox` flag to every Rustdoc command, but the same thing can be accomplished by\n+adding a feature to your Cargo.toml and adding `--feature dox` (or whatever you choose to name the\n+feature) to your `cargo doc` calls.\n+\n+Either way, once you create an environment for the documentation, you can start to augment your\n+`#[cfg]` attributes to allow both the target platform *and* the documentation configuration to leave\n+the item in. For example, `#[cfg(any(windows, feature = \"dox\"))]` will preserve the item either on\n+Windows or during the documentation process. Then, adding a new attribute `#[doc(cfg(windows))]`\n+will tell Rustdoc that the item is supposed to be used on Windows. For example:\n+\n+```rust\n+#![feature(doc_cfg)]\n+\n+/// Token struct that can only be used on Windows.\n+#[cfg(any(windows, feature = \"dox\"))]\n+#[doc(cfg(windows))]\n+pub struct WindowsToken;\n+\n+/// Token struct that can only be used on Unix.\n+#[cfg(any(unix, feature = \"dox\"))]\n+#[doc(cfg(unix))]\n+pub struct UnixToken;\n+```\n+\n+In this sample, the tokens will only appear on their respective platforms, but they will both appear\n+in documentation.\n+\n+`#[doc(cfg(...))]` was introduced to be used by the standard library and currently requires the\n+`#![feature(doc_cfg)]` feature gate. For more information, see [its chapter in the Unstable\n+Book][unstable-doc-cfg] and [its tracking issue][issue-doc-cfg].\n+\n+[unstable-doc-cfg]: ../unstable-book/language-features/doc-cfg.html\n+[issue-doc-cfg]: https://github.com/rust-lang/rust/issues/43781\n+\n+### Adding your trait to the \"Important Traits\" dialog\n+\n+Rustdoc keeps a list of a few traits that are believed to be \"fundamental\" to a given type when\n+implemented on it. These traits are intended to be the primary interface for their types, and are\n+often the only thing available to be documented on their types. For this reason, Rustdoc will track\n+when a given type implements one of these traits and call special attention to it when a function\n+returns one of these types. This is the \"Important Traits\" dialog, visible as a circle-i button next\n+to the function, which, when clicked, shows the dialog.\n+\n+In the standard library, the traits that qualify for inclusion are `Iterator`, `io::Read`, and\n+`io::Write`. However, rather than being implemented as a hard-coded list, these traits have a\n+special marker attribute on them: `#[doc(spotlight)]`. This means that you could apply this\n+attribute to your own trait to include it in the \"Important Traits\" dialog in documentation.\n+\n+The `#[doc(spotlight)]` attribute currently requires the `#![feature(doc_spotlight)]` feature gate.\n+For more information, see [its chapter in the Unstable Book][unstable-spotlight] and [its tracking\n+issue][issue-spotlight].\n+\n+[unstable-spotlight]: ../unstable-book/language-features/doc-spotlight.html\n+[issue-spotlight]: https://github.com/rust-lang/rust/issues/45040\n+\n+### Exclude certain dependencies from documentation\n+\n+The standard library uses several dependencies which, in turn, use several types and traits from the\n+standard library. In addition, there are several compiler-internal crates that are not considered to\n+be part of the official standard library, and thus would be a distraction to include in\n+documentation. It's not enough to exclude their crate documentation, since information about trait\n+implementations appears on the pages for both the type and the trait, which can be in different\n+crates!\n+\n+To prevent internal types from being included in documentation, the standard library adds an\n+attribute to their `extern crate` declarations: `#[doc(masked)]`. This causes Rustdoc to \"mask out\"\n+types from these crates when building lists of trait implementations.\n+\n+The `#[doc(masked)]` attribute is intended to be used internally, and requires the\n+`#![feature(doc_masked)]` feature gate.  For more information, see [its chapter in the Unstable\n+Book][unstable-masked] and [its tracking issue][issue-masked].\n+\n+[unstable-masked]: ../unstable-book/language-features/doc-masked.html\n+[issue-masked]: https://github.com/rust-lang/rust/issues/44027\n+\n+### Include external files as API documentation\n+\n+As designed in [RFC 1990], Rustdoc can read an external file to use as a type's documentation. This\n+is useful if certain documentation is so long that it would break the flow of reading the source.\n+Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` (where `sometype.md` is\n+a file adjacent to the `lib.rs` for the crate) will ask Rustdoc to instead read that file and use it\n+as if it were written inline.\n+\n+[RFC 1990]: https://github.com/rust-lang/rfcs/pull/1990\n+\n+`#[doc(include = \"...\")]` currently requires the `#![feature(external_doc)]` feature gate. For more\n+information, see [its chapter in the Unstable Book][unstable-include] and [its tracking\n+issue][issue-include].\n+\n+[unstable-include]: ../unstable-book/language-features/external-doc.html\n+[issue-include]: https://github.com/rust-lang/rust/issues/44732\n+\n+## Unstable command-line arguments\n+\n+These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are\n+themselves marked as unstable. To use any of these options, pass `-Z unstable-options` as well as\n+the flag in question to Rustdoc on the command-line. To do this from Cargo, you can either use the\n+`RUSTDOCFLAGS` environment variable or the `cargo rustdoc` command.\n+\n+### `--markdown-before-content`: include rendered Markdown before the content\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --markdown-before-content extra.md\n+$ rustdoc README.md -Z unstable-options --markdown-before-content extra.md\n+```\n+\n+Just like `--html-before-content`, this allows you to insert extra content inside the `<body>` tag\n+but before the other content `rustdoc` would normally produce in the rendered documentation.\n+However, instead of directly inserting the file verbatim, `rustdoc` will pass the files through a\n+Markdown renderer before inserting the result into the file.\n+\n+### `--markdown-after-content`: include rendered Markdown after the content\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --markdown-after-content extra.md\n+$ rustdoc README.md -Z unstable-options --markdown-after-content extra.md\n+```\n+\n+Just like `--html-after-content`, this allows you to insert extra content before the `</body>` tag\n+but after the other content `rustdoc` would normally produce in the rendered documentation.\n+However, instead of directly inserting the file verbatim, `rustdoc` will pass the files through a\n+Markdown renderer before inserting the result into the file.\n+\n+### `--playground-url`: control the location of the playground\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --playground-url https://play.rust-lang.org/\n+```\n+\n+When rendering a crate's docs, this flag gives the base URL of the Rust Playground, to use for\n+generating `Run` buttons. Unlike `--markdown-playground-url`, this argument works for standalone\n+Markdown files *and* Rust crates. This works the same way as adding `#![doc(html_playground_url =\n+\"url\")]` to your crate root, as mentioned in [the chapter about the `#[doc]`\n+attribute][doc-playground]. Please be aware that the official Rust Playground at\n+https://play.rust-lang.org does not have every crate available, so if your examples require your\n+crate, make sure the playground you provide has your crate available.\n+\n+[doc-playground]: the-doc-attribute.html#html_playground_url\n+\n+If both `--playground-url` and `--markdown-playground-url` are present when rendering a standalone\n+Markdown file, the URL given to `--markdown-playground-url` will take precedence. If both\n+`--playground-url` and `#![doc(html_playground_url = \"url\")]` are present when rendering crate docs,\n+the attribute will take precedence.\n+\n+### `--crate-version`: control the crate version\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --crate-version 1.3.37\n+```\n+\n+When `rustdoc` receives this flag, it will print an extra \"Version (version)\" into the sidebar of\n+the crate root's docs. You can use this flag to differentiate between different versions of your\n+library's documentation.\n+\n+### `--linker`: control the linker used for documentation tests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc --test src/lib.rs -Z unstable-options --linker foo\n+$ rustdoc --test README.md -Z unstable-options --linker foo\n+```\n+\n+When `rustdoc` runs your documentation tests, it needs to compile and link the tests as executables\n+before running them. This flag can be used to change the linker used on these executables. It's\n+equivalent to passing `-C linker=foo` to `rustc`.\n+\n+### `--sort-modules-by-appearance`: control how items on module pages are sorted\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --sort-modules-by-appearance\n+```\n+\n+Ordinarily, when `rustdoc` prints items in module pages, it will sort them alphabetically (taking\n+some consideration for their stability, and names that end in a number). Giving this flag to\n+`rustdoc` will disable this sorting and instead make it print the items in the order they appear in\n+the source.\n+\n+### `--themes`: provide additional themes\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --themes theme.css\n+```\n+\n+Giving this flag to `rustdoc` will make it copy your theme into the generated crate docs and enable\n+it in the theme selector. Note that `rustdoc` will reject your theme file if it doesn't style\n+everything the \"light\" theme does. See `--theme-checker` below for details.\n+\n+### `--theme-checker`: verify theme CSS for validity\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc -Z unstable-options --theme-checker theme.css\n+```\n+\n+Before including your theme in crate docs, `rustdoc` will compare all the CSS rules it contains\n+against the \"light\" theme included by default. Using this flag will allow you to see which rules are\n+missing if `rustdoc` rejects your theme.\n+\n+### `--resource-suffix`: modifying the name of CSS/JavaScript in crate docs\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --resource-suffix suf\n+```\n+\n+When rendering docs, `rustdoc` creates several CSS and JavaScript files as part of the output. Since\n+all these files are linked from every page, changing where they are can be cumbersome if you need to\n+specially cache them. This flag will rename all these files in the output to include the suffix in\n+the filename. For example, `light.css` would become `light-suf.css` with the above command.\n+\n+### `--display-warnings`: display warnings when documenting or running documentation tests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --display-warnings\n+$ rustdoc --test src/lib.rs -Z unstable-options --display-warnings\n+```\n+\n+The intent behind this flag is to allow the user to see warnings that occur within their library or\n+their documentation tests, which are usually suppressed. However, [due to a\n+bug][issue-display-warnings], this flag doesn't 100% work as intended. See the linked issue for\n+details.\n+\n+[issue-display-warnings]: https://github.com/rust-lang/rust/issues/41574\n+\n+### `--edition`: control the edition of docs and doctests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --edition 2018\n+$ rustdoc --test src/lib.rs -Z unstable-options --edition 2018\n+```\n+\n+This flag allows rustdoc to treat your rust code as the given edition. It will compile doctests with\n+the given edition as well. As with `rustc`, the default edition that `rustdoc` will use is `2015`\n+(the first edition).\n+\n+### `-Z force-unstable-if-unmarked`\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z force-unstable-if-unmarked\n+```\n+\n+This is an internal flag intended for the standard library and compiler that applies an\n+`#[unstable]` attribute to any dependent crate that doesn't have another stability attribute. This\n+allows `rustdoc` to be able to generate documentation for the compiler crates and the standard\n+library, as an equivalent command-line argument is provided to `rustc` when building those crates."}, {"sha": "e8256469b145078be9889c75600c86e64081012c", "filename": "src/doc/unstable-book/src/language-features/advanced-slice-patterns.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,35 +0,0 @@\n-# `advanced_slice_patterns`\n-\n-The tracking issue for this feature is: [#23121]\n-\n-[#23121]: https://github.com/rust-lang/rust/issues/23121\n-\n-See also [`slice_patterns`](language-features/slice-patterns.html).\n-\n-------------------------\n-\n-\n-The `advanced_slice_patterns` gate lets you use `..` to indicate any number of\n-elements inside a pattern matching a slice. This wildcard can only be used once\n-for a given array. If there's an identifier before the `..`, the result of the\n-slice will be bound to that name. For example:\n-\n-```rust\n-#![feature(advanced_slice_patterns, slice_patterns)]\n-\n-fn is_symmetric(list: &[u32]) -> bool {\n-    match list {\n-        &[] | &[_] => true,\n-        &[x, ref inside.., y] if x == y => is_symmetric(inside),\n-        _ => false\n-    }\n-}\n-\n-fn main() {\n-    let sym = &[0, 1, 4, 2, 4, 1, 0];\n-    assert!(is_symmetric(sym));\n-\n-    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n-    assert!(!is_symmetric(not_sym));\n-}\n-```"}, {"sha": "0be6a321103f0858b9e0d70981b6a6414e72a47c", "filename": "src/doc/unstable-book/src/language-features/conservative-impl-trait.md", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,66 +0,0 @@\n-# `conservative_impl_trait`\n-\n-The tracking issue for this feature is: [#34511]\n-\n-[#34511]: https://github.com/rust-lang/rust/issues/34511\n-\n-------------------------\n-\n-The `conservative_impl_trait` feature allows a conservative form of abstract\n-return types.\n-\n-Abstract return types allow a function to hide a concrete return type behind a\n-trait interface similar to trait objects, while still generating the same\n-statically dispatched code as with concrete types.\n-\n-## Examples\n-\n-```rust\n-#![feature(conservative_impl_trait)]\n-\n-fn even_iter() -> impl Iterator<Item=u32> {\n-    (0..).map(|n| n * 2)\n-}\n-\n-fn main() {\n-    let first_four_even_numbers = even_iter().take(4).collect::<Vec<_>>();\n-    assert_eq!(first_four_even_numbers, vec![0, 2, 4, 6]);\n-}\n-```\n-\n-## Background\n-\n-In today's Rust, you can write function signatures like:\n-\n-````rust,ignore\n-fn consume_iter_static<I: Iterator<Item=u8>>(iter: I) { }\n-\n-fn consume_iter_dynamic(iter: Box<Iterator<Item=u8>>) { }\n-````\n-\n-In both cases, the function does not depend on the exact type of the argument.\n-The type held is \"abstract\", and is assumed only to satisfy a trait bound.\n-\n-* In the `_static` version using generics, each use of the function is\n-  specialized to a concrete, statically-known type, giving static dispatch,\n-  inline layout, and other performance wins.\n-* In the `_dynamic` version using trait objects, the concrete argument type is\n-  only known at runtime using a vtable.\n-\n-On the other hand, while you can write:\n-\n-````rust,ignore\n-fn produce_iter_dynamic() -> Box<Iterator<Item=u8>> { }\n-````\n-\n-...but you _cannot_ write something like:\n-\n-````rust,ignore\n-fn produce_iter_static() -> Iterator<Item=u8> { }\n-````\n-\n-That is, in today's Rust, abstract return types can only be written using trait\n-objects, which can be a significant performance penalty. This RFC proposes\n-\"unboxed abstract types\" as a way of achieving signatures like\n-`produce_iter_static`. Like generics, unboxed abstract types guarantee static\n-dispatch and inline data layout."}, {"sha": "8e888de90a95149ecf786f9b62e8588114623547", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -36,11 +36,11 @@ fn main() {\n         return \"foo\"\n     };\n \n-    match generator.resume() {\n+    match unsafe { generator.resume() } {\n         GeneratorState::Yielded(1) => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n-    match generator.resume() {\n+    match unsafe { generator.resume() } {\n         GeneratorState::Complete(\"foo\") => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n@@ -69,9 +69,9 @@ fn main() {\n     };\n \n     println!(\"1\");\n-    generator.resume();\n+    unsafe { generator.resume() };\n     println!(\"3\");\n-    generator.resume();\n+    unsafe { generator.resume() };\n     println!(\"5\");\n }\n ```\n@@ -92,7 +92,7 @@ The `Generator` trait in `std::ops` currently looks like:\n pub trait Generator {\n     type Yield;\n     type Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n }\n ```\n \n@@ -175,8 +175,8 @@ fn main() {\n         return ret\n     };\n \n-    generator.resume();\n-    generator.resume();\n+    unsafe { generator.resume() };\n+    unsafe { generator.resume() };\n }\n ```\n \n@@ -200,7 +200,7 @@ fn main() {\n             type Yield = i32;\n             type Return = &'static str;\n \n-            fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n+            unsafe fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n                 use std::mem;\n                 match mem::replace(self, __Generator::Done) {\n                     __Generator::Start(s) => {\n@@ -223,8 +223,8 @@ fn main() {\n         __Generator::Start(ret)\n     };\n \n-    generator.resume();\n-    generator.resume();\n+    unsafe { generator.resume() };\n+    unsafe { generator.resume() };\n }\n ```\n "}, {"sha": "a850b7644c3a76fee296606cf1ea858640251c41", "filename": "src/doc/unstable-book/src/language-features/i128-type.md", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,25 +0,0 @@\n-# `i128_type`\n-\n-The tracking issue for this feature is: [#35118]\n-\n-[#35118]: https://github.com/rust-lang/rust/issues/35118\n-\n-------------------------\n-\n-The `i128_type` feature adds support for 128 bit signed and unsigned integer\n-types.\n-\n-```rust\n-#![feature(i128_type)]\n-\n-fn main() {\n-    assert_eq!(1u128 + 1u128, 2u128);\n-    assert_eq!(u128::min_value(), 0);\n-    assert_eq!(u128::max_value(), 340282366920938463463374607431768211455);\n-\n-    assert_eq!(1i128 - 2i128, -1i128);\n-    assert_eq!(i128::min_value(), -170141183460469231731687303715884105728);\n-    assert_eq!(i128::max_value(), 170141183460469231731687303715884105727);\n-}\n-```\n-"}, {"sha": "56f58803150ca6ca274b5b9046f771f92e1c0627", "filename": "src/doc/unstable-book/src/language-features/inclusive-range-syntax.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,20 +0,0 @@\n-# `inclusive_range_syntax`\n-\n-The tracking issue for this feature is: [#28237]\n-\n-[#28237]: https://github.com/rust-lang/rust/issues/28237\n-\n-------------------------\n-\n-To get a range that goes from 0 to 10 and includes the value 10, you\n-can write `0..=10`:\n-\n-```rust\n-#![feature(inclusive_range_syntax)]\n-\n-fn main() {\n-    for i in 0..=10 {\n-        println!(\"{}\", i);\n-    }\n-}\n-```"}, {"sha": "cc542931cbe1fc01b10f1e2aef1bf2bc417b7298", "filename": "src/doc/unstable-book/src/language-features/match-default-bindings.md", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,58 +0,0 @@\n-# `match_default_bindings`\n-\n-The tracking issue for this feature is: [#42640]\n-\n-[#42640]: https://github.com/rust-lang/rust/issues/42640\n-\n-------------------------\n-\n-Match default bindings (also called \"default binding modes in match\") improves ergonomics for\n-pattern-matching on references by introducing automatic dereferencing (and a corresponding shift\n-in binding modes) for large classes of patterns that would otherwise not compile.\n-\n-For example, under match default bindings,\n-\n-```rust\n-#![feature(match_default_bindings)]\n-\n-fn main() {\n-    let x: &Option<_> = &Some(0);\n-\n-    match x {\n-        Some(y) => {\n-            println!(\"y={}\", *y);\n-        },\n-        None => {},\n-    }\n-}\n-```\n-\n-compiles and is equivalent to either of the below:\n-\n-```rust\n-fn main() {\n-    let x: &Option<_> = &Some(0);\n-\n-    match *x {\n-        Some(ref y) => {\n-            println!(\"y={}\", *y);\n-        },\n-        None => {},\n-    }\n-}\n-```\n-\n-or\n-\n-```rust\n-fn main() {\n-    let x: &Option<_> = &Some(0);\n-\n-    match x {\n-        &Some(ref y) => {\n-            println!(\"y={}\", *y);\n-        },\n-        &None => {},\n-    }\n-}\n-```"}, {"sha": "0858988952c105c3e987f16e977ed8510209aa61", "filename": "src/doc/unstable-book/src/language-features/repr128.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -0,0 +1,18 @@\n+# `repr128`\n+\n+The tracking issue for this feature is: [#35118]\n+\n+[#35118]: https://github.com/rust-lang/rust/issues/35118\n+\n+------------------------\n+\n+The `repr128` feature adds support for `#[repr(u128)]` on `enum`s.\n+\n+```rust\n+#![feature(repr128)]\n+\n+#[repr(u128)]\n+enum Foo {\n+    Bar(u64),\n+}\n+```"}, {"sha": "133174268ef93f16fbfc191b9bd405751e81af04", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -4,25 +4,29 @@ The tracking issue for this feature is: [#23121]\n \n [#23121]: https://github.com/rust-lang/rust/issues/23121\n \n-See also\n-[`advanced_slice_patterns`](language-features/advanced-slice-patterns.html).\n-\n ------------------------\n \n-\n-If you want to match against a slice or array, you can use `&` with the\n-`slice_patterns` feature:\n+The `slice_patterns` feature gate lets you use `..` to indicate any number of\n+elements inside a pattern matching a slice. This wildcard can only be used once\n+for a given array. If there's an pattern before the `..`, the subslice will be\n+matched against that pattern. For example:\n \n ```rust\n #![feature(slice_patterns)]\n \n+fn is_symmetric(list: &[u32]) -> bool {\n+    match list {\n+        &[] | &[_] => true,\n+        &[x, ref inside.., y] if x == y => is_symmetric(inside),\n+        &[..] => false,\n+    }\n+}\n+\n fn main() {\n-    let v = vec![\"match_this\", \"1\"];\n+    let sym = &[0, 1, 4, 2, 4, 1, 0];\n+    assert!(is_symmetric(sym));\n \n-    match &v[..] {\n-        &[\"match_this\", second] => println!(\"The second element is {}\", second),\n-        _ => {},\n-    }\n+    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n+    assert!(!is_symmetric(not_sym));\n }\n ```\n-"}, {"sha": "6b3c5e92720df6e9ef6ee001f4676c96dadadf98", "filename": "src/doc/unstable-book/src/language-features/universal-impl-trait.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,32 +0,0 @@\n-# `universal_impl_trait`\n-\n-The tracking issue for this feature is: [#34511].\n-\n-[#34511]: https://github.com/rust-lang/rust/issues/34511\n-\n---------------------\n-\n-The `universal_impl_trait` feature extends the [`conservative_impl_trait`]\n-feature allowing the `impl Trait` syntax in arguments (universal\n-quantification).\n-\n-[`conservative_impl_trait`]: ./language-features/conservative-impl-trait.html\n-\n-## Examples\n-\n-```rust\n-#![feature(universal_impl_trait)]\n-use std::ops::Not;\n-\n-fn any_zero(values: impl IntoIterator<Item = i32>) -> bool {\n-    for val in values { if val == 0 { return true; } }\n-    false\n-}\n-\n-fn main() {\n-    let test1 = -5..;\n-    let test2 = vec![1, 8, 42, -87, 60];\n-    assert!(any_zero(test1));\n-    assert!(bool::not(any_zero(test2)));\n-}\n-```"}, {"sha": "2e4bb1a5257c94b76899fc56324825666a4542be", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,22 +0,0 @@\n-# `splice`\n-\n-The tracking issue for this feature is: [#44643]\n-\n-[#44643]: https://github.com/rust-lang/rust/issues/44643\n-\n-------------------------\n-\n-The `splice()` method on `String` allows you to replace a range\n-of values in a string with another range of values.\n-\n-A simple example:\n-\n-```rust\n-#![feature(splice)]\n-let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n-let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n-\n-// Replace the range up until the \u03b2 from the string\n-s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n-assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n-```"}, {"sha": "049444aa49bdd2ef90d7316c2e6d6d41bdf16f80", "filename": "src/doc/unstable-book/src/library-features/string-retain.md", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,23 +0,0 @@\n-# `string_retain`\n-\n-The tracking issue for this feature is: [#43874]\n-\n-[#43874]: https://github.com/rust-lang/rust/issues/43874\n-\n-------------------------\n-\n-Retains only the characters specified by the predicate.\n-\n-In other words, remove all characters `c` such that `f(c)` returns `false`.\n-This method operates in place and preserves the order of the retained\n-characters.\n-\n-```rust\n-#![feature(string_retain)]\n-\n-let mut s = String::from(\"f_o_ob_ar\");\n-\n-s.retain(|c| c != '_');\n-\n-assert_eq!(s, \"foobar\");\n-```"}, {"sha": "361e8d8e60eed9a48edc1c7a7023e7c3bb9ffadf", "filename": "src/etc/cat-and-grep.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fetc%2Fcat-and-grep.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fetc%2Fcat-and-grep.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcat-and-grep.sh?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -63,6 +63,11 @@ done\n \n shift $((OPTIND - 1))\n \n+# use gnu version of tool if available (for bsd)\n+if command -v \"g${GREPPER}\"; then\n+    GREPPER=\"g${GREPPER}\"\n+fi\n+\n LOG=$(mktemp -t cgrep.XXXXXX)\n trap \"rm -f $LOG\" EXIT\n "}, {"sha": "a7da69f65faf2b3532cdc6537cff92a167a139ac", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1400,7 +1400,6 @@ nonblock_expr\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1463,7 +1462,6 @@ expr\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1527,7 +1525,6 @@ expr_nostruct\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }"}, {"sha": "3bf919b0c0016e3c689b87146e5a0ba30c940f22", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,7 +12,7 @@ core = { path = \"../libcore\" }\n std_unicode = { path = \"../libstd_unicode\" }\n \n [dev-dependencies]\n-rand = \"0.3\"\n+rand = \"0.4\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "ccf2e2768d1a971d5362e49cd08aa4e67e1e2164", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -21,6 +21,7 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n+use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val, uninitialized};\n use core::ops::Deref;\n@@ -31,7 +32,7 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout, box_free};\n+use heap::{Heap, box_free};\n use boxed::Box;\n use string::String;\n use vec::Vec;"}, {"sha": "a43aadfe9a23a72c42b511a8c5a5a3f8add8c015", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -10,9 +10,10 @@\n \n #![deny(warnings)]\n \n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![feature(rand)]\n #![feature(repr_simd)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "a699ff9c0a76ec61d0a427ab58bfe10c23c09d72", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -284,6 +284,17 @@ macro_rules! sort_expensive {\n     }\n }\n \n+macro_rules! sort_lexicographic {\n+    ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n+            b.iter(|| v.clone().$f(|x| x.to_string()));\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+        }\n+    }\n+}\n+\n sort!(sort, sort_small_ascending, gen_ascending, 10);\n sort!(sort, sort_small_descending, gen_descending, 10);\n sort!(sort, sort_small_random, gen_random, 10);\n@@ -312,6 +323,10 @@ sort!(sort_unstable, sort_unstable_large_big, gen_big_random, 10000);\n sort_strings!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n sort_expensive!(sort_unstable_by, sort_unstable_large_expensive, gen_random, 10000);\n \n+sort_lexicographic!(sort_by_key, sort_by_key_lexicographic, gen_random, 10000);\n+sort_lexicographic!(sort_unstable_by_key, sort_unstable_by_key_lexicographic, gen_random, 10000);\n+sort_lexicographic!(sort_by_cached_key, sort_by_cached_key_lexicographic, gen_random, 10000);\n+\n macro_rules! reverse {\n     ($name:ident, $ty:ty, $f:expr) => {\n         #[bench]"}, {"sha": "668b61c51d8bc0f8e3a39e496ecc0c79b2d5ed4e", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -155,7 +155,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::ops::{Deref, DerefMut, Place, Placer, InPlace};\n+use core::ops::{Deref, DerefMut};\n use core::iter::{FromIterator, FusedIterator};\n use core::mem::{swap, size_of};\n use core::ptr;\n@@ -509,6 +509,31 @@ impl<T: Ord> BinaryHeap<T> {\n         self.data.shrink_to_fit();\n     }\n \n+    /// Discards capacity with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to(10);\n+    /// assert!(heap.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.data.shrink_to(min_capacity)\n+    }\n+\n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n     /// is empty.\n     ///\n@@ -1170,67 +1195,3 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-pub struct BinaryHeapPlace<'a, T: 'a>\n-where T: Clone + Ord {\n-    heap: *mut BinaryHeap<T>,\n-    place: vec::PlaceBack<'a, T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: Clone + Ord + fmt::Debug> fmt::Debug for BinaryHeapPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"BinaryHeapPlace\")\n-         .field(&self.place)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a> Placer<T> for &'a mut BinaryHeap<T>\n-where T: Clone + Ord {\n-    type Place = BinaryHeapPlace<'a, T>;\n-\n-    fn make_place(self) -> Self::Place {\n-        let ptr = self as *mut BinaryHeap<T>;\n-        let place = Placer::make_place(self.data.place_back());\n-        BinaryHeapPlace {\n-            heap: ptr,\n-            place,\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for BinaryHeapPlace<'a, T>\n-where T: Clone + Ord {\n-    fn pointer(&mut self) -> *mut T {\n-        self.place.pointer()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for BinaryHeapPlace<'a, T>\n-where T: Clone + Ord {\n-    type Owner = &'a T;\n-\n-    unsafe fn finalize(self) -> &'a T {\n-        self.place.finalize();\n-\n-        let heap: &mut BinaryHeap<T> = &mut *self.heap;\n-        let len = heap.len();\n-        let i = heap.sift_up(0, len - 1);\n-        heap.data.get_unchecked(i)\n-    }\n-}"}, {"sha": "c6741ddb822d5bb9114889bc71fdd2203f72e559", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -59,6 +59,7 @@ pub trait ToOwned {\n     /// let vv: Vec<i32> = v.to_owned();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n     fn to_owned(&self) -> Self::Owned;\n \n     /// Uses borrowed data to replace owned data, usually by cloning."}, {"sha": "4f9dc61ce196be1306884c2afca4c9b71cdabe31", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 102, "deletions": 153, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -55,54 +55,21 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use heap::{Heap, Layout, Alloc};\n use raw_vec::RawVec;\n \n use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n-use core::hash::{self, Hash, Hasher};\n+use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n-use core::marker::{self, Unsize};\n-use core::mem;\n+use core::marker::{Unpin, Unsize};\n+use core::mem::{self, Pin};\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n-use core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\n use core::ptr::{self, NonNull, Unique};\n use core::convert::From;\n use str::from_boxed_utf8_unchecked;\n \n-/// A value that represents the heap. This is the default place that the `box`\n-/// keyword allocates into when no place is supplied.\n-///\n-/// The following two examples are equivalent:\n-///\n-/// ```\n-/// #![feature(box_heap)]\n-///\n-/// #![feature(box_syntax, placement_in_syntax)]\n-/// use std::boxed::HEAP;\n-///\n-/// fn main() {\n-///     let foo: Box<i32> = in HEAP { 5 };\n-///     let foo = box 5;\n-/// }\n-/// ```\n-#[unstable(feature = \"box_heap\",\n-           reason = \"may be renamed; uncertain about custom allocator design\",\n-           issue = \"27779\")]\n-pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n-\n-/// This the singleton type used solely for `boxed::HEAP`.\n-#[unstable(feature = \"box_heap\",\n-           reason = \"may be renamed; uncertain about custom allocator design\",\n-           issue = \"27779\")]\n-#[allow(missing_debug_implementations)]\n-#[derive(Copy, Clone)]\n-pub struct ExchangeHeapSingleton {\n-    _force_singleton: (),\n-}\n-\n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n@@ -111,121 +78,6 @@ pub struct ExchangeHeapSingleton {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T: ?Sized>(Unique<T>);\n \n-/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n-///\n-/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n-/// introducing a separate `IntermediateBox<T>`; but then you hit\n-/// issues when you e.g. attempt to destructure an instance of `Box`,\n-/// since it is a lang item and so it gets special handling by the\n-/// compiler.  Easier just to make this parallel type for now.\n-///\n-/// FIXME (pnkfelix): Currently the `box` protocol only supports\n-/// creating instances of sized types. This IntermediateBox is\n-/// designed to be forward-compatible with a future protocol that\n-/// supports creating instances of unsized types; that is why the type\n-/// parameter has the `?Sized` generalization marker, and is also why\n-/// this carries an explicit size. However, it probably does not need\n-/// to carry the explicit alignment; that is just a work-around for\n-/// the fact that the `align_of` intrinsic currently requires the\n-/// input type to be Sized (which I do not think is strictly\n-/// necessary).\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-#[allow(missing_debug_implementations)]\n-pub struct IntermediateBox<T: ?Sized> {\n-    ptr: *mut u8,\n-    layout: Layout,\n-    marker: marker::PhantomData<*mut T>,\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-unsafe impl<T> Place<T> for IntermediateBox<T> {\n-    fn pointer(&mut self) -> *mut T {\n-        self.ptr as *mut T\n-    }\n-}\n-\n-unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n-    let p = b.ptr as *mut T;\n-    mem::forget(b);\n-    Box::from_raw(p)\n-}\n-\n-fn make_place<T>() -> IntermediateBox<T> {\n-    let layout = Layout::new::<T>();\n-\n-    let p = if layout.size() == 0 {\n-        mem::align_of::<T>() as *mut u8\n-    } else {\n-        unsafe {\n-            Heap.alloc(layout.clone()).unwrap_or_else(|err| {\n-                Heap.oom(err)\n-            })\n-        }\n-    };\n-\n-    IntermediateBox {\n-        ptr: p,\n-        layout,\n-        marker: marker::PhantomData,\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> BoxPlace<T> for IntermediateBox<T> {\n-    fn make_place() -> IntermediateBox<T> {\n-        make_place()\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> InPlace<T> for IntermediateBox<T> {\n-    type Owner = Box<T>;\n-    unsafe fn finalize(self) -> Box<T> {\n-        finalize(self)\n-    }\n-}\n-\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-impl<T> Boxed for Box<T> {\n-    type Data = T;\n-    type Place = IntermediateBox<T>;\n-    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> {\n-        finalize(b)\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> Placer<T> for ExchangeHeapSingleton {\n-    type Place = IntermediateBox<T>;\n-\n-    fn make_place(self) -> IntermediateBox<T> {\n-        make_place()\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T: ?Sized> Drop for IntermediateBox<T> {\n-    fn drop(&mut self) {\n-        if self.layout.size() > 0 {\n-            unsafe {\n-                Heap.dealloc(self.ptr, self.layout.clone())\n-            }\n-        }\n-    }\n-}\n-\n impl<T> Box<T> {\n     /// Allocates memory on the heap and then places `x` into it.\n     ///\n@@ -508,7 +360,7 @@ impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Hash> Hash for Box<T> {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n@@ -892,7 +744,104 @@ impl<T> Generator for Box<T>\n {\n     type Yield = T::Yield;\n     type Return = T::Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n         (**self).resume()\n     }\n }\n+\n+/// A pinned, heap allocated reference.\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[fundamental]\n+pub struct PinBox<T: ?Sized> {\n+    inner: Box<T>,\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T> PinBox<T> {\n+    /// Allocate memory on the heap, move the data into it and pin it.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn new(data: T) -> PinBox<T> {\n+        PinBox { inner: Box::new(data) }\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> PinBox<T> {\n+    /// Get a pinned reference to the data in this PinBox.\n+    pub fn as_pin<'a>(&'a mut self) -> Pin<'a, T> {\n+        unsafe { Pin::new_unchecked(&mut *self.inner) }\n+    }\n+\n+    /// Get a mutable reference to the data inside this PinBox.\n+    ///\n+    /// This function is unsafe. Users must guarantee that the data is never\n+    /// moved out of this reference.\n+    pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n+        &mut *this.inner\n+    }\n+\n+    /// Convert this PinBox into an unpinned Box.\n+    ///\n+    /// This function is unsafe. Users must guarantee that the data is never\n+    /// moved out of the box.\n+    pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n+        this.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> From<Box<T>> for PinBox<T> {\n+    fn from(boxed: Box<T>) -> PinBox<T> {\n+        PinBox { inner: boxed }\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: Unpin + ?Sized> From<PinBox<T>> for Box<T> {\n+    fn from(pinned: PinBox<T>) -> Box<T> {\n+        pinned.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> Deref for PinBox<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: Unpin + ?Sized> DerefMut for PinBox<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut *self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: fmt::Display + ?Sized> fmt::Display for PinBox<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&*self.inner, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: fmt::Debug + ?Sized> fmt::Debug for PinBox<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&*self.inner, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // It's not possible to extract the inner Uniq directly from the Box,\n+        // instead we cast it to a *const which aliases the Unique\n+        let ptr: *const T = &*self.inner;\n+        fmt::Pointer::fmt(&ptr, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}"}, {"sha": "c604df7049e0c02e10f53809f5c610986200b1a9", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -13,12 +13,12 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, Peekable, FusedIterator};\n use core::marker::PhantomData;\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::Index;\n+use core::ops::RangeBounds;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{Excluded, Included, Unbounded};\n-use range::RangeArgument;\n \n use super::node::{self, Handle, NodeRef, marker};\n use super::search;\n@@ -576,6 +576,33 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Returns the key-value pair corresponding to the supplied key.\n+    ///\n+    /// The supplied key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_get_key_value)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n+    /// assert_eq!(map.get_key_value(&2), None);\n+    /// ```\n+    #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n+        match search::search_tree(self.root.as_ref(), k) {\n+            Found(handle) => Some(handle.into_kv()),\n+            GoDown(_) => None,\n+        }\n+    }\n+\n     /// Returns `true` if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n@@ -777,7 +804,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::Included;\n+    /// use std::ops::Bound::Included;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(3, \"a\");\n@@ -790,7 +817,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n+        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_ref();\n         let root2 = self.root.as_ref();\n@@ -830,7 +857,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n+        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n@@ -1785,7 +1812,7 @@ fn last_leaf_edge<BorrowType, K, V>\n     }\n }\n \n-fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeArgument<Q>>(\n+fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R"}, {"sha": "49109d522e9651bb8e47ee2ff546b7ee9af28479", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -41,14 +41,14 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::heap::{Alloc, Layout};\n use core::marker::PhantomData;\n use core::mem;\n-use core::nonzero::NonZero;\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n use boxed::Box;\n-use heap::{Heap, Alloc, Layout};\n+use heap::Heap;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n@@ -149,14 +149,12 @@ impl<K, V> BoxedNode<K, V> {\n         }\n     }\n \n-    unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new_unchecked(ptr.get() as *mut LeafNode<K, V>) }\n+    unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n+        BoxedNode { ptr: Unique::from(ptr) }\n     }\n \n-    fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n-        unsafe {\n-            NonZero::from(self.ptr.as_ref())\n-        }\n+    fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n+        NonNull::from(self.ptr)\n     }\n }\n \n@@ -276,7 +274,7 @@ impl<K, V> Root<K, V> {\n ///   `NodeRef` could be pointing to either type of node.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n-    node: NonZero<*const LeafNode<K, V>>,\n+    node: NonNull<LeafNode<K, V>>,\n     // This is null unless the borrow type is `Mut`\n     root: *const Root<K, V>,\n     _marker: PhantomData<(BorrowType, Type)>\n@@ -302,15 +300,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(self.node.get() as *const InternalNode<K, V>)\n+            &*(self.node.as_ptr() as *mut InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(self.node.get() as *mut InternalNode<K, V>)\n+            &mut *(self.node.as_ptr() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -352,7 +350,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &*self.node.get()\n+            self.node.as_ref()\n         }\n     }\n \n@@ -382,7 +380,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        if let Some(non_zero) = NonZero::new(self.as_leaf().parent as *const LeafNode<K, V>) {\n+        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n                     height: self.height + 1,\n@@ -498,7 +497,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(self.node.get() as *mut LeafNode<K, V>)\n+            self.node.as_mut()\n         }\n     }\n \n@@ -1241,12 +1240,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Heap.dealloc(\n-                    right_node.node.get() as *mut u8,\n+                    right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Heap.dealloc(\n-                    right_node.node.get() as *mut u8,\n+                    right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "2aad476d3153aead98448a4ddc9c6985df21c4e0", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -16,12 +16,11 @@ use core::cmp::{min, max};\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, FromIterator, FusedIterator};\n-use core::ops::{BitOr, BitAnd, BitXor, Sub};\n+use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n \n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use super::Recover;\n-use range::RangeArgument;\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -240,7 +239,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n-    /// use std::collections::Bound::Included;\n+    /// use std::ops::Bound::Included;\n     ///\n     /// let mut set = BTreeSet::new();\n     /// set.insert(3);\n@@ -253,7 +252,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<T>\n-        where K: Ord, T: Borrow<K>, R: RangeArgument<K>\n+        where K: Ord, T: Borrow<K>, R: RangeBounds<K>\n     {\n         Range { iter: self.map.range(range) }\n     }"}, {"sha": "b2c4582e8406f4b5aaf30bc4fe9812f6083ea525", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -113,6 +113,8 @@\n //!\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n+//! * `x?` \u21d2 [`Debug`] with lower-case hexadecimal integers\n+//! * `X?` \u21d2 [`Debug`] with upper-case hexadecimal integers\n //! * `o` \u21d2 [`Octal`](trait.Octal.html)\n //! * `x` \u21d2 [`LowerHex`](trait.LowerHex.html)\n //! * `X` \u21d2 [`UpperHex`](trait.UpperHex.html)\n@@ -324,7 +326,7 @@\n //! sign := '+' | '-'\n //! width := count\n //! precision := count | '*'\n-//! type := identifier | ''\n+//! type := identifier | '?' | ''\n //! count := parameter | integer\n //! parameter := argument '$'\n //! ```\n@@ -514,17 +516,17 @@ pub use core::fmt::rt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Formatter, Result, Write};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Octal, Binary};\n+pub use core::fmt::{Binary, Octal};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Display, Debug};\n+pub use core::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerHex, UpperHex, Pointer};\n+pub use core::fmt::{LowerHex, Pointer, UpperHex};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::Error;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{ArgumentV1, Arguments, write};\n+pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n@@ -561,7 +563,8 @@ use string;\n pub fn format(args: Arguments) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    output.write_fmt(args)\n-          .expect(\"a formatting trait implementation returned an error\");\n+    output\n+        .write_fmt(args)\n+        .expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "9296a1130718ee37ea8994c1004d58ea7a9883d5", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -19,7 +19,7 @@ use core::intrinsics::{min_align_of_val, size_of_val};\n use core::mem::{self, ManuallyDrop};\n use core::usize;\n \n-pub use allocator::*;\n+pub use core::heap::*;\n #[doc(hidden)]\n pub mod __core {\n     pub use core::*;\n@@ -228,14 +228,6 @@ unsafe impl Alloc for Heap {\n     }\n }\n \n-/// An arbitrary non-null address to represent zero-size allocations.\n-///\n-/// This preserves the non-null invariant for types like `Box<T>`. The address\n-/// may overlap with non-zero-size memory allocations.\n-#[rustc_deprecated(since = \"1.19.0\", reason = \"Use Unique/NonNull::empty() instead\")]\n-#[unstable(feature = \"heap_api\", issue = \"27700\")]\n-pub const EMPTY: *mut () = 1 as *mut ();\n-\n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n #[cfg(not(test))]"}, {"sha": "6ce2547ef6e6d1a8518d9b3835d3331234c0b94b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 14, "deletions": 68, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -76,18 +76,19 @@\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(test, feature(placement_in))]\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n+#![feature(allocator_api)]\n #![feature(allow_internal_unstable)]\n #![feature(ascii_ctype)]\n #![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n@@ -96,37 +97,35 @@\n #![feature(fmt_internals)]\n #![feature(from_ref)]\n #![feature(fundamental)]\n-#![feature(generic_param_attrs)]\n-#![feature(i128_type)]\n-#![feature(inclusive_range)]\n-#![feature(iter_rfold)]\n+#![cfg_attr(stage0, feature(generic_param_attrs))]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![feature(lang_items)]\n #![feature(needs_allocator)]\n #![feature(nonzero)]\n #![feature(offset_to)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n-#![feature(placement_in_syntax)]\n-#![feature(placement_new_protocol)]\n+#![feature(pin)]\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n #![feature(slice_get_slice)]\n-#![feature(slice_patterns)]\n #![feature(slice_rsplit)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(exact_chunks)]\n #![feature(pointer_methods)]\n+#![feature(inclusive_range_fields)]\n \n-#![cfg_attr(not(test), feature(fn_traits, placement_new_protocol, swap_with_slice, i128))]\n-#![cfg_attr(test, feature(test, box_heap))]\n+#![cfg_attr(not(test), feature(fn_traits, swap_with_slice, i128))]\n+#![cfg_attr(test, feature(test))]\n \n // Allow testing this library\n \n@@ -144,9 +143,9 @@ extern crate std_unicode;\n #[macro_use]\n mod macros;\n \n-// Allocator trait and helper struct definitions\n-\n-pub mod allocator;\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"use the heap module in core, alloc, or std instead\")]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+pub use core::heap as allocator;\n \n // Heaps provided for low-level allocation strategies\n \n@@ -156,13 +155,12 @@ pub mod heap;\n \n // Need to conditionally define the mod from `boxed.rs` to avoid\n // duplicating the lang-items when building in test cfg; but also need\n-// to allow code to have `use boxed::HEAP;`\n-// and `use boxed::Box;` declarations.\n+// to allow code to have `use boxed::Box;` declarations.\n #[cfg(not(test))]\n pub mod boxed;\n #[cfg(test)]\n mod boxed {\n-    pub use std::boxed::{Box, IntermediateBox, HEAP};\n+    pub use std::boxed::Box;\n }\n #[cfg(test)]\n mod boxed_test;\n@@ -177,7 +175,6 @@ mod btree;\n pub mod borrow;\n pub mod fmt;\n pub mod linked_list;\n-pub mod range;\n pub mod slice;\n pub mod str;\n pub mod string;\n@@ -203,57 +200,6 @@ mod std {\n     pub use core::ops;      // RangeFull\n }\n \n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// #![feature(collections_range)]\n-///\n-/// use std::collections::range::RangeArgument;\n-/// use std::collections::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-///\n-/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n-/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n-///\n-/// ```\n-/// use std::collections::BTreeMap;\n-/// use std::collections::Bound::{Excluded, Included, Unbounded};\n-///\n-/// let mut map = BTreeMap::new();\n-/// map.insert(3, \"a\");\n-/// map.insert(5, \"b\");\n-/// map.insert(8, \"c\");\n-///\n-/// for (key, value) in map.range((Excluded(3), Included(8))) {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n-/// ```\n-///\n-/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}\n-\n /// An intermediate trait for specialization of `Extend`.\n #[doc(hidden)]\n trait SpecExtend<I: IntoIterator> {"}, {"sha": "129b3bc676432f058912c01ae3e834467ff34b0d", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 2, "deletions": 176, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -28,10 +28,9 @@ use core::hash::{Hasher, Hash};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem;\n-use core::ops::{BoxPlace, InPlace, Place, Placer};\n-use core::ptr::{self, NonNull};\n+use core::ptr::NonNull;\n \n-use boxed::{Box, IntermediateBox};\n+use boxed::Box;\n use super::SpecExtend;\n \n /// A doubly-linked list with owned nodes.\n@@ -786,62 +785,6 @@ impl<T> LinkedList<T> {\n             old_len: old_len,\n         }\n     }\n-\n-    /// Returns a place for insertion at the front of the list.\n-    ///\n-    /// Using this method with placement syntax is equivalent to\n-    /// [`push_front`](#method.push_front), but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list = LinkedList::new();\n-    /// list.front_place() <- 2;\n-    /// list.front_place() <- 4;\n-    /// assert!(list.iter().eq(&[4, 2]));\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"method name and placement protocol are subject to change\",\n-               issue = \"30172\")]\n-    pub fn front_place(&mut self) -> FrontPlace<T> {\n-        FrontPlace {\n-            list: self,\n-            node: IntermediateBox::make_place(),\n-        }\n-    }\n-\n-    /// Returns a place for insertion at the back of the list.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list = LinkedList::new();\n-    /// list.back_place() <- 2;\n-    /// list.back_place() <- 4;\n-    /// assert!(list.iter().eq(&[2, 4]));\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"method name and placement protocol are subject to change\",\n-               issue = \"30172\")]\n-    pub fn back_place(&mut self) -> BackPlace<T> {\n-        BackPlace {\n-            list: self,\n-            node: IntermediateBox::make_place(),\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1242,123 +1185,6 @@ impl<T: Hash> Hash for LinkedList<T> {\n     }\n }\n \n-unsafe fn finalize<T>(node: IntermediateBox<Node<T>>) -> Box<Node<T>> {\n-    let mut node = node.finalize();\n-    ptr::write(&mut node.next, None);\n-    ptr::write(&mut node.prev, None);\n-    node\n-}\n-\n-/// A place for insertion at the front of a `LinkedList`.\n-///\n-/// See [`LinkedList::front_place`](struct.LinkedList.html#method.front_place) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-pub struct FrontPlace<'a, T: 'a> {\n-    list: &'a mut LinkedList<T>,\n-    node: IntermediateBox<Node<T>>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for FrontPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"FrontPlace\")\n-         .field(&self.list)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for FrontPlace<'a, T> {\n-    type Place = Self;\n-\n-    fn make_place(self) -> Self {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for FrontPlace<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).element }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for FrontPlace<'a, T> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        let FrontPlace { list, node } = self;\n-        list.push_front_node(finalize(node));\n-    }\n-}\n-\n-/// A place for insertion at the back of a `LinkedList`.\n-///\n-/// See [`LinkedList::back_place`](struct.LinkedList.html#method.back_place) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-pub struct BackPlace<'a, T: 'a> {\n-    list: &'a mut LinkedList<T>,\n-    node: IntermediateBox<Node<T>>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for BackPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"BackPlace\")\n-         .field(&self.list)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for BackPlace<'a, T> {\n-    type Place = Self;\n-\n-    fn make_place(self) -> Self {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for BackPlace<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).element }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for BackPlace<'a, T> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        let BackPlace { list, node } = self;\n-        list.push_back_node(finalize(node));\n-    }\n-}\n-\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {"}, {"sha": "f862da0d61e012ed816811947a14f3fcab5005a5", "filename": "src/liballoc/range.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,152 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"collections_range\",\n-            reason = \"waiting for dust to settle on inclusive ranges\",\n-            issue = \"30877\")]\n-\n-//! Range syntax.\n-\n-use core::ops::{RangeFull, Range, RangeTo, RangeFrom, RangeInclusive, RangeToInclusive};\n-use Bound::{self, Excluded, Included, Unbounded};\n-\n-/// `RangeArgument` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n-pub trait RangeArgument<T: ?Sized> {\n-    /// Start index bound.\n-    ///\n-    /// Returns the start value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n-    /// # }\n-    /// ```\n-    fn start(&self) -> Bound<&T>;\n-\n-    /// End index bound.\n-    ///\n-    /// Returns the end value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n-    /// # }\n-    /// ```\n-    fn end(&self) -> Bound<&T>;\n-}\n-\n-// FIXME add inclusive ranges to RangeArgument\n-\n-impl<T: ?Sized> RangeArgument<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> RangeArgument<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<T> RangeArgument<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n-        match *self {\n-            (Included(ref start), _) => Included(start),\n-            (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _)           => Unbounded,\n-        }\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        match *self {\n-            (_, Included(ref end)) => Included(end),\n-            (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded)         => Unbounded,\n-        }\n-    }\n-}\n-\n-impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n-        self.0\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        self.1\n-    }\n-}"}, {"sha": "3edce8aebdf39fe5f1da4dc334cc029dd0ac5327", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -9,12 +9,15 @@\n // except according to those terms.\n \n use core::cmp;\n+use core::heap::{Alloc, Layout};\n use core::mem;\n use core::ops::Drop;\n use core::ptr::{self, Unique};\n use core::slice;\n-use heap::{Alloc, Layout, Heap};\n+use heap::Heap;\n use super::boxed::Box;\n+use super::allocator::CollectionAllocErr;\n+use super::allocator::CollectionAllocErr::*;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -84,7 +87,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let elem_size = mem::size_of::<T>();\n \n             let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-            alloc_guard(alloc_size);\n+            alloc_guard(alloc_size).expect(\"capacity overflow\");\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n@@ -308,7 +311,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n-                    alloc_guard(new_size);\n+                    alloc_guard(new_size).expect(\"capacity overflow\");\n                     let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                                  cur,\n                                                  new_layout);\n@@ -367,7 +370,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n-            alloc_guard(new_size);\n+            alloc_guard(new_size).expect(\"capacity overflow\");\n             let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n@@ -403,7 +406,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n+           -> Result<(), CollectionAllocErr> {\n+\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -413,43 +418,50 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity.\n             // Wrapping in case they gave a bad `used_cap`.\n             if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return;\n+                return Ok(());\n             }\n \n             // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n-            let new_layout = match Layout::array::<T>(new_cap) {\n-                Some(layout) => layout,\n-                None => panic!(\"capacity overflow\"),\n-            };\n-            alloc_guard(new_layout.size());\n+            let new_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n+            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+\n+            alloc_guard(new_layout.size())?;\n+\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n                     self.a.realloc(old_ptr, layout, new_layout)\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n-            let uniq = match res {\n-                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n-                Err(e) => self.a.oom(e),\n-            };\n-            self.ptr = uniq;\n+\n+            self.ptr = Unique::new_unchecked(res? as *mut T);\n             self.cap = new_cap;\n+\n+            Ok(())\n         }\n     }\n \n+    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        match self.try_reserve_exact(used_cap, needed_extra_cap) {\n+            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(AllocErr(e)) => self.a.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+     }\n+\n     /// Calculates the buffer's new size given that it'll hold `used_cap +\n     /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> usize {\n+    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<usize, CollectionAllocErr> {\n+\n         // Nothing we can really do about these checks :(\n-        let required_cap = used_cap.checked_add(needed_extra_cap)\n-            .expect(\"capacity overflow\");\n+        let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n-        cmp::max(double_cap, required_cap)\n+        Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -504,8 +516,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        unsafe {\n+    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<(), CollectionAllocErr> {\n+         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -514,33 +527,38 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity.\n             // Wrapping in case they give a bad `used_cap`\n             if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return;\n+               return Ok(());\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n+            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+\n+             // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size())?;\n \n-            let new_layout = match Layout::array::<T>(new_cap) {\n-                Some(layout) => layout,\n-                None => panic!(\"capacity overflow\"),\n-            };\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size());\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n                     self.a.realloc(old_ptr, layout, new_layout)\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n-            let uniq = match res {\n-                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n-                Err(e) => self.a.oom(e),\n-            };\n-            self.ptr = uniq;\n+\n+            self.ptr = Unique::new_unchecked(res? as *mut T);\n             self.cap = new_cap;\n+\n+            Ok(())\n         }\n     }\n \n+    /// The same as try_reserve, but errors are lowered to a call to oom().\n+    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        match self.try_reserve(used_cap, needed_extra_cap) {\n+            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(AllocErr(e)) => self.a.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+     }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -576,7 +594,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n+                              .expect(\"capacity overflow\");\n \n             // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n             // (regardless of whether `self.cap - used_cap` wrapped).\n@@ -585,7 +604,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size());\n+            alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -709,14 +728,14 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g. PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) {\n-    if mem::size_of::<usize>() < 8 {\n-        assert!(alloc_size <= ::core::isize::MAX as usize,\n-                \"capacity overflow\");\n+fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+    if mem::size_of::<usize>() < 8 && alloc_size > ::core::isize::MAX as usize {\n+        Err(CapacityOverflow)\n+    } else {\n+        Ok(())\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "8bdc57f96a6d5c7dda2f334ebe75987f74ec7771", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -250,6 +250,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n+use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n@@ -259,7 +260,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout, box_free};\n+use heap::{Heap, box_free};\n use string::String;\n use vec::Vec;\n "}, {"sha": "68f2313843c313e0982ad607d9885d7b3cb4b0a5", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -102,6 +102,7 @@ use core::mem::size_of;\n use core::mem;\n use core::ptr;\n use core::slice as core_slice;\n+use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n use boxed::Box;\n@@ -1302,7 +1303,8 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n log(m n))`\n+    /// worst-case, where the key function is `O(m)`.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -1328,12 +1330,82 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n-    pub fn sort_by_key<B, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> B, B: Ord\n+    pub fn sort_by_key<K, F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Sorts the slice with a key extraction function.\n+    ///\n+    /// During sorting, the key function is called only once per element.\n+    ///\n+    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n + n log n)`\n+    /// worst-case, where the key function is `O(m)`.\n+    ///\n+    /// For simple key functions (e.g. functions that are property accesses or\n+    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n+    /// faster.\n+    ///\n+    /// # Current implementation\n+    ///\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n+    ///\n+    /// In the worst case, the algorithm allocates temporary storage in a `Vec<(K, usize)>` the\n+    /// length of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_sort_by_cached_key)]\n+    /// let mut v = [-5i32, 4, 32, -3, 2];\n+    ///\n+    /// v.sort_by_cached_key(|k| k.to_string());\n+    /// assert!(v == [-3, -5, 2, 32, 4]);\n+    /// ```\n+    ///\n+    /// [pdqsort]: https://github.com/orlp/pdqsort\n+    #[unstable(feature = \"slice_sort_by_cached_key\", issue = \"34447\")]\n+    #[inline]\n+    pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n+    {\n+        // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n+        macro_rules! sort_by_key {\n+            ($t:ty, $slice:ident, $f:ident) => ({\n+                let mut indices: Vec<_> =\n+                    $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n+                // The elements of `indices` are unique, as they are indexed, so any sort will be\n+                // stable with respect to the original slice. We use `sort_unstable` here because\n+                // it requires less memory allocation.\n+                indices.sort_unstable();\n+                for i in 0..$slice.len() {\n+                    let mut index = indices[i].1;\n+                    while (index as usize) < i {\n+                        index = indices[index as usize].1;\n+                    }\n+                    indices[i].1 = index;\n+                    $slice.swap(i, index as usize);\n+                }\n+            })\n+        }\n+\n+        let sz_u8    = mem::size_of::<(K, u8)>();\n+        let sz_u16   = mem::size_of::<(K, u16)>();\n+        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_usize = mem::size_of::<(K, usize)>();\n+\n+        let len = self.len();\n+        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n+        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        sort_by_key!(usize, self, f)\n+    }\n+\n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n@@ -1410,7 +1482,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n     ///\n     /// # Current implementation\n     ///\n@@ -1420,9 +1492,6 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n-    /// slice consists of several concatenated sorted sequences.\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1435,9 +1504,8 @@ impl<T> [T] {\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> B,\n-              B: Ord\n+    pub fn sort_unstable_by_key<K, F>(&mut self, f: F)\n+        where F: FnMut(&T) -> K, K: Ord\n     {\n         core_slice::SliceExt::sort_unstable_by_key(self, f);\n     }"}, {"sha": "d5ef41df0d850d5804299a328f617f411f3abdd2", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -2122,6 +2122,48 @@ impl str {\n         unsafe { String::from_utf8_unchecked(buf) }\n     }\n \n+    /// Returns true if this `str` is entirely whitespace, and false otherwise.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n+    /// Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert!(\"    \\t \".is_whitespace());\n+    ///\n+    /// // a non-breaking space\n+    /// assert!(\"\\u{A0}\".is_whitespace());\n+    ///\n+    /// assert!(!\"   \u8d8a\".is_whitespace());\n+    /// ```\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn is_whitespace(&self) -> bool {\n+        UnicodeStr::is_whitespace(self)\n+    }\n+\n+    /// Returns true if this `str` is entirely alphanumeric, and false otherwise.\n+    ///\n+    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert!(\"\u06637\u09ecK\u0648\u85cf\".is_alphanumeric());\n+    /// assert!(!\"\u00be\u2460\".is_alphanumeric());\n+    /// ```\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    #[inline]\n+    pub fn is_alphanumeric(&self) -> bool {\n+        UnicodeStr::is_alphanumeric(self)\n+    }\n+\n     /// Checks if all characters in this string are within the ASCII range.\n     ///\n     /// # Examples"}, {"sha": "b95aae02894ed758e1ba8acb86b716daceeeb673", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 117, "deletions": 20, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -59,18 +59,18 @@\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::str::pattern::Pattern;\n use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n-use range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n+use super::allocator::CollectionAllocErr;\n \n /// A UTF-8 encoded, growable string.\n ///\n@@ -920,6 +920,79 @@ impl String {\n         self.vec.reserve_exact(additional)\n     }\n \n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `String`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    ///     let mut output = String::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.push_str(data);\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.vec.try_reserve(additional)\n+    }\n+\n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `String`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    ///     let mut output = String::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.push_str(data);\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.vec.try_reserve_exact(additional)\n+    }\n+\n     /// Shrinks the capacity of this `String` to match its length.\n     ///\n     /// # Examples\n@@ -941,6 +1014,34 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n+    /// Shrinks the capacity of this `String` with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// let mut s = String::from(\"foo\");\n+    ///\n+    /// s.reserve(100);\n+    /// assert!(s.capacity() >= 100);\n+    ///\n+    /// s.shrink_to(10);\n+    /// assert!(s.capacity() >= 10);\n+    /// s.shrink_to(0);\n+    /// assert!(s.capacity() >= 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.vec.shrink_to(min_capacity)\n+    }\n+\n     /// Appends the given [`char`] to the end of this `String`.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n@@ -1103,16 +1204,14 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(string_retain)]\n-    ///\n     /// let mut s = String::from(\"f_o_ob_ar\");\n     ///\n     /// s.retain(|c| c != '_');\n     ///\n     /// assert_eq!(s, \"foobar\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"string_retain\", issue = \"43874\")]\n+    #[stable(feature = \"string_retain\", since = \"1.26.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(char) -> bool\n     {\n@@ -1384,7 +1483,7 @@ impl String {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1418,7 +1517,7 @@ impl String {\n         }\n     }\n \n-    /// Creates a splicing iterator that removes the specified range in the string,\n+    /// Removes the specified range in the string,\n     /// and replaces it with the given string.\n     /// The given string doesn't need to be the same length as the range.\n     ///\n@@ -1438,21 +1537,20 @@ impl String {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(splice)]\n     /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n     ///\n     /// // Replace the range up until the \u03b2 from the string\n-    /// s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n+    /// s.replace_range(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n-    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"44643\")]\n-    pub fn splice<R>(&mut self, range: R, replace_with: &str)\n-        where R: RangeArgument<usize>\n+    #[stable(feature = \"splice\", since = \"1.27.0\")]\n+    pub fn replace_range<R>(&mut self, range: R, replace_with: &str)\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n-        // The String version of Splice does not have the memory safety issues\n+        // Replace_range does not have the memory safety issues of a vector Splice.\n         // of the vector version. The data is just plain bytes.\n \n         match range.start() {\n@@ -1502,15 +1600,14 @@ impl FromUtf8Error {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(from_utf8_error_as_bytes)]\n     /// // some invalid bytes, in a vector\n     /// let bytes = vec![0, 159];\n     ///\n     /// let value = String::from_utf8(bytes);\n     ///\n     /// assert_eq!(&[0, 159], value.unwrap_err().as_bytes());\n     /// ```\n-    #[unstable(feature = \"from_utf8_error_as_bytes\", reason = \"recently added\", issue = \"40895\")]\n+    #[stable(feature = \"from_utf8_error_as_bytes\", since = \"1.26.0\")]\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }\n@@ -1876,7 +1973,7 @@ impl ops::Index<ops::RangeFull> for String {\n         unsafe { str::from_utf8_unchecked(&self.vec) }\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::Index<ops::RangeInclusive<usize>> for String {\n     type Output = str;\n \n@@ -1885,7 +1982,7 @@ impl ops::Index<ops::RangeInclusive<usize>> for String {\n         Index::index(&**self, index)\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::Index<ops::RangeToInclusive<usize>> for String {\n     type Output = str;\n \n@@ -1923,14 +2020,14 @@ impl ops::IndexMut<ops::RangeFull> for String {\n         unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {"}, {"sha": "8494463463cb941fa7873097ede52783ba4c5910", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::panic;\n+use std::cmp;\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n+use std::panic::{self, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+use rand::{thread_rng, Rng};\n \n #[test]\n fn test_iterator() {\n@@ -274,29 +278,86 @@ fn test_extend_specialization() {\n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n \n-#[test]\n-fn test_placement() {\n-    let mut a = BinaryHeap::new();\n-    &mut a <- 2;\n-    &mut a <- 4;\n-    &mut a <- 3;\n-    assert_eq!(a.peek(), Some(&4));\n-    assert_eq!(a.len(), 3);\n-    &mut a <- 1;\n-    assert_eq!(a.into_sorted_vec(), vec![1, 2, 3, 4]);\n-}\n-\n-#[test]\n-fn test_placement_panic() {\n-    let mut heap = BinaryHeap::from(vec![1, 2, 3]);\n-    fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { &mut heap <- mkpanic(); }));\n-    assert_eq!(heap.len(), 3);\n-}\n-\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n         d\n     }\n }\n+\n+// old binaryheap failed this test\n+//\n+// Integrity means that all elements are present after a comparison panics,\n+// even if the order may not be correct.\n+//\n+// Destructors must be called exactly once per element.\n+#[test]\n+fn panic_safe() {\n+    static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+    #[derive(Eq, PartialEq, Ord, Clone, Debug)]\n+    struct PanicOrd<T>(T, bool);\n+\n+    impl<T> Drop for PanicOrd<T> {\n+        fn drop(&mut self) {\n+            // update global drop count\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    impl<T: PartialOrd> PartialOrd for PanicOrd<T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+            if self.1 || other.1 {\n+                panic!(\"Panicking comparison\");\n+            }\n+            self.0.partial_cmp(&other.0)\n+        }\n+    }\n+    let mut rng = thread_rng();\n+    const DATASZ: usize = 32;\n+    const NTEST: usize = 10;\n+\n+    // don't use 0 in the data -- we want to catch the zeroed-out case.\n+    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n+\n+    // since it's a fuzzy test, run several tries.\n+    for _ in 0..NTEST {\n+        for i in 1..DATASZ + 1 {\n+            DROP_COUNTER.store(0, Ordering::SeqCst);\n+\n+            let mut panic_ords: Vec<_> = data.iter()\n+                                             .filter(|&&x| x != i)\n+                                             .map(|&x| PanicOrd(x, false))\n+                                             .collect();\n+            let panic_item = PanicOrd(i, true);\n+\n+            // heapify the sane items\n+            rng.shuffle(&mut panic_ords);\n+            let mut heap = BinaryHeap::from(panic_ords);\n+            let inner_data;\n+\n+            {\n+                // push the panicking item to the heap and catch the panic\n+                let thread_result = {\n+                    let mut heap_ref = AssertUnwindSafe(&mut heap);\n+                    panic::catch_unwind(move || {\n+                        heap_ref.push(panic_item);\n+                    })\n+                };\n+                assert!(thread_result.is_err());\n+\n+                // Assert no elements were dropped\n+                let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+                assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n+                inner_data = heap.clone().into_vec();\n+                drop(heap);\n+            }\n+            let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+            assert_eq!(drops, DATASZ);\n+\n+            let mut data_sorted = inner_data.into_iter().map(|p| p.0).collect::<Vec<_>>();\n+            data_sorted.sort();\n+            assert_eq!(data_sorted, data);\n+        }\n+    }\n+}"}, {"sha": "6ebdb86cc4a9865a42bdde87419e87503ef249f0", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use std::collections::BTreeMap;\n-use std::collections::Bound::{self, Excluded, Included, Unbounded};\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n+use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::rc::Rc;\n \n use std::iter::FromIterator;"}, {"sha": "1a49fb9964ad727ef7c765c185f8024c35e56764", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -14,21 +14,22 @@\n #![feature(alloc_system)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n-#![feature(inclusive_range_syntax)]\n-#![feature(collection_placement)]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n #![feature(pattern)]\n-#![feature(placement_in_syntax)]\n #![feature(rand)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(splice)]\n #![feature(str_escape)]\n #![feature(string_retain)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(exact_chunks)]\n+#![feature(inclusive_range_fields)]\n \n extern crate alloc_system;\n extern crate std_unicode;"}, {"sha": "99d9c51efc75790c2e552c89d6490423445a2292", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 181, "deletions": 3, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -8,9 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cell::Cell;\n use std::cmp::Ordering::{Equal, Greater, Less};\n+use std::cmp::Ordering;\n use std::mem;\n+use std::panic;\n use std::rc::Rc;\n+use std::sync::atomic::Ordering::Relaxed;\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n+use std::thread;\n \n use rand::{Rng, thread_rng};\n \n@@ -419,6 +425,14 @@ fn test_sort() {\n                 v.sort_by(|a, b| b.cmp(a));\n                 assert!(v.windows(2).all(|w| w[0] >= w[1]));\n \n+                // Sort in lexicographic order.\n+                let mut v1 = orig.clone();\n+                let mut v2 = orig.clone();\n+                v1.sort_by_key(|x| x.to_string());\n+                v2.sort_by_cached_key(|x| x.to_string());\n+                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                assert!(v1 == v2);\n+\n                 // Sort with many pre-sorted runs.\n                 let mut v = orig.clone();\n                 v.sort();\n@@ -471,24 +485,29 @@ fn test_sort_stability() {\n             // the second item represents which occurrence of that\n             // number this element is, i.e. the second elements\n             // will occur in sorted order.\n-            let mut v: Vec<_> = (0..len)\n+            let mut orig: Vec<_> = (0..len)\n                 .map(|_| {\n                     let n = thread_rng().gen::<usize>() % 10;\n                     counts[n] += 1;\n                     (n, counts[n])\n                 })\n                 .collect();\n \n-            // only sort on the first element, so an unstable sort\n+            let mut v = orig.clone();\n+            // Only sort on the first element, so an unstable sort\n             // may mix up the counts.\n             v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n-            // this comparison includes the count (the second item\n+            // This comparison includes the count (the second item\n             // of the tuple), so elements with equal first items\n             // will need to be ordered with increasing\n             // counts... i.e. exactly asserting that this sort is\n             // stable.\n             assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+            let mut v = orig.clone();\n+            v.sort_by_cached_key(|&(x, _)| x);\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n         }\n     }\n }\n@@ -1341,3 +1360,162 @@ fn test_copy_from_slice_dst_shorter() {\n     let mut dst = [0; 3];\n     dst.copy_from_slice(&src);\n }\n+\n+const MAX_LEN: usize = 80;\n+\n+static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n+    // FIXME(RFC 1109): AtomicUsize is not Copy.\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+    AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n+];\n+\n+static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+#[derive(Clone, Eq)]\n+struct DropCounter {\n+    x: u32,\n+    id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n+    }\n+}\n+\n+macro_rules! test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n+\n+            let v = $input.to_owned();\n+            let _ = thread::spawn(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            }).join();\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e. the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1,\n+                        \"found drop count == {} for i == {}, len == {}\",\n+                        count, i, len);\n+            }\n+\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n+        }\n+    }\n+}\n+\n+thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+fn panic_safe() {\n+    let prev = panic::take_hook();\n+    panic::set_hook(Box::new(move |info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    }));\n+\n+    let mut rng = thread_rng();\n+\n+    for len in (1..20).chain(70..MAX_LEN) {\n+        for &modulus in &[5, 20, 50] {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| {\n+                        DropCounter {\n+                            x: rng.next_u32() % modulus,\n+                            id: id,\n+                            version: Cell::new(0),\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n+                }\n+\n+                test!(input, sort_by);\n+                test!(input, sort_unstable_by);\n+            }\n+        }\n+    }\n+}"}, {"sha": "cb4a17a22d8a4aa867a2676ff55c53eb06f51d64", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 178, "deletions": 15, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n use std::borrow::Cow;\n+use std::collections::CollectionAllocErr::*;\n+use std::mem::size_of;\n+use std::{usize, isize};\n \n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B>;\n@@ -440,53 +443,53 @@ fn test_drain() {\n }\n \n #[test]\n-fn test_splice() {\n+fn test_replace_range() {\n     let mut s = \"Hello, world!\".to_owned();\n-    s.splice(7..12, \"\u4e16\u754c\");\n+    s.replace_range(7..12, \"\u4e16\u754c\");\n     assert_eq!(s, \"Hello, \u4e16\u754c!\");\n }\n \n #[test]\n #[should_panic]\n-fn test_splice_char_boundary() {\n+fn test_replace_range_char_boundary() {\n     let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n-    s.splice(..8, \"\");\n+    s.replace_range(..8, \"\");\n }\n \n #[test]\n-fn test_splice_inclusive_range() {\n+fn test_replace_range_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    v.splice(2..=3, \"789\");\n+    v.replace_range(2..=3, \"789\");\n     assert_eq!(v, \"127895\");\n-    v.splice(1..=2, \"A\");\n+    v.replace_range(1..=2, \"A\");\n     assert_eq!(v, \"1A895\");\n }\n \n #[test]\n #[should_panic]\n-fn test_splice_out_of_bounds() {\n+fn test_replace_range_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n-    s.splice(5..6, \"789\");\n+    s.replace_range(5..6, \"789\");\n }\n \n #[test]\n #[should_panic]\n-fn test_splice_inclusive_out_of_bounds() {\n+fn test_replace_range_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n-    s.splice(5..=5, \"789\");\n+    s.replace_range(5..=5, \"789\");\n }\n \n #[test]\n-fn test_splice_empty() {\n+fn test_replace_range_empty() {\n     let mut s = String::from(\"12345\");\n-    s.splice(1..2, \"\");\n+    s.replace_range(1..2, \"\");\n     assert_eq!(s, \"1345\");\n }\n \n #[test]\n-fn test_splice_unbounded() {\n+fn test_replace_range_unbounded() {\n     let mut s = String::from(\"12345\");\n-    s.splice(.., \"\");\n+    s.replace_range(.., \"\");\n     assert_eq!(s, \"\");\n }\n \n@@ -504,3 +507,163 @@ fn test_into_boxed_str() {\n     let ys = xs.into_boxed_str();\n     assert_eq!(&*ys, \"hello my name is bob\");\n }\n+\n+#[test]\n+fn test_reserve_exact() {\n+    // This is all the same as test_reserve\n+\n+    let mut s = String::new();\n+    assert_eq!(s.capacity(), 0);\n+\n+    s.reserve_exact(2);\n+    assert!(s.capacity() >= 2);\n+\n+    for _i in 0..16 {\n+        s.push('0');\n+    }\n+\n+    assert!(s.capacity() >= 16);\n+    s.reserve_exact(16);\n+    assert!(s.capacity() >= 32);\n+\n+    s.push('0');\n+\n+    s.reserve_exact(16);\n+    assert!(s.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_string: String = String::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX + 1 is an OOM\n+            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            // Check usize::MAX is an OOM\n+            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: String = String::from(\"0123456789\");\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_string: String = String::new();\n+\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: String = String::from(\"0123456789\");\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "2895c53009d9ac9fae260e910bb5d148f34fc321", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 208, "deletions": 19, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -10,8 +10,9 @@\n \n use std::borrow::Cow;\n use std::mem::size_of;\n-use std::panic;\n+use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n+use std::collections::CollectionAllocErr::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -752,24 +753,6 @@ fn assert_covariance() {\n     }\n }\n \n-#[test]\n-fn test_placement() {\n-    let mut vec = vec![1];\n-    assert_eq!(vec.place_back() <- 2, &2);\n-    assert_eq!(vec.len(), 2);\n-    assert_eq!(vec.place_back() <- 3, &3);\n-    assert_eq!(vec.len(), 3);\n-    assert_eq!(&vec, &[1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_placement_panic() {\n-    let mut vec = vec![1, 2, 3];\n-    fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { vec.place_back() <- mkpanic(); }));\n-    assert_eq!(vec.len(), 3);\n-}\n-\n #[test]\n fn from_into_inner() {\n     let vec = vec![1, 2, 3];\n@@ -965,3 +948,209 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n }\n+\n+#[test]\n+fn test_reserve_exact() {\n+    // This is all the same as test_reserve\n+\n+    let mut v = Vec::new();\n+    assert_eq!(v.capacity(), 0);\n+\n+    v.reserve_exact(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push(16);\n+\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_bytes: Vec<u8> = Vec::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX + 1 is an OOM\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            // Check usize::MAX is an OOM\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with interesting type size\n+        let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should fail in the mul-by-size\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_bytes: Vec<u8> = Vec::new();\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "75d3f01f8b601c0a930008dc42d92ef3dc75ac6c", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 199, "deletions": 13, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -11,6 +11,9 @@\n use std::collections::VecDeque;\n use std::fmt::Debug;\n use std::collections::vec_deque::{Drain};\n+use std::collections::CollectionAllocErr::*;\n+use std::mem::size_of;\n+use std::{usize, isize};\n \n use self::Taggy::*;\n use self::Taggypar::*;\n@@ -1002,23 +1005,206 @@ fn test_is_empty() {\n }\n \n #[test]\n-fn test_placement_in() {\n-    let mut buf: VecDeque<isize> = VecDeque::new();\n-    buf.place_back() <- 1;\n-    buf.place_back() <- 2;\n-    assert_eq!(buf, [1,2]);\n+fn test_reserve_exact_2() {\n+    // This is all the same as test_reserve\n \n-    buf.place_front() <- 3;\n-    buf.place_front() <- 4;\n-    assert_eq!(buf, [4,3,1,2]);\n+    let mut v = VecDeque::new();\n+\n+    v.reserve_exact(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push_back(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push_back(16);\n+\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 48)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n \n     {\n-        let ptr_head = buf.place_front() <- 5;\n-        assert_eq!(*ptr_head, 5);\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX is an OOM\n+            // VecDeque starts with capacity 7, always adds 1 to the capacity\n+            // and also rounds the number to next power of 2 so this is the\n+            // furthest we can go without triggering CapacityOverflow\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n     }\n+\n+\n     {\n-        let ptr_tail = buf.place_back() <- 6;\n-        assert_eq!(*ptr_tail, 6);\n+        // Same basic idea, but with interesting type size\n+        let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should fail in the mul-by-size\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n     }\n-    assert_eq!(buf, [5,4,3,1,2,6]);\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX is an OOM\n+            // VecDeque starts with capacity 7, always adds 1 to the capacity\n+            // and also rounds the number to next power of 2 so this is the\n+            // furthest we can go without triggering CapacityOverflow\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n }"}, {"sha": "4b883b5bce79bd48f714b5442340696024eea662", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 236, "deletions": 121, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -66,7 +66,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::cmp::Ordering;\n+use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n@@ -75,7 +75,8 @@ use core::marker::PhantomData;\n use core::mem;\n #[cfg(not(test))]\n use core::num::Float;\n-use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{Index, IndexMut, RangeBounds};\n use core::ops;\n use core::ptr;\n use core::ptr::NonNull;\n@@ -85,8 +86,7 @@ use borrow::ToOwned;\n use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n-use super::range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n+use super::allocator::CollectionAllocErr;\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n@@ -333,9 +333,10 @@ impl<T> Vec<T> {\n     /// The vector will be able to hold exactly `capacity` elements without\n     /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n-    /// It is important to note that this function does not specify the *length*\n-    /// of the returned vector, but only the *capacity*. For an explanation of\n-    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n+    /// It is important to note that although the returned vector has the\n+    /// *capacity* specified, the vector will have a zero *length*. For an\n+    /// explanation of the difference between length and capacity, see\n+    /// *[Capacity and reallocation]*.\n     ///\n     /// [Capacity and reallocation]: #capacity-and-reallocation\n     ///\n@@ -489,6 +490,83 @@ impl<T> Vec<T> {\n         self.buf.reserve_exact(self.len, additional);\n     }\n \n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    ///     let mut output = Vec::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.buf.try_reserve(self.len, additional)\n+    }\n+\n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    ///     let mut output = Vec::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.buf.try_reserve_exact(self.len, additional)\n+    }\n+\n     /// Shrinks the capacity of the vector as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator\n@@ -508,6 +586,31 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n+    /// Shrinks the capacity of the vector with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// let mut vec = Vec::with_capacity(10);\n+    /// vec.extend([1, 2, 3].iter().cloned());\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// vec.shrink_to(4);\n+    /// assert!(vec.capacity() >= 4);\n+    /// vec.shrink_to(0);\n+    /// assert!(vec.capacity() >= 3);\n+    /// ```\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.buf.shrink_to_fit(cmp::max(self.len, min_capacity));\n+    }\n+\n     /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n     /// Note that this will drop any excess capacity.\n@@ -962,29 +1065,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Returns a place for insertion at the back of the `Vec`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// let mut vec = vec![1, 2];\n-    /// vec.place_back() <- 3;\n-    /// vec.place_back() <- 4;\n-    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec: self }\n-    }\n-\n     /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n@@ -1072,7 +1152,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1203,6 +1283,49 @@ impl<T> Vec<T> {\n         }\n         other\n     }\n+\n+    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n+    ///\n+    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n+    /// difference, with each additional slot filled with the result of\n+    /// calling the closure `f`. The return values from `f` will end up\n+    /// in the `Vec` in the order they have been generated.\n+    ///\n+    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n+    ///\n+    /// This method uses a closure to create new values on every push. If\n+    /// you'd rather [`Clone`] a given value, use [`resize`]. If you want\n+    /// to use the [`Default`] trait to generate values, you can pass\n+    /// [`Default::default()`] as the second argument..\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_resize_with)]\n+    ///\n+    /// let mut vec = vec![1, 2, 3];\n+    /// vec.resize_with(5, Default::default);\n+    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n+    ///\n+    /// let mut vec = vec![];\n+    /// let mut p = 1;\n+    /// vec.resize_with(4, || { p *= 2; p });\n+    /// assert_eq!(vec, [2, 4, 8, 16]);\n+    /// ```\n+    ///\n+    /// [`resize`]: #method.resize\n+    /// [`Clone`]: ../../std/clone/trait.Clone.html\n+    #[unstable(feature = \"vec_resize_with\", issue = \"41758\")]\n+    pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n+        where F: FnMut() -> T\n+    {\n+        let len = self.len();\n+        if new_len > len {\n+            self.extend_with(new_len - len, ExtendFunc(f));\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n }\n \n impl<T: Clone> Vec<T> {\n@@ -1212,8 +1335,9 @@ impl<T: Clone> Vec<T> {\n     /// difference, with each additional slot filled with `value`.\n     /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n     ///\n-    /// This method requires `Clone` to clone the passed value. If you'd\n-    /// rather create a value with `Default` instead, see [`resize_default`].\n+    /// This method requires [`Clone`] to be able clone the passed value. If\n+    /// you need more flexibility (or want to rely on [`Default`] instead of\n+    /// [`Clone`]), use [`resize_with`].\n     ///\n     /// # Examples\n     ///\n@@ -1227,7 +1351,9 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n     ///\n-    /// [`resize_default`]: #method.resize_default\n+    /// [`Clone`]: ../../std/clone/trait.Clone.html\n+    /// [`Default`]: ../../std/default/trait.Default.html\n+    /// [`resize_with`]: #method.resize_with\n     #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n@@ -1244,7 +1370,7 @@ impl<T: Clone> Vec<T> {\n     /// Iterates over the slice `other`, clones each element, and then appends\n     /// it to this `Vec`. The `other` vector is traversed in-order.\n     ///\n-    /// Note that this function is same as `extend` except that it is\n+    /// Note that this function is same as [`extend`] except that it is\n     /// specialized to work with slices instead. If and when Rust gets\n     /// specialization this function will likely be deprecated (but still\n     /// available).\n@@ -1256,6 +1382,8 @@ impl<T: Clone> Vec<T> {\n     /// vec.extend_from_slice(&[2, 3, 4]);\n     /// assert_eq!(vec, [1, 2, 3, 4]);\n     /// ```\n+    ///\n+    /// [`extend`]: #method.extend\n     #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n@@ -1266,12 +1394,11 @@ impl<T: Default> Vec<T> {\n     /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n     ///\n     /// If `new_len` is greater than `len`, the `Vec` is extended by the\n-    /// difference, with each additional slot filled with `Default::default()`.\n+    /// difference, with each additional slot filled with [`Default::default()`].\n     /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n     ///\n-    /// This method uses `Default` to create new values on every push. If\n-    /// you'd rather `Clone` a given value, use [`resize`].\n-    ///\n+    /// This method uses [`Default`] to create new values on every push. If\n+    /// you'd rather [`Clone`] a given value, use [`resize`].\n     ///\n     /// # Examples\n     ///\n@@ -1288,6 +1415,9 @@ impl<T: Default> Vec<T> {\n     /// ```\n     ///\n     /// [`resize`]: #method.resize\n+    /// [`Default::default()`]: ../../std/default/trait.Default.html#tymethod.default\n+    /// [`Default`]: ../../std/default/trait.Default.html\n+    /// [`Clone`]: ../../std/clone/trait.Clone.html\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n     pub fn resize_default(&mut self, new_len: usize) {\n         let len = self.len();\n@@ -1302,24 +1432,31 @@ impl<T: Default> Vec<T> {\n \n // This code generalises `extend_with_{element,default}`.\n trait ExtendWith<T> {\n-    fn next(&self) -> T;\n+    fn next(&mut self) -> T;\n     fn last(self) -> T;\n }\n \n struct ExtendElement<T>(T);\n impl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n-    fn next(&self) -> T { self.0.clone() }\n+    fn next(&mut self) -> T { self.0.clone() }\n     fn last(self) -> T { self.0 }\n }\n \n struct ExtendDefault;\n impl<T: Default> ExtendWith<T> for ExtendDefault {\n-    fn next(&self) -> T { Default::default() }\n+    fn next(&mut self) -> T { Default::default() }\n     fn last(self) -> T { Default::default() }\n }\n+\n+struct ExtendFunc<F>(F);\n+impl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n+    fn next(&mut self) -> T { (self.0)() }\n+    fn last(mut self) -> T { (self.0)() }\n+}\n+\n impl<T> Vec<T> {\n     /// Extend the vector by `n` values, using the given generator.\n-    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E) {\n+    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n         self.reserve(n);\n \n         unsafe {\n@@ -1457,40 +1594,69 @@ impl SpecFromElem for u8 {\n     }\n }\n \n-macro_rules! impl_spec_from_elem {\n+impl<T: Clone + IsZero> SpecFromElem for T {\n+    #[inline]\n+    fn from_elem(elem: T, n: usize) -> Vec<T> {\n+        if elem.is_zero() {\n+            return Vec {\n+                buf: RawVec::with_capacity_zeroed(n),\n+                len: n,\n+            }\n+        }\n+        let mut v = Vec::with_capacity(n);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}\n+\n+unsafe trait IsZero {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n     ($t: ty, $is_zero: expr) => {\n-        impl SpecFromElem for $t {\n+        unsafe impl IsZero for $t {\n             #[inline]\n-            fn from_elem(elem: $t, n: usize) -> Vec<$t> {\n-                if $is_zero(elem) {\n-                    return Vec {\n-                        buf: RawVec::with_capacity_zeroed(n),\n-                        len: n,\n-                    }\n-                }\n-                let mut v = Vec::with_capacity(n);\n-                v.extend_with(n, ExtendElement(elem));\n-                v\n+            fn is_zero(&self) -> bool {\n+                $is_zero(*self)\n             }\n         }\n-    };\n+    }\n }\n \n-impl_spec_from_elem!(i8, |x| x == 0);\n-impl_spec_from_elem!(i16, |x| x == 0);\n-impl_spec_from_elem!(i32, |x| x == 0);\n-impl_spec_from_elem!(i64, |x| x == 0);\n-impl_spec_from_elem!(i128, |x| x == 0);\n-impl_spec_from_elem!(isize, |x| x == 0);\n+impl_is_zero!(i8, |x| x == 0);\n+impl_is_zero!(i16, |x| x == 0);\n+impl_is_zero!(i32, |x| x == 0);\n+impl_is_zero!(i64, |x| x == 0);\n+impl_is_zero!(i128, |x| x == 0);\n+impl_is_zero!(isize, |x| x == 0);\n+\n+impl_is_zero!(u16, |x| x == 0);\n+impl_is_zero!(u32, |x| x == 0);\n+impl_is_zero!(u64, |x| x == 0);\n+impl_is_zero!(u128, |x| x == 0);\n+impl_is_zero!(usize, |x| x == 0);\n+\n+impl_is_zero!(char, |x| x == '\\0');\n+\n+impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n+impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n+\n+unsafe impl<T: ?Sized> IsZero for *const T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n \n-impl_spec_from_elem!(u16, |x| x == 0);\n-impl_spec_from_elem!(u32, |x| x == 0);\n-impl_spec_from_elem!(u64, |x| x == 0);\n-impl_spec_from_elem!(u128, |x| x == 0);\n-impl_spec_from_elem!(usize, |x| x == 0);\n+unsafe impl<T: ?Sized> IsZero for *mut T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n \n-impl_spec_from_elem!(f32, |x: f32| x == 0. && x.is_sign_positive());\n-impl_spec_from_elem!(f64, |x: f64| x == 0. && x.is_sign_positive());\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n@@ -1839,7 +2005,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n-        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n+        where R: RangeBounds<usize>, I: IntoIterator<Item=T>\n     {\n         Splice {\n             drain: self.drain(range),\n@@ -2382,57 +2548,6 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}\n \n-/// A place for insertion at the back of a `Vec`.\n-///\n-/// See [`Vec::place_back`](struct.Vec.html#method.place_back) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceBack<'a, T: 'a> {\n-    vec: &'a mut Vec<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n-    type Place = PlaceBack<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        // This will panic or abort if we would allocate > isize::MAX bytes\n-        // or if the length increment would overflow for zero-sized types.\n-        if self.vec.len == self.vec.buf.cap() {\n-            self.vec.buf.double();\n-        }\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { self.vec.as_mut_ptr().offset(self.vec.len as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(mut self) -> &'a mut T {\n-        let ptr = self.pointer();\n-        self.vec.len += 1;\n-        &mut *ptr\n-    }\n-}\n-\n-\n /// A splicing iterator for `Vec`.\n ///\n /// This struct is created by the [`splice()`] method on [`Vec`]. See its"}, {"sha": "f28c8e389967f616e6cff139b74d81c2c03dd4f7", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 129, "deletions": 147, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -21,7 +21,8 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n-use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::ptr::NonNull;\n use core::slice;\n@@ -31,8 +32,7 @@ use core::cmp;\n \n use raw_vec::RawVec;\n \n-use super::range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n+use super::allocator::CollectionAllocErr;\n use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n@@ -566,6 +566,97 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    ///     let mut output = VecDeque::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve_exact(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.try_reserve(additional)\n+    }\n+\n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `VecDeque<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    ///     let mut output = VecDeque::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        let old_cap = self.cap();\n+        let used_cap = self.len() + 1;\n+        let new_cap = used_cap.checked_add(additional)\n+            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+\n+        if new_cap > old_cap {\n+            self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Shrinks the capacity of the `VecDeque` as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator may still inform the\n@@ -584,9 +675,42 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn shrink_to_fit(&mut self) {\n+        self.shrink_to(0);\n+    }\n+\n+    /// Shrinks the capacity of the `VecDeque` with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    /// buf.extend(0..4);\n+    /// assert_eq!(buf.capacity(), 15);\n+    /// buf.shrink_to(6);\n+    /// assert!(buf.capacity() >= 6);\n+    /// buf.shrink_to(0);\n+    /// assert!(buf.capacity() >= 4);\n+    /// ```\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"0\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        assert!(self.capacity() >= min_capacity, \"Tried to shrink to a larger capacity\");\n+\n         // +1 since the ringbuffer always leaves one space empty\n         // len + 1 can't overflow for an existing, well-formed ringbuffer.\n-        let target_cap = cmp::max(self.len() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        let target_cap = cmp::max(\n+            cmp::max(min_capacity, self.len()) + 1,\n+            MINIMUM_CAPACITY + 1\n+        ).next_power_of_two();\n+\n         if target_cap < self.cap() {\n             // There are three cases of interest:\n             //   All elements are out of desired bounds\n@@ -844,7 +968,7 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1761,56 +1885,6 @@ impl<T> VecDeque<T> {\n             debug_assert!(!self.is_full());\n         }\n     }\n-\n-    /// Returns a place for insertion at the back of the `VecDeque`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.place_back() <- 3;\n-    /// buf.place_back() <- 4;\n-    /// assert_eq!(&buf, &[3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec_deque: self }\n-    }\n-\n-    /// Returns a place for insertion at the front of the `VecDeque`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_front`](#method.push_front),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.place_front() <- 3;\n-    /// buf.place_front() <- 4;\n-    /// assert_eq!(&buf, &[4, 3]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_front(&mut self) -> PlaceFront<T> {\n-        PlaceFront { vec_deque: self }\n-    }\n }\n \n impl<T: Clone> VecDeque<T> {\n@@ -2538,98 +2612,6 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     }\n }\n \n-/// A place for insertion at the back of a `VecDeque`.\n-///\n-/// See [`VecDeque::place_back`](struct.VecDeque.html#method.place_back) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceBack<'a, T: 'a> {\n-    vec_deque: &'a mut VecDeque<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n-    type Place = PlaceBack<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        self.vec_deque.grow_if_necessary();\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { self.vec_deque.ptr().offset(self.vec_deque.head as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(self) -> &'a mut T {\n-        let head = self.vec_deque.head;\n-        self.vec_deque.head = self.vec_deque.wrap_add(head, 1);\n-        &mut *(self.vec_deque.ptr().offset(head as isize))\n-    }\n-}\n-\n-/// A place for insertion at the front of a `VecDeque`.\n-///\n-/// See [`VecDeque::place_front`](struct.VecDeque.html#method.place_front) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceFront<'a, T: 'a> {\n-    vec_deque: &'a mut VecDeque<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceFront<'a, T> {\n-    type Place = PlaceFront<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        self.vec_deque.grow_if_necessary();\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceFront<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        let tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n-        unsafe { self.vec_deque.ptr().offset(tail as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceFront<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(self) -> &'a mut T {\n-        self.vec_deque.tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n-        &mut *(self.vec_deque.ptr().offset(self.vec_deque.tail as isize))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test;"}, {"sha": "7a8d01e4ef8b88f7dddea1adc63f0e1b852baa73", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -15,7 +15,6 @@\n                       form or name\",\n             issue = \"27783\")]\n #![deny(warnings)]\n-#![feature(alloc)]\n #![feature(alloc_system)]\n #![feature(libc)]\n #![feature(linkage)]\n@@ -25,7 +24,6 @@\n #![cfg_attr(not(dummy_jemalloc), feature(allocator_api))]\n #![rustc_alloc_kind = \"exe\"]\n \n-extern crate alloc;\n extern crate alloc_system;\n extern crate libc;\n \n@@ -35,7 +33,7 @@ pub use contents::*;\n mod contents {\n     use core::ptr;\n \n-    use alloc::heap::{Alloc, AllocErr, Layout};\n+    use core::heap::{Alloc, AllocErr, Layout};\n     use alloc_system::System;\n     use libc::{c_int, c_void, size_t};\n "}, {"sha": "d4404e564e0639960873fbacd4bf616130142a3e", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -17,7 +17,6 @@\n             issue = \"32838\")]\n #![feature(global_allocator)]\n #![feature(allocator_api)]\n-#![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n@@ -43,9 +42,7 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-extern crate alloc;\n-\n-use self::alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+use core::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub struct System;\n@@ -125,7 +122,7 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use alloc::heap::{Alloc, AllocErr, Layout};\n+    use core::heap::{Alloc, AllocErr, Layout};\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl<'a> Alloc for &'a System {\n@@ -134,6 +131,14 @@ mod platform {\n             let ptr = if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n                 libc::malloc(layout.size()) as *mut u8\n             } else {\n+                #[cfg(target_os = \"macos\")]\n+                {\n+                    if layout.align() > (1 << 31) {\n+                        return Err(AllocErr::Unsupported {\n+                            details: \"requested alignment too large\"\n+                        })\n+                    }\n+                }\n                 aligned_malloc(&layout)\n             };\n             if !ptr.is_null() {\n@@ -279,7 +284,7 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use alloc::heap::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n+    use core::heap::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -491,7 +496,7 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+    use core::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n     use System;\n     use self::dlmalloc::GlobalDlmalloc;\n "}, {"sha": "7eaf67e6ea66e30b991651b769f13f92d068f4a0", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -27,7 +27,7 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(generic_param_attrs)]\n+#![cfg_attr(stage0, feature(generic_param_attrs))]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]"}, {"sha": "2a2f6d96c8dc578d2474742f14c9bab0b36b0408", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1 +1 @@\n-Subproject commit 266ea0740a5bdd262a38bbd88fb55fc3d2a7a96e\n+Subproject commit 2a2f6d96c8dc578d2474742f14c9bab0b36b0408"}, {"sha": "24529f7a9d8d42161d2a943ad95878e9f4569e98", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -16,3 +16,6 @@ path = \"../libcore/tests/lib.rs\"\n [[bench]]\n name = \"corebenches\"\n path = \"../libcore/benches/lib.rs\"\n+\n+[dev-dependencies]\n+rand = \"0.4\""}, {"sha": "87144c27c9e11b1b71749f832c354cba97ff59f6", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -59,7 +59,7 @@ unsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n }\n \n /// The error type returned when a conversion from a slice to an array fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromSliceError(());\n \n@@ -148,7 +148,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.26.0\")]\n             impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n                 type Error = TryFromSliceError;\n \n@@ -162,7 +162,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"try_from\", issue = \"33417\")]\n+            #[stable(feature = \"try_from\", since = \"1.26.0\")]\n             impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n                 type Error = TryFromSliceError;\n "}, {"sha": "2c4bccebceb95247d45a42ffbba8130acc351df1", "filename": "src/libcore/ascii.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations on ASCII strings and characters.\n+//!\n+//! Most string operations in Rust act on UTF-8 strings. However, at times it\n+//! makes more sense to only consider the ASCII character set for a specific\n+//! operation.\n+//!\n+//! The [`escape_default`] function provides an iterator over the bytes of an\n+//! escaped version of the character given.\n+//!\n+//! [`escape_default`]: fn.escape_default.html\n+\n+#![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+\n+use fmt;\n+use ops::Range;\n+use iter::FusedIterator;\n+\n+/// An iterator over the escaped version of a byte.\n+///\n+/// This `struct` is created by the [`escape_default`] function. See its\n+/// documentation for more.\n+///\n+/// [`escape_default`]: fn.escape_default.html\n+#[stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+pub struct EscapeDefault {\n+    range: Range<usize>,\n+    data: [u8; 4],\n+}\n+\n+/// Returns an iterator that produces an escaped version of a `u8`.\n+///\n+/// The default is chosen with a bias toward producing literals that are\n+/// legal in a variety of languages, including C++11 and similar C-family\n+/// languages. The exact rules are:\n+///\n+/// * Tab is escaped as `\\t`.\n+/// * Carriage return is escaped as `\\r`.\n+/// * Line feed is escaped as `\\n`.\n+/// * Single quote is escaped as `\\'`.\n+/// * Double quote is escaped as `\\\"`.\n+/// * Backslash is escaped as `\\\\`.\n+/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n+///   inclusive is not escaped.\n+/// * Any other chars are given hex escapes of the form '\\xNN'.\n+/// * Unicode escapes are never generated by this function.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ascii;\n+///\n+/// let escaped = ascii::escape_default(b'0').next().unwrap();\n+/// assert_eq!(b'0', escaped);\n+///\n+/// let mut escaped = ascii::escape_default(b'\\t');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b't', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\r');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'r', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\n');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'n', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\'');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\'', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\"');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\"', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\\\');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\x9d');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'x', escaped.next().unwrap());\n+/// assert_eq!(b'9', escaped.next().unwrap());\n+/// assert_eq!(b'd', escaped.next().unwrap());\n+/// ```\n+#[stable(feature = \"core_ascii\", since = \"1.26.0\")]\n+pub fn escape_default(c: u8) -> EscapeDefault {\n+    let (data, len) = match c {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n+        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n+    };\n+\n+    return EscapeDefault { range: 0..len, data };\n+\n+    fn hexify(b: u8) -> u8 {\n+        match b {\n+            0 ... 9 => b'0' + b,\n+            _ => b'a' + b - 10,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for EscapeDefault {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.range.next_back().map(|i| self.data[i])\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for EscapeDefault {}\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EscapeDefault {}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl fmt::Debug for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EscapeDefault { .. }\")\n+    }\n+}"}, {"sha": "c947b003ccbffaa697586bfb32b5bc528687c142", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -11,7 +11,6 @@\n #![deny(warnings)]\n \n #![feature(flt2dec)]\n-#![feature(slice_patterns)]\n #![feature(test)]\n \n extern crate core;"}, {"sha": "f45a32d4b94acd8a83f2da8643fb2823f9349c95", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 149, "deletions": 15, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -14,24 +14,154 @@\n \n /// A trait for borrowing data.\n ///\n-/// In general, there may be several ways to \"borrow\" a piece of data.  The\n-/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+/// In Rust, it is common to provide different representations of a type for\n+/// different use cases. For instance, storage location and management for a\n+/// value can be specifically chosen as appropriate for a particular use via\n+/// pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic\n+/// wrappers that can be used with any type, some types provide optional\n+/// facets providing potentially costly functionality. An example for such a\n+/// type is [`String`] which adds the ability to extend a string to the basic\n+/// [`str`]. This requires keeping additional information unnecessary for a\n+/// simple, immutable string.\n ///\n-/// When writing generic code, it is often desirable to abstract over all ways\n-/// of borrowing data from a given type. That is the role of the `Borrow`\n-/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n-/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n-/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+/// These types provide access to the underlying data through references\n+/// to the type of that data. They are said to be \u2018borrowed as\u2019 that type.\n+/// For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`]\n+/// can be borrowed as `str`.\n ///\n-/// If you are implementing `Borrow` and both `Self` and `Borrowed` implement\n-/// `Hash`, `Eq`, and/or `Ord`, they must produce the same result.\n+/// Types express that they can be borrowed as some type `T` by implementing\n+/// `Borrow<T>`, providing a reference to a `T` in the trait\u2019s\n+/// [`borrow`] method. A type is free to borrow as several different types.\n+/// If it wishes to mutably borrow as the type \u2013 allowing the underlying data\n+/// to be modified, it can additionally implement [`BorrowMut<T>`].\n ///\n-/// `Borrow` is very similar to, but different than, `AsRef`. See\n-/// [the book][book] for more.\n+/// Further, when providing implementations for additional traits, it needs\n+/// to be considered whether they should behave identical to those of the\n+/// underlying type as a consequence of acting as a representation of that\n+/// underlying type. Generic code typically uses `Borrow<T>` when it relies\n+/// on the identical behavior of these additional trait implementations.\n+/// These traits will likely appear as additional trait bounds.\n ///\n-/// [book]: ../../book/first-edition/borrow-and-asref.html\n+/// If generic code merely needs to work for all types that can\n+/// provide a reference to related type `T`, it is often better to use\n+/// [`AsRef<T>`] as more types can safely implement it.\n+///\n+/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n+/// [`BorrowMut<T>`]: trait.BorrowMut.html\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n+/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n+/// [`str`]: ../../std/primitive.str.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`borrow`]: #tymethod.borrow\n+///\n+/// # Examples\n+///\n+/// As a data collection, [`HashMap<K, V>`] owns both keys and values. If\n+/// the key\u2019s actual data is wrapped in a managing type of some kind, it\n+/// should, however, still be possible to search for a value using a\n+/// reference to the key\u2019s data. For instance, if the key is a string, then\n+/// it is likely stored with the hash map as a [`String`], while it should\n+/// be possible to search using a [`&str`][`str`]. Thus, `insert` needs to\n+/// operate on a `String` while `get` needs to be able to use a `&str`.\n+///\n+/// Slightly simplified, the relevant parts of `HashMap<K, V>` look like\n+/// this:\n+///\n+/// ```\n+/// use std::borrow::Borrow;\n+/// use std::hash::Hash;\n+///\n+/// pub struct HashMap<K, V> {\n+///     # marker: ::std::marker::PhantomData<(K, V)>,\n+///     // fields omitted\n+/// }\n+///\n+/// impl<K, V> HashMap<K, V> {\n+///     pub fn insert(&self, key: K, value: V) -> Option<V>\n+///     where K: Hash + Eq\n+///     {\n+///         # unimplemented!()\n+///         // ...\n+///     }\n+///\n+///     pub fn get<Q>(&self, k: &Q) -> Option<&V>\n+///     where\n+///         K: Borrow<Q>,\n+///         Q: Hash + Eq + ?Sized\n+///     {\n+///         # unimplemented!()\n+///         // ...\n+///     }\n+/// }\n+/// ```\n+///\n+/// The entire hash map is generic over a key type `K`. Because these keys\n+/// are stored with the hash map, this type has to own the key\u2019s data.\n+/// When inserting a key-value pair, the map is given such a `K` and needs\n+/// to find the correct hash bucket and check if the key is already present\n+/// based on that `K`. It therefore requires `K: Hash + Eq`.\n+///\n+/// When searching for a value in the map, however, having to provide a\n+/// reference to a `K` as the key to search for would require to always\n+/// create such an owned value. For string keys, this would mean a `String`\n+/// value needs to be created just for the search for cases where only a\n+/// `str` is available.\n+///\n+/// Instead, the `get` method is generic over the type of the underlying key\n+/// data, called `Q` in the method signature above. It states that `K`\n+/// borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally\n+/// requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q`\n+/// have implementations of the `Hash` and `Eq` traits that produce identical\n+/// results.\n+///\n+/// The implementation of `get` relies in particular on identical\n+/// implementations of `Hash` by determining the key\u2019s hash bucket by calling\n+/// `Hash::hash` on the `Q` value even though it inserted the key based on\n+/// the hash value calculated from the `K` value.\n+///\n+/// As a consequence, the hash map breaks if a `K` wrapping a `Q` value\n+/// produces a different hash than `Q`. For instance, imagine you have a\n+/// type that wraps a string but compares ASCII letters ignoring their case:\n+///\n+/// ```\n+/// pub struct CaseInsensitiveString(String);\n+///\n+/// impl PartialEq for CaseInsensitiveString {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.0.eq_ignore_ascii_case(&other.0)\n+///     }\n+/// }\n+///\n+/// impl Eq for CaseInsensitiveString { }\n+/// ```\n+///\n+/// Because two equal values need to produce the same hash value, the\n+/// implementation of `Hash` needs to ignore ASCII case, too:\n+///\n+/// ```\n+/// # use std::hash::{Hash, Hasher};\n+/// # pub struct CaseInsensitiveString(String);\n+/// impl Hash for CaseInsensitiveString {\n+///     fn hash<H: Hasher>(&self, state: &mut H) {\n+///         for c in self.0.as_bytes() {\n+///             c.to_ascii_lowercase().hash(state)\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can\n+/// provide a reference to a string slice via its contained owned string.\n+/// But because its `Hash` implementation differs, it behaves differently\n+/// from `str` and therefore must not, in fact, implement `Borrow<str>`.\n+/// If it wants to allow others access to the underlying `str`, it can do\n+/// that via `AsRef<str>` which doesn\u2019t carry any extra requirements.\n+///\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n@@ -59,7 +189,11 @@ pub trait Borrow<Borrowed: ?Sized> {\n \n /// A trait for mutably borrowing data.\n ///\n-/// Similar to `Borrow`, but for mutable borrows.\n+/// As a companion to [`Borrow<T>`] this trait allows a type to borrow as\n+/// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n+/// for more information on borrowing as another type.\n+///\n+/// [`Borrow<T>`]: trait.Borrow.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n     /// Mutably borrows from an owned value."}, {"sha": "c8ee166fee3e9240383a7ff37c77a0c2e15be536", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -146,13 +146,12 @@\n //!\n //! ```\n //! #![feature(core_intrinsics)]\n-//! #![feature(shared)]\n //! use std::cell::Cell;\n-//! use std::ptr::Shared;\n+//! use std::ptr::NonNull;\n //! use std::intrinsics::abort;\n //!\n //! struct Rc<T: ?Sized> {\n-//!     ptr: Shared<RcBox<T>>\n+//!     ptr: NonNull<RcBox<T>>\n //! }\n //!\n //! struct RcBox<T: ?Sized> {\n@@ -1203,21 +1202,42 @@ impl<'a, T: ?Sized + fmt::Display> fmt::Display for RefMut<'a, T> {\n /// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n /// mutable. In general, transmuting an `&T` type into an `&mut T` is considered undefined behavior.\n ///\n-/// The compiler makes optimizations based on the knowledge that `&T` is not mutably aliased or\n-/// mutated, and that `&mut T` is unique. When building abstractions like `Cell`, `RefCell`,\n-/// `Mutex`, etc, you need to turn these optimizations off. `UnsafeCell` is the only legal way\n-/// to do this. When `UnsafeCell<T>` is immutably aliased, it is still safe to obtain a mutable\n-/// reference to its interior and/or to mutate it. However, it is up to the abstraction designer\n-/// to ensure that no two mutable references obtained this way are active at the same time, and\n-/// that there are no active mutable references or mutations when an immutable reference is obtained\n-/// from the cell. This is often done via runtime checks.\n+/// If you have a reference `&SomeStruct`, then normally in Rust all fields of `SomeStruct` are\n+/// immutable. The compiler makes optimizations based on the knowledge that `&T` is not mutably\n+/// aliased or mutated, and that `&mut T` is unique. `UnsafeCel<T>` is the only core language\n+/// feature to work around this restriction. All other types that allow internal mutability, such as\n+/// `Cell<T>` and `RefCell<T>` use `UnsafeCell` to wrap their internal data.\n ///\n-/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n-/// okay (provided you enforce the invariants some other way); it is still undefined behavior\n-/// to have multiple `&mut UnsafeCell<T>` aliases.\n+/// The `UnsafeCell` API itself is technically very simple: it gives you a raw pointer `*mut T` to\n+/// its contents. It is up to _you_ as the abstraction designer to use that raw pointer correctly.\n+///\n+/// The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:\n+///\n+/// - If you create a safe reference with lifetime `'a` (either a `&T` or `&mut T` reference) that\n+/// is accessible by safe code (for example, because you returned it), then you must not access\n+/// the data in any way that contradicts that reference for the remainder of `'a`. For example, that\n+/// means that if you take the `*mut T` from an `UnsafeCell<T>` and case it to an `&T`, then until\n+/// that reference's lifetime expires, the data in `T` must remain immutable (modulo any\n+/// `UnsafeCell` data found within `T`, of course). Similarly, if you create an `&mut T` reference\n+/// that is released to safe code, then you must not access the data within the `UnsafeCell` until\n+/// that reference expires.\n+///\n+/// - At all times, you must avoid data races, meaning that if multiple threads have access to\n+/// the same `UnsafeCell`, then any writes must have a proper happens-before relation to all other\n+/// accesses (or use atomics).\n ///\n+/// To assist with proper design, the following scenarios are explicitly declared legal\n+/// for single-threaded code:\n ///\n-/// Types like `Cell<T>` and `RefCell<T>` use this type to wrap their internal data.\n+/// 1. A `&T` reference can be released to safe code and there it can co-exit with other `&T`\n+/// references, but not with a `&mut T`\n+///\n+/// 2. A `&mut T` reference may be released to safe code, provided neither other `&mut T` nor `&T`\n+/// co-exist with it. A `&mut T` must always be unique.\n+///\n+/// Note that while mutating or mutably aliasing the contents of an `& UnsafeCell<T>` is\n+/// okay (provided you enforce the invariants some other way), it is still undefined behavior\n+/// to have multiple `&mut UnsafeCell<T>` aliases.\n ///\n /// # Examples\n ///\n@@ -1282,9 +1302,9 @@ impl<T: ?Sized> UnsafeCell<T> {\n     /// Gets a mutable pointer to the wrapped value.\n     ///\n     /// This can be cast to a pointer of any kind.\n-    /// Ensure that the access is unique when casting to\n-    /// `&mut T`, and ensure that there are no mutations or mutable\n-    /// aliases going on when casting to `&T`\n+    /// Ensure that the access is unique (no active references, mutable or not)\n+    /// when casting to `&mut T`, and ensure that there are no mutations\n+    /// or mutable aliases going on when casting to `&T`\n     ///\n     /// # Examples\n     ///"}, {"sha": "718c6b893edf229cfecf8ddb9d337521634136fd", "filename": "src/libcore/char.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -265,7 +265,7 @@ impl FromStr for char {\n }\n \n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n \n@@ -280,11 +280,11 @@ impl TryFrom<u32> for char {\n }\n \n /// The error type returned when a conversion from u32 to char fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct CharTryFromError(());\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl fmt::Display for CharTryFromError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"converted integer out of range for `char`\".fmt(f)\n@@ -902,6 +902,16 @@ impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n             }\n         })\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.0.size_hint();\n+\n+        // A code point is at most 4 bytes long.\n+        let min_code_points = lower / 4;\n+\n+        (min_code_points, upper)\n+    }\n }\n \n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]"}, {"sha": "58a8439162c118586033a21603889c32ed6bed7e", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -87,6 +87,23 @@\n ///     fn clone(&self) -> Stats { *self }\n /// }\n /// ```\n+///\n+/// ## Additional implementors\n+///\n+/// In addition to the [implementors listed below][impls],\n+/// the following types also implement `Clone`:\n+///\n+/// * Function item types (i.e. the distinct types defined for each function)\n+/// * Function pointer types (e.g. `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Clone` (e.g. `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Clone` (e.g. `()`, `(i32, bool)`)\n+/// * Closure types, if they capture no value from the environment\n+///   or if all such captured values implement `Clone` themselves.\n+///   Note that variables captured by shared reference always implement `Clone`\n+///   (even if the referent doesn't),\n+///   while variables captured by mutable reference never implement `Clone`.\n+///\n+/// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n pub trait Clone : Sized {\n@@ -100,6 +117,7 @@ pub trait Clone : Sized {\n     /// assert_eq!(\"Hello\", hello.clone());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n     fn clone(&self) -> Self;\n \n     /// Performs copy-assignment from `source`.\n@@ -130,3 +148,68 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n            reason = \"deriving hack, should not be public\",\n            issue = \"0\")]\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n+/// Implementations of `Clone` for primitive types.\n+///\n+/// Implementations that cannot be described in Rust\n+/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+#[cfg(not(stage0))]\n+mod impls {\n+\n+    use super::Clone;\n+\n+    macro_rules! impl_clone {\n+        ($($t:ty)*) => {\n+            $(\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl Clone for $t {\n+                    #[inline]\n+                    fn clone(&self) -> Self {\n+                        *self\n+                    }\n+                }\n+            )*\n+        }\n+    }\n+\n+    impl_clone! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n+    impl Clone for ! {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Clone for *const T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Clone for *mut T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+    // Shared references can be cloned, but mutable references *cannot*!\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized> Clone for &'a T {\n+        #[inline]\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n+\n+}"}, {"sha": "67445daa436024b54b0bae004af0c440d7c3fcd2", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -882,24 +882,24 @@ mod impls {\n \n     ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl Eq for ! {}\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n     impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self"}, {"sha": "637213957848c6b7c01bf35fb791a96356669a76", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -48,25 +48,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fmt;\n-\n-/// A type used as the error type for implementations of fallible conversion\n-/// traits in cases where conversions cannot actually fail.\n-///\n-/// Because `Infallible` has no variants, a value of this type can never exist.\n-/// It is used only to satisfy trait signatures that expect an error type, and\n-/// signals to both the compiler and the user that the error case is impossible.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Infallible {}\n-\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl fmt::Display for Infallible {\n-    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-        }\n-    }\n-}\n /// A cheap reference-to-reference conversion. Used to convert a value to a\n /// reference value within generic code.\n ///\n@@ -341,22 +322,26 @@ pub trait From<T>: Sized {\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Into`]: trait.Into.html\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     fn try_into(self) -> Result<T, Self::Error>;\n }\n \n /// Attempt to construct `Self` via a conversion.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     type Error;\n \n     /// Performs the conversion.\n+    #[stable(feature = \"try_from\", since = \"1.26.0\")]\n     fn try_from(value: T) -> Result<Self, Self::Error>;\n }\n \n@@ -382,7 +367,7 @@ impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U>\n     }\n }\n \n-// FIXME (#23442): replace the above impls for &/&mut with the following more general one:\n+// FIXME (#45742): replace the above impls for &/&mut with the following more general one:\n // // As lifts over Deref\n // impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n //     fn as_ref(&self) -> &U {\n@@ -399,7 +384,7 @@ impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U>\n     }\n }\n \n-// FIXME (#23442): replace the above impl for &mut with the following more general one:\n+// FIXME (#45742): replace the above impl for &mut with the following more general one:\n // // AsMut lifts over DerefMut\n // impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n //     fn as_mut(&mut self) -> &mut U {\n@@ -424,7 +409,7 @@ impl<T> From<T> for T {\n \n \n // TryFrom implies TryInto\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl<T, U> TryInto<U> for T where U: TryFrom<T>\n {\n     type Error = U::Error;\n@@ -436,9 +421,9 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n \n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl<T, U> TryFrom<U> for T where T: From<U> {\n-    type Error = Infallible;\n+    type Error = !;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {\n         Ok(T::from(value))"}, {"sha": "d55219d7226e6d5fda7e7679df06994ab6a987f8", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 220, "deletions": 19, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -333,7 +333,7 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n+enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, DebugLowerHex, DebugUpperHex }\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n@@ -401,10 +401,21 @@ impl<'a> Arguments<'a> {\n /// safely be done, so no constructors are given and the fields are private\n /// to prevent modification.\n ///\n-/// The [`format_args!`] macro will safely create an instance of this structure\n-/// and pass it to a function or closure, passed as the first argument. The\n-/// macro validates the format string at compile-time so usage of the [`write`]\n-/// and [`format`] functions can be safely performed.\n+/// The [`format_args!`] macro will safely create an instance of this structure.\n+/// The macro validates the format string at compile-time so usage of the\n+/// [`write`] and [`format`] functions can be safely performed.\n+///\n+/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n+/// and `Display` contexts as seen below. The example also shows that `Debug`\n+/// and `Display` format to the same thing: the interpolated format string\n+/// in `format_args!`.\n+///\n+/// ```rust\n+/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// assert_eq!(\"1 foo 2\", display);\n+/// assert_eq!(display, debug);\n+/// ```\n ///\n /// [`format_args!`]: ../../std/macro.format_args.html\n /// [`format`]: ../../std/fmt/fn.format.html\n@@ -684,18 +695,16 @@ pub trait Octal {\n ///\n /// The `Binary` trait should format its output as a number in binary.\n ///\n-/// For primitive signed integers (`i8` to `i128`, and `isize`),\n+/// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n /// negative values are formatted as the two\u2019s complement representation.\n ///\n /// The alternate flag, `#`, adds a `0b` in front of the output.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n ///\n-/// [module]: ../../std/fmt/index.html\n-///\n /// # Examples\n ///\n-/// Basic usage with `i32`:\n+/// Basic usage with [`i32`]:\n ///\n /// ```\n /// let x = 42; // 42 is '101010' in binary\n@@ -725,6 +734,12 @@ pub trait Octal {\n ///\n /// println!(\"l as binary is: {:b}\", l);\n /// ```\n+///\n+/// [module]: ../../std/fmt/index.html\n+/// [`i8`]: ../../std/primitive.i8.html\n+/// [`i128`]: ../../std/primitive.i128.html\n+/// [`isize`]: ../../std/primitive.isize.html\n+/// [`i32`]: ../../std/primitive.i32.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n@@ -1375,32 +1390,170 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    /// Optionally specified integer width that the output should be\n+    /// Optionally specified integer width that the output should be.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if let Some(width) = formatter.width() {\n+    ///             // If we received a width, we use it\n+    ///             write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n+    ///         } else {\n+    ///             // Otherwise we do nothing special\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn width(&self) -> Option<usize> { self.width }\n \n-    /// Optionally specified precision for numeric types\n+    /// Optionally specified precision for numeric types.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(f32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if let Some(precision) = formatter.precision() {\n+    ///             // If we received a precision, we use it.\n+    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n+    ///         } else {\n+    ///             // Otherwise we default to 2.\n+    ///             write!(formatter, \"Foo({:.2})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n \n     /// Determines if the `+` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.sign_plus() {\n+    ///             write!(formatter,\n+    ///                    \"Foo({}{})\",\n+    ///                    if self.0 < 0 { '-' } else { '+' },\n+    ///                    self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n \n     /// Determines if the `-` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.sign_minus() {\n+    ///             // You want a minus sign? Have one!\n+    ///             write!(formatter, \"-Foo({})\", self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n \n     /// Determines if the `#` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.alternate() {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"{}\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n \n     /// Determines if the `0` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         assert!(formatter.sign_aware_zero_pad());\n+    ///         assert_eq!(formatter.width(), Some(4));\n+    ///         // We ignore the formatter's options.\n+    ///         write!(formatter, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_aware_zero_pad(&self) -> bool {\n         self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n     }\n \n+    // FIXME: Decide what public API we want for these two flags.\n+    // https://github.com/rust-lang/rust/issues/48584\n+    fn debug_lower_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0 }\n+\n+    fn debug_upper_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0 }\n+\n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n     /// [`fmt::Debug`] implementations for structs.\n     ///\n@@ -1411,23 +1564,32 @@ impl<'a> Formatter<'a> {\n     ///\n     /// ```rust\n     /// use std::fmt;\n+    /// use std::net::Ipv4Addr;\n     ///\n     /// struct Foo {\n     ///     bar: i32,\n     ///     baz: String,\n+    ///     addr: Ipv4Addr,\n     /// }\n     ///\n     /// impl fmt::Debug for Foo {\n     ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n     ///         fmt.debug_struct(\"Foo\")\n     ///             .field(\"bar\", &self.bar)\n     ///             .field(\"baz\", &self.baz)\n+    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n     ///             .finish()\n     ///     }\n     /// }\n     ///\n-    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n-    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+    /// assert_eq!(\n+    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n+    ///     format!(\"{:?}\", Foo {\n+    ///         bar: 10,\n+    ///         baz: \"Hello World\".to_string(),\n+    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n+    ///     })\n+    /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n@@ -1441,20 +1603,24 @@ impl<'a> Formatter<'a> {\n     ///\n     /// ```rust\n     /// use std::fmt;\n+    /// use std::marker::PhantomData;\n     ///\n-    /// struct Foo(i32, String);\n+    /// struct Foo<T>(i32, String, PhantomData<T>);\n     ///\n-    /// impl fmt::Debug for Foo {\n+    /// impl<T> fmt::Debug for Foo<T> {\n     ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n     ///         fmt.debug_tuple(\"Foo\")\n     ///             .field(&self.0)\n     ///             .field(&self.1)\n+    ///             .field(&format_args!(\"_\"))\n     ///             .finish()\n     ///     }\n     /// }\n     ///\n-    /// // prints \"Foo(10, \"Hello World\")\"\n-    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+    /// assert_eq!(\n+    ///     \"Foo(10, \\\"Hello\\\", _)\",\n+    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::<u8>))\n+    /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n@@ -1504,6 +1670,41 @@ impl<'a> Formatter<'a> {\n     /// // prints \"{10, 11}\"\n     /// println!(\"{:?}\", Foo(vec![10, 11]));\n     /// ```\n+    ///\n+    /// [`format_args!`]: ../../std/macro.format_args.html\n+    ///\n+    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n+    /// to build a list of match arms:\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n+    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n+    ///\n+    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n+    /// where\n+    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n+    /// {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         L::fmt(&(self.0).0, fmt)?;\n+    ///         fmt.write_str(\" => \")?;\n+    ///         R::fmt(&(self.0).1, fmt)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n+    /// where\n+    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n+    /// {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_set()\n+    ///         .entries(self.0.iter().map(Arm))\n+    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n+    ///         .finish()\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n         builders::debug_set_new(self)\n@@ -1575,14 +1776,14 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[stable(feature = \"never_type\", since = \"1.26.0\")]\n impl Debug for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self\n     }\n }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[stable(feature = \"never_type\", since = \"1.26.0\")]\n impl Display for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self"}, {"sha": "4451ab445cc5c9e5315598a76032d7aa50d0f13c", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -49,32 +49,30 @@ doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n #[doc(hidden)]\n trait GenericRadix {\n     /// The number of digits.\n-    fn base(&self) -> u8;\n+    const BASE: u8;\n \n     /// A radix-specific prefix string.\n-    fn prefix(&self) -> &'static str {\n-        \"\"\n-    }\n+    const PREFIX: &'static str;\n \n     /// Converts an integer to corresponding radix digit.\n-    fn digit(&self, x: u8) -> u8;\n+    fn digit(x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 128\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf = [0; 128];\n+        let mut buf: [u8; 128] = unsafe { mem::uninitialized() };\n         let mut curr = buf.len();\n-        let base = T::from_u8(self.base());\n+        let base = T::from_u8(Self::BASE);\n         if is_nonnegative {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n             for byte in buf.iter_mut().rev() {\n-                let n = x % base;              // Get the current place value.\n-                x = x / base;                  // Deaccumulate the number.\n-                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n+                let n = x % base;               // Get the current place value.\n+                x = x / base;                   // Deaccumulate the number.\n+                *byte = Self::digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n@@ -84,9 +82,9 @@ trait GenericRadix {\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = zero - (x % base);     // Get the current place value.\n-                x = x / base;                  // Deaccumulate the number.\n-                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n+                let n = zero - (x % base);      // Get the current place value.\n+                x = x / base;                   // Deaccumulate the number.\n+                *byte = Self::digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n@@ -95,7 +93,7 @@ trait GenericRadix {\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n-        f.pad_integral(is_nonnegative, self.prefix(), buf)\n+        f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n     }\n }\n \n@@ -107,10 +105,6 @@ struct Binary;\n #[derive(Clone, PartialEq)]\n struct Octal;\n \n-/// A decimal (base 10) radix\n-#[derive(Clone, PartialEq)]\n-struct Decimal;\n-\n /// A hexadecimal (base 16) radix, formatted with lower-case characters\n #[derive(Clone, PartialEq)]\n struct LowerHex;\n@@ -122,12 +116,12 @@ struct UpperHex;\n macro_rules! radix {\n     ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n         impl GenericRadix for $T {\n-            fn base(&self) -> u8 { $base }\n-            fn prefix(&self) -> &'static str { $prefix }\n-            fn digit(&self, x: u8) -> u8 {\n+            const BASE: u8 = $base;\n+            const PREFIX: &'static str = $prefix;\n+            fn digit(x: u8) -> u8 {\n                 match x {\n                     $($x => $conv,)+\n-                    x => panic!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+                    x => panic!(\"number not in the range 0..{}: {}\", Self::BASE - 1, x),\n                 }\n             }\n         }\n@@ -136,7 +130,6 @@ macro_rules! radix {\n \n radix! { Binary,    2, \"0b\", x @  0 ...  1 => b'0' + x }\n radix! { Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x }\n-radix! { Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x }\n radix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n                              x @ 10 ... 15 => b'a' + (x - 10) }\n radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n@@ -159,7 +152,13 @@ macro_rules! debug {\n         impl fmt::Debug for $T {\n             #[inline]\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::Display::fmt(self, f)\n+                if f.debug_lower_hex() {\n+                    fmt::LowerHex::fmt(self, f)\n+                } else if f.debug_upper_hex() {\n+                    fmt::UpperHex::fmt(self, f)\n+                } else {\n+                    fmt::Display::fmt(self, f)\n+                }\n             }\n         }\n     }"}, {"sha": "3e1f21cafe4124dfa754242990dd7fd8932ab662", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -99,9 +99,10 @@ use mem;\n #[allow(deprecated)]\n pub use self::sip::SipHasher;\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n #[allow(deprecated)]\n-pub use self::sip::{SipHasher13, SipHasher24};\n+#[doc(hidden)]\n+pub use self::sip::SipHasher13;\n \n mod sip;\n \n@@ -307,7 +308,7 @@ pub trait Hasher {\n     }\n     /// Writes a single `u128` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    #[stable(feature = \"i128\", since = \"1.26.0\")]\n     fn write_u128(&mut self, i: u128) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })\n     }\n@@ -347,7 +348,7 @@ pub trait Hasher {\n     }\n     /// Writes a single `i128` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    #[stable(feature = \"i128\", since = \"1.26.0\")]\n     fn write_i128(&mut self, i: i128) {\n         self.write_u128(i as u128)\n     }"}, {"sha": "e3bdecdc4b1fd714ede210948c373d048bf30abe", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 12, "deletions": 44, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -23,22 +23,23 @@ use mem;\n /// (eg. `collections::HashMap` uses it by default).\n ///\n /// See: <https://131002.net/siphash>\n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n+#[doc(hidden)]\n pub struct SipHasher13 {\n     hasher: Hasher<Sip13Rounds>,\n }\n \n /// An implementation of SipHash 2-4.\n ///\n /// See: <https://131002.net/siphash/>\n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n #[rustc_deprecated(since = \"1.13.0\",\n                    reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n-pub struct SipHasher24 {\n+struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n }\n \n@@ -156,14 +157,16 @@ impl SipHasher {\n     #[rustc_deprecated(since = \"1.13.0\",\n                        reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher(SipHasher24::new_with_keys(key0, key1))\n+        SipHasher(SipHasher24 {\n+            hasher: Hasher::new_with_keys(key0, key1)\n+        })\n     }\n }\n \n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n     #[rustc_deprecated(since = \"1.13.0\",\n                        reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new() -> SipHasher13 {\n@@ -172,7 +175,7 @@ impl SipHasher13 {\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n     #[rustc_deprecated(since = \"1.13.0\",\n                        reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n@@ -182,28 +185,6 @@ impl SipHasher13 {\n     }\n }\n \n-impl SipHasher24 {\n-    /// Creates a new `SipHasher24` with the two initial keys set to 0.\n-    #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n-    pub fn new() -> SipHasher24 {\n-        SipHasher24::new_with_keys(0, 0)\n-    }\n-\n-    /// Creates a `SipHasher24` that is keyed off the provided keys.\n-    #[inline]\n-    #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n-        SipHasher24 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        }\n-    }\n-}\n-\n impl<S: Sip> Hasher<S> {\n     #[inline]\n     fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n@@ -271,16 +252,16 @@ impl<S: Sip> Hasher<S> {\n impl super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n-        self.0.write(msg)\n+        self.0.hasher.write(msg)\n     }\n \n     #[inline]\n     fn finish(&self) -> u64 {\n-        self.0.finish()\n+        self.0.hasher.finish()\n     }\n }\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n impl super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n@@ -293,19 +274,6 @@ impl super::Hasher for SipHasher13 {\n     }\n }\n \n-#[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n-impl super::Hasher for SipHasher24 {\n-    #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n-        self.hasher.write(msg)\n-    }\n-\n-    #[inline]\n-    fn finish(&self) -> u64 {\n-        self.hasher.finish()\n-    }\n-}\n-\n impl<S: Sip> super::Hasher for Hasher<S> {\n     // see short_write comment for explanation\n     #[inline]"}, {"sha": "fe19c923a58d153d2add0d72ed39c72b1e7e6929", "filename": "src/libcore/heap.rs", "status": "renamed", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fheap.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -15,11 +15,11 @@\n                       tracing garbage collector\",\n             issue = \"32838\")]\n \n-use core::cmp;\n-use core::fmt;\n-use core::mem;\n-use core::usize;\n-use core::ptr::{self, NonNull};\n+use cmp;\n+use fmt;\n+use mem;\n+use usize;\n+use ptr::{self, NonNull};\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n@@ -65,13 +65,11 @@ pub struct Layout {\n \n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `None` if any of the following conditions\n+    /// or returns `None` if either of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must be a power of two,\n     ///\n-    /// * `align` must not exceed 2<sup>31</sup> (i.e. `1 << 31`),\n-    ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n@@ -81,10 +79,6 @@ impl Layout {\n             return None;\n         }\n \n-        if align > (1 << 31) {\n-            return None;\n-        }\n-\n         // (power-of-two implies align != 0.)\n \n         // Rounded up size is:\n@@ -113,9 +107,8 @@ impl Layout {\n     /// # Safety\n     ///\n     /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two that is also less than or equal to 2<sup>31</sup>, nor\n-    /// that `size` aligned to `align` fits within the address space\n-    /// (i.e. the `Layout::from_size_align` preconditions).\n+    /// a power-of-two nor `size` aligned to `align` fits within the\n+    /// address space (i.e. the `Layout::from_size_align` preconditions).\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Layout {\n         Layout { size: size, align: align }\n@@ -220,10 +213,10 @@ impl Layout {\n         let padded_size = self.size.checked_add(self.padding_needed_for(self.align))?;\n         let alloc_size = padded_size.checked_mul(n)?;\n \n-        // We can assume that `self.align` is a power-of-two that does\n-        // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n-        // rounded up to a multiple of `self.align`; therefore, the\n-        // call to `Layout::from_size_align` below should never panic.\n+        // We can assume that `self.align` is a power-of-two.\n+        // Furthermore, `alloc_size` has already been rounded up\n+        // to a multiple of `self.align`; therefore, the call to\n+        // `Layout::from_size_align` below should never panic.\n         Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n     }\n \n@@ -373,6 +366,24 @@ impl fmt::Display for CannotReallocInPlace {\n     }\n }\n \n+/// Augments `AllocErr` with a CapacityOverflow variant.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+pub enum CollectionAllocErr {\n+    /// Error due to the computed capacity exceeding the collection's maximum\n+    /// (usually `isize::MAX` bytes).\n+    CapacityOverflow,\n+    /// Error due to the allocator (see the `AllocErr` type's docs).\n+    AllocErr(AllocErr),\n+}\n+\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+impl From<AllocErr> for CollectionAllocErr {\n+    fn from(err: AllocErr) -> Self {\n+        CollectionAllocErr::AllocErr(err)\n+    }\n+}\n+\n /// An implementation of `Alloc` can allocate, reallocate, and\n /// deallocate arbitrary blocks of data described via `Layout`.\n ///\n@@ -550,7 +561,7 @@ pub unsafe trait Alloc {\n     /// invoked method, and let the client decide whether to invoke\n     /// this `oom` method in response.\n     fn oom(&mut self, _: AllocErr) -> ! {\n-        unsafe { ::core::intrinsics::abort() }\n+        unsafe { ::intrinsics::abort() }\n     }\n \n     // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==", "previous_filename": "src/liballoc/allocator.rs"}, {"sha": "3b740adc46832d06e0c21c5429d5527542c62a04", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1314,6 +1314,11 @@ extern \"rust-intrinsic\" {\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n+    /// Performs an exact division, resulting in undefined behavior where\n+    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+    #[cfg(not(stage0))]\n+    pub fn exact_div<T>(x: T, y: T) -> T;\n+\n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n@@ -1396,3 +1401,8 @@ extern \"rust-intrinsic\" {\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }\n+\n+#[cfg(stage0)]\n+pub unsafe fn exact_div<T>(a: T, b: T) -> T {\n+    unchecked_div(a, b)\n+}"}, {"sha": "4ccf446aa6346f007655b95e50ebe30e60881c1a", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -974,13 +974,13 @@ pub trait Iterator {\n     ///     // each iteration, we'll multiply the state by the element\n     ///     *state = *state * x;\n     ///\n-    ///     // the value passed on to the next iteration\n-    ///     Some(*state)\n+    ///     // then, we'll yield the negation of the state\n+    ///     Some(-*state)\n     /// });\n     ///\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// assert_eq!(iter.next(), Some(2));\n-    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), Some(-1));\n+    /// assert_eq!(iter.next(), Some(-2));\n+    /// assert_eq!(iter.next(), Some(-6));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n@@ -1368,6 +1368,7 @@ pub trait Iterator {\n     /// [`Result`]: ../../std/result/enum.Result.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n         FromIterator::from_iter(self)\n     }\n@@ -1446,7 +1447,6 @@ pub trait Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [1, 2, 3];\n     ///\n     /// // the checked sum of all of the elements of the array\n@@ -1458,7 +1458,6 @@ pub trait Iterator {\n     /// Short-circuiting:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [10, 20, 30, 100, 40, 50];\n     /// let mut it = a.iter();\n     ///\n@@ -1472,7 +1471,7 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(&40));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n@@ -1495,7 +1494,6 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// use std::fs::rename;\n     /// use std::io::{stdout, Write};\n     /// use std::path::Path;\n@@ -1512,7 +1510,7 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(\"stale_bread.json\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n         Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n     {\n@@ -1745,6 +1743,38 @@ pub trait Iterator {\n         }).break_value()\n     }\n \n+    /// Applies function to the elements of iterator and returns\n+    /// the first non-none result.\n+    ///\n+    /// `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(iterator_find_map)]\n+    /// let a = [\"lol\", \"NaN\", \"2\", \"5\"];\n+    ///\n+    /// let mut first_number = a.iter().find_map(|s| s.parse().ok());\n+    ///\n+    /// assert_eq!(first_number, Some(2));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_find_map\",\n+               reason = \"unstable new API\",\n+               issue = \"49602\")]\n+    fn find_map<B, F>(&mut self, mut f: F) -> Option<B> where\n+        Self: Sized,\n+        F: FnMut(Self::Item) -> Option<B>,\n+    {\n+        self.try_for_each(move |x| {\n+            match f(x) {\n+                Some(x) => LoopState::Break(x),\n+                None => LoopState::Continue(()),\n+            }\n+        }).break_value()\n+    }\n+\n     /// Searches for an element in an iterator, returning its index.\n     ///\n     /// `position()` takes a closure that returns `true` or `false`. It applies"}, {"sha": "1e8476d3880c8a4fc197c0c95e647ebca69ccf62", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1872,7 +1872,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // FIXME(#6393): merge these when borrow-checking gets better.\n+        // FIXME(#43234): merge these when borrow-checking gets better.\n         if n == 0 {\n             match self.peeked.take() {\n                 Some(v) => v,\n@@ -2605,7 +2605,7 @@ impl<I, U> DoubleEndedIterator for Flatten<I>\n     }\n }\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n impl<I, U> FusedIterator for Flatten<I>\n     where I: FusedIterator, U: Iterator,\n           I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}"}, {"sha": "5d57207763e47b671306ca3674f20da7cfd7eb14", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -91,7 +91,7 @@ macro_rules! step_impl_unsigned {\n             #[inline]\n             #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n+                match <$t>::private_try_from(n) {\n                     Ok(n_as_t) => self.checked_add(n_as_t),\n                     Err(_) => None,\n                 }\n@@ -123,7 +123,7 @@ macro_rules! step_impl_signed {\n             #[inline]\n             #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n+                match <$unsigned>::private_try_from(n) {\n                     Ok(n_as_unsigned) => {\n                         // Wrapping in unsigned space handles cases like\n                         // `-120_i8.add_usize(200) == Some(80_i8)`,\n@@ -186,9 +186,7 @@ macro_rules! range_exact_iter_impl {\n \n macro_rules! range_incl_exact_iter_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n+        #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n         impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n     )*)\n }\n@@ -202,9 +200,7 @@ macro_rules! range_trusted_len_impl {\n \n macro_rules! range_incl_trusted_len_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"inclusive_range\",\n-                   reason = \"recently added, follows RFC\",\n-                   issue = \"28237\")]\n+        #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n         unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n     )*)\n }\n@@ -328,7 +324,7 @@ impl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<A: Step> TrustedLen for ops::RangeFrom<A> {}\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     type Item = A;\n \n@@ -422,7 +418,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -465,3 +461,74 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}\n+\n+/// Compensate removal of some impls per\n+/// https://github.com/rust-lang/rust/pull/49305#issuecomment-376293243\n+trait PrivateTryFromUsize: Sized {\n+    fn private_try_from(n: usize) -> Result<Self, ()>;\n+}\n+\n+impl<T> PrivateTryFromUsize for T where T: TryFrom<usize> {\n+    #[inline]\n+    fn private_try_from(n: usize) -> Result<Self, ()> {\n+        T::try_from(n).map_err(|_| ())\n+    }\n+}\n+\n+// no possible bounds violation\n+macro_rules! try_from_unbounded {\n+    ($($target:ty),*) => {$(\n+        impl PrivateTryFromUsize for $target {\n+            #[inline]\n+            fn private_try_from(value: usize) -> Result<Self, ()> {\n+                Ok(value as $target)\n+            }\n+        }\n+    )*}\n+}\n+\n+// unsigned to signed (only positive bound)\n+#[cfg(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))]\n+macro_rules! try_from_upper_bounded {\n+    ($($target:ty),*) => {$(\n+        impl PrivateTryFromUsize for $target {\n+            #[inline]\n+            fn private_try_from(u: usize) -> Result<$target, ()> {\n+                if u > (<$target>::max_value() as usize) {\n+                    Err(())\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+\n+#[cfg(target_pointer_width = \"16\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_unbounded!(u16, u32, u64, u128);\n+    try_from_unbounded!(i32, i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_upper_bounded!(u16);\n+    try_from_unbounded!(u32, u64, u128);\n+    try_from_upper_bounded!(i32);\n+    try_from_unbounded!(i64, i128);\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+mod ptr_try_from_impls {\n+    use super::PrivateTryFromUsize;\n+\n+    try_from_upper_bounded!(u16, u32);\n+    try_from_unbounded!(u64, u128);\n+    try_from_upper_bounded!(i32, i64);\n+    try_from_unbounded!(i128);\n+}"}, {"sha": "ddbb59989424f11502b5c4b0f17e8f29498c571c", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -427,7 +427,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [\"1\", \"2\", \"3\"];\n     /// let sum = a.iter()\n     ///     .map(|&s| s.parse::<i32>())\n@@ -438,7 +437,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Short-circuiting:\n     ///\n     /// ```\n-    /// #![feature(iterator_try_fold)]\n     /// let a = [\"1\", \"rust\", \"3\"];\n     /// let mut it = a.iter();\n     /// let sum = it\n@@ -452,7 +450,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(it.next_back(), Some(&\"1\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n@@ -491,7 +489,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iter_rfold)]\n     /// let a = [1, 2, 3];\n     ///\n     /// // the sum of all of the elements of a\n@@ -505,7 +502,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// and continuing with each element from the back until the front:\n     ///\n     /// ```\n-    /// #![feature(iter_rfold)]\n     /// let numbers = [1, 2, 3, 4, 5];\n     ///\n     /// let zero = \"0\".to_string();\n@@ -517,14 +513,14 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iter_rfold\", issue = \"44705\")]\n+    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n     fn rfold<B, F>(mut self, accum: B, mut f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n         self.try_rfold(accum, move |acc, x| AlwaysOk(f(acc, x))).0\n     }\n \n-    /// Searches for an element of an iterator from the right that satisfies a predicate.\n+    /// Searches for an element of an iterator from the back that satisfies a predicate.\n     ///\n     /// `rfind()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, starting at the end, and if any\n@@ -547,8 +543,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(iter_rfind)]\n-    ///\n     /// let a = [1, 2, 3];\n     ///\n     /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n@@ -559,8 +553,6 @@ pub trait DoubleEndedIterator: Iterator {\n     /// Stopping at the first `true`:\n     ///\n     /// ```\n-    /// #![feature(iter_rfind)]\n-    ///\n     /// let a = [1, 2, 3];\n     ///\n     /// let mut iter = a.iter();\n@@ -571,7 +563,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(iter.next_back(), Some(&1));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"iter_rfind\", issue = \"39480\")]\n+    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n     fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n@@ -901,6 +893,15 @@ impl<I, T, E> Iterator for ResultShunt<I, E>\n             None => None,\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.error.is_some() {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n }\n \n #[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]"}, {"sha": "5a62b8438f93d2a8dccdd5568e36c00427f0dd99", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -74,16 +74,19 @@\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n+#![feature(fn_must_use)]\n #![feature(fundamental)]\n-#![feature(i128_type)]\n-#![feature(inclusive_range_syntax)]\n+#![cfg_attr(stage0, feature(i128_type))]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(intrinsics)]\n #![feature(iterator_flatten)]\n #![feature(iterator_repeat_with)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]\n-#![feature(never_type)]\n+#![feature(exhaustive_patterns)]\n+#![feature(macro_at_most_once_rep)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n #![feature(optin_builtin_traits)]\n@@ -101,6 +104,7 @@\n #![feature(unwind_attributes)]\n \n #![cfg_attr(stage0, allow(unused_attributes))]\n+#![cfg_attr(stage0, feature(never_type))]\n \n #[prelude_import]\n #[allow(unused)]\n@@ -165,6 +169,7 @@ pub mod borrow;\n \n pub mod any;\n pub mod array;\n+pub mod ascii;\n pub mod sync;\n pub mod cell;\n pub mod char;\n@@ -181,6 +186,10 @@ pub mod hash;\n pub mod fmt;\n pub mod time;\n \n+/* Heap memory allocator trait */\n+#[allow(missing_docs)]\n+pub mod heap;\n+\n // note: does not need to be public\n mod char_private;\n mod iter_private;"}, {"sha": "8a87bea71e2530cf9562698aa6650955a854cc33", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -76,6 +76,7 @@ macro_rules! panic {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n@@ -784,4 +785,18 @@ mod builtin {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n     }\n+\n+    /// Ensure that a boolean expression is `true` at runtime.\n+    ///\n+    /// For more information, see the documentation for [`std::assert!`].\n+    ///\n+    /// [`std::assert!`]: ../std/macro.assert.html\n+    #[macro_export]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(dox)]\n+    macro_rules! assert {\n+        ($cond:expr) => ({ /* compiler built-in */ });\n+        ($cond:expr,) => ({ /* compiler built-in */ });\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    }\n }"}, {"sha": "885aabe08069d4e064cbebd9183819fe799084e8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -260,13 +260,29 @@ pub trait Unsize<T: ?Sized> {\n /// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n /// avoid a breaking API change.\n ///\n+/// ## Additional implementors\n+///\n+/// In addition to the [implementors listed below][impls],\n+/// the following types also implement `Copy`:\n+///\n+/// * Function item types (i.e. the distinct types defined for each function)\n+/// * Function pointer types (e.g. `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Copy` (e.g. `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Copy` (e.g. `()`, `(i32, bool)`)\n+/// * Closure types, if they capture no value from the environment\n+///   or if all such captured values implement `Copy` themselves.\n+///   Note that variables captured by shared reference always implement `Copy`\n+///   (even if the referent doesn't),\n+///   while variables captured by mutable reference never implement `Copy`.\n+///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Drop`]: ../../std/ops/trait.Drop.html\n /// [`size_of::<T>`]: ../../std/mem/fn.size_of.html\n /// [`Clone`]: ../clone/trait.Clone.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`i32`]: ../../std/primitive.i32.html\n+/// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -343,8 +359,21 @@ pub trait Copy : Clone {\n /// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n+#[rustc_on_unimplemented(\n+    message=\"`{Self}` cannot be shared between threads safely\",\n+    label=\"`{Self}` cannot be shared between threads safely\"\n+)]\n pub unsafe auto trait Sync {\n+    // FIXME(estebank): once support to add notes in `rustc_on_unimplemented`\n+    // lands in beta, and it has been extended to check whether a closure is\n+    // anywhere in the requirement chain, extend it as such (#48534):\n+    // ```\n+    // on(\n+    //     closure,\n+    //     note=\"`{Self}` cannot be shared safely, consider marking the closure `move`\"\n+    // ),\n+    // ```\n+\n     // Empty\n }\n \n@@ -565,3 +594,53 @@ unsafe impl<T: ?Sized> Freeze for *const T {}\n unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<'a, T: ?Sized> Freeze for &'a T {}\n unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n+\n+/// Types which can be moved out of a `Pin`.\n+///\n+/// The `Unpin` trait is used to control the behavior of the [`Pin`] type. If a\n+/// type implements `Unpin`, it is safe to move a value of that type out of the\n+/// `Pin` pointer.\n+///\n+/// This trait is automatically implemented for almost every type.\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+pub unsafe auto trait Unpin {}\n+\n+/// Implementations of `Copy` for primitive types.\n+///\n+/// Implementations that cannot be described in Rust\n+/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\n+#[cfg(not(stage0))]\n+mod copy_impls {\n+\n+    use super::Copy;\n+\n+    macro_rules! impl_copy {\n+        ($($t:ty)*) => {\n+            $(\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                impl Copy for $t {}\n+            )*\n+        }\n+    }\n+\n+    impl_copy! {\n+        usize u8 u16 u32 u64 u128\n+        isize i8 i16 i32 i64 i128\n+        f32 f64\n+        bool char\n+    }\n+\n+    #[stable(feature = \"never_type\", since = \"1.26.0\")]\n+    impl Copy for ! {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Copy for *const T {}\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: ?Sized> Copy for *mut T {}\n+\n+    // Shared references can be copied, but mutable references *cannot*!\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized> Copy for &'a T {}\n+\n+}"}, {"sha": "b2467c948b4b156506dabb8c771e73736e6569d0", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -20,9 +20,9 @@ use cmp;\n use fmt;\n use hash;\n use intrinsics;\n-use marker::{Copy, PhantomData, Sized};\n+use marker::{Copy, PhantomData, Sized, Unpin, Unsize};\n use ptr;\n-use ops::{Deref, DerefMut};\n+use ops::{Deref, DerefMut, CoerceUnsized};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n@@ -1105,3 +1105,111 @@ impl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n pub unsafe fn unreachable() -> ! {\n     intrinsics::unreachable()\n }\n+\n+/// A pinned reference.\n+///\n+/// A pinned reference is a lot like a mutable reference, except that it is not\n+/// safe to move a value out of a pinned reference unless the type of that\n+/// value implements the `Unpin` trait.\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[fundamental]\n+pub struct Pin<'a, T: ?Sized + 'a> {\n+    inner: &'a mut T,\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized + Unpin> Pin<'a, T> {\n+    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// implements `Unpin`.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn new(reference: &'a mut T) -> Pin<'a, T> {\n+        Pin { inner: reference }\n+    }\n+}\n+\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> Pin<'a, T> {\n+    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// may or may not implement `Unpin`.\n+    ///\n+    /// This constructor is unsafe because we do not know what will happen with\n+    /// that data after the reference ends. If you cannot guarantee that the\n+    /// data will never move again, calling this constructor is invalid.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn new_unchecked(reference: &'a mut T) -> Pin<'a, T> {\n+        Pin { inner: reference }\n+    }\n+\n+    /// Borrow a Pin for a shorter lifetime than it already has.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn borrow<'b>(this: &'b mut Pin<'a, T>) -> Pin<'b, T> {\n+        Pin { inner: this.inner }\n+    }\n+\n+    /// Get a mutable reference to the data inside of this `Pin`.\n+    ///\n+    /// This function is unsafe. You must guarantee that you will never move\n+    /// the data out of the mutable reference you receive when you call this\n+    /// function.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn get_mut<'b>(this: &'b mut Pin<'a, T>) -> &'b mut T {\n+        this.inner\n+    }\n+\n+    /// Construct a new pin by mapping the interior value.\n+    ///\n+    /// For example, if you  wanted to get a `Pin` of a field of something, you\n+    /// could use this to get access to that field in one line of code.\n+    ///\n+    /// This function is unsafe. You must guarantee that the data you return\n+    /// will not move so long as the argument value does not move (for example,\n+    /// because it is one of the fields of that value), and also that you do\n+    /// not move out of the argument you receive to the interior function.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn map<'b, U, F>(this: &'b mut Pin<'a, T>, f: F) -> Pin<'b, U> where\n+        F: FnOnce(&mut T) -> &mut U\n+    {\n+        Pin { inner: f(this.inner) }\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> Deref for Pin<'a, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized + Unpin> DerefMut for Pin<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: fmt::Debug + ?Sized> fmt::Debug for Pin<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: fmt::Display + ?Sized> fmt::Display for Pin<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> fmt::Pointer for Pin<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&(&*self.inner as *const T), f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<'a, U>> for Pin<'a, T> {}"}, {"sha": "19836d98844e292d7be235601e344664faac182f", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n //! Exposes the NonZero lang item which provides optimization hints.\n-#![unstable(feature = \"nonzero\",\n-            reason = \"needs an RFC to flesh out the design\",\n-            issue = \"27730\")]\n+#![unstable(feature = \"nonzero\", reason = \"deprecated\", issue = \"49137\")]\n+#![rustc_deprecated(reason = \"use `std::ptr::NonNull` or `std::num::NonZero*` instead\",\n+                    since = \"1.26.0\")]\n+#![allow(deprecated)]\n \n use ops::CoerceUnsized;\n \n@@ -62,14 +63,11 @@ impl_zeroable_for_integer_types! {\n /// NULL or 0 that might allow certain optimizations.\n #[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n-pub struct NonZero<T: Zeroable>(T);\n+pub struct NonZero<T: Zeroable>(pub(crate) T);\n \n impl<T: Zeroable> NonZero<T> {\n     /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n-    #[unstable(feature = \"nonzero\",\n-               reason = \"needs an RFC to flesh out the design\",\n-               issue = \"27730\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)"}, {"sha": "989376d1ac2d2021f891c83d4432791ddf6ee1d4", "filename": "src/libcore/num/i128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi128.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,6 +12,6 @@\n //!\n //! *[See also the `i128` primitive type](../../std/primitive.i128.html).*\n \n-#![unstable(feature = \"i128\", issue=\"35118\")]\n+#![stable(feature = \"i128\", since = \"1.26.0\")]\n \n-int_module! { i128, #[unstable(feature = \"i128\", issue=\"35118\")] }\n+int_module! { i128, #[stable(feature = \"i128\", since=\"1.26.0\")] }"}, {"sha": "dcda404721c160582bd9e6b5bde643b7179923c8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 150, "deletions": 100, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,12 +12,111 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::{Infallible, TryFrom};\n+use convert::TryFrom;\n use fmt;\n use intrinsics;\n+#[allow(deprecated)] use nonzero::NonZero;\n use ops;\n use str::FromStr;\n \n+macro_rules! impl_nonzero_fmt {\n+    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+        $(\n+            #[$stability]\n+            #[allow(deprecated)]\n+            impl fmt::$Trait for $Ty {\n+                #[inline]\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    self.get().fmt(f)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+macro_rules! nonzero_integers {\n+    ( #[$stability: meta] #[$deprecation: meta] $( $Ty: ident($Int: ty); )+ ) => {\n+        $(\n+            /// An integer that is known not to equal zero.\n+            ///\n+            /// This may enable some memory layout optimization such as:\n+            ///\n+            /// ```rust\n+            /// # #![feature(nonzero)]\n+            /// use std::mem::size_of;\n+            /// assert_eq!(size_of::<Option<std::num::NonZeroU32>>(), size_of::<u32>());\n+            /// ```\n+            #[$stability]\n+            #[$deprecation]\n+            #[allow(deprecated)]\n+            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+            pub struct $Ty(NonZero<$Int>);\n+\n+            #[allow(deprecated)]\n+            impl $Ty {\n+                /// Create a non-zero without checking the value.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The value must not be zero.\n+                #[$stability]\n+                #[inline]\n+                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n+                    $Ty(NonZero(n))\n+                }\n+\n+                /// Create a non-zero if the given value is not zero.\n+                #[$stability]\n+                #[inline]\n+                pub fn new(n: $Int) -> Option<Self> {\n+                    if n != 0 {\n+                        Some($Ty(NonZero(n)))\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                /// Returns the value as a primitive type.\n+                #[$stability]\n+                #[inline]\n+                pub fn get(self) -> $Int {\n+                    self.0 .0\n+                }\n+\n+            }\n+\n+            impl_nonzero_fmt! {\n+                #[$stability]\n+                (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_integers! {\n+    #[unstable(feature = \"nonzero\", issue = \"49137\")]\n+    #[allow(deprecated)]  // Redundant, works around \"error: inconsistent lockstep iteration\"\n+    NonZeroU8(u8);\n+    NonZeroU16(u16);\n+    NonZeroU32(u32);\n+    NonZeroU64(u64);\n+    NonZeroU128(u128);\n+    NonZeroUsize(usize);\n+}\n+\n+nonzero_integers! {\n+    #[unstable(feature = \"nonzero\", issue = \"49137\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"\\\n+        signed non-zero integers are considered for removal due to lack of known use cases. \\\n+        If you\u2019re using them, please comment on https://github.com/rust-lang/rust/issues/49137\")]\n+    NonZeroI8(i8);\n+    NonZeroI16(i16);\n+    NonZeroI32(i32);\n+    NonZeroI64(i64);\n+    NonZeroI128(i128);\n+    NonZeroIsize(isize);\n+}\n+\n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n /// Operations like `+` on `u32` values is intended to never overflow,\n@@ -1546,11 +1645,7 @@ impl i64 {\n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n-        170141183460469231731687303715884105727, \"#![feature(i128_type)]\n-#![feature(i128)]\n-# fn main() {\n-\", \"\n-# }\" }\n+        170141183460469231731687303715884105727, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n@@ -3404,12 +3499,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"#![feature(i128_type)]\n-#![feature(i128)]\n-\n-# fn main() {\n-\", \"\n-# }\" }\n+    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\" }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n@@ -3573,7 +3663,7 @@ macro_rules! from_str_radix_int_impl {\n from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n /// The error type returned when a checked integral type conversion fails.\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n #[derive(Debug, Copy, Clone)]\n pub struct TryFromIntError(());\n \n@@ -3588,40 +3678,24 @@ impl TryFromIntError {\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n impl fmt::Display for TryFromIntError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         self.__description().fmt(fmt)\n     }\n }\n \n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl From<Infallible> for TryFromIntError {\n-    fn from(infallible: Infallible) -> TryFromIntError {\n-        match infallible {\n-        }\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+impl From<!> for TryFromIntError {\n+    fn from(never: !) -> TryFromIntError {\n+        never\n     }\n }\n \n-// no possible bounds violation\n-macro_rules! try_from_unbounded {\n-    ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n-        impl TryFrom<$source> for $target {\n-            type Error = Infallible;\n-\n-            #[inline]\n-            fn try_from(value: $source) -> Result<Self, Self::Error> {\n-                Ok(value as $target)\n-            }\n-        }\n-    )*}\n-}\n-\n // only negative bounds\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3640,7 +3714,7 @@ macro_rules! try_from_lower_bounded {\n // unsigned to signed (only positive bound)\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3659,7 +3733,7 @@ macro_rules! try_from_upper_bounded {\n // all other cases\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n-        #[unstable(feature = \"try_from\", issue = \"33417\")]\n+        #[stable(feature = \"try_from\", since = \"1.26.0\")]\n         impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n@@ -3716,82 +3790,44 @@ try_from_both_bounded!(i128, u64, u32, u16, u8);\n try_from_upper_bounded!(usize, isize);\n try_from_lower_bounded!(isize, usize);\n \n+try_from_upper_bounded!(usize, u8);\n+try_from_upper_bounded!(usize, i8, i16);\n+try_from_both_bounded!(isize, u8);\n+try_from_both_bounded!(isize, i8);\n+\n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n-\n-    try_from_upper_bounded!(usize, u8);\n-    try_from_unbounded!(usize, u16, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16);\n-    try_from_unbounded!(usize, i32, i64, i128);\n+    use convert::TryFrom;\n \n-    try_from_both_bounded!(isize, u8);\n+    // Fallible across platfoms, only implementation differs\n     try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8);\n-    try_from_unbounded!(isize, i16, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16);\n-    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16);\n     rev!(try_from_both_bounded, usize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u8);\n-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i16);\n-    rev!(try_from_both_bounded, isize, i32, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n-\n-    try_from_upper_bounded!(usize, u8, u16);\n-    try_from_unbounded!(usize, u32, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32);\n-    try_from_unbounded!(usize, i64, i128);\n+    use convert::TryFrom;\n \n-    try_from_both_bounded!(isize, u8, u16);\n+    // Fallible across platfoms, only implementation differs\n+    try_from_both_bounded!(isize, u16);\n     try_from_lower_bounded!(isize, u32, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16);\n-    try_from_unbounded!(isize, i32, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16, u32);\n-    rev!(try_from_upper_bounded, usize, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n     rev!(try_from_both_bounded, usize, i64, i128);\n-\n-    rev!(try_from_unbounded, isize, u8, u16);\n-    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i16, i32);\n-    rev!(try_from_both_bounded, isize, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::{Infallible, TryFrom};\n-\n-    try_from_upper_bounded!(usize, u8, u16, u32);\n-    try_from_unbounded!(usize, u64, u128);\n-    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n-    try_from_unbounded!(usize, i128);\n+    use convert::TryFrom;\n \n-    try_from_both_bounded!(isize, u8, u16, u32);\n+    // Fallible across platfoms, only implementation differs\n+    try_from_both_bounded!(isize, u16, u32);\n     try_from_lower_bounded!(isize, u64, u128);\n-    try_from_both_bounded!(isize, i8, i16, i32);\n-    try_from_unbounded!(isize, i64, i128);\n-\n-    rev!(try_from_unbounded, usize, u16, u32, u64);\n-    rev!(try_from_upper_bounded, usize, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n     rev!(try_from_both_bounded, usize, i128);\n-\n-    rev!(try_from_unbounded, isize, u8, u16, u32);\n-    rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i16, i32, i64);\n-    rev!(try_from_both_bounded, isize, i128);\n }\n \n #[doc(hidden)]\n@@ -3967,39 +4003,53 @@ macro_rules! impl_from {\n impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n-impl_from! { u64, u128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n \n // Signed -> Signed\n impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { i32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n-impl_from! { i64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n \n // Unsigned -> Signed\n impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u8, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u16, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n-impl_from! { u32, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n-impl_from! { u64, i128, #[unstable(feature = \"i128\", issue = \"35118\")] }\n+impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n+\n+// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n+// which imply that pointer-sized integers must be at least 16 bits:\n+// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\n+impl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+impl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n+\n+// RISC-V defines the possibility of a 128-bit address space (RV128).\n+\n+// CHERI proposes 256-bit \u201ccapabilities\u201d. Unclear if this would be relevant to usize/isize.\n+// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n+// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n+\n \n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64."}, {"sha": "e8c783a1bb542e20f573a3d6648a38cd61c36c83", "filename": "src/libcore/num/u128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu128.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -12,5 +12,5 @@\n //!\n //! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n \n-#![unstable(feature = \"i128\", issue=\"35118\")]\n-uint_module! { u128, #[unstable(feature = \"i128\", issue=\"35118\")] }\n+#![stable(feature = \"i128\", since = \"1.26.0\")]\n+uint_module! { u128, #[stable(feature = \"i128\", since=\"1.26.0\")] }"}, {"sha": "826883fdc3f01de6bf0f3f08ae47f66d6893359a", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -317,11 +317,320 @@ macro_rules! wrapping_impl {\n         }\n         forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n+\n     )*)\n }\n \n wrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n+macro_rules! wrapping_int_impl {\n+    ($($t:ty)*) => ($(\n+        impl Wrapping<$t> {\n+            /// Returns the number of ones in the binary representation of\n+            /// `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i8> = Wrapping(-0b1000_0000);\n+            ///\n+            /// assert_eq!(n.count_ones(), 1);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn count_ones(self) -> u32 {\n+                self.0.count_ones()\n+            }\n+\n+            /// Returns the number of zeros in the binary representation of\n+            /// `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i8> = Wrapping(-0b1000_0000);\n+            ///\n+            /// assert_eq!(n.count_zeros(), 7);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn count_zeros(self) -> u32 {\n+                self.0.count_zeros()\n+            }\n+\n+            /// Returns the number of leading zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i16> = Wrapping(-1);\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 0);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n+            }\n+\n+            /// Returns the number of trailing zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i8> = Wrapping(-4);\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 2);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn trailing_zeros(self) -> u32 {\n+                self.0.trailing_zeros()\n+            }\n+\n+            /// Shifts the bits to the left by a specified amount, `n`,\n+            /// wrapping the truncated bits to the end of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as `>>`!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            /// let m: Wrapping<i64> = Wrapping(-0x76543210FEDCBA99);\n+            ///\n+            /// assert_eq!(n.rotate_left(32), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn rotate_left(self, n: u32) -> Self {\n+                Wrapping(self.0.rotate_left(n))\n+            }\n+\n+            /// Shifts the bits to the right by a specified amount, `n`,\n+            /// wrapping the truncated bits to the beginning of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as `<<`!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            /// let m: Wrapping<i64> = Wrapping(-0xFEDCBA987654322);\n+            ///\n+            /// assert_eq!(n.rotate_right(4), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn rotate_right(self, n: u32) -> Self {\n+                Wrapping(self.0.rotate_right(n))\n+            }\n+\n+            /// Reverses the byte order of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i16> = Wrapping(0b0000000_01010101);\n+            /// assert_eq!(n, Wrapping(85));\n+            ///\n+            /// let m = n.swap_bytes();\n+            ///\n+            /// assert_eq!(m, Wrapping(0b01010101_00000000));\n+            /// assert_eq!(m, Wrapping(21760));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn swap_bytes(self) -> Self {\n+                Wrapping(self.0.swap_bytes())\n+            }\n+\n+            /// Converts an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(Wrapping::<i64>::from_be(n), n);\n+            /// } else {\n+            ///     assert_eq!(Wrapping::<i64>::from_be(n), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn from_be(x: Self) -> Self {\n+                Wrapping(<$t>::from_be(x.0))\n+            }\n+\n+            /// Converts an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(Wrapping::<i64>::from_le(n), n);\n+            /// } else {\n+            ///     assert_eq!(Wrapping::<i64>::from_le(n), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn from_le(x: Self) -> Self {\n+                Wrapping(<$t>::from_le(x.0))\n+            }\n+\n+            /// Converts `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n);\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn to_be(self) -> Self {\n+                Wrapping(self.0.to_be())\n+            }\n+\n+            /// Converts `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n);\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn to_le(self) -> Self {\n+                Wrapping(self.0.to_le())\n+            }\n+\n+            /// Raises self to the power of `exp`, using exponentiation by\n+            /// squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let x: Wrapping<i32> = Wrapping(2); // or any other integer type\n+            ///\n+            /// assert_eq!(x.pow(4), Wrapping(16));\n+            /// ```\n+            ///\n+            /// Results that are too large are wrapped:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// // 5 ^ 4 = 625, which is too big for a u8\n+            /// let x: Wrapping<u8> = Wrapping(5);\n+            ///\n+            /// assert_eq!(x.pow(4).0, 113);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn pow(self, exp: u32) -> Self {\n+                Wrapping(self.0.wrapping_pow(exp))\n+            }\n+        }\n+    )*)\n+}\n+\n+wrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+\n mod shift_max {\n     #![allow(non_upper_case_globals)]\n "}, {"sha": "474f7e34c3470673e0def41a06f19a83fe568ab2", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -95,7 +95,7 @@\n pub trait Drop {\n     /// Executes the destructor for this type.\n     ///\n-    /// This method is called implilcitly when the value goes out of scope,\n+    /// This method is called implicitly when the value goes out of scope,\n     /// and cannot be called explicitly (this is compiler error [E0040]).\n     /// However, the [`std::mem::drop`] function in the prelude can be\n     /// used to call the argument's `Drop` implementation."}, {"sha": "4b70c5398be4f1e138cab935b7bc54cfed3d8b00", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -56,11 +56,11 @@ pub enum GeneratorState<Y, R> {\n ///         return \"foo\"\n ///     };\n ///\n-///     match generator.resume() {\n+///     match unsafe { generator.resume() } {\n ///         GeneratorState::Yielded(1) => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n-///     match generator.resume() {\n+///     match unsafe { generator.resume() } {\n ///         GeneratorState::Complete(\"foo\") => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n@@ -98,6 +98,10 @@ pub trait Generator {\n     /// generator will continue executing until it either yields or returns, at\n     /// which point this function will return.\n     ///\n+    /// The function is unsafe because it can be used on an immovable generator.\n+    /// After such a call, the immovable generator must not move again, but\n+    /// this is not enforced by the compiler.\n+    ///\n     /// # Return value\n     ///\n     /// The `GeneratorState` enum returned from this function indicates what\n@@ -116,7 +120,7 @@ pub trait Generator {\n     /// been returned previously. While generator literals in the language are\n     /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n     /// for all implementations of the `Generator` trait.\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n }\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n@@ -125,7 +129,7 @@ impl<'a, T> Generator for &'a mut T\n {\n     type Yield = T::Yield;\n     type Return = T::Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n         (**self).resume()\n     }\n }"}, {"sha": "ce4f45762de48d3571a3f8e68660262c6d844a75", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -161,7 +161,6 @@ mod drop;\n mod function;\n mod generator;\n mod index;\n-mod place;\n mod range;\n mod try;\n mod unsize;\n@@ -191,17 +190,14 @@ pub use self::index::{Index, IndexMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-pub use self::range::{RangeInclusive, RangeToInclusive};\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+pub use self::range::{RangeInclusive, RangeToInclusive, RangeBounds, Bound};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::try::Try;\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};\n \n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n-\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n pub use self::unsize::CoerceUnsized;"}, {"sha": "b3dcf4e7ee9578c9e5155d563d332d10fe19e9ff", "filename": "src/libcore/ops/place.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n-/// that allocate an intermediate \"place\" that holds uninitialized\n-/// state.  The desugaring evaluates EXPR, and writes the result at\n-/// the address returned by the `pointer` method of this trait.\n-///\n-/// A `Place` can be thought of as a special representation for a\n-/// hypothetical `&uninit` reference (which Rust cannot currently\n-/// express directly). That is, it represents a pointer to\n-/// uninitialized storage.\n-///\n-/// The client is responsible for two steps: First, initializing the\n-/// payload (it can access its address via `pointer`). Second,\n-/// converting the agent to an instance of the owning pointer, via the\n-/// appropriate `finalize` method (see the `InPlace`.\n-///\n-/// If evaluating EXPR fails, then it is up to the destructor for the\n-/// implementation of Place to clean up any intermediate state\n-/// (e.g. deallocate box storage, pop a stack, etc).\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub unsafe trait Place<Data: ?Sized> {\n-    /// Returns the address where the input value will be written.\n-    /// Note that the data at this address is generally uninitialized,\n-    /// and thus one should use `ptr::write` for initializing it.\n-    ///\n-    /// This function must return a pointer through which a value\n-    /// of type `Data` can be written.\n-    fn pointer(&mut self) -> *mut Data;\n-}\n-\n-/// Interface to implementations of  `PLACE <- EXPR`.\n-///\n-/// `PLACE <- EXPR` effectively desugars into:\n-///\n-/// ```\n-/// # #![feature(placement_new_protocol, box_heap)]\n-/// # use std::ops::{Placer, Place, InPlace};\n-/// # #[allow(non_snake_case)]\n-/// # fn main() {\n-/// # let PLACE = std::boxed::HEAP;\n-/// # let EXPR = 1;\n-/// let p = PLACE;\n-/// let mut place = Placer::make_place(p);\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// unsafe {\n-///     std::ptr::write(raw_place, value);\n-///     InPlace::finalize(place)\n-/// }\n-/// # ; }\n-/// ```\n-///\n-/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n-/// if the type of `PLACE` is `P`, then the final type of the whole\n-/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n-/// traits).\n-///\n-/// Values for types implementing this trait usually are transient\n-/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n-/// or `Copy`, since the `make_place` method takes `self` by value.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Placer<Data: ?Sized> {\n-    /// `Place` is the intermediate agent guarding the\n-    /// uninitialized state for `Data`.\n-    type Place: InPlace<Data>;\n-\n-    /// Creates a fresh place from `self`.\n-    fn make_place(self) -> Self::Place;\n-}\n-\n-/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait InPlace<Data: ?Sized>: Place<Data> {\n-    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n-    ///\n-    /// Note that when `PLACE <- EXPR` is solely used for\n-    /// side-effecting an existing data-structure,\n-    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n-    /// information at all (e.g. it can be the unit type `()` in that\n-    /// case).\n-    type Owner;\n-\n-    /// Converts self into the final value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// the returned instance of `Owner` and forgetting self.\n-    unsafe fn finalize(self) -> Self::Owner;\n-}\n-\n-/// Core trait for the `box EXPR` form.\n-///\n-/// `box EXPR` effectively desugars into:\n-///\n-/// ```\n-/// # #![feature(placement_new_protocol)]\n-/// # use std::ops::{BoxPlace, Place, Boxed};\n-/// # #[allow(non_snake_case)]\n-/// # fn main() {\n-/// # let EXPR = 1;\n-/// let mut place = BoxPlace::make_place();\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// # let _: Box<_> =\n-/// unsafe {\n-///     ::std::ptr::write(raw_place, value);\n-///     Boxed::finalize(place)\n-/// }\n-/// # ; }\n-/// ```\n-///\n-/// The type of `box EXPR` is supplied from its surrounding\n-/// context; in the above expansion, the result type `T` is used\n-/// to determine which implementation of `Boxed` to use, and that\n-/// `<T as Boxed>` in turn dictates determines which\n-/// implementation of `BoxPlace` to use, namely:\n-/// `<<T as Boxed>::Place as BoxPlace>`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Boxed {\n-    /// The kind of data that is stored in this kind of box.\n-    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n-    /// The place that will negotiate the storage of the data.\n-    type Place: BoxPlace<Self::Data>;\n-\n-    /// Converts filled place into final owning value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// returned instance of `Self` and forgetting `filled`.\n-    unsafe fn finalize(filled: Self::Place) -> Self;\n-}\n-\n-/// Specialization of `Place` trait supporting `box EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n-    /// Creates a globally fresh place.\n-    fn make_place() -> Self;\n-}"}, {"sha": "3f6674071256696e45bf74c8229a05c85993dd71", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 278, "deletions": 25, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -128,7 +128,7 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// The range is empty if either side is incomparable:\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// use std::f32::NAN;\n     /// assert!(!(3.0..5.0).is_empty());\n@@ -283,7 +283,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// #![feature(inclusive_range_fields)]\n ///\n /// assert_eq!((3..=5), std::ops::RangeInclusive { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n@@ -293,21 +293,17 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeInclusive<Idx> {\n     /// The lower bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub start: Idx,\n     /// The upper bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[unstable(feature = \"inclusive_range_fields\", issue = \"49022\")]\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..={:?}\", self.start, self.end)\n@@ -320,7 +316,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// #![feature(range_contains)]\n     ///\n     /// assert!(!(3..=5).contains(2));\n     /// assert!( (3..=5).contains(3));\n@@ -341,7 +337,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// assert!(!(3..=5).is_empty());\n     /// assert!(!(3..=3).is_empty());\n@@ -351,7 +347,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// The range is empty if either side is incomparable:\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// use std::f32::NAN;\n     /// assert!(!(3.0..=5.0).is_empty());\n@@ -362,7 +358,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// This method returns `true` after iteration has finished:\n     ///\n     /// ```\n-    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    /// #![feature(range_is_empty)]\n     ///\n     /// let mut r = 3..=5;\n     /// for _ in r.by_ref() {}\n@@ -385,16 +381,13 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// The `..=end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax)]\n /// assert_eq!((..=5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n /// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n-/// #![feature(inclusive_range_syntax)]\n-///\n /// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n /// // std::iter::Iterator` is not satisfied\n /// for i in ..=5 {\n@@ -406,8 +399,6 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n-/// #![feature(inclusive_range_syntax)]\n-///\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ..=2], [0,1,2  ]);  // RangeToInclusive\n /// assert_eq!(arr[1..=2], [  1,2  ]);\n@@ -417,16 +408,14 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// [`Iterator`]: ../iter/trait.IntoIterator.html\n /// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub struct RangeToInclusive<Idx> {\n     /// The upper bound of the range (inclusive)\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..={:?}\", self.end)\n@@ -440,7 +429,7 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// #![feature(range_contains)]\n     ///\n     /// assert!( (..=5).contains(-1_000_000_000));\n     /// assert!( (..=5).contains(5));\n@@ -453,3 +442,267 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n \n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n+\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// #![feature(collections_range)]\n+///\n+/// use std::ops::Bound::*;\n+/// use std::ops::RangeBounds;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+///\n+/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n+/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+/// use std::ops::Bound::{Excluded, Included, Unbounded};\n+///\n+/// let mut map = BTreeMap::new();\n+/// map.insert(3, \"a\");\n+/// map.insert(5, \"b\");\n+/// map.insert(8, \"c\");\n+///\n+/// for (key, value) in map.range((Excluded(3), Included(8))) {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n+/// ```\n+///\n+/// [`BTreeMap::range`]: ../../std/collections/btree_map/struct.BTreeMap.html#method.range\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+/// `RangeBounds` is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+pub trait RangeBounds<T: ?Sized> {\n+    /// Start index bound.\n+    ///\n+    /// Returns the start value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections_range)]\n+    ///\n+    /// # fn main() {\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((..10).start(), Unbounded);\n+    /// assert_eq!((3..10).start(), Included(&3));\n+    /// # }\n+    /// ```\n+    fn start(&self) -> Bound<&T>;\n+\n+    /// End index bound.\n+    ///\n+    /// Returns the end value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections_range)]\n+    ///\n+    /// # fn main() {\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((3..).end(), Unbounded);\n+    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// # }\n+    /// ```\n+    fn end(&self) -> Bound<&T>;\n+}\n+\n+use self::Bound::{Excluded, Included, Unbounded};\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T: ?Sized> RangeBounds<T> for RangeFull {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeFrom<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeTo<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for Range<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeToInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            (Included(ref start), _) => Included(start),\n+            (Excluded(ref start), _) => Excluded(start),\n+            (Unbounded, _)           => Unbounded,\n+        }\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            (_, Included(ref end)) => Included(end),\n+            (_, Excluded(ref end)) => Excluded(end),\n+            (_, Unbounded)         => Unbounded,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+    fn start(&self) -> Bound<&T> {\n+        self.0\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        self.1\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeFrom<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeTo<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for Range<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeInclusive<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeToInclusive<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(self.end)\n+    }\n+}"}, {"sha": "ef6a8fb6a61c105686f26cef42068178ab4e46b1", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -20,7 +20,7 @@\n        any(from_method=\"from_error\", from_method=\"from_ok\"),\n        from_desugaring=\"?\"),\n       message=\"the `?` operator can only be used in a \\\n-               function that returns `Result` \\\n+               function that returns `Result` or `Option` \\\n                (or another type that implements `{Try}`)\",\n       label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n    on(all(from_method=\"into_result\", from_desugaring=\"?\"),"}, {"sha": "61ef6798b2efb2062d5c874f531c86171a573c22", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1188,6 +1188,16 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n                     None => None,\n                 }\n             }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                if self.found_none {\n+                    (0, Some(0))\n+                } else {\n+                    let (_, upper) = self.iter.size_hint();\n+                    (0, upper)\n+                }\n+            }\n         }\n \n         let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };"}, {"sha": "5a54de06b5ef2bf55cd99509d1233582a5996db4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 255, "deletions": 20, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -23,7 +23,7 @@ use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n use mem;\n-use nonzero::NonZero;\n+#[allow(deprecated)] use nonzero::NonZero;\n \n use cmp::Ordering::{self, Less, Equal, Greater};\n \n@@ -669,7 +669,7 @@ impl<T: ?Sized> *const T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -700,6 +700,124 @@ impl<T: ?Sized> *const T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        // This is the same sequence that Clang emits for pointer subtraction.\n+        // It can be neither `nsw` nor `nuw` because the input is treated as\n+        // unsigned but then the output is treated as signed, so neither works.\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        intrinsics::exact_div(d, pointee_size as _)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *const i32 = 3 as _;\n+    /// let ptr2: *const i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        d.wrapping_div(pointee_size as _)\n+    }\n+\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n@@ -1316,7 +1434,7 @@ impl<T: ?Sized> *mut T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -1347,6 +1465,113 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset-1\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).offset_from(origin)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *mut i32 = 3 as _;\n+    /// let ptr2: *mut i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).wrapping_offset_from(origin)\n+    }\n+\n     /// Computes the byte offset that needs to be applied in order to\n     /// make the pointer aligned to `align`.\n     /// If it is not possible to align the pointer, the implementation returns\n@@ -2285,6 +2510,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n #[unstable(feature = \"ptr_internals\", issue = \"0\",\n            reason = \"use NonNull instead and consider PhantomData<T> \\\n                      (if you also use #[may_dangle]), Send, and/or Sync\")]\n+#[allow(deprecated)]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     // NOTE: this marker has no consequences for variance, but is necessary\n@@ -2332,24 +2558,29 @@ impl<T: Sized> Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n+        Unique { pointer: NonZero(ptr as _), _marker: PhantomData }\n     }\n \n     /// Creates a new `Unique` if `ptr` is non-null.\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| Unique { pointer: nz, _marker: PhantomData })\n+        if !ptr.is_null() {\n+            Some(Unique { pointer: NonZero(ptr as _), _marker: PhantomData })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n     pub fn as_ptr(self) -> *mut T {\n-        self.pointer.get() as *mut T\n+        self.pointer.0 as *mut T\n     }\n \n     /// Dereferences the content.\n@@ -2392,16 +2623,18 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n     fn from(reference: &'a T) -> Self {\n-        Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n+        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n     }\n }\n \n@@ -2412,11 +2645,6 @@ impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n     }\n }\n \n-/// Previous name of `NonNull`.\n-#[rustc_deprecated(since = \"1.25.0\", reason = \"renamed to `NonNull`\")]\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-pub type Shared<T> = NonNull<T>;\n-\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using\n@@ -2425,7 +2653,7 @@ pub type Shared<T> = NonNull<T>;\n ///\n /// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n /// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<NonNull<T>>` has the same size as `NonNull<T>`.\n+/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n /// However the pointer may still dangle if it isn't dereferenced.\n ///\n /// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n@@ -2436,7 +2664,7 @@ pub type Shared<T> = NonNull<T>;\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n pub struct NonNull<T: ?Sized> {\n-    pointer: NonZero<*const T>,\n+    #[allow(deprecated)] pointer: NonZero<*const T>,\n }\n \n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n@@ -2463,6 +2691,7 @@ impl<T: Sized> NonNull<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T: ?Sized> NonNull<T> {\n     /// Creates a new `NonNull`.\n     ///\n@@ -2471,19 +2700,23 @@ impl<T: ?Sized> NonNull<T> {\n     /// `ptr` must be non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: NonZero::new_unchecked(ptr) }\n+        NonNull { pointer: NonZero(ptr as _) }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| NonNull { pointer: nz })\n+        if !ptr.is_null() {\n+            Some(NonNull { pointer: NonZero(ptr as _) })\n+        } else {\n+            None\n+        }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     pub fn as_ptr(self) -> *mut T {\n-        self.pointer.get() as *mut T\n+        self.pointer.0 as *mut T\n     }\n \n     /// Dereferences the content.\n@@ -2581,15 +2814,17 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        NonNull { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero(reference as _) }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n     fn from(reference: &'a T) -> Self {\n-        NonNull { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero(reference as _) }\n     }\n }"}, {"sha": "0f1b7cb8fcc00ea34af430396864d97bb741ab9d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1039,7 +1039,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n }\n \n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n@@ -1080,7 +1080,7 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n "}, {"sha": "1185b7acaae1f3101d34307983185843208ae8f0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -165,6 +165,37 @@ Section: Creating a string\n ///\n /// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n /// [`&str`]: ../../std/str/fn.from_utf8.html\n+///\n+/// # Examples\n+///\n+/// This error type\u2019s methods can be used to create functionality\n+/// similar to `String::from_utf8_lossy` without allocating heap memory:\n+///\n+/// ```\n+/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n+///     loop {\n+///         match ::std::str::from_utf8(input) {\n+///             Ok(valid) => {\n+///                 push(valid);\n+///                 break\n+///             }\n+///             Err(error) => {\n+///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n+///                 unsafe {\n+///                     push(::std::str::from_utf8_unchecked(valid))\n+///                 }\n+///                 push(\"\\u{FFFD}\");\n+///\n+///                 if let Some(invalid_sequence_length) = error.error_len() {\n+///                     input = &after_valid[invalid_sequence_length..]\n+///                 } else {\n+///                     break\n+///                 }\n+///             }\n+///         }\n+///     }\n+/// }\n+/// ```\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n@@ -1779,9 +1810,7 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::Index<ops::RangeInclusive<usize>> for str {\n         type Output = str;\n \n@@ -1791,9 +1820,7 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::Index<ops::RangeToInclusive<usize>> for str {\n         type Output = str;\n \n@@ -1803,18 +1830,14 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n             index.index_mut(self)\n         }\n     }\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n         #[inline]\n         fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n@@ -1997,9 +2020,7 @@ mod traits {\n         }\n     }\n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n         #[inline]\n@@ -2042,9 +2063,7 @@ mod traits {\n \n \n \n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n+    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;\n         #[inline]"}, {"sha": "d336934ec7214ad56668dae5428abfef74ee7514", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 591, "deletions": 366, "changes": 957, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -205,8 +205,11 @@ pub enum Ordering {\n     /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// When coupled with a load, uses [`Acquire`] ordering, and with a store\n-    /// [`Release`] ordering.\n+    /// Has the effects of both [`Acquire`] and [`Release`] together.\n+    ///\n+    /// This ordering is only applicable for operations that combine both loads and stores.\n+    ///\n+    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n     ///\n     /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n     /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n@@ -948,6 +951,8 @@ macro_rules! atomic_int {\n      $stable_from:meta,\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n+     $extra_feature:expr,\n+     $min_fn:ident, $max_fn:ident,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -959,12 +964,7 @@ macro_rules! atomic_int {\n         /// ). For more about the differences between atomic types and\n         /// non-atomic types, please see the [module-level documentation].\n         ///\n-        /// Please note that examples are shared between atomic variants of\n-        /// primitive integer types, so it's normal that they are all\n-        /// demonstrating [`AtomicIsize`].\n-        ///\n         /// [module-level documentation]: index.html\n-        /// [`AtomicIsize`]: struct.AtomicIsize.html\n         #[$stable]\n         pub struct $atomic_type {\n             v: UnsafeCell<$int_type>,\n@@ -1001,396 +1001,549 @@ macro_rules! atomic_int {\n         unsafe impl Sync for $atomic_type {}\n \n         impl $atomic_type {\n-            /// Creates a new atomic integer.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let atomic_forty_two  = AtomicIsize::new(42);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub const fn new(v: $int_type) -> Self {\n-                $atomic_type {v: UnsafeCell::new(v)}\n+            doc_comment! {\n+                concat!(\"Creates a new atomic integer.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub const fn new(v: $int_type) -> Self {\n+                    $atomic_type {v: UnsafeCell::new(v)}\n+                }\n             }\n \n-            /// Returns a mutable reference to the underlying integer.\n-            ///\n-            /// This is safe because the mutable reference guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let mut some_isize = AtomicIsize::new(10);\n-            /// assert_eq!(*some_isize.get_mut(), 10);\n-            /// *some_isize.get_mut() = 5;\n-            /// assert_eq!(some_isize.load(Ordering::SeqCst), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn get_mut(&mut self) -> &mut $int_type {\n-                unsafe { &mut *self.v.get() }\n+            doc_comment! {\n+                concat!(\"Returns a mutable reference to the underlying integer.\n+\n+This is safe because the mutable reference guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_var = \", stringify!($atomic_type), \"::new(10);\n+assert_eq!(*some_var.get_mut(), 10);\n+*some_var.get_mut() = 5;\n+assert_eq!(some_var.load(Ordering::SeqCst), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn get_mut(&mut self) -> &mut $int_type {\n+                    unsafe { &mut *self.v.get() }\n+                }\n             }\n \n-            /// Consumes the atomic and returns the contained value.\n-            ///\n-            /// This is safe because passing `self` by value guarantees that no other threads are\n-            /// concurrently accessing the atomic data.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::AtomicIsize;\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            /// assert_eq!(some_isize.into_inner(), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable_access]\n-            pub fn into_inner(self) -> $int_type {\n-                self.v.into_inner()\n+            doc_comment! {\n+                concat!(\"Consumes the atomic and returns the contained value.\n+\n+This is safe because passing `self` by value guarantees that no other threads are\n+concurrently accessing the atomic data.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+assert_eq!(some_var.into_inner(), 5);\n+```\"),\n+                #[inline]\n+                #[$stable_access]\n+                pub fn into_inner(self) -> $int_type {\n+                    self.v.into_inner()\n+                }\n             }\n \n-            /// Loads a value from the atomic integer.\n-            ///\n-            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Release`] or [`AcqRel`].\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn load(&self, order: Ordering) -> $int_type {\n-                unsafe { atomic_load(self.v.get(), order) }\n+            doc_comment! {\n+                concat!(\"Loads a value from the atomic integer.\n+\n+`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+# Panics\n+\n+Panics if `order` is [`Release`] or [`AcqRel`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.load(Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn load(&self, order: Ordering) -> $int_type {\n+                    unsafe { atomic_load(self.v.get(), order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer.\n-            ///\n-            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// some_isize.store(10, Ordering::Relaxed);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            ///\n-            /// # Panics\n-            ///\n-            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-            ///\n-            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            #[inline]\n-            #[$stable]\n-            pub fn store(&self, val: $int_type, order: Ordering) {\n-                unsafe { atomic_store(self.v.get(), val, order); }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer.\n+\n+`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+some_var.store(10, Ordering::Relaxed);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\n+\n+# Panics\n+\n+Panics if `order` is [`Acquire`] or [`AcqRel`].\n+\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn store(&self, val: $int_type, order: Ordering) {\n+                    unsafe { atomic_store(self.v.get(), val, order); }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer, returning the previous value.\n-            ///\n-            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n-            /// operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_swap(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer, returning the previous value.\n+\n+`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_swap(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is always the previous value. If it is equal to `current`, then the\n-            /// value was updated.\n-            ///\n-            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-            /// ordering of this operation.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn compare_and_swap(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    order: Ordering) -> $int_type {\n-                match self.compare_exchange(current,\n-                                            new,\n-                                            order,\n-                                            strongest_failure_ordering(order)) {\n-                    Ok(x) => x,\n-                    Err(x) => x,\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is always the previous value. If it is equal to `current`, then the\n+value was updated.\n+\n+`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+ordering of this operation.\n+\n+[`Ordering`]: enum.Ordering.html\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn compare_and_swap(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        order: Ordering) -> $int_type {\n+                    match self.compare_exchange(current,\n+                                                new,\n+                                                order,\n+                                                strongest_failure_ordering(order)) {\n+                        Ok(x) => x,\n+                        Err(x) => x,\n+                    }\n                 }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// The return value is a result indicating whether the new value was written and\n-            /// containing the previous value. On success this value is guaranteed to be equal to\n-            /// `current`.\n-            ///\n-            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if\n-            /// the operation succeeds while the second describes the required ordering when\n-            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let some_isize = AtomicIsize::new(5);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(5, 10,\n-            ///                                        Ordering::Acquire,\n-            ///                                        Ordering::Relaxed),\n-            ///            Ok(5));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            ///\n-            /// assert_eq!(some_isize.compare_exchange(6, 12,\n-            ///                                        Ordering::SeqCst,\n-            ///                                        Ordering::Acquire),\n-            ///            Err(10));\n-            /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange(&self,\n-                                    current: $int_type,\n-                                    new: $int_type,\n-                                    success: Ordering,\n-                                    failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+The return value is a result indicating whether the new value was written and\n+containing the previous value. On success this value is guaranteed to be equal to\n+`current`.\n+\n+`compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if\n+the operation succeeds while the second describes the required ordering when\n+the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let some_var = \", stringify!($atomic_type), \"::new(5);\n+\n+assert_eq!(some_var.compare_exchange(5, 10,\n+                                     Ordering::Acquire,\n+                                     Ordering::Relaxed),\n+           Ok(5));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+\n+assert_eq!(some_var.compare_exchange(6, 12,\n+                                     Ordering::SeqCst,\n+                                     Ordering::Acquire),\n+           Err(10));\n+assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange(&self,\n+                                        current: $int_type,\n+                                        new: $int_type,\n+                                        success: Ordering,\n+                                        failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+                }\n             }\n \n-            /// Stores a value into the atomic integer if the current value is the same as the\n-            /// `current` value.\n-            ///\n-            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n-            /// when the comparison succeeds, which can result in more efficient code on some\n-            /// platforms. The return value is a result indicating whether the new value was\n-            /// written and containing the previous value.\n-            ///\n-            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-            /// ordering of this operation. The first describes the required ordering if the\n-            /// operation succeeds while the second describes the required ordering when the\n-            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-            /// must be equivalent or weaker than the success ordering.\n-            ///\n-            /// [`compare_exchange`]: #method.compare_exchange\n-            /// [`Ordering`]: enum.Ordering.html\n-            /// [`Release`]: enum.Ordering.html#variant.Release\n-            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let val = AtomicIsize::new(4);\n-            ///\n-            /// let mut old = val.load(Ordering::Relaxed);\n-            /// loop {\n-            ///     let new = old * 2;\n-            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-            ///         Ok(_) => break,\n-            ///         Err(x) => old = x,\n-            ///     }\n-            /// }\n-            /// ```\n-            #[inline]\n-            #[$stable_cxchg]\n-            pub fn compare_exchange_weak(&self,\n-                                         current: $int_type,\n-                                         new: $int_type,\n-                                         success: Ordering,\n-                                         failure: Ordering) -> Result<$int_type, $int_type> {\n-                unsafe {\n-                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+            doc_comment! {\n+                concat!(\"Stores a value into the atomic integer if the current value is the same as\n+the `current` value.\n+\n+Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+when the comparison succeeds, which can result in more efficient code on some\n+platforms. The return value is a result indicating whether the new value was\n+written and containing the previous value.\n+\n+`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering if the\n+operation succeeds while the second describes the required ordering when the\n+operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+must be equivalent or weaker than the success ordering.\n+\n+[`compare_exchange`]: #method.compare_exchange\n+[`Ordering`]: enum.Ordering.html\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let val = \", stringify!($atomic_type), \"::new(4);\n+\n+let mut old = val.load(Ordering::Relaxed);\n+loop {\n+    let new = old * 2;\n+    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+        Ok(_) => break,\n+        Err(x) => old = x,\n+    }\n+}\n+```\"),\n+                #[inline]\n+                #[$stable_cxchg]\n+                pub fn compare_exchange_weak(&self,\n+                                             current: $int_type,\n+                                             new: $int_type,\n+                                             success: Ordering,\n+                                             failure: Ordering) -> Result<$int_type, $int_type> {\n+                    unsafe {\n+                        atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+                    }\n                 }\n             }\n \n-            /// Adds to the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_add(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Adds to the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0);\n+assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_add(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Subtracts from the current value, returning the previous value.\n-            ///\n-            /// This operation wraps around on overflow.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0);\n-            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), -10);\n-            /// ```\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_sub(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Subtracts from the current value, returning the previous value.\n+\n+This operation wraps around on overflow.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(20);\n+assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n+assert_eq!(foo.load(Ordering::SeqCst), 10);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_sub(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"and\" with the current value.\n-            ///\n-            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_and(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"and\\\" with the current value.\n+\n+Performs a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_and(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"nand\" with the current value.\n-            ///\n-            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// #![feature(atomic_nand)]\n-            ///\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0xf731);\n-            /// assert_eq!(foo.fetch_nand(0x137f, Ordering::SeqCst), 0xf731);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), !(0xf731 & 0x137f));\n-            #[inline]\n-            #[$stable_nand]\n-            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_nand(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"nand\\\" with the current value.\n+\n+Performs a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"#![feature(atomic_nand)]\n+\n+use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0x13);\n+assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n+assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n+```\"),\n+                #[inline]\n+                #[$stable_nand]\n+                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_nand(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"or\" with the current value.\n-            ///\n-            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_or(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"or\\\" with the current value.\n+\n+Performs a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_or(self.v.get(), val, order) }\n+                }\n             }\n \n-            /// Bitwise \"xor\" with the current value.\n-            ///\n-            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n-            /// sets the new value to the result.\n-            ///\n-            /// Returns the previous value.\n-            ///\n-            /// # Examples\n-            ///\n-            /// ```\n-            /// use std::sync::atomic::{AtomicIsize, Ordering};\n-            ///\n-            /// let foo = AtomicIsize::new(0b101101);\n-            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-            #[inline]\n-            #[$stable]\n-            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n-                unsafe { atomic_xor(self.v.get(), val, order) }\n+            doc_comment! {\n+                concat!(\"Bitwise \\\"xor\\\" with the current value.\n+\n+Performs a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(0b101101);\n+assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+```\"),\n+                #[inline]\n+                #[$stable]\n+                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { atomic_xor(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Fetches the value, and applies a function to it that returns an optional\n+new value. Returns a `Result` (`Ok(_)` if the function returned `Some(_)`, else `Err(_)`) of the\n+previous value.\n+\n+Note: This may call the function multiple times if the value has been changed from other threads in\n+the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n+but once to the stored value.\n+\n+# Examples\n+\n+```rust\n+#![feature(no_more_cas)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let x = \", stringify!($atomic_type), \"::new(7);\n+assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.load(Ordering::SeqCst), 9);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"no_more_cas\",\n+                       reason = \"no more CAS loops in user code\",\n+                       issue = \"48655\")]\n+                pub fn fetch_update<F>(&self,\n+                                       mut f: F,\n+                                       fetch_order: Ordering,\n+                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                where F: FnMut($int_type) -> Option<$int_type> {\n+                    let mut prev = self.load(fetch_order);\n+                    while let Some(next) = f(prev) {\n+                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                            x @ Ok(_) => return x,\n+                            Err(next_prev) => prev = next_prev\n+                        }\n+                    }\n+                    Err(prev)\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Maximum with the current value.\n+\n+Finds the maximum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n+assert_eq!(foo.load(Ordering::SeqCst), 42);\n+```\n+\n+If you want to obtain the maximum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 42;\n+let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n+assert!(max_foo == 42);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $max_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Minimum with the current value.\n+\n+Finds the minimum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 23);\n+assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 22);\n+```\n+\n+If you want to obtain the minimum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 12;\n+let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n+assert_eq!(min_foo, 12);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $min_fn(self.v.get(), val, order) }\n+                }\n             }\n+\n         }\n     }\n }\n@@ -1404,6 +1557,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1415,6 +1570,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1426,6 +1583,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1437,6 +1596,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1448,6 +1609,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1459,6 +1622,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1470,6 +1635,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1481,6 +1648,8 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n+    \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1492,6 +1661,8 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n+    \"\",\n+    atomic_min, atomic_max,\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1503,6 +1674,8 @@ atomic_int!{\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n+    \"\",\n+    atomic_umin, atomic_umax,\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1680,6 +1853,58 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_max(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_min(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umax(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umin(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n /// An atomic fence.\n ///\n /// Depending on the specified order, a fence prevents the compiler and CPU from"}, {"sha": "950222dbcfa3fe8d303097e6832e0af6af648196", "filename": "src/libcore/tests/ascii.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -0,0 +1,357 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::char::from_u32;\n+\n+#[test]\n+fn test_is_ascii() {\n+    assert!(b\"\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n+\n+    assert!(\"\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n+}\n+\n+#[test]\n+fn test_to_ascii_uppercase() {\n+    assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n+    assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n+                   (from_u32(upper).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_to_ascii_lowercase() {\n+    assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n+                   (from_u32(lower).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_make_ascii_lower_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_lowercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'A', b'a');\n+    test!(b'a', b'a');\n+    test!(b'!', b'!');\n+    test!('A', 'a');\n+    test!('\u00c0', '\u00c0');\n+    test!('a', 'a');\n+    test!('!', '!');\n+    test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n+    test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n+}\n+\n+\n+#[test]\n+fn test_make_ascii_upper_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_uppercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'a', b'A');\n+    test!(b'A', b'A');\n+    test!(b'!', b'!');\n+    test!('a', 'A');\n+    test!('\u00e0', '\u00e0');\n+    test!('A', 'A');\n+    test!('!', '!');\n+    test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n+    test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n+\n+    let mut x = \"Hello\".to_string();\n+    x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+    assert_eq!(x, \"HELlo\")\n+}\n+\n+#[test]\n+fn test_eq_ignore_ascii_case() {\n+    assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n+    assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n+    assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n+    assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n+    assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n+                &from_u32(lower).unwrap().to_string()));\n+    }\n+}\n+\n+#[test]\n+fn inference_works() {\n+    let x = \"a\".to_string();\n+    x.eq_ignore_ascii_case(\"A\");\n+}\n+\n+// Shorthands used by the is_ascii_* tests.\n+macro_rules! assert_all {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if !b.$what() {\n+                    panic!(\"expected {}({}) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if !b.$what() {\n+                    panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+        )+\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+}\n+macro_rules! assert_none {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}({}) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+        )*\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+}\n+\n+#[test]\n+fn test_is_ascii_alphabetic() {\n+    assert_all!(is_ascii_alphabetic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_alphabetic,\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_uppercase() {\n+    assert_all!(is_ascii_uppercase,\n+        \"\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_uppercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_lowercase() {\n+    assert_all!(is_ascii_lowercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+    );\n+    assert_none!(is_ascii_lowercase,\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_alphanumeric() {\n+    assert_all!(is_ascii_alphanumeric,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_alphanumeric,\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_digit() {\n+    assert_all!(is_ascii_digit,\n+        \"\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_digit,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_hexdigit() {\n+    assert_all!(is_ascii_hexdigit,\n+        \"\",\n+        \"0123456789\",\n+        \"abcdefABCDEF\",\n+    );\n+    assert_none!(is_ascii_hexdigit,\n+        \"ghijklmnopqrstuvwxyz\",\n+        \"GHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_punctuation() {\n+    assert_all!(is_ascii_punctuation,\n+        \"\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_punctuation,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_graphic() {\n+    assert_all!(is_ascii_graphic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_graphic,\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_whitespace() {\n+    assert_all!(is_ascii_whitespace,\n+        \"\",\n+        \" \\t\\n\\x0c\\r\",\n+    );\n+    assert_none!(is_ascii_whitespace,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x0b\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_control() {\n+    assert_all!(is_ascii_control,\n+        \"\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+    assert_none!(is_ascii_control,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \",\n+    );\n+}"}, {"sha": "bc205ec0582ea8c7ae1405c323494fa62eb67aff", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -150,3 +150,9 @@ fn test_format_int_twos_complement() {\n     assert!(format!(\"{}\", i32::MIN) == \"-2147483648\");\n     assert!(format!(\"{}\", i64::MIN) == \"-9223372036854775808\");\n }\n+\n+#[test]\n+fn test_format_debug_hex() {\n+    assert!(format!(\"{:02x?}\", b\"Foo\\0\") == \"[46, 6f, 6f, 00]\");\n+    assert!(format!(\"{:02X?}\", b\"Foo\\0\") == \"[46, 6F, 6F, 00]\");\n+}"}, {"sha": "bad858011e960e4513fbe29a36ea5c9c4640de83", "filename": "src/libcore/tests/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fsip.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -11,7 +11,7 @@\n #![allow(deprecated)]\n \n use core::hash::{Hash, Hasher};\n-use core::hash::{SipHasher, SipHasher13, SipHasher24};\n+use core::hash::{SipHasher, SipHasher13};\n use core::{slice, mem};\n \n // Hash just the bytes of the slice, without length prefix\n@@ -224,14 +224,14 @@ fn test_siphash_2_4() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n     let mut buf = Vec::new();\n     let mut t = 0;\n-    let mut state_inc = SipHasher24::new_with_keys(k0, k1);\n+    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n \n     while t < 64 {\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with(SipHasher24::new_with_keys(k0, k1), &Bytes(&buf));\n+        let out = hash_with(SipHasher::new_with_keys(k0, k1), &Bytes(&buf));\n         assert_eq!(vec, out);\n \n-        let full = hash_with(SipHasher24::new_with_keys(k0, k1), &Bytes(&buf));\n+        let full = hash_with(SipHasher::new_with_keys(k0, k1), &Bytes(&buf));\n         let i = state_inc.finish();\n \n         assert_eq!(full, i);\n@@ -322,13 +322,13 @@ fn test_hash_no_concat_alias() {\n #[test]\n fn test_write_short_works() {\n     let test_usize = 0xd0c0b0a0usize;\n-    let mut h1 = SipHasher24::new();\n+    let mut h1 = SipHasher::new();\n     h1.write_usize(test_usize);\n     h1.write(b\"bytes\");\n     h1.write(b\"string\");\n     h1.write_u8(0xFFu8);\n     h1.write_u8(0x01u8);\n-    let mut h2 = SipHasher24::new();\n+    let mut h2 = SipHasher::new();\n     h2.write(unsafe {\n         slice::from_raw_parts(&test_usize as *const _ as *const u8,\n                               mem::size_of::<usize>())"}, {"sha": "2abac0cf1d5b93bd01ca47407eb4e0b997e3ce69", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1146,6 +1146,33 @@ fn test_find() {\n     assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n }\n \n+#[test]\n+fn test_find_map() {\n+    let xs: &[isize] = &[];\n+    assert_eq!(xs.iter().find_map(half_if_even), None);\n+    let xs: &[isize] = &[3, 5];\n+    assert_eq!(xs.iter().find_map(half_if_even), None);\n+    let xs: &[isize] = &[4, 5];\n+    assert_eq!(xs.iter().find_map(half_if_even), Some(2));\n+    let xs: &[isize] = &[3, 6];\n+    assert_eq!(xs.iter().find_map(half_if_even), Some(3));\n+\n+    let xs: &[isize] = &[1, 2, 3, 4, 5, 6, 7];\n+    let mut iter = xs.iter();\n+    assert_eq!(iter.find_map(half_if_even), Some(1));\n+    assert_eq!(iter.find_map(half_if_even), Some(2));\n+    assert_eq!(iter.find_map(half_if_even), Some(3));\n+    assert_eq!(iter.next(), Some(&7));\n+\n+    fn half_if_even(x: &isize) -> Option<isize> {\n+        if x % 2 == 0 {\n+            Some(x / 2)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[test]\n fn test_position() {\n     let v = &[1, 3, 9, 27, 103, 14, 11];"}, {"sha": "de7211e718c9f20333b33a576cbf019f71cc1389", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -10,6 +10,7 @@\n \n #![deny(warnings)]\n \n+#![feature(ascii_ctype)]\n #![feature(box_syntax)]\n #![feature(core_float)]\n #![feature(core_private_bignum)]\n@@ -20,39 +21,39 @@\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(hashmap_internals)]\n #![feature(iterator_step_by)]\n-#![feature(i128_type)]\n-#![feature(inclusive_range)]\n-#![feature(inclusive_range_syntax)]\n-#![feature(iterator_try_fold)]\n+#![cfg_attr(stage0, feature(i128_type))]\n+#![cfg_attr(stage0, feature(inclusive_range_syntax))]\n #![feature(iterator_flatten)]\n-#![feature(conservative_impl_trait)]\n-#![feature(iter_rfind)]\n-#![feature(iter_rfold)]\n+#![cfg_attr(stage0, feature(conservative_impl_trait))]\n #![feature(iterator_repeat_with)]\n #![feature(nonzero)]\n #![feature(pattern)]\n #![feature(range_is_empty)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n-#![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n+#![feature(slice_rotate)]\n #![feature(sort_internals)]\n #![feature(specialization)]\n #![feature(step_trait)]\n #![feature(test)]\n #![feature(trusted_len)]\n-#![feature(try_from)]\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n #![feature(atomic_nand)]\n #![feature(reverse_bits)]\n+#![feature(inclusive_range_fields)]\n+#![feature(iterator_find_map)]\n \n extern crate core;\n extern crate test;\n+extern crate rand;\n \n mod any;\n mod array;\n+mod ascii;\n mod atomic;\n mod cell;\n mod char;"}, {"sha": "8d39298bac3d1b1b3cd13210987fac5e94a1bf71", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -8,36 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::nonzero::NonZero;\n+use core::num::NonZeroU32;\n use core::option::Option;\n use core::option::Option::{Some, None};\n use std::mem::size_of;\n \n #[test]\n fn test_create_nonzero_instance() {\n     let _a = unsafe {\n-        NonZero::new_unchecked(21)\n+        NonZeroU32::new_unchecked(21)\n     };\n }\n \n #[test]\n fn test_size_nonzero_in_option() {\n-    assert_eq!(size_of::<NonZero<u32>>(), size_of::<Option<NonZero<u32>>>());\n+    assert_eq!(size_of::<NonZeroU32>(), size_of::<Option<NonZeroU32>>());\n }\n \n #[test]\n fn test_match_on_nonzero_option() {\n     let a = Some(unsafe {\n-        NonZero::new_unchecked(42)\n+        NonZeroU32::new_unchecked(42)\n     });\n     match a {\n         Some(val) => assert_eq!(val.get(), 42),\n-        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n     }\n \n-    match unsafe { Some(NonZero::new_unchecked(43)) } {\n+    match unsafe { Some(NonZeroU32::new_unchecked(43)) } {\n         Some(val) => assert_eq!(val.get(), 43),\n-        None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n+        None => panic!(\"unexpected None while matching on Some(NonZeroU32(_))\")\n     }\n }\n \n@@ -98,3 +98,26 @@ fn test_match_option_string() {\n         None => panic!(\"unexpected None while matching on Some(String { ... })\")\n     }\n }\n+\n+mod atom {\n+    use core::num::NonZeroU32;\n+\n+    #[derive(PartialEq, Eq)]\n+    pub struct Atom {\n+        index: NonZeroU32, // private\n+    }\n+    pub const FOO_ATOM: Atom = Atom { index: unsafe { NonZeroU32::new_unchecked(7) } };\n+}\n+\n+macro_rules! atom {\n+    (\"foo\") => { atom::FOO_ATOM }\n+}\n+\n+#[test]\n+fn test_match_nonzero_const_pattern() {\n+    match atom!(\"foo\") {\n+        // Using as a pattern is supported by the compiler:\n+        atom!(\"foo\") => {}\n+        _ => panic!(\"Expected the const item as a pattern to match.\")\n+    }\n+}"}, {"sha": "04567e25e25ba243a3b1fc3c766f848fa56e20c8", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -23,6 +23,7 @@ mod strategy {\n     mod dragon;\n     mod grisu;\n }\n+mod random;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {"}, {"sha": "315ac4d7d99f53650a3a61c07307078bef959df9", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:--test\n-\n-#![feature(rustc_private, flt2dec)]\n-\n-extern crate core;\n-extern crate rand;\n+#![cfg(not(target_arch = \"wasm32\"))]\n \n use std::i16;\n use std::mem;\n@@ -24,8 +19,9 @@ use core::num::flt2dec::strategy::grisu::format_exact_opt;\n use core::num::flt2dec::strategy::grisu::format_shortest_opt;\n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-use rand::{Rand, XorShiftRng};\n+use rand::{self, Rand, XorShiftRng};\n use rand::distributions::{IndependentSample, Range};\n+\n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n         FullDecoded::Finite(decoded) => decoded,\n@@ -161,3 +157,4 @@ fn exact_f64_random_equivalence_test() {\n                                              |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n     }\n }\n+", "previous_filename": "src/test/run-pass-fulldeps/flt2dec.rs"}, {"sha": "c7edb55b378c36ce1208c32a96ef6b448f15c778", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -37,15 +37,6 @@ mod flt2dec;\n mod dec2flt;\n mod bignum;\n \n-\n-/// Adds the attribute to all items in the block.\n-macro_rules! cfg_block {\n-    ($(#[$attr:meta]{$($it:item)*})*) => {$($(\n-        #[$attr]\n-        $it\n-    )*)*}\n-}\n-\n /// Groups items that assume the pointer width is either 16/32/64, and has to be altered if\n /// support for larger/smaller pointer widths are added in the future.\n macro_rules! assume_usize_width {\n@@ -318,42 +309,6 @@ assume_usize_width! {\n \n     test_impl_try_from_always_ok! { test_try_u16usize, u16, usize }\n     test_impl_try_from_always_ok! { test_try_i16isize, i16, isize }\n-\n-    test_impl_try_from_always_ok! { test_try_usizeu64, usize, u64 }\n-    test_impl_try_from_always_ok! { test_try_usizeu128, usize, u128 }\n-    test_impl_try_from_always_ok! { test_try_usizei128, usize, i128 }\n-\n-    test_impl_try_from_always_ok! { test_try_isizei64, isize, i64 }\n-    test_impl_try_from_always_ok! { test_try_isizei128, isize, i128 }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_always_ok! { test_try_usizeu16, usize, u16 }\n-            test_impl_try_from_always_ok! { test_try_isizei16, isize, i16 }\n-            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n-            test_impl_try_from_always_ok! { test_try_usizei32, usize, i32 }\n-            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n-            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_always_ok! { test_try_usizeu32, usize, u32 }\n-            test_impl_try_from_always_ok! { test_try_isizei32, isize, i32 }\n-            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_always_ok! { test_try_usizei64, usize, i64 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_always_ok! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_always_ok! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_always_ok! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_always_ok! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_always_ok! { test_try_u64usize, u64, usize }\n-            test_impl_try_from_always_ok! { test_try_i64isize, i64, isize }\n-        }\n-    );\n }\n \n /// Conversions where max of $source can be represented as $target,\n@@ -402,24 +357,6 @@ assume_usize_width! {\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu64, isize, u64 }\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu128, isize, u128 }\n     test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeusize, isize, usize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu16, isize, u16 }\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_isizeu32, isize, u32 }\n-\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32usize, i32, usize }\n-            test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64usize, i64, usize }\n-        }\n-    );\n }\n \n /// Conversions where max of $source can not be represented as $target,\n@@ -461,29 +398,9 @@ test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i64, u128, i64 }\n test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128i128, u128, i128 }\n \n assume_usize_width! {\n-    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64isize, u64, isize }\n-    test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u128isize, u128, isize }\n-\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei8, usize, i8 }\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei16, usize, i16 }\n     test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizeisize, usize, isize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16isize, u16, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32isize, u32, isize }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei32, usize, i32 }\n-            test_impl_try_from_unsigned_to_signed_upper_err! { test_try_usizei64, usize, i64 }\n-        }\n-    );\n }\n \n /// Conversions where min/max of $source can not be represented as $target.\n@@ -543,34 +460,6 @@ test_impl_try_from_same_sign_err! { test_try_i128i64, i128, i64 }\n \n assume_usize_width! {\n     test_impl_try_from_same_sign_err! { test_try_usizeu8, usize, u8 }\n-    test_impl_try_from_same_sign_err! { test_try_u128usize, u128, usize }\n-    test_impl_try_from_same_sign_err! { test_try_i128isize, i128, isize }\n-\n-    cfg_block!(\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_same_sign_err! { test_try_u32usize, u32, usize }\n-            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n-\n-            test_impl_try_from_same_sign_err! { test_try_i32isize, i32, isize }\n-            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_same_sign_err! { test_try_u64usize, u64, usize }\n-            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n-\n-            test_impl_try_from_same_sign_err! { test_try_i64isize, i64, isize }\n-            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_same_sign_err! { test_try_usizeu16, usize, u16 }\n-            test_impl_try_from_same_sign_err! { test_try_usizeu32, usize, u32 }\n-\n-            test_impl_try_from_same_sign_err! { test_try_isizei16, isize, i16 }\n-            test_impl_try_from_same_sign_err! { test_try_isizei32, isize, i32 }\n-        }\n-    );\n }\n \n /// Conversions where neither the min nor the max of $source can be represented by\n@@ -615,22 +504,6 @@ test_impl_try_from_signed_to_unsigned_err! { test_try_i128u64, i128, u64 }\n assume_usize_width! {\n     test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu8, isize, u8 }\n     test_impl_try_from_signed_to_unsigned_err! { test_try_i128usize, i128, usize }\n-\n-    cfg_block! {\n-        #[cfg(target_pointer_width = \"16\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i32usize, i32, usize }\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n-        }\n-        #[cfg(target_pointer_width = \"32\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_i64usize, i64, usize }\n-\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n-        }\n-        #[cfg(target_pointer_width = \"64\")] {\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu16, isize, u16 }\n-            test_impl_try_from_signed_to_unsigned_err! { test_try_isizeu32, isize, u32 }\n-        }\n-    }\n }\n \n macro_rules! test_float {"}, {"sha": "53fdfa0682742454284a2ea9bdea79970d335a6c", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -10,7 +10,6 @@\n \n use core::result::Result::{Ok, Err};\n \n-\n #[test]\n fn test_position() {\n     let b = [1, 2, 3, 5, 5];\n@@ -481,3 +480,73 @@ fn test_rotate_right() {\n         assert_eq!(a[(i + 42) % N], i);\n     }\n }\n+\n+#[test]\n+#[cfg(not(target_arch = \"wasm32\"))]\n+fn sort_unstable() {\n+    use core::cmp::Ordering::{Equal, Greater, Less};\n+    use core::slice::heapsort;\n+    use rand::{Rng, XorShiftRng};\n+\n+    let mut v = [0; 600];\n+    let mut tmp = [0; 600];\n+    let mut rng = XorShiftRng::new_unseeded();\n+\n+    for len in (2..25).chain(500..510) {\n+        let v = &mut v[0..len];\n+        let tmp = &mut tmp[0..len];\n+\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..100 {\n+                for i in 0..len {\n+                    v[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                // Sort in default order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable();\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| a.cmp(b));\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| b.cmp(a));\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Test heapsort using `<` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a < b);\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Test heapsort using `>` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a > b);\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+            }\n+        }\n+    }\n+\n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_unstable();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n+    // Should not panic.\n+    [0i32; 0].sort_unstable();\n+    [(); 10].sort_unstable();\n+    [(); 100].sort_unstable();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort_unstable();\n+    assert!(v == [0xDEADBEEF]);\n+}"}, {"sha": "0f45f965104cadff7b8cce5e168e73a0036cf36b", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -108,6 +108,10 @@ pub enum Flag {\n     /// For numbers, this means that the number will be padded with zeroes,\n     /// and the sign (`+` or `-`) will precede them.\n     FlagSignAwareZeroPad,\n+    /// For Debug / `?`, format integers in lower-case hexadecimal.\n+    FlagDebugLowerHex,\n+    /// For Debug / `?`, format integers in upper-case hexadecimal.\n+    FlagDebugUpperHex,\n }\n \n /// A count is used for the precision and width parameters of an integer, and\n@@ -377,8 +381,22 @@ impl<'a> Parser<'a> {\n                 spec.precision = self.count();\n             }\n         }\n-        // Finally the actual format specifier\n-        if self.consume('?') {\n+        // Optional radix followed by the actual format specifier\n+        if self.consume('x') {\n+            if self.consume('?') {\n+                spec.flags |= 1 << (FlagDebugLowerHex as u32);\n+                spec.ty = \"?\";\n+            } else {\n+                spec.ty = \"x\";\n+            }\n+        } else if self.consume('X') {\n+            if self.consume('?') {\n+                spec.flags |= 1 << (FlagDebugUpperHex as u32);\n+                spec.ty = \"?\";\n+            } else {\n+                spec.ty = \"X\";\n+            }\n+        } else if self.consume('?') {\n             spec.ty = \"?\";\n         } else {\n             spec.ty = self.word();"}, {"sha": "81fa0374f549e903f5384737f1d000d6c4a8ba2d", "filename": "src/libgetopts/lib.rs", "status": "removed", "additions": 0, "deletions": 1622, "changes": 1622, "blob_url": "https://github.com/rust-lang/rust/blob/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c649fbed4d4d86aed16dff8c0245b4871353cd1/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=6c649fbed4d4d86aed16dff8c0245b4871353cd1", "patch": "@@ -1,1622 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple getopt alternative.\n-//!\n-//! Construct a vector of options, either by using `reqopt`, `optopt`, and `optflag`\n-//! or by building them from components yourself, and pass them to `getopts`,\n-//! along with a vector of actual arguments (not including `argv[0]`). You'll\n-//! either get a failure code back, or a match. You'll have to verify whether\n-//! the amount of 'free' arguments in the match is what you expect. Use `opt_*`\n-//! accessors to get argument values out of the matches object.\n-//!\n-//! Single-character options are expected to appear on the command line with a\n-//! single preceding dash; multiple-character options are expected to be\n-//! proceeded by two dashes. Options that expect an argument accept their\n-//! argument following either a space or an equals sign. Single-character\n-//! options don't require the space.\n-//!\n-//! # Example\n-//!\n-//! The following example shows simple command line parsing for an application\n-//! that requires an input file to be specified, accepts an optional output\n-//! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n-//!\n-//! ```{.rust}\n-//! #![feature(rustc_private)]\n-//!\n-//! extern crate getopts;\n-//! use getopts::{optopt,optflag,getopts,OptGroup,usage};\n-//! use std::env;\n-//!\n-//! fn do_work(inp: &str, out: Option<String>) {\n-//!     println!(\"{}\", inp);\n-//!     match out {\n-//!         Some(x) => println!(\"{}\", x),\n-//!         None => println!(\"No Output\"),\n-//!     }\n-//! }\n-//!\n-//! fn print_usage(program: &str, opts: &[OptGroup]) {\n-//!     let brief = format!(\"Usage: {} [options]\", program);\n-//!     print!(\"{}\", usage(&brief, opts));\n-//! }\n-//!\n-//! fn main() {\n-//!     let args: Vec<String> = env::args().collect();\n-//!\n-//!     let program = args[0].clone();\n-//!\n-//!     let opts = &[\n-//!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n-//!         optflag(\"h\", \"help\", \"print this help menu\")\n-//!     ];\n-//!     let matches = match getopts(&args[1..], opts) {\n-//!         Ok(m) => { m }\n-//!         Err(f) => { panic!(f.to_string()) }\n-//!     };\n-//!     if matches.opt_present(\"h\") {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     }\n-//!     let output = matches.opt_str(\"o\");\n-//!     let input = if !matches.free.is_empty() {\n-//!         matches.free[0].clone()\n-//!     } else {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     };\n-//!     do_work(&input, output);\n-//! }\n-//! ```\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-\n-#![deny(missing_docs)]\n-#![deny(warnings)]\n-\n-use self::Name::*;\n-use self::HasArg::*;\n-use self::Occur::*;\n-use self::Fail::*;\n-use self::Optval::*;\n-use self::SplitWithinState::*;\n-use self::Whitespace::*;\n-use self::LengthLimit::*;\n-\n-use std::fmt;\n-use std::iter::repeat;\n-use std::result;\n-\n-/// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Name {\n-    /// A string representing the long name of an option.\n-    /// For example: \"help\"\n-    Long(String),\n-    /// A char representing the short name of an option.\n-    /// For example: 'h'\n-    Short(char),\n-}\n-\n-/// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum HasArg {\n-    /// The option requires an argument.\n-    Yes,\n-    /// The option takes no argument.\n-    No,\n-    /// The option argument is optional.\n-    Maybe,\n-}\n-\n-/// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum Occur {\n-    /// The option occurs once.\n-    Req,\n-    /// The option occurs at most once.\n-    Optional,\n-    /// The option occurs zero or more times.\n-    Multi,\n-}\n-\n-/// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Opt {\n-    /// Name of the option\n-    pub name: Name,\n-    /// Whether it has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-    /// Which options it aliases\n-    pub aliases: Vec<Opt>,\n-}\n-\n-/// One group of options, e.g., both `-h` and `--help`, along with\n-/// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct OptGroup {\n-    /// Short name of the option, e.g. `h` for a `-h` option\n-    pub short_name: String,\n-    /// Long name of the option, e.g. `help` for a `--help` option\n-    pub long_name: String,\n-    /// Hint for argument, e.g. `FILE` for a `-o FILE` option\n-    pub hint: String,\n-    /// Description for usage help text\n-    pub desc: String,\n-    /// Whether option has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-}\n-\n-/// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum Optval {\n-    Val(String),\n-    Given,\n-}\n-\n-/// The result of checking command line arguments. Contains a vector\n-/// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Matches {\n-    /// Options that matched\n-    opts: Vec<Opt>,\n-    /// Values of the Options that matched\n-    vals: Vec<Vec<Optval>>,\n-    /// Free string fragments\n-    pub free: Vec<String>,\n-}\n-\n-/// The type returned when the command line does not conform to the\n-/// expected format. Use the `Debug` implementation to output detailed\n-/// information.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Fail {\n-    /// The option requires an argument but none was passed.\n-    ArgumentMissing(String),\n-    /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(String),\n-    /// A required option is not present.\n-    OptionMissing(String),\n-    /// A single occurrence option is being used multiple times.\n-    OptionDuplicated(String),\n-    /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(String),\n-}\n-\n-/// The type of failure that occurred.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[allow(missing_docs)]\n-pub enum FailType {\n-    ArgumentMissing_,\n-    UnrecognizedOption_,\n-    OptionMissing_,\n-    OptionDuplicated_,\n-    UnexpectedArgument_,\n-}\n-\n-/// The result of parsing a command line with a set of options.\n-pub type Result = result::Result<Matches, Fail>;\n-\n-impl Name {\n-    fn from_str(nm: &str) -> Name {\n-        if nm.len() == 1 {\n-            Short(nm.chars().next().unwrap())\n-        } else {\n-            Long(nm.to_owned())\n-        }\n-    }\n-\n-    fn to_string(&self) -> String {\n-        match *self {\n-            Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_owned(),\n-        }\n-    }\n-}\n-\n-impl OptGroup {\n-    /// Translate OptGroup into Opt.\n-    /// (Both short and long names correspond to different Opts).\n-    pub fn long_to_short(&self) -> Opt {\n-        let OptGroup {\n-            short_name,\n-            long_name,\n-            hasarg,\n-            occur,\n-            ..\n-        } = (*self).clone();\n-\n-        match (short_name.len(), long_name.len()) {\n-            (0, 0) => panic!(\"this long-format option was given no name\"),\n-            (0, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, 0) => {\n-                Opt {\n-                    name: Short(short_name.chars().next().unwrap()),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: vec![Opt {\n-                                      name: Short(short_name.chars().next().unwrap()),\n-                                      hasarg,\n-                                      occur,\n-                                      aliases: Vec::new(),\n-                                  }],\n-                }\n-            }\n-            _ => panic!(\"something is wrong with the long-form opt\"),\n-        }\n-    }\n-}\n-\n-impl Matches {\n-    fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(&self.opts[..], Name::from_str(nm)) {\n-            Some(id) => self.vals[id].clone(),\n-            None => panic!(\"No option '{}' defined\", nm),\n-        }\n-    }\n-\n-    fn opt_val(&self, nm: &str) -> Option<Optval> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            Some(vals[0].clone())\n-        }\n-    }\n-\n-    /// Returns true if an option was matched.\n-    pub fn opt_present(&self, nm: &str) -> bool {\n-        !self.opt_vals(nm).is_empty()\n-    }\n-\n-    /// Returns the number of times an option was matched.\n-    pub fn opt_count(&self, nm: &str) -> usize {\n-        self.opt_vals(nm).len()\n-    }\n-\n-    /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[String]) -> bool {\n-        for nm in names {\n-            match find_opt(&self.opts, Name::from_str(&**nm)) {\n-                Some(id) if !self.vals[id].is_empty() => return true,\n-                _ => (),\n-            };\n-        }\n-        false\n-    }\n-\n-    /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[String]) -> Option<String> {\n-        for nm in names {\n-            if let Some(Val(ref s)) = self.opt_val(&nm[..]) {\n-                  return Some(s.clone())\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Returns a vector of the arguments provided to all matches of the given\n-    /// option.\n-    ///\n-    /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n-        let mut acc: Vec<String> = Vec::new();\n-        let r = self.opt_vals(nm);\n-        for v in &r {\n-            match *v {\n-                Val(ref s) => acc.push((*s).clone()),\n-                _ => (),\n-            }\n-        }\n-        acc\n-    }\n-\n-    /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            return None::<String>;\n-        }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n-            _ => None,\n-        }\n-    }\n-\n-\n-    /// Returns the matching string, a default, or none.\n-    ///\n-    /// Returns none if the option was not present, `def` if the option was\n-    /// present but no argument was provided, and the argument if the option was\n-    /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            match vals[0] {\n-                Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_owned()),\n-            }\n-        }\n-    }\n-}\n-\n-fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg.as_bytes()[0] == b'-'\n-}\n-\n-fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n-    // Search main options.\n-    let pos = opts.iter().position(|opt| opt.name == nm);\n-    if pos.is_some() {\n-        return pos;\n-    }\n-\n-    // Search in aliases.\n-    for candidate in opts {\n-        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n-            return opts.iter().position(|opt| opt.name == candidate.name);\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Create a long option that is required and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Req,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional and does not take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that can occur more than once and does not\n-/// take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an optional argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Maybe,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional, takes an argument, and may occur\n-/// multiple times.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a generic option group, stating all parameters explicitly\n-pub fn opt(short_name: &str,\n-           long_name: &str,\n-           desc: &str,\n-           hint: &str,\n-           hasarg: HasArg,\n-           occur: Occur)\n-           -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg,\n-        occur,\n-    }\n-}\n-\n-impl fmt::Display for Fail {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ArgumentMissing(ref nm) => write!(f, \"Argument to option '{}' missing.\", *nm),\n-            UnrecognizedOption(ref nm) => write!(f, \"Unrecognized option: '{}'.\", *nm),\n-            OptionMissing(ref nm) => write!(f, \"Required option '{}' missing.\", *nm),\n-            OptionDuplicated(ref nm) => write!(f, \"Option '{}' given more than once.\", *nm),\n-            UnexpectedArgument(ref nm) => write!(f, \"Option '{}' does not take an argument.\", *nm),\n-        }\n-    }\n-}\n-\n-/// Parse command line arguments according to the provided options.\n-///\n-/// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n-/// `opt_str`, etc. to interrogate results.\n-/// # Panics\n-///\n-/// Returns `Err(Fail)` on failure: use the `Debug` implementation of `Fail` to display\n-/// information about it.\n-pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n-    let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n-    let n_opts = opts.len();\n-\n-    fn f(_x: usize) -> Vec<Optval> {\n-        Vec::new()\n-    }\n-\n-    let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n-    let mut free: Vec<String> = Vec::new();\n-    let l = args.len();\n-    let mut i = 0;\n-    while i < l {\n-        let cur = args[i].clone();\n-        let curlen = cur.len();\n-        if !is_arg(&cur[..]) {\n-            free.push(cur);\n-        } else if cur == \"--\" {\n-            let mut j = i + 1;\n-            while j < l {\n-                free.push(args[j].clone());\n-                j += 1;\n-            }\n-            break;\n-        } else {\n-            let mut names;\n-            let mut i_arg = None;\n-            if cur.as_bytes()[1] == b'-' {\n-                let tail = &cur[2..curlen];\n-                let tail_eq: Vec<&str> = tail.splitn(2, '=').collect();\n-                if tail_eq.len() <= 1 {\n-                    names = vec![Long(tail.to_owned())];\n-                } else {\n-                    names = vec![Long(tail_eq[0].to_owned())];\n-                    i_arg = Some(tail_eq[1].to_owned());\n-                }\n-            } else {\n-                let mut j = 1;\n-                names = Vec::new();\n-                while j < curlen {\n-                    let ch = cur[j..].chars().next().unwrap();\n-                    let opt = Short(ch);\n-\n-                    // In a series of potential options (eg. -aheJ), if we\n-                    // see one which takes an argument, we assume all\n-                    // subsequent characters make up the argument. This\n-                    // allows options such as -L/usr/local/lib/foo to be\n-                    // interpreted correctly\n-\n-                    let opt_id = match find_opt(&opts, opt.clone()) {\n-                        Some(id) => id,\n-                        None => return Err(UnrecognizedOption(opt.to_string())),\n-                    };\n-\n-                    names.push(opt);\n-\n-                    let arg_follows = match opts[opt_id].hasarg {\n-                        Yes | Maybe => true,\n-                        No => false,\n-                    };\n-\n-                    let next = j + ch.len_utf8();\n-                    if arg_follows && next < curlen {\n-                        i_arg = Some((&cur[next..curlen]).to_owned());\n-                        break;\n-                    }\n-\n-                    j = next;\n-                }\n-            }\n-            let mut name_pos = 0;\n-            for nm in &names {\n-                name_pos += 1;\n-                let optid = match find_opt(&opts, (*nm).clone()) {\n-                    Some(id) => id,\n-                    None => return Err(UnrecognizedOption(nm.to_string())),\n-                };\n-                match opts[optid].hasarg {\n-                    No => {\n-                        if name_pos == names.len() && !i_arg.is_none() {\n-                            return Err(UnexpectedArgument(nm.to_string()));\n-                        }\n-                        let v = &mut vals[optid];\n-                        v.push(Given);\n-                    }\n-                    Maybe => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val((i_arg.clone()).unwrap()));\n-                        } else if name_pos < names.len() || i + 1 == l || is_arg(&args[i + 1][..]) {\n-                            let v = &mut vals[optid];\n-                            v.push(Given);\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                    Yes => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val(i_arg.clone().unwrap()));\n-                        } else if i + 1 == l {\n-                            return Err(ArgumentMissing(nm.to_string()));\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        i += 1;\n-    }\n-    for i in 0..n_opts {\n-        let n = vals[i].len();\n-        let occ = opts[i].occur;\n-        if occ == Req && n == 0 {\n-            return Err(OptionMissing(opts[i].name.to_string()));\n-        }\n-        if occ != Multi && n > 1 {\n-            return Err(OptionDuplicated(opts[i].name.to_string()));\n-        }\n-    }\n-    Ok(Matches {\n-        opts,\n-        vals,\n-        free,\n-    })\n-}\n-\n-/// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n-\n-    let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n-\n-    let rows = opts.iter().map(|optref| {\n-        let OptGroup{short_name,\n-                     long_name,\n-                     hint,\n-                     desc,\n-                     hasarg,\n-                     ..} = (*optref).clone();\n-\n-        let mut row = repeat(\" \").take(4).collect::<String>();\n-\n-        // short option\n-        match short_name.len() {\n-            0 => {}\n-            1 => {\n-                row.push('-');\n-                row.push_str(&short_name[..]);\n-                row.push(' ');\n-            }\n-            _ => panic!(\"the short name should only be 1 ascii char long\"),\n-        }\n-\n-        // long option\n-        match long_name.len() {\n-            0 => {}\n-            _ => {\n-                row.push_str(\"--\");\n-                row.push_str(&long_name[..]);\n-                row.push(' ');\n-            }\n-        }\n-\n-        // arg\n-        match hasarg {\n-            No => {}\n-            Yes => row.push_str(&hint[..]),\n-            Maybe => {\n-                row.push('[');\n-                row.push_str(&hint[..]);\n-                row.push(']');\n-            }\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // here we just need to indent the start of the description\n-        let rowlen = row.chars().count();\n-        if rowlen < 24 {\n-            for _ in 0..24 - rowlen {\n-                row.push(' ');\n-            }\n-        } else {\n-            row.push_str(&desc_sep[..]);\n-        }\n-\n-        // Normalize desc to contain words separated by one space character\n-        let mut desc_normalized_whitespace = String::new();\n-        for word in desc.split_whitespace() {\n-            desc_normalized_whitespace.push_str(word);\n-            desc_normalized_whitespace.push(' ');\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        let mut desc_rows = Vec::new();\n-        each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n-            desc_rows.push(substr.to_owned());\n-            true\n-        });\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // wrapped description\n-        row.push_str(&desc_rows.join(&desc_sep[..]));\n-\n-        row\n-    });\n-\n-    format!(\"{}\\n\\nOptions:\\n{}\\n\",\n-            brief,\n-            rows.collect::<Vec<String>>().join(\"\\n\"))\n-}\n-\n-fn format_option(opt: &OptGroup) -> String {\n-    let mut line = String::new();\n-\n-    if opt.occur != Req {\n-        line.push('[');\n-    }\n-\n-    // Use short_name is possible, but fallback to long_name.\n-    if !opt.short_name.is_empty() {\n-        line.push('-');\n-        line.push_str(&opt.short_name[..]);\n-    } else {\n-        line.push_str(\"--\");\n-        line.push_str(&opt.long_name[..]);\n-    }\n-\n-    if opt.hasarg != No {\n-        line.push(' ');\n-        if opt.hasarg == Maybe {\n-            line.push('[');\n-        }\n-        line.push_str(&opt.hint[..]);\n-        if opt.hasarg == Maybe {\n-            line.push(']');\n-        }\n-    }\n-\n-    if opt.occur != Req {\n-        line.push(']');\n-    }\n-    if opt.occur == Multi {\n-        line.push_str(\"..\");\n-    }\n-\n-    line\n-}\n-\n-/// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n-    let mut line = format!(\"Usage: {} \", program_name);\n-    line.push_str(&opts.iter()\n-                       .map(format_option)\n-                       .collect::<Vec<String>>()\n-                       .join(\" \")[..]);\n-    line\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SplitWithinState {\n-    A, // leading whitespace, initial state\n-    B, // words\n-    C, // internal and trailing whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum Whitespace {\n-    Ws, // current char is whitespace\n-    Cr, // current char is not whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum LengthLimit {\n-    UnderLim, // current char makes current substring still fit in limit\n-    OverLim, // current char makes current substring no longer fit in limit\n-}\n-\n-\n-/// Splits a string into substrings with possibly internal whitespace,\n-/// each of them at most `lim` bytes long. The substrings have leading and trailing\n-/// whitespace removed, and are only cut at whitespace boundaries.\n-///\n-/// Note: Function was moved here from `std::str` because this module is the only place that\n-/// uses it, and because it was too specific for a general string function.\n-///\n-/// # Panics\n-///\n-/// Panics during iteration if the string contains a non-whitespace\n-/// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool\n-    where F: FnMut(&str) -> bool\n-{\n-    // Just for fun, let's write this as a state machine:\n-\n-    let mut slice_start = 0;\n-    let mut last_start = 0;\n-    let mut last_end = 0;\n-    let mut state = A;\n-    let mut fake_i = ss.len();\n-    let mut lim = lim;\n-\n-    let mut cont = true;\n-\n-    // if the limit is larger than the string, lower it to save cycles\n-    if lim >= fake_i {\n-        lim = fake_i;\n-    }\n-\n-    let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n-        let whitespace = if c.is_whitespace() {\n-            Ws\n-        } else {\n-            Cr\n-        };\n-        let limit = if (i - slice_start + 1) <= lim {\n-            UnderLim\n-        } else {\n-            OverLim\n-        };\n-\n-        state = match (state, whitespace, limit) {\n-            (A, Ws, _) => A,\n-            (A, Cr, _) => {\n-                slice_start = i;\n-                last_start = i;\n-                B\n-            }\n-\n-            (B, Cr, UnderLim) => B,\n-            (B, Cr, OverLim) if (i - last_start + 1) > lim => {\n-                panic!(\"word starting with {} longer than limit!\",\n-                       &ss[last_start..i + 1])\n-            }\n-            (B, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = last_start;\n-                B\n-            }\n-            (B, Ws, UnderLim) => {\n-                last_end = i;\n-                C\n-            }\n-            (B, Ws, OverLim) => {\n-                last_end = i;\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-\n-            (C, Cr, UnderLim) => {\n-                last_start = i;\n-                B\n-            }\n-            (C, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = i;\n-                last_start = i;\n-                last_end = i;\n-                B\n-            }\n-            (C, Ws, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-            (C, Ws, UnderLim) => C,\n-        };\n-\n-        *cont\n-    };\n-\n-    ss.char_indices().all(|x| machine(&mut cont, x));\n-\n-    // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont &&\n-          match state {\n-        B | C => true,\n-        A => false,\n-    } {\n-        machine(&mut cont, (fake_i, ' '));\n-        fake_i += 1;\n-    }\n-    cont\n-}\n-\n-#[test]\n-fn test_split_within() {\n-    fn t(s: &str, i: usize, u: &[String]) {\n-        let mut v = Vec::new();\n-        each_split_within(s, i, |s| {\n-            v.push(s.to_string());\n-            true\n-        });\n-        assert!(v.iter().zip(u).all(|(a, b)| a == b));\n-    }\n-    t(\"\", 0, &[]);\n-    t(\"\", 15, &[]);\n-    t(\"hello\", 15, &[\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      15,\n-      &[\"Mary had a\".to_string(), \"little lamb\".to_string(), \"Little lamb\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      ::std::usize::MAX,\n-      &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use std::result::Result::{Err, Ok};\n-    use std::result;\n-\n-    // Tests for reqopt\n-    #[test]\n-    fn test_reqopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (long arg)\");\n-            }\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (short arg)\");\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optopt\n-    #[test]\n-    fn test_optopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflag\n-    #[test]\n-    fn test_optflag() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_long_arg() {\n-        let args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(UnexpectedArgument(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_multi() {\n-        let args = vec![\"--test\".to_string(), \"-t\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_short_arg() {\n-        let args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                // The next variable after the flag is just a free argument\n-\n-                assert!(m.free[0] == \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflagmulti\n-    #[test]\n-    fn test_optflagmulti_short1() {\n-        let args = vec![\"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2a() {\n-        let args = vec![\"-v\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2b() {\n-        let args = vec![\"-vv\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long1() {\n-        let args = vec![\"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long2() {\n-        let args = vec![\"--verbose\".to_string(), \"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_mix() {\n-        let args = vec![\"--verbose\".to_string(),\n-                        \"-v\".to_string(),\n-                        \"-vv\".to_string(),\n-                        \"verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 4);\n-                assert_eq!(m.opt_count(\"v\"), 4);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optmulti\n-    #[test]\n-    fn test_optmulti() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-                let pair = m.opt_strs(\"test\");\n-                assert!(pair[0] == \"20\");\n-                assert!(pair[1] == \"30\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unrecognized_option() {\n-        let long_args = vec![\"--untest\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-u\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_combined() {\n-        let args = vec![\"prog\".to_string(),\n-                        \"free1\".to_string(),\n-                        \"-s\".to_string(),\n-                        \"20\".to_string(),\n-                        \"free2\".to_string(),\n-                        \"--flag\".to_string(),\n-                        \"--long=30\".to_string(),\n-                        \"-f\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"40\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"50\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-A B\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-60 70\".to_string()];\n-        let opts = vec![optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n-                        optflag(\"\", \"flag\", \"a flag\"),\n-                        reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n-                        optflag(\"f\", \"\", \"another flag\"),\n-                        optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n-                        optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-                        optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.free[0] == \"prog\");\n-                assert!(m.free[1] == \"free1\");\n-                assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n-                assert!(m.free[2] == \"free2\");\n-                assert!((m.opt_present(\"flag\")));\n-                assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n-                assert!((m.opt_present(\"f\")));\n-                let pair = m.opt_strs(\"m\");\n-                assert!(pair[0] == \"40\");\n-                assert!(pair[1] == \"50\");\n-                let pair = m.opt_strs(\"n\");\n-                assert!(pair[0] == \"-A B\");\n-                assert!(pair[1] == \"-60 70\");\n-                assert!((!m.opt_present(\"notpresent\")));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_multi() {\n-        let opts = vec![optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n-\n-        let args_single = vec![\"-e\".to_string(), \"foo\".to_string()];\n-        let matches_single = &match getopts(&args_single, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_single.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present(&[]));\n-\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-\n-        let args_both = vec![\"-e\".to_string(),\n-                             \"foo\".to_string(),\n-                             \"--encrypt\".to_string(),\n-                             \"foo\".to_string()];\n-        let matches_both = &match getopts(&args_both, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_both.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present(&[]));\n-\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_nospace() {\n-        let args = vec![\"-Lfoo\".to_string(), \"-M.\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n-        assert!(matches.opts_present(&[\"M\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\");\n-\n-    }\n-\n-    #[test]\n-    fn test_nospace_conflict() {\n-        let args = vec![\"-vvLverbose\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optflagmulti(\"v\", \"verbose\", \"Verbose\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n-        assert!(matches.opts_present(&[\"v\".to_string()]));\n-        assert_eq!(3, matches.opt_count(\"v\"));\n-    }\n-\n-    #[test]\n-    fn test_long_to_short() {\n-        let mut short = Opt {\n-            name: Name::Long(\"banana\".to_string()),\n-            hasarg: HasArg::Yes,\n-            occur: Occur::Req,\n-            aliases: Vec::new(),\n-        };\n-        short.aliases = vec![Opt {\n-                                 name: Name::Short('b'),\n-                                 hasarg: HasArg::Yes,\n-                                 occur: Occur::Req,\n-                                 aliases: Vec::new(),\n-                             }];\n-        let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n-\n-        assert!(verbose.long_to_short() == short);\n-    }\n-\n-    #[test]\n-    fn test_aliases_long_and_short() {\n-        let opts = vec![optflagmulti(\"a\", \"apple\", \"Desc\")];\n-\n-        let args = vec![\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string()];\n-\n-        let matches = getopts(&args, &opts).unwrap();\n-        assert_eq!(3, matches.opt_count(\"a\"));\n-        assert_eq!(3, matches.opt_count(\"apple\"));\n-    }\n-\n-    #[test]\n-    fn test_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -b --banana VAL     Desc\n-    -a --012345678901234567890123456789 VAL\n-                        Desc\n-    -k --kiwi           Desc\n-    -p [VAL]            Desc\n-    -l VAL              Desc\n-\";\n-\n-        let generated_usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_usage_description_wrapping() {\n-        // indentation should be 24 spaces\n-        // lines wrap after 78: or rather descriptions wrap after 54\n-\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"kiwi\",\n-                                     // 54\n-                                     \"This is a long description which won't be wrapped..+..\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This is a long description which _will_ be wrapped..+..\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --kiwi           This is a long description which won't be wrapped..+..\n-    -a --apple          This is a long description which _will_ be\n-                        wrapped..+..\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_usage_description_multibyte_handling() {\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"k\\u{2013}w\\u{2013}\",\n-                                     \"The word kiwi is normally spelled with two i's\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This \\u{201C}description\\u{201D} has some characters that \\\n-                                      could confuse the line wrapping; an apple costs 0.51\u20ac in \\\n-                                      some parts of Europe.\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --k\u2013w\u2013           The word kiwi is normally spelled with two i's\n-    -a --apple          This \u201cdescription\u201d has some characters that could\n-                        confuse the line wrapping; an apple costs 0.51\u20ac in\n-                        some parts of Europe.\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_short_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n-        let generated_usage = short_usage(\"fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_args_with_equals() {\n-        let args = vec![\"--one\".to_string(), \"A=B\".to_string(),\n-                        \"--two=C=D\".to_string()];\n-        let opts = vec![optopt(\"o\", \"one\", \"One\", \"INFO\"),\n-                        optopt(\"t\", \"two\", \"Two\", \"INFO\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e)\n-        };\n-        assert_eq!(matches.opts_str(&[\"o\".to_string()]).unwrap(), \"A=B\");\n-        assert_eq!(matches.opts_str(&[\"t\".to_string()]).unwrap(), \"C=D\");\n-    }\n-}"}, {"sha": "d8c366d2413d9cf15975eb67bf64feb49b5de58f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -711,6 +711,12 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n+impl<'a> IntoCow<'a, str> for Cow<'a, str> {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        self\n+    }\n+}\n+\n impl<'a, T: Clone> IntoCow<'a, [T]> for Vec<T> {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)"}, {"sha": "a7e78a78e17c8776d7780008ccb3ce541ec64ae9", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1 +1 @@\n-Subproject commit 56444a4545bd71430d64b86b8a71714cfdbe9f5d\n+Subproject commit a7e78a78e17c8776d7780008ccb3ce541ec64ae9"}, {"sha": "007093981d3e19a6ee1ce62557b53627fc50c432", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 90, "deletions": 56, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -34,13 +34,12 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n-#![feature(i128_type)]\n+#![cfg_attr(stage0, feature(i128_type))]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(lang_items)]\n #![feature(optin_builtin_traits)]\n \n-#[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors;\n@@ -156,7 +155,7 @@ impl IntoIterator for TokenStream {\n     type IntoIter = TokenTreeIter;\n \n     fn into_iter(self) -> TokenTreeIter {\n-        TokenTreeIter { cursor: self.0.trees(), next: None }\n+        TokenTreeIter { cursor: self.0.trees(), stack: Vec::new() }\n     }\n }\n \n@@ -554,7 +553,7 @@ impl Literal {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct TokenTreeIter {\n     cursor: tokenstream::Cursor,\n-    next: Option<tokenstream::TokenStream>,\n+    stack: Vec<TokenTree>,\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -563,9 +562,10 @@ impl Iterator for TokenTreeIter {\n \n     fn next(&mut self) -> Option<TokenTree> {\n         loop {\n-            let next =\n-                unwrap_or!(self.next.take().or_else(|| self.cursor.next_as_stream()), return None);\n-            let tree = TokenTree::from_internal(next, &mut self.next);\n+            let tree = self.stack.pop().or_else(|| {\n+                let next = self.cursor.next_as_stream()?;\n+                Some(TokenTree::from_internal(next, &mut self.stack))\n+            })?;\n             if tree.span.0 == DUMMY_SP {\n                 if let TokenNode::Group(Delimiter::None, stream) = tree.kind {\n                     self.cursor.insert(stream.0);\n@@ -598,12 +598,12 @@ impl Delimiter {\n }\n \n impl TokenTree {\n-    fn from_internal(stream: tokenstream::TokenStream, next: &mut Option<tokenstream::TokenStream>)\n+    fn from_internal(stream: tokenstream::TokenStream, stack: &mut Vec<TokenTree>)\n                 -> TokenTree {\n         use syntax::parse::token::*;\n \n         let (tree, is_joint) = stream.as_tree();\n-        let (mut span, token) = match tree {\n+        let (span, token) = match tree {\n             tokenstream::TokenTree::Token(span, token) => (span, token),\n             tokenstream::TokenTree::Delimited(span, delimed) => {\n                 let delimiter = Delimiter::from_internal(delimed.delim);\n@@ -615,34 +615,32 @@ impl TokenTree {\n         };\n \n         let op_kind = if is_joint { Spacing::Joint } else { Spacing::Alone };\n-        macro_rules! op {\n-            ($op:expr) => { TokenNode::Op($op, op_kind) }\n-        }\n-\n-        macro_rules! joint {\n-            ($first:expr, $rest:expr) => { joint($first, $rest, is_joint, &mut span, next) }\n+        macro_rules! tt {\n+            ($e:expr) => (TokenTree { span: Span(span), kind: $e })\n         }\n-\n-        fn joint(first: char, rest: Token, is_joint: bool, span: &mut syntax_pos::Span,\n-                 next: &mut Option<tokenstream::TokenStream>)\n-                 -> TokenNode {\n-            let (first_span, rest_span) = (*span, *span);\n-            *span = first_span;\n-            let tree = tokenstream::TokenTree::Token(rest_span, rest);\n-            *next = Some(if is_joint { tree.joint() } else { tree.into() });\n-            TokenNode::Op(first, Spacing::Joint)\n+        macro_rules! op {\n+            ($a:expr) => (TokenNode::Op($a, op_kind));\n+            ($a:expr, $b:expr) => ({\n+                stack.push(tt!(TokenNode::Op($b, op_kind).into()));\n+                TokenNode::Op($a, Spacing::Joint)\n+            });\n+            ($a:expr, $b:expr, $c:expr) => ({\n+                stack.push(tt!(TokenNode::Op($c, op_kind)));\n+                stack.push(tt!(TokenNode::Op($b, Spacing::Joint)));\n+                TokenNode::Op($a, Spacing::Joint)\n+            })\n         }\n \n         let kind = match token {\n             Eq => op!('='),\n             Lt => op!('<'),\n-            Le => joint!('<', Eq),\n-            EqEq => joint!('=', Eq),\n-            Ne => joint!('!', Eq),\n-            Ge => joint!('>', Eq),\n+            Le => op!('<', '='),\n+            EqEq => op!('=', '='),\n+            Ne => op!('!', '='),\n+            Ge => op!('>', '='),\n             Gt => op!('>'),\n-            AndAnd => joint!('&', BinOp(And)),\n-            OrOr => joint!('|', BinOp(Or)),\n+            AndAnd => op!('&', '&'),\n+            OrOr => op!('|', '|'),\n             Not => op!('!'),\n             Tilde => op!('~'),\n             BinOp(Plus) => op!('+'),\n@@ -653,37 +651,46 @@ impl TokenTree {\n             BinOp(Caret) => op!('^'),\n             BinOp(And) => op!('&'),\n             BinOp(Or) => op!('|'),\n-            BinOp(Shl) => joint!('<', Lt),\n-            BinOp(Shr) => joint!('>', Gt),\n-            BinOpEq(Plus) => joint!('+', Eq),\n-            BinOpEq(Minus) => joint!('-', Eq),\n-            BinOpEq(Star) => joint!('*', Eq),\n-            BinOpEq(Slash) => joint!('/', Eq),\n-            BinOpEq(Percent) => joint!('%', Eq),\n-            BinOpEq(Caret) => joint!('^', Eq),\n-            BinOpEq(And) => joint!('&', Eq),\n-            BinOpEq(Or) => joint!('|', Eq),\n-            BinOpEq(Shl) => joint!('<', Le),\n-            BinOpEq(Shr) => joint!('>', Ge),\n+            BinOp(Shl) => op!('<', '<'),\n+            BinOp(Shr) => op!('>', '>'),\n+            BinOpEq(Plus) => op!('+', '='),\n+            BinOpEq(Minus) => op!('-', '='),\n+            BinOpEq(Star) => op!('*', '='),\n+            BinOpEq(Slash) => op!('/', '='),\n+            BinOpEq(Percent) => op!('%', '='),\n+            BinOpEq(Caret) => op!('^', '='),\n+            BinOpEq(And) => op!('&', '='),\n+            BinOpEq(Or) => op!('|', '='),\n+            BinOpEq(Shl) => op!('<', '<', '='),\n+            BinOpEq(Shr) => op!('>', '>', '='),\n             At => op!('@'),\n             Dot => op!('.'),\n-            DotDot => joint!('.', Dot),\n-            DotDotDot => joint!('.', DotDot),\n-            DotDotEq => joint!('.', DotEq),\n+            DotDot => op!('.', '.'),\n+            DotDotDot => op!('.', '.', '.'),\n+            DotDotEq => op!('.', '.', '='),\n             Comma => op!(','),\n             Semi => op!(';'),\n             Colon => op!(':'),\n-            ModSep => joint!(':', Colon),\n-            RArrow => joint!('-', Gt),\n-            LArrow => joint!('<', BinOp(Minus)),\n-            FatArrow => joint!('=', Gt),\n+            ModSep => op!(':', ':'),\n+            RArrow => op!('-', '>'),\n+            LArrow => op!('<', '-'),\n+            FatArrow => op!('=', '>'),\n             Pound => op!('#'),\n             Dollar => op!('$'),\n             Question => op!('?'),\n-            Underscore => op!('_'),\n \n-            Ident(ident) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n-            Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n+            Ident(ident, false) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n+            Ident(ident, true) => TokenNode::Term(Term(Symbol::intern(&format!(\"r#{}\", ident)))),\n+            Literal(..) => TokenNode::Literal(self::Literal(token)),\n+            DocComment(c) => {\n+                let stream = vec![\n+                    tt!(TokenNode::Term(Term::intern(\"doc\"))),\n+                    tt!(op!('=')),\n+                    tt!(TokenNode::Literal(self::Literal(Literal(Lit::Str_(c), None)))),\n+                ].into_iter().collect();\n+                stack.push(tt!(TokenNode::Group(Delimiter::Bracket, stream)));\n+                op!('#')\n+            }\n \n             Interpolated(_) => {\n                 __internal::with_sess(|(sess, _)| {\n@@ -692,7 +699,7 @@ impl TokenTree {\n                 })\n             }\n \n-            DotEq => joint!('.', Eq),\n+            DotEq => op!('.', '='),\n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n         };\n@@ -714,11 +721,39 @@ impl TokenTree {\n             },\n             TokenNode::Term(symbol) => {\n                 let ident = ast::Ident { name: symbol.0, ctxt: self.span.0.ctxt() };\n+                let sym_str = symbol.0.as_str();\n                 let token =\n-                    if symbol.0.as_str().starts_with(\"'\") { Lifetime(ident) } else { Ident(ident) };\n+                    if sym_str.starts_with(\"'\") { Lifetime(ident) }\n+                    else if sym_str.starts_with(\"r#\") {\n+                        let name = Symbol::intern(&sym_str[2..]);\n+                        let ident = ast::Ident { name, ctxt: self.span.0.ctxt() };\n+                        Ident(ident, true)\n+                    } else { Ident(ident, false) };\n                 return TokenTree::Token(self.span.0, token).into();\n             }\n-            TokenNode::Literal(token) => return TokenTree::Token(self.span.0, token.0).into(),\n+            TokenNode::Literal(self::Literal(Literal(Lit::Integer(ref a), b)))\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let integer = Symbol::intern(&a.as_str()[1..]);\n+                let integer = Literal(Lit::Integer(integer), b);\n+                let a = TokenTree::Token(self.span.0, minus);\n+                let b = TokenTree::Token(self.span.0, integer);\n+                return vec![a, b].into_iter().collect()\n+            }\n+            TokenNode::Literal(self::Literal(Literal(Lit::Float(ref a), b)))\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let float = Symbol::intern(&a.as_str()[1..]);\n+                let float = Literal(Lit::Float(float), b);\n+                let a = TokenTree::Token(self.span.0, minus);\n+                let b = TokenTree::Token(self.span.0, float);\n+                return vec![a, b].into_iter().collect()\n+            }\n+            TokenNode::Literal(token) => {\n+                return TokenTree::Token(self.span.0, token.0).into()\n+            }\n         };\n \n         let token = match op {\n@@ -743,7 +778,6 @@ impl TokenTree {\n             '#' => Pound,\n             '$' => Dollar,\n             '?' => Question,\n-            '_' => Underscore,\n             _ => panic!(\"unsupported character {}\", op),\n         };\n "}, {"sha": "8d6c7d68dfe23090441114164c8ebe0b661f0163", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -27,6 +27,7 @@ fn main() {\n                                    \"InstrProfilingFile.c\",\n                                    \"InstrProfilingMerge.c\",\n                                    \"InstrProfilingMergeFile.c\",\n+                                   \"InstrProfilingNameVar.c\",\n                                    \"InstrProfilingPlatformDarwin.c\",\n                                    \"InstrProfilingPlatformLinux.c\",\n                                    \"InstrProfilingPlatformOther.c\",\n@@ -42,6 +43,8 @@ fn main() {\n         cfg.define(\"strdup\", Some(\"_strdup\"));\n         cfg.define(\"open\", Some(\"_open\"));\n         cfg.define(\"fdopen\", Some(\"_fdopen\"));\n+        cfg.define(\"getpid\", Some(\"_getpid\"));\n+        cfg.define(\"fileno\", Some(\"_fileno\"));\n     } else {\n         // Turn off various features of gcc and such, mostly copying\n         // compiler-rt's build system already\n@@ -50,6 +53,7 @@ fn main() {\n         cfg.flag(\"-fomit-frame-pointer\");\n         cfg.flag(\"-ffreestanding\");\n         cfg.define(\"VISIBILITY_HIDDEN\", None);\n+        cfg.define(\"COMPILER_RT_HAS_UNAME\", Some(\"1\"));\n     }\n \n     for src in profile_sources {"}, {"sha": "2aae0f24d484932b27a9df391d174886cb3f9c33", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -56,3 +56,4 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n #        later crate stop compiling. If you can remove this and everything\n #        compiles, then please feel free to do so!\n flate2 = \"1.0\"\n+tempdir = \"0.3\""}, {"sha": "278e0f9a26e433d032a5d2c3a4c0ee8142f3c4a9", "filename": "src/librustc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -10,7 +10,6 @@\n \n #![deny(warnings)]\n \n-#![feature(slice_patterns)]\n #![feature(test)]\n \n extern crate test;"}, {"sha": "1247db55f58506b0519a456a2137b88e3ce0ee0e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -473,8 +473,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         // Keep track of the previous guard expressions\n         let mut prev_guards = Vec::new();\n-        // Track if the previous pattern contained bindings or wildcards\n-        let mut prev_has_bindings = false;\n \n         for arm in arms {\n             // Add an exit node for when we've visited all the\n@@ -493,40 +491,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat.contains_bindings_or_wild();\n-\n-                    // If both this pattern and the previous pattern\n-                    // were free of bindings, they must consist only\n-                    // of \"constant\" patterns. Note we cannot match an\n-                    // all-constant pattern, fail the guard, and then\n-                    // match *another* all-constant pattern. This is\n-                    // because if the previous pattern matches, then\n-                    // we *cannot* match this one, unless all the\n-                    // constants are the same (which is rejected by\n-                    // `check_match`).\n-                    //\n-                    // We can use this to be smarter about the flow\n-                    // along guards. If the previous pattern matched,\n-                    // then we know we will not visit the guard in\n-                    // this one (whether or not the guard succeeded),\n-                    // if the previous pattern failed, then we know\n-                    // the guard for that pattern will not have been\n-                    // visited. Thus, it is not possible to visit both\n-                    // the previous guard and the current one when\n-                    // both patterns consist only of constant\n-                    // sub-patterns.\n-                    //\n-                    // However, if the above does not hold, then all\n-                    // previous guards need to be wired to visit the\n-                    // current guard pattern.\n-                    if prev_has_bindings || this_has_bindings {\n-                        while let Some(prev) = prev_guards.pop() {\n-                            self.add_contained_edge(prev, guard_start);\n-                        }\n+                    // #47295: We used to have very special case code\n+                    // here for when a pair of arms are both formed\n+                    // solely from constants, and if so, not add these\n+                    // edges.  But this was not actually sound without\n+                    // other constraints that we stopped enforcing at\n+                    // some point.\n+                    while let Some(prev) = prev_guards.pop() {\n+                        self.add_contained_edge(prev, guard_start);\n                     }\n \n-                    prev_has_bindings = this_has_bindings;\n-\n                     // Push the guard onto the list of previous guards\n                     prev_guards.push(guard_exit);\n "}, {"sha": "f1f383d7ad1262f5c5ae2cf30852d812286314fe", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 3, "deletions": 294, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -1,295 +1,4 @@\n-# Dependency graph for incremental compilation\n+To learn more about how dependency tracking works in rustc, see the [rustc\n+guide].\n \n-This module contains the infrastructure for managing the incremental\n-compilation dependency graph. This README aims to explain how it ought\n-to be used. In this document, we'll first explain the overall\n-strategy, and then share some tips for handling specific scenarios.\n-\n-The high-level idea is that we want to instrument the compiler to\n-track which parts of the AST and other IR are read/written by what.\n-This way, when we come back later, we can look at this graph and\n-determine what work needs to be redone.\n-\n-### The dependency graph\n-\n-The nodes of the graph are defined by the enum `DepNode`. They represent\n-one of three things:\n-\n-1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n-2. Data nodes (like `TypeOfItem(DefId)`) represent some computed\n-   information about a particular item.\n-3. Procedure nodes (like `CoherenceCheckTrait(DefId)`) represent some\n-   procedure that is executing. Usually this procedure is\n-   performing some kind of check for errors. You can think of them as\n-   computed values where the value being computed is `()` (and the\n-   value may fail to be computed, if an error results).\n-\n-An edge `N1 -> N2` is added between two nodes if either:\n-\n-- the value of `N1` is used to compute `N2`;\n-- `N1` is read by the procedure `N2`;\n-- the procedure `N1` writes the value `N2`.\n-\n-The latter two conditions are equivalent to the first one if you think\n-of procedures as values.\n-\n-### Basic tracking\n-\n-There is a very general strategy to ensure that you have a correct, if\n-sometimes overconservative, dependency graph. The two main things you have\n-to do are (a) identify shared state and (b) identify the current tasks.\n-\n-### Identifying shared state\n-\n-Identify \"shared state\" that will be written by one pass and read by\n-another. In particular, we need to identify shared state that will be\n-read \"across items\" -- that is, anything where changes in one item\n-could invalidate work done for other items. So, for example:\n-\n-1. The signature for a function is \"shared state\".\n-2. The computed type of some expression in the body of a function is\n-   not shared state, because if it changes it does not itself\n-   invalidate other functions (though it may be that it causes new\n-   monomorphizations to occur, but that's handled independently).\n-\n-Put another way: if the HIR for an item changes, we are going to\n-recompile that item for sure. But we need the dep tracking map to tell\n-us what *else* we have to recompile. Shared state is anything that is\n-used to communicate results from one item to another.\n-\n-### Identifying the current task, tracking reads/writes, etc\n-\n-FIXME(#42293). This text needs to be rewritten for the new red-green\n-system, which doesn't fully exist yet.\n-\n-#### Dependency tracking map\n-\n-`DepTrackingMap` is a particularly convenient way to correctly store\n-shared state. A `DepTrackingMap` is a special hashmap that will add\n-edges automatically when `get` and `insert` are called. The idea is\n-that, when you get/insert a value for the key `K`, we will add an edge\n-from/to the node `DepNode::Variant(K)` (for some variant specific to\n-the map).\n-\n-Each `DepTrackingMap` is parameterized by a special type `M` that\n-implements `DepTrackingMapConfig`; this trait defines the key and value\n-types of the map, and also defines a fn for converting from the key to\n-a `DepNode` label. You don't usually have to muck about with this by\n-hand, there is a macro for creating it. You can see the complete set\n-of `DepTrackingMap` definitions in `librustc/middle/ty/maps.rs`.\n-\n-As an example, let's look at the `adt_defs` map. The `adt_defs` map\n-maps from the def-id of a struct/enum to its `AdtDef`. It is defined\n-using this macro:\n-\n-```rust\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n-//            ~~~~~~~  ~~~~~~~~~~~~~ ~~~~~     ~~~~~~~~~~~~~~~~~~~~~~\n-//               |           |      Key type       Value type\n-//               |    DepNode variant\n-//      Name of map id type\n-```\n-\n-this indicates that a map id type `AdtDefs` will be created. The key\n-of the map will be a `DefId` and value will be\n-`ty::AdtDefMaster<'tcx>`. The `DepNode` will be created by\n-`DepNode::ItemSignature(K)` for a given key.\n-\n-Once that is done, you can just use the `DepTrackingMap` like any\n-other map:\n-\n-```rust\n-let mut map: DepTrackingMap<M> = DepTrackingMap::new(dep_graph);\n-map.insert(key, value); // registers dep_graph.write\n-map.get(key; // registers dep_graph.read\n-```\n-\n-#### Memoization\n-\n-One particularly interesting case is memoization. If you have some\n-shared state that you compute in a memoized fashion, the correct thing\n-to do is to define a `RefCell<DepTrackingMap>` for it and use the\n-`memoize` helper:\n-\n-```rust\n-map.memoize(key, || /* compute value */)\n-```\n-\n-This will create a graph that looks like\n-\n-    ... -> MapVariant(key) -> CurrentTask\n-\n-where `MapVariant` is the `DepNode` variant that the map is associated with,\n-and `...` are whatever edges the `/* compute value */` closure creates.\n-\n-In particular, using the memoize helper is much better than writing\n-the obvious code yourself:\n-\n-```rust\n-if let Some(result) = map.get(key) {\n-    return result;\n-}\n-let value = /* compute value */;\n-map.insert(key, value);\n-```\n-\n-If you write that code manually, the dependency graph you get will\n-include artificial edges that are not necessary. For example, imagine that\n-two tasks, A and B, both invoke the manual memoization code, but A happens\n-to go first. The resulting graph will be:\n-\n-    ... -> A -> MapVariant(key) -> B\n-    ~~~~~~~~~~~~~~~~~~~~~~~~~~~       // caused by A writing to MapVariant(key)\n-                ~~~~~~~~~~~~~~~~~~~~  // caused by B reading from MapVariant(key)\n-\n-This graph is not *wrong*, but it encodes a path from A to B that\n-should not exist.  In contrast, using the memoized helper, you get:\n-\n-    ... -> MapVariant(key) -> A\n-                 |\n-                 +----------> B\n-\n-which is much cleaner.\n-\n-**Be aware though that the closure is executed with `MapVariant(key)`\n-pushed onto the stack as the current task!** That means that you must\n-add explicit `read` calls for any shared state that it accesses\n-implicitly from its environment. See the section on \"explicit calls to\n-read and write when starting a new subtask\" above for more details.\n-\n-### How to decide where to introduce a new task\n-\n-Certainly, you need at least one task on the stack: any attempt to\n-`read` or `write` shared state will panic if there is no current\n-task. But where does it make sense to introduce subtasks? The basic\n-rule is that a subtask makes sense for any discrete unit of work you\n-may want to skip in the future. Adding a subtask separates out the\n-reads/writes from *that particular subtask* versus the larger\n-context. An example: you might have a 'meta' task for all of borrow\n-checking, and then subtasks for borrow checking individual fns.  (Seen\n-in this light, memoized computations are just a special case where we\n-may want to avoid redoing the work even within the context of one\n-compilation.)\n-\n-The other case where you might want a subtask is to help with refining\n-the reads/writes for some later bit of work that needs to be memoized.\n-For example, we create a subtask for type-checking the body of each\n-fn.  However, in the initial version of incr. comp. at least, we do\n-not expect to actually *SKIP* type-checking -- we only expect to skip\n-trans. However, it's still useful to create subtasks for type-checking\n-individual items, because, otherwise, if a fn sig changes, we won't\n-know which callers are affected -- in fact, because the graph would be\n-so coarse, we'd just have to retrans everything, since we can't\n-distinguish which fns used which fn sigs.\n-\n-### Testing the dependency graph\n-\n-There are various ways to write tests against the dependency graph.\n-The simplest mechanism are the\n-`#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n-annotations. These are used in compile-fail tests to test whether the\n-expected set of paths exist in the dependency graph. As an example,\n-see `src/test/compile-fail/dep-graph-caller-callee.rs`.\n-\n-The idea is that you can annotate a test like:\n-\n-```rust\n-#[rustc_if_this_changed]\n-fn foo() { }\n-\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n-fn bar() { foo(); }\n-\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n-fn baz() { }\n-```\n-\n-This will check whether there is a path in the dependency graph from\n-`Hir(foo)` to `TypeckTables(bar)`. An error is reported for each\n-`#[rustc_then_this_would_need]` annotation that indicates whether a\n-path exists. `//~ ERROR` annotations can then be used to test if a\n-path is found (as demonstrated above).\n-\n-### Debugging the dependency graph\n-\n-#### Dumping the graph\n-\n-The compiler is also capable of dumping the dependency graph for your\n-debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n-graph will be dumped to `dep_graph.{txt,dot}` in the current\n-directory.  You can override the filename with the `RUST_DEP_GRAPH`\n-environment variable.\n-\n-Frequently, though, the full dep graph is quite overwhelming and not\n-particularly helpful. Therefore, the compiler also allows you to filter\n-the graph. You can filter in three ways:\n-\n-1. All edges originating in a particular set of nodes (usually a single node).\n-2. All edges reaching a particular set of nodes.\n-3. All edges that lie between given start and end nodes.\n-\n-To filter, use the `RUST_DEP_GRAPH_FILTER` environment variable, which should\n-look like one of the following:\n-\n-```\n-source_filter     // nodes originating from source_filter\n--> target_filter  // nodes that can reach target_filter\n-source_filter -> target_filter // nodes in between source_filter and target_filter\n-```\n-\n-`source_filter` and `target_filter` are a `&`-separated list of strings.\n-A node is considered to match a filter if all of those strings appear in its\n-label. So, for example:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='-> TypeckTables'\n-```\n-\n-would select the predecessors of all `TypeckTables` nodes. Usually though you\n-want the `TypeckTables` node for some particular fn, so you might write:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='-> TypeckTables & bar'\n-```\n-\n-This will select only the `TypeckTables` nodes for fns with `bar` in their name.\n-\n-Perhaps you are finding that when you change `foo` you need to re-type-check `bar`,\n-but you don't think you should have to. In that case, you might do:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckTables & bar'\n-```\n-\n-This will dump out all the nodes that lead from `Hir(foo)` to\n-`TypeckTables(bar)`, from which you can (hopefully) see the source\n-of the erroneous edge.\n-\n-#### Tracking down incorrect edges\n-\n-Sometimes, after you dump the dependency graph, you will find some\n-path that should not exist, but you will not be quite sure how it came\n-to be. **When the compiler is built with debug assertions,** it can\n-help you track that down. Simply set the `RUST_FORBID_DEP_GRAPH_EDGE`\n-environment variable to a filter. Every edge created in the dep-graph\n-will be tested against that filter -- if it matches, a `bug!` is\n-reported, so you can easily see the backtrace (`RUST_BACKTRACE=1`).\n-\n-The syntax for these filters is the same as described in the previous\n-section. However, note that this filter is applied to every **edge**\n-and doesn't handle longer paths in the graph, unlike the previous\n-section.\n-\n-Example:\n-\n-You find that there is a path from the `Hir` of `foo` to the type\n-check of `bar` and you don't think there should be. You dump the\n-dep-graph as described in the previous section and open `dep-graph.txt`\n-to see something like:\n-\n-    Hir(foo) -> Collect(bar)\n-    Collect(bar) -> TypeckTables(bar)\n-\n-That first edge looks suspicious to you. So you set\n-`RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n-then observe the backtrace. Voila, bug fixed!\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/query.html"}, {"sha": "d1f3736556c5dc28eaff476814ae693bc0dc412e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -67,11 +67,12 @@ use hir::{HirId, ItemLocalId};\n \n use ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n-use ty::subst::Substs;\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n+use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e. which sub-expression of the macro we are in) but don't need\n@@ -80,6 +81,10 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n+macro_rules! replace {\n+    ($x:tt with $($y:tt)*) => ($($y)*)\n+}\n+\n macro_rules! is_anon_attr {\n     (anon) => (true);\n     ($attr:ident) => (false);\n@@ -111,7 +116,7 @@ macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n         [$($attr:ident),* ]\n-        $variant:ident $(( $($tuple_arg:tt),* ))*\n+        $variant:ident $(( $tuple_arg_ty:ty $(,)* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n     ) => (\n@@ -134,7 +139,7 @@ macro_rules! define_dep_nodes {\n \n                             // tuple args\n                             $({\n-                                return <( $($tuple_arg,)* ) as DepNodeParams>\n+                                return <$tuple_arg_ty as DepNodeParams>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n@@ -186,7 +191,7 @@ macro_rules! define_dep_nodes {\n                         DepKind :: $variant => {\n                             // tuple args\n                             $({\n-                                $(erase!($tuple_arg);)*\n+                                erase!($tuple_arg_ty);\n                                 return true;\n                             })*\n \n@@ -205,7 +210,7 @@ macro_rules! define_dep_nodes {\n \n         pub enum DepConstructor<$tcx> {\n             $(\n-                $variant $(( $($tuple_arg),* ))*\n+                $variant $(( $tuple_arg_ty ))*\n                          $({ $($struct_arg_name : $struct_arg_ty),* })*\n             ),*\n         }\n@@ -227,15 +232,14 @@ macro_rules! define_dep_nodes {\n             {\n                 match dep {\n                     $(\n-                        DepConstructor :: $variant $(( $($tuple_arg),* ))*\n+                        DepConstructor :: $variant $(( replace!(($tuple_arg_ty) with arg) ))*\n                                                    $({ $($struct_arg_name),* })*\n                             =>\n                         {\n                             // tuple args\n                             $({\n-                                let tupled_args = ( $($tuple_arg,)* );\n-                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n-                                                                         tcx);\n+                                erase!($tuple_arg_ty);\n+                                let hash = DepNodeParams::to_fingerprint(&arg, tcx);\n                                 let dep_node = DepNode {\n                                     kind: DepKind::$variant,\n                                     hash\n@@ -247,7 +251,7 @@ macro_rules! define_dep_nodes {\n                                     tcx.sess.opts.debugging_opts.query_dep_graph)\n                                 {\n                                     tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        tupled_args.to_debug_str(tcx)\n+                                        arg.to_debug_str(tcx)\n                                     });\n                                 }\n \n@@ -575,17 +579,22 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n+    [] CheckItemWellFormed(DefId),\n+    [] CheckTraitItemWellFormed(DefId),\n+    [] CheckImplItemWellFormed(DefId),\n     [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n     [input] CrateDisambiguator(CrateNum),\n     [input] CrateHash(CrateNum),\n     [input] OriginalCrateName(CrateNum),\n+    [input] ExtraFileName(CrateNum),\n \n     [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n     [] AllTraitImplementations(CrateNum),\n \n+    [] DllimportForeignItems(CrateNum),\n     [] IsDllimportForeignItem(DefId),\n     [] IsStaticallyIncludedForeignItem(DefId),\n     [] NativeLibraryKind(DefId),\n@@ -609,8 +618,6 @@ define_dep_nodes!( <'tcx>\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n-    [] HasCloneClosures(CrateNum),\n-    [] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a\n@@ -631,7 +638,9 @@ define_dep_nodes!( <'tcx>\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,\n-    [anon] NormalizeTy,\n+    [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n+    [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n+    [] DropckOutlives(CanonicalTyGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n@@ -641,7 +650,13 @@ define_dep_nodes!( <'tcx>\n \n     [] GetSymbolExportLevel(DefId),\n \n+    [] WasmCustomSections(CrateNum),\n+\n     [input] Features,\n+\n+    [] ProgramClausesFor(DefId),\n+    [] WasmImportModuleMap(CrateNum),\n+    [] ForeignModules(CrateNum),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n@@ -679,43 +694,43 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        tcx.def_path_hash(self.0).0\n+        tcx.def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(self.0)\n+        tcx.item_path_str(*self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        tcx.hir.definitions().def_path_hash(self.0).0\n+        tcx.hir.definitions().def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(DefId::local(self.0))\n+        tcx.item_path_str(DefId::local(*self))\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (CrateNum,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n         let def_id = DefId {\n-            krate: self.0,\n+            krate: *self,\n             index: CRATE_DEF_INDEX,\n         };\n         tcx.def_path_hash(def_id).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.crate_name(self.0).as_str().to_string()\n+        tcx.crate_name(*self).as_str().to_string()\n     }\n }\n \n@@ -743,17 +758,17 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (HirId,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        let (HirId {\n+        let HirId {\n             owner,\n             local_id: ItemLocalId(local_id),\n-        },) = *self;\n+        } = *self;\n \n         let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n         let local_id = Fingerprint::from_smaller_hash(local_id as u64);"}, {"sha": "d60c22064d3a0cd0ee3900a1dec51d175e28ea58", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use errors::DiagnosticBuilder;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHashingContextProvider};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n@@ -20,7 +19,7 @@ use std::hash::Hash;\n use ty::TyCtxt;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n-use ich::Fingerprint;\n+use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n@@ -189,47 +188,49 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/incremental-compilation.html\n-    pub fn with_task<C, A, R, HCX>(&self,\n+    pub fn with_task<'gcx, C, A, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    arg: A,\n                                    task: fn(C, A) -> R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, task,\n             |data, key| data.borrow_mut().push_task(key),\n             |data, key| data.borrow_mut().pop_task(key))\n     }\n \n-    fn with_task_impl<C, A, R, HCX>(&self,\n+    fn with_task_impl<'gcx, C, A, R>(&self,\n                                     key: DepNode,\n                                     cx: C,\n                                     arg: A,\n                                     task: fn(C, A) -> R,\n                                     push: fn(&RefCell<CurrentDepGraph>, DepNode),\n                                     pop: fn(&RefCell<CurrentDepGraph>, DepNode) -> DepNodeIndex)\n                                     -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         if let Some(ref data) = self.data {\n             push(&data.current, key);\n-            if cfg!(debug_assertions) {\n-                profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n-            };\n \n             // In incremental mode, hash the result of the task. We don't\n             // do anything with the hash yet, but we are computing it\n             // anyway so that\n             //  - we make sure that the infrastructure works and\n             //  - we can get an idea of the runtime cost.\n-            let mut hcx = cx.create_stable_hashing_context();\n+            let mut hcx = cx.get_stable_hashing_context();\n+\n+            if cfg!(debug_assertions) {\n+                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskBegin(key.clone()))\n+            };\n \n             let result = task(cx, arg);\n+\n             if cfg!(debug_assertions) {\n-                profq_msg(ProfileQueriesMsg::TaskEnd)\n+                profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n             let dep_node_index = pop(&data.current, key);\n@@ -274,7 +275,7 @@ impl DepGraph {\n             (result, dep_node_index)\n         } else {\n             if key.kind.fingerprint_needed_for_crate_hash() {\n-                let mut hcx = cx.create_stable_hashing_context();\n+                let mut hcx = cx.get_stable_hashing_context();\n                 let result = task(cx, arg);\n                 let mut stable_hasher = StableHasher::new();\n                 result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -314,14 +315,14 @@ impl DepGraph {\n \n     /// Execute something within an \"eval-always\" task which is a task\n     // that runs whenever anything changes.\n-    pub fn with_eval_always_task<C, A, R, HCX>(&self,\n+    pub fn with_eval_always_task<'gcx, C, A, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    arg: A,\n                                    task: fn(C, A) -> R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n-              R: HashStable<HCX>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n+              R: HashStable<StableHashingContext<'gcx>>,\n     {\n         self.with_task_impl(key, cx, arg, task,\n             |data, key| data.borrow_mut().push_eval_always_task(key),\n@@ -475,10 +476,8 @@ impl DepGraph {\n             fingerprints.resize(current_dep_graph.nodes.len(), Fingerprint::ZERO);\n         }\n \n-        let nodes: IndexVec<_, (DepNode, Fingerprint)> =\n-            current_dep_graph.nodes.iter_enumerated().map(|(idx, &dep_node)| {\n-            (dep_node, fingerprints[idx])\n-        }).collect();\n+        let fingerprints = fingerprints.clone().convert_index_type();\n+        let nodes = current_dep_graph.nodes.clone().convert_index_type();\n \n         let total_edge_count: usize = current_dep_graph.edges.iter()\n                                                              .map(|v| v.len())\n@@ -502,6 +501,7 @@ impl DepGraph {\n \n         SerializedDepGraph {\n             nodes,\n+            fingerprints,\n             edge_list_indices,\n             edge_list_data,\n         }\n@@ -647,8 +647,15 @@ impl DepGraph {\n                                 return None\n                             }\n                             None => {\n-                                bug!(\"try_mark_green() - Forcing the DepNode \\\n-                                      should have set its color\")\n+                                if !tcx.sess.has_errors() {\n+                                    bug!(\"try_mark_green() - Forcing the DepNode \\\n+                                          should have set its color\")\n+                                } else {\n+                                    // If the query we just forced has resulted\n+                                    // in some kind of compilation error, we\n+                                    // don't expect that the corresponding\n+                                    // dep-node color has been updated.\n+                                }\n                             }\n                         }\n                     } else {"}, {"sha": "669a99019aa60176de63f093266766a75d8638a4", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2", "patch": "@@ -23,7 +23,7 @@ impl PreviousDepGraph {\n     pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n         let index: FxHashMap<_, _> = data.nodes\n             .iter_enumerated()\n-            .map(|(idx, &(dep_node, _))| (dep_node, idx))\n+            .map(|(idx, &dep_node)| (dep_node, idx))\n             .collect();\n         PreviousDepGraph { data, index }\n     }\n@@ -41,7 +41,7 @@ impl PreviousDepGraph {\n \n     #[inline]\n     pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n-        self.data.nodes[dep_node_index].0\n+        self.data.nodes[dep_node_index]\n     }\n \n     #[inline]\n@@ -58,14 +58,14 @@ impl PreviousDepGraph {\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index\n             .get(dep_node)\n-            .map(|&node_index| self.data.nodes[node_index].1)\n+            .map(|&node_index| self.data.fingerprints[node_index])\n     }\n \n     #[inline]\n     pub fn fingerprint_by_index(&self,\n                                 dep_node_index: SerializedDepNodeIndex)\n                                 -> Fingerprint {\n-        self.data.nodes[dep_node_index].1\n+        self.data.fingerprints[dep_node_index]\n     }\n \n     pub fn node_count(&self) -> usize {"}, {"sha": "60fc813a25d51eda38da1293b1a8943a89c35225", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "2662e70999196f458de10c16608a9f55b52e1558", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "956cd17f38f214cd91f47550641f74cdb667742a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 133, "deletions": 11, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "9f51eb8c35a82787f10c6143ca6ce0fcd9f87080", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "5f9f37094f579a5bc01c546dcce43f066ba73de8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1522, "deletions": 1164, "changes": 2686, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "f77275926eba37477648a5dd8a7bca8d94868173", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "e8bcbfbb77a1791cb03d6d65352566accc740c8a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "be8cceb61189633d6cb8337f18c817c336af6b54", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "1f00a3ab1f5ded464dc5fb701b7725ad9afa0a9e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "ff501f30c891a5cd46e93384e5cfcf3bea5804c4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "04b725957b627f41aef542b66288f58ea5c25fb4", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "0071850e1052b5a77292d68d50e34c1a64ca6e89", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "c3b3e10201f9920665028f7a8bb920035a09be43", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "c73f171806e42510e766cc4f347143b4effe9f8a", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "425459f448fad32b7fb6ac1ab26460f2a14c0cb9", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "340dd32a237c01fa29240d207cd700435e35ebc6", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 204, "deletions": 27, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "1b77a2e7c82b985d119b0fbdef3d9dd2e1c18d7e", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "eb5df697216a362bd15164efa26b39d8fcaa57b4", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 182, "deletions": 57, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "89dbc76c8a65c2b58306e8d3ea1d95f2de912d29", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "4357c9a5a776acd3cdec0084200f0e8337b3972f", "filename": "src/librustc/infer/canonical.rs", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "c2167751a27e7d099ec527fa2104357b27ddb6bf", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "96c2309882108769634a9f91b1c978a4b9e86b1b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "6074bfd083d46dc82a0f1d8e5080ea8a85d6230e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "961dd70a4685204b927909c1738f9f3463b73b6b", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "d44f2ec95492f9592456577a4158042ff2a74c90", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "28aba51ab372468b403f4ff62525bb9d176db1c4", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "0086aed3e7c975b94b41d8b2646139b55be56dca", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "00b2ac7449f7e9a9ac1e5378296d3c560b25eadb", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "032a5c59d2dcaac063b1e11b2687fab781ad75b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 37, "deletions": 227, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "4bc64acc7630690ddae18eda0394d5bfbe7bd3d0", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "e5461685bd470bd21a744008698bf75013d6f0ac", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "07b87e2012dde775df98f09d6c502d3ec8a8aed0", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "4113a2dd4178bfd8e92a162d6e8d2c6ab673c642", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "77b722c5695f86803465b0586d96ec7c2360c666", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "91df6cabf3a8b88c4ae0e5a6a5b947a494638aa7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "dcad8132c2b2478a0b3eac0d0475010b8d647e67", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "97cfcf0f60795a07080b82d196a545aee8e14db9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "3c833251f72a78c410b5ab735ced0fb569791bc9", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "1497be2d5ba0d35448feeed03c0ca4dcce1a95fd", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "7dc84b9ca29561bc2d754ea859d19f442edb36d4", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 320, "deletions": 1, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "19a7576b7ceac4ed1abd99d739a9c89751ebb46b", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "add9b621596b63219db2d406dab8020c0a4bb13a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "abd52624c30d4c6b96e7d4083c764ccdd7b28bcd", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "37d79f408f3f00a7ab1487869e690ce6a07672e1", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "966353b53a95aefa875399f02271ebdf8aee23a5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "6bf0c5d1ba3e39478389c9fa1d60b95fec599f37", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "7e1b7c08c3dad99fc22c4566c84cf15a3e78082e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "ceda72dcd7ae0ab51976be10386baf0c636bd5fb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 115, "deletions": 73, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "328b2db2b58282ade9b5d6267842fb50af59aa29", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 114, "deletions": 38, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "9b75c19a875ebc4ad83ac100ae5f1aa6a78afb92", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "9e69990f22c0d0c20af457727493daf481e919be", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "e242ec4985ab4ae838f7a974aef0776fcf4fc4d4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "9ed4e6a8e00ae5e3c7bc325362c6c9288fe1eedc", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 87, "deletions": 125, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "20902d9111019bd33c50ad11b927e7101e7317f2", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "666ca5eabe81b93485f5ba5cf3718ceaef1b43e1", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "a3fdb6f73abb0e97f13c49244a33f39fa16ff7d3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "59d1a298eaa69ae6fab6d2bd1e173d227724186a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 99, "deletions": 48, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "77cf50a8341edbaf0805c07ccb814a5568d596fa", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "d2dca9f60845a42ee91d7c2d1e47b344633a786a", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "31f8af1f96872a94189d9e9e0ef32da0e801d285", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "8eee6f35ab9565680c6de5376fe7584d1fc7a607", "filename": "src/librustc/traits/engine.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "d2bde14732bbcdab4eca9a21ea495311826b497d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 142, "deletions": 51, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "1c091d68a2ef1474271ff7cb64f858a560c05b67", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 77, "deletions": 78, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "2ce1b75e3151fa5e3d86b4393d2e6cdee6fe4202", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "2a62d0b5ee39a282db94d4fd89611ce153e45d4e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "af1d2c77c28a867bf40460843ebb964cffef6772", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "f1f9256f825373bca5101446e98f9ca7318292aa", "filename": "src/librustc/traits/query/mod.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "63f50cff4c2ad2c01a37626d52bfe00d9a5e8b25", "filename": "src/librustc/traits/query/normalize.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "a9734e9c2986e0831dd4c1c404e038ea2fa88ae3", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "b1649686323f8750e09e47f33be76fdf28a7f839", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 29, "deletions": 69, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "30b2c55afa1948c5c9f24277655d78d5d15fae8e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "e56a8662f3eb4346747c3ae36e083d49422c6a8d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "d6e6f0e98adc48afb18f4f61efdae5ac64dec78d", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 150, "deletions": 208, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "31e851126d76ad495b8abf0d2513357d890c6ef4", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 58, "deletions": 97, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "9e38911f53c9a0ec179cb93f5428725b1e771349", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "a0c31e8b509239230c7b909d180bf3f86f9f224a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "4e15f0711a5aa2a6b88bc71cde1635b801215117", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "fdda2286da03b00332fa51d21031581bd16699b9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 97, "deletions": 42, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "eb3924186472c57d9364ca1b551db96f7026bf87", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "31b3ca44700e96676f076782f02d0af0797279f1", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "086fc66c70f9d27e85bef68f93c77bade8f3231e", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "8071cd0c639da6b8a3dec899d13b7dd9853b94ab", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "325f8575fd0a792b922546a9277cc3d737fdb4c2", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "76f7a0b59a2a568352ee86726154598e2a21d76b", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "1f23b0a27e33de547d85402b0bf9301317978ce1", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "5f9c305d92f04ec32860e064606b3cb541e19f7d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "a08cd57b1f7e24639d4e1128419f4240f6f9428e", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "b8167ec918638be880a6bc0351e98c105208dd01", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "8651619705b4203680a513756eea95bab481330f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "c103d6e015aa4c37093a10ed548822dd2804eb5c", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 82, "deletions": 62, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "fa69eb8e5bc661f8b057538b6c88d1cd1b271cbd", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "8d38d7dbbbbff6e3594f0319a727f991197a06ea", "filename": "src/librustc/ty/maps/values.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "72ba199eb24122d38032e4f5717d6b9911a2b240", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 124, "deletions": 169, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "36eb3e3f94cfa0c529750b954c27d160bd310f8a", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "8cf662ccaea9254f9421c5ee4d37a504b828662f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 133, "deletions": 441, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "ed04d41ba1457fbfddb518db98a4928884b7d4a9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "e7b58ae1564aa1683a86a36d92c5ee81eae26a47", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "22f851a908b252b5f2046949b4f4fdb74a812876", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 45, "deletions": 145, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "46c048e839b4b9e422942b387f1e2f3e8169f4aa", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "f05d56c9d8371657ccb05c6d1b76cd422f425b6c", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "b68cfd278fa9eb0b01f35b3124b94c1822874ce3", "filename": "src/librustc/util/captures.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Futil%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Futil%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcaptures.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "6b896a889e3003112b33eee21e6ad1ee32afb9c7", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "d27cda4040e5646bf249eeb85e7564efe8c4a6f0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "ee38cca7828be0ef486d8f3555d0675ee6b26524", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "6f08fcf702595eb49957fc70ff8c43516c6925c9", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "627d79724b28a463568723c97dedc96728eaa13d", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "4c5b1417a2f670865a8c535d01f2243c171ef018", "filename": "src/librustc_back/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FCargo.toml?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "3c01692c12b3c846957c15f44d2746158808e1f8", "filename": "src/librustc_back/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FREADME.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "9baee26770998a4ffe92f3bb53ad7d4a303134d9", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "ab7df4ba1c543395b28c6b857c4a657997375685", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "3b13ef015006432fadc3f1d768d1d92351317f0c", "filename": "src/librustc_back/target/l4re_base.rs", "status": "modified", "additions": 16, "deletions": 55, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "cffd1daed99f28bc7a5a0adf560d052b98cda8b3", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "555855b8f815ddea8dc971a62fc2a54f60b60896", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "6bef2fe2ea717eb0cbb88452c17179d1de62bfed", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "a5dbdd111835976abf0112af111da65a48dd7a08", "filename": "src/librustc_back/target/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "507243a58a5f9506b62c282c7a7c6875e7f470bb", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 96, "deletions": 26, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "821a77f52f511b203fb6ead8cc2fb5586c47e949", "filename": "src/librustc_back/target/x86_64_unknown_l4re_uclibc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}, {"sha": "29f03c06ab75999c5048b74340ee2a87b8cf60b0", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b06fe1ef53775d8ff747528d429dc92054c20b2/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=1b06fe1ef53775d8ff747528d429dc92054c20b2"}]}