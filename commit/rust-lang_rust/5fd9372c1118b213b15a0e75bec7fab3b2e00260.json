{"sha": "5fd9372c1118b213b15a0e75bec7fab3b2e00260", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZDkzNzJjMTExOGIyMTNiMTVhMGU3NWJlYzdmYWIzYjJlMDAyNjA=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-13T07:17:05Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-04-13T16:48:58Z"}, "message": "BufWriter: optimize for write sizes less than buffer size\n\nOptimize for the common case where the input write size is less than the\nbuffer size. This slightly increases the cost for pathological write\npatterns that commonly fill the buffer exactly, but if a client is doing\nthat frequently, they're already paying the cost of frequent flushing,\netc., so the cost is of this optimization to them is relatively small.", "tree": {"sha": "d4ba89128afa13fa433fc51a1c3dded3450e8115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4ba89128afa13fa433fc51a1c3dded3450e8115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fd9372c1118b213b15a0e75bec7fab3b2e00260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd9372c1118b213b15a0e75bec7fab3b2e00260", "html_url": "https://github.com/rust-lang/rust/commit/5fd9372c1118b213b15a0e75bec7fab3b2e00260", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fd9372c1118b213b15a0e75bec7fab3b2e00260/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b43e8e248bfba9e8d26821c6d98deba94d024abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43e8e248bfba9e8d26821c6d98deba94d024abf", "html_url": "https://github.com/rust-lang/rust/commit/b43e8e248bfba9e8d26821c6d98deba94d024abf"}], "stats": {"total": 56, "additions": 32, "deletions": 24}, "files": [{"sha": "f0ff186d99b118bc45f266261102724a935d7bcd", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5fd9372c1118b213b15a0e75bec7fab3b2e00260/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd9372c1118b213b15a0e75bec7fab3b2e00260/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=5fd9372c1118b213b15a0e75bec7fab3b2e00260", "patch": "@@ -349,19 +349,26 @@ impl<W: Write> BufWriter<W> {\n     // Ensure this function does not get inlined into `write`, so that it\n     // remains inlineable and its common path remains as short as possible.\n     // If this function ends up being called frequently relative to `write`,\n-    // it's likely a sign that the client is using an improperly sized buffer.\n+    // it's likely a sign that the client is using an improperly sized buffer\n+    // or their write patterns are somewhat pathological.\n     #[inline(never)]\n-    fn flush_and_write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.flush_buf()?;\n+    fn write_cold(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n \n-        // Why not len > capacity? To avoid a needless trip through the buffer when the\n-        // input exactly fills. We'd just need to flush it to the underlying writer anyway.\n+        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n+        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n         if buf.len() >= self.buf.capacity() {\n             self.panicked = true;\n             let r = self.get_mut().write(buf);\n             self.panicked = false;\n             r\n         } else {\n+            // Write to the buffer. In this case, we write to the buffer even if it fills it\n+            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n+            // input to the inner writer, which in many cases would be a worse strategy.\n+\n             // SAFETY: We just called `self.flush_buf()`, so `self.buf.len()` is 0, and\n             // we entered this else block because `buf.len() < self.buf.capacity()`.\n             // Therefore, `self.buf.len() + buf.len() <= self.buf.capacity()`.\n@@ -376,23 +383,30 @@ impl<W: Write> BufWriter<W> {\n     // Ensure this function does not get inlined into `write_all`, so that it\n     // remains inlineable and its common path remains as short as possible.\n     // If this function ends up being called frequently relative to `write_all`,\n-    // it's likely a sign that the client is using an improperly sized buffer.\n+    // it's likely a sign that the client is using an improperly sized buffer\n+    // or their write patterns are somewhat pathological.\n     #[inline(never)]\n-    fn flush_and_write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+    fn write_all_cold(&mut self, buf: &[u8]) -> io::Result<()> {\n         // Normally, `write_all` just calls `write` in a loop. We can do better\n         // by calling `self.get_mut().write_all()` directly, which avoids\n         // round trips through the buffer in the event of a series of partial\n         // writes in some circumstances.\n-        self.flush_buf()?;\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n \n-        // Why not len > capacity? To avoid a needless trip through the buffer when the\n-        // input exactly fills. We'd just need to flush it to the underlying writer anyway.\n+        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n+        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n         if buf.len() >= self.buf.capacity() {\n             self.panicked = true;\n             let r = self.get_mut().write_all(buf);\n             self.panicked = false;\n             r\n         } else {\n+            // Write to the buffer. In this case, we write to the buffer even if it fills it\n+            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n+            // input to the inner writer, which in many cases would be a worse strategy.\n+\n             // SAFETY: We just called `self.flush_buf()`, so `self.buf.len()` is 0, and\n             // we entered this else block because `buf.len() < self.buf.capacity()`.\n             // Therefore, `self.buf.len() + buf.len() <= self.buf.capacity()`.\n@@ -489,39 +503,33 @@ impl fmt::Debug for WriterPanicked {\n impl<W: Write> Write for BufWriter<W> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        // The `buf.len() != self.buf.capacity()` check is done to avoid a needless trip through\n-        // the buffer when the input is exactly the same size as it. For many clients, that is a\n-        // rare event, so it's unfortunate that the check is in the common code path. But it\n-        // prevents pathological cases for other clients which *always* make writes of this size.\n-        // See #72919 and #79930 for more info and a breadcrumb trail.\n-        if self.buf.len() + buf.len() <= self.buf.capacity() && buf.len() != self.buf.capacity() {\n+        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n+        // See `write_cold` for details.\n+        if self.buf.len() + buf.len() < self.buf.capacity() {\n             // SAFETY: safe by above conditional.\n             unsafe {\n                 self.write_to_buffer_unchecked(buf);\n             }\n \n             Ok(buf.len())\n         } else {\n-            self.flush_and_write(buf)\n+            self.write_cold(buf)\n         }\n     }\n \n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        // The `buf.len() != self.buf.capacity()` check is done to avoid a needless trip through\n-        // the buffer when the input is exactly the same size as it. For many clients, that is a\n-        // rare event, so it's unfortunate that the check is in the common code path. But it\n-        // prevents pathological cases for other clients which *always* make writes of this size.\n-        // See #72919 and #79930 for more info and a breadcrumb trail.\n-        if self.buf.len() + buf.len() <= self.buf.capacity() && buf.len() != self.buf.capacity() {\n+        // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n+        // See `write_all_cold` for details.\n+        if self.buf.len() + buf.len() < self.buf.capacity() {\n             // SAFETY: safe by above conditional.\n             unsafe {\n                 self.write_to_buffer_unchecked(buf);\n             }\n \n             Ok(())\n         } else {\n-            self.flush_and_write_all(buf)\n+            self.write_all_cold(buf)\n         }\n     }\n "}]}