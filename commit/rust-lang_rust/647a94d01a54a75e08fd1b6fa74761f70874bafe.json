{"sha": "647a94d01a54a75e08fd1b6fa74761f70874bafe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0N2E5NGQwMWE1NGE3NWUwOGZkMWI2ZmE3NDc2MWY3MDg3NGJhZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T07:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T07:21:39Z"}, "message": "auto merge of #5260 : pcwalton/rust/assert, r=pcwalton\n\nr? @brson", "tree": {"sha": "f59ac942ce69c32b85c0afa9709c563fa7005e14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f59ac942ce69c32b85c0afa9709c563fa7005e14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/647a94d01a54a75e08fd1b6fa74761f70874bafe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/647a94d01a54a75e08fd1b6fa74761f70874bafe", "html_url": "https://github.com/rust-lang/rust/commit/647a94d01a54a75e08fd1b6fa74761f70874bafe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/647a94d01a54a75e08fd1b6fa74761f70874bafe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7", "html_url": "https://github.com/rust-lang/rust/commit/ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7"}, {"sha": "48b14f55625dda49477a733f28e5a9317b6a26bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/48b14f55625dda49477a733f28e5a9317b6a26bc", "html_url": "https://github.com/rust-lang/rust/commit/48b14f55625dda49477a733f28e5a9317b6a26bc"}], "stats": {"total": 19072, "additions": 9613, "deletions": 9459}, "files": [{"sha": "8924ee6f4f60cac67916d0c567aec9470e61535b", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -205,7 +205,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n The keywords are the following strings:\n \n ~~~~~~~~ {.keyword}\n-as assert\n+as\n break\n const copy\n do drop\n@@ -2000,7 +2000,7 @@ let v = ~[1,2,3];\n \n mutate(copy v);   // Pass a copy\n \n-assert v[0] == 1; // Original was not modified\n+fail_unless!(v[0] == 1); // Original was not modified\n ~~~~\n \n ### Unary move expressions\n@@ -2450,17 +2450,6 @@ In the future, logging will move into a library, and will no longer be a core ex\n It is therefore recommended to use the macro forms of logging (`error!`, `debug!`, etc.) to minimize disruption in code that uses logging.\n \n \n-### Assert expressions\n-\n-~~~~~~~~{.ebnf .gram}\n-assert_expr : \"assert\" expr ;\n-~~~~~~~~\n-\n-> **Note:** In future versions of Rust, `assert` will be changed from a full expression to a macro.\n-\n-An `assert` expression causes the program to fail if its `expr` argument evaluates to `false`.\n-The failure carries string representation of the false expression.\n-\n # Type system\n \n ## Types\n@@ -2560,7 +2549,7 @@ An example of a tuple type and its use:\n type Pair<'self> = (int,&'self str);\n let p: Pair<'static> = (10,\"hello\");\n let (a, b) = p;\n-assert b != \"world\";\n+fail_unless!(b != \"world\");\n ~~~~\n \n \n@@ -2581,7 +2570,7 @@ An example of a vector type and its use:\n ~~~~\n let v: &[int] = &[7, 5, 3];\n let i: int = v[2];\n-assert (i == 3);\n+fail_unless!(i == 3);\n ~~~~\n \n All accessible elements of a vector are always initialized, and access to a vector is always bounds-checked.\n@@ -2986,7 +2975,7 @@ example of an _implicit dereference_ operation performed on box values:\n ~~~~~~~~\n struct Foo { y: int }\n let x = @Foo{y: 10};\n-assert x.y == 10;\n+fail_unless!(x.y == 10);\n ~~~~~~~~\n \n Other operations act on box values as single-word-sized address values. For"}, {"sha": "6660a4a7942163eac4349e5cb5ff16f5b01be6a9", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -239,7 +239,7 @@ fn unix_time_in_microseconds() -> u64 {\n     }\n }\n \n-# fn main() { assert fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"; }\n+# fn main() { fail_unless!(fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"); }\n ~~~~\n \n The `#[nolink]` attribute indicates that there's no foreign library to"}, {"sha": "f5d3a482a9f7b3db9247c48756ba12bd699c97da", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -297,9 +297,9 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n \n Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n (which can also be written with an error string as an argument: `fail!(\n-~reason)`) and the `assert` construct (which effectively calls `fail!()` if a\n-boolean expression is false) are both ways to raise exceptions. When a task\n-raises an exception the task unwinds its stack---running destructors and\n+~reason)`) and the `fail_unless!` construct (which effectively calls `fail!()`\n+if a boolean expression is false) are both ways to raise exceptions. When a\n+task raises an exception the task unwinds its stack---running destructors and\n freeing memory along the way---and then exits. Unlike exceptions in C++,\n exceptions in Rust are unrecoverable within a single task: once a task fails,\n there is no way to \"catch\" the exception.\n@@ -339,7 +339,7 @@ let result: Result<int, ()> = do task::try {\n         fail!(~\"oops!\");\n     }\n };\n-assert result.is_err();\n+fail_unless!(result.is_err());\n ~~~\n \n Unlike `spawn`, the function spawned using `try` may return a value,\n@@ -401,7 +401,7 @@ do spawn {  // Bidirectionally linked\n     // Wait for the supervised child task to exist.\n     let message = receiver.recv();\n     // Kill both it and the parent task.\n-    assert message != 42;\n+    fail_unless!(message != 42);\n }\n do try {  // Unidirectionally linked\n     sender.send(42);\n@@ -507,13 +507,13 @@ do spawn {\n };\n \n from_child.send(22);\n-assert from_child.recv() == ~\"22\";\n+fail_unless!(from_child.recv() == ~\"22\");\n \n from_child.send(23);\n from_child.send(0);\n \n-assert from_child.recv() == ~\"23\";\n-assert from_child.recv() == ~\"0\";\n+fail_unless!(from_child.recv() == ~\"23\");\n+fail_unless!(from_child.recv() == ~\"0\");\n \n # }\n ~~~~"}, {"sha": "79553d5aa6ed0a6dd1ec4a4b57791a60982bd670", "filename": "doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -381,7 +381,7 @@ expression to the given type.\n ~~~~\n let x: float = 4.0;\n let y: uint = x as uint;\n-assert y == 4u;\n+fail_unless!(y == 4u);\n ~~~~\n \n ## Syntax extensions\n@@ -849,8 +849,8 @@ Ending the function with a semicolon like so is equivalent to returning `()`.\n fn line(a: int, b: int, x: int) -> int { a * x + b  }\n fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }\n \n-assert 8  == line(5, 3, 1);\n-assert () == oops(5, 3, 1);\n+fail_unless!(8 == line(5, 3, 1));\n+fail_unless!(() == oops(5, 3, 1));\n ~~~~\n \n As with `match` expressions and `let` bindings, function arguments support\n@@ -1000,7 +1000,7 @@ let x = ~10;\n let y = copy x;\n \n let z = *x + *y;\n-assert z == 20;\n+fail_unless!(z == 20);\n ~~~~\n \n When they do not contain any managed boxes, owned boxes can be sent\n@@ -1327,8 +1327,8 @@ and [`core::str`]. Here are some examples.\n let crayons = [Almond, AntiqueBrass, Apricot];\n \n // Check the length of the vector\n-assert crayons.len() == 3;\n-assert !crayons.is_empty();\n+fail_unless!(crayons.len() == 3);\n+fail_unless!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n for crayons.each |crayon| {"}, {"sha": "7d53b29e040296e57d244e800e91c742759f097e", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -63,7 +63,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n           getopts::optopt(~\"logfile\"),\n           getopts::optflag(~\"jit\")];\n \n-    assert !args.is_empty();\n+    fail_unless!(!args.is_empty());\n     let args_ = vec::tail(args);\n     let matches =\n         &match getopts::getopts(args_, opts) {"}, {"sha": "b8e95c67e27667528dcf7679c68f45a075068d59", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -25,7 +25,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n     let mut env = os::env();\n \n     // Make sure we include the aux directory in the path\n-    assert prog.ends_with(~\".exe\");\n+    fail_unless!(prog.ends_with(~\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u) + ~\".libaux\";\n \n     env = do vec::map(env) |pair| {"}, {"sha": "7a2a15a5421dc2202e927e531443d13ea1cdd529", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -23,11 +23,18 @@ use vec;\n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n \n-#[abi = \"cdecl\"]\n-pub extern mod rustrt {\n-    pub unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                            ++v: **vec::raw::VecRepr,\n-                                            ++n: libc::size_t);\n+pub mod rustrt {\n+    use libc;\n+    use sys;\n+    use vec;\n+\n+    #[abi = \"cdecl\"]\n+    #[link_name = \"rustrt\"]\n+    pub extern {\n+        pub unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+                                                ++v: **vec::raw::VecRepr,\n+                                                ++n: libc::size_t);\n+    }\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n@@ -285,31 +292,31 @@ pub fn test() {\n         }\n     }\n \n-    assert seq_range(10, 15) == @[10, 11, 12, 13, 14];\n-    assert from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5];\n-    assert from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14];\n+    fail_unless!(seq_range(10, 15) == @[10, 11, 12, 13, 14]);\n+    fail_unless!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n+    fail_unless!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n }\n \n #[test]\n pub fn append_test() {\n-    assert @[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6];\n+    fail_unless!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n }\n \n #[test]\n pub fn test_from_owned() {\n-    assert from_owned::<int>(~[]) == @[];\n-    assert from_owned(~[true]) == @[true];\n-    assert from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5];\n-    assert from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"];\n-    assert from_owned(~[~[42]]) == @[~[42]];\n+    fail_unless!(from_owned::<int>(~[]) == @[]);\n+    fail_unless!(from_owned(~[true]) == @[true]);\n+    fail_unless!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+    fail_unless!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n+    fail_unless!(from_owned(~[~[42]]) == @[~[42]]);\n }\n \n #[test]\n pub fn test_from_slice() {\n-    assert from_slice::<int>([]) == @[];\n-    assert from_slice([true]) == @[true];\n-    assert from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5];\n-    assert from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"];\n-    assert from_slice([@[42]]) == @[@[42]];\n+    fail_unless!(from_slice::<int>([]) == @[]);\n+    fail_unless!(from_slice([true]) == @[true]);\n+    fail_unless!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+    fail_unless!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n+    fail_unless!(from_slice([@[42]]) == @[@[42]]);\n }\n "}, {"sha": "13b8d0fc907fd998612e739ea0d5a6039066cc64", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -86,20 +86,20 @@ pub fn test_bool_from_str() {\n     use from_str::FromStr;\n \n     do all_values |v| {\n-        assert Some(v) == FromStr::from_str(to_str(v))\n+        fail_unless!(Some(v) == FromStr::from_str(to_str(v)))\n     }\n }\n \n #[test]\n pub fn test_bool_to_str() {\n-    assert to_str(false) == ~\"false\";\n-    assert to_str(true) == ~\"true\";\n+    fail_unless!(to_str(false) == ~\"false\");\n+    fail_unless!(to_str(true) == ~\"true\");\n }\n \n #[test]\n pub fn test_bool_to_bit() {\n     do all_values |v| {\n-        assert to_bit(v) == if is_true(v) { 1u8 } else { 0u8 };\n+        fail_unless!(to_bit(v) == if is_true(v) { 1u8 } else { 0u8 });\n     }\n }\n "}, {"sha": "f17b04da503a9b875408f80112e12f6cffba96c9", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn forget<T>(-x: T);\n-    fn reinterpret_cast<T, U>(&&e: T) -> U;\n+pub mod rusti {\n+    #[abi = \"rust-intrinsic\"]\n+    #[link_name = \"rusti\"]\n+    pub extern {\n+        fn forget<T>(-x: T);\n+        fn reinterpret_cast<T, U>(&&e: T) -> U;\n+    }\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n@@ -45,7 +48,7 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *\n  * # Example\n  *\n- *     assert transmute(\"L\") == ~[76u8, 0u8];\n+ *     fail_unless!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n #[inline(always)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n@@ -109,7 +112,7 @@ pub mod tests {\n \n     #[test]\n     pub fn test_reinterpret_cast() {\n-        assert 1u == unsafe { reinterpret_cast(&1) };\n+        fail_unless!(1u == unsafe { reinterpret_cast(&1) });\n     }\n \n     #[test]\n@@ -120,8 +123,8 @@ pub mod tests {\n             let ptr: *int = transmute(box); // refcount 2\n             let _box1: @~str = reinterpret_cast(&ptr);\n             let _box2: @~str = reinterpret_cast(&ptr);\n-            assert *_box1 == ~\"box box box\";\n-            assert *_box2 == ~\"box box box\";\n+            fail_unless!(*_box1 == ~\"box box box\");\n+            fail_unless!(*_box2 == ~\"box box box\");\n             // Will destroy _box1 and _box2. Without the bump, this would\n             // use-after-free. With too many bumps, it would leak.\n         }\n@@ -133,15 +136,15 @@ pub mod tests {\n         unsafe {\n             let x = @100u8;\n             let x: *BoxRepr = transmute(x);\n-            assert (*x).data == 100;\n+            fail_unless!((*x).data == 100);\n             let _x: @int = transmute(x);\n         }\n     }\n \n     #[test]\n     pub fn test_transmute2() {\n         unsafe {\n-            assert ~[76u8, 0u8] == transmute(~\"L\");\n+            fail_unless!(~[76u8, 0u8] == transmute(~\"L\"));\n         }\n     }\n }"}, {"sha": "8df0037b2afe309d3893cbdc87a26fb9f0d98753", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -65,12 +65,12 @@ pub impl<T> Cell<T> {\n #[test]\n fn test_basic() {\n     let value_cell = Cell(~10);\n-    assert !value_cell.is_empty();\n+    fail_unless!(!value_cell.is_empty());\n     let value = value_cell.take();\n-    assert value == ~10;\n-    assert value_cell.is_empty();\n+    fail_unless!(value == ~10);\n+    fail_unless!(value_cell.is_empty());\n     value_cell.put_back(value);\n-    assert !value_cell.is_empty();\n+    fail_unless!(!value_cell.is_empty());\n }\n \n #[test]"}, {"sha": "7922103029b510de9d44b6b64a0ad51bb80ede89", "filename": "src/libcore/char.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -200,7 +200,7 @@ pub pure fn escape_unicode(c: char) -> ~str {\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });\n-    assert str::len(s) <= pad;\n+    fail_unless!(str::len(s) <= pad);\n     let mut out = ~\"\\\\\";\n     unsafe {\n         str::push_str(&mut out, str::from_char(c));\n@@ -258,91 +258,91 @@ impl Eq for char {\n \n #[test]\n fn test_is_lowercase() {\n-    assert is_lowercase('a');\n-    assert is_lowercase('\u00f6');\n-    assert is_lowercase('\u00df');\n-    assert !is_lowercase('\u00dc');\n-    assert !is_lowercase('P');\n+    fail_unless!(is_lowercase('a'));\n+    fail_unless!(is_lowercase('\u00f6'));\n+    fail_unless!(is_lowercase('\u00df'));\n+    fail_unless!(!is_lowercase('\u00dc'));\n+    fail_unless!(!is_lowercase('P'));\n }\n \n #[test]\n fn test_is_uppercase() {\n-    assert !is_uppercase('h');\n-    assert !is_uppercase('\u00e4');\n-    assert !is_uppercase('\u00df');\n-    assert is_uppercase('\u00d6');\n-    assert is_uppercase('T');\n+    fail_unless!(!is_uppercase('h'));\n+    fail_unless!(!is_uppercase('\u00e4'));\n+    fail_unless!(!is_uppercase('\u00df'));\n+    fail_unless!(is_uppercase('\u00d6'));\n+    fail_unless!(is_uppercase('T'));\n }\n \n #[test]\n fn test_is_whitespace() {\n-    assert is_whitespace(' ');\n-    assert is_whitespace('\\u2007');\n-    assert is_whitespace('\\t');\n-    assert is_whitespace('\\n');\n+    fail_unless!(is_whitespace(' '));\n+    fail_unless!(is_whitespace('\\u2007'));\n+    fail_unless!(is_whitespace('\\t'));\n+    fail_unless!(is_whitespace('\\n'));\n \n-    assert !is_whitespace('a');\n-    assert !is_whitespace('_');\n-    assert !is_whitespace('\\u0000');\n+    fail_unless!(!is_whitespace('a'));\n+    fail_unless!(!is_whitespace('_'));\n+    fail_unless!(!is_whitespace('\\u0000'));\n }\n \n #[test]\n fn test_to_digit() {\n-    assert to_digit('0', 10u) == Some(0u);\n-    assert to_digit('1', 2u) == Some(1u);\n-    assert to_digit('2', 3u) == Some(2u);\n-    assert to_digit('9', 10u) == Some(9u);\n-    assert to_digit('a', 16u) == Some(10u);\n-    assert to_digit('A', 16u) == Some(10u);\n-    assert to_digit('b', 16u) == Some(11u);\n-    assert to_digit('B', 16u) == Some(11u);\n-    assert to_digit('z', 36u) == Some(35u);\n-    assert to_digit('Z', 36u) == Some(35u);\n+    fail_unless!(to_digit('0', 10u) == Some(0u));\n+    fail_unless!(to_digit('1', 2u) == Some(1u));\n+    fail_unless!(to_digit('2', 3u) == Some(2u));\n+    fail_unless!(to_digit('9', 10u) == Some(9u));\n+    fail_unless!(to_digit('a', 16u) == Some(10u));\n+    fail_unless!(to_digit('A', 16u) == Some(10u));\n+    fail_unless!(to_digit('b', 16u) == Some(11u));\n+    fail_unless!(to_digit('B', 16u) == Some(11u));\n+    fail_unless!(to_digit('z', 36u) == Some(35u));\n+    fail_unless!(to_digit('Z', 36u) == Some(35u));\n \n-    assert to_digit(' ', 10u).is_none();\n-    assert to_digit('$', 36u).is_none();\n+    fail_unless!(to_digit(' ', 10u).is_none());\n+    fail_unless!(to_digit('$', 36u).is_none());\n }\n \n #[test]\n fn test_is_ascii() {\n-   assert str::all(~\"banana\", is_ascii);\n-   assert ! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", is_ascii);\n+   fail_unless!(str::all(~\"banana\", is_ascii));\n+   fail_unless!(! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", is_ascii));\n }\n \n #[test]\n fn test_is_digit() {\n-   assert is_digit('2');\n-   assert is_digit('7');\n-   assert ! is_digit('c');\n-   assert ! is_digit('i');\n-   assert ! is_digit('z');\n-   assert ! is_digit('Q');\n+   fail_unless!(is_digit('2'));\n+   fail_unless!(is_digit('7'));\n+   fail_unless!(! is_digit('c'));\n+   fail_unless!(! is_digit('i'));\n+   fail_unless!(! is_digit('z'));\n+   fail_unless!(! is_digit('Q'));\n }\n \n #[test]\n fn test_escape_default() {\n-    assert escape_default('\\n') == ~\"\\\\n\";\n-    assert escape_default('\\r') == ~\"\\\\r\";\n-    assert escape_default('\\'') == ~\"\\\\'\";\n-    assert escape_default('\"') == ~\"\\\\\\\"\";\n-    assert escape_default(' ') == ~\" \";\n-    assert escape_default('a') == ~\"a\";\n-    assert escape_default('~') == ~\"~\";\n-    assert escape_default('\\x00') == ~\"\\\\x00\";\n-    assert escape_default('\\x1f') == ~\"\\\\x1f\";\n-    assert escape_default('\\x7f') == ~\"\\\\x7f\";\n-    assert escape_default('\\xff') == ~\"\\\\xff\";\n-    assert escape_default('\\u011b') == ~\"\\\\u011b\";\n-    assert escape_default('\\U0001d4b6') == ~\"\\\\U0001d4b6\";\n+    fail_unless!(escape_default('\\n') == ~\"\\\\n\");\n+    fail_unless!(escape_default('\\r') == ~\"\\\\r\");\n+    fail_unless!(escape_default('\\'') == ~\"\\\\'\");\n+    fail_unless!(escape_default('\"') == ~\"\\\\\\\"\");\n+    fail_unless!(escape_default(' ') == ~\" \");\n+    fail_unless!(escape_default('a') == ~\"a\");\n+    fail_unless!(escape_default('~') == ~\"~\");\n+    fail_unless!(escape_default('\\x00') == ~\"\\\\x00\");\n+    fail_unless!(escape_default('\\x1f') == ~\"\\\\x1f\");\n+    fail_unless!(escape_default('\\x7f') == ~\"\\\\x7f\");\n+    fail_unless!(escape_default('\\xff') == ~\"\\\\xff\");\n+    fail_unless!(escape_default('\\u011b') == ~\"\\\\u011b\");\n+    fail_unless!(escape_default('\\U0001d4b6') == ~\"\\\\U0001d4b6\");\n }\n \n \n #[test]\n fn test_escape_unicode() {\n-    assert escape_unicode('\\x00') == ~\"\\\\x00\";\n-    assert escape_unicode('\\n') == ~\"\\\\x0a\";\n-    assert escape_unicode(' ') == ~\"\\\\x20\";\n-    assert escape_unicode('a') == ~\"\\\\x61\";\n-    assert escape_unicode('\\u011b') == ~\"\\\\u011b\";\n-    assert escape_unicode('\\U0001d4b6') == ~\"\\\\U0001d4b6\";\n+    fail_unless!(escape_unicode('\\x00') == ~\"\\\\x00\");\n+    fail_unless!(escape_unicode('\\n') == ~\"\\\\x0a\");\n+    fail_unless!(escape_unicode(' ') == ~\"\\\\x20\");\n+    fail_unless!(escape_unicode('a') == ~\"\\\\x61\");\n+    fail_unless!(escape_unicode('\\u011b') == ~\"\\\\u011b\");\n+    fail_unless!(escape_unicode('\\U0001d4b6') == ~\"\\\\U0001d4b6\");\n }"}, {"sha": "bf1ea5f1150a7c70c0388644a36b34b3dc7a25dc", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -218,9 +218,14 @@ pub unsafe fn annihilate() {\n }\n \n /// Bindings to the runtime\n-extern mod rustrt {\n-    #[rust_stack]\n-    // FIXME (#4386): Unable to make following method private.\n-    pub unsafe fn rust_get_task() -> *c_void;\n+pub mod rustrt {\n+    use libc::c_void;\n+\n+    #[link_name = \"rustrt\"]\n+    pub extern {\n+        #[rust_stack]\n+        // FIXME (#4386): Unable to make following method private.\n+        pub unsafe fn rust_get_task() -> *c_void;\n+    }\n }\n "}, {"sha": "81f6a7e426640ebb1ad72e5ce9c3cd2dab7d9b29", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -172,10 +172,10 @@ pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n mod test {\n     #[test]\n     fn test_int() {\n-        assert 5.cmp(&10) == Less;\n-        assert 10.cmp(&5) == Greater;\n-        assert 5.cmp(&5) == Equal;\n-        assert (-5).cmp(&12) == Less;\n-        assert 12.cmp(-5) == Greater;\n+        fail_unless!(5.cmp(&10) == Less);\n+        fail_unless!(10.cmp(&5) == Greater);\n+        fail_unless!(5.cmp(&5) == Equal);\n+        fail_unless!((-5).cmp(&12) == Less);\n+        fail_unless!(12.cmp(-5) == Greater);\n     }\n }"}, {"sha": "5b189abf4a373adbd417670b763d7c9cf6e514a8", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -464,6 +464,6 @@ pub mod test {\n             let _chan = chan;\n         }\n \n-        assert !port.peek();\n+        fail_unless!(!port.peek());\n     }\n }"}, {"sha": "17d15a8886f4d6c3a9ba789fe0cd5f08f924bf79", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -124,7 +124,7 @@ mod test {\n             trouble(1);\n         }\n \n-        assert inner_trapped;\n+        fail_unless!(inner_trapped);\n     }\n \n     #[test]\n@@ -140,7 +140,7 @@ mod test {\n             trouble(1);\n         }\n \n-        assert outer_trapped;\n+        fail_unless!(outer_trapped);\n     }\n \n     fn nested_reraise_trap_test_inner() {\n@@ -157,7 +157,7 @@ mod test {\n             trouble(1);\n         }\n \n-        assert inner_trapped;\n+        fail_unless!(inner_trapped);\n     }\n \n     #[test]\n@@ -172,7 +172,7 @@ mod test {\n             nested_reraise_trap_test_inner();\n         }\n \n-        assert outer_trapped;\n+        fail_unless!(outer_trapped);\n     }\n \n     #[test]\n@@ -187,6 +187,6 @@ mod test {\n             trouble(1);\n         }\n \n-        assert trapped;\n+        fail_unless!(trapped);\n     }\n }"}, {"sha": "21d8361868441d1e9a09037a32a756287e3152fe", "filename": "src/libcore/core.rc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -52,6 +52,14 @@ Implicitly, all crates behave as if they included the following prologue:\n #[deny(non_camel_case_types)];\n #[allow(deprecated_mutable_fields)];\n \n+// On Linux, link to the runtime with -lrt.\n+#[cfg(target_os = \"linux\")]\n+pub mod linkhack {\n+    #[link_args=\"-lrustrt -lrt\"]\n+    extern {\n+    }\n+}\n+\n /* The Prelude. */\n \n pub mod prelude;"}, {"sha": "5654d4b9c9b5806a2eec897829c35459cd9f6976", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 182, "deletions": 182, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -170,7 +170,7 @@ priv impl<T> DList<T> {\n     // Remove a node from the list.\n     fn unlink(@mut self, nobe: @mut DListNode<T>) {\n         self.assert_mine(nobe);\n-        assert self.size > 0;\n+        fail_unless!(self.size > 0);\n         self.link(nobe.prev, nobe.next);\n         nobe.prev = None; // Release extraneous references.\n         nobe.next = None;\n@@ -192,7 +192,7 @@ priv impl<T> DList<T> {\n                    nobe: DListLink<T>,\n                    neighbour: @mut DListNode<T>) {\n         self.assert_mine(neighbour);\n-        assert self.size > 0;\n+        fail_unless!(self.size > 0);\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, Some(neighbour));\n         self.size += 1;\n@@ -201,7 +201,7 @@ priv impl<T> DList<T> {\n                     neighbour: @mut DListNode<T>,\n                     nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n-        assert self.size > 0;\n+        fail_unless!(self.size > 0);\n         self.link(nobe, neighbour.next);\n         self.link(Some(neighbour), nobe);\n         self.size += 1;\n@@ -409,15 +409,15 @@ pub impl<T> DList<T> {\n     /// Check data structure integrity. O(n).\n     fn assert_consistent(@mut self) {\n         if self.hd.is_none() || self.tl.is_none() {\n-            assert self.hd.is_none() && self.tl.is_none();\n+            fail_unless!(self.hd.is_none() && self.tl.is_none());\n         }\n         // iterate forwards\n         let mut count = 0;\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n         while link.is_some() {\n             let nobe = link.get();\n-            assert nobe.linked;\n+            fail_unless!(nobe.linked);\n             // check cycle\n             if rabbit.is_some() {\n                 rabbit = rabbit.get().next;\n@@ -426,19 +426,19 @@ pub impl<T> DList<T> {\n                 rabbit = rabbit.get().next;\n             }\n             if rabbit.is_some() {\n-                assert !managed::mut_ptr_eq(rabbit.get(), nobe);\n+                fail_unless!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n             }\n             // advance\n             link = nobe.next_link();\n             count += 1;\n         }\n-        assert count == self.len();\n+        fail_unless!(count == self.len());\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n         while link.is_some() {\n             let nobe = link.get();\n-            assert nobe.linked;\n+            fail_unless!(nobe.linked);\n             // check cycle\n             if rabbit.is_some() {\n                 rabbit = rabbit.get().prev;\n@@ -447,13 +447,13 @@ pub impl<T> DList<T> {\n                 rabbit = rabbit.get().prev;\n             }\n             if rabbit.is_some() {\n-                assert !managed::mut_ptr_eq(rabbit.get(), nobe);\n+                fail_unless!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n             }\n             // advance\n             link = nobe.prev_link();\n             count -= 1;\n         }\n-        assert count == 0;\n+        fail_unless!(count == 0);\n     }\n }\n \n@@ -513,66 +513,66 @@ mod tests {\n         let ab = from_vec(~[a,b]);\n         let cd = from_vec(~[c,d]);\n         let abcd = concat(concat(from_vec(~[ab,cd])));\n-        abcd.assert_consistent(); assert abcd.len() == 8;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 1;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 2;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 3;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 4;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 5;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 6;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 7;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 8;\n-        abcd.assert_consistent(); assert abcd.is_empty();\n+        abcd.assert_consistent(); fail_unless!(abcd.len() == 8);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 1);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 2);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 3);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 4);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 5);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 6);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 7);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 8);\n+        abcd.assert_consistent(); fail_unless!(abcd.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n-        assert a.len() == 6;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 6);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.pop().get() == 6;\n-        a.assert_consistent(); assert a.is_empty();\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 6);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_empty() {\n         let a = from_vec(~[1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n-        assert a.len() == 3;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 3);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.is_empty();\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n-        assert a.len() == 3;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 3);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.pop().get() == 6;\n-        a.assert_consistent(); assert a.is_empty();\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 6);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_two_empty() {\n         let a = DList::<int>();\n         let b = DList::<int>();\n         a.append(b);\n-        assert a.len() == 0;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 0);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n         a.assert_consistent();\n     }\n@@ -595,34 +595,34 @@ mod tests {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         b.prepend(a);\n-        assert a.len() == 0;\n-        assert b.len() == 6;\n+        fail_unless!(a.len() == 0);\n+        fail_unless!(b.len() == 6);\n         a.assert_consistent();\n-        b.assert_consistent(); assert b.pop().get() == 1;\n-        b.assert_consistent(); assert b.pop().get() == 2;\n-        b.assert_consistent(); assert b.pop().get() == 3;\n-        b.assert_consistent(); assert b.pop().get() == 4;\n-        b.assert_consistent(); assert b.pop().get() == 5;\n-        b.assert_consistent(); assert b.pop().get() == 6;\n-        b.assert_consistent(); assert b.is_empty();\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 1);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 2);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 3);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 4);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 5);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 6);\n+        b.assert_consistent(); fail_unless!(b.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.reverse();\n-        assert a.len() == 5;\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.is_empty();\n+        fail_unless!(a.len() == 5);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse_empty() {\n         let a = DList::<int>();\n         a.reverse();\n-        assert a.len() == 0;\n+        fail_unless!(a.len() == 0);\n         a.assert_consistent();\n     }\n     #[test]\n@@ -633,94 +633,94 @@ mod tests {\n                 a.insert_before(3, nobe);\n             }\n         }\n-        assert a.len() == 6;\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.is_empty();\n+        fail_unless!(a.len() == 6);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_clear() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.clear();\n-        assert a.len() == 0;\n+        fail_unless!(a.len() == 0);\n         a.assert_consistent();\n     }\n     #[test]\n     pub fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n         let full1 = from_vec(~[1,2,3]);\n-        assert empty.is_empty();\n-        assert !full1.is_empty();\n+        fail_unless!(empty.is_empty());\n+        fail_unless!(!full1.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_head_tail() {\n         let l = from_vec(~[1,2,3]);\n-        assert l.head() == 1;\n-        assert l.tail() == 3;\n-        assert l.len() == 3;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.len() == 3);\n     }\n     #[test]\n     pub fn test_dlist_pop() {\n         let l = from_vec(~[1,2,3]);\n-        assert l.pop().get() == 1;\n-        assert l.tail() == 3;\n-        assert l.head() == 2;\n-        assert l.pop().get() == 2;\n-        assert l.tail() == 3;\n-        assert l.head() == 3;\n-        assert l.pop().get() == 3;\n-        assert l.is_empty();\n-        assert l.pop().is_none();\n+        fail_unless!(l.pop().get() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.head() == 2);\n+        fail_unless!(l.pop().get() == 2);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.head() == 3);\n+        fail_unless!(l.pop().get() == 3);\n+        fail_unless!(l.is_empty());\n+        fail_unless!(l.pop().is_none());\n     }\n     #[test]\n     pub fn test_dlist_pop_tail() {\n         let l = from_vec(~[1,2,3]);\n-        assert l.pop_tail().get() == 3;\n-        assert l.tail() == 2;\n-        assert l.head() == 1;\n-        assert l.pop_tail().get() == 2;\n-        assert l.tail() == 1;\n-        assert l.head() == 1;\n-        assert l.pop_tail().get() == 1;\n-        assert l.is_empty();\n-        assert l.pop_tail().is_none();\n+        fail_unless!(l.pop_tail().get() == 3);\n+        fail_unless!(l.tail() == 2);\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.pop_tail().get() == 2);\n+        fail_unless!(l.tail() == 1);\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.pop_tail().get() == 1);\n+        fail_unless!(l.is_empty());\n+        fail_unless!(l.pop_tail().is_none());\n     }\n     #[test]\n     pub fn test_dlist_push() {\n         let l = DList::<int>();\n         l.push(1);\n-        assert l.head() == 1;\n-        assert l.tail() == 1;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 1);\n         l.push(2);\n-        assert l.head() == 1;\n-        assert l.tail() == 2;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 2);\n         l.push(3);\n-        assert l.head() == 1;\n-        assert l.tail() == 3;\n-        assert l.len() == 3;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.len() == 3);\n     }\n     #[test]\n     pub fn test_dlist_push_head() {\n         let l = DList::<int>();\n         l.push_head(3);\n-        assert l.head() == 3;\n-        assert l.tail() == 3;\n+        fail_unless!(l.head() == 3);\n+        fail_unless!(l.tail() == 3);\n         l.push_head(2);\n-        assert l.head() == 2;\n-        assert l.tail() == 3;\n+        fail_unless!(l.head() == 2);\n+        fail_unless!(l.tail() == 3);\n         l.push_head(1);\n-        assert l.head() == 1;\n-        assert l.tail() == 3;\n-        assert l.len() == 3;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.len() == 3);\n     }\n     #[test]\n     pub fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n-        assert iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050;\n+        fail_unless!(iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050);\n     }\n     #[test]\n     pub fn test_dlist_break_early() {\n@@ -730,173 +730,173 @@ mod tests {\n             x += 1;\n             if (*i == 3) { break; }\n         }\n-        assert x == 3;\n+        fail_unless!(x == 3);\n     }\n     #[test]\n     pub fn test_dlist_remove_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); assert l.len() == 2;\n-        l.assert_consistent(); assert l.head() == 2;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); fail_unless!(l.head() == 2);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_mid() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); assert l.len() == 2;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert l.len() == 2;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_one_two() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(one);\n         l.assert_consistent(); l.remove(two);\n         // and through and through, the vorpal blade went snicker-snack\n-        l.assert_consistent(); assert l.len() == 1;\n-        l.assert_consistent(); assert l.head() == 3;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 1);\n+        l.assert_consistent(); fail_unless!(l.head() == 3);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_one_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(one);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert l.len() == 1;\n-        l.assert_consistent(); assert l.head() == 2;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 1);\n+        l.assert_consistent(); fail_unless!(l.head() == 2);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_two_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert l.len() == 1;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 1);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_all() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n         l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n-        l.assert_consistent(); assert l.peek().is_none();\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.peek().is_none());\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_n_before() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_n_before(three, two);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_n_after() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_n_after(three, one);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_before_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_before(3, one);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 3;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 3);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_after_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_after(3, two);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_dlist_asymmetric_link() {"}, {"sha": "e26f94261f9f9e071905230abe5b3a950b234e18", "filename": "src/libcore/either.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -176,92 +176,92 @@ fn test_either_left() {\n     let val = Left(10);\n     fn f_left(x: &int) -> bool { *x == 10 }\n     fn f_right(_x: &uint) -> bool { false }\n-    assert (either(f_left, f_right, &val));\n+    fail_unless!((either(f_left, f_right, &val)));\n }\n \n #[test]\n fn test_either_right() {\n     let val = Right(10u);\n     fn f_left(_x: &int) -> bool { false }\n     fn f_right(x: &uint) -> bool { *x == 10u }\n-    assert (either(f_left, f_right, &val));\n+    fail_unless!((either(f_left, f_right, &val)));\n }\n \n #[test]\n fn test_lefts() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = lefts(input);\n-    assert (result == ~[10, 12, 14]);\n+    fail_unless!((result == ~[10, 12, 14]));\n }\n \n #[test]\n fn test_lefts_none() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n     let result = lefts(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_lefts_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = lefts(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_rights() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = rights(input);\n-    assert (result == ~[11, 13]);\n+    fail_unless!((result == ~[11, 13]));\n }\n \n #[test]\n fn test_rights_none() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n     let result = rights(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_rights_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = rights(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_partition() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let (lefts, rights) = partition(input);\n-    assert (lefts[0] == 10);\n-    assert (lefts[1] == 12);\n-    assert (lefts[2] == 14);\n-    assert (rights[0] == 11);\n-    assert (rights[1] == 13);\n+    fail_unless!((lefts[0] == 10));\n+    fail_unless!((lefts[1] == 12));\n+    fail_unless!((lefts[2] == 14));\n+    fail_unless!((rights[0] == 11));\n+    fail_unless!((rights[1] == 13));\n }\n \n #[test]\n fn test_partition_no_lefts() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n     let (lefts, rights) = partition(input);\n-    assert (vec::len(lefts) == 0u);\n-    assert (vec::len(rights) == 2u);\n+    fail_unless!((vec::len(lefts) == 0u));\n+    fail_unless!((vec::len(rights) == 2u));\n }\n \n #[test]\n fn test_partition_no_rights() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n     let (lefts, rights) = partition(input);\n-    assert (vec::len(lefts) == 2u);\n-    assert (vec::len(rights) == 0u);\n+    fail_unless!((vec::len(lefts) == 2u));\n+    fail_unless!((vec::len(rights) == 0u));\n }\n \n #[test]\n fn test_partition_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let (lefts, rights) = partition(input);\n-    assert (vec::len(lefts) == 0u);\n-    assert (vec::len(rights) == 0u);\n+    fail_unless!((vec::len(lefts) == 0u));\n+    fail_unless!((vec::len(rights) == 0u));\n }\n \n //"}, {"sha": "f9348ae5380736cf1150d245cb676f985f5e937b", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -21,16 +21,23 @@ use vec;\n \n #[cfg(test)] use rand;\n \n-extern mod rustrt {\n-    unsafe fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n-                                         src_buf_len: size_t,\n-                                         pout_len: *size_t,\n-                                         flags: c_int) -> *c_void;\n+pub mod rustrt {\n+    use libc::{c_int, c_void, size_t};\n \n-    unsafe fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n-                                           src_buf_len: size_t,\n-                                           pout_len: *size_t,\n-                                           flags: c_int) -> *c_void;\n+    #[link_name = \"rustrt\"]\n+    pub extern {\n+        unsafe fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n+                                             src_buf_len: size_t,\n+                                             pout_len: *size_t,\n+                                             flags: c_int)\n+                                          -> *c_void;\n+\n+        unsafe fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n+                                               src_buf_len: size_t,\n+                                               pout_len: *size_t,\n+                                               flags: c_int)\n+                                            -> *c_void;\n+    }\n }\n \n const lz_none : c_int = 0x0;   // Huffman-coding only.\n@@ -47,7 +54,7 @@ pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n                                                    len as size_t,\n                                                    ptr::addr_of(&outsz),\n                                                    lz_norm);\n-            assert res as int != 0;\n+            fail_unless!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n@@ -65,7 +72,7 @@ pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n                                                      len as size_t,\n                                                      ptr::addr_of(&outsz),\n                                                      0);\n-            assert res as int != 0;\n+            fail_unless!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n@@ -94,6 +101,6 @@ fn test_flate_round_trip() {\n         debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n                in.len(), cmp.len(),\n                100.0 * ((cmp.len() as float) / (in.len() as float)));\n-        assert(in == out);\n+        fail_unless!((in == out));\n     }\n }"}, {"sha": "5f84f7f0d19e52ae5173affc7f0b11860da657a4", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -48,23 +48,30 @@ use sys;\n pub use stackwalk::Word;\n \n // Mirrors rust_stack.h stk_seg\n-struct StackSegment {\n+pub struct StackSegment {\n     prev: *StackSegment,\n     next: *StackSegment,\n     end: uintptr_t,\n     // And other fields which we don't care about...\n }\n \n-extern mod rustrt {\n-    #[rust_stack]\n-    pub unsafe fn rust_call_tydesc_glue(root: *Word,\n-                                        tydesc: *Word,\n-                                        field: size_t);\n+pub mod rustrt {\n+    use libc::size_t;\n+    use stackwalk::Word;\n+    use super::StackSegment;\n \n-    #[rust_stack]\n-    pub unsafe fn rust_gc_metadata() -> *Word;\n+    #[link_name = \"rustrt\"]\n+    pub extern {\n+        #[rust_stack]\n+        pub unsafe fn rust_call_tydesc_glue(root: *Word,\n+                                            tydesc: *Word,\n+                                            field: size_t);\n \n-    pub unsafe fn rust_get_stack_segment() -> *StackSegment;\n+        #[rust_stack]\n+        pub unsafe fn rust_gc_metadata() -> *Word;\n+\n+        pub unsafe fn rust_get_stack_segment() -> *StackSegment;\n+    }\n }\n \n unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {"}, {"sha": "7f2189df20e25699f042cb69fbf741e89fa65d45", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -458,7 +458,7 @@ pub fn test_siphash() {\n         let vec = u8to64_le!(vecs[t], 0);\n         let out = buf.hash_keyed(k0, k1);\n         debug!(\"got %?, expected %?\", out, vec);\n-        assert vec == out;\n+        fail_unless!(vec == out);\n \n         stream_full.reset();\n         stream_full.input(buf);\n@@ -467,7 +467,7 @@ pub fn test_siphash() {\n         let v = to_hex_str(&vecs[t]);\n         debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n \n-        assert f == i && f == v;\n+        fail_unless!(f == i && f == v);\n \n         buf += ~[t as u8];\n         stream_inc.input(~[t as u8]);\n@@ -479,20 +479,20 @@ pub fn test_siphash() {\n #[test] #[cfg(target_arch = \"arm\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert (val as u64).hash() != (val as uint).hash();\n-    assert (val as u32).hash() == (val as uint).hash();\n+    fail_unless!((val as u64).hash() != (val as uint).hash());\n+    fail_unless!((val as u32).hash() == (val as uint).hash());\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert (val as u64).hash() == (val as uint).hash();\n-    assert (val as u32).hash() != (val as uint).hash();\n+    fail_unless!((val as u64).hash() == (val as uint).hash());\n+    fail_unless!((val as u32).hash() != (val as uint).hash());\n }\n #[test] #[cfg(target_arch = \"x86\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert (val as u64).hash() != (val as uint).hash();\n-    assert (val as u32).hash() == (val as uint).hash();\n+    fail_unless!((val as u64).hash() != (val as uint).hash());\n+    fail_unless!((val as u32).hash() == (val as uint).hash());\n }\n \n #[test]\n@@ -507,17 +507,17 @@ pub fn test_hash_idempotent() {\n pub fn test_hash_no_bytes_dropped_64() {\n     let val = 0xdeadbeef_deadbeef_u64;\n \n-    assert val.hash() != zero_byte(val, 0).hash();\n-    assert val.hash() != zero_byte(val, 1).hash();\n-    assert val.hash() != zero_byte(val, 2).hash();\n-    assert val.hash() != zero_byte(val, 3).hash();\n-    assert val.hash() != zero_byte(val, 4).hash();\n-    assert val.hash() != zero_byte(val, 5).hash();\n-    assert val.hash() != zero_byte(val, 6).hash();\n-    assert val.hash() != zero_byte(val, 7).hash();\n+    fail_unless!(val.hash() != zero_byte(val, 0).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 1).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 2).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 3).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 4).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 5).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 6).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 7).hash());\n \n     fn zero_byte(val: u64, byte: uint) -> u64 {\n-        assert byte < 8;\n+        fail_unless!(byte < 8);\n         val & !(0xff << (byte * 8))\n     }\n }\n@@ -526,13 +526,13 @@ pub fn test_hash_no_bytes_dropped_64() {\n pub fn test_hash_no_bytes_dropped_32() {\n     let val = 0xdeadbeef_u32;\n \n-    assert val.hash() != zero_byte(val, 0).hash();\n-    assert val.hash() != zero_byte(val, 1).hash();\n-    assert val.hash() != zero_byte(val, 2).hash();\n-    assert val.hash() != zero_byte(val, 3).hash();\n+    fail_unless!(val.hash() != zero_byte(val, 0).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 1).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 2).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 3).hash());\n \n     fn zero_byte(val: u32, byte: uint) -> u32 {\n-        assert byte < 4;\n+        fail_unless!(byte < 4);\n         val & !(0xff << (byte * 8))\n     }\n }"}, {"sha": "783f96d9b9e81f50506a5f4b5a950abb1316b950", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 140, "deletions": 140, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -642,119 +642,119 @@ pub mod linear {\n         #[test]\n         pub fn test_insert() {\n             let mut m = LinearMap::new();\n-            assert m.insert(1, 2);\n-            assert m.insert(2, 4);\n-            assert *m.get(&1) == 2;\n-            assert *m.get(&2) == 4;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(2, 4));\n+            fail_unless!(*m.get(&1) == 2);\n+            fail_unless!(*m.get(&2) == 4);\n         }\n \n         #[test]\n         pub fn test_insert_overwrite() {\n             let mut m = LinearMap::new();\n-            assert m.insert(1, 2);\n-            assert *m.get(&1) == 2;\n-            assert !m.insert(1, 3);\n-            assert *m.get(&1) == 3;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(*m.get(&1) == 2);\n+            fail_unless!(!m.insert(1, 3));\n+            fail_unless!(*m.get(&1) == 3);\n         }\n \n         #[test]\n         pub fn test_insert_conflicts() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            assert m.insert(1, 2);\n-            assert m.insert(5, 3);\n-            assert m.insert(9, 4);\n-            assert *m.get(&9) == 4;\n-            assert *m.get(&5) == 3;\n-            assert *m.get(&1) == 2;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(5, 3));\n+            fail_unless!(m.insert(9, 4));\n+            fail_unless!(*m.get(&9) == 4);\n+            fail_unless!(*m.get(&5) == 3);\n+            fail_unless!(*m.get(&1) == 2);\n         }\n \n         #[test]\n         pub fn test_conflict_remove() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            assert m.insert(1, 2);\n-            assert m.insert(5, 3);\n-            assert m.insert(9, 4);\n-            assert m.remove(&1);\n-            assert *m.get(&9) == 4;\n-            assert *m.get(&5) == 3;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(5, 3));\n+            fail_unless!(m.insert(9, 4));\n+            fail_unless!(m.remove(&1));\n+            fail_unless!(*m.get(&9) == 4);\n+            fail_unless!(*m.get(&5) == 3);\n         }\n \n         #[test]\n         pub fn test_is_empty() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            assert m.insert(1, 2);\n-            assert !m.is_empty();\n-            assert m.remove(&1);\n-            assert m.is_empty();\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(!m.is_empty());\n+            fail_unless!(m.remove(&1));\n+            fail_unless!(m.is_empty());\n         }\n \n         #[test]\n         pub fn test_pop() {\n             let mut m = LinearMap::new();\n             m.insert(1, 2);\n-            assert m.pop(&1) == Some(2);\n-            assert m.pop(&1) == None;\n+            fail_unless!(m.pop(&1) == Some(2));\n+            fail_unless!(m.pop(&1) == None);\n         }\n \n         #[test]\n         pub fn test_swap() {\n             let mut m = LinearMap::new();\n-            assert m.swap(1, 2) == None;\n-            assert m.swap(1, 3) == Some(2);\n-            assert m.swap(1, 4) == Some(3);\n+            fail_unless!(m.swap(1, 2) == None);\n+            fail_unless!(m.swap(1, 3) == Some(2));\n+            fail_unless!(m.swap(1, 4) == Some(3));\n         }\n \n         #[test]\n         pub fn test_find_or_insert() {\n             let mut m = LinearMap::new::<int, int>();\n-            assert m.find_or_insert(1, 2) == &2;\n-            assert m.find_or_insert(1, 3) == &2;\n+            fail_unless!(m.find_or_insert(1, 2) == &2);\n+            fail_unless!(m.find_or_insert(1, 3) == &2);\n         }\n \n         #[test]\n         pub fn test_find_or_insert_with() {\n             let mut m = LinearMap::new::<int, int>();\n-            assert m.find_or_insert_with(1, |_| 2) == &2;\n-            assert m.find_or_insert_with(1, |_| 3) == &2;\n+            fail_unless!(m.find_or_insert_with(1, |_| 2) == &2);\n+            fail_unless!(m.find_or_insert_with(1, |_| 3) == &2);\n         }\n \n         #[test]\n         pub fn test_consume() {\n             let mut m = LinearMap::new();\n-            assert m.insert(1, 2);\n-            assert m.insert(2, 3);\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(2, 3));\n             let mut m2 = LinearMap::new();\n             do m.consume |k, v| {\n                 m2.insert(k, v);\n             }\n-            assert m.len() == 0;\n-            assert m2.len() == 2;\n-            assert m2.get(&1) == &2;\n-            assert m2.get(&2) == &3;\n+            fail_unless!(m.len() == 0);\n+            fail_unless!(m2.len() == 2);\n+            fail_unless!(m2.get(&1) == &2);\n+            fail_unless!(m2.get(&2) == &3);\n         }\n \n         #[test]\n         pub fn test_iterate() {\n             let mut m = linear::linear_map_with_capacity(4);\n             for uint::range(0, 32) |i| {\n-                assert m.insert(i, i*2);\n+                fail_unless!(m.insert(i, i*2));\n             }\n             let mut observed = 0;\n             for m.each |&(k, v)| {\n-                assert *v == *k * 2;\n+                fail_unless!(*v == *k * 2);\n                 observed |= (1 << *k);\n             }\n-            assert observed == 0xFFFF_FFFF;\n+            fail_unless!(observed == 0xFFFF_FFFF);\n         }\n \n         #[test]\n         pub fn test_find() {\n             let mut m = LinearMap::new();\n-            assert m.find(&1).is_none();\n+            fail_unless!(m.find(&1).is_none());\n             m.insert(1, 2);\n             match m.find(&1) {\n                 None => fail!(),\n-                Some(v) => assert *v == 2\n+                Some(v) => fail_unless!(*v == 2)\n             }\n         }\n \n@@ -769,19 +769,19 @@ pub mod linear {\n             m2.insert(1, 2);\n             m2.insert(2, 3);\n \n-            assert m1 != m2;\n+            fail_unless!(m1 != m2);\n \n             m2.insert(3, 4);\n \n-            assert m1 == m2;\n+            fail_unless!(m1 == m2);\n         }\n \n         #[test]\n         pub fn test_expand() {\n             let mut m = LinearMap::new();\n \n-            assert m.len() == 0;\n-            assert m.is_empty();\n+            fail_unless!(m.len() == 0);\n+            fail_unless!(m.is_empty());\n \n             let mut i = 0u;\n             let old_resize_at = m.resize_at;\n@@ -790,8 +790,8 @@ pub mod linear {\n                 i += 1;\n             }\n \n-            assert m.len() == i;\n-            assert !m.is_empty();\n+            fail_unless!(m.len() == i);\n+            fail_unless!(!m.is_empty());\n         }\n     }\n \n@@ -805,160 +805,160 @@ pub mod linear {\n         fn test_disjoint() {\n             let mut xs = linear::LinearSet::new();\n             let mut ys = linear::LinearSet::new();\n-            assert xs.is_disjoint(&ys);\n-            assert ys.is_disjoint(&xs);\n-            assert xs.insert(5);\n-            assert ys.insert(11);\n-            assert xs.is_disjoint(&ys);\n-            assert ys.is_disjoint(&xs);\n-            assert xs.insert(7);\n-            assert xs.insert(19);\n-            assert xs.insert(4);\n-            assert ys.insert(2);\n-            assert ys.insert(-11);\n-            assert xs.is_disjoint(&ys);\n-            assert ys.is_disjoint(&xs);\n-            assert ys.insert(7);\n-            assert !xs.is_disjoint(&ys);\n-            assert !ys.is_disjoint(&xs);\n+            fail_unless!(xs.is_disjoint(&ys));\n+            fail_unless!(ys.is_disjoint(&xs));\n+            fail_unless!(xs.insert(5));\n+            fail_unless!(ys.insert(11));\n+            fail_unless!(xs.is_disjoint(&ys));\n+            fail_unless!(ys.is_disjoint(&xs));\n+            fail_unless!(xs.insert(7));\n+            fail_unless!(xs.insert(19));\n+            fail_unless!(xs.insert(4));\n+            fail_unless!(ys.insert(2));\n+            fail_unless!(ys.insert(-11));\n+            fail_unless!(xs.is_disjoint(&ys));\n+            fail_unless!(ys.is_disjoint(&xs));\n+            fail_unless!(ys.insert(7));\n+            fail_unless!(!xs.is_disjoint(&ys));\n+            fail_unless!(!ys.is_disjoint(&xs));\n         }\n \n         #[test]\n         fn test_subset_and_superset() {\n             let mut a = linear::LinearSet::new();\n-            assert a.insert(0);\n-            assert a.insert(5);\n-            assert a.insert(11);\n-            assert a.insert(7);\n+            fail_unless!(a.insert(0));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(11));\n+            fail_unless!(a.insert(7));\n \n             let mut b = linear::LinearSet::new();\n-            assert b.insert(0);\n-            assert b.insert(7);\n-            assert b.insert(19);\n-            assert b.insert(250);\n-            assert b.insert(11);\n-            assert b.insert(200);\n+            fail_unless!(b.insert(0));\n+            fail_unless!(b.insert(7));\n+            fail_unless!(b.insert(19));\n+            fail_unless!(b.insert(250));\n+            fail_unless!(b.insert(11));\n+            fail_unless!(b.insert(200));\n \n-            assert !a.is_subset(&b);\n-            assert !a.is_superset(&b);\n-            assert !b.is_subset(&a);\n-            assert !b.is_superset(&a);\n+            fail_unless!(!a.is_subset(&b));\n+            fail_unless!(!a.is_superset(&b));\n+            fail_unless!(!b.is_subset(&a));\n+            fail_unless!(!b.is_superset(&a));\n \n-            assert b.insert(5);\n+            fail_unless!(b.insert(5));\n \n-            assert a.is_subset(&b);\n-            assert !a.is_superset(&b);\n-            assert !b.is_subset(&a);\n-            assert b.is_superset(&a);\n+            fail_unless!(a.is_subset(&b));\n+            fail_unless!(!a.is_superset(&b));\n+            fail_unless!(!b.is_subset(&a));\n+            fail_unless!(b.is_superset(&a));\n         }\n \n         #[test]\n         fn test_intersection() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(11);\n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(77);\n-            assert a.insert(103);\n-            assert a.insert(5);\n-            assert a.insert(-5);\n-\n-            assert b.insert(2);\n-            assert b.insert(11);\n-            assert b.insert(77);\n-            assert b.insert(-9);\n-            assert b.insert(-42);\n-            assert b.insert(5);\n-            assert b.insert(3);\n+            fail_unless!(a.insert(11));\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(77));\n+            fail_unless!(a.insert(103));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(-5));\n+\n+            fail_unless!(b.insert(2));\n+            fail_unless!(b.insert(11));\n+            fail_unless!(b.insert(77));\n+            fail_unless!(b.insert(-9));\n+            fail_unless!(b.insert(-42));\n+            fail_unless!(b.insert(5));\n+            fail_unless!(b.insert(3));\n \n             let mut i = 0;\n             let expected = [3, 5, 11, 77];\n             for a.intersection(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n \n         #[test]\n         fn test_difference() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(5);\n-            assert a.insert(9);\n-            assert a.insert(11);\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(9));\n+            fail_unless!(a.insert(11));\n \n-            assert b.insert(3);\n-            assert b.insert(9);\n+            fail_unless!(b.insert(3));\n+            fail_unless!(b.insert(9));\n \n             let mut i = 0;\n             let expected = [1, 5, 11];\n             for a.difference(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n \n         #[test]\n         fn test_symmetric_difference() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(5);\n-            assert a.insert(9);\n-            assert a.insert(11);\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(9));\n+            fail_unless!(a.insert(11));\n \n-            assert b.insert(-2);\n-            assert b.insert(3);\n-            assert b.insert(9);\n-            assert b.insert(14);\n-            assert b.insert(22);\n+            fail_unless!(b.insert(-2));\n+            fail_unless!(b.insert(3));\n+            fail_unless!(b.insert(9));\n+            fail_unless!(b.insert(14));\n+            fail_unless!(b.insert(22));\n \n             let mut i = 0;\n             let expected = [-2, 1, 5, 11, 14, 22];\n             for a.symmetric_difference(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n \n         #[test]\n         fn test_union() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(5);\n-            assert a.insert(9);\n-            assert a.insert(11);\n-            assert a.insert(16);\n-            assert a.insert(19);\n-            assert a.insert(24);\n-\n-            assert b.insert(-2);\n-            assert b.insert(1);\n-            assert b.insert(5);\n-            assert b.insert(9);\n-            assert b.insert(13);\n-            assert b.insert(19);\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(9));\n+            fail_unless!(a.insert(11));\n+            fail_unless!(a.insert(16));\n+            fail_unless!(a.insert(19));\n+            fail_unless!(a.insert(24));\n+\n+            fail_unless!(b.insert(-2));\n+            fail_unless!(b.insert(1));\n+            fail_unless!(b.insert(5));\n+            fail_unless!(b.insert(9));\n+            fail_unless!(b.insert(13));\n+            fail_unless!(b.insert(19));\n \n             let mut i = 0;\n             let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n             for a.union(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n     }\n }"}, {"sha": "cc40b90d61a348adfd012efd0b630a87f89020f7", "filename": "src/libcore/io.rs", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -32,11 +32,16 @@ use vec;\n #[allow(non_camel_case_types)] // not sure what to do about this\n pub type fd_t = c_int;\n \n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    unsafe fn rust_get_stdin() -> *libc::FILE;\n-    unsafe fn rust_get_stdout() -> *libc::FILE;\n-    unsafe fn rust_get_stderr() -> *libc::FILE;\n+pub mod rustrt {\n+    use libc;\n+\n+    #[abi = \"cdecl\"]\n+    #[link_name = \"rustrt\"]\n+    pub extern {\n+        unsafe fn rust_get_stdin() -> *libc::FILE;\n+        unsafe fn rust_get_stdout() -> *libc::FILE;\n+        unsafe fn rust_get_stderr() -> *libc::FILE;\n+    }\n }\n \n // Reading\n@@ -242,7 +247,7 @@ impl<T:Reader> ReaderUtil for T {\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n                 i += 1;\n-                assert (w > 0);\n+                fail_unless!((w > 0));\n                 if w == 1 {\n                     chars.push(b0 as char);\n                     loop;\n@@ -255,8 +260,8 @@ impl<T:Reader> ReaderUtil for T {\n                 while i < end {\n                     let next = bytes[i] as int;\n                     i += 1;\n-                    assert (next > -1);\n-                    assert (next & 192 == 128);\n+                    fail_unless!((next > -1));\n+                    fail_unless!((next & 192 == 128));\n                     val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n@@ -297,7 +302,7 @@ impl<T:Reader> ReaderUtil for T {\n         if vec::len(c) == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        assert(vec::len(c) == 1);\n+        fail_unless!((vec::len(c) == 1));\n         return c[0];\n     }\n \n@@ -332,7 +337,7 @@ impl<T:Reader> ReaderUtil for T {\n     // FIXME int reading methods need to deal with eof - issue #2004\n \n     fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n-        assert nbytes > 0 && nbytes <= 8;\n+        fail_unless!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64, pos = 0, i = nbytes;\n         while i > 0 {\n@@ -348,7 +353,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n-        assert nbytes > 0 && nbytes <= 8;\n+        fail_unless!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64, i = nbytes;\n         while i > 0 {\n@@ -478,7 +483,7 @@ impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n             do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n-                assert buf_len >= len;\n+                fail_unless!(buf_len >= len);\n \n                 let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n                                         len as size_t, *self);\n@@ -499,9 +504,9 @@ impl Reader for *libc::FILE {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         unsafe {\n-            assert libc::fseek(*self,\n-                               offset as c_long,\n-                               convert_whence(whence)) == 0 as c_int;\n+            fail_unless!(libc::fseek(*self,\n+                                     offset as c_long,\n+                                     convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n@@ -687,9 +692,9 @@ impl Writer for *libc::FILE {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         unsafe {\n-            assert libc::fseek(*self,\n-                               offset as c_long,\n-                               convert_whence(whence)) == 0 as c_int;\n+            fail_unless!(libc::fseek(*self,\n+                                     offset as c_long,\n+                                     convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n@@ -816,7 +821,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n \n pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n                           f: fn(v: &[u8]) -> T) -> T {\n-    assert size <= 8u;\n+    fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n       2u => f(&[n as u8,\n@@ -848,7 +853,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n \n pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n                            f: fn(v: &[u8]) -> T) -> T {\n-    assert size <= 8u;\n+    fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n       2u => f(&[(n >> 8) as u8,\n@@ -881,7 +886,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n pub fn u64_from_be_bytes(data: &[const u8],\n                          start: uint, size: uint) -> u64 {\n     let mut sz = size;\n-    assert (sz <= 8u);\n+    fail_unless!((sz <= 8u));\n     let mut val = 0_u64;\n     let mut pos = start;\n     while sz > 0u {\n@@ -1158,7 +1163,7 @@ pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n         // Make sure the vector has a trailing null and is proper utf8.\n         v.push(0);\n     }\n-    assert str::is_utf8(v);\n+    fail_unless!(str::is_utf8(v));\n \n     unsafe { ::cast::transmute(v) }\n }\n@@ -1230,7 +1235,7 @@ pub mod fsync {\n             None => (),\n             Some(level) => {\n               // fail hard if not succesful\n-              assert((self.arg.fsync_fn)(self.arg.val, level) != -1);\n+              fail_unless!(((self.arg.fsync_fn)(self.arg.val, level) != -1));\n             }\n           }\n         }\n@@ -1315,22 +1320,22 @@ mod tests {\n         let inp: io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         log(debug, copy frood2);\n-        assert frood == frood2;\n+        fail_unless!(frood == frood2);\n     }\n \n     #[test]\n     fn test_readchars_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : ~[char] = inp.read_chars(128);\n-            assert(vec::len(res) == 0);\n+            fail_unless!((vec::len(res) == 0));\n         }\n     }\n \n     #[test]\n     fn test_read_line_utf8() {\n         do io::with_str_reader(~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n             let line = inp.read_line();\n-            assert line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n+            fail_unless!(line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n         }\n     }\n \n@@ -1347,10 +1352,10 @@ mod tests {\n             do io::with_str_reader(s) |inp| {\n                 let res : ~[char] = inp.read_chars(len);\n                 if (len <= vec::len(ivals)) {\n-                    assert(vec::len(res) == len);\n+                    fail_unless!((vec::len(res) == len));\n                 }\n-                assert(vec::slice(ivals, 0u, vec::len(res)) ==\n-                       vec::map(res, |x| *x as int));\n+                fail_unless!(vec::slice(ivals, 0u, vec::len(res)) ==\n+                             vec::map(res, |x| *x as int));\n             }\n         }\n         let mut i = 0;\n@@ -1366,23 +1371,23 @@ mod tests {\n     fn test_readchar() {\n         do io::with_str_reader(~\"\u751f\") |inp| {\n             let res : char = inp.read_char();\n-            assert(res as int == 29983);\n+            fail_unless!((res as int == 29983));\n         }\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : char = inp.read_char();\n-            assert(res as int == -1);\n+            fail_unless!((res as int == -1));\n         }\n     }\n \n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n           result::Err(copy e) => {\n-            assert e == ~\"error opening not a file\";\n+            fail_unless!(e == ~\"error opening not a file\");\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1423,7 +1428,7 @@ mod tests {\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), ~[]) {\n           result::Err(copy e) => {\n-            assert str::starts_with(e, \"error opening\");\n+            fail_unless!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1433,7 +1438,7 @@ mod tests {\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n           result::Err(copy e) => {\n-            assert str::starts_with(e, \"error opening\");\n+            fail_unless!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1443,17 +1448,17 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]);\n+        fail_unless!(wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]));\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert wr.bytes.borrow(|bytes| bytes ==\n-            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        fail_unless!(wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]));\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert wr.bytes.borrow(|bytes| bytes ==\n-            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        fail_unless!(wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]));\n     }\n \n     #[test]\n@@ -1473,7 +1478,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                assert file.read_le_u64() == *i;\n+                fail_unless!(file.read_le_u64() == *i);\n             }\n         }\n     }\n@@ -1495,7 +1500,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                assert file.read_be_u64() == *i;\n+                fail_unless!(file.read_be_u64() == *i);\n             }\n         }\n     }\n@@ -1519,7 +1524,7 @@ mod tests {\n             for ints.each |i| {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n-                assert file.read_be_int_n(4) == *i as i64;\n+                fail_unless!(file.read_be_int_n(4) == *i as i64);\n             }\n         }\n     }\n@@ -1538,7 +1543,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             let f = file.read_be_f32();\n-            assert f == 8.1250;\n+            fail_unless!(f == 8.1250);\n         }\n     }\n \n@@ -1555,8 +1560,8 @@ mod tests {\n \n         {\n             let file = io::file_reader(&path).get();\n-            assert file.read_be_f32() == 8.1250;\n-            assert file.read_le_f32() == 8.1250;\n+            fail_unless!(file.read_be_f32() == 8.1250);\n+            fail_unless!(file.read_le_f32() == 8.1250);\n         }\n     }\n }"}, {"sha": "245c1db2bb4b8c5eddf4ae93911480a7bae9e2e5", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -28,7 +28,7 @@ mod inst {\n         let mut link = self.peek_n();\n         while option::is_some(&link) {\n             let nobe = option::get(link);\n-            assert nobe.linked;\n+            fail_unless!(nobe.linked);\n \n             {\n                 let frozen_nobe = &*nobe;"}, {"sha": "b59824969bb85d144e0604b16893086cc39b92e7", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 446, "deletions": 363, "changes": 809, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1006,138 +1006,160 @@ pub mod funcs {\n     // or anything. The same is not true of POSIX.\n \n     pub mod c95 {\n-        use libc::types::common::c95::{FILE, c_void, fpos_t};\n-        use libc::types::os::arch::c95::{c_char, c_double, c_int, c_long};\n-        use libc::types::os::arch::c95::{c_uint, c_ulong, c_void, size_t};\n-\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod ctype {\n-            unsafe fn isalnum(c: c_int) -> c_int;\n-            unsafe fn isalpha(c: c_int) -> c_int;\n-            unsafe fn iscntrl(c: c_int) -> c_int;\n-            unsafe fn isdigit(c: c_int) -> c_int;\n-            unsafe fn isgraph(c: c_int) -> c_int;\n-            unsafe fn islower(c: c_int) -> c_int;\n-            unsafe fn isprint(c: c_int) -> c_int;\n-            unsafe fn ispunct(c: c_int) -> c_int;\n-            unsafe fn isspace(c: c_int) -> c_int;\n-            unsafe fn isupper(c: c_int) -> c_int;\n-            unsafe fn isxdigit(c: c_int) -> c_int;\n-            unsafe fn tolower(c: c_char) -> c_char;\n-            unsafe fn toupper(c: c_char) -> c_char;\n+        pub mod ctype {\n+            use libc::types::os::arch::c95::{c_char, c_int};\n+\n+            pub extern {\n+                unsafe fn isalnum(c: c_int) -> c_int;\n+                unsafe fn isalpha(c: c_int) -> c_int;\n+                unsafe fn iscntrl(c: c_int) -> c_int;\n+                unsafe fn isdigit(c: c_int) -> c_int;\n+                unsafe fn isgraph(c: c_int) -> c_int;\n+                unsafe fn islower(c: c_int) -> c_int;\n+                unsafe fn isprint(c: c_int) -> c_int;\n+                unsafe fn ispunct(c: c_int) -> c_int;\n+                unsafe fn isspace(c: c_int) -> c_int;\n+                unsafe fn isupper(c: c_int) -> c_int;\n+                unsafe fn isxdigit(c: c_int) -> c_int;\n+                unsafe fn tolower(c: c_char) -> c_char;\n+                unsafe fn toupper(c: c_char) -> c_char;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod stdio {\n-            unsafe fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n-            unsafe fn freopen(filename: *c_char, mode: *c_char,\n-                       file: *FILE) -> *FILE;\n-            unsafe fn fflush(file: *FILE) -> c_int;\n-            unsafe fn fclose(file: *FILE) -> c_int;\n-            unsafe fn remove(filename: *c_char) -> c_int;\n-            unsafe fn rename(oldname: *c_char, newname: *c_char) -> c_int;\n-            unsafe fn tmpfile() -> *FILE;\n-            unsafe fn setvbuf(stream: *FILE, buffer: *c_char,\n-                       mode: c_int, size: size_t) -> c_int;\n-            unsafe fn setbuf(stream: *FILE, buf: *c_char);\n-            // Omitted: printf and scanf variants.\n-            unsafe fn fgetc(stream: *FILE) -> c_int;\n-            unsafe fn fgets(buf: *mut c_char, n: c_int,\n-                     stream: *FILE) -> *c_char;\n-            unsafe fn fputc(c: c_int, stream: *FILE) -> c_int;\n-            unsafe fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n-            // Omitted: getc, getchar (might be macros).\n-\n-            // Omitted: gets, so ridiculously unsafe that it should not\n-            // survive.\n-\n-            // Omitted: putc, putchar (might be macros).\n-            unsafe fn puts(s: *c_char) -> c_int;\n-            unsafe fn ungetc(c: c_int, stream: *FILE) -> c_int;\n-            unsafe fn fread(ptr: *mut c_void, size: size_t,\n-                     nobj: size_t, stream: *FILE) -> size_t;\n-            unsafe fn fwrite(ptr: *c_void, size: size_t,\n-                      nobj: size_t, stream: *FILE) -> size_t;\n-            unsafe fn fseek(stream: *FILE, offset: c_long,\n-                     whence: c_int) -> c_int;\n-            unsafe fn ftell(stream: *FILE) -> c_long;\n-            unsafe fn rewind(stream: *FILE);\n-            unsafe fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-            unsafe fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-            unsafe fn feof(stream: *FILE) -> c_int;\n-            unsafe fn ferror(stream: *FILE) -> c_int;\n-            unsafe fn perror(s: *c_char);\n+        pub mod stdio {\n+            use libc::types::common::c95::{FILE, c_void, fpos_t};\n+            use libc::types::os::arch::c95::{c_char, c_int, c_long, size_t};\n+\n+            pub extern {\n+                unsafe fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n+                unsafe fn freopen(filename: *c_char, mode: *c_char,\n+                           file: *FILE) -> *FILE;\n+                unsafe fn fflush(file: *FILE) -> c_int;\n+                unsafe fn fclose(file: *FILE) -> c_int;\n+                unsafe fn remove(filename: *c_char) -> c_int;\n+                unsafe fn rename(oldname: *c_char, newname: *c_char) -> c_int;\n+                unsafe fn tmpfile() -> *FILE;\n+                unsafe fn setvbuf(stream: *FILE, buffer: *c_char,\n+                           mode: c_int, size: size_t) -> c_int;\n+                unsafe fn setbuf(stream: *FILE, buf: *c_char);\n+                // Omitted: printf and scanf variants.\n+                unsafe fn fgetc(stream: *FILE) -> c_int;\n+                unsafe fn fgets(buf: *mut c_char, n: c_int,\n+                         stream: *FILE) -> *c_char;\n+                unsafe fn fputc(c: c_int, stream: *FILE) -> c_int;\n+                unsafe fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n+                // Omitted: getc, getchar (might be macros).\n+\n+                // Omitted: gets, so ridiculously unsafe that it should not\n+                // survive.\n+\n+                // Omitted: putc, putchar (might be macros).\n+                unsafe fn puts(s: *c_char) -> c_int;\n+                unsafe fn ungetc(c: c_int, stream: *FILE) -> c_int;\n+                unsafe fn fread(ptr: *mut c_void, size: size_t,\n+                         nobj: size_t, stream: *FILE) -> size_t;\n+                unsafe fn fwrite(ptr: *c_void, size: size_t,\n+                          nobj: size_t, stream: *FILE) -> size_t;\n+                unsafe fn fseek(stream: *FILE, offset: c_long,\n+                         whence: c_int) -> c_int;\n+                unsafe fn ftell(stream: *FILE) -> c_long;\n+                unsafe fn rewind(stream: *FILE);\n+                unsafe fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n+                unsafe fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n+                unsafe fn feof(stream: *FILE) -> c_int;\n+                unsafe fn ferror(stream: *FILE) -> c_int;\n+                unsafe fn perror(s: *c_char);\n+            }\n         }\n \n-\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod stdlib {\n-            unsafe fn abs(i: c_int) -> c_int;\n-            unsafe fn labs(i: c_long) -> c_long;\n-            // Omitted: div, ldiv (return pub type incomplete).\n-            unsafe fn atof(s: *c_char) -> c_double;\n-            unsafe fn atoi(s: *c_char) -> c_int;\n-            unsafe fn strtod(s: *c_char, endp: **c_char) -> c_double;\n-            unsafe fn strtol(s: *c_char, endp: **c_char, base: c_int)\n-                          -> c_long;\n-            unsafe fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n-                           -> c_ulong;\n-            unsafe fn calloc(nobj: size_t, size: size_t) -> *c_void;\n-            unsafe fn malloc(size: size_t) -> *c_void;\n-            unsafe fn realloc(p: *c_void, size: size_t) -> *c_void;\n-            unsafe fn free(p: *c_void);\n-            unsafe fn abort() -> !;\n-            unsafe fn exit(status: c_int) -> !;\n-            // Omitted: atexit.\n-            unsafe fn system(s: *c_char) -> c_int;\n-            unsafe fn getenv(s: *c_char) -> *c_char;\n-            // Omitted: bsearch, qsort\n-            unsafe fn rand() -> c_int;\n-            unsafe fn srand(seed: c_uint);\n+        pub mod stdlib {\n+            use libc::types::common::c95::c_void;\n+            use libc::types::os::arch::c95::{c_char, c_double, c_int};\n+            use libc::types::os::arch::c95::{c_long, c_uint, c_ulong};\n+            use libc::types::os::arch::c95::{size_t};\n+\n+            pub extern {\n+                unsafe fn abs(i: c_int) -> c_int;\n+                unsafe fn labs(i: c_long) -> c_long;\n+                // Omitted: div, ldiv (return pub type incomplete).\n+                unsafe fn atof(s: *c_char) -> c_double;\n+                unsafe fn atoi(s: *c_char) -> c_int;\n+                unsafe fn strtod(s: *c_char, endp: **c_char) -> c_double;\n+                unsafe fn strtol(s: *c_char, endp: **c_char, base: c_int)\n+                              -> c_long;\n+                unsafe fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n+                               -> c_ulong;\n+                unsafe fn calloc(nobj: size_t, size: size_t) -> *c_void;\n+                unsafe fn malloc(size: size_t) -> *c_void;\n+                unsafe fn realloc(p: *c_void, size: size_t) -> *c_void;\n+                unsafe fn free(p: *c_void);\n+                unsafe fn abort() -> !;\n+                unsafe fn exit(status: c_int) -> !;\n+                // Omitted: atexit.\n+                unsafe fn system(s: *c_char) -> c_int;\n+                unsafe fn getenv(s: *c_char) -> *c_char;\n+                // Omitted: bsearch, qsort\n+                unsafe fn rand() -> c_int;\n+                unsafe fn srand(seed: c_uint);\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod string {\n-            unsafe fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n-            unsafe fn strncpy(dst: *c_char, src: *c_char, n: size_t)\n-                           -> *c_char;\n-            unsafe fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n-            unsafe fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;\n-            unsafe fn strcmp(cs: *c_char, ct: *c_char) -> c_int;\n-            unsafe fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;\n-            unsafe fn strcoll(cs: *c_char, ct: *c_char) -> c_int;\n-            unsafe fn strchr(cs: *c_char, c: c_int) -> *c_char;\n-            unsafe fn strrchr(cs: *c_char, c: c_int) -> *c_char;\n-            unsafe fn strspn(cs: *c_char, ct: *c_char) -> size_t;\n-            unsafe fn strcspn(cs: *c_char, ct: *c_char) -> size_t;\n-            unsafe fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;\n-            unsafe fn strstr(cs: *c_char, ct: *c_char) -> *c_char;\n-            unsafe fn strlen(cs: *c_char) -> size_t;\n-            unsafe fn strerror(n: c_int) -> *c_char;\n-            unsafe fn strtok(s: *c_char, t: *c_char) -> *c_char;\n-            unsafe fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;\n-\n-            // These are fine to execute on the Rust stack. They must be, in\n-            // fact, because LLVM generates calls to them!\n-            #[rust_stack]\n-            #[inline(always)]\n-            unsafe fn memcpy(s: *c_void, ct: *c_void, n: size_t) -> *c_void;\n-            #[rust_stack]\n-            #[inline(always)]\n-            unsafe fn memmove(s: *c_void, ct: *c_void, n: size_t) -> *c_void;\n-            #[rust_stack]\n-            #[inline(always)]\n-            unsafe fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;\n-            #[rust_stack]\n-            #[inline(always)]\n-            unsafe fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n-            #[rust_stack]\n-            #[inline(always)]\n-            unsafe fn memset(s: *c_void, c: c_int, n: size_t) -> *c_void;\n+        pub mod string {\n+            use libc::types::common::c95::c_void;\n+            use libc::types::os::arch::c95::{c_char, c_int, size_t};\n+\n+            pub extern {\n+                unsafe fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n+                unsafe fn strncpy(dst: *c_char, src: *c_char, n: size_t)\n+                               -> *c_char;\n+                unsafe fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n+                unsafe fn strncat(s: *c_char, ct: *c_char, n: size_t)\n+                               -> *c_char;\n+                unsafe fn strcmp(cs: *c_char, ct: *c_char) -> c_int;\n+                unsafe fn strncmp(cs: *c_char, ct: *c_char, n: size_t)\n+                               -> c_int;\n+                unsafe fn strcoll(cs: *c_char, ct: *c_char) -> c_int;\n+                unsafe fn strchr(cs: *c_char, c: c_int) -> *c_char;\n+                unsafe fn strrchr(cs: *c_char, c: c_int) -> *c_char;\n+                unsafe fn strspn(cs: *c_char, ct: *c_char) -> size_t;\n+                unsafe fn strcspn(cs: *c_char, ct: *c_char) -> size_t;\n+                unsafe fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;\n+                unsafe fn strstr(cs: *c_char, ct: *c_char) -> *c_char;\n+                unsafe fn strlen(cs: *c_char) -> size_t;\n+                unsafe fn strerror(n: c_int) -> *c_char;\n+                unsafe fn strtok(s: *c_char, t: *c_char) -> *c_char;\n+                unsafe fn strxfrm(s: *c_char, ct: *c_char, n: size_t)\n+                               -> size_t;\n+\n+                // These are fine to execute on the Rust stack. They must be,\n+                // in fact, because LLVM generates calls to them!\n+                #[rust_stack]\n+                #[inline(always)]\n+                unsafe fn memcpy(s: *c_void, ct: *c_void, n: size_t)\n+                              -> *c_void;\n+                #[rust_stack]\n+                #[inline(always)]\n+                unsafe fn memmove(s: *c_void, ct: *c_void, n: size_t)\n+                               -> *c_void;\n+                #[rust_stack]\n+                #[inline(always)]\n+                unsafe fn memcmp(cx: *c_void, ct: *c_void, n: size_t)\n+                              -> c_int;\n+                #[rust_stack]\n+                #[inline(always)]\n+                unsafe fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n+                #[rust_stack]\n+                #[inline(always)]\n+                unsafe fn memset(s: *c_void, c: c_int, n: size_t) -> *c_void;\n+            }\n         }\n     }\n \n@@ -1151,127 +1173,136 @@ pub mod funcs {\n     pub mod posix88 {\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod stat_ {\n+        pub mod stat_ {\n             use libc::types::os::common::posix01::stat;\n             use libc::types::os::arch::c95::{c_int, c_char};\n \n-            #[link_name = \"_chmod\"]\n-            unsafe fn chmod(path: *c_char, mode: c_int) -> c_int;\n+            pub extern {\n+                #[link_name = \"_chmod\"]\n+                unsafe fn chmod(path: *c_char, mode: c_int) -> c_int;\n \n-            #[link_name = \"_mkdir\"]\n-            unsafe fn mkdir(path: *c_char) -> c_int;\n+                #[link_name = \"_mkdir\"]\n+                unsafe fn mkdir(path: *c_char) -> c_int;\n \n-            #[link_name = \"_fstat64\"]\n-            unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n+                #[link_name = \"_fstat64\"]\n+                unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n-            #[link_name = \"_stat64\"]\n-            unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                #[link_name = \"_stat64\"]\n+                unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod stdio {\n+        pub mod stdio {\n             use libc::types::common::c95::FILE;\n             use libc::types::os::arch::c95::{c_int, c_char};\n \n-            #[link_name = \"_popen\"]\n-            unsafe fn popen(command: *c_char, mode: *c_char) -> *FILE;\n+            pub extern {\n+                #[link_name = \"_popen\"]\n+                unsafe fn popen(command: *c_char, mode: *c_char) -> *FILE;\n \n-            #[link_name = \"_pclose\"]\n-            unsafe fn pclose(stream: *FILE) -> c_int;\n+                #[link_name = \"_pclose\"]\n+                unsafe fn pclose(stream: *FILE) -> c_int;\n \n-            #[link_name = \"_fdopen\"]\n-            unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n+                #[link_name = \"_fdopen\"]\n+                unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n \n-            #[link_name = \"_fileno\"]\n-            unsafe fn fileno(stream: *FILE) -> c_int;\n+                #[link_name = \"_fileno\"]\n+                unsafe fn fileno(stream: *FILE) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod fcntl {\n-            use libc::types::os::arch::c95::{c_int, c_char};\n+        pub mod fcntl {\n+            pub extern {\n+                use libc::types::os::arch::c95::{c_int, c_char};\n \n-            #[link_name = \"_open\"]\n-            unsafe fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n+                #[link_name = \"_open\"]\n+                unsafe fn open(path: *c_char, oflag: c_int, mode: c_int)\n+                            -> c_int;\n \n-            #[link_name = \"_creat\"]\n-            unsafe fn creat(path: *c_char, mode: c_int) -> c_int;\n+                #[link_name = \"_creat\"]\n+                unsafe fn creat(path: *c_char, mode: c_int) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod dirent {\n+        pub mod dirent {\n             // Not supplied at all.\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod unistd {\n+        pub mod unistd {\n             use libc::types::common::c95::c_void;\n             use libc::types::os::arch::c95::{c_int, c_uint, c_char,\n                                              c_long, size_t};\n             use libc::types::os::arch::c99::intptr_t;\n \n-            #[link_name = \"_access\"]\n-            unsafe fn access(path: *c_char, amode: c_int) -> c_int;\n-\n-            #[link_name = \"_chdir\"]\n-            unsafe fn chdir(dir: *c_char) -> c_int;\n+            pub extern {\n+                #[link_name = \"_access\"]\n+                unsafe fn access(path: *c_char, amode: c_int) -> c_int;\n \n-            #[link_name = \"_close\"]\n-            unsafe fn close(fd: c_int) -> c_int;\n+                #[link_name = \"_chdir\"]\n+                unsafe fn chdir(dir: *c_char) -> c_int;\n \n-            #[link_name = \"_dup\"]\n-            unsafe fn dup(fd: c_int) -> c_int;\n+                #[link_name = \"_close\"]\n+                unsafe fn close(fd: c_int) -> c_int;\n \n-            #[link_name = \"_dup2\"]\n-            unsafe fn dup2(src: c_int, dst: c_int) -> c_int;\n+                #[link_name = \"_dup\"]\n+                unsafe fn dup(fd: c_int) -> c_int;\n \n-            #[link_name = \"_execv\"]\n-            unsafe fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n+                #[link_name = \"_dup2\"]\n+                unsafe fn dup2(src: c_int, dst: c_int) -> c_int;\n \n-            #[link_name = \"_execve\"]\n-            unsafe fn execve(prog: *c_char, argv: **c_char,\n-                      envp: **c_char) -> c_int;\n+                #[link_name = \"_execv\"]\n+                unsafe fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n \n-            #[link_name = \"_execvp\"]\n-            unsafe fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+                #[link_name = \"_execve\"]\n+                unsafe fn execve(prog: *c_char, argv: **c_char,\n+                          envp: **c_char) -> c_int;\n \n-            #[link_name = \"_execvpe\"]\n-            unsafe fn execvpe(c: *c_char, argv: **c_char,\n-                       envp: **c_char) -> c_int;\n+                #[link_name = \"_execvp\"]\n+                unsafe fn execvp(c: *c_char, argv: **c_char) -> c_int;\n \n-            #[link_name = \"_getcwd\"]\n-            unsafe fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n+                #[link_name = \"_execvpe\"]\n+                unsafe fn execvpe(c: *c_char, argv: **c_char,\n+                           envp: **c_char) -> c_int;\n \n-            #[link_name = \"_getpid\"]\n-            unsafe fn getpid() -> c_int;\n+                #[link_name = \"_getcwd\"]\n+                unsafe fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n \n-            #[link_name = \"_isatty\"]\n-            unsafe fn isatty(fd: c_int) -> c_int;\n+                #[link_name = \"_getpid\"]\n+                unsafe fn getpid() -> c_int;\n \n-            #[link_name = \"_lseek\"]\n-            unsafe fn lseek(fd: c_int, offset: c_long, origin: c_int)\n-                         -> c_long;\n+                #[link_name = \"_isatty\"]\n+                unsafe fn isatty(fd: c_int) -> c_int;\n \n-            #[link_name = \"_pipe\"]\n-            unsafe fn pipe(fds: *mut c_int, psize: c_uint,\n-                    textmode: c_int) -> c_int;\n+                #[link_name = \"_lseek\"]\n+                unsafe fn lseek(fd: c_int, offset: c_long, origin: c_int)\n+                             -> c_long;\n \n-            #[link_name = \"_read\"]\n-            unsafe fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n-                        -> c_int;\n+                #[link_name = \"_pipe\"]\n+                unsafe fn pipe(fds: *mut c_int, psize: c_uint,\n+                        textmode: c_int) -> c_int;\n \n-            #[link_name = \"_rmdir\"]\n-            unsafe fn rmdir(path: *c_char) -> c_int;\n+                #[link_name = \"_read\"]\n+                unsafe fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n+                            -> c_int;\n \n-            #[link_name = \"_unlink\"]\n-            unsafe fn unlink(c: *c_char) -> c_int;\n+                #[link_name = \"_rmdir\"]\n+                unsafe fn rmdir(path: *c_char) -> c_int;\n \n-            #[link_name = \"_write\"]\n-            unsafe fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n+                #[link_name = \"_unlink\"]\n+                unsafe fn unlink(c: *c_char) -> c_int;\n \n+                #[link_name = \"_write\"]\n+                unsafe fn write(fd: c_int, buf: *c_void, count: c_uint)\n+                             -> c_int;\n+            }\n         }\n     }\n \n@@ -1281,119 +1312,145 @@ pub mod funcs {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix88 {\n-        use libc::types::common::c95::{FILE, c_void};\n-        use libc::types::common::posix88::{DIR, dirent_t};\n-        use libc::types::os::arch::c95::{c_char, c_int, c_long, c_uint};\n-        use libc::types::os::arch::c95::{size_t};\n-        use libc::types::os::arch::posix01::stat;\n-        use libc::types::os::arch::posix88::{gid_t, mode_t, off_t, pid_t};\n-        use libc::types::os::arch::posix88::{ssize_t, uid_t};\n-\n-        #[nolink]\n-        #[abi = \"cdecl\"]\n-        pub extern mod stat_ {\n-            unsafe fn chmod(path: *c_char, mode: mode_t) -> c_int;\n-            unsafe fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n-\n-            #[cfg(target_os = \"linux\")]\n-            #[cfg(target_os = \"freebsd\")]\n-            #[cfg(target_os = \"android\")]\n-           unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n-\n-            #[cfg(target_os = \"macos\")]\n-            #[link_name = \"fstat64\"]\n-            unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n-\n-            unsafe fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n-            unsafe fn mkfifo(path: *c_char, mode: mode_t) -> c_int;\n-\n-            #[cfg(target_os = \"linux\")]\n-            #[cfg(target_os = \"freebsd\")]\n-            #[cfg(target_os = \"android\")]\n-            unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n-\n-            #[cfg(target_os = \"macos\")]\n-            #[link_name = \"stat64\"]\n-            unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+        pub mod stat_ {\n+            use libc::types::os::arch::c95::{c_char, c_int};\n+            use libc::types::os::arch::posix01::stat;\n+            use libc::types::os::arch::posix88::mode_t;\n+\n+            #[nolink]\n+            #[abi = \"cdecl\"]\n+            pub extern {\n+                unsafe fn chmod(path: *c_char, mode: mode_t) -> c_int;\n+                unsafe fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n+\n+                #[cfg(target_os = \"linux\")]\n+                #[cfg(target_os = \"freebsd\")]\n+                #[cfg(target_os = \"android\")]\n+               unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n+\n+                #[cfg(target_os = \"macos\")]\n+                #[link_name = \"fstat64\"]\n+                unsafe fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n+\n+                unsafe fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n+                unsafe fn mkfifo(path: *c_char, mode: mode_t) -> c_int;\n+\n+                #[cfg(target_os = \"linux\")]\n+                #[cfg(target_os = \"freebsd\")]\n+                #[cfg(target_os = \"android\")]\n+                unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+\n+                #[cfg(target_os = \"macos\")]\n+                #[link_name = \"stat64\"]\n+                unsafe fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod stdio {\n-            unsafe fn popen(command: *c_char, mode: *c_char) -> *FILE;\n-            unsafe fn pclose(stream: *FILE) -> c_int;\n-            unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n-            unsafe fn fileno(stream: *FILE) -> c_int;\n+        pub mod stdio {\n+            use libc::types::common::c95::FILE;\n+            use libc::types::os::arch::c95::{c_char, c_int};\n+\n+            pub extern {\n+                unsafe fn popen(command: *c_char, mode: *c_char) -> *FILE;\n+                unsafe fn pclose(stream: *FILE) -> c_int;\n+                unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n+                unsafe fn fileno(stream: *FILE) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod fcntl {\n-            unsafe fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n-            unsafe fn creat(path: *c_char, mode: mode_t) -> c_int;\n-            unsafe fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n+        pub mod fcntl {\n+            use libc::types::os::arch::c95::{c_char, c_int};\n+            use libc::types::os::arch::posix88::mode_t;\n+\n+            pub extern {\n+                unsafe fn open(path: *c_char, oflag: c_int, mode: c_int)\n+                            -> c_int;\n+                unsafe fn creat(path: *c_char, mode: mode_t) -> c_int;\n+                unsafe fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod dirent {\n-            unsafe fn opendir(dirname: *c_char) -> *DIR;\n-            unsafe fn closedir(dirp: *DIR) -> c_int;\n-            unsafe fn readdir(dirp: *DIR) -> *dirent_t;\n-            unsafe fn rewinddir(dirp: *DIR);\n-            unsafe fn seekdir(dirp: *DIR, loc: c_long);\n-            unsafe fn telldir(dirp: *DIR) -> c_long;\n+        pub mod dirent {\n+            use libc::types::common::posix88::{DIR, dirent_t};\n+            use libc::types::os::arch::c95::{c_char, c_int, c_long};\n+\n+            pub extern {\n+                unsafe fn opendir(dirname: *c_char) -> *DIR;\n+                unsafe fn closedir(dirp: *DIR) -> c_int;\n+                unsafe fn readdir(dirp: *DIR) -> *dirent_t;\n+                unsafe fn rewinddir(dirp: *DIR);\n+                unsafe fn seekdir(dirp: *DIR, loc: c_long);\n+                unsafe fn telldir(dirp: *DIR) -> c_long;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod unistd {\n-            unsafe fn access(path: *c_char, amode: c_int) -> c_int;\n-            unsafe fn alarm(seconds: c_uint) -> c_uint;\n-            unsafe fn chdir(dir: *c_char) -> c_int;\n-            unsafe fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;\n-            unsafe fn close(fd: c_int) -> c_int;\n-            unsafe fn dup(fd: c_int) -> c_int;\n-            unsafe fn dup2(src: c_int, dst: c_int) -> c_int;\n-            unsafe fn execv(prog: *c_char, argv: **c_char) -> c_int;\n-            unsafe fn execve(prog: *c_char, argv: **c_char, envp: **c_char)\n-                          -> c_int;\n-            unsafe fn execvp(c: *c_char, argv: **c_char) -> c_int;\n-            unsafe fn fork() -> pid_t;\n-            unsafe fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n-            unsafe fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n-            unsafe fn getegid() -> gid_t;\n-            unsafe fn geteuid() -> uid_t;\n-            unsafe fn getgid() -> gid_t ;\n-            unsafe fn getgroups(ngroups_max: c_int, groups: *mut gid_t)\n+        pub mod unistd {\n+            use libc::types::common::c95::c_void;\n+            use libc::types::os::arch::c95::{c_char, c_int, c_long, c_uint};\n+            use libc::types::os::arch::c95::{size_t};\n+            use libc::types::os::arch::posix88::{gid_t, off_t, pid_t};\n+            use libc::types::os::arch::posix88::{ssize_t, uid_t};\n+\n+            pub extern {\n+                unsafe fn access(path: *c_char, amode: c_int) -> c_int;\n+                unsafe fn alarm(seconds: c_uint) -> c_uint;\n+                unsafe fn chdir(dir: *c_char) -> c_int;\n+                unsafe fn chown(path: *c_char, uid: uid_t, gid: gid_t)\n                              -> c_int;\n-            unsafe fn getlogin() -> *c_char;\n-            unsafe fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)\n-                          -> c_int;\n-            unsafe fn getpgrp() -> pid_t;\n-            unsafe fn getpid() -> pid_t;\n-            unsafe fn getppid() -> pid_t;\n-            unsafe fn getuid() -> uid_t;\n-            unsafe fn isatty(fd: c_int) -> c_int;\n-            unsafe fn link(src: *c_char, dst: *c_char) -> c_int;\n-            unsafe fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;\n-            unsafe fn pathconf(path: *c_char, name: c_int) -> c_long;\n-            unsafe fn pause() -> c_int;\n-            unsafe fn pipe(fds: *mut c_int) -> c_int;\n-            unsafe fn read(fd: c_int, buf: *mut c_void,\n-                    count: size_t) -> ssize_t;\n-            unsafe fn rmdir(path: *c_char) -> c_int;\n-            unsafe fn setgid(gid: gid_t) -> c_int;\n-            unsafe fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;\n-            unsafe fn setsid() -> pid_t;\n-            unsafe fn setuid(uid: uid_t) -> c_int;\n-            unsafe fn sleep(secs: c_uint) -> c_uint;\n-            unsafe fn sysconf(name: c_int) -> c_long;\n-            unsafe fn tcgetpgrp(fd: c_int) -> pid_t;\n-            unsafe fn ttyname(fd: c_int) -> *c_char;\n-            unsafe fn unlink(c: *c_char) -> c_int;\n-            unsafe fn write(fd: c_int, buf: *c_void, count: size_t)\n-                         -> ssize_t;\n+                unsafe fn close(fd: c_int) -> c_int;\n+                unsafe fn dup(fd: c_int) -> c_int;\n+                unsafe fn dup2(src: c_int, dst: c_int) -> c_int;\n+                unsafe fn execv(prog: *c_char, argv: **c_char) -> c_int;\n+                unsafe fn execve(prog: *c_char,\n+                                 argv: **c_char,\n+                                 envp: **c_char)\n+                              -> c_int;\n+                unsafe fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+                unsafe fn fork() -> pid_t;\n+                unsafe fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n+                unsafe fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n+                unsafe fn getegid() -> gid_t;\n+                unsafe fn geteuid() -> uid_t;\n+                unsafe fn getgid() -> gid_t ;\n+                unsafe fn getgroups(ngroups_max: c_int, groups: *mut gid_t)\n+                                 -> c_int;\n+                unsafe fn getlogin() -> *c_char;\n+                unsafe fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)\n+                              -> c_int;\n+                unsafe fn getpgrp() -> pid_t;\n+                unsafe fn getpid() -> pid_t;\n+                unsafe fn getppid() -> pid_t;\n+                unsafe fn getuid() -> uid_t;\n+                unsafe fn isatty(fd: c_int) -> c_int;\n+                unsafe fn link(src: *c_char, dst: *c_char) -> c_int;\n+                unsafe fn lseek(fd: c_int, offset: off_t, whence: c_int)\n+                             -> off_t;\n+                unsafe fn pathconf(path: *c_char, name: c_int) -> c_long;\n+                unsafe fn pause() -> c_int;\n+                unsafe fn pipe(fds: *mut c_int) -> c_int;\n+                unsafe fn read(fd: c_int, buf: *mut c_void,\n+                        count: size_t) -> ssize_t;\n+                unsafe fn rmdir(path: *c_char) -> c_int;\n+                unsafe fn setgid(gid: gid_t) -> c_int;\n+                unsafe fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;\n+                unsafe fn setsid() -> pid_t;\n+                unsafe fn setuid(uid: uid_t) -> c_int;\n+                unsafe fn sleep(secs: c_uint) -> c_uint;\n+                unsafe fn sysconf(name: c_int) -> c_long;\n+                unsafe fn tcgetpgrp(fd: c_int) -> pid_t;\n+                unsafe fn ttyname(fd: c_int) -> *c_char;\n+                unsafe fn unlink(c: *c_char) -> c_int;\n+                unsafe fn write(fd: c_int, buf: *c_void, count: size_t)\n+                             -> ssize_t;\n+            }\n         }\n     }\n \n@@ -1402,59 +1459,70 @@ pub mod funcs {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix01 {\n-        use libc::types::os::arch::c95::{c_char, c_int, size_t};\n-        use libc::types::os::arch::posix01::stat;\n-        use libc::types::os::arch::posix88::{pid_t, ssize_t};\n-\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod stat_ {\n-            #[cfg(target_os = \"linux\")]\n-            #[cfg(target_os = \"freebsd\")]\n-            #[cfg(target_os = \"android\")]\n-            unsafe fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n-\n-            #[cfg(target_os = \"macos\")]\n-            #[link_name = \"lstat64\"]\n-            unsafe fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+        pub mod stat_ {\n+            use libc::types::os::arch::c95::{c_char, c_int};\n+            use libc::types::os::arch::posix01::stat;\n+\n+            pub extern {\n+                #[cfg(target_os = \"linux\")]\n+                #[cfg(target_os = \"freebsd\")]\n+                #[cfg(target_os = \"android\")]\n+                unsafe fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+\n+                #[cfg(target_os = \"macos\")]\n+                #[link_name = \"lstat64\"]\n+                unsafe fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod unistd {\n-            unsafe fn readlink(path: *c_char, buf: *mut c_char,\n-                        bufsz: size_t) -> ssize_t;\n+        pub mod unistd {\n+            use libc::types::os::arch::c95::{c_char, c_int, size_t};\n+            use libc::types::os::arch::posix88::{ssize_t};\n \n-            unsafe fn fsync(fd: c_int) -> c_int;\n+            pub extern {\n+                unsafe fn readlink(path: *c_char, buf: *mut c_char,\n+                            bufsz: size_t) -> ssize_t;\n \n-            #[cfg(target_os = \"linux\")]\n-            #[cfg(target_os = \"android\")]\n-            unsafe fn fdatasync(fd: c_int) -> c_int;\n+                unsafe fn fsync(fd: c_int) -> c_int;\n \n-            unsafe fn setenv(name: *c_char, val: *c_char,\n-                      overwrite: c_int) -> c_int;\n-            unsafe fn unsetenv(name: *c_char) -> c_int;\n-            unsafe fn putenv(string: *c_char) -> c_int;\n+                #[cfg(target_os = \"linux\")]\n+                #[cfg(target_os = \"android\")]\n+                unsafe fn fdatasync(fd: c_int) -> c_int;\n \n-            unsafe fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n+                unsafe fn setenv(name: *c_char, val: *c_char,\n+                          overwrite: c_int) -> c_int;\n+                unsafe fn unsetenv(name: *c_char) -> c_int;\n+                unsafe fn putenv(string: *c_char) -> c_int;\n+\n+                unsafe fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n+            }\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        pub extern mod wait {\n-            unsafe fn waitpid(pid: pid_t, status: *mut c_int,\n-                       options: c_int) -> pid_t;\n+        pub mod wait {\n+            use libc::types::os::arch::c95::{c_int};\n+            use libc::types::os::arch::posix88::{pid_t};\n+\n+            pub extern {\n+                unsafe fn waitpid(pid: pid_t,\n+                                  status: *mut c_int,\n+                                  options: c_int)\n+                               -> pid_t;\n+            }\n         }\n     }\n \n     #[cfg(target_os = \"win32\")]\n     pub mod posix01 {\n-        #[nolink]\n-        pub extern mod stat_ {\n+        pub mod stat_ {\n         }\n \n-        #[nolink]\n-        pub extern mod unistd {\n+        pub mod unistd {\n         }\n     }\n \n@@ -1465,30 +1533,30 @@ pub mod funcs {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix08 {\n-        #[nolink]\n-        pub extern mod unistd {\n+        pub mod unistd {\n         }\n     }\n \n \n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n-    #[nolink]\n-    #[abi = \"cdecl\"]\n-    pub extern mod bsd44 {\n-        use libc::types::common::c95::{c_void};\n-        use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n+    pub mod bsd44 {\n+        #[abi = \"cdecl\"]\n+        pub extern {\n+            use libc::types::common::c95::{c_void};\n+            use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n \n-        unsafe fn sysctl(name: *c_int, namelen: c_uint,\n-                  oldp: *mut c_void, oldlenp: *mut size_t,\n-                  newp: *c_void, newlen: size_t) -> c_int;\n+            unsafe fn sysctl(name: *c_int, namelen: c_uint,\n+                      oldp: *mut c_void, oldlenp: *mut size_t,\n+                      newp: *c_void, newlen: size_t) -> c_int;\n \n-        unsafe fn sysctlbyname(name: *c_char,\n-                        oldp: *mut c_void, oldlenp: *mut size_t,\n-                        newp: *c_void, newlen: size_t) -> c_int;\n+            unsafe fn sysctlbyname(name: *c_char,\n+                            oldp: *mut c_void, oldlenp: *mut size_t,\n+                            newp: *c_void, newlen: size_t) -> c_int;\n \n-        unsafe fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n-                           sizep: *mut size_t) -> c_int;\n+            unsafe fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n+                               sizep: *mut size_t) -> c_int;\n+        }\n     }\n \n \n@@ -1500,12 +1568,15 @@ pub mod funcs {\n \n     #[cfg(target_os = \"macos\")]\n     #[nolink]\n-    #[abi = \"cdecl\"]\n-    pub extern mod extra {\n+    pub mod extra {\n         use libc::types::os::arch::c95::{c_char, c_int};\n \n-        unsafe fn _NSGetExecutablePath(buf: *mut c_char,\n-                                bufsize: *mut u32) -> c_int;\n+        #[abi = \"cdecl\"]\n+        pub extern {\n+            unsafe fn _NSGetExecutablePath(buf: *mut c_char,\n+                                           bufsize: *mut u32)\n+                                        -> c_int;\n+        }\n     }\n \n     #[cfg(target_os = \"freebsd\")]\n@@ -1520,38 +1591,50 @@ pub mod funcs {\n \n     #[cfg(target_os = \"win32\")]\n     pub mod extra {\n-        use libc::types::os::arch::c95::c_int;\n-        use libc::types::os::arch::extra::{DWORD, HMODULE, LPCWSTR, LPWSTR};\n-        use libc::types::os::arch::extra::{BOOL, LPSECURITY_ATTRIBUTES};\n-\n-        #[abi = \"stdcall\"]\n-        pub extern mod kernel32 {\n-            unsafe fn GetEnvironmentVariableW(n: LPCWSTR,\n-                                       v: LPWSTR,\n-                                       nsize: DWORD) -> DWORD;\n-            unsafe fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n-\n-            unsafe fn GetModuleFileNameW(hModule: HMODULE,\n-                                  lpFilename: LPWSTR,\n-                                  nSize: DWORD) -> DWORD;\n-            unsafe fn CreateDirectoryW(lpPathName: LPCWSTR,\n-                                lpSecurityAttributes:\n-                                LPSECURITY_ATTRIBUTES) -> BOOL;\n-            unsafe fn CopyFileW(lpExistingFileName: LPCWSTR,\n-                         lpNewFileName: LPCWSTR,\n-                         bFailIfExists: BOOL) -> BOOL;\n-            unsafe fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n-            unsafe fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-            unsafe fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-\n-            unsafe fn GetLastError() -> DWORD;\n+\n+        pub mod kernel32 {\n+            use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n+            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR};\n+            use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES};\n+\n+            #[abi = \"stdcall\"]\n+            pub extern {\n+                unsafe fn GetEnvironmentVariableW(n: LPCWSTR,\n+                                                  v: LPWSTR,\n+                                                  nsize: DWORD)\n+                                               -> DWORD;\n+                unsafe fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR)\n+                                               -> BOOL;\n+\n+                unsafe fn GetModuleFileNameW(hModule: HMODULE,\n+                                             lpFilename: LPWSTR,\n+                                             nSize: DWORD)\n+                                          -> DWORD;\n+                unsafe fn CreateDirectoryW(lpPathName: LPCWSTR,\n+                                           lpSecurityAttributes:\n+                                           LPSECURITY_ATTRIBUTES)\n+                                        -> BOOL;\n+                unsafe fn CopyFileW(lpExistingFileName: LPCWSTR,\n+                                    lpNewFileName: LPCWSTR,\n+                                    bFailIfExists: BOOL)\n+                                 -> BOOL;\n+                unsafe fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n+                unsafe fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+                unsafe fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+\n+                unsafe fn GetLastError() -> DWORD;\n+            }\n         }\n \n-        #[abi = \"cdecl\"]\n-        #[nolink]\n-        pub extern mod msvcrt {\n-            #[link_name = \"_commit\"]\n-            unsafe fn commit(fd: c_int) -> c_int;\n+        pub mod msvcrt {\n+            use libc::types::os::arch::c95::c_int;\n+\n+            #[abi = \"cdecl\"]\n+            #[nolink]\n+            pub extern {\n+                #[link_name = \"_commit\"]\n+                unsafe fn commit(fd: c_int) -> c_int;\n+            }\n         }\n     }\n }"}, {"sha": "be6469abc92440ba11fc482731ca10487d3ed68f", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -12,13 +12,16 @@\n \n use libc;\n \n-#[nolink]\n-extern mod rustrt {\n-    unsafe fn rust_log_console_on();\n-    unsafe fn rust_log_console_off();\n-    unsafe fn rust_log_str(level: u32,\n-                           string: *libc::c_char,\n-                           size: libc::size_t);\n+pub mod rustrt {\n+    use libc;\n+\n+    pub extern {\n+        unsafe fn rust_log_console_on();\n+        unsafe fn rust_log_console_off();\n+        unsafe fn rust_log_str(level: u32,\n+                               string: *libc::c_char,\n+                               size: libc::size_t);\n+    }\n }\n \n /// Turns on logging to stdout globally"}, {"sha": "1bef895ea0b7286f865b85a41680eba5702a1772", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -72,8 +72,8 @@ impl<T:Ord> Ord for @const T {\n fn test() {\n     let x = @3;\n     let y = @3;\n-    assert (ptr_eq::<int>(x, x));\n-    assert (ptr_eq::<int>(y, y));\n-    assert (!ptr_eq::<int>(x, y));\n-    assert (!ptr_eq::<int>(y, x));\n+    fail_unless!((ptr_eq::<int>(x, x)));\n+    fail_unless!((ptr_eq::<int>(y, y)));\n+    fail_unless!((!ptr_eq::<int>(x, y)));\n+    fail_unless!((!ptr_eq::<int>(y, x)));\n }"}, {"sha": "875d378b6453f80084b91f205de87487877a0e27", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -38,7 +38,7 @@ pub fn Mut<T>(t: T) -> Mut<T> {\n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n-    assert (m.mode as uint) == (ReadOnly as uint);\n+    fail_unless!((m.mode as uint) == (ReadOnly as uint));\n     let Data {value: value, mode: _} = m;\n     value\n }\n@@ -105,9 +105,9 @@ pub fn test_const_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |p| {\n         do m.borrow_const |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n             *p += 1;\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }\n@@ -117,9 +117,9 @@ pub fn test_mut_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_mut |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n             *q += 1;\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }\n@@ -129,7 +129,7 @@ pub fn test_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_imm |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }\n@@ -139,7 +139,7 @@ pub fn test_const_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |p| {\n         do m.borrow_const |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }"}, {"sha": "342a02c836a7e7d5e3b863bcf21102c50fc6096b", "filename": "src/libcore/num/cmath.rs", "status": "modified", "additions": 142, "deletions": 128, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -17,146 +17,160 @@ use libc::c_double;\n // function names are almost identical to C's libmath, a few have been\n // renamed, grep for \"rename:\"\n \n-#[link_name = \"m\"]\n-#[abi = \"cdecl\"]\n-pub extern mod c_double_utils {\n+pub mod c_double_utils {\n+    use libc::{c_double, c_int};\n \n-    // Alpabetically sorted by link_name\n+    #[link_name = \"m\"]\n+    #[abi = \"cdecl\"]\n+    pub extern {\n+        // Alpabetically sorted by link_name\n \n-    unsafe fn acos(n: c_double) -> c_double;\n-    unsafe fn asin(n: c_double) -> c_double;\n-    unsafe fn atan(n: c_double) -> c_double;\n-    unsafe fn atan2(a: c_double, b: c_double) -> c_double;\n-    unsafe fn cbrt(n: c_double) -> c_double;\n-    unsafe fn ceil(n: c_double) -> c_double;\n-    unsafe fn copysign(x: c_double, y: c_double) -> c_double;\n-    unsafe fn cos(n: c_double) -> c_double;\n-    unsafe fn cosh(n: c_double) -> c_double;\n-    unsafe fn erf(n: c_double) -> c_double;\n-    unsafe fn erfc(n: c_double) -> c_double;\n-    unsafe fn exp(n: c_double) -> c_double;\n-    unsafe fn expm1(n: c_double) -> c_double;\n-    unsafe fn exp2(n: c_double) -> c_double;\n-    #[link_name=\"fabs\"] unsafe fn abs(n: c_double) -> c_double;\n-    // rename: for clarity and consistency with add/sub/mul/div\n-    #[link_name=\"fdim\"]\n-    unsafe fn abs_sub(a: c_double, b: c_double) -> c_double;\n-    unsafe fn floor(n: c_double) -> c_double;\n-    // rename: for clarity and consistency with add/sub/mul/div\n-    #[link_name=\"fma\"] unsafe fn mul_add(a: c_double, b: c_double,\n-                                       c: c_double) -> c_double;\n-    #[link_name=\"fmax\"] unsafe fn fmax(a: c_double, b: c_double) -> c_double;\n-    #[link_name=\"fmin\"] unsafe fn fmin(a: c_double, b: c_double) -> c_double;\n-    unsafe fn nextafter(x: c_double, y: c_double) -> c_double;\n-    unsafe fn frexp(n: c_double, value: &mut c_int) -> c_double;\n-    unsafe fn hypot(x: c_double, y: c_double) -> c_double;\n-    unsafe fn ldexp(x: c_double, n: c_int) -> c_double;\n-    #[cfg(unix)]\n-    #[link_name=\"lgamma_r\"] unsafe fn lgamma(n: c_double,\n-                                           sign: &mut c_int) -> c_double;\n-    #[cfg(windows)]\n-    #[link_name=\"__lgamma_r\"] unsafe fn lgamma(n: c_double,\n-                                             sign: &mut c_int) -> c_double;\n-    // renamed: log is a reserved keyword; ln seems more natural, too\n-    #[link_name=\"log\"] unsafe fn ln(n: c_double) -> c_double;\n-    // renamed: \"logb\" /often/ is confused for log2 by beginners\n-    #[link_name=\"logb\"] unsafe fn log_radix(n: c_double) -> c_double;\n-    // renamed: to be consitent with log as ln\n-    #[link_name=\"log1p\"] unsafe fn ln1p(n: c_double) -> c_double;\n-    unsafe fn log10(n: c_double) -> c_double;\n-    unsafe fn log2(n: c_double) -> c_double;\n-    #[link_name=\"ilogb\"] unsafe fn ilog_radix(n: c_double) -> c_int;\n-    unsafe fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n-    unsafe fn pow(n: c_double, e: c_double) -> c_double;\n-// FIXME (#1379): enable when rounding modes become available\n-//    unsafe fn rint(n: c_double) -> c_double;\n-    unsafe fn round(n: c_double) -> c_double;\n-    // rename: for consistency with logradix\n-    #[link_name=\"scalbn\"] unsafe fn ldexp_radix(n: c_double, i: c_int) ->\n-        c_double;\n-    unsafe fn sin(n: c_double) -> c_double;\n-    unsafe fn sinh(n: c_double) -> c_double;\n-    unsafe fn sqrt(n: c_double) -> c_double;\n-    unsafe fn tan(n: c_double) -> c_double;\n-    unsafe fn tanh(n: c_double) -> c_double;\n-    unsafe fn tgamma(n: c_double) -> c_double;\n-    unsafe fn trunc(n: c_double) -> c_double;\n+        unsafe fn acos(n: c_double) -> c_double;\n+        unsafe fn asin(n: c_double) -> c_double;\n+        unsafe fn atan(n: c_double) -> c_double;\n+        unsafe fn atan2(a: c_double, b: c_double) -> c_double;\n+        unsafe fn cbrt(n: c_double) -> c_double;\n+        unsafe fn ceil(n: c_double) -> c_double;\n+        unsafe fn copysign(x: c_double, y: c_double) -> c_double;\n+        unsafe fn cos(n: c_double) -> c_double;\n+        unsafe fn cosh(n: c_double) -> c_double;\n+        unsafe fn erf(n: c_double) -> c_double;\n+        unsafe fn erfc(n: c_double) -> c_double;\n+        unsafe fn exp(n: c_double) -> c_double;\n+        unsafe fn expm1(n: c_double) -> c_double;\n+        unsafe fn exp2(n: c_double) -> c_double;\n+        #[link_name=\"fabs\"] unsafe fn abs(n: c_double) -> c_double;\n+        // rename: for clarity and consistency with add/sub/mul/div\n+        #[link_name=\"fdim\"]\n+        unsafe fn abs_sub(a: c_double, b: c_double) -> c_double;\n+        unsafe fn floor(n: c_double) -> c_double;\n+        // rename: for clarity and consistency with add/sub/mul/div\n+        #[link_name=\"fma\"]\n+        unsafe fn mul_add(a: c_double, b: c_double, c: c_double) -> c_double;\n+        #[link_name=\"fmax\"]\n+        unsafe fn fmax(a: c_double, b: c_double) -> c_double;\n+        #[link_name=\"fmin\"]\n+        unsafe fn fmin(a: c_double, b: c_double) -> c_double;\n+        unsafe fn nextafter(x: c_double, y: c_double) -> c_double;\n+        unsafe fn frexp(n: c_double, value: &mut c_int) -> c_double;\n+        unsafe fn hypot(x: c_double, y: c_double) -> c_double;\n+        unsafe fn ldexp(x: c_double, n: c_int) -> c_double;\n+        #[cfg(unix)]\n+        #[link_name=\"lgamma_r\"]\n+        unsafe fn lgamma(n: c_double, sign: &mut c_int) -> c_double;\n+        #[cfg(windows)]\n+        #[link_name=\"__lgamma_r\"]\n+        unsafe fn lgamma(n: c_double, sign: &mut c_int) -> c_double;\n+        // renamed: log is a reserved keyword; ln seems more natural, too\n+        #[link_name=\"log\"] unsafe fn ln(n: c_double) -> c_double;\n+        // renamed: \"logb\" /often/ is confused for log2 by beginners\n+        #[link_name=\"logb\"] unsafe fn log_radix(n: c_double) -> c_double;\n+        // renamed: to be consitent with log as ln\n+        #[link_name=\"log1p\"] unsafe fn ln1p(n: c_double) -> c_double;\n+        unsafe fn log10(n: c_double) -> c_double;\n+        unsafe fn log2(n: c_double) -> c_double;\n+        #[link_name=\"ilogb\"] unsafe fn ilog_radix(n: c_double) -> c_int;\n+        unsafe fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n+        unsafe fn pow(n: c_double, e: c_double) -> c_double;\n+    // FIXME (#1379): enable when rounding modes become available\n+    //    unsafe fn rint(n: c_double) -> c_double;\n+        unsafe fn round(n: c_double) -> c_double;\n+        // rename: for consistency with logradix\n+        #[link_name=\"scalbn\"] unsafe fn ldexp_radix(n: c_double, i: c_int) ->\n+            c_double;\n+        unsafe fn sin(n: c_double) -> c_double;\n+        unsafe fn sinh(n: c_double) -> c_double;\n+        unsafe fn sqrt(n: c_double) -> c_double;\n+        unsafe fn tan(n: c_double) -> c_double;\n+        unsafe fn tanh(n: c_double) -> c_double;\n+        unsafe fn tgamma(n: c_double) -> c_double;\n+        unsafe fn trunc(n: c_double) -> c_double;\n \n-    // These are commonly only available for doubles\n+        // These are commonly only available for doubles\n \n-    unsafe fn j0(n: c_double) -> c_double;\n-    unsafe fn j1(n: c_double) -> c_double;\n-    unsafe fn jn(i: c_int, n: c_double) -> c_double;\n+        unsafe fn j0(n: c_double) -> c_double;\n+        unsafe fn j1(n: c_double) -> c_double;\n+        unsafe fn jn(i: c_int, n: c_double) -> c_double;\n \n-    unsafe fn y0(n: c_double) -> c_double;\n-    unsafe fn y1(n: c_double) -> c_double;\n-    unsafe fn yn(i: c_int, n: c_double) -> c_double;\n+        unsafe fn y0(n: c_double) -> c_double;\n+        unsafe fn y1(n: c_double) -> c_double;\n+        unsafe fn yn(i: c_int, n: c_double) -> c_double;\n+    }\n }\n \n-#[link_name = \"m\"]\n-#[abi = \"cdecl\"]\n-pub extern mod c_float_utils {\n+pub mod c_float_utils {\n+    use libc::{c_float, c_int};\n \n-    // Alpabetically sorted by link_name\n+    #[link_name = \"m\"]\n+    #[abi = \"cdecl\"]\n+    pub extern {\n+        // Alpabetically sorted by link_name\n \n-    #[link_name=\"acosf\"] unsafe fn acos(n: c_float) -> c_float;\n-    #[link_name=\"asinf\"] unsafe fn asin(n: c_float) -> c_float;\n-    #[link_name=\"atanf\"] unsafe fn atan(n: c_float) -> c_float;\n-    #[link_name=\"atan2f\"] unsafe fn atan2(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"cbrtf\"] unsafe fn cbrt(n: c_float) -> c_float;\n-    #[link_name=\"ceilf\"] unsafe fn ceil(n: c_float) -> c_float;\n-    #[link_name=\"copysignf\"] unsafe fn copysign(x: c_float,\n-                                              y: c_float) -> c_float;\n-    #[link_name=\"cosf\"] unsafe fn cos(n: c_float) -> c_float;\n-    #[link_name=\"coshf\"] unsafe fn cosh(n: c_float) -> c_float;\n-    #[link_name=\"erff\"] unsafe fn erf(n: c_float) -> c_float;\n-    #[link_name=\"erfcf\"] unsafe fn erfc(n: c_float) -> c_float;\n-    #[link_name=\"expf\"] unsafe fn exp(n: c_float) -> c_float;\n-    #[link_name=\"expm1f\"]unsafe fn expm1(n: c_float) -> c_float;\n-    #[link_name=\"exp2f\"] unsafe fn exp2(n: c_float) -> c_float;\n-    #[link_name=\"fabsf\"] unsafe fn abs(n: c_float) -> c_float;\n-    #[link_name=\"fdimf\"] unsafe fn abs_sub(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"floorf\"] unsafe fn floor(n: c_float) -> c_float;\n-    #[link_name=\"frexpf\"] unsafe fn frexp(n: c_float,\n-                                        value: &mut c_int) -> c_float;\n-    #[link_name=\"fmaf\"] unsafe fn mul_add(a: c_float,\n-                                        b: c_float, c: c_float) -> c_float;\n-    #[link_name=\"fmaxf\"] unsafe fn fmax(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"fminf\"] unsafe fn fmin(a: c_float, b: c_float) -> c_float;\n-    #[link_name=\"nextafterf\"] unsafe fn nextafter(x: c_float,\n-                                                y: c_float) -> c_float;\n-    #[link_name=\"hypotf\"] unsafe fn hypot(x: c_float, y: c_float) -> c_float;\n-    #[link_name=\"ldexpf\"] unsafe fn ldexp(x: c_float, n: c_int) -> c_float;\n+        #[link_name=\"acosf\"] unsafe fn acos(n: c_float) -> c_float;\n+        #[link_name=\"asinf\"] unsafe fn asin(n: c_float) -> c_float;\n+        #[link_name=\"atanf\"] unsafe fn atan(n: c_float) -> c_float;\n+        #[link_name=\"atan2f\"]\n+        unsafe fn atan2(a: c_float, b: c_float) -> c_float;\n+        #[link_name=\"cbrtf\"] unsafe fn cbrt(n: c_float) -> c_float;\n+        #[link_name=\"ceilf\"] unsafe fn ceil(n: c_float) -> c_float;\n+        #[link_name=\"copysignf\"] unsafe fn copysign(x: c_float,\n+                                                  y: c_float) -> c_float;\n+        #[link_name=\"cosf\"] unsafe fn cos(n: c_float) -> c_float;\n+        #[link_name=\"coshf\"] unsafe fn cosh(n: c_float) -> c_float;\n+        #[link_name=\"erff\"] unsafe fn erf(n: c_float) -> c_float;\n+        #[link_name=\"erfcf\"] unsafe fn erfc(n: c_float) -> c_float;\n+        #[link_name=\"expf\"] unsafe fn exp(n: c_float) -> c_float;\n+        #[link_name=\"expm1f\"]unsafe fn expm1(n: c_float) -> c_float;\n+        #[link_name=\"exp2f\"] unsafe fn exp2(n: c_float) -> c_float;\n+        #[link_name=\"fabsf\"] unsafe fn abs(n: c_float) -> c_float;\n+        #[link_name=\"fdimf\"]\n+        unsafe fn abs_sub(a: c_float, b: c_float) -> c_float;\n+        #[link_name=\"floorf\"] unsafe fn floor(n: c_float) -> c_float;\n+        #[link_name=\"frexpf\"] unsafe fn frexp(n: c_float,\n+                                            value: &mut c_int) -> c_float;\n+        #[link_name=\"fmaf\"]\n+        unsafe fn mul_add(a: c_float, b: c_float, c: c_float) -> c_float;\n+        #[link_name=\"fmaxf\"]\n+        unsafe fn fmax(a: c_float, b: c_float) -> c_float;\n+        #[link_name=\"fminf\"]\n+        unsafe fn fmin(a: c_float, b: c_float) -> c_float;\n+        #[link_name=\"nextafterf\"]\n+        unsafe fn nextafter(x: c_float, y: c_float) -> c_float;\n+        #[link_name=\"hypotf\"]\n+        unsafe fn hypot(x: c_float, y: c_float) -> c_float;\n+        #[link_name=\"ldexpf\"]\n+        unsafe fn ldexp(x: c_float, n: c_int) -> c_float;\n \n-    #[cfg(unix)]\n-    #[link_name=\"lgammaf_r\"] unsafe fn lgamma(n: c_float,\n-                                            sign: &mut c_int) -> c_float;\n+        #[cfg(unix)]\n+        #[link_name=\"lgammaf_r\"] unsafe fn lgamma(n: c_float,\n+                                                sign: &mut c_int) -> c_float;\n \n-    #[cfg(windows)]\n-    #[link_name=\"__lgammaf_r\"] unsafe fn lgamma(n: c_float,\n-                                              sign: &mut c_int) -> c_float;\n+        #[cfg(windows)]\n+        #[link_name=\"__lgammaf_r\"]\n+        unsafe fn lgamma(n: c_float, sign: &mut c_int) -> c_float;\n \n-    #[link_name=\"logf\"] unsafe fn ln(n: c_float) -> c_float;\n-    #[link_name=\"logbf\"] unsafe fn log_radix(n: c_float) -> c_float;\n-    #[link_name=\"log1pf\"] unsafe fn ln1p(n: c_float) -> c_float;\n-    #[link_name=\"log2f\"] unsafe fn log2(n: c_float) -> c_float;\n-    #[link_name=\"log10f\"] unsafe fn log10(n: c_float) -> c_float;\n-    #[link_name=\"ilogbf\"] unsafe fn ilog_radix(n: c_float) -> c_int;\n-    #[link_name=\"modff\"] unsafe fn modf(n: c_float,\n-                                      iptr: &mut c_float) -> c_float;\n-    #[link_name=\"powf\"] unsafe fn pow(n: c_float, e: c_float) -> c_float;\n-// FIXME (#1379): enable when rounding modes become available\n-//    #[link_name=\"rintf\"] unsafe fn rint(n: c_float) -> c_float;\n-    #[link_name=\"roundf\"] unsafe fn round(n: c_float) -> c_float;\n-    #[link_name=\"scalbnf\"] unsafe fn ldexp_radix(n: c_float, i: c_int)\n-        -> c_float;\n-    #[link_name=\"sinf\"] unsafe fn sin(n: c_float) -> c_float;\n-    #[link_name=\"sinhf\"] unsafe fn sinh(n: c_float) -> c_float;\n-    #[link_name=\"sqrtf\"] unsafe fn sqrt(n: c_float) -> c_float;\n-    #[link_name=\"tanf\"] unsafe fn tan(n: c_float) -> c_float;\n-    #[link_name=\"tanhf\"] unsafe fn tanh(n: c_float) -> c_float;\n-    #[link_name=\"tgammaf\"] unsafe fn tgamma(n: c_float) -> c_float;\n-    #[link_name=\"truncf\"] unsafe fn trunc(n: c_float) -> c_float;\n+        #[link_name=\"logf\"] unsafe fn ln(n: c_float) -> c_float;\n+        #[link_name=\"logbf\"] unsafe fn log_radix(n: c_float) -> c_float;\n+        #[link_name=\"log1pf\"] unsafe fn ln1p(n: c_float) -> c_float;\n+        #[link_name=\"log2f\"] unsafe fn log2(n: c_float) -> c_float;\n+        #[link_name=\"log10f\"] unsafe fn log10(n: c_float) -> c_float;\n+        #[link_name=\"ilogbf\"] unsafe fn ilog_radix(n: c_float) -> c_int;\n+        #[link_name=\"modff\"] unsafe fn modf(n: c_float,\n+                                          iptr: &mut c_float) -> c_float;\n+        #[link_name=\"powf\"] unsafe fn pow(n: c_float, e: c_float) -> c_float;\n+    // FIXME (#1379): enable when rounding modes become available\n+    //    #[link_name=\"rintf\"] unsafe fn rint(n: c_float) -> c_float;\n+        #[link_name=\"roundf\"] unsafe fn round(n: c_float) -> c_float;\n+        #[link_name=\"scalbnf\"] unsafe fn ldexp_radix(n: c_float, i: c_int)\n+            -> c_float;\n+        #[link_name=\"sinf\"] unsafe fn sin(n: c_float) -> c_float;\n+        #[link_name=\"sinhf\"] unsafe fn sinh(n: c_float) -> c_float;\n+        #[link_name=\"sqrtf\"] unsafe fn sqrt(n: c_float) -> c_float;\n+        #[link_name=\"tanf\"] unsafe fn tan(n: c_float) -> c_float;\n+        #[link_name=\"tanhf\"] unsafe fn tanh(n: c_float) -> c_float;\n+        #[link_name=\"tgammaf\"] unsafe fn tgamma(n: c_float) -> c_float;\n+        #[link_name=\"truncf\"] unsafe fn trunc(n: c_float) -> c_float;\n+    }\n }\n \n // PORT check these by running src/etc/machconsts.c for your architecture"}, {"sha": "54521abea9ec0da5d0fbd87d880edbd0943b60e2", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -583,56 +583,56 @@ pub fn test_num() {\n     let ten: f32 = num::cast(10);\n     let two: f32 = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    assert (20u     == 20f32.to_uint());\n-    assert (20u8    == 20f32.to_u8());\n-    assert (20u16   == 20f32.to_u16());\n-    assert (20u32   == 20f32.to_u32());\n-    assert (20u64   == 20f32.to_u64());\n-    assert (20i     == 20f32.to_int());\n-    assert (20i8    == 20f32.to_i8());\n-    assert (20i16   == 20f32.to_i16());\n-    assert (20i32   == 20f32.to_i32());\n-    assert (20i64   == 20f32.to_i64());\n-    assert (20f     == 20f32.to_float());\n-    assert (20f32   == 20f32.to_f32());\n-    assert (20f64   == 20f32.to_f64());\n-\n-    assert (20f32 == NumCast::from(20u));\n-    assert (20f32 == NumCast::from(20u8));\n-    assert (20f32 == NumCast::from(20u16));\n-    assert (20f32 == NumCast::from(20u32));\n-    assert (20f32 == NumCast::from(20u64));\n-    assert (20f32 == NumCast::from(20i));\n-    assert (20f32 == NumCast::from(20i8));\n-    assert (20f32 == NumCast::from(20i16));\n-    assert (20f32 == NumCast::from(20i32));\n-    assert (20f32 == NumCast::from(20i64));\n-    assert (20f32 == NumCast::from(20f));\n-    assert (20f32 == NumCast::from(20f32));\n-    assert (20f32 == NumCast::from(20f64));\n-\n-    assert (20f32 == num::cast(20u));\n-    assert (20f32 == num::cast(20u8));\n-    assert (20f32 == num::cast(20u16));\n-    assert (20f32 == num::cast(20u32));\n-    assert (20f32 == num::cast(20u64));\n-    assert (20f32 == num::cast(20i));\n-    assert (20f32 == num::cast(20i8));\n-    assert (20f32 == num::cast(20i16));\n-    assert (20f32 == num::cast(20i32));\n-    assert (20f32 == num::cast(20i64));\n-    assert (20f32 == num::cast(20f));\n-    assert (20f32 == num::cast(20f32));\n-    assert (20f32 == num::cast(20f64));\n+    fail_unless!((20u     == 20f32.to_uint()));\n+    fail_unless!((20u8    == 20f32.to_u8()));\n+    fail_unless!((20u16   == 20f32.to_u16()));\n+    fail_unless!((20u32   == 20f32.to_u32()));\n+    fail_unless!((20u64   == 20f32.to_u64()));\n+    fail_unless!((20i     == 20f32.to_int()));\n+    fail_unless!((20i8    == 20f32.to_i8()));\n+    fail_unless!((20i16   == 20f32.to_i16()));\n+    fail_unless!((20i32   == 20f32.to_i32()));\n+    fail_unless!((20i64   == 20f32.to_i64()));\n+    fail_unless!((20f     == 20f32.to_float()));\n+    fail_unless!((20f32   == 20f32.to_f32()));\n+    fail_unless!((20f64   == 20f32.to_f64()));\n+\n+    fail_unless!((20f32 == NumCast::from(20u)));\n+    fail_unless!((20f32 == NumCast::from(20u8)));\n+    fail_unless!((20f32 == NumCast::from(20u16)));\n+    fail_unless!((20f32 == NumCast::from(20u32)));\n+    fail_unless!((20f32 == NumCast::from(20u64)));\n+    fail_unless!((20f32 == NumCast::from(20i)));\n+    fail_unless!((20f32 == NumCast::from(20i8)));\n+    fail_unless!((20f32 == NumCast::from(20i16)));\n+    fail_unless!((20f32 == NumCast::from(20i32)));\n+    fail_unless!((20f32 == NumCast::from(20i64)));\n+    fail_unless!((20f32 == NumCast::from(20f)));\n+    fail_unless!((20f32 == NumCast::from(20f32)));\n+    fail_unless!((20f32 == NumCast::from(20f64)));\n+\n+    fail_unless!((20f32 == num::cast(20u)));\n+    fail_unless!((20f32 == num::cast(20u8)));\n+    fail_unless!((20f32 == num::cast(20u16)));\n+    fail_unless!((20f32 == num::cast(20u32)));\n+    fail_unless!((20f32 == num::cast(20u64)));\n+    fail_unless!((20f32 == num::cast(20i)));\n+    fail_unless!((20f32 == num::cast(20i8)));\n+    fail_unless!((20f32 == num::cast(20i16)));\n+    fail_unless!((20f32 == num::cast(20i32)));\n+    fail_unless!((20f32 == num::cast(20i64)));\n+    fail_unless!((20f32 == num::cast(20f)));\n+    fail_unless!((20f32 == num::cast(20f32)));\n+    fail_unless!((20f32 == num::cast(20f64)));\n }\n \n //"}, {"sha": "a2cf629dc9f362dde7879883d37bdc44b75f52b1", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -607,56 +607,56 @@ pub fn test_num() {\n     let ten: f64 = num::cast(10);\n     let two: f64 = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20f64.to_uint());\n-    assert (20u8  == 20f64.to_u8());\n-    assert (20u16 == 20f64.to_u16());\n-    assert (20u32 == 20f64.to_u32());\n-    assert (20u64 == 20f64.to_u64());\n-    assert (20i   == 20f64.to_int());\n-    assert (20i8  == 20f64.to_i8());\n-    assert (20i16 == 20f64.to_i16());\n-    assert (20i32 == 20f64.to_i32());\n-    assert (20i64 == 20f64.to_i64());\n-    assert (20f   == 20f64.to_float());\n-    assert (20f32 == 20f64.to_f32());\n-    assert (20f64 == 20f64.to_f64());\n-\n-    assert (20f64 == NumCast::from(20u));\n-    assert (20f64 == NumCast::from(20u8));\n-    assert (20f64 == NumCast::from(20u16));\n-    assert (20f64 == NumCast::from(20u32));\n-    assert (20f64 == NumCast::from(20u64));\n-    assert (20f64 == NumCast::from(20i));\n-    assert (20f64 == NumCast::from(20i8));\n-    assert (20f64 == NumCast::from(20i16));\n-    assert (20f64 == NumCast::from(20i32));\n-    assert (20f64 == NumCast::from(20i64));\n-    assert (20f64 == NumCast::from(20f));\n-    assert (20f64 == NumCast::from(20f32));\n-    assert (20f64 == NumCast::from(20f64));\n-\n-    assert (20f64 == num::cast(20u));\n-    assert (20f64 == num::cast(20u8));\n-    assert (20f64 == num::cast(20u16));\n-    assert (20f64 == num::cast(20u32));\n-    assert (20f64 == num::cast(20u64));\n-    assert (20f64 == num::cast(20i));\n-    assert (20f64 == num::cast(20i8));\n-    assert (20f64 == num::cast(20i16));\n-    assert (20f64 == num::cast(20i32));\n-    assert (20f64 == num::cast(20i64));\n-    assert (20f64 == num::cast(20f));\n-    assert (20f64 == num::cast(20f32));\n-    assert (20f64 == num::cast(20f64));\n+    fail_unless!((20u   == 20f64.to_uint()));\n+    fail_unless!((20u8  == 20f64.to_u8()));\n+    fail_unless!((20u16 == 20f64.to_u16()));\n+    fail_unless!((20u32 == 20f64.to_u32()));\n+    fail_unless!((20u64 == 20f64.to_u64()));\n+    fail_unless!((20i   == 20f64.to_int()));\n+    fail_unless!((20i8  == 20f64.to_i8()));\n+    fail_unless!((20i16 == 20f64.to_i16()));\n+    fail_unless!((20i32 == 20f64.to_i32()));\n+    fail_unless!((20i64 == 20f64.to_i64()));\n+    fail_unless!((20f   == 20f64.to_float()));\n+    fail_unless!((20f32 == 20f64.to_f32()));\n+    fail_unless!((20f64 == 20f64.to_f64()));\n+\n+    fail_unless!((20f64 == NumCast::from(20u)));\n+    fail_unless!((20f64 == NumCast::from(20u8)));\n+    fail_unless!((20f64 == NumCast::from(20u16)));\n+    fail_unless!((20f64 == NumCast::from(20u32)));\n+    fail_unless!((20f64 == NumCast::from(20u64)));\n+    fail_unless!((20f64 == NumCast::from(20i)));\n+    fail_unless!((20f64 == NumCast::from(20i8)));\n+    fail_unless!((20f64 == NumCast::from(20i16)));\n+    fail_unless!((20f64 == NumCast::from(20i32)));\n+    fail_unless!((20f64 == NumCast::from(20i64)));\n+    fail_unless!((20f64 == NumCast::from(20f)));\n+    fail_unless!((20f64 == NumCast::from(20f32)));\n+    fail_unless!((20f64 == NumCast::from(20f64)));\n+\n+    fail_unless!((20f64 == num::cast(20u)));\n+    fail_unless!((20f64 == num::cast(20u8)));\n+    fail_unless!((20f64 == num::cast(20u16)));\n+    fail_unless!((20f64 == num::cast(20u32)));\n+    fail_unless!((20f64 == num::cast(20u64)));\n+    fail_unless!((20f64 == num::cast(20i)));\n+    fail_unless!((20f64 == num::cast(20i8)));\n+    fail_unless!((20f64 == num::cast(20i16)));\n+    fail_unless!((20f64 == num::cast(20i32)));\n+    fail_unless!((20f64 == num::cast(20i64)));\n+    fail_unless!((20f64 == num::cast(20f)));\n+    fail_unless!((20f64 == num::cast(20f32)));\n+    fail_unless!((20f64 == num::cast(20f64)));\n }\n \n //"}, {"sha": "1cceddf51a1d3dd74897ea4635ba5b86a5dbe2f1", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -180,7 +180,7 @@ pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n #[test]\n pub fn test_to_str_exact_do_decimal() {\n     let s = to_str_exact(5.0, 4u);\n-    assert s == ~\"5.0000\";\n+    fail_unless!(s == ~\"5.0000\");\n }\n \n /**\n@@ -500,248 +500,248 @@ impl ops::Neg<float> for float {\n \n #[test]\n pub fn test_from_str() {\n-   assert from_str(~\"3\") == Some(3.);\n-   assert from_str(~\"3.14\") == Some(3.14);\n-   assert from_str(~\"+3.14\") == Some(3.14);\n-   assert from_str(~\"-3.14\") == Some(-3.14);\n-   assert from_str(~\"2.5E10\") == Some(25000000000.);\n-   assert from_str(~\"2.5e10\") == Some(25000000000.);\n-   assert from_str(~\"25000000000.E-10\") == Some(2.5);\n-   assert from_str(~\".\") == Some(0.);\n-   assert from_str(~\".e1\") == Some(0.);\n-   assert from_str(~\".e-1\") == Some(0.);\n-   assert from_str(~\"5.\") == Some(5.);\n-   assert from_str(~\".5\") == Some(0.5);\n-   assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"-.5\") == Some(-0.5);\n-   assert from_str(~\"-5\") == Some(-5.);\n-   assert from_str(~\"inf\") == Some(infinity);\n-   assert from_str(~\"+inf\") == Some(infinity);\n-   assert from_str(~\"-inf\") == Some(neg_infinity);\n+   fail_unless!(from_str(~\"3\") == Some(3.));\n+   fail_unless!(from_str(~\"3.14\") == Some(3.14));\n+   fail_unless!(from_str(~\"+3.14\") == Some(3.14));\n+   fail_unless!(from_str(~\"-3.14\") == Some(-3.14));\n+   fail_unless!(from_str(~\"2.5E10\") == Some(25000000000.));\n+   fail_unless!(from_str(~\"2.5e10\") == Some(25000000000.));\n+   fail_unless!(from_str(~\"25000000000.E-10\") == Some(2.5));\n+   fail_unless!(from_str(~\".\") == Some(0.));\n+   fail_unless!(from_str(~\".e1\") == Some(0.));\n+   fail_unless!(from_str(~\".e-1\") == Some(0.));\n+   fail_unless!(from_str(~\"5.\") == Some(5.));\n+   fail_unless!(from_str(~\".5\") == Some(0.5));\n+   fail_unless!(from_str(~\"0.5\") == Some(0.5));\n+   fail_unless!(from_str(~\"-.5\") == Some(-0.5));\n+   fail_unless!(from_str(~\"-5\") == Some(-5.));\n+   fail_unless!(from_str(~\"inf\") == Some(infinity));\n+   fail_unless!(from_str(~\"+inf\") == Some(infinity));\n+   fail_unless!(from_str(~\"-inf\") == Some(neg_infinity));\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str(~\"NaN\") {\n-       Some(f) => assert is_NaN(f),\n+       Some(f) => fail_unless!(is_NaN(f)),\n        None => fail!()\n    }\n    // note: -0 == 0, hence these slightly more complex tests\n    match from_str(~\"-0\") {\n-       Some(v) if is_zero(v) => assert is_negative(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_negative(v)),\n        _ => fail!()\n    }\n    match from_str(~\"0\") {\n-       Some(v) if is_zero(v) => assert is_positive(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_positive(v)),\n        _ => fail!()\n    }\n \n-   assert from_str(~\"\").is_none();\n-   assert from_str(~\"x\").is_none();\n-   assert from_str(~\" \").is_none();\n-   assert from_str(~\"   \").is_none();\n-   assert from_str(~\"e\").is_none();\n-   assert from_str(~\"E\").is_none();\n-   assert from_str(~\"E1\").is_none();\n-   assert from_str(~\"1e1e1\").is_none();\n-   assert from_str(~\"1e1.1\").is_none();\n-   assert from_str(~\"1e1-1\").is_none();\n+   fail_unless!(from_str(~\"\").is_none());\n+   fail_unless!(from_str(~\"x\").is_none());\n+   fail_unless!(from_str(~\" \").is_none());\n+   fail_unless!(from_str(~\"   \").is_none());\n+   fail_unless!(from_str(~\"e\").is_none());\n+   fail_unless!(from_str(~\"E\").is_none());\n+   fail_unless!(from_str(~\"E1\").is_none());\n+   fail_unless!(from_str(~\"1e1e1\").is_none());\n+   fail_unless!(from_str(~\"1e1.1\").is_none());\n+   fail_unless!(from_str(~\"1e1-1\").is_none());\n }\n \n #[test]\n pub fn test_from_str_hex() {\n-   assert from_str_hex(~\"a4\") == Some(164.);\n-   assert from_str_hex(~\"a4.fe\") == Some(164.9921875);\n-   assert from_str_hex(~\"-a4.fe\") == Some(-164.9921875);\n-   assert from_str_hex(~\"+a4.fe\") == Some(164.9921875);\n-   assert from_str_hex(~\"ff0P4\") == Some(0xff00 as float);\n-   assert from_str_hex(~\"ff0p4\") == Some(0xff00 as float);\n-   assert from_str_hex(~\"ff0p-4\") == Some(0xff as float);\n-   assert from_str_hex(~\".\") == Some(0.);\n-   assert from_str_hex(~\".p1\") == Some(0.);\n-   assert from_str_hex(~\".p-1\") == Some(0.);\n-   assert from_str_hex(~\"f.\") == Some(15.);\n-   assert from_str_hex(~\".f\") == Some(0.9375);\n-   assert from_str_hex(~\"0.f\") == Some(0.9375);\n-   assert from_str_hex(~\"-.f\") == Some(-0.9375);\n-   assert from_str_hex(~\"-f\") == Some(-15.);\n-   assert from_str_hex(~\"inf\") == Some(infinity);\n-   assert from_str_hex(~\"+inf\") == Some(infinity);\n-   assert from_str_hex(~\"-inf\") == Some(neg_infinity);\n+   fail_unless!(from_str_hex(~\"a4\") == Some(164.));\n+   fail_unless!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n+   fail_unless!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n+   fail_unless!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n+   fail_unless!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n+   fail_unless!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n+   fail_unless!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n+   fail_unless!(from_str_hex(~\".\") == Some(0.));\n+   fail_unless!(from_str_hex(~\".p1\") == Some(0.));\n+   fail_unless!(from_str_hex(~\".p-1\") == Some(0.));\n+   fail_unless!(from_str_hex(~\"f.\") == Some(15.));\n+   fail_unless!(from_str_hex(~\".f\") == Some(0.9375));\n+   fail_unless!(from_str_hex(~\"0.f\") == Some(0.9375));\n+   fail_unless!(from_str_hex(~\"-.f\") == Some(-0.9375));\n+   fail_unless!(from_str_hex(~\"-f\") == Some(-15.));\n+   fail_unless!(from_str_hex(~\"inf\") == Some(infinity));\n+   fail_unless!(from_str_hex(~\"+inf\") == Some(infinity));\n+   fail_unless!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str_hex(~\"NaN\") {\n-       Some(f) => assert is_NaN(f),\n+       Some(f) => fail_unless!(is_NaN(f)),\n        None => fail!()\n    }\n    // note: -0 == 0, hence these slightly more complex tests\n    match from_str_hex(~\"-0\") {\n-       Some(v) if is_zero(v) => assert is_negative(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_negative(v)),\n        _ => fail!()\n    }\n    match from_str_hex(~\"0\") {\n-       Some(v) if is_zero(v) => assert is_positive(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_positive(v)),\n        _ => fail!()\n    }\n-   assert from_str_hex(~\"e\") == Some(14.);\n-   assert from_str_hex(~\"E\") == Some(14.);\n-   assert from_str_hex(~\"E1\") == Some(225.);\n-   assert from_str_hex(~\"1e1e1\") == Some(123361.);\n-   assert from_str_hex(~\"1e1.1\") == Some(481.0625);\n-\n-   assert from_str_hex(~\"\").is_none();\n-   assert from_str_hex(~\"x\").is_none();\n-   assert from_str_hex(~\" \").is_none();\n-   assert from_str_hex(~\"   \").is_none();\n-   assert from_str_hex(~\"p\").is_none();\n-   assert from_str_hex(~\"P\").is_none();\n-   assert from_str_hex(~\"P1\").is_none();\n-   assert from_str_hex(~\"1p1p1\").is_none();\n-   assert from_str_hex(~\"1p1.1\").is_none();\n-   assert from_str_hex(~\"1p1-1\").is_none();\n+   fail_unless!(from_str_hex(~\"e\") == Some(14.));\n+   fail_unless!(from_str_hex(~\"E\") == Some(14.));\n+   fail_unless!(from_str_hex(~\"E1\") == Some(225.));\n+   fail_unless!(from_str_hex(~\"1e1e1\") == Some(123361.));\n+   fail_unless!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n+\n+   fail_unless!(from_str_hex(~\"\").is_none());\n+   fail_unless!(from_str_hex(~\"x\").is_none());\n+   fail_unless!(from_str_hex(~\" \").is_none());\n+   fail_unless!(from_str_hex(~\"   \").is_none());\n+   fail_unless!(from_str_hex(~\"p\").is_none());\n+   fail_unless!(from_str_hex(~\"P\").is_none());\n+   fail_unless!(from_str_hex(~\"P1\").is_none());\n+   fail_unless!(from_str_hex(~\"1p1p1\").is_none());\n+   fail_unless!(from_str_hex(~\"1p1.1\").is_none());\n+   fail_unless!(from_str_hex(~\"1p1-1\").is_none());\n }\n \n #[test]\n pub fn test_to_str_hex() {\n-   assert to_str_hex(164.) == ~\"a4\";\n-   assert to_str_hex(164.9921875) == ~\"a4.fe\";\n-   assert to_str_hex(-164.9921875) == ~\"-a4.fe\";\n-   assert to_str_hex(0xff00 as float) == ~\"ff00\";\n-   assert to_str_hex(-(0xff00 as float)) == ~\"-ff00\";\n-   assert to_str_hex(0.) == ~\"0\";\n-   assert to_str_hex(15.) == ~\"f\";\n-   assert to_str_hex(-15.) == ~\"-f\";\n-   assert to_str_hex(0.9375) == ~\"0.f\";\n-   assert to_str_hex(-0.9375) == ~\"-0.f\";\n-   assert to_str_hex(infinity) == ~\"inf\";\n-   assert to_str_hex(neg_infinity) == ~\"-inf\";\n-   assert to_str_hex(NaN) == ~\"NaN\";\n-   assert to_str_hex(0.) == ~\"0\";\n-   assert to_str_hex(-0.) == ~\"-0\";\n+   fail_unless!(to_str_hex(164.) == ~\"a4\");\n+   fail_unless!(to_str_hex(164.9921875) == ~\"a4.fe\");\n+   fail_unless!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n+   fail_unless!(to_str_hex(0xff00 as float) == ~\"ff00\");\n+   fail_unless!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n+   fail_unless!(to_str_hex(0.) == ~\"0\");\n+   fail_unless!(to_str_hex(15.) == ~\"f\");\n+   fail_unless!(to_str_hex(-15.) == ~\"-f\");\n+   fail_unless!(to_str_hex(0.9375) == ~\"0.f\");\n+   fail_unless!(to_str_hex(-0.9375) == ~\"-0.f\");\n+   fail_unless!(to_str_hex(infinity) == ~\"inf\");\n+   fail_unless!(to_str_hex(neg_infinity) == ~\"-inf\");\n+   fail_unless!(to_str_hex(NaN) == ~\"NaN\");\n+   fail_unless!(to_str_hex(0.) == ~\"0\");\n+   fail_unless!(to_str_hex(-0.) == ~\"-0\");\n }\n \n #[test]\n pub fn test_to_str_radix() {\n-   assert to_str_radix(36., 36u) == ~\"10\";\n-   assert to_str_radix(8.125, 2u) == ~\"1000.001\";\n+   fail_unless!(to_str_radix(36., 36u) == ~\"10\");\n+   fail_unless!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n }\n \n #[test]\n pub fn test_from_str_radix() {\n-   assert from_str_radix(~\"10\", 36u) == Some(36.);\n-   assert from_str_radix(~\"1000.001\", 2u) == Some(8.125);\n+   fail_unless!(from_str_radix(~\"10\", 36u) == Some(36.));\n+   fail_unless!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n }\n \n #[test]\n pub fn test_positive() {\n-  assert(is_positive(infinity));\n-  assert(is_positive(1.));\n-  assert(is_positive(0.));\n-  assert(!is_positive(-1.));\n-  assert(!is_positive(neg_infinity));\n-  assert(!is_positive(1./neg_infinity));\n-  assert(!is_positive(NaN));\n+  fail_unless!((is_positive(infinity)));\n+  fail_unless!((is_positive(1.)));\n+  fail_unless!((is_positive(0.)));\n+  fail_unless!((!is_positive(-1.)));\n+  fail_unless!((!is_positive(neg_infinity)));\n+  fail_unless!((!is_positive(1./neg_infinity)));\n+  fail_unless!((!is_positive(NaN)));\n }\n \n #[test]\n pub fn test_negative() {\n-  assert(!is_negative(infinity));\n-  assert(!is_negative(1.));\n-  assert(!is_negative(0.));\n-  assert(is_negative(-1.));\n-  assert(is_negative(neg_infinity));\n-  assert(is_negative(1./neg_infinity));\n-  assert(!is_negative(NaN));\n+  fail_unless!((!is_negative(infinity)));\n+  fail_unless!((!is_negative(1.)));\n+  fail_unless!((!is_negative(0.)));\n+  fail_unless!((is_negative(-1.)));\n+  fail_unless!((is_negative(neg_infinity)));\n+  fail_unless!((is_negative(1./neg_infinity)));\n+  fail_unless!((!is_negative(NaN)));\n }\n \n #[test]\n pub fn test_nonpositive() {\n-  assert(!is_nonpositive(infinity));\n-  assert(!is_nonpositive(1.));\n-  assert(!is_nonpositive(0.));\n-  assert(is_nonpositive(-1.));\n-  assert(is_nonpositive(neg_infinity));\n-  assert(is_nonpositive(1./neg_infinity));\n-  assert(!is_nonpositive(NaN));\n+  fail_unless!((!is_nonpositive(infinity)));\n+  fail_unless!((!is_nonpositive(1.)));\n+  fail_unless!((!is_nonpositive(0.)));\n+  fail_unless!((is_nonpositive(-1.)));\n+  fail_unless!((is_nonpositive(neg_infinity)));\n+  fail_unless!((is_nonpositive(1./neg_infinity)));\n+  fail_unless!((!is_nonpositive(NaN)));\n }\n \n #[test]\n pub fn test_nonnegative() {\n-  assert(is_nonnegative(infinity));\n-  assert(is_nonnegative(1.));\n-  assert(is_nonnegative(0.));\n-  assert(!is_nonnegative(-1.));\n-  assert(!is_nonnegative(neg_infinity));\n-  assert(!is_nonnegative(1./neg_infinity));\n-  assert(!is_nonnegative(NaN));\n+  fail_unless!((is_nonnegative(infinity)));\n+  fail_unless!((is_nonnegative(1.)));\n+  fail_unless!((is_nonnegative(0.)));\n+  fail_unless!((!is_nonnegative(-1.)));\n+  fail_unless!((!is_nonnegative(neg_infinity)));\n+  fail_unless!((!is_nonnegative(1./neg_infinity)));\n+  fail_unless!((!is_nonnegative(NaN)));\n }\n \n #[test]\n pub fn test_to_str_inf() {\n-    assert to_str_digits(infinity, 10u) == ~\"inf\";\n-    assert to_str_digits(-infinity, 10u) == ~\"-inf\";\n+    fail_unless!(to_str_digits(infinity, 10u) == ~\"inf\");\n+    fail_unless!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n }\n \n #[test]\n pub fn test_round() {\n-    assert round(5.8) == 6.0;\n-    assert round(5.2) == 5.0;\n-    assert round(3.0) == 3.0;\n-    assert round(2.5) == 3.0;\n-    assert round(-3.5) == -4.0;\n+    fail_unless!(round(5.8) == 6.0);\n+    fail_unless!(round(5.2) == 5.0);\n+    fail_unless!(round(3.0) == 3.0);\n+    fail_unless!(round(2.5) == 3.0);\n+    fail_unless!(round(-3.5) == -4.0);\n }\n \n #[test]\n pub fn test_num() {\n     let ten: float = num::cast(10);\n     let two: float = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20f.to_uint());\n-    assert (20u8  == 20f.to_u8());\n-    assert (20u16 == 20f.to_u16());\n-    assert (20u32 == 20f.to_u32());\n-    assert (20u64 == 20f.to_u64());\n-    assert (20i   == 20f.to_int());\n-    assert (20i8  == 20f.to_i8());\n-    assert (20i16 == 20f.to_i16());\n-    assert (20i32 == 20f.to_i32());\n-    assert (20i64 == 20f.to_i64());\n-    assert (20f   == 20f.to_float());\n-    assert (20f32 == 20f.to_f32());\n-    assert (20f64 == 20f.to_f64());\n-\n-    assert (20f == NumCast::from(20u));\n-    assert (20f == NumCast::from(20u8));\n-    assert (20f == NumCast::from(20u16));\n-    assert (20f == NumCast::from(20u32));\n-    assert (20f == NumCast::from(20u64));\n-    assert (20f == NumCast::from(20i));\n-    assert (20f == NumCast::from(20i8));\n-    assert (20f == NumCast::from(20i16));\n-    assert (20f == NumCast::from(20i32));\n-    assert (20f == NumCast::from(20i64));\n-    assert (20f == NumCast::from(20f));\n-    assert (20f == NumCast::from(20f32));\n-    assert (20f == NumCast::from(20f64));\n-\n-    assert (20f == num::cast(20u));\n-    assert (20f == num::cast(20u8));\n-    assert (20f == num::cast(20u16));\n-    assert (20f == num::cast(20u32));\n-    assert (20f == num::cast(20u64));\n-    assert (20f == num::cast(20i));\n-    assert (20f == num::cast(20i8));\n-    assert (20f == num::cast(20i16));\n-    assert (20f == num::cast(20i32));\n-    assert (20f == num::cast(20i64));\n-    assert (20f == num::cast(20f));\n-    assert (20f == num::cast(20f32));\n-    assert (20f == num::cast(20f64));\n+    fail_unless!((20u   == 20f.to_uint()));\n+    fail_unless!((20u8  == 20f.to_u8()));\n+    fail_unless!((20u16 == 20f.to_u16()));\n+    fail_unless!((20u32 == 20f.to_u32()));\n+    fail_unless!((20u64 == 20f.to_u64()));\n+    fail_unless!((20i   == 20f.to_int()));\n+    fail_unless!((20i8  == 20f.to_i8()));\n+    fail_unless!((20i16 == 20f.to_i16()));\n+    fail_unless!((20i32 == 20f.to_i32()));\n+    fail_unless!((20i64 == 20f.to_i64()));\n+    fail_unless!((20f   == 20f.to_float()));\n+    fail_unless!((20f32 == 20f.to_f32()));\n+    fail_unless!((20f64 == 20f.to_f64()));\n+\n+    fail_unless!((20f == NumCast::from(20u)));\n+    fail_unless!((20f == NumCast::from(20u8)));\n+    fail_unless!((20f == NumCast::from(20u16)));\n+    fail_unless!((20f == NumCast::from(20u32)));\n+    fail_unless!((20f == NumCast::from(20u64)));\n+    fail_unless!((20f == NumCast::from(20i)));\n+    fail_unless!((20f == NumCast::from(20i8)));\n+    fail_unless!((20f == NumCast::from(20i16)));\n+    fail_unless!((20f == NumCast::from(20i32)));\n+    fail_unless!((20f == NumCast::from(20i64)));\n+    fail_unless!((20f == NumCast::from(20f)));\n+    fail_unless!((20f == NumCast::from(20f32)));\n+    fail_unless!((20f == NumCast::from(20f64)));\n+\n+    fail_unless!((20f == num::cast(20u)));\n+    fail_unless!((20f == num::cast(20u8)));\n+    fail_unless!((20f == num::cast(20u16)));\n+    fail_unless!((20f == num::cast(20u32)));\n+    fail_unless!((20f == num::cast(20u64)));\n+    fail_unless!((20f == num::cast(20i)));\n+    fail_unless!((20f == num::cast(20i8)));\n+    fail_unless!((20f == num::cast(20i16)));\n+    fail_unless!((20f == num::cast(20i32)));\n+    fail_unless!((20f == num::cast(20i64)));\n+    fail_unless!((20f == num::cast(20f)));\n+    fail_unless!((20f == num::cast(20f32)));\n+    fail_unless!((20f == num::cast(20f64)));\n }\n \n "}, {"sha": "2f59b4c50de04189f336e8b54f8760018534fb9b", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 79, "deletions": 74, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -41,18 +41,18 @@ pub pure fn div(x: T, y: T) -> T { x / y }\n  *\n  * # Examples\n  * ~~~\n- * assert int::rem(5 / 2) == 1;\n+ * fail_unless!(int::rem(5 / 2) == 1);\n  * ~~~\n  *\n  * When faced with negative numbers, the result copies the sign of the\n  * dividend.\n  *\n  * ~~~\n- * assert int::rem(2 / -3) ==  2;\n+ * fail_unless!(int::rem(2 / -3) ==  2);\n  * ~~~\n  *\n  * ~~~\n- * assert int::rem(-2 / 3) ==  -2;\n+ * fail_unless!(int::rem(-2 / 3) ==  -2);\n  * ~~~\n  *\n  */\n@@ -95,7 +95,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  * for int::range(1, 5) |i| {\n  *     sum += i;\n  * }\n- * assert sum == 10;\n+ * fail_unless!(sum == 10);\n  * ~~~\n  */\n #[inline(always)]\n@@ -275,129 +275,134 @@ impl ToStrRadix for T {\n \n #[test]\n fn test_from_str() {\n-    assert from_str(~\"0\") == Some(0 as T);\n-    assert from_str(~\"3\") == Some(3 as T);\n-    assert from_str(~\"10\") == Some(10 as T);\n-    assert i32::from_str(~\"123456789\") == Some(123456789 as i32);\n-    assert from_str(~\"00100\") == Some(100 as T);\n+    fail_unless!(from_str(~\"0\") == Some(0 as T));\n+    fail_unless!(from_str(~\"3\") == Some(3 as T));\n+    fail_unless!(from_str(~\"10\") == Some(10 as T));\n+    fail_unless!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n+    fail_unless!(from_str(~\"00100\") == Some(100 as T));\n \n-    assert from_str(~\"-1\") == Some(-1 as T);\n-    assert from_str(~\"-3\") == Some(-3 as T);\n-    assert from_str(~\"-10\") == Some(-10 as T);\n-    assert i32::from_str(~\"-123456789\") == Some(-123456789 as i32);\n-    assert from_str(~\"-00100\") == Some(-100 as T);\n+    fail_unless!(from_str(~\"-1\") == Some(-1 as T));\n+    fail_unless!(from_str(~\"-3\") == Some(-3 as T));\n+    fail_unless!(from_str(~\"-10\") == Some(-10 as T));\n+    fail_unless!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n+    fail_unless!(from_str(~\"-00100\") == Some(-100 as T));\n \n-    assert from_str(~\" \").is_none();\n-    assert from_str(~\"x\").is_none();\n+    fail_unless!(from_str(~\" \").is_none());\n+    fail_unless!(from_str(~\"x\").is_none());\n }\n \n #[test]\n fn test_parse_bytes() {\n     use str::to_bytes;\n-    assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T);\n-    assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T);\n-    assert parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T);\n-    assert i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) == Some(65535 as i32);\n-    assert parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T);\n-    assert parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T);\n-\n-    assert parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T);\n-    assert parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T);\n-    assert parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T);\n-    assert i32::parse_bytes(to_bytes(~\"-123\"), 16u) == Some(-291 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) == Some(-65535 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) == Some(-65535 as i32);\n-    assert parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T);\n-    assert parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T);\n-\n-    assert parse_bytes(to_bytes(~\"Z\"), 35u).is_none();\n-    assert parse_bytes(to_bytes(~\"-9\"), 2u).is_none();\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+                 Some(65535 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n+                 Some(65535 as i32));\n+    fail_unless!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n+\n+    fail_unless!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n+                 Some(-291 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n+                 Some(-65535 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n+                 Some(-65535 as i32));\n+    fail_unless!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n+\n+    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n+    fail_unless!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n }\n \n #[test]\n fn test_to_str() {\n-    assert (to_str_radix(0 as T, 10u) == ~\"0\");\n-    assert (to_str_radix(1 as T, 10u) == ~\"1\");\n-    assert (to_str_radix(-1 as T, 10u) == ~\"-1\");\n-    assert (to_str_radix(127 as T, 16u) == ~\"7f\");\n-    assert (to_str_radix(100 as T, 10u) == ~\"100\");\n+    fail_unless!((to_str_radix(0 as T, 10u) == ~\"0\"));\n+    fail_unless!((to_str_radix(1 as T, 10u) == ~\"1\"));\n+    fail_unless!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n+    fail_unless!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n+    fail_unless!((to_str_radix(100 as T, 10u) == ~\"100\"));\n \n }\n \n #[test]\n fn test_int_to_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n-    assert (i8::to_str(i8_val) == ~\"127\");\n+    fail_unless!((i8::to_str(i8_val) == ~\"127\"));\n \n     i8_val += 1 as i8;\n-    assert (i8::to_str(i8_val) == ~\"-128\");\n+    fail_unless!((i8::to_str(i8_val) == ~\"-128\"));\n \n     let mut i16_val: i16 = 32_767_i16;\n-    assert (i16::to_str(i16_val) == ~\"32767\");\n+    fail_unless!((i16::to_str(i16_val) == ~\"32767\"));\n \n     i16_val += 1 as i16;\n-    assert (i16::to_str(i16_val) == ~\"-32768\");\n+    fail_unless!((i16::to_str(i16_val) == ~\"-32768\"));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert (i32::to_str(i32_val) == ~\"2147483647\");\n+    fail_unless!((i32::to_str(i32_val) == ~\"2147483647\"));\n \n     i32_val += 1 as i32;\n-    assert (i32::to_str(i32_val) == ~\"-2147483648\");\n+    fail_unless!((i32::to_str(i32_val) == ~\"-2147483648\"));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert (i64::to_str(i64_val) == ~\"9223372036854775807\");\n+    fail_unless!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n \n     i64_val += 1 as i64;\n-    assert (i64::to_str(i64_val) == ~\"-9223372036854775808\");\n+    fail_unless!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n }\n \n #[test]\n fn test_int_from_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n-    assert (i8::from_str(~\"127\") == Some(i8_val));\n-    assert (i8::from_str(~\"128\").is_none());\n+    fail_unless!((i8::from_str(~\"127\") == Some(i8_val)));\n+    fail_unless!((i8::from_str(~\"128\").is_none()));\n \n     i8_val += 1 as i8;\n-    assert (i8::from_str(~\"-128\") == Some(i8_val));\n-    assert (i8::from_str(~\"-129\").is_none());\n+    fail_unless!((i8::from_str(~\"-128\") == Some(i8_val)));\n+    fail_unless!((i8::from_str(~\"-129\").is_none()));\n \n     let mut i16_val: i16 = 32_767_i16;\n-    assert (i16::from_str(~\"32767\") == Some(i16_val));\n-    assert (i16::from_str(~\"32768\").is_none());\n+    fail_unless!((i16::from_str(~\"32767\") == Some(i16_val)));\n+    fail_unless!((i16::from_str(~\"32768\").is_none()));\n \n     i16_val += 1 as i16;\n-    assert (i16::from_str(~\"-32768\") == Some(i16_val));\n-    assert (i16::from_str(~\"-32769\").is_none());\n+    fail_unless!((i16::from_str(~\"-32768\") == Some(i16_val)));\n+    fail_unless!((i16::from_str(~\"-32769\").is_none()));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert (i32::from_str(~\"2147483647\") == Some(i32_val));\n-    assert (i32::from_str(~\"2147483648\").is_none());\n+    fail_unless!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n+    fail_unless!((i32::from_str(~\"2147483648\").is_none()));\n \n     i32_val += 1 as i32;\n-    assert (i32::from_str(~\"-2147483648\") == Some(i32_val));\n-    assert (i32::from_str(~\"-2147483649\").is_none());\n+    fail_unless!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n+    fail_unless!((i32::from_str(~\"-2147483649\").is_none()));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert (i64::from_str(~\"9223372036854775807\") == Some(i64_val));\n-    assert (i64::from_str(~\"9223372036854775808\").is_none());\n+    fail_unless!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n+    fail_unless!((i64::from_str(~\"9223372036854775808\").is_none()));\n \n     i64_val += 1 as i64;\n-    assert (i64::from_str(~\"-9223372036854775808\") == Some(i64_val));\n-    assert (i64::from_str(~\"-9223372036854775809\").is_none());\n+    fail_unless!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n+    fail_unless!((i64::from_str(~\"-9223372036854775809\").is_none()));\n }\n \n #[test]\n pub fn test_num() {\n     let ten: T = num::cast(10);\n     let two: T = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n@@ -416,10 +421,10 @@ pub fn test_ranges() {\n     for range_step(36,30,-2) |i| {\n         l.push(i);\n     }\n-    assert l == ~[0,1,2,\n-                  13,12,11,\n-                  20,22,24,\n-                  36,34,32];\n+    fail_unless!(l == ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32]);\n \n     // None of the `fail`s should execute.\n     for range(10,0) |_i| {"}, {"sha": "3c4ca532be764beb3edcb1cf62da5ded3032344f", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i16 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i16.to_uint());\n-    assert (20u8  == 20i16.to_u8());\n-    assert (20u16 == 20i16.to_u16());\n-    assert (20u32 == 20i16.to_u32());\n-    assert (20u64 == 20i16.to_u64());\n-    assert (20i   == 20i16.to_int());\n-    assert (20i8  == 20i16.to_i8());\n-    assert (20i16 == 20i16.to_i16());\n-    assert (20i32 == 20i16.to_i32());\n-    assert (20i64 == 20i16.to_i64());\n-    assert (20f   == 20i16.to_float());\n-    assert (20f32 == 20i16.to_f32());\n-    assert (20f64 == 20i16.to_f64());\n+    fail_unless!((20u   == 20i16.to_uint()));\n+    fail_unless!((20u8  == 20i16.to_u8()));\n+    fail_unless!((20u16 == 20i16.to_u16()));\n+    fail_unless!((20u32 == 20i16.to_u32()));\n+    fail_unless!((20u64 == 20i16.to_u64()));\n+    fail_unless!((20i   == 20i16.to_int()));\n+    fail_unless!((20i8  == 20i16.to_i8()));\n+    fail_unless!((20i16 == 20i16.to_i16()));\n+    fail_unless!((20i32 == 20i16.to_i32()));\n+    fail_unless!((20i64 == 20i16.to_i64()));\n+    fail_unless!((20f   == 20i16.to_float()));\n+    fail_unless!((20f32 == 20i16.to_f32()));\n+    fail_unless!((20f64 == 20i16.to_f64()));\n \n-    assert (20i16 == NumCast::from(20u));\n-    assert (20i16 == NumCast::from(20u8));\n-    assert (20i16 == NumCast::from(20u16));\n-    assert (20i16 == NumCast::from(20u32));\n-    assert (20i16 == NumCast::from(20u64));\n-    assert (20i16 == NumCast::from(20i));\n-    assert (20i16 == NumCast::from(20i8));\n-    assert (20i16 == NumCast::from(20i16));\n-    assert (20i16 == NumCast::from(20i32));\n-    assert (20i16 == NumCast::from(20i64));\n-    assert (20i16 == NumCast::from(20f));\n-    assert (20i16 == NumCast::from(20f32));\n-    assert (20i16 == NumCast::from(20f64));\n+    fail_unless!((20i16 == NumCast::from(20u)));\n+    fail_unless!((20i16 == NumCast::from(20u8)));\n+    fail_unless!((20i16 == NumCast::from(20u16)));\n+    fail_unless!((20i16 == NumCast::from(20u32)));\n+    fail_unless!((20i16 == NumCast::from(20u64)));\n+    fail_unless!((20i16 == NumCast::from(20i)));\n+    fail_unless!((20i16 == NumCast::from(20i8)));\n+    fail_unless!((20i16 == NumCast::from(20i16)));\n+    fail_unless!((20i16 == NumCast::from(20i32)));\n+    fail_unless!((20i16 == NumCast::from(20i64)));\n+    fail_unless!((20i16 == NumCast::from(20f)));\n+    fail_unless!((20i16 == NumCast::from(20f32)));\n+    fail_unless!((20i16 == NumCast::from(20f64)));\n \n-    assert (20i16 == num::cast(20u));\n-    assert (20i16 == num::cast(20u8));\n-    assert (20i16 == num::cast(20u16));\n-    assert (20i16 == num::cast(20u32));\n-    assert (20i16 == num::cast(20u64));\n-    assert (20i16 == num::cast(20i));\n-    assert (20i16 == num::cast(20i8));\n-    assert (20i16 == num::cast(20i16));\n-    assert (20i16 == num::cast(20i32));\n-    assert (20i16 == num::cast(20i64));\n-    assert (20i16 == num::cast(20f));\n-    assert (20i16 == num::cast(20f32));\n-    assert (20i16 == num::cast(20f64));\n+    fail_unless!((20i16 == num::cast(20u)));\n+    fail_unless!((20i16 == num::cast(20u8)));\n+    fail_unless!((20i16 == num::cast(20u16)));\n+    fail_unless!((20i16 == num::cast(20u32)));\n+    fail_unless!((20i16 == num::cast(20u64)));\n+    fail_unless!((20i16 == num::cast(20i)));\n+    fail_unless!((20i16 == num::cast(20i8)));\n+    fail_unless!((20i16 == num::cast(20i16)));\n+    fail_unless!((20i16 == num::cast(20i32)));\n+    fail_unless!((20i16 == num::cast(20i64)));\n+    fail_unless!((20i16 == num::cast(20f)));\n+    fail_unless!((20i16 == num::cast(20f32)));\n+    fail_unless!((20i16 == num::cast(20f64)));\n }"}, {"sha": "30eb4437d570113611b08313371177649513d1a3", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i32 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i32.to_uint());\n-    assert (20u8  == 20i32.to_u8());\n-    assert (20u16 == 20i32.to_u16());\n-    assert (20u32 == 20i32.to_u32());\n-    assert (20u64 == 20i32.to_u64());\n-    assert (20i   == 20i32.to_int());\n-    assert (20i8  == 20i32.to_i8());\n-    assert (20i16 == 20i32.to_i16());\n-    assert (20i32 == 20i32.to_i32());\n-    assert (20i64 == 20i32.to_i64());\n-    assert (20f   == 20i32.to_float());\n-    assert (20f32 == 20i32.to_f32());\n-    assert (20f64 == 20i32.to_f64());\n+    fail_unless!((20u   == 20i32.to_uint()));\n+    fail_unless!((20u8  == 20i32.to_u8()));\n+    fail_unless!((20u16 == 20i32.to_u16()));\n+    fail_unless!((20u32 == 20i32.to_u32()));\n+    fail_unless!((20u64 == 20i32.to_u64()));\n+    fail_unless!((20i   == 20i32.to_int()));\n+    fail_unless!((20i8  == 20i32.to_i8()));\n+    fail_unless!((20i16 == 20i32.to_i16()));\n+    fail_unless!((20i32 == 20i32.to_i32()));\n+    fail_unless!((20i64 == 20i32.to_i64()));\n+    fail_unless!((20f   == 20i32.to_float()));\n+    fail_unless!((20f32 == 20i32.to_f32()));\n+    fail_unless!((20f64 == 20i32.to_f64()));\n \n-    assert (20i32 == NumCast::from(20u));\n-    assert (20i32 == NumCast::from(20u8));\n-    assert (20i32 == NumCast::from(20u16));\n-    assert (20i32 == NumCast::from(20u32));\n-    assert (20i32 == NumCast::from(20u64));\n-    assert (20i32 == NumCast::from(20i));\n-    assert (20i32 == NumCast::from(20i8));\n-    assert (20i32 == NumCast::from(20i16));\n-    assert (20i32 == NumCast::from(20i32));\n-    assert (20i32 == NumCast::from(20i64));\n-    assert (20i32 == NumCast::from(20f));\n-    assert (20i32 == NumCast::from(20f32));\n-    assert (20i32 == NumCast::from(20f64));\n+    fail_unless!((20i32 == NumCast::from(20u)));\n+    fail_unless!((20i32 == NumCast::from(20u8)));\n+    fail_unless!((20i32 == NumCast::from(20u16)));\n+    fail_unless!((20i32 == NumCast::from(20u32)));\n+    fail_unless!((20i32 == NumCast::from(20u64)));\n+    fail_unless!((20i32 == NumCast::from(20i)));\n+    fail_unless!((20i32 == NumCast::from(20i8)));\n+    fail_unless!((20i32 == NumCast::from(20i16)));\n+    fail_unless!((20i32 == NumCast::from(20i32)));\n+    fail_unless!((20i32 == NumCast::from(20i64)));\n+    fail_unless!((20i32 == NumCast::from(20f)));\n+    fail_unless!((20i32 == NumCast::from(20f32)));\n+    fail_unless!((20i32 == NumCast::from(20f64)));\n \n-    assert (20i32 == num::cast(20u));\n-    assert (20i32 == num::cast(20u8));\n-    assert (20i32 == num::cast(20u16));\n-    assert (20i32 == num::cast(20u32));\n-    assert (20i32 == num::cast(20u64));\n-    assert (20i32 == num::cast(20i));\n-    assert (20i32 == num::cast(20i8));\n-    assert (20i32 == num::cast(20i16));\n-    assert (20i32 == num::cast(20i32));\n-    assert (20i32 == num::cast(20i64));\n-    assert (20i32 == num::cast(20f));\n-    assert (20i32 == num::cast(20f32));\n-    assert (20i32 == num::cast(20f64));\n+    fail_unless!((20i32 == num::cast(20u)));\n+    fail_unless!((20i32 == num::cast(20u8)));\n+    fail_unless!((20i32 == num::cast(20u16)));\n+    fail_unless!((20i32 == num::cast(20u32)));\n+    fail_unless!((20i32 == num::cast(20u64)));\n+    fail_unless!((20i32 == num::cast(20i)));\n+    fail_unless!((20i32 == num::cast(20i8)));\n+    fail_unless!((20i32 == num::cast(20i16)));\n+    fail_unless!((20i32 == num::cast(20i32)));\n+    fail_unless!((20i32 == num::cast(20i64)));\n+    fail_unless!((20i32 == num::cast(20f)));\n+    fail_unless!((20i32 == num::cast(20f32)));\n+    fail_unless!((20i32 == num::cast(20f64)));\n }"}, {"sha": "61736cf958743783abb182c58ccc439c629fd83a", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i64 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i64.to_uint());\n-    assert (20u8  == 20i64.to_u8());\n-    assert (20u16 == 20i64.to_u16());\n-    assert (20u32 == 20i64.to_u32());\n-    assert (20u64 == 20i64.to_u64());\n-    assert (20i   == 20i64.to_int());\n-    assert (20i8  == 20i64.to_i8());\n-    assert (20i16 == 20i64.to_i16());\n-    assert (20i32 == 20i64.to_i32());\n-    assert (20i64 == 20i64.to_i64());\n-    assert (20f   == 20i64.to_float());\n-    assert (20f32 == 20i64.to_f32());\n-    assert (20f64 == 20i64.to_f64());\n+    fail_unless!((20u   == 20i64.to_uint()));\n+    fail_unless!((20u8  == 20i64.to_u8()));\n+    fail_unless!((20u16 == 20i64.to_u16()));\n+    fail_unless!((20u32 == 20i64.to_u32()));\n+    fail_unless!((20u64 == 20i64.to_u64()));\n+    fail_unless!((20i   == 20i64.to_int()));\n+    fail_unless!((20i8  == 20i64.to_i8()));\n+    fail_unless!((20i16 == 20i64.to_i16()));\n+    fail_unless!((20i32 == 20i64.to_i32()));\n+    fail_unless!((20i64 == 20i64.to_i64()));\n+    fail_unless!((20f   == 20i64.to_float()));\n+    fail_unless!((20f32 == 20i64.to_f32()));\n+    fail_unless!((20f64 == 20i64.to_f64()));\n \n-    assert (20i64 == NumCast::from(20u));\n-    assert (20i64 == NumCast::from(20u8));\n-    assert (20i64 == NumCast::from(20u16));\n-    assert (20i64 == NumCast::from(20u32));\n-    assert (20i64 == NumCast::from(20u64));\n-    assert (20i64 == NumCast::from(20i));\n-    assert (20i64 == NumCast::from(20i8));\n-    assert (20i64 == NumCast::from(20i16));\n-    assert (20i64 == NumCast::from(20i32));\n-    assert (20i64 == NumCast::from(20i64));\n-    assert (20i64 == NumCast::from(20f));\n-    assert (20i64 == NumCast::from(20f32));\n-    assert (20i64 == NumCast::from(20f64));\n+    fail_unless!((20i64 == NumCast::from(20u)));\n+    fail_unless!((20i64 == NumCast::from(20u8)));\n+    fail_unless!((20i64 == NumCast::from(20u16)));\n+    fail_unless!((20i64 == NumCast::from(20u32)));\n+    fail_unless!((20i64 == NumCast::from(20u64)));\n+    fail_unless!((20i64 == NumCast::from(20i)));\n+    fail_unless!((20i64 == NumCast::from(20i8)));\n+    fail_unless!((20i64 == NumCast::from(20i16)));\n+    fail_unless!((20i64 == NumCast::from(20i32)));\n+    fail_unless!((20i64 == NumCast::from(20i64)));\n+    fail_unless!((20i64 == NumCast::from(20f)));\n+    fail_unless!((20i64 == NumCast::from(20f32)));\n+    fail_unless!((20i64 == NumCast::from(20f64)));\n \n-    assert (20i64 == num::cast(20u));\n-    assert (20i64 == num::cast(20u8));\n-    assert (20i64 == num::cast(20u16));\n-    assert (20i64 == num::cast(20u32));\n-    assert (20i64 == num::cast(20u64));\n-    assert (20i64 == num::cast(20i));\n-    assert (20i64 == num::cast(20i8));\n-    assert (20i64 == num::cast(20i16));\n-    assert (20i64 == num::cast(20i32));\n-    assert (20i64 == num::cast(20i64));\n-    assert (20i64 == num::cast(20f));\n-    assert (20i64 == num::cast(20f32));\n-    assert (20i64 == num::cast(20f64));\n+    fail_unless!((20i64 == num::cast(20u)));\n+    fail_unless!((20i64 == num::cast(20u8)));\n+    fail_unless!((20i64 == num::cast(20u16)));\n+    fail_unless!((20i64 == num::cast(20u32)));\n+    fail_unless!((20i64 == num::cast(20u64)));\n+    fail_unless!((20i64 == num::cast(20i)));\n+    fail_unless!((20i64 == num::cast(20i8)));\n+    fail_unless!((20i64 == num::cast(20i16)));\n+    fail_unless!((20i64 == num::cast(20i32)));\n+    fail_unless!((20i64 == num::cast(20i64)));\n+    fail_unless!((20i64 == num::cast(20f)));\n+    fail_unless!((20i64 == num::cast(20f32)));\n+    fail_unless!((20i64 == num::cast(20f64)));\n }"}, {"sha": "e70811adff1c0162e494c50bfe1ae21a3a5f5de2", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i8 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i8.to_uint());\n-    assert (20u8  == 20i8.to_u8());\n-    assert (20u16 == 20i8.to_u16());\n-    assert (20u32 == 20i8.to_u32());\n-    assert (20u64 == 20i8.to_u64());\n-    assert (20i   == 20i8.to_int());\n-    assert (20i8  == 20i8.to_i8());\n-    assert (20i16 == 20i8.to_i16());\n-    assert (20i32 == 20i8.to_i32());\n-    assert (20i64 == 20i8.to_i64());\n-    assert (20f   == 20i8.to_float());\n-    assert (20f32 == 20i8.to_f32());\n-    assert (20f64 == 20i8.to_f64());\n+    fail_unless!((20u   == 20i8.to_uint()));\n+    fail_unless!((20u8  == 20i8.to_u8()));\n+    fail_unless!((20u16 == 20i8.to_u16()));\n+    fail_unless!((20u32 == 20i8.to_u32()));\n+    fail_unless!((20u64 == 20i8.to_u64()));\n+    fail_unless!((20i   == 20i8.to_int()));\n+    fail_unless!((20i8  == 20i8.to_i8()));\n+    fail_unless!((20i16 == 20i8.to_i16()));\n+    fail_unless!((20i32 == 20i8.to_i32()));\n+    fail_unless!((20i64 == 20i8.to_i64()));\n+    fail_unless!((20f   == 20i8.to_float()));\n+    fail_unless!((20f32 == 20i8.to_f32()));\n+    fail_unless!((20f64 == 20i8.to_f64()));\n \n-    assert (20i8 == NumCast::from(20u));\n-    assert (20i8 == NumCast::from(20u8));\n-    assert (20i8 == NumCast::from(20u16));\n-    assert (20i8 == NumCast::from(20u32));\n-    assert (20i8 == NumCast::from(20u64));\n-    assert (20i8 == NumCast::from(20i));\n-    assert (20i8 == NumCast::from(20i8));\n-    assert (20i8 == NumCast::from(20i16));\n-    assert (20i8 == NumCast::from(20i32));\n-    assert (20i8 == NumCast::from(20i64));\n-    assert (20i8 == NumCast::from(20f));\n-    assert (20i8 == NumCast::from(20f32));\n-    assert (20i8 == NumCast::from(20f64));\n+    fail_unless!((20i8 == NumCast::from(20u)));\n+    fail_unless!((20i8 == NumCast::from(20u8)));\n+    fail_unless!((20i8 == NumCast::from(20u16)));\n+    fail_unless!((20i8 == NumCast::from(20u32)));\n+    fail_unless!((20i8 == NumCast::from(20u64)));\n+    fail_unless!((20i8 == NumCast::from(20i)));\n+    fail_unless!((20i8 == NumCast::from(20i8)));\n+    fail_unless!((20i8 == NumCast::from(20i16)));\n+    fail_unless!((20i8 == NumCast::from(20i32)));\n+    fail_unless!((20i8 == NumCast::from(20i64)));\n+    fail_unless!((20i8 == NumCast::from(20f)));\n+    fail_unless!((20i8 == NumCast::from(20f32)));\n+    fail_unless!((20i8 == NumCast::from(20f64)));\n \n-    assert (20i8 == num::cast(20u));\n-    assert (20i8 == num::cast(20u8));\n-    assert (20i8 == num::cast(20u16));\n-    assert (20i8 == num::cast(20u32));\n-    assert (20i8 == num::cast(20u64));\n-    assert (20i8 == num::cast(20i));\n-    assert (20i8 == num::cast(20i8));\n-    assert (20i8 == num::cast(20i16));\n-    assert (20i8 == num::cast(20i32));\n-    assert (20i8 == num::cast(20i64));\n-    assert (20i8 == num::cast(20f));\n-    assert (20i8 == num::cast(20f32));\n-    assert (20i8 == num::cast(20f64));\n+    fail_unless!((20i8 == num::cast(20u)));\n+    fail_unless!((20i8 == num::cast(20u8)));\n+    fail_unless!((20i8 == num::cast(20u16)));\n+    fail_unless!((20i8 == num::cast(20u32)));\n+    fail_unless!((20i8 == num::cast(20u64)));\n+    fail_unless!((20i8 == num::cast(20i)));\n+    fail_unless!((20i8 == num::cast(20i8)));\n+    fail_unless!((20i8 == num::cast(20i16)));\n+    fail_unless!((20i8 == num::cast(20i32)));\n+    fail_unless!((20i8 == num::cast(20i64)));\n+    fail_unless!((20i8 == num::cast(20f)));\n+    fail_unless!((20i8 == num::cast(20f32)));\n+    fail_unless!((20i8 == num::cast(20f64)));\n }"}, {"sha": "f007cc5b119fb873375c2a1ba3eff608ba70037d", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -40,21 +40,21 @@ mod inst {\n \n     #[test]\n     fn test_pow() {\n-        assert (pow(0, 0u) == 1);\n-        assert (pow(0, 1u) == 0);\n-        assert (pow(0, 2u) == 0);\n-        assert (pow(-1, 0u) == 1);\n-        assert (pow(1, 0u) == 1);\n-        assert (pow(-3, 2u) == 9);\n-        assert (pow(-3, 3u) == -27);\n-        assert (pow(4, 9u) == 262144);\n+        fail_unless!((pow(0, 0u) == 1));\n+        fail_unless!((pow(0, 1u) == 0));\n+        fail_unless!((pow(0, 2u) == 0));\n+        fail_unless!((pow(-1, 0u) == 1));\n+        fail_unless!((pow(1, 0u) == 1));\n+        fail_unless!((pow(-3, 2u) == 9));\n+        fail_unless!((pow(-3, 3u) == -27));\n+        fail_unless!((pow(4, 9u) == 262144));\n     }\n \n     #[test]\n     fn test_overflows() {\n-        assert (::int::max_value > 0);\n-        assert (::int::min_value <= 0);\n-        assert (::int::min_value + ::int::max_value + 1 == 0);\n+        fail_unless!((::int::max_value > 0));\n+        fail_unless!((::int::min_value <= 0));\n+        fail_unless!((::int::min_value + ::int::max_value + 1 == 0));\n     }\n }\n \n@@ -84,45 +84,45 @@ impl NumCast for int {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i.to_uint());\n-    assert (20u8  == 20i.to_u8());\n-    assert (20u16 == 20i.to_u16());\n-    assert (20u32 == 20i.to_u32());\n-    assert (20u64 == 20i.to_u64());\n-    assert (20i   == 20i.to_int());\n-    assert (20i8  == 20i.to_i8());\n-    assert (20i16 == 20i.to_i16());\n-    assert (20i32 == 20i.to_i32());\n-    assert (20i64 == 20i.to_i64());\n-    assert (20f   == 20i.to_float());\n-    assert (20f32 == 20i.to_f32());\n-    assert (20f64 == 20i.to_f64());\n+    fail_unless!((20u   == 20i.to_uint()));\n+    fail_unless!((20u8  == 20i.to_u8()));\n+    fail_unless!((20u16 == 20i.to_u16()));\n+    fail_unless!((20u32 == 20i.to_u32()));\n+    fail_unless!((20u64 == 20i.to_u64()));\n+    fail_unless!((20i   == 20i.to_int()));\n+    fail_unless!((20i8  == 20i.to_i8()));\n+    fail_unless!((20i16 == 20i.to_i16()));\n+    fail_unless!((20i32 == 20i.to_i32()));\n+    fail_unless!((20i64 == 20i.to_i64()));\n+    fail_unless!((20f   == 20i.to_float()));\n+    fail_unless!((20f32 == 20i.to_f32()));\n+    fail_unless!((20f64 == 20i.to_f64()));\n \n-    assert (20i == NumCast::from(20u));\n-    assert (20i == NumCast::from(20u8));\n-    assert (20i == NumCast::from(20u16));\n-    assert (20i == NumCast::from(20u32));\n-    assert (20i == NumCast::from(20u64));\n-    assert (20i == NumCast::from(20i));\n-    assert (20i == NumCast::from(20i8));\n-    assert (20i == NumCast::from(20i16));\n-    assert (20i == NumCast::from(20i32));\n-    assert (20i == NumCast::from(20i64));\n-    assert (20i == NumCast::from(20f));\n-    assert (20i == NumCast::from(20f32));\n-    assert (20i == NumCast::from(20f64));\n+    fail_unless!((20i == NumCast::from(20u)));\n+    fail_unless!((20i == NumCast::from(20u8)));\n+    fail_unless!((20i == NumCast::from(20u16)));\n+    fail_unless!((20i == NumCast::from(20u32)));\n+    fail_unless!((20i == NumCast::from(20u64)));\n+    fail_unless!((20i == NumCast::from(20i)));\n+    fail_unless!((20i == NumCast::from(20i8)));\n+    fail_unless!((20i == NumCast::from(20i16)));\n+    fail_unless!((20i == NumCast::from(20i32)));\n+    fail_unless!((20i == NumCast::from(20i64)));\n+    fail_unless!((20i == NumCast::from(20f)));\n+    fail_unless!((20i == NumCast::from(20f32)));\n+    fail_unless!((20i == NumCast::from(20f64)));\n \n-    assert (20i == num::cast(20u));\n-    assert (20i == num::cast(20u8));\n-    assert (20i == num::cast(20u16));\n-    assert (20i == num::cast(20u32));\n-    assert (20i == num::cast(20u64));\n-    assert (20i == num::cast(20i));\n-    assert (20i == num::cast(20i8));\n-    assert (20i == num::cast(20i16));\n-    assert (20i == num::cast(20i32));\n-    assert (20i == num::cast(20i64));\n-    assert (20i == num::cast(20f));\n-    assert (20i == num::cast(20f32));\n-    assert (20i == num::cast(20f64));\n+    fail_unless!((20i == num::cast(20u)));\n+    fail_unless!((20i == num::cast(20u8)));\n+    fail_unless!((20i == num::cast(20u16)));\n+    fail_unless!((20i == num::cast(20u32)));\n+    fail_unless!((20i == num::cast(20u64)));\n+    fail_unless!((20i == num::cast(20i)));\n+    fail_unless!((20i == num::cast(20i8)));\n+    fail_unless!((20i == num::cast(20i16)));\n+    fail_unless!((20i == num::cast(20i32)));\n+    fail_unless!((20i == num::cast(20i64)));\n+    fail_unless!((20i == num::cast(20f)));\n+    fail_unless!((20i == num::cast(20f32)));\n+    fail_unless!((20i == num::cast(20f64)));\n }"}, {"sha": "a462aed8be0d19004fb8af8d6b1489417d216815", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -55,7 +55,7 @@ pub enum RoundMode {\n  *\n  * ~~~\n  * let twenty: f32 = num::cast(0x14);\n- * assert twenty == 20f32;\n+ * fail_unless!(twenty == 20f32);\n  * ~~~\n  */\n #[inline(always)]"}, {"sha": "11bd7dbfd3ad94dca3cb206885e7379f3594a9c2", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -238,102 +238,104 @@ impl ToStrRadix for T {\n \n #[test]\n pub fn test_to_str() {\n-    assert to_str_radix(0 as T, 10u) == ~\"0\";\n-    assert to_str_radix(1 as T, 10u) == ~\"1\";\n-    assert to_str_radix(2 as T, 10u) == ~\"2\";\n-    assert to_str_radix(11 as T, 10u) == ~\"11\";\n-    assert to_str_radix(11 as T, 16u) == ~\"b\";\n-    assert to_str_radix(255 as T, 16u) == ~\"ff\";\n-    assert to_str_radix(0xff as T, 10u) == ~\"255\";\n+    fail_unless!(to_str_radix(0 as T, 10u) == ~\"0\");\n+    fail_unless!(to_str_radix(1 as T, 10u) == ~\"1\");\n+    fail_unless!(to_str_radix(2 as T, 10u) == ~\"2\");\n+    fail_unless!(to_str_radix(11 as T, 10u) == ~\"11\");\n+    fail_unless!(to_str_radix(11 as T, 16u) == ~\"b\");\n+    fail_unless!(to_str_radix(255 as T, 16u) == ~\"ff\");\n+    fail_unless!(to_str_radix(0xff as T, 10u) == ~\"255\");\n }\n \n #[test]\n pub fn test_from_str() {\n-    assert from_str(~\"0\") == Some(0u as T);\n-    assert from_str(~\"3\") == Some(3u as T);\n-    assert from_str(~\"10\") == Some(10u as T);\n-    assert u32::from_str(~\"123456789\") == Some(123456789 as u32);\n-    assert from_str(~\"00100\") == Some(100u as T);\n+    fail_unless!(from_str(~\"0\") == Some(0u as T));\n+    fail_unless!(from_str(~\"3\") == Some(3u as T));\n+    fail_unless!(from_str(~\"10\") == Some(10u as T));\n+    fail_unless!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n+    fail_unless!(from_str(~\"00100\") == Some(100u as T));\n \n-    assert from_str(~\"\").is_none();\n-    assert from_str(~\" \").is_none();\n-    assert from_str(~\"x\").is_none();\n+    fail_unless!(from_str(~\"\").is_none());\n+    fail_unless!(from_str(~\" \").is_none());\n+    fail_unless!(from_str(~\"x\").is_none());\n }\n \n #[test]\n pub fn test_parse_bytes() {\n     use str::to_bytes;\n-    assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T);\n-    assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T);\n-    assert parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T);\n-    assert u16::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291u as u16);\n-    assert u16::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535u as u16);\n-    assert parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T);\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n+    fail_unless!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n+                 Some(291u as u16));\n+    fail_unless!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+                 Some(65535u as u16));\n+    fail_unless!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n \n-    assert parse_bytes(to_bytes(~\"Z\"), 10u).is_none();\n-    assert parse_bytes(to_bytes(~\"_\"), 2u).is_none();\n+    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n+    fail_unless!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n }\n \n #[test]\n fn test_uint_to_str_overflow() {\n     let mut u8_val: u8 = 255_u8;\n-    assert (u8::to_str(u8_val) == ~\"255\");\n+    fail_unless!((u8::to_str(u8_val) == ~\"255\"));\n \n     u8_val += 1 as u8;\n-    assert (u8::to_str(u8_val) == ~\"0\");\n+    fail_unless!((u8::to_str(u8_val) == ~\"0\"));\n \n     let mut u16_val: u16 = 65_535_u16;\n-    assert (u16::to_str(u16_val) == ~\"65535\");\n+    fail_unless!((u16::to_str(u16_val) == ~\"65535\"));\n \n     u16_val += 1 as u16;\n-    assert (u16::to_str(u16_val) == ~\"0\");\n+    fail_unless!((u16::to_str(u16_val) == ~\"0\"));\n \n     let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert (u32::to_str(u32_val) == ~\"4294967295\");\n+    fail_unless!((u32::to_str(u32_val) == ~\"4294967295\"));\n \n     u32_val += 1 as u32;\n-    assert (u32::to_str(u32_val) == ~\"0\");\n+    fail_unless!((u32::to_str(u32_val) == ~\"0\"));\n \n     let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert (u64::to_str(u64_val) == ~\"18446744073709551615\");\n+    fail_unless!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n \n     u64_val += 1 as u64;\n-    assert (u64::to_str(u64_val) == ~\"0\");\n+    fail_unless!((u64::to_str(u64_val) == ~\"0\"));\n }\n \n #[test]\n fn test_uint_from_str_overflow() {\n     let mut u8_val: u8 = 255_u8;\n-    assert (u8::from_str(~\"255\") == Some(u8_val));\n-    assert (u8::from_str(~\"256\").is_none());\n+    fail_unless!((u8::from_str(~\"255\") == Some(u8_val)));\n+    fail_unless!((u8::from_str(~\"256\").is_none()));\n \n     u8_val += 1 as u8;\n-    assert (u8::from_str(~\"0\") == Some(u8_val));\n-    assert (u8::from_str(~\"-1\").is_none());\n+    fail_unless!((u8::from_str(~\"0\") == Some(u8_val)));\n+    fail_unless!((u8::from_str(~\"-1\").is_none()));\n \n     let mut u16_val: u16 = 65_535_u16;\n-    assert (u16::from_str(~\"65535\") == Some(u16_val));\n-    assert (u16::from_str(~\"65536\").is_none());\n+    fail_unless!((u16::from_str(~\"65535\") == Some(u16_val)));\n+    fail_unless!((u16::from_str(~\"65536\").is_none()));\n \n     u16_val += 1 as u16;\n-    assert (u16::from_str(~\"0\") == Some(u16_val));\n-    assert (u16::from_str(~\"-1\").is_none());\n+    fail_unless!((u16::from_str(~\"0\") == Some(u16_val)));\n+    fail_unless!((u16::from_str(~\"-1\").is_none()));\n \n     let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert (u32::from_str(~\"4294967295\") == Some(u32_val));\n-    assert (u32::from_str(~\"4294967296\").is_none());\n+    fail_unless!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n+    fail_unless!((u32::from_str(~\"4294967296\").is_none()));\n \n     u32_val += 1 as u32;\n-    assert (u32::from_str(~\"0\") == Some(u32_val));\n-    assert (u32::from_str(~\"-1\").is_none());\n+    fail_unless!((u32::from_str(~\"0\") == Some(u32_val)));\n+    fail_unless!((u32::from_str(~\"-1\").is_none()));\n \n     let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert (u64::from_str(~\"18446744073709551615\") == Some(u64_val));\n-    assert (u64::from_str(~\"18446744073709551616\").is_none());\n+    fail_unless!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n+    fail_unless!((u64::from_str(~\"18446744073709551616\").is_none()));\n \n     u64_val += 1 as u64;\n-    assert (u64::from_str(~\"0\") == Some(u64_val));\n-    assert (u64::from_str(~\"-1\").is_none());\n+    fail_unless!((u64::from_str(~\"0\") == Some(u64_val)));\n+    fail_unless!((u64::from_str(~\"-1\").is_none()));\n }\n \n #[test]\n@@ -367,10 +369,10 @@ pub fn test_ranges() {\n         l.push(i);\n     }\n \n-    assert l == ~[0,1,2,\n-                  13,12,11,\n-                  20,22,24,\n-                  36,34,32];\n+    fail_unless!(l == ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32]);\n \n     // None of the `fail`s should execute.\n     for range(0,0) |_i| {\n@@ -392,11 +394,11 @@ pub fn test_num() {\n     let ten: T = num::cast(10);\n     let two: T = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]"}, {"sha": "16a1d6209295a1407242885308889a4fc909a3e1", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u16 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u16.to_uint());\n-    assert (20u8  == 20u16.to_u8());\n-    assert (20u16 == 20u16.to_u16());\n-    assert (20u32 == 20u16.to_u32());\n-    assert (20u64 == 20u16.to_u64());\n-    assert (20i   == 20u16.to_int());\n-    assert (20i8  == 20u16.to_i8());\n-    assert (20i16 == 20u16.to_i16());\n-    assert (20i32 == 20u16.to_i32());\n-    assert (20i64 == 20u16.to_i64());\n-    assert (20f   == 20u16.to_float());\n-    assert (20f32 == 20u16.to_f32());\n-    assert (20f64 == 20u16.to_f64());\n+    fail_unless!((20u   == 20u16.to_uint()));\n+    fail_unless!((20u8  == 20u16.to_u8()));\n+    fail_unless!((20u16 == 20u16.to_u16()));\n+    fail_unless!((20u32 == 20u16.to_u32()));\n+    fail_unless!((20u64 == 20u16.to_u64()));\n+    fail_unless!((20i   == 20u16.to_int()));\n+    fail_unless!((20i8  == 20u16.to_i8()));\n+    fail_unless!((20i16 == 20u16.to_i16()));\n+    fail_unless!((20i32 == 20u16.to_i32()));\n+    fail_unless!((20i64 == 20u16.to_i64()));\n+    fail_unless!((20f   == 20u16.to_float()));\n+    fail_unless!((20f32 == 20u16.to_f32()));\n+    fail_unless!((20f64 == 20u16.to_f64()));\n \n-    assert (20u16 == NumCast::from(20u));\n-    assert (20u16 == NumCast::from(20u8));\n-    assert (20u16 == NumCast::from(20u16));\n-    assert (20u16 == NumCast::from(20u32));\n-    assert (20u16 == NumCast::from(20u64));\n-    assert (20u16 == NumCast::from(20i));\n-    assert (20u16 == NumCast::from(20i8));\n-    assert (20u16 == NumCast::from(20i16));\n-    assert (20u16 == NumCast::from(20i32));\n-    assert (20u16 == NumCast::from(20i64));\n-    assert (20u16 == NumCast::from(20f));\n-    assert (20u16 == NumCast::from(20f32));\n-    assert (20u16 == NumCast::from(20f64));\n+    fail_unless!((20u16 == NumCast::from(20u)));\n+    fail_unless!((20u16 == NumCast::from(20u8)));\n+    fail_unless!((20u16 == NumCast::from(20u16)));\n+    fail_unless!((20u16 == NumCast::from(20u32)));\n+    fail_unless!((20u16 == NumCast::from(20u64)));\n+    fail_unless!((20u16 == NumCast::from(20i)));\n+    fail_unless!((20u16 == NumCast::from(20i8)));\n+    fail_unless!((20u16 == NumCast::from(20i16)));\n+    fail_unless!((20u16 == NumCast::from(20i32)));\n+    fail_unless!((20u16 == NumCast::from(20i64)));\n+    fail_unless!((20u16 == NumCast::from(20f)));\n+    fail_unless!((20u16 == NumCast::from(20f32)));\n+    fail_unless!((20u16 == NumCast::from(20f64)));\n \n-    assert (20u16 == num::cast(20u));\n-    assert (20u16 == num::cast(20u8));\n-    assert (20u16 == num::cast(20u16));\n-    assert (20u16 == num::cast(20u32));\n-    assert (20u16 == num::cast(20u64));\n-    assert (20u16 == num::cast(20i));\n-    assert (20u16 == num::cast(20i8));\n-    assert (20u16 == num::cast(20i16));\n-    assert (20u16 == num::cast(20i32));\n-    assert (20u16 == num::cast(20i64));\n-    assert (20u16 == num::cast(20f));\n-    assert (20u16 == num::cast(20f32));\n-    assert (20u16 == num::cast(20f64));\n+    fail_unless!((20u16 == num::cast(20u)));\n+    fail_unless!((20u16 == num::cast(20u8)));\n+    fail_unless!((20u16 == num::cast(20u16)));\n+    fail_unless!((20u16 == num::cast(20u32)));\n+    fail_unless!((20u16 == num::cast(20u64)));\n+    fail_unless!((20u16 == num::cast(20i)));\n+    fail_unless!((20u16 == num::cast(20i8)));\n+    fail_unless!((20u16 == num::cast(20i16)));\n+    fail_unless!((20u16 == num::cast(20i32)));\n+    fail_unless!((20u16 == num::cast(20i64)));\n+    fail_unless!((20u16 == num::cast(20f)));\n+    fail_unless!((20u16 == num::cast(20f32)));\n+    fail_unless!((20u16 == num::cast(20f64)));\n }"}, {"sha": "cf92feb6427f402c2525e96a523314a9499a7ebb", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u32 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u64.to_uint());\n-    assert (20u8  == 20u64.to_u8());\n-    assert (20u16 == 20u64.to_u16());\n-    assert (20u32 == 20u64.to_u32());\n-    assert (20u64 == 20u64.to_u64());\n-    assert (20i   == 20u64.to_int());\n-    assert (20i8  == 20u64.to_i8());\n-    assert (20i16 == 20u64.to_i16());\n-    assert (20i32 == 20u64.to_i32());\n-    assert (20i64 == 20u64.to_i64());\n-    assert (20f   == 20u64.to_float());\n-    assert (20f32 == 20u64.to_f32());\n-    assert (20f64 == 20u64.to_f64());\n+    fail_unless!((20u   == 20u64.to_uint()));\n+    fail_unless!((20u8  == 20u64.to_u8()));\n+    fail_unless!((20u16 == 20u64.to_u16()));\n+    fail_unless!((20u32 == 20u64.to_u32()));\n+    fail_unless!((20u64 == 20u64.to_u64()));\n+    fail_unless!((20i   == 20u64.to_int()));\n+    fail_unless!((20i8  == 20u64.to_i8()));\n+    fail_unless!((20i16 == 20u64.to_i16()));\n+    fail_unless!((20i32 == 20u64.to_i32()));\n+    fail_unless!((20i64 == 20u64.to_i64()));\n+    fail_unless!((20f   == 20u64.to_float()));\n+    fail_unless!((20f32 == 20u64.to_f32()));\n+    fail_unless!((20f64 == 20u64.to_f64()));\n \n-    assert (20u64 == NumCast::from(20u));\n-    assert (20u64 == NumCast::from(20u8));\n-    assert (20u64 == NumCast::from(20u16));\n-    assert (20u64 == NumCast::from(20u32));\n-    assert (20u64 == NumCast::from(20u64));\n-    assert (20u64 == NumCast::from(20i));\n-    assert (20u64 == NumCast::from(20i8));\n-    assert (20u64 == NumCast::from(20i16));\n-    assert (20u64 == NumCast::from(20i32));\n-    assert (20u64 == NumCast::from(20i64));\n-    assert (20u64 == NumCast::from(20f));\n-    assert (20u64 == NumCast::from(20f32));\n-    assert (20u64 == NumCast::from(20f64));\n+    fail_unless!((20u64 == NumCast::from(20u)));\n+    fail_unless!((20u64 == NumCast::from(20u8)));\n+    fail_unless!((20u64 == NumCast::from(20u16)));\n+    fail_unless!((20u64 == NumCast::from(20u32)));\n+    fail_unless!((20u64 == NumCast::from(20u64)));\n+    fail_unless!((20u64 == NumCast::from(20i)));\n+    fail_unless!((20u64 == NumCast::from(20i8)));\n+    fail_unless!((20u64 == NumCast::from(20i16)));\n+    fail_unless!((20u64 == NumCast::from(20i32)));\n+    fail_unless!((20u64 == NumCast::from(20i64)));\n+    fail_unless!((20u64 == NumCast::from(20f)));\n+    fail_unless!((20u64 == NumCast::from(20f32)));\n+    fail_unless!((20u64 == NumCast::from(20f64)));\n \n-    assert (20u64 == num::cast(20u));\n-    assert (20u64 == num::cast(20u8));\n-    assert (20u64 == num::cast(20u16));\n-    assert (20u64 == num::cast(20u32));\n-    assert (20u64 == num::cast(20u64));\n-    assert (20u64 == num::cast(20i));\n-    assert (20u64 == num::cast(20i8));\n-    assert (20u64 == num::cast(20i16));\n-    assert (20u64 == num::cast(20i32));\n-    assert (20u64 == num::cast(20i64));\n-    assert (20u64 == num::cast(20f));\n-    assert (20u64 == num::cast(20f32));\n-    assert (20u64 == num::cast(20f64));\n+    fail_unless!((20u64 == num::cast(20u)));\n+    fail_unless!((20u64 == num::cast(20u8)));\n+    fail_unless!((20u64 == num::cast(20u16)));\n+    fail_unless!((20u64 == num::cast(20u32)));\n+    fail_unless!((20u64 == num::cast(20u64)));\n+    fail_unless!((20u64 == num::cast(20i)));\n+    fail_unless!((20u64 == num::cast(20i8)));\n+    fail_unless!((20u64 == num::cast(20i16)));\n+    fail_unless!((20u64 == num::cast(20i32)));\n+    fail_unless!((20u64 == num::cast(20i64)));\n+    fail_unless!((20u64 == num::cast(20f)));\n+    fail_unless!((20u64 == num::cast(20f32)));\n+    fail_unless!((20u64 == num::cast(20f64)));\n }"}, {"sha": "269d8e185f37bd4c936bb7e4da452cabc1ff860b", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u64 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u64.to_uint());\n-    assert (20u8  == 20u64.to_u8());\n-    assert (20u16 == 20u64.to_u16());\n-    assert (20u32 == 20u64.to_u32());\n-    assert (20u64 == 20u64.to_u64());\n-    assert (20i   == 20u64.to_int());\n-    assert (20i8  == 20u64.to_i8());\n-    assert (20i16 == 20u64.to_i16());\n-    assert (20i32 == 20u64.to_i32());\n-    assert (20i64 == 20u64.to_i64());\n-    assert (20f   == 20u64.to_float());\n-    assert (20f32 == 20u64.to_f32());\n-    assert (20f64 == 20u64.to_f64());\n+    fail_unless!((20u   == 20u64.to_uint()));\n+    fail_unless!((20u8  == 20u64.to_u8()));\n+    fail_unless!((20u16 == 20u64.to_u16()));\n+    fail_unless!((20u32 == 20u64.to_u32()));\n+    fail_unless!((20u64 == 20u64.to_u64()));\n+    fail_unless!((20i   == 20u64.to_int()));\n+    fail_unless!((20i8  == 20u64.to_i8()));\n+    fail_unless!((20i16 == 20u64.to_i16()));\n+    fail_unless!((20i32 == 20u64.to_i32()));\n+    fail_unless!((20i64 == 20u64.to_i64()));\n+    fail_unless!((20f   == 20u64.to_float()));\n+    fail_unless!((20f32 == 20u64.to_f32()));\n+    fail_unless!((20f64 == 20u64.to_f64()));\n \n-    assert (20u64 == NumCast::from(20u));\n-    assert (20u64 == NumCast::from(20u8));\n-    assert (20u64 == NumCast::from(20u16));\n-    assert (20u64 == NumCast::from(20u32));\n-    assert (20u64 == NumCast::from(20u64));\n-    assert (20u64 == NumCast::from(20i));\n-    assert (20u64 == NumCast::from(20i8));\n-    assert (20u64 == NumCast::from(20i16));\n-    assert (20u64 == NumCast::from(20i32));\n-    assert (20u64 == NumCast::from(20i64));\n-    assert (20u64 == NumCast::from(20f));\n-    assert (20u64 == NumCast::from(20f32));\n-    assert (20u64 == NumCast::from(20f64));\n+    fail_unless!((20u64 == NumCast::from(20u)));\n+    fail_unless!((20u64 == NumCast::from(20u8)));\n+    fail_unless!((20u64 == NumCast::from(20u16)));\n+    fail_unless!((20u64 == NumCast::from(20u32)));\n+    fail_unless!((20u64 == NumCast::from(20u64)));\n+    fail_unless!((20u64 == NumCast::from(20i)));\n+    fail_unless!((20u64 == NumCast::from(20i8)));\n+    fail_unless!((20u64 == NumCast::from(20i16)));\n+    fail_unless!((20u64 == NumCast::from(20i32)));\n+    fail_unless!((20u64 == NumCast::from(20i64)));\n+    fail_unless!((20u64 == NumCast::from(20f)));\n+    fail_unless!((20u64 == NumCast::from(20f32)));\n+    fail_unless!((20u64 == NumCast::from(20f64)));\n \n-    assert (20u64 == num::cast(20u));\n-    assert (20u64 == num::cast(20u8));\n-    assert (20u64 == num::cast(20u16));\n-    assert (20u64 == num::cast(20u32));\n-    assert (20u64 == num::cast(20u64));\n-    assert (20u64 == num::cast(20i));\n-    assert (20u64 == num::cast(20i8));\n-    assert (20u64 == num::cast(20i16));\n-    assert (20u64 == num::cast(20i32));\n-    assert (20u64 == num::cast(20i64));\n-    assert (20u64 == num::cast(20f));\n-    assert (20u64 == num::cast(20f32));\n-    assert (20u64 == num::cast(20f64));\n+    fail_unless!((20u64 == num::cast(20u)));\n+    fail_unless!((20u64 == num::cast(20u8)));\n+    fail_unless!((20u64 == num::cast(20u16)));\n+    fail_unless!((20u64 == num::cast(20u32)));\n+    fail_unless!((20u64 == num::cast(20u64)));\n+    fail_unless!((20u64 == num::cast(20i)));\n+    fail_unless!((20u64 == num::cast(20i8)));\n+    fail_unless!((20u64 == num::cast(20i16)));\n+    fail_unless!((20u64 == num::cast(20i32)));\n+    fail_unless!((20u64 == num::cast(20i64)));\n+    fail_unless!((20u64 == num::cast(20f)));\n+    fail_unless!((20u64 == num::cast(20f32)));\n+    fail_unless!((20u64 == num::cast(20f64)));\n }"}, {"sha": "44428abdb4ff078a0fd20cee94c605374fa37903", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -52,45 +52,45 @@ impl NumCast for u8 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u     == 20u8.to_uint());\n-    assert (20u8    == 20u8.to_u8());\n-    assert (20u16   == 20u8.to_u16());\n-    assert (20u32   == 20u8.to_u32());\n-    assert (20u64   == 20u8.to_u64());\n-    assert (20i     == 20u8.to_int());\n-    assert (20i8    == 20u8.to_i8());\n-    assert (20i16   == 20u8.to_i16());\n-    assert (20i32   == 20u8.to_i32());\n-    assert (20i64   == 20u8.to_i64());\n-    assert (20f     == 20u8.to_float());\n-    assert (20f32   == 20u8.to_f32());\n-    assert (20f64   == 20u8.to_f64());\n+    fail_unless!((20u     == 20u8.to_uint()));\n+    fail_unless!((20u8    == 20u8.to_u8()));\n+    fail_unless!((20u16   == 20u8.to_u16()));\n+    fail_unless!((20u32   == 20u8.to_u32()));\n+    fail_unless!((20u64   == 20u8.to_u64()));\n+    fail_unless!((20i     == 20u8.to_int()));\n+    fail_unless!((20i8    == 20u8.to_i8()));\n+    fail_unless!((20i16   == 20u8.to_i16()));\n+    fail_unless!((20i32   == 20u8.to_i32()));\n+    fail_unless!((20i64   == 20u8.to_i64()));\n+    fail_unless!((20f     == 20u8.to_float()));\n+    fail_unless!((20f32   == 20u8.to_f32()));\n+    fail_unless!((20f64   == 20u8.to_f64()));\n \n-    assert (20u8 == NumCast::from(20u));\n-    assert (20u8 == NumCast::from(20u8));\n-    assert (20u8 == NumCast::from(20u16));\n-    assert (20u8 == NumCast::from(20u32));\n-    assert (20u8 == NumCast::from(20u64));\n-    assert (20u8 == NumCast::from(20i));\n-    assert (20u8 == NumCast::from(20i8));\n-    assert (20u8 == NumCast::from(20i16));\n-    assert (20u8 == NumCast::from(20i32));\n-    assert (20u8 == NumCast::from(20i64));\n-    assert (20u8 == NumCast::from(20f));\n-    assert (20u8 == NumCast::from(20f32));\n-    assert (20u8 == NumCast::from(20f64));\n+    fail_unless!((20u8 == NumCast::from(20u)));\n+    fail_unless!((20u8 == NumCast::from(20u8)));\n+    fail_unless!((20u8 == NumCast::from(20u16)));\n+    fail_unless!((20u8 == NumCast::from(20u32)));\n+    fail_unless!((20u8 == NumCast::from(20u64)));\n+    fail_unless!((20u8 == NumCast::from(20i)));\n+    fail_unless!((20u8 == NumCast::from(20i8)));\n+    fail_unless!((20u8 == NumCast::from(20i16)));\n+    fail_unless!((20u8 == NumCast::from(20i32)));\n+    fail_unless!((20u8 == NumCast::from(20i64)));\n+    fail_unless!((20u8 == NumCast::from(20f)));\n+    fail_unless!((20u8 == NumCast::from(20f32)));\n+    fail_unless!((20u8 == NumCast::from(20f64)));\n \n-    assert (20u8 == num::cast(20u));\n-    assert (20u8 == num::cast(20u8));\n-    assert (20u8 == num::cast(20u16));\n-    assert (20u8 == num::cast(20u32));\n-    assert (20u8 == num::cast(20u64));\n-    assert (20u8 == num::cast(20i));\n-    assert (20u8 == num::cast(20i8));\n-    assert (20u8 == num::cast(20i16));\n-    assert (20u8 == num::cast(20i32));\n-    assert (20u8 == num::cast(20i64));\n-    assert (20u8 == num::cast(20f));\n-    assert (20u8 == num::cast(20f32));\n-    assert (20u8 == num::cast(20f64));\n+    fail_unless!((20u8 == num::cast(20u)));\n+    fail_unless!((20u8 == num::cast(20u8)));\n+    fail_unless!((20u8 == num::cast(20u16)));\n+    fail_unless!((20u8 == num::cast(20u32)));\n+    fail_unless!((20u8 == num::cast(20u64)));\n+    fail_unless!((20u8 == num::cast(20i)));\n+    fail_unless!((20u8 == num::cast(20i8)));\n+    fail_unless!((20u8 == num::cast(20i16)));\n+    fail_unless!((20u8 == num::cast(20i32)));\n+    fail_unless!((20u8 == num::cast(20i64)));\n+    fail_unless!((20u8 == num::cast(20f)));\n+    fail_unless!((20u8 == num::cast(20f32)));\n+    fail_unless!((20u8 == num::cast(20f64)));\n }"}, {"sha": "6814b0e7541990e6bb88220cd4ad0068ed809df4", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -143,61 +143,61 @@ pub mod inst {\n \n     #[test]\n     fn test_next_power_of_two() {\n-        assert (next_power_of_two(0u) == 0u);\n-        assert (next_power_of_two(1u) == 1u);\n-        assert (next_power_of_two(2u) == 2u);\n-        assert (next_power_of_two(3u) == 4u);\n-        assert (next_power_of_two(4u) == 4u);\n-        assert (next_power_of_two(5u) == 8u);\n-        assert (next_power_of_two(6u) == 8u);\n-        assert (next_power_of_two(7u) == 8u);\n-        assert (next_power_of_two(8u) == 8u);\n-        assert (next_power_of_two(9u) == 16u);\n-        assert (next_power_of_two(10u) == 16u);\n-        assert (next_power_of_two(11u) == 16u);\n-        assert (next_power_of_two(12u) == 16u);\n-        assert (next_power_of_two(13u) == 16u);\n-        assert (next_power_of_two(14u) == 16u);\n-        assert (next_power_of_two(15u) == 16u);\n-        assert (next_power_of_two(16u) == 16u);\n-        assert (next_power_of_two(17u) == 32u);\n-        assert (next_power_of_two(18u) == 32u);\n-        assert (next_power_of_two(19u) == 32u);\n-        assert (next_power_of_two(20u) == 32u);\n-        assert (next_power_of_two(21u) == 32u);\n-        assert (next_power_of_two(22u) == 32u);\n-        assert (next_power_of_two(23u) == 32u);\n-        assert (next_power_of_two(24u) == 32u);\n-        assert (next_power_of_two(25u) == 32u);\n-        assert (next_power_of_two(26u) == 32u);\n-        assert (next_power_of_two(27u) == 32u);\n-        assert (next_power_of_two(28u) == 32u);\n-        assert (next_power_of_two(29u) == 32u);\n-        assert (next_power_of_two(30u) == 32u);\n-        assert (next_power_of_two(31u) == 32u);\n-        assert (next_power_of_two(32u) == 32u);\n-        assert (next_power_of_two(33u) == 64u);\n-        assert (next_power_of_two(34u) == 64u);\n-        assert (next_power_of_two(35u) == 64u);\n-        assert (next_power_of_two(36u) == 64u);\n-        assert (next_power_of_two(37u) == 64u);\n-        assert (next_power_of_two(38u) == 64u);\n-        assert (next_power_of_two(39u) == 64u);\n+        fail_unless!((next_power_of_two(0u) == 0u));\n+        fail_unless!((next_power_of_two(1u) == 1u));\n+        fail_unless!((next_power_of_two(2u) == 2u));\n+        fail_unless!((next_power_of_two(3u) == 4u));\n+        fail_unless!((next_power_of_two(4u) == 4u));\n+        fail_unless!((next_power_of_two(5u) == 8u));\n+        fail_unless!((next_power_of_two(6u) == 8u));\n+        fail_unless!((next_power_of_two(7u) == 8u));\n+        fail_unless!((next_power_of_two(8u) == 8u));\n+        fail_unless!((next_power_of_two(9u) == 16u));\n+        fail_unless!((next_power_of_two(10u) == 16u));\n+        fail_unless!((next_power_of_two(11u) == 16u));\n+        fail_unless!((next_power_of_two(12u) == 16u));\n+        fail_unless!((next_power_of_two(13u) == 16u));\n+        fail_unless!((next_power_of_two(14u) == 16u));\n+        fail_unless!((next_power_of_two(15u) == 16u));\n+        fail_unless!((next_power_of_two(16u) == 16u));\n+        fail_unless!((next_power_of_two(17u) == 32u));\n+        fail_unless!((next_power_of_two(18u) == 32u));\n+        fail_unless!((next_power_of_two(19u) == 32u));\n+        fail_unless!((next_power_of_two(20u) == 32u));\n+        fail_unless!((next_power_of_two(21u) == 32u));\n+        fail_unless!((next_power_of_two(22u) == 32u));\n+        fail_unless!((next_power_of_two(23u) == 32u));\n+        fail_unless!((next_power_of_two(24u) == 32u));\n+        fail_unless!((next_power_of_two(25u) == 32u));\n+        fail_unless!((next_power_of_two(26u) == 32u));\n+        fail_unless!((next_power_of_two(27u) == 32u));\n+        fail_unless!((next_power_of_two(28u) == 32u));\n+        fail_unless!((next_power_of_two(29u) == 32u));\n+        fail_unless!((next_power_of_two(30u) == 32u));\n+        fail_unless!((next_power_of_two(31u) == 32u));\n+        fail_unless!((next_power_of_two(32u) == 32u));\n+        fail_unless!((next_power_of_two(33u) == 64u));\n+        fail_unless!((next_power_of_two(34u) == 64u));\n+        fail_unless!((next_power_of_two(35u) == 64u));\n+        fail_unless!((next_power_of_two(36u) == 64u));\n+        fail_unless!((next_power_of_two(37u) == 64u));\n+        fail_unless!((next_power_of_two(38u) == 64u));\n+        fail_unless!((next_power_of_two(39u) == 64u));\n     }\n \n     #[test]\n     fn test_overflows() {\n         use uint;\n-        assert (uint::max_value > 0u);\n-        assert (uint::min_value <= 0u);\n-        assert (uint::min_value + uint::max_value + 1u == 0u);\n+        fail_unless!((uint::max_value > 0u));\n+        fail_unless!((uint::min_value <= 0u));\n+        fail_unless!((uint::min_value + uint::max_value + 1u == 0u));\n     }\n \n     #[test]\n     fn test_div() {\n-        assert(div_floor(3u, 4u) == 0u);\n-        assert(div_ceil(3u, 4u)  == 1u);\n-        assert(div_round(3u, 4u) == 1u);\n+        fail_unless!((div_floor(3u, 4u) == 0u));\n+        fail_unless!((div_ceil(3u, 4u)  == 1u));\n+        fail_unless!((div_round(3u, 4u) == 1u));\n     }\n \n     #[test]\n@@ -206,7 +206,7 @@ pub mod inst {\n         let ten = 10 as uint;\n         let mut accum = 0;\n         for ten.times { accum += 1; }\n-        assert (accum == 10);\n+        fail_unless!((accum == 10));\n     }\n }\n \n@@ -236,45 +236,45 @@ impl NumCast for uint {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u.to_uint());\n-    assert (20u8  == 20u.to_u8());\n-    assert (20u16 == 20u.to_u16());\n-    assert (20u32 == 20u.to_u32());\n-    assert (20u64 == 20u.to_u64());\n-    assert (20i   == 20u.to_int());\n-    assert (20i8  == 20u.to_i8());\n-    assert (20i16 == 20u.to_i16());\n-    assert (20i32 == 20u.to_i32());\n-    assert (20i64 == 20u.to_i64());\n-    assert (20f   == 20u.to_float());\n-    assert (20f32 == 20u.to_f32());\n-    assert (20f64 == 20u.to_f64());\n+    fail_unless!((20u   == 20u.to_uint()));\n+    fail_unless!((20u8  == 20u.to_u8()));\n+    fail_unless!((20u16 == 20u.to_u16()));\n+    fail_unless!((20u32 == 20u.to_u32()));\n+    fail_unless!((20u64 == 20u.to_u64()));\n+    fail_unless!((20i   == 20u.to_int()));\n+    fail_unless!((20i8  == 20u.to_i8()));\n+    fail_unless!((20i16 == 20u.to_i16()));\n+    fail_unless!((20i32 == 20u.to_i32()));\n+    fail_unless!((20i64 == 20u.to_i64()));\n+    fail_unless!((20f   == 20u.to_float()));\n+    fail_unless!((20f32 == 20u.to_f32()));\n+    fail_unless!((20f64 == 20u.to_f64()));\n \n-    assert (20u == NumCast::from(20u));\n-    assert (20u == NumCast::from(20u8));\n-    assert (20u == NumCast::from(20u16));\n-    assert (20u == NumCast::from(20u32));\n-    assert (20u == NumCast::from(20u64));\n-    assert (20u == NumCast::from(20i));\n-    assert (20u == NumCast::from(20i8));\n-    assert (20u == NumCast::from(20i16));\n-    assert (20u == NumCast::from(20i32));\n-    assert (20u == NumCast::from(20i64));\n-    assert (20u == NumCast::from(20f));\n-    assert (20u == NumCast::from(20f32));\n-    assert (20u == NumCast::from(20f64));\n+    fail_unless!((20u == NumCast::from(20u)));\n+    fail_unless!((20u == NumCast::from(20u8)));\n+    fail_unless!((20u == NumCast::from(20u16)));\n+    fail_unless!((20u == NumCast::from(20u32)));\n+    fail_unless!((20u == NumCast::from(20u64)));\n+    fail_unless!((20u == NumCast::from(20i)));\n+    fail_unless!((20u == NumCast::from(20i8)));\n+    fail_unless!((20u == NumCast::from(20i16)));\n+    fail_unless!((20u == NumCast::from(20i32)));\n+    fail_unless!((20u == NumCast::from(20i64)));\n+    fail_unless!((20u == NumCast::from(20f)));\n+    fail_unless!((20u == NumCast::from(20f32)));\n+    fail_unless!((20u == NumCast::from(20f64)));\n \n-    assert (20u == num::cast(20u));\n-    assert (20u == num::cast(20u8));\n-    assert (20u == num::cast(20u16));\n-    assert (20u == num::cast(20u32));\n-    assert (20u == num::cast(20u64));\n-    assert (20u == num::cast(20i));\n-    assert (20u == num::cast(20i8));\n-    assert (20u == num::cast(20i16));\n-    assert (20u == num::cast(20i32));\n-    assert (20u == num::cast(20i64));\n-    assert (20u == num::cast(20f));\n-    assert (20u == num::cast(20f32));\n-    assert (20u == num::cast(20f64));\n+    fail_unless!((20u == num::cast(20u)));\n+    fail_unless!((20u == num::cast(20u8)));\n+    fail_unless!((20u == num::cast(20u16)));\n+    fail_unless!((20u == num::cast(20u32)));\n+    fail_unless!((20u == num::cast(20u64)));\n+    fail_unless!((20u == num::cast(20i)));\n+    fail_unless!((20u == num::cast(20i8)));\n+    fail_unless!((20u == num::cast(20i16)));\n+    fail_unless!((20u == num::cast(20i32)));\n+    fail_unless!((20u == num::cast(20i64)));\n+    fail_unless!((20u == num::cast(20f)));\n+    fail_unless!((20u == num::cast(20f32)));\n+    fail_unless!((20u == num::cast(20f64)));\n }"}, {"sha": "7b0e4d07b53b819320a8319fd23a56b892dc2a61", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -437,7 +437,7 @@ fn test_unwrap_ptr() {\n     let opt = Some(x);\n     let y = unwrap(opt);\n     let addr_y = ptr::addr_of(&(*y));\n-    assert addr_x == addr_y;\n+    fail_unless!(addr_x == addr_y);\n }\n \n #[test]\n@@ -447,7 +447,7 @@ fn test_unwrap_str() {\n     let opt = Some(x);\n     let y = unwrap(opt);\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n-    assert addr_x == addr_y;\n+    fail_unless!(addr_x == addr_y);\n }\n \n #[test]\n@@ -472,7 +472,7 @@ fn test_unwrap_resource() {\n         let opt = Some(x);\n         let _y = unwrap(opt);\n     }\n-    assert *i == 1;\n+    fail_unless!(*i == 1);\n }\n \n #[test]\n@@ -483,8 +483,8 @@ fn test_option_dance() {\n     for x.each |_x| {\n         y2 = swap_unwrap(&mut y);\n     }\n-    assert y2 == 5;\n-    assert y.is_none();\n+    fail_unless!(y2 == 5);\n+    fail_unless!(y.is_none());\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n@@ -504,15 +504,15 @@ fn test_option_while_some() {\n             None\n         }\n     }\n-    assert i == 11;\n+    fail_unless!(i == 11);\n }\n \n #[test]\n fn test_get_or_zero() {\n     let some_stuff = Some(42);\n-    assert some_stuff.get_or_zero() == 42;\n+    fail_unless!(some_stuff.get_or_zero() == 42);\n     let no_stuff: Option<int> = None;\n-    assert no_stuff.get_or_zero() == 0;\n+    fail_unless!(no_stuff.get_or_zero() == 0);\n }\n \n // Local Variables:"}, {"sha": "5c73e45364be7b754c5de559218715e21deac8a8", "filename": "src/libcore/os.rs", "status": "modified", "additions": 62, "deletions": 54, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -51,15 +51,20 @@ pub fn close(fd: c_int) -> c_int {\n     }\n }\n \n-extern mod rustrt {\n-    unsafe fn rust_get_argc() -> c_int;\n-    unsafe fn rust_get_argv() -> **c_char;\n-    unsafe fn rust_getcwd() -> ~str;\n-    unsafe fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n-    unsafe fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    unsafe fn rust_list_files2(&&path: ~str) -> ~[~str];\n-    unsafe fn rust_process_wait(handle: c_int) -> c_int;\n-    unsafe fn rust_set_exit_status(code: libc::intptr_t);\n+pub mod rustrt {\n+    use libc::{c_char, c_int};\n+    use libc;\n+\n+    pub extern {\n+        unsafe fn rust_get_argc() -> c_int;\n+        unsafe fn rust_get_argv() -> **c_char;\n+        unsafe fn rust_getcwd() -> ~str;\n+        unsafe fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n+        unsafe fn rust_path_exists(path: *libc::c_char) -> c_int;\n+        unsafe fn rust_list_files2(&&path: ~str) -> ~[~str];\n+        unsafe fn rust_process_wait(handle: c_int) -> c_int;\n+        unsafe fn rust_set_exit_status(code: libc::intptr_t);\n+    }\n }\n \n pub const TMPBUF_SZ : uint = 1000u;\n@@ -159,16 +164,16 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n }\n \n pub fn env() -> ~[(~str,~str)] {\n-    extern mod rustrt {\n+    extern {\n         unsafe fn rust_env_pairs() -> ~[~str];\n     }\n \n     unsafe {\n         do with_env_lock {\n             let mut pairs = ~[];\n-            for vec::each(rustrt::rust_env_pairs()) |p| {\n+            for vec::each(rust_env_pairs()) |p| {\n                 let vs = str::splitn_char(*p, '=', 1u);\n-                assert vec::len(vs) == 2u;\n+                fail_unless!(vec::len(vs) == 2u);\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n             pairs\n@@ -308,7 +313,8 @@ pub fn waitpid(pid: pid_t) -> c_int {\n         use libc::funcs::posix01::wait::*;\n         let mut status = 0 as c_int;\n \n-        assert (waitpid(pid, &mut status, 0 as c_int) != (-1 as c_int));\n+        fail_unless!((waitpid(pid, &mut status, 0 as c_int) !=\n+                     (-1 as c_int)));\n         return status;\n     }\n }\n@@ -321,7 +327,7 @@ pub fn pipe() -> Pipe {\n     unsafe {\n         let mut fds = Pipe {in: 0 as c_int,\n                         out: 0 as c_int };\n-        assert (libc::pipe(&mut fds.in) == (0 as c_int));\n+        fail_unless!((libc::pipe(&mut fds.in) == (0 as c_int)));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -340,9 +346,9 @@ pub fn pipe() -> Pipe {\n                     out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-        assert (res == 0 as c_int);\n-        assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n-        assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n+        fail_unless!((res == 0 as c_int));\n+        fail_unless!((fds.in != -1 as c_int && fds.in != 0 as c_int));\n+        fail_unless!((fds.out != -1 as c_int && fds.in != 0 as c_int));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -1137,21 +1143,21 @@ mod tests {\n     #[test]\n     pub fn test_args() {\n         let a = real_args();\n-        assert a.len() >= 1;\n+        fail_unless!(a.len() >= 1);\n     }\n \n     fn make_rand_name() -> ~str {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n-        assert getenv(n).is_none();\n+        fail_unless!(getenv(n).is_none());\n         n\n     }\n \n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n, ~\"VALUE\");\n-        assert getenv(n) == option::Some(~\"VALUE\");\n+        fail_unless!(getenv(n) == option::Some(~\"VALUE\"));\n     }\n \n     #[test]\n@@ -1161,9 +1167,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, ~\"1\");\n         setenv(n, ~\"2\");\n-        assert getenv(n) == option::Some(~\"2\");\n+        fail_unless!(getenv(n) == option::Some(~\"2\"));\n         setenv(n, ~\"\");\n-        assert getenv(n) == option::Some(~\"\");\n+        fail_unless!(getenv(n) == option::Some(~\"\"));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1178,33 +1184,33 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, copy s);\n-        assert getenv(n) == option::Some(s);\n+        fail_unless!(getenv(n) == option::Some(s));\n     }\n \n     #[test]\n     fn test_self_exe_path() {\n         let path = os::self_exe_path();\n-        assert path.is_some();\n+        fail_unless!(path.is_some());\n         let path = path.get();\n         log(debug, copy path);\n \n         // Hard to test this function\n-        assert path.is_absolute;\n+        fail_unless!(path.is_absolute);\n     }\n \n     #[test]\n     #[ignore]\n     fn test_env_getenv() {\n         let e = env();\n-        assert vec::len(e) > 0u;\n+        fail_unless!(vec::len(e) > 0u);\n         for vec::each(e) |p| {\n             let (n, v) = copy *p;\n             log(debug, copy n);\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert v2.is_none() || v2 == option::Some(v);\n+            fail_unless!(v2.is_none() || v2 == option::Some(v));\n         }\n     }\n \n@@ -1214,15 +1220,15 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, ~\"VALUE\");\n-        assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n+        fail_unless!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n \n         e = env();\n-        assert vec::contains(e, &(n, ~\"VALUE\"));\n+        fail_unless!(vec::contains(e, &(n, ~\"VALUE\")));\n     }\n \n     #[test]\n     fn test() {\n-        assert (!Path(\"test-path\").is_absolute);\n+        fail_unless!((!Path(\"test-path\").is_absolute));\n \n         log(debug, ~\"Current working directory: \" + getcwd().to_str());\n \n@@ -1236,10 +1242,10 @@ mod tests {\n         let oldhome = getenv(~\"HOME\");\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n-        assert os::homedir().is_none();\n+        fail_unless!(os::homedir().is_none());\n \n         for oldhome.each |s| { setenv(~\"HOME\", *s) }\n     }\n@@ -1254,19 +1260,19 @@ mod tests {\n         setenv(~\"HOME\", ~\"\");\n         setenv(~\"USERPROFILE\", ~\"\");\n \n-        assert os::homedir().is_none();\n+        fail_unless!(os::homedir().is_none());\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n \n         setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         option::iter(&oldhome, |s| setenv(~\"HOME\", *s));\n         option::iter(&olduserprofile,\n@@ -1275,7 +1281,7 @@ mod tests {\n \n     #[test]\n     fn tmpdir() {\n-        assert !str::is_empty(os::tmpdir().to_str());\n+        fail_unless!(!str::is_empty(os::tmpdir().to_str()));\n     }\n \n     // Issue #712\n@@ -1288,7 +1294,7 @@ mod tests {\n     fn list_dir() {\n         let dirs = os::list_dir(&Path(\".\"));\n         // Just assuming that we've got some contents in the current directory\n-        assert (vec::len(dirs) > 0u);\n+        fail_unless!((vec::len(dirs) > 0u));\n \n         for vec::each(dirs) |dir| {\n             log(debug, copy *dir);\n@@ -1297,29 +1303,30 @@ mod tests {\n \n     #[test]\n     fn path_is_dir() {\n-        assert (os::path_is_dir(&Path(\".\")));\n-        assert (!os::path_is_dir(&Path(\"test/stdtest/fs.rs\")));\n+        fail_unless!((os::path_is_dir(&Path(\".\"))));\n+        fail_unless!((!os::path_is_dir(&Path(\"test/stdtest/fs.rs\"))));\n     }\n \n     #[test]\n     fn path_exists() {\n-        assert (os::path_exists(&Path(\".\")));\n-        assert (!os::path_exists(&Path(\"test/nonexistent-bogus-path\")));\n+        fail_unless!((os::path_exists(&Path(\".\"))));\n+        fail_unless!((!os::path_exists(&Path(\n+                     \"test/nonexistent-bogus-path\"))));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      assert !os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n-                            &Path(\"test/other-bogus-path\"));\n-      assert !os::path_exists(&Path(\"test/other-bogus-path\"));\n+      fail_unless!(!os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n+                            &Path(\"test/other-bogus-path\")));\n+      fail_unless!(!os::path_exists(&Path(\"test/other-bogus-path\")));\n     }\n \n     #[test]\n     fn copy_file_ok() {\n         unsafe {\n           let tempdir = getcwd(); // would like to use $TMPDIR,\n                                   // doesn't seem to work on Linux\n-          assert (str::len(tempdir.to_str()) > 0u);\n+          fail_unless!((str::len(tempdir.to_str()) > 0u));\n           let in = tempdir.push(\"in.txt\");\n           let out = tempdir.push(\"out.txt\");\n \n@@ -1329,23 +1336,24 @@ mod tests {\n                     libc::fopen(fromp, modebuf)\n                 }\n           };\n-          assert (ostream as uint != 0u);\n+          fail_unless!((ostream as uint != 0u));\n           let s = ~\"hello\";\n           let mut buf = str::to_bytes(s) + ~[0 as u8];\n           do vec::as_mut_buf(buf) |b, _len| {\n-              assert (libc::fwrite(b as *c_void, 1u as size_t,\n+              fail_unless!((libc::fwrite(b as *c_void, 1u as size_t,\n                                    (str::len(s) + 1u) as size_t, ostream)\n-                      == buf.len() as size_t)};\n-          assert (libc::fclose(ostream) == (0u as c_int));\n+                      == buf.len() as size_t))\n+          }\n+          fail_unless!((libc::fclose(ostream) == (0u as c_int)));\n           let rs = os::copy_file(&in, &out);\n           if (!os::path_exists(&in)) {\n             fail!(fmt!(\"%s doesn't exist\", in.to_str()));\n           }\n-          assert(rs);\n+          fail_unless!((rs));\n           let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n-          assert (rslt == 0);\n-          assert (remove_file(&in));\n-          assert (remove_file(&out));\n+          fail_unless!((rslt == 0));\n+          fail_unless!((remove_file(&in)));\n+          fail_unless!((remove_file(&out)));\n         }\n     }\n }"}, {"sha": "c688607400719aaed88ca2a7f45910c190e8a546", "filename": "src/libcore/path.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -439,7 +439,7 @@ impl GenericPath for PosixPath {\n \n     pure fn with_filename(&self, f: &str) -> PosixPath {\n         unsafe {\n-            assert ! str::any(f, |c| windows::is_sep(c as u8));\n+            fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n             self.dir_path().push(f)\n         }\n     }\n@@ -484,7 +484,7 @@ impl GenericPath for PosixPath {\n     }\n \n     pure fn push_rel(&self, other: &PosixPath) -> PosixPath {\n-        assert !other.is_absolute;\n+        fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n@@ -650,7 +650,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     pure fn with_filename(&self, f: &str) -> WindowsPath {\n-        assert ! str::any(f, |c| windows::is_sep(c as u8));\n+        fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n         self.dir_path().push(f)\n     }\n \n@@ -697,7 +697,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     pure fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n-        assert !other.is_absolute;\n+        fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n@@ -880,30 +880,30 @@ mod tests {\n         let path = PosixPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        assert ~\"tmp/hmm\" == path.to_str();\n+        fail_unless!(~\"tmp/hmm\" == path.to_str());\n \n         let path = WindowsPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        assert ~\"tmp\\\\hmm\" == path.to_str();\n+        fail_unless!(~\"tmp\\\\hmm\" == path.to_str());\n     }\n \n     #[test]\n     fn test_filetype_foo_bar() {\n         let wp = PosixPath(\"foo.bar\");\n-        assert wp.filetype() == Some(~\".bar\");\n+        fail_unless!(wp.filetype() == Some(~\".bar\"));\n \n         let wp = WindowsPath(\"foo.bar\");\n-        assert wp.filetype() == Some(~\".bar\");\n+        fail_unless!(wp.filetype() == Some(~\".bar\"));\n     }\n \n     #[test]\n     fn test_filetype_foo() {\n         let wp = PosixPath(\"foo\");\n-        assert wp.filetype() == None;\n+        fail_unless!(wp.filetype() == None);\n \n         let wp = WindowsPath(\"foo\");\n-        assert wp.filetype() == None;\n+        fail_unless!(wp.filetype() == None);\n     }\n \n     #[test]\n@@ -914,7 +914,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert ss == sss;\n+                fail_unless!(ss == sss);\n             }\n         }\n \n@@ -972,7 +972,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert ss == sss;\n+                fail_unless!(ss == sss);\n             }\n         }\n \n@@ -988,37 +988,43 @@ mod tests {\n \n     #[test]\n     fn test_extract_unc_prefixes() {\n-        assert windows::extract_unc_prefix(\"\\\\\\\\\").is_none();\n-        assert windows::extract_unc_prefix(\"//\").is_none();\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none();\n-        assert windows::extract_unc_prefix(\"//hi\").is_none();\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n-            Some((~\"hi\", ~\"\\\\\"));\n-        assert windows::extract_unc_prefix(\"//hi\\\\\") ==\n-            Some((~\"hi\", ~\"\\\\\"));\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n-            Some((~\"hi\", ~\"\\\\there\"));\n-        assert windows::extract_unc_prefix(\"//hi/there\") ==\n-            Some((~\"hi\", ~\"/there\"));\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n-        assert windows::extract_unc_prefix(\"//hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"//\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"//hi\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n+            Some((~\"hi\", ~\"\\\\\")));\n+        fail_unless!(windows::extract_unc_prefix(\"//hi\\\\\") ==\n+            Some((~\"hi\", ~\"\\\\\")));\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n+            Some((~\"hi\", ~\"\\\\there\")));\n+        fail_unless!(windows::extract_unc_prefix(\"//hi/there\") ==\n+            Some((~\"hi\", ~\"/there\")));\n+        fail_unless!(windows::extract_unc_prefix(\n+            \"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n+        fail_unless!(windows::extract_unc_prefix(\n+            \"//hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n     }\n \n     #[test]\n     fn test_extract_drive_prefixes() {\n-        assert windows::extract_drive_prefix(\"c\").is_none();\n-        assert windows::extract_drive_prefix(\"c:\") == Some((~\"c\", ~\"\"));\n-        assert windows::extract_drive_prefix(\"d:\") == Some((~\"d\", ~\"\"));\n-        assert windows::extract_drive_prefix(\"z:\") == Some((~\"z\", ~\"\"));\n-        assert windows::extract_drive_prefix(\"c:\\\\hi\") ==\n-            Some((~\"c\", ~\"\\\\hi\"));\n-        assert windows::extract_drive_prefix(\"d:hi\") == Some((~\"d\", ~\"hi\"));\n-        assert windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n-            Some((~\"c\", ~\"hi\\\\there.txt\"));\n-        assert windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n-            Some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n+        fail_unless!(windows::extract_drive_prefix(\"c\").is_none());\n+        fail_unless!(windows::extract_drive_prefix(\"c:\") ==\n+                     Some((~\"c\", ~\"\")));\n+        fail_unless!(windows::extract_drive_prefix(\"d:\") ==\n+                     Some((~\"d\", ~\"\")));\n+        fail_unless!(windows::extract_drive_prefix(\"z:\") ==\n+                     Some((~\"z\", ~\"\")));\n+        fail_unless!(windows::extract_drive_prefix(\"c:\\\\hi\") ==\n+                     Some((~\"c\", ~\"\\\\hi\")));\n+        fail_unless!(windows::extract_drive_prefix(\"d:hi\") ==\n+                     Some((~\"d\", ~\"hi\")));\n+        fail_unless!(windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n+                     Some((~\"c\", ~\"hi\\\\there.txt\")));\n+        fail_unless!(windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n+                     Some((~\"c\", ~\"\\\\hi\\\\there.txt\")));\n     }\n \n     #[test]\n@@ -1029,7 +1035,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert ss == sss;\n+                fail_unless!(ss == sss);\n             }\n         }\n \n@@ -1114,9 +1120,9 @@ mod tests {\n \n     #[test]\n     fn test_windows_path_restrictions() {\n-        assert WindowsPath(\"hi\").is_restricted() == false;\n-        assert WindowsPath(\"C:\\\\NUL\").is_restricted() == true;\n-        assert WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true;\n-        assert WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true;\n+        fail_unless!(WindowsPath(\"hi\").is_restricted() == false);\n+        fail_unless!(WindowsPath(\"C:\\\\NUL\").is_restricted() == true);\n+        fail_unless!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true);\n+        fail_unless!(WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true);\n     }\n }"}, {"sha": "afb7aef25a3a08bd641b54f2ff89b170c41099fb", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -161,7 +161,7 @@ pub impl PacketHeader {\n     unsafe fn mark_blocked(&self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n-        assert old_task.is_null();\n+        fail_unless!(old_task.is_null());\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n@@ -183,7 +183,7 @@ pub impl PacketHeader {\n     // continuum. It ends making multiple unique pointers to the same\n     // thing. You'll proobably want to forget them when you're done.\n     unsafe fn buf_header(&self) -> ~BufferHeader {\n-        assert self.buffer.is_not_null();\n+        fail_unless!(self.buffer.is_not_null());\n         reinterpret_cast(&self.buffer)\n     }\n \n@@ -288,22 +288,28 @@ pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n \n #[doc(hidden)]\n #[allow(non_camel_case_types)]\n-type rust_task = libc::c_void;\n+pub type rust_task = libc::c_void;\n \n #[doc(hidden)]\n-extern mod rustrt {\n-    #[rust_stack]\n-    unsafe fn rust_get_task() -> *rust_task;\n-    #[rust_stack]\n-    unsafe fn rust_task_ref(task: *rust_task);\n-    unsafe fn rust_task_deref(task: *rust_task);\n+pub mod rustrt {\n+    use libc;\n+    use super::rust_task;\n \n-    #[rust_stack]\n-    unsafe fn task_clear_event_reject(task: *rust_task);\n+    pub extern {\n+        #[rust_stack]\n+        unsafe fn rust_get_task() -> *rust_task;\n+        #[rust_stack]\n+        unsafe fn rust_task_ref(task: *rust_task);\n+        unsafe fn rust_task_deref(task: *rust_task);\n \n-    unsafe fn task_wait_event(this: *rust_task, killed: &mut *libc::c_void)\n-                        -> bool;\n-    unsafe fn task_signal_event(target: *rust_task, event: *libc::c_void);\n+        #[rust_stack]\n+        unsafe fn task_clear_event_reject(task: *rust_task);\n+\n+        unsafe fn task_wait_event(this: *rust_task,\n+                                  killed: &mut *libc::c_void)\n+                               -> bool;\n+        unsafe fn task_signal_event(target: *rust_task, event: *libc::c_void);\n+    }\n }\n \n #[doc(hidden)]\n@@ -380,8 +386,8 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n-    assert ptr::addr_of(&(p.header)) == header;\n-    assert p.payload.is_none();\n+    fail_unless!(ptr::addr_of(&(p.header)) == header);\n+    fail_unless!(p.payload.is_none());\n     p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n@@ -482,7 +488,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     debug!(\"blocked = %x this = %x old_task = %x\",\n            p.header.blocked_task as uint,\n            this as uint, old_task as uint);\n-    assert old_task.is_null();\n+    fail_unless!(old_task.is_null());\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n     loop {\n@@ -527,7 +533,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n-            assert old_state == Terminated;\n+            fail_unless!(old_state == Terminated);\n \n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n@@ -576,7 +582,7 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n         fail!(~\"you dun goofed\")\n       }\n       Terminated => {\n-        assert p.header.blocked_task.is_null();\n+        fail_unless!(p.header.blocked_task.is_null());\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -587,20 +593,20 @@ fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n-        assert p.header.blocked_task.is_null();\n+        fail_unless!(p.header.blocked_task.is_null());\n         // the sender will clean up\n       }\n       Blocked => {\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             unsafe {\n                 rustrt::rust_task_deref(old_task);\n-                assert old_task == rustrt::rust_get_task();\n+                fail_unless!(old_task == rustrt::rust_get_task());\n             }\n         }\n       }\n       Terminated | Full => {\n-        assert p.header.blocked_task.is_null();\n+        fail_unless!(p.header.blocked_task.is_null());\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -663,8 +669,8 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     debug!(\"%?, %?\", ready_packet, pkts[ready_packet]);\n \n     unsafe {\n-        assert (*pkts[ready_packet].header()).state == Full\n-            || (*pkts[ready_packet].header()).state == Terminated;\n+        fail_unless!((*pkts[ready_packet].header()).state == Full\n+                     || (*pkts[ready_packet].header()).state == Terminated);\n     }\n \n     ready_packet\n@@ -993,6 +999,6 @@ pub mod test {\n             let _chan = chan;\n         }\n \n-        assert !port.peek();\n+        fail_unless!(!port.peek());\n     }\n }"}, {"sha": "ebf41dc48f40500656d5aea1db106fb941113a3f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -20,25 +20,32 @@ use sys;\n #[cfg(test)] use str;\n #[cfg(notest)] use cmp::{Eq, Ord};\n \n-#[nolink]\n-#[abi = \"cdecl\"]\n-extern mod libc_ {\n-    #[rust_stack]\n-    unsafe fn memmove(dest: *mut c_void,\n-                      src: *const c_void,\n-                      n: libc::size_t)\n-                   -> *c_void;\n-\n-    #[rust_stack]\n-    unsafe fn memset(dest: *mut c_void,\n-                     c: libc::c_int,\n-                     len: libc::size_t)\n-                  -> *c_void;\n+pub mod libc_ {\n+    use libc::c_void;\n+    use libc;\n+\n+    #[nolink]\n+    #[abi = \"cdecl\"]\n+    pub extern {\n+        #[rust_stack]\n+        unsafe fn memmove(dest: *mut c_void,\n+                          src: *const c_void,\n+                          n: libc::size_t)\n+                       -> *c_void;\n+\n+        #[rust_stack]\n+        unsafe fn memset(dest: *mut c_void,\n+                         c: libc::c_int,\n+                         len: libc::size_t)\n+                      -> *c_void;\n+    }\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn addr_of<T>(&&val: T) -> *T;\n+pub mod rusti {\n+    #[abi = \"rust-intrinsic\"]\n+    pub extern {\n+        fn addr_of<T>(&&val: T) -> *T;\n+    }\n }\n \n /// Get an unsafe pointer to a value\n@@ -303,28 +310,30 @@ pub fn test() {\n         let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n         let iptr: *mut int = cast::reinterpret_cast(&pptr);\n-        assert (*iptr == 10);;\n+        fail_unless!((*iptr == 10));;\n         *iptr = 30;\n-        assert (*iptr == 30);\n-        assert (p.fst == 30);;\n+        fail_unless!((*iptr == 30));\n+        fail_unless!((p.fst == 30));;\n \n         *pptr = Pair {fst: 50, snd: 60};\n-        assert (*iptr == 50);\n-        assert (p.fst == 50);\n-        assert (p.snd == 60);\n+        fail_unless!((*iptr == 50));\n+        fail_unless!((p.fst == 50));\n+        fail_unless!((p.snd == 60));\n \n         let mut v0 = ~[32000u16, 32001u16, 32002u16];\n         let mut v1 = ~[0u16, 0u16, 0u16];\n \n         copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n                     offset(vec::raw::to_ptr(v0), 1u), 1u);\n-        assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        fail_unless!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n         copy_memory(vec::raw::to_mut_ptr(v1),\n                     offset(vec::raw::to_ptr(v0), 2u), 1u);\n-        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        fail_unless!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+                      v1[2] == 0u16));\n         copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n                     vec::raw::to_ptr(v0), 1u);\n-        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n+        fail_unless!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+                      v1[2] == 32000u16));\n     }\n }\n \n@@ -335,9 +344,12 @@ pub fn test_position() {\n \n     let s = ~\"hello\";\n     unsafe {\n-        assert 2u == as_c_str(s, |p| position(p, |c| *c == 'l' as c_char));\n-        assert 4u == as_c_str(s, |p| position(p, |c| *c == 'o' as c_char));\n-        assert 5u == as_c_str(s, |p| position(p, |c| *c == 0 as c_char));\n+        fail_unless!(2u == as_c_str(s, |p| position(p,\n+            |c| *c == 'l' as c_char)));\n+        fail_unless!(4u == as_c_str(s, |p| position(p,\n+            |c| *c == 'o' as c_char)));\n+        fail_unless!(5u == as_c_str(s, |p| position(p,\n+            |c| *c == 0 as c_char)));\n     }\n }\n \n@@ -351,8 +363,8 @@ pub fn test_buf_len() {\n             do str::as_c_str(s2) |p2| {\n                 let v = ~[p0, p1, p2, null()];\n                 do vec::as_imm_buf(v) |vp, len| {\n-                    assert unsafe { buf_len(vp) } == 3u;\n-                    assert len == 4u;\n+                    fail_unless!(unsafe { buf_len(vp) } == 3u);\n+                    fail_unless!(len == 4u);\n                 }\n             }\n         }\n@@ -362,18 +374,18 @@ pub fn test_buf_len() {\n #[test]\n pub fn test_is_null() {\n    let p: *int = null();\n-   assert p.is_null();\n-   assert !p.is_not_null();\n+   fail_unless!(p.is_null());\n+   fail_unless!(!p.is_not_null());\n \n    let q = offset(p, 1u);\n-   assert !q.is_null();\n-   assert q.is_not_null();\n+   fail_unless!(!q.is_null());\n+   fail_unless!(q.is_not_null());\n \n    let mp: *mut int = mut_null();\n-   assert mp.is_null();\n-   assert !mp.is_not_null();\n+   fail_unless!(mp.is_null());\n+   fail_unless!(!mp.is_not_null());\n \n    let mq = mp.offset(1u);\n-   assert !mq.is_null();\n-   assert mq.is_not_null();\n+   fail_unless!(!mq.is_null());\n+   fail_unless!(mq.is_not_null());\n }"}, {"sha": "cf90edf86f4216f6d9bd1d12d6f7b9e4cfa925da", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -117,15 +117,20 @@ impl<T:Rand> Rand for Option<T> {\n }\n \n #[allow(non_camel_case_types)] // runtime type\n-enum rust_rng {}\n+pub enum rust_rng {}\n \n #[abi = \"cdecl\"]\n-extern mod rustrt {\n-    unsafe fn rand_seed_size() -> size_t;\n-    unsafe fn rand_gen_seed(buf: *mut u8, sz: size_t);\n-    unsafe fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n-    unsafe fn rand_next(rng: *rust_rng) -> u32;\n-    unsafe fn rand_free(rng: *rust_rng);\n+pub mod rustrt {\n+    use libc::size_t;\n+    use rand::rust_rng;\n+\n+    pub extern {\n+        unsafe fn rand_seed_size() -> size_t;\n+        unsafe fn rand_gen_seed(buf: *mut u8, sz: size_t);\n+        unsafe fn rand_new_seeded(buf: *u8, sz: size_t) -> *rust_rng;\n+        unsafe fn rand_next(rng: *rust_rng) -> u32;\n+        unsafe fn rand_free(rng: *rust_rng);\n+    }\n }\n \n /// A random number generator\n@@ -157,7 +162,7 @@ pub impl Rng {\n      * failing if start >= end\n      */\n     fn gen_int_range(&self, start: int, end: int) -> int {\n-        assert start < end;\n+        fail_unless!(start < end);\n         start + int::abs(self.gen_int() % (end - start))\n     }\n \n@@ -191,7 +196,7 @@ pub impl Rng {\n      * failing if start >= end\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n-        assert start < end;\n+        fail_unless!(start < end);\n         start + (self.gen_uint() % (end - start))\n     }\n \n@@ -243,7 +248,7 @@ pub impl Rng {\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n     fn gen_char_from(&self, chars: &str) -> char {\n-        assert !chars.is_empty();\n+        fail_unless!(!chars.is_empty());\n         self.choose(str::chars(chars))\n     }\n \n@@ -498,7 +503,7 @@ pub mod tests {\n         let seed = rand::seed();\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n-        assert ra.gen_str(100u) == rb.gen_str(100u);\n+        fail_unless!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -507,7 +512,7 @@ pub mod tests {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n-        assert ra.gen_str(100u) == rb.gen_str(100u);\n+        fail_unless!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -517,17 +522,17 @@ pub mod tests {\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n-        assert r == 890007737u32 // on x86_64\n-            || r == 2935188040u32; // on x86\n+        fail_unless!(r == 890007737u32 // on x86_64\n+                     || r == 2935188040u32); // on x86\n     }\n \n     #[test]\n     pub fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n-        assert a >= -3 && a < 42;\n-        assert r.gen_int_range(0, 1) == 0;\n-        assert r.gen_int_range(-12, -11) == -12;\n+        fail_unless!(a >= -3 && a < 42);\n+        fail_unless!(r.gen_int_range(0, 1) == 0);\n+        fail_unless!(r.gen_int_range(-12, -11) == -12);\n     }\n \n     #[test]\n@@ -541,9 +546,9 @@ pub mod tests {\n     pub fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n-        assert a >= 3u && a < 42u;\n-        assert r.gen_uint_range(0u, 1u) == 0u;\n-        assert r.gen_uint_range(12u, 13u) == 12u;\n+        fail_unless!(a >= 3u && a < 42u);\n+        fail_unless!(r.gen_uint_range(0u, 1u) == 0u);\n+        fail_unless!(r.gen_uint_range(12u, 13u) == 12u);\n     }\n \n     #[test]\n@@ -564,8 +569,8 @@ pub mod tests {\n     #[test]\n     pub fn gen_weighted_bool() {\n         let r = rand::Rng();\n-        assert r.gen_weighted_bool(0u) == true;\n-        assert r.gen_weighted_bool(1u) == true;\n+        fail_unless!(r.gen_weighted_bool(0u) == true);\n+        fail_unless!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n@@ -574,85 +579,85 @@ pub mod tests {\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n-        assert r.gen_str(0u).len() == 0u;\n-        assert r.gen_str(10u).len() == 10u;\n-        assert r.gen_str(16u).len() == 16u;\n+        fail_unless!(r.gen_str(0u).len() == 0u);\n+        fail_unless!(r.gen_str(10u).len() == 10u);\n+        fail_unless!(r.gen_str(16u).len() == 16u);\n     }\n \n     #[test]\n     pub fn gen_bytes() {\n         let r = rand::Rng();\n-        assert r.gen_bytes(0u).len() == 0u;\n-        assert r.gen_bytes(10u).len() == 10u;\n-        assert r.gen_bytes(16u).len() == 16u;\n+        fail_unless!(r.gen_bytes(0u).len() == 0u);\n+        fail_unless!(r.gen_bytes(10u).len() == 10u);\n+        fail_unless!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n     pub fn choose() {\n         let r = rand::Rng();\n-        assert r.choose([1, 1, 1]) == 1;\n+        fail_unless!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n     pub fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n-        assert x.is_none();\n-        assert r.choose_option([1, 1, 1]) == Some(1);\n+        fail_unless!(x.is_none());\n+        fail_unless!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n     pub fn choose_weighted() {\n         let r = rand::Rng();\n-        assert r.choose_weighted(~[\n+        fail_unless!(r.choose_weighted(~[\n             rand::Weighted { weight: 1u, item: 42 },\n-        ]) == 42;\n-        assert r.choose_weighted(~[\n+        ]) == 42);\n+        fail_unless!(r.choose_weighted(~[\n             rand::Weighted { weight: 0u, item: 42 },\n             rand::Weighted { weight: 1u, item: 43 },\n-        ]) == 43;\n+        ]) == 43);\n     }\n \n     #[test]\n     pub fn choose_weighted_option() {\n         let r = rand::Rng();\n-        assert r.choose_weighted_option(~[\n+        fail_unless!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 1u, item: 42 },\n-        ]) == Some(42);\n-        assert r.choose_weighted_option(~[\n+        ]) == Some(42));\n+        fail_unless!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 0u, item: 42 },\n             rand::Weighted { weight: 1u, item: 43 },\n-        ]) == Some(43);\n+        ]) == Some(43));\n         let v: Option<int> = r.choose_weighted_option([]);\n-        assert v.is_none();\n+        fail_unless!(v.is_none());\n     }\n \n     #[test]\n     pub fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n-        assert r.weighted_vec(~[]) == empty;\n-        assert r.weighted_vec(~[\n+        fail_unless!(r.weighted_vec(~[]) == empty);\n+        fail_unless!(r.weighted_vec(~[\n             rand::Weighted { weight: 0u, item: 3u },\n             rand::Weighted { weight: 1u, item: 2u },\n             rand::Weighted { weight: 2u, item: 1u },\n-        ]) == ~[2u, 1u, 1u];\n+        ]) == ~[2u, 1u, 1u]);\n     }\n \n     #[test]\n     pub fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n-        assert r.shuffle(~[]) == empty;\n-        assert r.shuffle(~[1, 1, 1]) == ~[1, 1, 1];\n+        fail_unless!(r.shuffle(~[]) == empty);\n+        fail_unless!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n     pub fn task_rng() {\n         let r = rand::task_rng();\n         r.gen_int();\n-        assert r.shuffle(~[1, 1, 1]) == ~[1, 1, 1];\n-        assert r.gen_uint_range(0u, 1u) == 0u;\n+        fail_unless!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        fail_unless!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]"}, {"sha": "eaae9d03e8ea86df9047013ec83289635ead100e", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -231,7 +231,7 @@ pub impl ReprVisitor {\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n-            assert mtbl == 2;\n+            fail_unless!(mtbl == 2);\n             self.writer.write_str(\"const \");\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_repr() {\n             error!(\"expected '%s', got '%s'\",\n                    e, s);\n         }\n-        assert s == e;\n+        fail_unless!(s == e);\n     }\n \n "}, {"sha": "dd9b55e6725804152876c107f7c6dbdd2c752950", "filename": "src/libcore/result.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -294,7 +294,7 @@ pub impl<T, E: Copy> Result<T, E> {\n  *         else { return ok(x+1u); }\n  *     }\n  *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n- *         assert incd == ~[2u, 3u, 4u];\n+ *         fail_unless!(incd == ~[2u, 3u, 4u]);\n  *     }\n  */\n #[inline(always)]\n@@ -337,7 +337,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n-    assert vec::same_length(ss, ts);\n+    fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n     let mut vs = vec::with_capacity(n);\n     let mut i = 0u;\n@@ -360,7 +360,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n-    assert vec::same_length(ss, ts);\n+    fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {\n@@ -407,50 +407,50 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        assert get(&chain(op1(), op2)) == 667u;\n+        fail_unless!(get(&chain(op1(), op2)) == 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert get_err(&chain(op3(), op2)) == ~\"sadface\";\n+        fail_unless!(get_err(&chain(op3(), op2)) == ~\"sadface\");\n     }\n \n     #[test]\n     pub fn test_impl_iter() {\n         let mut valid = false;\n         Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n-        assert valid;\n+        fail_unless!(valid);\n \n         Err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n-        assert valid;\n+        fail_unless!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_iter_err() {\n         let mut valid = true;\n         Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n-        assert valid;\n+        fail_unless!(valid);\n \n         valid = false;\n         Err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n-        assert valid;\n+        fail_unless!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\");\n-        assert Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\");\n+        fail_unless!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\"));\n+        fail_unless!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\"));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\");\n-        assert Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\");\n+        fail_unless!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\"));\n+        fail_unless!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\"));\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let foo: Result<int, ()> = Ok(100);\n-        assert *foo.get_ref() == 100;\n+        fail_unless!(*foo.get_ref() == 100);\n     }\n }"}, {"sha": "bebcc909dc6582c51cfccb6517cfed059afc3170", "filename": "src/libcore/run.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -23,12 +23,20 @@ use str;\n use task;\n use vec;\n \n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    unsafe fn rust_run_program(argv: **libc::c_char, envp: *c_void,\n-                               dir: *libc::c_char,\n-                               in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-                            -> pid_t;\n+pub mod rustrt {\n+    use libc::{c_int, c_void, pid_t};\n+    use libc;\n+\n+    #[abi = \"cdecl\"]\n+    pub extern {\n+        unsafe fn rust_run_program(argv: **libc::c_char,\n+                                   envp: *c_void,\n+                                   dir: *libc::c_char,\n+                                   in_fd: c_int,\n+                                   out_fd: c_int,\n+                                   err_fd: c_int)\n+                                -> pid_t;\n+    }\n }\n \n /// A value representing a child process\n@@ -488,7 +496,7 @@ mod tests {\n \n         log(debug, copy expected);\n         log(debug, copy actual);\n-        assert (expected == actual);\n+        fail_unless!((expected == actual));\n     }\n \n     #[test]\n@@ -497,7 +505,7 @@ mod tests {\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n-        assert status == 1;\n+        fail_unless!(status == 1);\n     }\n \n }"}, {"sha": "107e52b245e37c33368334f1792a650d154de3ce", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -86,11 +86,16 @@ fn frame_address(f: fn(++x: *u8)) {\n     }\n }\n \n-extern mod rustrt {\n-    pub unsafe fn rust_dbg_breakpoint();\n+pub mod rustrt {\n+    pub extern {\n+        pub unsafe fn rust_dbg_breakpoint();\n+    }\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    pub fn frame_address(f: &once fn(++x: *u8));\n+pub mod rusti {\n+    #[abi = \"rust-intrinsic\"]\n+    pub extern {\n+        pub fn frame_address(f: &once fn(++x: *u8));\n+    }\n }\n+"}, {"sha": "6a0673878e0e2fffae85a75a6751e40200713b46", "filename": "src/libcore/str.rs", "status": "modified", "additions": 379, "deletions": 366, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -43,7 +43,7 @@ Section: Creating a string\n  * Fails if invalid UTF-8\n  */\n pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n-    assert is_utf8(vv);\n+    fail_unless!(is_utf8(vv));\n     return unsafe { raw::from_bytes(vv) };\n }\n \n@@ -60,7 +60,7 @@ pub pure fn from_slice(s: &str) -> ~str {\n  * Fails if invalid UTF-8\n  */\n pub pure fn from_byte(b: u8) -> ~str {\n-    assert b < 128u8;\n+    fail_unless!(b < 128u8);\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n@@ -249,7 +249,7 @@ Section: Adding to and removing from a string\n  */\n pub fn pop_char(s: &mut ~str) -> char {\n     let end = len(*s);\n-    assert end > 0u;\n+    fail_unless!(end > 0u);\n     let CharRange {ch, next} = char_range_at_reverse(*s, end);\n     unsafe { raw::set_len(s, next); }\n     return ch;\n@@ -417,8 +417,8 @@ pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n  * beyond the last character of the string\n  */\n pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n-    assert is_char_boundary(s, begin);\n-    assert is_char_boundary(s, end);\n+    fail_unless!(is_char_boundary(s, begin));\n+    fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n@@ -429,8 +429,8 @@ pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n  * the last character of the string\n  */\n pub pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n-    assert is_char_boundary(s, begin);\n-    assert is_char_boundary(s, end);\n+    fail_unless!(is_char_boundary(s, begin));\n+    fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::view_bytes(s, begin, end) }\n }\n \n@@ -528,7 +528,7 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n // See Issue #1932 for why this is a naive search\n pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n-    assert sep_len > 0u;\n+    fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n \n     while i < l {\n@@ -568,7 +568,7 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n  * # Example\n  *\n  * ~~~\n- * assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n+ * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n  * ~~~\n  */\n pub pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n@@ -1088,8 +1088,8 @@ pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n-        assert start <= end;\n-        assert end <= len(s);\n+        fail_unless!(start <= end);\n+        fail_unless!(end <= len(s));\n         let mut i = start;\n         let b = c as u8;\n         while i < end {\n@@ -1167,8 +1167,8 @@ pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n-        assert start >= end;\n-        assert start <= len(s);\n+        fail_unless!(start >= end);\n+        fail_unless!(start <= len(s));\n         let mut i = start;\n         let b = c as u8;\n         while i > end {\n@@ -1248,9 +1248,9 @@ pub pure fn find_from(s: &str, start: uint, f: fn(char)\n  */\n pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n-    assert start <= end;\n-    assert end <= len(s);\n-    assert is_char_boundary(s, start);\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(s));\n+    fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n         let CharRange {ch, next} = char_range_at(s, i);\n@@ -1328,9 +1328,9 @@ pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n pub pure fn rfind_between(s: &str, start: uint, end: uint,\n                           f: fn(char) -> bool)\n     -> Option<uint> {\n-    assert start >= end;\n-    assert start <= len(s);\n-    assert is_char_boundary(s, start);\n+    fail_unless!(start >= end);\n+    fail_unless!(start <= len(s));\n+    fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i > end {\n         let CharRange {ch, next: prev} = char_range_at_reverse(s, i);\n@@ -1412,7 +1412,7 @@ pub pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n-    assert end <= len(haystack);\n+    fail_unless!(end <= len(haystack));\n     let needle_len = len(needle);\n     if needle_len == 0u { return Some(start); }\n     if needle_len > end { return None; }\n@@ -1574,11 +1574,11 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n             if (ch & 0xFFFF_u32) == ch {\n                 // The BMP falls through (assuming non-surrogate, as it\n                 // should)\n-                assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n+                fail_unless!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n                 u.push(ch as u16)\n             } else {\n                 // Supplementary planes break into surrogates.\n-                assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n+                fail_unless!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n                 ch -= 0x1_0000_u32;\n                 let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n                 let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n@@ -1601,8 +1601,8 @@ pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n \n         } else {\n             let u2 = v[i+1u];\n-            assert u >= 0xD800_u16 && u <= 0xDBFF_u16;\n-            assert u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16;\n+            fail_unless!(u >= 0xD800_u16 && u <= 0xDBFF_u16);\n+            fail_unless!(u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16);\n             let mut c = (u - 0xD800_u16) as char;\n             c = c << 10;\n             c |= (u2 - 0xDC00_u16) as char;\n@@ -1643,8 +1643,8 @@ pub pure fn with_capacity(capacity: uint) -> ~str {\n  * The number of Unicode characters in `s` between the given indices.\n  */\n pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n-    assert is_char_boundary(s, start);\n-    assert is_char_boundary(s, end);\n+    fail_unless!(is_char_boundary(s, start));\n+    fail_unless!(is_char_boundary(s, end));\n     let mut i = start, len = 0u;\n     while i < end {\n         let next = char_range_at(s, i).next;\n@@ -1656,11 +1656,11 @@ pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n pub pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n-    assert is_char_boundary(s, start);\n+    fail_unless!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n     let l = len(s);\n     while cnt > 0u {\n-        assert end < l;\n+        fail_unless!(end < l);\n         let next = char_range_at(s, end).next;\n         cnt -= 1u;\n         end = next;\n@@ -1743,14 +1743,14 @@ pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n-    assert (w != 0u);\n+    fail_unless!((w != 0u));\n     if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n     let mut val = 0u;\n     let end = i + w;\n     let mut i = i + 1u;\n     while i < end {\n         let byte = s[i];\n-        assert (byte & 192u8 == tag_cont_u8);\n+        fail_unless!((byte & 192u8 == tag_cont_u8));\n         val <<= 6u;\n         val += (byte & 63u8) as uint;\n         i += 1u;\n@@ -1816,7 +1816,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n  */\n pub pure fn all_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n-    assert is_char_boundary(s, start);\n+    fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n         let CharRange {ch, next} = char_range_at(s, i);\n@@ -1924,7 +1924,7 @@ pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n-        assert len > 0;\n+        fail_unless!(len > 0);\n         if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n             as_c_str(from_slice(s), f)\n         } else {\n@@ -2005,7 +2005,7 @@ pub fn reserve_at_least(s: &mut ~str, n: uint) {\n pub pure fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n-        assert vcap > 0u;\n+        fail_unless!(vcap > 0u);\n         vcap - 1u\n     }\n }\n@@ -2062,7 +2062,7 @@ pub mod raw {\n         vec::raw::set_len(&mut v, len);\n         v.push(0u8);\n \n-        assert is_utf8(v);\n+        fail_unless!(is_utf8(v));\n         return ::cast::transmute(v);\n     }\n \n@@ -2090,7 +2090,7 @@ pub mod raw {\n     pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n                               f: fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n-        assert is_utf8(::cast::reinterpret_cast(&v));\n+        fail_unless!(is_utf8(::cast::reinterpret_cast(&v)));\n         f(::cast::transmute(v))\n     }\n \n@@ -2106,8 +2106,8 @@ pub mod raw {\n      */\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n-            assert (begin <= end);\n-            assert (end <= n);\n+            fail_unless!((begin <= end));\n+            fail_unless!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n             unsafe {\n@@ -2136,8 +2136,8 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n-             assert (begin <= end);\n-             assert (end <= n);\n+             fail_unless!((begin <= end));\n+             fail_unless!((end <= n));\n \n              let tuple = (ptr::offset(sbuf, begin), end - begin + 1);\n              ::cast::reinterpret_cast(&tuple)\n@@ -2165,7 +2165,7 @@ pub mod raw {\n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n-        assert (len > 0u);\n+        fail_unless!((len > 0u));\n         let b = s[len - 1u];\n         unsafe { set_len(s, len - 1u) };\n         return b;\n@@ -2174,7 +2174,7 @@ pub mod raw {\n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n-        assert (len > 0u);\n+        fail_unless!((len > 0u));\n         let b = s[0];\n         *s = unsafe { raw::slice_bytes(*s, 1u, len) };\n         return b;\n@@ -2196,7 +2196,7 @@ pub mod raw {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n-            assert (c == ~\"AAA\");\n+            fail_unless!((c == ~\"AAA\"));\n         }\n     }\n \n@@ -2441,69 +2441,69 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        assert (eq(&~\"\", &~\"\"));\n-        assert (eq(&~\"foo\", &~\"foo\"));\n-        assert (!eq(&~\"foo\", &~\"bar\"));\n+        fail_unless!((eq(&~\"\", &~\"\")));\n+        fail_unless!((eq(&~\"foo\", &~\"foo\")));\n+        fail_unless!((!eq(&~\"foo\", &~\"bar\")));\n     }\n \n     #[test]\n     fn test_eq_slice() {\n-        assert (eq_slice(view(\"foobar\", 0, 3), \"foo\"));\n-        assert (eq_slice(view(\"barfoo\", 3, 6), \"foo\"));\n-        assert (!eq_slice(\"foo1\", \"foo2\"));\n+        fail_unless!((eq_slice(view(\"foobar\", 0, 3), \"foo\")));\n+        fail_unless!((eq_slice(view(\"barfoo\", 3, 6), \"foo\")));\n+        fail_unless!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n     #[test]\n     fn test_le() {\n-        assert (le(&\"\", &\"\"));\n-        assert (le(&\"\", &\"foo\"));\n-        assert (le(&\"foo\", &\"foo\"));\n-        assert (!eq(&~\"foo\", &~\"bar\"));\n+        fail_unless!((le(&\"\", &\"\")));\n+        fail_unless!((le(&\"\", &\"foo\")));\n+        fail_unless!((le(&\"foo\", &\"foo\")));\n+        fail_unless!((!eq(&~\"foo\", &~\"bar\")));\n     }\n \n     #[test]\n     fn test_len() {\n-        assert (len(~\"\") == 0u);\n-        assert (len(~\"hello world\") == 11u);\n-        assert (len(~\"\\x63\") == 1u);\n-        assert (len(~\"\\xa2\") == 2u);\n-        assert (len(~\"\\u03c0\") == 2u);\n-        assert (len(~\"\\u2620\") == 3u);\n-        assert (len(~\"\\U0001d11e\") == 4u);\n+        fail_unless!((len(~\"\") == 0u));\n+        fail_unless!((len(~\"hello world\") == 11u));\n+        fail_unless!((len(~\"\\x63\") == 1u));\n+        fail_unless!((len(~\"\\xa2\") == 2u));\n+        fail_unless!((len(~\"\\u03c0\") == 2u));\n+        fail_unless!((len(~\"\\u2620\") == 3u));\n+        fail_unless!((len(~\"\\U0001d11e\") == 4u));\n \n-        assert (char_len(~\"\") == 0u);\n-        assert (char_len(~\"hello world\") == 11u);\n-        assert (char_len(~\"\\x63\") == 1u);\n-        assert (char_len(~\"\\xa2\") == 1u);\n-        assert (char_len(~\"\\u03c0\") == 1u);\n-        assert (char_len(~\"\\u2620\") == 1u);\n-        assert (char_len(~\"\\U0001d11e\") == 1u);\n-        assert (char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n+        fail_unless!((char_len(~\"\") == 0u));\n+        fail_unless!((char_len(~\"hello world\") == 11u));\n+        fail_unless!((char_len(~\"\\x63\") == 1u));\n+        fail_unless!((char_len(~\"\\xa2\") == 1u));\n+        fail_unless!((char_len(~\"\\u03c0\") == 1u));\n+        fail_unless!((char_len(~\"\\u2620\") == 1u));\n+        fail_unless!((char_len(~\"\\U0001d11e\") == 1u));\n+        fail_unless!((char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u));\n     }\n \n     #[test]\n     fn test_rfind_char() {\n-        assert rfind_char(~\"hello\", 'l') == Some(3u);\n-        assert rfind_char(~\"hello\", 'o') == Some(4u);\n-        assert rfind_char(~\"hello\", 'h') == Some(0u);\n-        assert rfind_char(~\"hello\", 'z').is_none();\n-        assert rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u);\n+        fail_unless!(rfind_char(~\"hello\", 'l') == Some(3u));\n+        fail_unless!(rfind_char(~\"hello\", 'o') == Some(4u));\n+        fail_unless!(rfind_char(~\"hello\", 'h') == Some(0u));\n+        fail_unless!(rfind_char(~\"hello\", 'z').is_none());\n+        fail_unless!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u));\n     }\n \n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         let cc = pop_char(&mut data);\n-        assert ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n-        assert '\u534e' == cc;\n+        fail_unless!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data);\n+        fail_unless!('\u534e' == cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n         let cc2 = pop_char(&mut data2);\n-        assert ~\"\" == data2;\n-        assert '\u534e' == cc2;\n+        fail_unless!(~\"\" == data2);\n+        fail_unless!('\u534e' == cc2);\n     }\n \n     #[test]\n@@ -2520,27 +2520,27 @@ mod tests {\n             log(debug, ~\"split_byte: \" + s);\n             let v = split_char(s, c);\n             debug!(\"split_byte to: %?\", v);\n-            assert vec::all2(v, u, |a,b| a == b);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n         t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        assert ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n-            == split_char(~\"...hello.there.\", '.');\n+        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n+                     == split_char(~\"...hello.there.\", '.'));\n \n-        assert ~[~\"\"] == split_char(~\"\", 'z');\n-        assert ~[~\"\",~\"\"] == split_char(~\"z\", 'z');\n-        assert ~[~\"ok\"] == split_char(~\"ok\", 'z');\n+        fail_unless!(~[~\"\"] == split_char(~\"\", 'z'));\n+        fail_unless!(~[~\"\",~\"\"] == split_char(~\"z\", 'z'));\n+        fail_unless!(~[~\"ok\"] == split_char(~\"ok\", 'z'));\n     }\n \n     #[test]\n     fn test_split_char_2() {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-            == split_char(data, 'V');\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-            == split_char(data, '\u0e17');\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n+                     == split_char(data, 'V'));\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+                     == split_char(data, '\u0e17'));\n     }\n \n     #[test]\n@@ -2550,7 +2550,7 @@ mod tests {\n             let v = splitn_char(s, c, n);\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert vec::all2(v, u, |a,b| a == b);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);\n         t(~\"abc.hello.there\", '.', 1u, ~[~\"abc\", ~\"hello.there\"]);\n@@ -2562,35 +2562,35 @@ mod tests {\n         t(~\"...hello.there.\", '.', 5u,\n           ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        assert ~[~\"\"] == splitn_char(~\"\", 'z', 5u);\n-        assert ~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u);\n-        assert ~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u);\n-        assert ~[~\"z\"] == splitn_char(~\"z\", 'z', 0u);\n-        assert ~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u);\n-        assert ~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u);\n+        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n+        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n+        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n+        fail_unless!(~[~\"z\"] == splitn_char(~\"z\", 'z', 0u));\n+        fail_unless!(~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u));\n+        fail_unless!(~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u));\n     }\n \n     #[test]\n     fn test_splitn_char_2 () {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-            == splitn_char(data, '\u534e', 1u);\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n+                     == splitn_char(data, '\u534e', 1u));\n \n-        assert ~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n-            == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u);\n-        assert ~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u);\n-        assert ~[~\"\"] == splitn_char(~\"\", 'z', 5u);\n-        assert ~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u);\n+        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n+                     == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u));\n+        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n+        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n+        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n     }\n \n \n     #[test]\n     fn test_splitn_char_3() {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-            == splitn_char(data, 'V', 1u);\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-            == splitn_char(data, '\u0e17', 1u);\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n+                     == splitn_char(data, 'V', 1u));\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+                     == splitn_char(data, '\u0e17', 1u));\n \n     }\n \n@@ -2599,7 +2599,7 @@ mod tests {\n         fn t(s: &str, sep: &a/str, i: int, k: &str) {\n             fn borrow(x: &a/str) -> &a/str { x }\n             let v = split_str(s, sep);\n-            assert borrow(v[i]) == k;\n+            fail_unless!(borrow(v[i]) == k);\n         }\n \n         t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n@@ -2611,146 +2611,148 @@ mod tests {\n         t(~\"::hello::there::\", ~\"::\", 3, ~\"\");\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n-            == split_str (data, ~\"\u4e2d\u534e\");\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n+                     == split_str (data, ~\"\u4e2d\u534e\"));\n \n-        assert ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-            == split_str(~\"zzXXXzzYYYzz\", ~\"zz\");\n+        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n+                     == split_str(~\"zzXXXzzYYYzz\", ~\"zz\"));\n \n-        assert ~[~\"zz\", ~\"zYYYz\"]\n-            == split_str(~\"zzXXXzYYYz\", ~\"XXX\");\n+        fail_unless!(~[~\"zz\", ~\"zYYYz\"] == split_str(~\"zzXXXzYYYz\", ~\"XXX\"));\n \n \n-        assert ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] == split_str(~\".XXX.YYY.\", ~\".\");\n-        assert ~[~\"\"] == split_str(~\"\", ~\".\");\n-        assert ~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\");\n-        assert ~[~\"ok\"] == split_str(~\"ok\", ~\"z\");\n-        assert ~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\");\n-        assert ~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\");\n+        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] ==\n+                     split_str(~\".XXX.YYY.\", ~\".\"));\n+        fail_unless!(~[~\"\"] == split_str(~\"\", ~\".\"));\n+        fail_unless!(~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\"));\n+        fail_unless!(~[~\"ok\"] == split_str(~\"ok\", ~\"z\"));\n+        fail_unless!(~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\"));\n+        fail_unless!(~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\"));\n     }\n \n \n     #[test]\n     fn test_split() {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-            == split (data, |cc| cc == '\u534e');\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n+                     == split (data, |cc| cc == '\u534e'));\n \n-        assert ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-            == split(~\"zzXXXzYYYz\", char::is_lowercase);\n+        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n+                     == split(~\"zzXXXzYYYz\", char::is_lowercase));\n \n-        assert ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n-            == split(~\"zzXXXzYYYz\", char::is_uppercase);\n+        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n+                     == split(~\"zzXXXzYYYz\", char::is_uppercase));\n \n-        assert ~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z');\n-        assert ~[~\"\"] == split(~\"\", |cc| cc == 'z');\n-        assert ~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z');\n+        fail_unless!(~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z'));\n+        fail_unless!(~[~\"\"] == split(~\"\", |cc| cc == 'z'));\n+        fail_unless!(~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z'));\n     }\n \n     #[test]\n     fn test_lines() {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n-            == lines(lf);\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+                     == lines(lf));\n \n-        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n-            == lines_any(lf);\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+                     == lines_any(lf));\n \n-        assert ~[~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\", ~\"\"]\n-            == lines(crlf);\n+        fail_unless!(~[~\"\\r\", ~\"Mary had a little lamb\\r\",\n+                       ~\"Little lamb\\r\", ~\"\"]\n+            == lines(crlf));\n \n-        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n-            == lines_any(crlf);\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+            == lines_any(crlf));\n \n-        assert ~[~\"\"] == lines    (~\"\");\n-        assert ~[~\"\"] == lines_any(~\"\");\n-        assert ~[~\"\",~\"\"] == lines    (~\"\\n\");\n-        assert ~[~\"\",~\"\"] == lines_any(~\"\\n\");\n-        assert ~[~\"banana\"] == lines    (~\"banana\");\n-        assert ~[~\"banana\"] == lines_any(~\"banana\");\n+        fail_unless!(~[~\"\"] == lines    (~\"\"));\n+        fail_unless!(~[~\"\"] == lines_any(~\"\"));\n+        fail_unless!(~[~\"\",~\"\"] == lines    (~\"\\n\"));\n+        fail_unless!(~[~\"\",~\"\"] == lines_any(~\"\\n\"));\n+        fail_unless!(~[~\"banana\"] == lines    (~\"banana\"));\n+        fail_unless!(~[~\"banana\"] == lines_any(~\"banana\"));\n     }\n \n     #[test]\n     fn test_words () {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        assert ~[~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n-            == words(data);\n+        fail_unless!(~[\n+            ~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n+            == words(data));\n \n-        assert ~[~\"ok\"] == words(~\"ok\");\n-        assert ~[] == words(~\"\");\n+        fail_unless!(~[~\"ok\"] == words(~\"ok\"));\n+        fail_unless!(~[] == words(~\"\"));\n     }\n \n     #[test]\n     fn test_split_within() {\n-        assert split_within(~\"\", 0) == ~[];\n-        assert split_within(~\"\", 15) == ~[];\n-        assert split_within(~\"hello\", 15) == ~[~\"hello\"];\n+        fail_unless!(split_within(~\"\", 0) == ~[]);\n+        fail_unless!(split_within(~\"\", 15) == ~[]);\n+        fail_unless!(split_within(~\"hello\", 15) == ~[~\"hello\"]);\n \n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         error!(\"~~~~ %?\", split_within(data, 15));\n-        assert split_within(data, 15) == ~[~\"Mary had a\",\n-                                           ~\"little lamb\",\n-                                           ~\"Little lamb\"];\n+        fail_unless!(split_within(data, 15) == ~[~\"Mary had a\",\n+                                                 ~\"little lamb\",\n+                                                 ~\"Little lamb\"]);\n     }\n \n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert find_str(~\"banana\", ~\"apple pie\").is_none();\n-        assert find_str(~\"\", ~\"\") == Some(0u);\n+        fail_unless!(find_str(~\"banana\", ~\"apple pie\").is_none());\n+        fail_unless!(find_str(~\"\", ~\"\") == Some(0u));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert find_str(data, ~\"\")     == Some(0u);\n-        assert find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u);\n-        assert find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u);\n-        assert find_str(data, ~\"\u4e2d\u534e\") == Some(27u);\n-        assert find_str(data, ~\"\u0e44\u0e17\u534e\").is_none();\n+        fail_unless!(find_str(data, ~\"\")     == Some(0u));\n+        fail_unless!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u));\n+        fail_unless!(find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u));\n+        fail_unless!(find_str(data, ~\"\u4e2d\u534e\") == Some(27u));\n+        fail_unless!(find_str(data, ~\"\u0e44\u0e17\u534e\").is_none());\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        assert find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u);\n+        fail_unless!(find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u));\n \n         let data = ~\"abcabc\";\n-        assert find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u);\n-        assert find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u);\n-        assert find_str_between(data, ~\"ab\", 2u, 4u).is_none();\n+        fail_unless!(find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u));\n+        fail_unless!(find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u));\n+        fail_unless!(find_str_between(data, ~\"ab\", 2u, 4u).is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data = data + data;\n-        assert find_str_between(data, ~\"\", 0u, 43u) == Some(0u);\n-        assert find_str_between(data, ~\"\", 6u, 43u) == Some(6u);\n+        fail_unless!(find_str_between(data, ~\"\", 0u, 43u) == Some(0u));\n+        fail_unless!(find_str_between(data, ~\"\", 6u, 43u) == Some(6u));\n \n-        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u);\n-        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u);\n-        assert find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u);\n-        assert find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u);\n-        assert find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u);\n+        fail_unless!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u));\n+        fail_unless!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u));\n+        fail_unless!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u));\n+        fail_unless!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u));\n+        fail_unless!(find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u));\n \n-        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u);\n-        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u);\n-        assert find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u);\n-        assert find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u);\n-        assert find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u);\n+        fail_unless!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u));\n+        fail_unless!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u));\n+        fail_unless!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u));\n+        fail_unless!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u));\n+        fail_unless!(find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u));\n     }\n \n     #[test]\n     fn test_substr() {\n         fn t(a: &str, b: &str, start: int) {\n-            assert substr(a, start as uint, len(b)) == b.to_str();\n+            fail_unless!(substr(a, start as uint, len(b)) == b.to_str());\n         }\n         t(~\"hello\", ~\"llo\", 2);\n         t(~\"hello\", ~\"el\", 1);\n-        assert ~\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u);\n+        fail_unless!(~\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n     }\n \n     #[test]\n     fn test_concat() {\n         fn t(v: &[~str], s: &str) {\n-            assert concat(v) == s.to_str();\n+            fail_unless!(concat(v) == s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n         let v: ~[~str] = ~[];\n@@ -2761,7 +2763,7 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n-            assert connect(v, sep) == s.to_str();\n+            fail_unless!(connect(v, sep) == s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           ~\" \", ~\"you know I'm no good\");\n@@ -2773,7 +2775,7 @@ mod tests {\n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n-            assert connect_slices(v, sep) == s.to_str();\n+            fail_unless!(connect_slices(v, sep) == s.to_str());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");\n@@ -2783,11 +2785,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert repeat(~\"x\", 4) == ~\"xxxx\";\n-        assert repeat(~\"hi\", 4) == ~\"hihihihi\";\n-        assert repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\";\n-        assert repeat(~\"\", 4) == ~\"\";\n-        assert repeat(~\"hi\", 0) == ~\"\";\n+        fail_unless!(repeat(~\"x\", 4) == ~\"xxxx\");\n+        fail_unless!(repeat(~\"hi\", 4) == ~\"hihihihi\");\n+        fail_unless!(repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n+        fail_unless!(repeat(~\"\", 4) == ~\"\");\n+        fail_unless!(repeat(~\"hi\", 0) == ~\"\");\n     }\n \n     #[test]\n@@ -2799,24 +2801,25 @@ mod tests {\n         let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n         let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n         let actual = to_upper(input);\n-        assert expected == actual;\n+        fail_unless!(expected == actual);\n     }\n \n     #[test]\n     fn test_to_lower() {\n         unsafe {\n-            assert ~\"\" == map(~\"\", |c| libc::tolower(c as c_char) as char);\n-            assert ~\"ymca\" == map(~\"YMCA\",\n-                                 |c| libc::tolower(c as c_char) as char);\n+            fail_unless!(~\"\" == map(~\"\",\n+                |c| libc::tolower(c as c_char) as char));\n+            fail_unless!(~\"ymca\" == map(~\"YMCA\",\n+                |c| libc::tolower(c as c_char) as char));\n         }\n     }\n \n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2);\n-            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3);\n-            assert ~\"\" == raw::slice_bytes(~\"abc\", 1, 1);\n+            fail_unless!(~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2));\n+            fail_unless!(~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3));\n+            fail_unless!(~\"\" == raw::slice_bytes(~\"abc\", 1, 1));\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n@@ -2829,44 +2832,45 @@ mod tests {\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n                 rs\n             }\n-            assert half_a_million_letter_a() ==\n-                raw::slice_bytes(a_million_letter_a(), 0u, 500000);\n+            fail_unless!(half_a_million_letter_a() ==\n+                raw::slice_bytes(a_million_letter_a(), 0u, 500000));\n         }\n     }\n \n     #[test]\n     fn test_starts_with() {\n-        assert (starts_with(~\"\", ~\"\"));\n-        assert (starts_with(~\"abc\", ~\"\"));\n-        assert (starts_with(~\"abc\", ~\"a\"));\n-        assert (!starts_with(~\"a\", ~\"abc\"));\n-        assert (!starts_with(~\"\", ~\"abc\"));\n+        fail_unless!((starts_with(~\"\", ~\"\")));\n+        fail_unless!((starts_with(~\"abc\", ~\"\")));\n+        fail_unless!((starts_with(~\"abc\", ~\"a\")));\n+        fail_unless!((!starts_with(~\"a\", ~\"abc\")));\n+        fail_unless!((!starts_with(~\"\", ~\"abc\")));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert (ends_with(~\"\", ~\"\"));\n-        assert (ends_with(~\"abc\", ~\"\"));\n-        assert (ends_with(~\"abc\", ~\"c\"));\n-        assert (!ends_with(~\"a\", ~\"abc\"));\n-        assert (!ends_with(~\"\", ~\"abc\"));\n+        fail_unless!((ends_with(~\"\", ~\"\")));\n+        fail_unless!((ends_with(~\"abc\", ~\"\")));\n+        fail_unless!((ends_with(~\"abc\", ~\"c\")));\n+        fail_unless!((!ends_with(~\"a\", ~\"abc\")));\n+        fail_unless!((!ends_with(~\"\", ~\"abc\")));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        assert (is_empty(~\"\"));\n-        assert (!is_empty(~\"a\"));\n+        fail_unless!((is_empty(~\"\")));\n+        fail_unless!((!is_empty(~\"a\")));\n     }\n \n     #[test]\n     fn test_replace() {\n         let a = ~\"a\";\n-        assert replace(~\"\", a, ~\"b\") == ~\"\";\n-        assert replace(~\"a\", a, ~\"b\") == ~\"b\";\n-        assert replace(~\"ab\", a, ~\"b\") == ~\"bb\";\n+        fail_unless!(replace(~\"\", a, ~\"b\") == ~\"\");\n+        fail_unless!(replace(~\"a\", a, ~\"b\") == ~\"b\");\n+        fail_unless!(replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n         let test = ~\"test\";\n-        assert replace(~\" test test \", test, ~\"toast\") == ~\" toast toast \";\n-        assert replace(~\" test test \", test, ~\"\") == ~\"   \";\n+        fail_unless!(replace(~\" test test \", test, ~\"toast\") ==\n+            ~\" toast toast \");\n+        fail_unless!(replace(~\" test test \", test, ~\"\") == ~\"   \");\n     }\n \n     #[test]\n@@ -2876,7 +2880,7 @@ mod tests {\n \n         let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n         let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert (replace(data, a, repl) ==  A);\n+        fail_unless!((replace(data, a, repl) ==  A));\n     }\n \n     #[test]\n@@ -2886,7 +2890,7 @@ mod tests {\n \n         let b = ~\"\u0e30\u0e40\";\n         let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert (replace(data, b,   repl) ==  B);\n+        fail_unless!((replace(data, b,   repl) ==  B));\n     }\n \n     #[test]\n@@ -2896,7 +2900,7 @@ mod tests {\n \n         let c = ~\"\u4e2d\u534e\";\n         let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert (replace(data, c, repl) ==  C);\n+        fail_unless!((replace(data, c, repl) ==  C));\n     }\n \n     #[test]\n@@ -2905,21 +2909,21 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = ~\"\u0e44\u0e17\u534e\";\n-        assert (replace(data, d, repl) == data);\n+        fail_unless!((replace(data, d, repl) == data));\n     }\n \n     #[test]\n     fn test_slice() {\n-        assert ~\"ab\" == slice(~\"abc\", 0, 2);\n-        assert ~\"bc\" == slice(~\"abc\", 1, 3);\n-        assert ~\"\" == slice(~\"abc\", 1, 1);\n-        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3);\n+        fail_unless!(~\"ab\" == slice(~\"abc\", 0, 2));\n+        fail_unless!(~\"bc\" == slice(~\"abc\", 1, 3));\n+        fail_unless!(~\"\" == slice(~\"abc\", 1, 1));\n+        fail_unless!(~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert ~\"\u0e1b\" == slice(data, 0, 3);\n-        assert ~\"\u0e23\" == slice(data, 3, 6);\n-        assert ~\"\" == slice(data, 3, 3);\n-        assert ~\"\u534e\" == slice(data, 30, 33);\n+        fail_unless!(~\"\u0e1b\" == slice(data, 0, 3));\n+        fail_unless!(~\"\u0e23\" == slice(data, 3, 6));\n+        fail_unless!(~\"\" == slice(data, 3, 3));\n+        fail_unless!(~\"\u534e\" == slice(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -2936,24 +2940,24 @@ mod tests {\n             while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             rs\n         }\n-        assert half_a_million_letter_X() ==\n-            slice(a_million_letter_X(), 0u, 3u * 500000u);\n+        fail_unless!(half_a_million_letter_X() ==\n+            slice(a_million_letter_X(), 0u, 3u * 500000u));\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = ~\"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert ~\"\u534e\" == slice(ss, 3u, 6u);\n-        assert ~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u);\n+        fail_unless!(~\"\u534e\" == slice(ss, 3u, 6u));\n+        fail_unless!(~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n \n-        assert ~\"ab\" == slice(~\"abc\", 0u, 2u);\n-        assert ~\"bc\" == slice(~\"abc\", 1u, 3u);\n-        assert ~\"\" == slice(~\"abc\", 1u, 1u);\n+        fail_unless!(~\"ab\" == slice(~\"abc\", 0u, 2u));\n+        fail_unless!(~\"bc\" == slice(~\"abc\", 1u, 3u));\n+        fail_unless!(~\"\" == slice(~\"abc\", 1u, 1u));\n \n-        assert ~\"\u4e2d\" == slice(ss, 0u, 3u);\n-        assert ~\"\u534eV\" == slice(ss, 3u, 7u);\n-        assert ~\"\" == slice(ss, 3u, 3u);\n+        fail_unless!(~\"\u4e2d\" == slice(ss, 0u, 3u));\n+        fail_unless!(~\"\u534eV\" == slice(ss, 3u, 7u));\n+        fail_unless!(~\"\" == slice(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -2975,95 +2979,101 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        assert trim_left_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \";\n-        assert trim_left_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo *** \";\n-        assert trim_left_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\";\n-        assert trim_left_chars(~\"foo *** \", ~['*', ' ']) == ~\"foo *** \";\n+        fail_unless!(trim_left_chars(~\" *** foo *** \", ~[]) ==\n+                     ~\" *** foo *** \");\n+        fail_unless!(trim_left_chars(~\" *** foo *** \", ~['*', ' ']) ==\n+                     ~\"foo *** \");\n+        fail_unless!(trim_left_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n+        fail_unless!(trim_left_chars(~\"foo *** \", ~['*', ' ']) ==\n+                     ~\"foo *** \");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        assert trim_right_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \";\n-        assert trim_right_chars(~\" *** foo *** \", ~['*', ' ']) == ~\" *** foo\";\n-        assert trim_right_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\";\n-        assert trim_right_chars(~\" *** foo\", ~['*', ' ']) == ~\" *** foo\";\n+        fail_unless!(trim_right_chars(~\" *** foo *** \", ~[]) ==\n+                     ~\" *** foo *** \");\n+        fail_unless!(trim_right_chars(~\" *** foo *** \", ~['*', ' ']) ==\n+                     ~\" *** foo\");\n+        fail_unless!(trim_right_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n+        fail_unless!(trim_right_chars(~\" *** foo\", ~['*', ' ']) ==\n+                     ~\" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert trim_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \";\n-        assert trim_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo\";\n-        assert trim_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\";\n-        assert trim_chars(~\"foo\", ~['*', ' ']) == ~\"foo\";\n+        fail_unless!(trim_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \");\n+        fail_unless!(trim_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo\");\n+        fail_unless!(trim_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n+        fail_unless!(trim_chars(~\"foo\", ~['*', ' ']) == ~\"foo\");\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        assert (trim_left(~\"\") == ~\"\");\n-        assert (trim_left(~\"a\") == ~\"a\");\n-        assert (trim_left(~\"    \") == ~\"\");\n-        assert (trim_left(~\"     blah\") == ~\"blah\");\n-        assert (trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n-        assert (trim_left(~\"hey \") == ~\"hey \");\n+        fail_unless!((trim_left(~\"\") == ~\"\"));\n+        fail_unless!((trim_left(~\"a\") == ~\"a\"));\n+        fail_unless!((trim_left(~\"    \") == ~\"\"));\n+        fail_unless!((trim_left(~\"     blah\") == ~\"blah\"));\n+        fail_unless!((trim_left(~\"   \\u3000  wut\") == ~\"wut\"));\n+        fail_unless!((trim_left(~\"hey \") == ~\"hey \"));\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        assert (trim_right(~\"\") == ~\"\");\n-        assert (trim_right(~\"a\") == ~\"a\");\n-        assert (trim_right(~\"    \") == ~\"\");\n-        assert (trim_right(~\"blah     \") == ~\"blah\");\n-        assert (trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n-        assert (trim_right(~\" hey\") == ~\" hey\");\n+        fail_unless!((trim_right(~\"\") == ~\"\"));\n+        fail_unless!((trim_right(~\"a\") == ~\"a\"));\n+        fail_unless!((trim_right(~\"    \") == ~\"\"));\n+        fail_unless!((trim_right(~\"blah     \") == ~\"blah\"));\n+        fail_unless!((trim_right(~\"wut   \\u3000  \") == ~\"wut\"));\n+        fail_unless!((trim_right(~\" hey\") == ~\" hey\"));\n     }\n \n     #[test]\n     fn test_trim() {\n-        assert (trim(~\"\") == ~\"\");\n-        assert (trim(~\"a\") == ~\"a\");\n-        assert (trim(~\"    \") == ~\"\");\n-        assert (trim(~\"    blah     \") == ~\"blah\");\n-        assert (trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n-        assert (trim(~\" hey dude \") == ~\"hey dude\");\n+        fail_unless!((trim(~\"\") == ~\"\"));\n+        fail_unless!((trim(~\"a\") == ~\"a\"));\n+        fail_unless!((trim(~\"    \") == ~\"\"));\n+        fail_unless!((trim(~\"    blah     \") == ~\"blah\"));\n+        fail_unless!((trim(~\"\\nwut   \\u3000  \") == ~\"wut\"));\n+        fail_unless!((trim(~\" hey dude \") == ~\"hey dude\"));\n     }\n \n     #[test]\n     fn test_is_whitespace() {\n-        assert (is_whitespace(~\"\"));\n-        assert (is_whitespace(~\" \"));\n-        assert (is_whitespace(~\"\\u2009\")); // Thin space\n-        assert (is_whitespace(~\"  \\n\\t   \"));\n-        assert (!is_whitespace(~\"   _   \"));\n+        fail_unless!((is_whitespace(~\"\")));\n+        fail_unless!((is_whitespace(~\" \")));\n+        fail_unless!((is_whitespace(~\"\\u2009\"))); // Thin space\n+        fail_unless!((is_whitespace(~\"  \\n\\t   \")));\n+        fail_unless!((!is_whitespace(~\"   _   \")));\n     }\n \n     #[test]\n     fn test_is_ascii() {\n-        assert (is_ascii(~\"\"));\n-        assert (is_ascii(~\"a\"));\n-        assert (!is_ascii(~\"\\u2009\"));\n+        fail_unless!((is_ascii(~\"\")));\n+        fail_unless!((is_ascii(~\"a\")));\n+        fail_unless!((!is_ascii(~\"\\u2009\")));\n     }\n \n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe { raw::shift_byte(&mut s) };\n-        assert (s == ~\"BC\");\n-        assert (b == 65u8);\n+        fail_unless!((s == ~\"BC\"));\n+        fail_unless!((b == 65u8));\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe { raw::pop_byte(&mut s) };\n-        assert (s == ~\"AB\");\n-        assert (b == 67u8);\n+        fail_unless!((s == ~\"AB\"));\n+        fail_unless!((b == 67u8));\n     }\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n         let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n         let b = unsafe { raw::from_bytes(a) };\n-        assert (b == ~\"AAAAAAA\");\n+        fail_unless!((b == ~\"AAAAAAA\"));\n     }\n \n     #[test]\n@@ -3080,7 +3090,7 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-        assert ss == from_bytes(bb);\n+        fail_unless!(ss == from_bytes(bb));\n     }\n \n     #[test]\n@@ -3107,7 +3117,7 @@ mod tests {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = raw::from_buf(b);\n-            assert (c == ~\"AAAAAAA\");\n+            fail_unless!((c == ~\"AAAAAAA\"));\n         }\n     }\n \n@@ -3123,20 +3133,20 @@ mod tests {\n     fn test_as_buf() {\n         let a = ~\"Abcdefg\";\n         let b = as_buf(a, |buf, _l| {\n-            assert unsafe { *buf } == 65u8;\n+            fail_unless!(unsafe { *buf } == 65u8);\n             100\n         });\n-        assert (b == 100);\n+        fail_unless!((b == 100));\n     }\n \n     #[test]\n     fn test_as_buf_small() {\n         let a = ~\"A\";\n         let b = as_buf(a, |buf, _l| {\n-            assert unsafe { *buf } == 65u8;\n+            fail_unless!(unsafe { *buf } == 65u8);\n             100\n         });\n-        assert (b == 100);\n+        fail_unless!((b == 100));\n     }\n \n     #[test]\n@@ -3145,7 +3155,7 @@ mod tests {\n             let s = ~\"hello\";\n             let sb = as_buf(s, |b, _l| b);\n             let s_cstr = raw::from_buf(sb);\n-            assert s_cstr == s;\n+            fail_unless!(s_cstr == s);\n         }\n     }\n \n@@ -3154,11 +3164,11 @@ mod tests {\n         let a = ~\"hello\";\n         do as_buf(a) |buf, len| {\n             unsafe {\n-                assert a[0] == 'h' as u8;\n-                assert *buf == 'h' as u8;\n-                assert len == 6u;\n-                assert *ptr::offset(buf,4u) == 'o' as u8;\n-                assert *ptr::offset(buf,5u) == 0u8;\n+                fail_unless!(a[0] == 'h' as u8);\n+                fail_unless!(*buf == 'h' as u8);\n+                fail_unless!(len == 6u);\n+                fail_unless!(*ptr::offset(buf,4u) == 'o' as u8);\n+                fail_unless!(*ptr::offset(buf,5u) == 0u8);\n             }\n         }\n     }\n@@ -3172,50 +3182,50 @@ mod tests {\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n         let n2: uint = vec::len::<u8>(v);\n-        assert (n1 == n2);\n+        fail_unless!((n1 == n2));\n         while i < n1 {\n             let a: u8 = s1[i];\n             let b: u8 = s2[i];\n             log(debug, a);\n             log(debug, b);\n-            assert (a == b);\n+            fail_unless!((a == b));\n             i += 1u;\n         }\n     }\n \n     #[test]\n     fn test_contains() {\n-        assert contains(~\"abcde\", ~\"bcd\");\n-        assert contains(~\"abcde\", ~\"abcd\");\n-        assert contains(~\"abcde\", ~\"bcde\");\n-        assert contains(~\"abcde\", ~\"\");\n-        assert contains(~\"\", ~\"\");\n-        assert !contains(~\"abcde\", ~\"def\");\n-        assert !contains(~\"\", ~\"a\");\n+        fail_unless!(contains(~\"abcde\", ~\"bcd\"));\n+        fail_unless!(contains(~\"abcde\", ~\"abcd\"));\n+        fail_unless!(contains(~\"abcde\", ~\"bcde\"));\n+        fail_unless!(contains(~\"abcde\", ~\"\"));\n+        fail_unless!(contains(~\"\", ~\"\"));\n+        fail_unless!(!contains(~\"abcde\", ~\"def\"));\n+        fail_unless!(!contains(~\"\", ~\"a\"));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert  contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\");\n-        assert  contains(data, ~\"\u0e30\u0e40\");\n-        assert  contains(data, ~\"\u4e2d\u534e\");\n-        assert !contains(data, ~\"\u0e44\u0e17\u534e\");\n+        fail_unless!(contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"));\n+        fail_unless!(contains(data, ~\"\u0e30\u0e40\"));\n+        fail_unless!(contains(data, ~\"\u4e2d\u534e\"));\n+        fail_unless!(!contains(data, ~\"\u0e44\u0e17\u534e\"));\n     }\n \n     #[test]\n     fn test_contains_char() {\n-        assert contains_char(~\"abc\", 'b');\n-        assert contains_char(~\"a\", 'a');\n-        assert !contains_char(~\"abc\", 'd');\n-        assert !contains_char(~\"\", 'a');\n+        fail_unless!(contains_char(~\"abc\", 'b'));\n+        fail_unless!(contains_char(~\"a\", 'a'));\n+        fail_unless!(!contains_char(~\"abc\", 'd'));\n+        fail_unless!(!contains_char(~\"\", 'a'));\n     }\n \n     #[test]\n     fn test_chars_each() {\n         let mut i = 0;\n         for chars_each(~\"x\\u03c0y\") |ch| {\n             match i {\n-              0 => assert ch == 'x',\n-              1 => assert ch == '\\u03c0',\n-              2 => assert ch == 'y',\n+              0 => fail_unless!(ch == 'x'),\n+              1 => fail_unless!(ch == '\\u03c0'),\n+              2 => fail_unless!(ch == 'y'),\n               _ => fail!(~\"test_chars_each failed\")\n             }\n             i += 1;\n@@ -3230,16 +3240,16 @@ mod tests {\n \n         for bytes_each(~\"xyz\") |bb| {\n             match i {\n-              0 => assert bb == 'x' as u8,\n-              1 => assert bb == 'y' as u8,\n-              2 => assert bb == 'z' as u8,\n+              0 => fail_unless!(bb == 'x' as u8),\n+              1 => fail_unless!(bb == 'y' as u8),\n+              2 => fail_unless!(bb == 'z' as u8),\n               _ => fail!(~\"test_bytes_each failed\")\n             }\n             i += 1;\n         }\n \n         for bytes_each(~\"\") |bb| {\n-            assert bb == 0u8;\n+            fail_unless!(bb == 0u8);\n         }\n     }\n \n@@ -3251,10 +3261,10 @@ mod tests {\n \n         for split_char_each(data, ' ') |xx| {\n             match ii {\n-              0 => assert \"\\nMary\" == xx,\n-              1 => assert \"had\"    == xx,\n-              2 => assert \"a\"      == xx,\n-              3 => assert \"little\" == xx,\n+              0 => fail_unless!(\"\\nMary\" == xx),\n+              1 => fail_unless!(\"had\"    == xx),\n+              2 => fail_unless!(\"a\"      == xx),\n+              3 => fail_unless!(\"little\" == xx),\n               _ => ()\n             }\n             ii += 1;\n@@ -3269,9 +3279,9 @@ mod tests {\n \n         for splitn_char_each(data, ' ', 2u) |xx| {\n             match ii {\n-              0 => assert \"\\nMary\" == xx,\n-              1 => assert \"had\"    == xx,\n-              2 => assert \"a little lamb\\nLittle lamb\\n\" == xx,\n+              0 => fail_unless!(\"\\nMary\" == xx),\n+              1 => fail_unless!(\"had\"    == xx),\n+              2 => fail_unless!(\"a little lamb\\nLittle lamb\\n\" == xx),\n               _ => ()\n             }\n             ii += 1;\n@@ -3286,10 +3296,10 @@ mod tests {\n \n         for words_each(data) |ww| {\n             match ii {\n-              0 => assert \"Mary\"   == ww,\n-              1 => assert \"had\"    == ww,\n-              2 => assert \"a\"      == ww,\n-              3 => assert \"little\" == ww,\n+              0 => fail_unless!(\"Mary\"   == ww),\n+              1 => fail_unless!(\"had\"    == ww),\n+              2 => fail_unless!(\"a\"      == ww),\n+              3 => fail_unless!(\"little\" == ww),\n               _ => ()\n             }\n             ii += 1;\n@@ -3306,10 +3316,10 @@ mod tests {\n \n         for lines_each(lf) |x| {\n             match ii {\n-                0 => assert \"\" == x,\n-                1 => assert \"Mary had a little lamb\" == x,\n-                2 => assert \"Little lamb\" == x,\n-                3 => assert \"\" == x,\n+                0 => fail_unless!(\"\" == x),\n+                1 => fail_unless!(\"Mary had a little lamb\" == x),\n+                2 => fail_unless!(\"Little lamb\" == x),\n+                3 => fail_unless!(\"\" == x),\n                 _ => ()\n             }\n             ii += 1;\n@@ -3319,35 +3329,37 @@ mod tests {\n     #[test]\n     fn test_map() {\n         unsafe {\n-            assert ~\"\" == map(~\"\", |c| libc::toupper(c as c_char) as char);\n-            assert ~\"YMCA\" == map(~\"ymca\",\n-                                  |c| libc::toupper(c as c_char) as char);\n+            fail_unless!(~\"\" == map(~\"\", |c|\n+                libc::toupper(c as c_char) as char));\n+            fail_unless!(~\"YMCA\" == map(~\"ymca\",\n+                                  |c| libc::toupper(c as c_char) as char));\n         }\n     }\n \n     #[test]\n     fn test_all() {\n-        assert true  == all(~\"\", char::is_uppercase);\n-        assert false == all(~\"ymca\", char::is_uppercase);\n-        assert true  == all(~\"YMCA\", char::is_uppercase);\n-        assert false == all(~\"yMCA\", char::is_uppercase);\n-        assert false == all(~\"YMCy\", char::is_uppercase);\n+        fail_unless!(true  == all(~\"\", char::is_uppercase));\n+        fail_unless!(false == all(~\"ymca\", char::is_uppercase));\n+        fail_unless!(true  == all(~\"YMCA\", char::is_uppercase));\n+        fail_unless!(false == all(~\"yMCA\", char::is_uppercase));\n+        fail_unless!(false == all(~\"YMCy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_any() {\n-        assert false  == any(~\"\", char::is_uppercase);\n-        assert false == any(~\"ymca\", char::is_uppercase);\n-        assert true  == any(~\"YMCA\", char::is_uppercase);\n-        assert true == any(~\"yMCA\", char::is_uppercase);\n-        assert true == any(~\"Ymcy\", char::is_uppercase);\n+        fail_unless!(false  == any(~\"\", char::is_uppercase));\n+        fail_unless!(false == any(~\"ymca\", char::is_uppercase));\n+        fail_unless!(true  == any(~\"YMCA\", char::is_uppercase));\n+        fail_unless!(true == any(~\"yMCA\", char::is_uppercase));\n+        fail_unless!(true == any(~\"Ymcy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_chars() {\n         let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m']\n-            == chars(ss);\n+        fail_unless!(~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a',\n+                       'm']\n+            == chars(ss));\n     }\n \n     #[test]\n@@ -3391,10 +3403,10 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             let (s, u) = copy *p;\n-            assert to_utf16(s) == u;\n-            assert from_utf16(u) == s;\n-            assert from_utf16(to_utf16(s)) == s;\n-            assert to_utf16(from_utf16(u)) == u;\n+            fail_unless!(to_utf16(s) == u);\n+            fail_unless!(from_utf16(u) == s);\n+            fail_unless!(from_utf16(to_utf16(s)) == s);\n+            fail_unless!(to_utf16(from_utf16(u)) == u);\n         }\n     }\n \n@@ -3408,40 +3420,41 @@ mod tests {\n                 break;\n             }\n         }\n-        assert found_b;\n+        fail_unless!(found_b);\n     }\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\";\n-        assert escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\";\n-        assert escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\";\n-        assert escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\";\n-        assert escape_unicode(~\"\\x00\\x01\\xfe\\xff\") == ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\";\n-        assert escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\";\n-        assert escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n-            ~\"\\\\U00010000\\\\U0010ffff\";\n-        assert escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\";\n-        assert escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\";\n+        fail_unless!(escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\");\n+        fail_unless!(escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\");\n+        fail_unless!(escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\");\n+        fail_unless!(escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\");\n+        fail_unless!(escape_unicode(~\"\\x00\\x01\\xfe\\xff\") ==\n+                     ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n+        fail_unless!(escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        fail_unless!(escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n+            ~\"\\\\U00010000\\\\U0010ffff\");\n+        fail_unless!(escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\");\n+        fail_unless!(escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\");\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert escape_default(~\"abc\") == ~\"abc\";\n-        assert escape_default(~\"a c\") == ~\"a c\";\n-        assert escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\";\n-        assert escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\";\n-        assert escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\";\n-        assert escape_default(~\"\\U00010000\\U0010ffff\") ==\n-            ~\"\\\\U00010000\\\\U0010ffff\";\n-        assert escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\";\n-        assert escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\";\n+        fail_unless!(escape_default(~\"abc\") == ~\"abc\");\n+        fail_unless!(escape_default(~\"a c\") == ~\"a c\");\n+        fail_unless!(escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\");\n+        fail_unless!(escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\");\n+        fail_unless!(escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        fail_unless!(escape_default(~\"\\U00010000\\U0010ffff\") ==\n+            ~\"\\\\U00010000\\\\U0010ffff\");\n+        fail_unless!(escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\");\n+        fail_unless!(escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n     #[test]\n     fn test_to_managed() {\n-        assert (~\"abc\").to_managed() == @\"abc\";\n-        assert view(\"abcdef\", 1, 5).to_managed() == @\"bcde\";\n+        fail_unless!((~\"abc\").to_managed() == @\"abc\");\n+        fail_unless!(view(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "d4db61f4519c3acb79410380f11832391db5bc89", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -22,32 +22,40 @@ use str;\n pub type FreeGlue = &self/fn(*TypeDesc, *c_void);\n \n // Corresponds to runtime type_desc type\n-pub enum TypeDesc = {\n+pub struct TypeDesc {\n     size: uint,\n     align: uint,\n     take_glue: uint,\n     drop_glue: uint,\n     free_glue: uint\n     // Remaining fields not listed\n-};\n+}\n \n /// The representation of a Rust closure\n pub struct Closure {\n     code: *(),\n     env: *(),\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn get_tydesc<T>() -> *();\n-    fn size_of<T>() -> uint;\n-    fn pref_align_of<T>() -> uint;\n-    fn min_align_of<T>() -> uint;\n+pub mod rusti {\n+    #[abi = \"rust-intrinsic\"]\n+    pub extern {\n+        fn get_tydesc<T>() -> *();\n+        fn size_of<T>() -> uint;\n+        fn pref_align_of<T>() -> uint;\n+        fn min_align_of<T>() -> uint;\n+    }\n }\n \n-extern mod rustrt {\n-    #[rust_stack]\n-    unsafe fn rust_upcall_fail(expr: *c_char, file: *c_char, line: size_t);\n+pub mod rustrt {\n+    use libc::{c_char, size_t};\n+\n+    pub extern {\n+        #[rust_stack]\n+        unsafe fn rust_upcall_fail(expr: *c_char,\n+                                   file: *c_char,\n+                                   line: size_t);\n+    }\n }\n \n /// Compares contents of two pointers using the default method.\n@@ -148,64 +156,71 @@ pub pure fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     }\n }\n \n+pub pure fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n+    unsafe {\n+        let (msg, file) = (msg.to_owned(), file.to_owned());\n+        begin_unwind(~\"assertion failed: \" + msg, file, line)\n+    }\n+}\n+\n #[cfg(test)]\n pub mod tests {\n     use cast;\n     use sys::{Closure, pref_align_of, size_of, nonzero_size_of};\n \n     #[test]\n     pub fn size_of_basic() {\n-        assert size_of::<u8>() == 1u;\n-        assert size_of::<u16>() == 2u;\n-        assert size_of::<u32>() == 4u;\n-        assert size_of::<u64>() == 8u;\n+        fail_unless!(size_of::<u8>() == 1u);\n+        fail_unless!(size_of::<u16>() == 2u);\n+        fail_unless!(size_of::<u32>() == 4u);\n+        fail_unless!(size_of::<u64>() == 8u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     pub fn size_of_32() {\n-        assert size_of::<uint>() == 4u;\n-        assert size_of::<*uint>() == 4u;\n+        fail_unless!(size_of::<uint>() == 4u);\n+        fail_unless!(size_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn size_of_64() {\n-        assert size_of::<uint>() == 8u;\n-        assert size_of::<*uint>() == 8u;\n+        fail_unless!(size_of::<uint>() == 8u);\n+        fail_unless!(size_of::<*uint>() == 8u);\n     }\n \n     #[test]\n     pub fn nonzero_size_of_basic() {\n         type Z = [i8 * 0];\n-        assert size_of::<Z>() == 0u;\n-        assert nonzero_size_of::<Z>() == 1u;\n-        assert nonzero_size_of::<uint>() == size_of::<uint>();\n+        fail_unless!(size_of::<Z>() == 0u);\n+        fail_unless!(nonzero_size_of::<Z>() == 1u);\n+        fail_unless!(nonzero_size_of::<uint>() == size_of::<uint>());\n     }\n \n     #[test]\n     pub fn align_of_basic() {\n-        assert pref_align_of::<u8>() == 1u;\n-        assert pref_align_of::<u16>() == 2u;\n-        assert pref_align_of::<u32>() == 4u;\n+        fail_unless!(pref_align_of::<u8>() == 1u);\n+        fail_unless!(pref_align_of::<u16>() == 2u);\n+        fail_unless!(pref_align_of::<u32>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     pub fn align_of_32() {\n-        assert pref_align_of::<uint>() == 4u;\n-        assert pref_align_of::<*uint>() == 4u;\n+        fail_unless!(pref_align_of::<uint>() == 4u);\n+        fail_unless!(pref_align_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn align_of_64() {\n-        assert pref_align_of::<uint>() == 8u;\n-        assert pref_align_of::<*uint>() == 8u;\n+        fail_unless!(pref_align_of::<uint>() == 8u);\n+        fail_unless!(pref_align_of::<*uint>() == 8u);\n     }\n \n     #[test]\n@@ -214,7 +229,7 @@ pub mod tests {\n             let x = 10;\n             let f: fn(int) -> int = |y| x + y;\n \n-            assert f(20) == 30;\n+            fail_unless!(f(20) == 30);\n \n             let original_closure: Closure = cast::transmute(f);\n \n@@ -227,7 +242,7 @@ pub mod tests {\n             };\n \n             let new_f: fn(int) -> int = cast::transmute(new_closure);\n-            assert new_f(20) == 30;\n+            fail_unless!(new_f(20) == 30);\n         }\n     }\n }"}, {"sha": "72c328d4613bc179f8b7c1bf9f79ab5d193ebea7", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -92,16 +92,17 @@ fn test_tls_multitask() {\n         do task::spawn {\n             unsafe {\n                 // TLS shouldn't carry over.\n-                assert local_data_get(my_key).is_none();\n+                fail_unless!(local_data_get(my_key).is_none());\n                 local_data_set(my_key, @~\"child data\");\n-                assert *(local_data_get(my_key).get()) == ~\"child data\";\n+                fail_unless!(*(local_data_get(my_key).get()) ==\n+                    ~\"child data\");\n                 // should be cleaned up for us\n             }\n         }\n         // Must work multiple times\n-        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n     }\n }\n \n@@ -111,7 +112,7 @@ fn test_tls_overwrite() {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"first data\");\n         local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n-        assert *(local_data_get(my_key).get()) == ~\"next data\";\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"next data\");\n     }\n }\n \n@@ -120,9 +121,9 @@ fn test_tls_pop() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"weasel\");\n-        assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n+        fail_unless!(*(local_data_pop(my_key).get()) == ~\"weasel\");\n         // Pop must remove the data from the map.\n-        assert local_data_pop(my_key).is_none();\n+        fail_unless!(local_data_pop(my_key).is_none());\n     }\n }\n \n@@ -143,7 +144,7 @@ fn test_tls_modify() {\n                 None                 => fail!(~\"missing value\")\n             }\n         });\n-        assert *(local_data_pop(my_key).get()) == ~\"next data\";\n+        fail_unless!(*(local_data_pop(my_key).get()) == ~\"next data\");\n     }\n }\n "}, {"sha": "cb1283019ebaa6102d7ed1dcb2f4da421464332a", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -43,7 +43,7 @@ type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n-        assert !map_ptr.is_null();\n+        fail_unless!(!map_ptr.is_null());\n         // Get and keep the single reference that was created at the\n         // beginning.\n         let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);"}, {"sha": "065feaebb516981704da97835183d796cfb25ac3", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -848,14 +848,14 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let mut result = None;\n     do task().future_result(|+r| { result = Some(r); }).spawn { }\n-    assert option::unwrap(result).recv() == Success;\n+    fail_unless!(option::unwrap(result).recv() == Success);\n \n     result = None;\n     do task().future_result(|+r|\n         { result = Some(r); }).unlinked().spawn {\n         fail!();\n     }\n-    assert option::unwrap(result).recv() == Failure;\n+    fail_unless!(option::unwrap(result).recv() == Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -901,7 +901,7 @@ fn test_spawn_sched() {\n \n         do spawn_sched(SingleThreaded) {\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n-            assert parent_sched_id != child_sched_id;\n+            fail_unless!(parent_sched_id != child_sched_id);\n \n             if (i == 0) {\n                 ch.send(());\n@@ -929,24 +929,28 @@ fn test_spawn_sched_childs_on_default_sched() {\n         do spawn {\n             let ch = ch.f.swap_unwrap();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n-            assert parent_sched_id != child_sched_id;\n-            assert child_sched_id == default_id;\n+            fail_unless!(parent_sched_id != child_sched_id);\n+            fail_unless!(child_sched_id == default_id);\n             ch.send(());\n         };\n     };\n \n     po.recv();\n }\n \n-#[nolink]\n #[cfg(test)]\n-extern mod testrt {\n-    unsafe fn rust_dbg_lock_create() -> *libc::c_void;\n-    unsafe fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-    unsafe fn rust_dbg_lock_lock(lock: *libc::c_void);\n-    unsafe fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-    unsafe fn rust_dbg_lock_wait(lock: *libc::c_void);\n-    unsafe fn rust_dbg_lock_signal(lock: *libc::c_void);\n+pub mod testrt {\n+    use libc;\n+\n+    #[nolink]\n+    pub extern {\n+        unsafe fn rust_dbg_lock_create() -> *libc::c_void;\n+        unsafe fn rust_dbg_lock_destroy(lock: *libc::c_void);\n+        unsafe fn rust_dbg_lock_lock(lock: *libc::c_void);\n+        unsafe fn rust_dbg_lock_unlock(lock: *libc::c_void);\n+        unsafe fn rust_dbg_lock_wait(lock: *libc::c_void);\n+        unsafe fn rust_dbg_lock_signal(lock: *libc::c_void);\n+    }\n }\n \n #[test]\n@@ -1020,7 +1024,7 @@ fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     }\n \n     let x_in_child = p.recv();\n-    assert x_in_parent == x_in_child;\n+    fail_unless!(x_in_parent == x_in_child);\n }\n \n #[test]\n@@ -1175,7 +1179,7 @@ fn test_sched_thread_per_core() {\n         unsafe {\n             let cores = rt::rust_num_threads();\n             let reported_threads = rt::rust_sched_threads();\n-            assert(cores as uint == reported_threads as uint);\n+            fail_unless!((cores as uint == reported_threads as uint));\n             chan.send(());\n         }\n     }\n@@ -1190,9 +1194,9 @@ fn test_spawn_thread_on_demand() {\n     do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n             let max_threads = rt::rust_sched_threads();\n-            assert(max_threads as int == 2);\n+            fail_unless!((max_threads as int == 2));\n             let running_threads = rt::rust_sched_current_nonlazy_threads();\n-            assert(running_threads as int == 1);\n+            fail_unless!((running_threads as int == 1));\n \n             let (port2, chan2) = comm::stream();\n \n@@ -1201,7 +1205,7 @@ fn test_spawn_thread_on_demand() {\n             }\n \n             let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n-            assert(running_threads2 as int == 2);\n+            fail_unless!((running_threads2 as int == 2));\n \n             port2.recv();\n             chan.send(());"}, {"sha": "7b7ec769fa9a76b6909e2505db77fcd70f259ec5", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -102,11 +102,11 @@ fn new_taskset() -> TaskSet {\n }\n fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task);\n-    assert didnt_overwrite;\n+    fail_unless!(didnt_overwrite);\n }\n fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n-    assert was_present;\n+    fail_unless!(was_present);\n }\n pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n@@ -230,7 +230,7 @@ fn each_ancestor(list:        &mut AncestorList,\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n                 // Check monotonicity\n-                assert last_generation > nobe.generation;\n+                fail_unless!(last_generation > nobe.generation);\n                 /*##########################################################*\n                  * Step 1: Look at this ancestor group (call iterator block).\n                  *##########################################################*/\n@@ -422,7 +422,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n                 }\n             }\n             for taskset_each(&group.descendants) |child| {\n-                assert child != me;\n+                fail_unless!(child != me);\n                 rt::rust_task_kill_other(child);\n             }\n             // Only one task should ever do this.\n@@ -497,7 +497,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                         }\n                         None => 0 // the actual value doesn't really matter.\n                     };\n-                assert new_generation < uint::max_value;\n+                fail_unless!(new_generation < uint::max_value);\n                 // Build a new node in the ancestor list.\n                 AncestorList(Some(unstable::exclusive(AncestorNode {\n                     generation: new_generation,\n@@ -544,7 +544,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n                 DefaultScheduler => rt::new_task(),\n                 _ => new_task_in_sched(opts.sched)\n             };\n-            assert !new_task.is_null();\n+            fail_unless!(!new_task.is_null());\n             // Getting killed after here would leak the task.\n             let mut notify_chan = if opts.notify_chan.is_none() {\n                 None\n@@ -716,7 +716,7 @@ fn test_spawn_raw_notify_success() {\n     };\n     do spawn_raw(opts) {\n     }\n-    assert notify_po.recv() == Success;\n+    fail_unless!(notify_po.recv() == Success);\n }\n \n #[test]\n@@ -733,5 +733,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    assert notify_po.recv() == Failure;\n+    fail_unless!(notify_po.recv() == Failure);\n }"}, {"sha": "8215152ef74e9c35bbb4e9133475ae82143d9edf", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -140,31 +140,31 @@ impl<A:ToStr> ToStr for @[A] {\n mod tests {\n     #[test]\n     fn test_simple_types() {\n-        assert 1i.to_str() == ~\"1\";\n-        assert (-1i).to_str() == ~\"-1\";\n-        assert 200u.to_str() == ~\"200\";\n-        assert 2u8.to_str() == ~\"2\";\n-        assert true.to_str() == ~\"true\";\n-        assert false.to_str() == ~\"false\";\n-        assert ().to_str() == ~\"()\";\n-        assert (~\"hi\").to_str() == ~\"hi\";\n-        assert (@\"hi\").to_str() == ~\"hi\";\n+        fail_unless!(1i.to_str() == ~\"1\");\n+        fail_unless!((-1i).to_str() == ~\"-1\");\n+        fail_unless!(200u.to_str() == ~\"200\");\n+        fail_unless!(2u8.to_str() == ~\"2\");\n+        fail_unless!(true.to_str() == ~\"true\");\n+        fail_unless!(false.to_str() == ~\"false\");\n+        fail_unless!(().to_str() == ~\"()\");\n+        fail_unless!((~\"hi\").to_str() == ~\"hi\");\n+        fail_unless!((@\"hi\").to_str() == ~\"hi\");\n     }\n \n     #[test]\n     fn test_tuple_types() {\n-        assert (1, 2).to_str() == ~\"(1, 2)\";\n-        assert (~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\";\n-        assert ((), ((), 100)).to_str() == ~\"((), ((), 100))\";\n+        fail_unless!((1, 2).to_str() == ~\"(1, 2)\");\n+        fail_unless!((~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\");\n+        fail_unless!(((), ((), 100)).to_str() == ~\"((), ((), 100))\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = ~[];\n-        assert x.to_str() == ~\"[]\";\n-        assert (~[1]).to_str() == ~\"[1]\";\n-        assert (~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\";\n-        assert (~[~[], ~[1], ~[1, 1]]).to_str() ==\n-               ~\"[[], [1], [1, 1]]\";\n+        fail_unless!(x.to_str() == ~\"[]\");\n+        fail_unless!((~[1]).to_str() == ~\"[1]\");\n+        fail_unless!((~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\");\n+        fail_unless!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n+               ~\"[[], [1], [1, 1]]\");\n     }\n }"}, {"sha": "395772df57179efeff398beb802cd1f1afc183c2", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -327,7 +327,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n #[cfg(test)]\n pub fn check_integrity<T>(trie: &TrieNode<T>) {\n-    assert trie.count != 0;\n+    fail_unless!(trie.count != 0);\n \n     let mut sum = 0;\n \n@@ -342,7 +342,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n         }\n     }\n \n-    assert sum == trie.count;\n+    fail_unless!(sum == trie.count);\n }\n \n #[cfg(test)]\n@@ -356,32 +356,32 @@ mod tests {\n         let n = 300;\n \n         for uint::range_step(1, n, 2) |x| {\n-            assert trie.insert(x, x + 1);\n-            assert trie.contains_key(&x);\n+            fail_unless!(trie.insert(x, x + 1));\n+            fail_unless!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(0, n, 2) |x| {\n-            assert !trie.contains_key(&x);\n-            assert trie.insert(x, x + 1);\n+            fail_unless!(!trie.contains_key(&x));\n+            fail_unless!(trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range(0, n) |x| {\n-            assert trie.contains_key(&x);\n-            assert !trie.insert(x, x + 1);\n+            fail_unless!(trie.contains_key(&x));\n+            fail_unless!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(1, n, 2) |x| {\n-            assert trie.remove(&x);\n-            assert !trie.contains_key(&x);\n+            fail_unless!(trie.remove(&x));\n+            fail_unless!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(0, n, 2) |x| {\n-            assert trie.contains_key(&x);\n-            assert !trie.insert(x, x + 1);\n+            fail_unless!(trie.contains_key(&x));\n+            fail_unless!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n     }\n@@ -390,16 +390,16 @@ mod tests {\n     fn test_each() {\n         let mut m = TrieMap::new();\n \n-        assert m.insert(3, 6);\n-        assert m.insert(0, 0);\n-        assert m.insert(4, 8);\n-        assert m.insert(2, 4);\n-        assert m.insert(1, 2);\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.insert(1, 2));\n \n         let mut n = 0;\n         for m.each |&(k, v)| {\n-            assert k == n;\n-            assert *v == n * 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n * 2);\n             n += 1;\n         }\n     }\n@@ -415,10 +415,10 @@ mod tests {\n         let mut n = uint::max_value - 9999;\n         for m.each |&(k, v)| {\n             if n == uint::max_value - 5000 { break }\n-            assert n < uint::max_value - 5000;\n+            fail_unless!(n < uint::max_value - 5000);\n \n-            assert k == n;\n-            assert *v == n / 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n / 2);\n             n += 1;\n         }\n     }\n@@ -427,16 +427,16 @@ mod tests {\n     fn test_each_reverse() {\n         let mut m = TrieMap::new();\n \n-        assert m.insert(3, 6);\n-        assert m.insert(0, 0);\n-        assert m.insert(4, 8);\n-        assert m.insert(2, 4);\n-        assert m.insert(1, 2);\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.insert(1, 2));\n \n         let mut n = 4;\n         for m.each_reverse |&(k, v)| {\n-            assert k == n;\n-            assert *v == n * 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n * 2);\n             n -= 1;\n         }\n     }\n@@ -452,10 +452,10 @@ mod tests {\n         let mut n = uint::max_value;\n         for m.each_reverse |&(k, v)| {\n             if n == uint::max_value - 5000 { break }\n-            assert n > uint::max_value - 5000;\n+            fail_unless!(n > uint::max_value - 5000);\n \n-            assert k == n;\n-            assert *v == n / 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n / 2);\n             n -= 1;\n         }\n     }"}, {"sha": "e41ff424012b233b18d8b72e819583b02e9103c0", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -202,15 +202,15 @@ impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n #[test]\n fn test_tuple_ref() {\n     let x = (~\"foo\", ~\"bar\");\n-    assert x.first_ref() == &~\"foo\";\n-    assert x.second_ref() == &~\"bar\";\n+    fail_unless!(x.first_ref() == &~\"foo\");\n+    fail_unless!(x.second_ref() == &~\"bar\");\n }\n \n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_tuple() {\n-    assert (948, 4039.48).first() == 948;\n-    assert (34.5, ~\"foo\").second() == ~\"foo\";\n-    assert ('a', 2).swap() == (2, 'a');\n+    fail_unless!((948, 4039.48).first() == 948);\n+    fail_unless!((34.5, ~\"foo\").second() == ~\"foo\");\n+    fail_unless!(('a', 2).swap() == (2, 'a'));\n }\n "}, {"sha": "96cd732d815d5bb4c4bbd8893a1273cdb198c174", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -36,18 +36,22 @@ pub mod extfmt;\n #[cfg(notest)]\n pub mod lang;\n \n-extern mod rustrt {\n-    pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n-    pub unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n-    pub unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n-    pub unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n-\n-    pub unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n-    pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n+mod rustrt {\n+    use unstable::{raw_thread, rust_little_lock};\n+\n+    pub extern {\n+        pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n+        pub unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n+        pub unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n+        pub unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n+\n+        pub unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n+        pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n+    }\n }\n \n #[allow(non_camel_case_types)] // runtime type\n-type raw_thread = libc::c_void;\n+pub type raw_thread = libc::c_void;\n \n /**\n \n@@ -79,7 +83,7 @@ fn test_run_in_bare_thread() {\n     unsafe {\n         let i = 100;\n         do run_in_bare_thread {\n-            assert i == 100;\n+            fail_unless!(i == 100);\n         }\n     }\n }\n@@ -90,7 +94,7 @@ fn test_run_in_bare_thread_exchange() {\n         // Does the exchange heap work without the runtime?\n         let i = ~100;\n         do run_in_bare_thread {\n-            assert i == ~100;\n+            fail_unless!(i == ~100);\n         }\n     }\n }\n@@ -123,7 +127,7 @@ impl<T> Drop for ArcDestruct<T>{\n                 let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n                 let new_count =\n                     intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                assert new_count >= 0;\n+                fail_unless!(new_count >= 0);\n                 if new_count == 0 {\n                     // drop glue takes over.\n                 } else {\n@@ -163,7 +167,7 @@ pub unsafe fn get_shared_mutable_state<T:Owned>(\n {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert ptr.count > 0;\n+        fail_unless!(ptr.count > 0);\n         let r = cast::transmute(option::get_ref(&ptr.data));\n         cast::forget(ptr);\n         return r;\n@@ -174,7 +178,7 @@ pub unsafe fn get_shared_immutable_state<T:Owned>(\n         rc: &a/SharedMutableState<T>) -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert ptr.count > 0;\n+        fail_unless!(ptr.count > 0);\n         // Cast us back into the correct region\n         let r = cast::transmute_region(option::get_ref(&ptr.data));\n         cast::forget(ptr);\n@@ -187,7 +191,7 @@ pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-        assert new_count >= 2;\n+        fail_unless!(new_count >= 2);\n         cast::forget(ptr);\n     }\n     ArcDestruct((*rc).data)\n@@ -204,7 +208,7 @@ impl<T:Owned> Clone for SharedMutableState<T> {\n /****************************************************************************/\n \n #[allow(non_camel_case_types)] // runtime type\n-type rust_little_lock = *libc::c_void;\n+pub type rust_little_lock = *libc::c_void;\n \n struct LittleLock {\n     l: rust_little_lock,\n@@ -338,7 +342,7 @@ pub mod tests {\n         for futures.each |f| { f.recv() }\n \n         do total.with |total| {\n-            assert **total == num_tasks * count\n+            fail_unless!(**total == num_tasks * count)\n         };\n     }\n \n@@ -350,11 +354,11 @@ pub mod tests {\n         let x2 = x.clone();\n         do task::try || {\n             do x2.with |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do x.with |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n }"}, {"sha": "f878161eca19cfec838b76c4b3b9257c6aa177ab", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -37,8 +37,12 @@ pub fn at_exit(f: ~fn()) {\n // NB: The double pointer indirection here is because ~fn() is a fat\n // pointer and due to FFI problems I am more comfortable making the\n // interface use a normal pointer\n-extern mod rustrt {\n-    fn rust_register_exit_function(runner: *c_void, f: ~~fn());\n+mod rustrt {\n+    use libc::c_void;\n+\n+    pub extern {\n+        fn rust_register_exit_function(runner: *c_void, f: ~~fn());\n+    }\n }\n \n struct ExitFunctions {\n@@ -75,7 +79,7 @@ fn test_at_exit() {\n     let i = 10;\n     do at_exit {\n         debug!(\"at_exit1\");\n-        assert i == 10;\n+        fail_unless!(i == 10);\n     }\n }\n \n@@ -85,8 +89,8 @@ fn test_at_exit_many() {\n     for uint::range(20, 100) |j| {\n         do at_exit {\n             debug!(\"at_exit2\");\n-            assert i == 10;\n-            assert j > i;\n+            fail_unless!(i == 10);\n+            fail_unless!(j > i);\n         }\n     }\n }"}, {"sha": "a2815cebc51aa39f5a1d95c305966c62a6a9d0ae", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -20,11 +20,11 @@ use intrinsic::TyDesc;\n \n pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n     unsafe {\n-        assert td.is_not_null();\n+        fail_unless!(td.is_not_null());\n \n         let total_size = get_box_size(size, (*td).align);\n         let p = c_malloc(total_size as size_t);\n-        assert p.is_not_null();\n+        fail_unless!(p.is_not_null());\n \n         // FIXME #3475: Converting between our two different tydesc types\n         let td: *TyDesc = transmute(td);\n@@ -46,7 +46,7 @@ pub unsafe fn free(ptr: *c_void) {\n     let exchange_count = &mut *rust_get_exchange_count_ptr();\n     atomic_xsub(exchange_count, 1);\n \n-    assert ptr.is_not_null();\n+    fail_unless!(ptr.is_not_null());\n     c_free(ptr);\n }\n \n@@ -60,7 +60,7 @@ fn get_box_size(body_size: uint, body_align: uint) -> uint {\n // Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n // of two.\n fn align_to(size: uint, align: uint) -> uint {\n-    assert align != 0;\n+    fail_unless!(align != 0);\n     (size + align - 1) & !(align - 1)\n }\n "}, {"sha": "b682f88b70e534bbfa7a948ac955a3986f4e1755", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -340,11 +340,11 @@ pub mod ct {\n             parse_count(s, 0, s.len()) == Parsed::new(count, next)\n         }\n \n-        assert test(\"\", CountImplied, 0);\n-        assert test(\"*\", CountIsNextParam, 1);\n-        assert test(\"*1\", CountIsNextParam, 1);\n-        assert test(\"*1$\", CountIsParam(1), 3);\n-        assert test(\"123\", CountIs(123), 3);\n+        fail_unless!(test(\"\", CountImplied, 0));\n+        fail_unless!(test(\"*\", CountIsNextParam, 1));\n+        fail_unless!(test(\"*1\", CountIsNextParam, 1));\n+        fail_unless!(test(\"*1$\", CountIsParam(1), 3));\n+        fail_unless!(test(\"123\", CountIs(123), 3));\n     }\n \n     #[test]\n@@ -355,8 +355,8 @@ pub mod ct {\n \n         fn test(s: &str, flags: &[Flag], next: uint) {\n             let f = parse_flags(s, 0, s.len());\n-            assert pack(f.val) == pack(flags);\n-            assert f.next == next;\n+            fail_unless!(pack(f.val) == pack(flags));\n+            fail_unless!(f.next == next);\n         }\n \n         test(\"\", [], 0);\n@@ -367,7 +367,7 @@ pub mod ct {\n \n     #[test]\n     fn test_parse_fmt_string() {\n-        assert parse_fmt_string(\"foo %s bar\", die) == ~[\n+        fail_unless!(parse_fmt_string(\"foo %s bar\", die) == ~[\n             PieceString(~\"foo \"),\n             PieceConv(Conv {\n                 param: None,\n@@ -376,19 +376,19 @@ pub mod ct {\n                 precision: CountImplied,\n                 ty: TyStr,\n             }),\n-            PieceString(~\" bar\")];\n+            PieceString(~\" bar\")]);\n \n-        assert parse_fmt_string(\"%s\", die) == ~[\n+        fail_unless!(parse_fmt_string(\"%s\", die) == ~[\n             PieceConv(Conv {\n                 param: None,\n                 flags: ~[],\n                 width: CountImplied,\n                 precision: CountImplied,\n                 ty: TyStr,\n-            })];\n+            })]);\n \n-        assert parse_fmt_string(\"%%%%\", die) == ~[\n-            PieceString(~\"%\"), PieceString(~\"%\")];\n+        fail_unless!(parse_fmt_string(\"%%%%\", die) == ~[\n+            PieceString(~\"%\"), PieceString(~\"%\")]);\n     }\n \n     #[test]\n@@ -397,10 +397,10 @@ pub mod ct {\n             parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n         }\n \n-        assert test(\"\", None, 0);\n-        assert test(\"foo\", None, 0);\n-        assert test(\"123\", None, 0);\n-        assert test(\"123$\", Some(123), 4);\n+        fail_unless!(test(\"\", None, 0));\n+        fail_unless!(test(\"foo\", None, 0));\n+        fail_unless!(test(\"123\", None, 0));\n+        fail_unless!(test(\"123$\", Some(123), 4));\n     }\n \n     #[test]\n@@ -409,12 +409,12 @@ pub mod ct {\n             parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n         }\n \n-        assert test(\"\", CountImplied, 0);\n-        assert test(\".\", CountIs(0), 1);\n-        assert test(\".*\", CountIsNextParam, 2);\n-        assert test(\".*1\", CountIsNextParam, 2);\n-        assert test(\".*1$\", CountIsParam(1), 4);\n-        assert test(\".123\", CountIs(123), 4);\n+        fail_unless!(test(\"\", CountImplied, 0));\n+        fail_unless!(test(\".\", CountIs(0), 1));\n+        fail_unless!(test(\".*\", CountIsNextParam, 2));\n+        fail_unless!(test(\".*1\", CountIsNextParam, 2));\n+        fail_unless!(test(\".*1$\", CountIsParam(1), 4));\n+        fail_unless!(test(\".123\", CountIs(123), 4));\n     }\n \n     #[test]\n@@ -423,17 +423,17 @@ pub mod ct {\n             parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n         }\n \n-        assert test(\"b\", TyBool);\n-        assert test(\"c\", TyChar);\n-        assert test(\"d\", TyInt(Signed));\n-        assert test(\"f\", TyFloat);\n-        assert test(\"i\", TyInt(Signed));\n-        assert test(\"o\", TyOctal);\n-        assert test(\"s\", TyStr);\n-        assert test(\"t\", TyBits);\n-        assert test(\"x\", TyHex(CaseLower));\n-        assert test(\"X\", TyHex(CaseUpper));\n-        assert test(\"?\", TyPoly);\n+        fail_unless!(test(\"b\", TyBool));\n+        fail_unless!(test(\"c\", TyChar));\n+        fail_unless!(test(\"d\", TyInt(Signed)));\n+        fail_unless!(test(\"f\", TyFloat));\n+        fail_unless!(test(\"i\", TyInt(Signed)));\n+        fail_unless!(test(\"o\", TyOctal));\n+        fail_unless!(test(\"s\", TyStr));\n+        fail_unless!(test(\"t\", TyBits));\n+        fail_unless!(test(\"x\", TyHex(CaseLower)));\n+        fail_unless!(test(\"X\", TyHex(CaseUpper)));\n+        fail_unless!(test(\"?\", TyPoly));\n     }\n \n     #[test]\n@@ -453,16 +453,16 @@ pub mod ct {\n     #[test]\n     fn test_peek_num() {\n         let s1 = \"\";\n-        assert peek_num(s1, 0, s1.len()).is_none();\n+        fail_unless!(peek_num(s1, 0, s1.len()).is_none());\n \n         let s2 = \"foo\";\n-        assert peek_num(s2, 0, s2.len()).is_none();\n+        fail_unless!(peek_num(s2, 0, s2.len()).is_none());\n \n         let s3 = \"123\";\n-        assert peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3));\n+        fail_unless!(peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3)));\n \n         let s4 = \"123foo\";\n-        assert peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3));\n+        fail_unless!(peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3)));\n     }\n }\n "}, {"sha": "5089470e6efbe7651c3383fb921fc0ae1313981b", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -57,11 +57,11 @@ fn test_success() {\n     do (|| {\n         i = 10;\n     }).finally {\n-        assert !failing();\n-        assert i == 10;\n+        fail_unless!(!failing());\n+        fail_unless!(i == 10);\n         i = 20;\n     }\n-    assert i == 20;\n+    fail_unless!(i == 20);\n }\n \n #[test]\n@@ -73,16 +73,16 @@ fn test_fail() {\n         i = 10;\n         fail!();\n     }).finally {\n-        assert failing();\n-        assert i == 10;\n+        fail_unless!(failing());\n+        fail_unless!(i == 10);\n     }\n }\n \n #[test]\n fn test_retval() {\n     let closure: &fn() -> int = || 10;\n     let i = do closure.finally { };\n-    assert i == 10;\n+    fail_unless!(i == 10);\n }\n \n #[test]"}, {"sha": "654bf18a5b6b9ffbf232a0a5a318ccf398df523b", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -187,7 +187,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n         let prev_i = unsafe { atomic_cxchg(&mut *global_ptr, 0, state_i) };\n \n         // Sanity check that we're not trying to reinitialize after shutdown\n-        assert prev_i != POISON;\n+        fail_unless!(prev_i != POISON);\n \n         if prev_i == 0 {\n             // Successfully installed the global pointer\n@@ -201,7 +201,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n                 let prev_i = unsafe {\n                     atomic_cxchg(&mut *global_ptr, state_i, POISON)\n                 };\n-                assert prev_i == state_i;\n+                fail_unless!(prev_i == state_i);\n \n                 // Capture the global state object in the at_exit closure\n                 // so that it is destroyed at the right time\n@@ -245,7 +245,7 @@ fn test_clone_rc() {\n                     ~shared_mutable_state(10)\n                 };\n \n-                assert get_shared_immutable_state(&val) == &10;\n+                fail_unless!(get_shared_immutable_state(&val) == &10);\n             }\n         }\n     }\n@@ -273,7 +273,7 @@ fn test_modify() {\n             match v {\n                 Some(sms) => {\n                     let v = get_shared_immutable_state(sms);\n-                    assert *v == 10;\n+                    fail_unless!(*v == 10);\n                     None\n                 },\n                 _ => fail!()"}, {"sha": "db0b1cc33cd671d11753d634ec8de0276eaade58", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -26,12 +26,16 @@ pub const FROZEN_BIT: uint = 0x80000000;\n #[cfg(target_word_size = \"64\")]\n pub const FROZEN_BIT: uint = 0x8000000000000000;\n \n-pub extern mod rustrt {\n-    #[rust_stack]\n-    unsafe fn rust_upcall_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n+pub mod rustrt {\n+    use libc::{c_char, uintptr_t};\n \n-    #[rust_stack]\n-    unsafe fn rust_upcall_free(ptr: *c_char);\n+    pub extern {\n+        #[rust_stack]\n+        unsafe fn rust_upcall_malloc(td: *c_char, size: uintptr_t) -> *c_char;\n+\n+        #[rust_stack]\n+        unsafe fn rust_upcall_free(ptr: *c_char);\n+    }\n }\n \n #[lang=\"fail_\"]"}, {"sha": "7e9742fecbba461a4894b7acf764c9ceeaa0917b", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -40,7 +40,7 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let shutdown_port = Cell(shutdown_port);\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n-    assert service.try_send(RegisterWeakTask(task, shutdown_chan));\n+    fail_unless!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n     unsafe { rust_dec_kernel_live_count(); }\n     do (|| {\n         f(shutdown_port.take())\n@@ -102,7 +102,7 @@ fn run_weak_task_service(port: Port<ServiceMsg>) {\n             RegisterWeakTask(task, shutdown_chan) => {\n                 let previously_unregistered =\n                     shutdown_map.insert(task, shutdown_chan);\n-                assert previously_unregistered;\n+                fail_unless!(previously_unregistered);\n             }\n             UnregisterWeakTask(task) => {\n                 match shutdown_map.pop(&task) {"}, {"sha": "214a9dea8d18c12ebf2210484259776b32ab606f", "filename": "src/libcore/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -82,7 +82,7 @@ terminate normally, but instead directly return from a function.\n \n ~~~\n fn choose_weighted_item(v: &[Item]) -> Item {\n-    assert !v.is_empty();\n+    fail_unless!(!v.is_empty());\n     let mut so_far = 0u;\n     for v.each |item| {\n         so_far += item.weight;\n@@ -110,23 +110,23 @@ mod tests {\n     pub fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n-        //FIXME #3387 assert x.eq(id(copy x));\n+        //FIXME #3387 fail_unless!(x.eq(id(copy x)));\n         let y = copy x;\n-        assert x.eq(&id(y));\n+        fail_unless!(x.eq(&id(y)));\n     }\n     #[test]\n     pub fn test_swap() {\n         let mut x = 31337;\n         let mut y = 42;\n         swap(&mut x, &mut y);\n-        assert x == 42;\n-        assert y == 31337;\n+        fail_unless!(x == 42);\n+        fail_unless!(y == 31337);\n     }\n     #[test]\n     pub fn test_replace() {\n         let mut x = Some(NonCopyable());\n         let y = replace(&mut x, None);\n-        assert x.is_none();\n-        assert y.is_some();\n+        fail_unless!(x.is_none());\n+        fail_unless!(y.is_some());\n     }\n }"}, {"sha": "365de1ac3e2b9e3800ac06c63a286cdb3d1b44fa", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 378, "deletions": 368, "changes": 746, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -28,16 +28,22 @@ use sys;\n use uint;\n use vec;\n \n-#[abi = \"cdecl\"]\n-pub extern mod rustrt {\n-    // These names are terrible. reserve_shared applies\n-    // to ~[] and reserve_shared_actual applies to @[].\n-    unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n-                                 ++v: **raw::VecRepr,\n-                                 ++n: libc::size_t);\n-    unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n-                                        ++v: **raw::VecRepr,\n-                                        ++n: libc::size_t);\n+pub mod rustrt {\n+    use libc;\n+    use sys;\n+    use vec::raw;\n+\n+    #[abi = \"cdecl\"]\n+    pub extern {\n+        // These names are terrible. reserve_shared applies\n+        // to ~[] and reserve_shared_actual applies to @[].\n+        unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n+                                     ++v: **raw::VecRepr,\n+                                     ++n: libc::size_t);\n+        unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+                                            ++v: **raw::VecRepr,\n+                                            ++n: libc::size_t);\n+    }\n }\n \n /// Returns true if a vector contains no elements\n@@ -251,8 +257,8 @@ pub pure fn last_opt<T>(v: &r/[T]) -> Option<&r/T> {\n /// Return a slice that points into another slice.\n #[inline(always)]\n pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n+    fail_unless!((start <= end));\n+    fail_unless!((end <= len(v)));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -268,8 +274,8 @@ pub pure fn mut_slice<T>(v: &r/mut [T],\n                          start: uint,\n                          end: uint)\n                       -> &r/mut [T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n+    fail_unless!((start <= end));\n+    fail_unless!((end <= len(v)));\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -285,8 +291,8 @@ pub pure fn const_slice<T>(v: &r/[const T],\n                            start: uint,\n                            end: uint)\n                         -> &r/[const T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n+    fail_unless!((start <= end));\n+    fail_unless!((end <= len(v)));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -442,7 +448,7 @@ pub pure fn partitioned<T:Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n /// Removes the first element from a vector and return it\n pub fn shift<T>(v: &mut ~[T]) -> T {\n     unsafe {\n-        assert !v.is_empty();\n+        fail_unless!(!v.is_empty());\n \n         if v.len() == 1 { return v.pop() }\n \n@@ -459,7 +465,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // Save the last element. We're going to overwrite its position\n         let mut work_elt = v.pop();\n         // We still should have room to work where what last element was\n-        assert capacity(v) >= ln;\n+        fail_unless!(capacity(v) >= ln);\n         // Pretend like we have the original length so we can use\n         // the vector copy_memory to overwrite the hole we just made\n         raw::set_len(&mut *v, ln);\n@@ -505,7 +511,7 @@ pub fn unshift<T>(v: &mut ~[T], x: T) {\n /// elements after position i one position to the right.\n pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n     let len = v.len();\n-    assert i <= len;\n+    fail_unless!(i <= len);\n \n     v.push(x);\n     let mut j = len;\n@@ -519,7 +525,7 @@ pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n /// all elements after position i one position to the left.\n pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     let len = v.len();\n-    assert i < len;\n+    fail_unless!(i < len);\n \n     let mut j = i;\n     while j < len - 1 {\n@@ -644,7 +650,7 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n /// Shorten a vector, dropping excess elements.\n pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_mut_buf(*v) |p, oldlen| {\n-        assert(newlen <= oldlen);\n+        fail_unless!((newlen <= oldlen));\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n@@ -1142,8 +1148,8 @@ pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  */\n pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n                             f: fn(t: &T) -> bool) -> Option<uint> {\n-    assert start <= end;\n-    assert end <= len(v);\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(v));\n     let mut i = start;\n     while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n     return None;\n@@ -1175,8 +1181,8 @@ pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  */\n pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: fn(t: &T) -> bool) -> Option<uint> {\n-    assert start <= end;\n-    assert end <= len(v);\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(v));\n     let mut i = end;\n     while i > start {\n         if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n@@ -1232,7 +1238,7 @@ pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n     let mut zipped = ~[];\n     let sz = len(v);\n     let mut i = 0u;\n-    assert sz == len(u);\n+    fail_unless!(sz == len(u));\n     while i < sz {\n         unsafe { zipped.push((v[i], u[i])); i += 1u; }\n     }\n@@ -1247,7 +1253,7 @@ pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n  */\n pub pure fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     let mut i = len(v);\n-    assert i == len(u);\n+    fail_unless!(i == len(u));\n     let mut w = with_capacity(i);\n     while i > 0 {\n         unsafe { w.push((v.pop(),u.pop())); }\n@@ -1426,7 +1432,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  */\n #[inline]\n pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n-    assert len(v1) == len(v2);\n+    fail_unless!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n             return;\n@@ -1470,7 +1476,7 @@ pub pure fn each_permutation<T:Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n \n pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n-    assert 1u <= nn;\n+    fail_unless!(1u <= nn);\n     for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len {\n@@ -2189,8 +2195,8 @@ pub mod raw {\n     #[inline(always)]\n     pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[const T],\n                                  count: uint) {\n-        assert dst.len() >= count;\n-        assert src.len() >= count;\n+        fail_unless!(dst.len() >= count);\n+        fail_unless!(src.len() >= count);\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n@@ -2516,65 +2522,65 @@ mod tests {\n             let a = ~[1, 2, 3];\n             let mut ptr = raw::to_ptr(a);\n             let b = from_buf(ptr, 3u);\n-            assert (len(b) == 3u);\n-            assert (b[0] == 1);\n-            assert (b[1] == 2);\n-            assert (b[2] == 3);\n+            fail_unless!((len(b) == 3u));\n+            fail_unless!((b[0] == 1));\n+            fail_unless!((b[1] == 2));\n+            fail_unless!((b[2] == 3));\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n             ptr = raw::to_ptr(c);\n             let d = from_buf(ptr, 5u);\n-            assert (len(d) == 5u);\n-            assert (d[0] == 1);\n-            assert (d[1] == 2);\n-            assert (d[2] == 3);\n-            assert (d[3] == 4);\n-            assert (d[4] == 5);\n+            fail_unless!((len(d) == 5u));\n+            fail_unless!((d[0] == 1));\n+            fail_unless!((d[1] == 2));\n+            fail_unless!((d[2] == 3));\n+            fail_unless!((d[3] == 4));\n+            fail_unless!((d[4] == 5));\n         }\n     }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n         let mut v = from_fn(3u, square);\n-        assert (len(v) == 3u);\n-        assert (v[0] == 0u);\n-        assert (v[1] == 1u);\n-        assert (v[2] == 4u);\n+        fail_unless!((len(v) == 3u));\n+        fail_unless!((v[0] == 0u));\n+        fail_unless!((v[1] == 1u));\n+        fail_unless!((v[2] == 4u));\n \n         // Test on-heap from_fn.\n         v = from_fn(5u, square);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 0u);\n-        assert (v[1] == 1u);\n-        assert (v[2] == 4u);\n-        assert (v[3] == 9u);\n-        assert (v[4] == 16u);\n+        fail_unless!((len(v) == 5u));\n+        fail_unless!((v[0] == 0u));\n+        fail_unless!((v[1] == 1u));\n+        fail_unless!((v[2] == 4u));\n+        fail_unless!((v[3] == 9u));\n+        fail_unless!((v[4] == 16u));\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n         let mut v = from_elem(2u, 10u);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 10u);\n-        assert (v[1] == 10u);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 10u));\n+        fail_unless!((v[1] == 10u));\n \n         // Test on-heap from_elem.\n         v = from_elem(6u, 20u);\n-        assert (v[0] == 20u);\n-        assert (v[1] == 20u);\n-        assert (v[2] == 20u);\n-        assert (v[3] == 20u);\n-        assert (v[4] == 20u);\n-        assert (v[5] == 20u);\n+        fail_unless!((v[0] == 20u));\n+        fail_unless!((v[1] == 20u));\n+        fail_unless!((v[2] == 20u));\n+        fail_unless!((v[3] == 20u));\n+        fail_unless!((v[4] == 20u));\n+        fail_unless!((v[5] == 20u));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        assert (is_empty::<int>(~[]));\n-        assert (!is_empty(~[0]));\n+        fail_unless!((is_empty::<int>(~[])));\n+        fail_unless!((!is_empty(~[0])));\n     }\n \n     #[test]\n@@ -2583,18 +2589,18 @@ mod tests {\n         let v0 : &[Z] = &[];\n         let v1 : &[Z] = &[[]];\n         let v2 : &[Z] = &[[], []];\n-        assert(sys::size_of::<Z>() == 0);\n-        assert(len(v0) == 0);\n-        assert(len(v1) == 1);\n-        assert(len(v2) == 2);\n+        fail_unless!((sys::size_of::<Z>() == 0));\n+        fail_unless!((len(v0) == 0));\n+        fail_unless!((len(v1) == 1));\n+        fail_unless!((len(v2) == 2));\n     }\n \n     #[test]\n     fn test_head() {\n         let mut a = ~[11];\n-        assert a.head() == &11;\n+        fail_unless!(a.head() == &11);\n         a = ~[11, 12];\n-        assert a.head() == &11;\n+        fail_unless!(a.head() == &11);\n     }\n \n     #[test]\n@@ -2608,19 +2614,19 @@ mod tests {\n     #[test]\n     fn test_head_opt() {\n         let mut a = ~[];\n-        assert a.head_opt() == None;\n+        fail_unless!(a.head_opt() == None);\n         a = ~[11];\n-        assert a.head_opt().unwrap() == &11;\n+        fail_unless!(a.head_opt().unwrap() == &11);\n         a = ~[11, 12];\n-        assert a.head_opt().unwrap() == &11;\n+        fail_unless!(a.head_opt().unwrap() == &11);\n     }\n \n     #[test]\n     fn test_tail() {\n         let mut a = ~[11];\n-        assert a.tail() == &[];\n+        fail_unless!(a.tail() == &[]);\n         a = ~[11, 12];\n-        assert a.tail() == &[12];\n+        fail_unless!(a.tail() == &[12]);\n     }\n \n     #[test]\n@@ -2634,9 +2640,9 @@ mod tests {\n     #[test]\n     fn test_tailn() {\n         let mut a = ~[11, 12, 13];\n-        assert a.tailn(0) == &[11, 12, 13];\n+        fail_unless!(a.tailn(0) == &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        assert a.tailn(2) == &[13];\n+        fail_unless!(a.tailn(2) == &[13]);\n     }\n \n     #[test]\n@@ -2650,9 +2656,9 @@ mod tests {\n     #[test]\n     fn test_init() {\n         let mut a = ~[11];\n-        assert a.init() == &[];\n+        fail_unless!(a.init() == &[]);\n         a = ~[11, 12];\n-        assert a.init() == &[11];\n+        fail_unless!(a.init() == &[11]);\n     }\n \n     #[init]\n@@ -2666,9 +2672,9 @@ mod tests {\n     #[test]\n     fn test_initn() {\n         let mut a = ~[11, 12, 13];\n-        assert a.initn(0) == &[11, 12, 13];\n+        fail_unless!(a.initn(0) == &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        assert a.initn(2) == &[11];\n+        fail_unless!(a.initn(2) == &[11]);\n     }\n \n     #[init]\n@@ -2682,9 +2688,9 @@ mod tests {\n     #[test]\n     fn test_last() {\n         let mut a = ~[11];\n-        assert a.last() == &11;\n+        fail_unless!(a.last() == &11);\n         a = ~[11, 12];\n-        assert a.last() == &12;\n+        fail_unless!(a.last() == &12);\n     }\n \n     #[test]\n@@ -2697,75 +2703,75 @@ mod tests {\n     #[test]\n     fn test_last_opt() {\n         let mut a = ~[];\n-        assert a.last_opt() == None;\n+        fail_unless!(a.last_opt() == None);\n         a = ~[11];\n-        assert a.last_opt().unwrap() == &11;\n+        fail_unless!(a.last_opt().unwrap() == &11);\n         a = ~[11, 12];\n-        assert a.last_opt().unwrap() == &12;\n+        fail_unless!(a.last_opt().unwrap() == &12);\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n         let v_a = slice(vec_fixed, 1u, len(vec_fixed)).to_vec();\n-        assert (len(v_a) == 3u);\n-        assert (v_a[0] == 2);\n-        assert (v_a[1] == 3);\n-        assert (v_a[2] == 4);\n+        fail_unless!((len(v_a) == 3u));\n+        fail_unless!((v_a[0] == 2));\n+        fail_unless!((v_a[1] == 3));\n+        fail_unless!((v_a[2] == 4));\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n         let v_b = slice(vec_stack, 1u, 3u).to_vec();\n-        assert (len(v_b) == 2u);\n-        assert (v_b[0] == 2);\n-        assert (v_b[1] == 3);\n+        fail_unless!((len(v_b) == 2u));\n+        fail_unless!((v_b[0] == 2));\n+        fail_unless!((v_b[1] == 3));\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n         let v_c = slice(vec_managed, 0u, 3u).to_vec();\n-        assert (len(v_c) == 3u);\n-        assert (v_c[0] == 1);\n-        assert (v_c[1] == 2);\n-        assert (v_c[2] == 3);\n+        fail_unless!((len(v_c) == 3u));\n+        fail_unless!((v_c[0] == 1));\n+        fail_unless!((v_c[1] == 2));\n+        fail_unless!((v_c[2] == 3));\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = slice(vec_unique, 1u, 6u).to_vec();\n-        assert (len(v_d) == 5u);\n-        assert (v_d[0] == 2);\n-        assert (v_d[1] == 3);\n-        assert (v_d[2] == 4);\n-        assert (v_d[3] == 5);\n-        assert (v_d[4] == 6);\n+        fail_unless!((len(v_d) == 5u));\n+        fail_unless!((v_d[0] == 2));\n+        fail_unless!((v_d[1] == 3));\n+        fail_unless!((v_d[2] == 4));\n+        fail_unless!((v_d[3] == 5));\n+        fail_unless!((v_d[4] == 6));\n     }\n \n     #[test]\n     fn test_pop() {\n         // Test on-heap pop.\n         let mut v = ~[1, 2, 3, 4, 5];\n         let e = v.pop();\n-        assert (len(v) == 4u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n-        assert (v[3] == 4);\n-        assert (e == 5);\n+        fail_unless!((len(v) == 4u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 2));\n+        fail_unless!((v[2] == 3));\n+        fail_unless!((v[3] == 4));\n+        fail_unless!((e == 5));\n     }\n \n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        assert (len(v) == 4);\n-        assert e == 1;\n-        assert (v[0] == 5);\n+        fail_unless!((len(v) == 4));\n+        fail_unless!(e == 1);\n+        fail_unless!((v[0] == 5));\n         e = v.swap_remove(3);\n-        assert (len(v) == 3);\n-        assert e == 4;\n-        assert (v[0] == 5);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n+        fail_unless!((len(v) == 3));\n+        fail_unless!(e == 4);\n+        fail_unless!((v[0] == 5));\n+        fail_unless!((v[1] == 2));\n+        fail_unless!((v[2] == 3));\n     }\n \n     #[test]\n@@ -2774,83 +2780,83 @@ mod tests {\n         let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n                       ::unstable::exclusive(())];\n         let mut _e = v.swap_remove(0);\n-        assert (len(v) == 2);\n+        fail_unless!((len(v) == 2));\n         _e = v.swap_remove(1);\n-        assert (len(v) == 1);\n+        fail_unless!((len(v) == 1));\n         _e = v.swap_remove(0);\n-        assert (len(v) == 0);\n+        fail_unless!((len(v) == 0));\n     }\n \n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n         v.push(1);\n-        assert (len(v) == 1u);\n-        assert (v[0] == 1);\n+        fail_unless!((len(v) == 1u));\n+        fail_unless!((v[0] == 1));\n \n         // Test on-heap push().\n         v.push(2);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 2));\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n         v.grow(2u, &1);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 1);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 1));\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 1);\n-        assert (v[2] == 2);\n-        assert (v[3] == 2);\n-        assert (v[4] == 2);\n+        fail_unless!((len(v) == 5u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 1));\n+        fail_unless!((v[2] == 2));\n+        fail_unless!((v[3] == 2));\n+        fail_unless!((v[4] == 2));\n     }\n \n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n         v.grow_fn(3u, square);\n-        assert (len(v) == 3u);\n-        assert (v[0] == 0u);\n-        assert (v[1] == 1u);\n-        assert (v[2] == 4u);\n+        fail_unless!((len(v) == 3u));\n+        fail_unless!((v[0] == 0u));\n+        fail_unless!((v[1] == 1u));\n+        fail_unless!((v[2] == 4u));\n     }\n \n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n         v.grow_set(4u, &4, 5);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n-        assert (v[3] == 4);\n-        assert (v[4] == 5);\n+        fail_unless!((len(v) == 5u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 2));\n+        fail_unless!((v[2] == 3));\n+        fail_unless!((v[3] == 4));\n+        fail_unless!((v[4] == 5));\n     }\n \n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n         v.truncate(1);\n-        assert(v.len() == 1);\n-        assert(*(v[0]) == 6);\n+        fail_unless!((v.len() == 1));\n+        fail_unless!((*(v[0]) == 6));\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut v = ~[@6,@5,@4];\n         v.clear();\n-        assert(v.len() == 0);\n+        fail_unless!((v.len() == 0));\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n@@ -2859,7 +2865,7 @@ mod tests {\n         fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n             v.dedup();\n-            assert(v == b);\n+            fail_unless!((v == b));\n         }\n         case(~[], ~[]);\n         case(~[1], ~[1]);\n@@ -2904,20 +2910,20 @@ mod tests {\n         // Test on-stack map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = map(v, square_ref);\n-        assert (len(w) == 3u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 4u);\n-        assert (w[2] == 9u);\n+        fail_unless!((len(w) == 3u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 4u));\n+        fail_unless!((w[2] == 9u));\n \n         // Test on-heap map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = map(v, square_ref);\n-        assert (len(w) == 5u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 4u);\n-        assert (w[2] == 9u);\n-        assert (w[3] == 16u);\n-        assert (w[4] == 25u);\n+        fail_unless!((len(w) == 5u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 4u));\n+        fail_unless!((w[2] == 9u));\n+        fail_unless!((w[3] == 16u));\n+        fail_unless!((w[4] == 25u));\n     }\n \n     #[test]\n@@ -2928,25 +2934,25 @@ mod tests {\n         let v1 = ~[5, 4, 3, 2, 1];\n         let u = map2::<int, int, int>(v0, v1, f);\n         let mut i = 0;\n-        while i < 5 { assert (v0[i] * v1[i] == u[i]); i += 1; }\n+        while i < 5 { fail_unless!((v0[i] * v1[i] == u[i])); i += 1; }\n     }\n \n     #[test]\n     fn test_filter_mapped() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_mapped(v, square_if_odd_r);\n-        assert (len(w) == 2u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n+        fail_unless!((len(w) == 2u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_mapped(v, square_if_odd_r);\n-        assert (len(w) == 3u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n-        assert (w[2] == 25u);\n+        fail_unless!((len(w) == 3u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n+        fail_unless!((w[2] == 25u));\n \n         fn halve(i: &int) -> Option<int> {\n             if *i % 2 == 0 {\n@@ -2961,29 +2967,29 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert (filter_mapped(all_even, halve) ==\n-                map(all_even, halve_for_sure));\n-        assert (filter_mapped(all_odd1, halve) == ~[]);\n-        assert (filter_mapped(all_odd2, halve) == ~[]);\n-        assert (filter_mapped(mix, halve) == mix_dest);\n+        fail_unless!(filter_mapped(all_even, halve) ==\n+                     map(all_even, halve_for_sure));\n+        fail_unless!((filter_mapped(all_odd1, halve) == ~[]));\n+        fail_unless!((filter_mapped(all_odd2, halve) == ~[]));\n+        fail_unless!((filter_mapped(mix, halve) == mix_dest));\n     }\n \n     #[test]\n     fn test_filter_map() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_map(v, square_if_odd_v);\n-        assert (len(w) == 2u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n+        fail_unless!((len(w) == 2u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_map(v, square_if_odd_v);\n-        assert (len(w) == 3u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n-        assert (w[2] == 25u);\n+        fail_unless!((len(w) == 3u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n+        fail_unless!((w[2] == 25u));\n \n         fn halve(i: int) -> Option<int> {\n             if i % 2 == 0 {\n@@ -2999,37 +3005,37 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert (filter_map(all_even, halve) ==\n-                map(all_even0, halve_for_sure));\n-        assert (filter_map(all_odd1, halve) == ~[]);\n-        assert (filter_map(all_odd2, halve) == ~[]);\n-        assert (filter_map(mix, halve) == mix_dest);\n+        fail_unless!(filter_map(all_even, halve) ==\n+                     map(all_even0, halve_for_sure));\n+        fail_unless!((filter_map(all_odd1, halve) == ~[]));\n+        fail_unless!((filter_map(all_odd2, halve) == ~[]));\n+        fail_unless!((filter_map(mix, halve) == mix_dest));\n     }\n \n     #[test]\n     fn test_filter() {\n-        assert filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u];\n-        assert filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[];\n+        fail_unless!(filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u]);\n+        fail_unless!(filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[]);\n     }\n \n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert v == ~[1, 3, 5];\n+        fail_unless!(v == ~[1, 3, 5]);\n     }\n \n     #[test]\n     fn test_foldl() {\n         // Test on-stack fold.\n         let mut v = ~[1u, 2u, 3u];\n         let mut sum = foldl(0u, v, add);\n-        assert (sum == 6u);\n+        fail_unless!((sum == 6u));\n \n         // Test on-heap fold.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         sum = foldl(0u, v, add);\n-        assert (sum == 15u);\n+        fail_unless!((sum == 15u));\n     }\n \n     #[test]\n@@ -3039,7 +3045,7 @@ mod tests {\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldl(0, v, sub);\n-        assert sum == -10;\n+        fail_unless!(sum == -10);\n     }\n \n     #[test]\n@@ -3049,7 +3055,7 @@ mod tests {\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldr(v, 0, sub);\n-        assert sum == -2;\n+        fail_unless!(sum == -2);\n     }\n \n     #[test]\n@@ -3065,18 +3071,18 @@ mod tests {\n         for each(~[1, 2, 3]) |v| {\n             i += *v;\n         }\n-        assert i == 6;\n+        fail_unless!(i == 6);\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n         for eachi(~[1, 2, 3]) |j, v| {\n-            if i == 0 { assert *v == 1; }\n-            assert j + 1u == *v as uint;\n+            if i == 0 { fail_unless!(*v == 1); }\n+            fail_unless!(j + 1u == *v as uint);\n             i += *v;\n         }\n-        assert i == 6;\n+        fail_unless!(i == 6);\n     }\n \n     #[test]\n@@ -3090,21 +3096,21 @@ mod tests {\n     fn test_reach_nonempty() {\n         let mut i = 0;\n         for rev_each(~[1, 2, 3]) |v| {\n-            if i == 0 { assert *v == 3; }\n+            if i == 0 { fail_unless!(*v == 3); }\n             i += *v\n         }\n-        assert i == 6;\n+        fail_unless!(i == 6);\n     }\n \n     #[test]\n     fn test_reachi() {\n         let mut i = 0;\n         for rev_eachi(~[0, 1, 2]) |j, v| {\n-            if i == 0 { assert *v == 2; }\n-            assert j == *v as uint;\n+            if i == 0 { fail_unless!(*v == 2); }\n+            fail_unless!(j == *v as uint);\n             i += *v;\n         }\n-        assert i == 3;\n+        fail_unless!(i == 3);\n     }\n \n     #[test]\n@@ -3113,47 +3119,47 @@ mod tests {\n \n         results = ~[];\n         for each_permutation(~[]) |v| { results.push(from_slice(v)); }\n-        assert results == ~[~[]];\n+        fail_unless!(results == ~[~[]]);\n \n         results = ~[];\n         for each_permutation(~[7]) |v| { results.push(from_slice(v)); }\n-        assert results == ~[~[7]];\n+        fail_unless!(results == ~[~[7]]);\n \n         results = ~[];\n         for each_permutation(~[1,1]) |v| { results.push(from_slice(v)); }\n-        assert results == ~[~[1,1],~[1,1]];\n+        fail_unless!(results == ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n         for each_permutation(~[5,2,0]) |v| { results.push(from_slice(v)); }\n-        assert results ==\n-            ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n+        fail_unless!(results ==\n+            ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n \n     #[test]\n     fn test_any_and_all() {\n-        assert (any(~[1u, 2u, 3u], is_three));\n-        assert (!any(~[0u, 1u, 2u], is_three));\n-        assert (any(~[1u, 2u, 3u, 4u, 5u], is_three));\n-        assert (!any(~[1u, 2u, 4u, 5u, 6u], is_three));\n+        fail_unless!((any(~[1u, 2u, 3u], is_three)));\n+        fail_unless!((!any(~[0u, 1u, 2u], is_three)));\n+        fail_unless!((any(~[1u, 2u, 3u, 4u, 5u], is_three)));\n+        fail_unless!((!any(~[1u, 2u, 4u, 5u, 6u], is_three)));\n \n-        assert (all(~[3u, 3u, 3u], is_three));\n-        assert (!all(~[3u, 3u, 2u], is_three));\n-        assert (all(~[3u, 3u, 3u, 3u, 3u], is_three));\n-        assert (!all(~[3u, 3u, 0u, 1u, 2u], is_three));\n+        fail_unless!((all(~[3u, 3u, 3u], is_three)));\n+        fail_unless!((!all(~[3u, 3u, 2u], is_three)));\n+        fail_unless!((all(~[3u, 3u, 3u, 3u, 3u], is_three)));\n+        fail_unless!((!all(~[3u, 3u, 0u, 1u, 2u], is_three)));\n     }\n \n     #[test]\n     fn test_any2_and_all2() {\n \n-        assert (any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        assert (any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        assert (!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        assert (any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        fail_unless!((any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal)));\n+        fail_unless!((any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal)));\n+        fail_unless!((!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal)));\n+        fail_unless!((any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal)));\n \n-        assert (all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        assert (!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        assert (!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        assert (!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        fail_unless!((all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal)));\n+        fail_unless!((!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal)));\n+        fail_unless!((!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal)));\n+        fail_unless!((!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal)));\n     }\n \n     #[test]\n@@ -3163,301 +3169,305 @@ mod tests {\n \n         let z1 = zip(v1, v2);\n \n-        assert ((1, 4) == z1[0]);\n-        assert ((2, 5) == z1[1]);\n-        assert ((3, 6) == z1[2]);\n+        fail_unless!(((1, 4) == z1[0]));\n+        fail_unless!(((2, 5) == z1[1]));\n+        fail_unless!(((3, 6) == z1[2]));\n \n         let (left, right) = unzip(z1);\n \n-        assert ((1, 4) == (left[0], right[0]));\n-        assert ((2, 5) == (left[1], right[1]));\n-        assert ((3, 6) == (left[2], right[2]));\n+        fail_unless!(((1, 4) == (left[0], right[0])));\n+        fail_unless!(((2, 5) == (left[1], right[1])));\n+        fail_unless!(((3, 6) == (left[2], right[2])));\n     }\n \n     #[test]\n     fn test_position_elem() {\n-        assert position_elem(~[], &1).is_none();\n+        fail_unless!(position_elem(~[], &1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert position_elem(v1, &1) == Some(0u);\n-        assert position_elem(v1, &2) == Some(1u);\n-        assert position_elem(v1, &5) == Some(5u);\n-        assert position_elem(v1, &4).is_none();\n+        fail_unless!(position_elem(v1, &1) == Some(0u));\n+        fail_unless!(position_elem(v1, &2) == Some(1u));\n+        fail_unless!(position_elem(v1, &5) == Some(5u));\n+        fail_unless!(position_elem(v1, &4).is_none());\n     }\n \n     #[test]\n     fn test_position() {\n         fn less_than_three(i: &int) -> bool { return *i < 3; }\n         fn is_eighteen(i: &int) -> bool { return *i == 18; }\n \n-        assert position(~[], less_than_three).is_none();\n+        fail_unless!(position(~[], less_than_three).is_none());\n \n         let v1 = ~[5, 4, 3, 2, 1];\n-        assert position(v1, less_than_three) == Some(3u);\n-        assert position(v1, is_eighteen).is_none();\n+        fail_unless!(position(v1, less_than_three) == Some(3u));\n+        fail_unless!(position(v1, is_eighteen).is_none());\n     }\n \n     #[test]\n     fn test_position_between() {\n-        assert position_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(position_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert position_between(v, 0u, 0u, f).is_none();\n-        assert position_between(v, 0u, 1u, f).is_none();\n-        assert position_between(v, 0u, 2u, f) == Some(1u);\n-        assert position_between(v, 0u, 3u, f) == Some(1u);\n-        assert position_between(v, 0u, 4u, f) == Some(1u);\n+        fail_unless!(position_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(position_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(position_between(v, 0u, 2u, f) == Some(1u));\n+        fail_unless!(position_between(v, 0u, 3u, f) == Some(1u));\n+        fail_unless!(position_between(v, 0u, 4u, f) == Some(1u));\n \n-        assert position_between(v, 1u, 1u, f).is_none();\n-        assert position_between(v, 1u, 2u, f) == Some(1u);\n-        assert position_between(v, 1u, 3u, f) == Some(1u);\n-        assert position_between(v, 1u, 4u, f) == Some(1u);\n+        fail_unless!(position_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(position_between(v, 1u, 2u, f) == Some(1u));\n+        fail_unless!(position_between(v, 1u, 3u, f) == Some(1u));\n+        fail_unless!(position_between(v, 1u, 4u, f) == Some(1u));\n \n-        assert position_between(v, 2u, 2u, f).is_none();\n-        assert position_between(v, 2u, 3u, f).is_none();\n-        assert position_between(v, 2u, 4u, f) == Some(3u);\n+        fail_unless!(position_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(position_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(position_between(v, 2u, 4u, f) == Some(3u));\n \n-        assert position_between(v, 3u, 3u, f).is_none();\n-        assert position_between(v, 3u, 4u, f) == Some(3u);\n+        fail_unless!(position_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(position_between(v, 3u, 4u, f) == Some(3u));\n \n-        assert position_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(position_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_find() {\n-        assert find(~[], f).is_none();\n+        fail_unless!(find(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert find(v, f) == Some((1, 'b'));\n-        assert find(v, g).is_none();\n+        fail_unless!(find(v, f) == Some((1, 'b')));\n+        fail_unless!(find(v, g).is_none());\n     }\n \n     #[test]\n     fn test_find_between() {\n-        assert find_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(find_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert find_between(v, 0u, 0u, f).is_none();\n-        assert find_between(v, 0u, 1u, f).is_none();\n-        assert find_between(v, 0u, 2u, f) == Some((1, 'b'));\n-        assert find_between(v, 0u, 3u, f) == Some((1, 'b'));\n-        assert find_between(v, 0u, 4u, f) == Some((1, 'b'));\n+        fail_unless!(find_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(find_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(find_between(v, 0u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 0u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 0u, 4u, f) == Some((1, 'b')));\n \n-        assert find_between(v, 1u, 1u, f).is_none();\n-        assert find_between(v, 1u, 2u, f) == Some((1, 'b'));\n-        assert find_between(v, 1u, 3u, f) == Some((1, 'b'));\n-        assert find_between(v, 1u, 4u, f) == Some((1, 'b'));\n+        fail_unless!(find_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(find_between(v, 1u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 1u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 1u, 4u, f) == Some((1, 'b')));\n \n-        assert find_between(v, 2u, 2u, f).is_none();\n-        assert find_between(v, 2u, 3u, f).is_none();\n-        assert find_between(v, 2u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(find_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(find_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(find_between(v, 2u, 4u, f) == Some((3, 'b')));\n \n-        assert find_between(v, 3u, 3u, f).is_none();\n-        assert find_between(v, 3u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(find_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(find_between(v, 3u, 4u, f) == Some((3, 'b')));\n \n-        assert find_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(find_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_rposition() {\n-        assert find(~[], f).is_none();\n+        fail_unless!(find(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert position(v, f) == Some(1u);\n-        assert position(v, g).is_none();\n+        fail_unless!(position(v, f) == Some(1u));\n+        fail_unless!(position(v, g).is_none());\n     }\n \n     #[test]\n     fn test_rposition_between() {\n-        assert rposition_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(rposition_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rposition_between(v, 0u, 0u, f).is_none();\n-        assert rposition_between(v, 0u, 1u, f).is_none();\n-        assert rposition_between(v, 0u, 2u, f) == Some(1u);\n-        assert rposition_between(v, 0u, 3u, f) == Some(1u);\n-        assert rposition_between(v, 0u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(rposition_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(rposition_between(v, 0u, 2u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 0u, 3u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 0u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 1u, 1u, f).is_none();\n-        assert rposition_between(v, 1u, 2u, f) == Some(1u);\n-        assert rposition_between(v, 1u, 3u, f) == Some(1u);\n-        assert rposition_between(v, 1u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(rposition_between(v, 1u, 2u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 1u, 3u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 1u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 2u, 2u, f).is_none();\n-        assert rposition_between(v, 2u, 3u, f).is_none();\n-        assert rposition_between(v, 2u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(rposition_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(rposition_between(v, 2u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 3u, 3u, f).is_none();\n-        assert rposition_between(v, 3u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(rposition_between(v, 3u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(rposition_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_rfind() {\n-        assert rfind(~[], f).is_none();\n+        fail_unless!(rfind(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rfind(v, f) == Some((3, 'b'));\n-        assert rfind(v, g).is_none();\n+        fail_unless!(rfind(v, f) == Some((3, 'b')));\n+        fail_unless!(rfind(v, g).is_none());\n     }\n \n     #[test]\n     fn test_rfind_between() {\n-        assert rfind_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(rfind_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rfind_between(v, 0u, 0u, f).is_none();\n-        assert rfind_between(v, 0u, 1u, f).is_none();\n-        assert rfind_between(v, 0u, 2u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 0u, 3u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 0u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(rfind_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(rfind_between(v, 0u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 0u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 0u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 1u, 1u, f).is_none();\n-        assert rfind_between(v, 1u, 2u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 1u, 3u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 1u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(rfind_between(v, 1u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 1u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 1u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 2u, 2u, f).is_none();\n-        assert rfind_between(v, 2u, 3u, f).is_none();\n-        assert rfind_between(v, 2u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(rfind_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(rfind_between(v, 2u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 3u, 3u, f).is_none();\n-        assert rfind_between(v, 3u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(rfind_between(v, 3u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(rfind_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];\n-        assert (v[0] == 10);\n-        assert (v[1] == 20);\n+        fail_unless!((v[0] == 10));\n+        fail_unless!((v[1] == 20));\n         reverse(v);\n-        assert (v[0] == 20);\n-        assert (v[1] == 10);\n+        fail_unless!((v[0] == 20));\n+        fail_unless!((v[1] == 10));\n         let v2 = reversed::<int>(~[10, 20]);\n-        assert (v2[0] == 20);\n-        assert (v2[1] == 10);\n+        fail_unless!((v2[0] == 20));\n+        fail_unless!((v2[1] == 10));\n         v[0] = 30;\n-        assert (v2[0] == 20);\n+        fail_unless!((v2[0] == 20));\n         // Make sure they work with 0-length vectors too.\n \n         let v4 = reversed::<int>(~[]);\n-        assert (v4 == ~[]);\n+        fail_unless!((v4 == ~[]));\n         let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n         let mut v2 = reversed::<int>(~[10, 20]);\n-        assert (v2[0] == 20);\n-        assert (v2[1] == 10);\n+        fail_unless!((v2[0] == 20));\n+        fail_unless!((v2[1] == 10));\n     }\n \n     #[test]\n     fn test_split() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert split(~[], f) == ~[];\n-        assert split(~[1, 2], f) == ~[~[1, 2]];\n-        assert split(~[3, 1, 2], f) == ~[~[], ~[1, 2]];\n-        assert split(~[1, 2, 3], f) == ~[~[1, 2], ~[]];\n-        assert split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]];\n+        fail_unless!(split(~[], f) == ~[]);\n+        fail_unless!(split(~[1, 2], f) == ~[~[1, 2]]);\n+        fail_unless!(split(~[3, 1, 2], f) == ~[~[], ~[1, 2]]);\n+        fail_unless!(split(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_splitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert splitn(~[], 1u, f) == ~[];\n-        assert splitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n-        assert splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]];\n-        assert splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]];\n-        assert splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n-                      ~[~[1, 2], ~[4, 3, 5]];\n+        fail_unless!(splitn(~[], 1u, f) == ~[]);\n+        fail_unless!(splitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n+        fail_unless!(splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]]);\n+        fail_unless!(splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+                      ~[~[1, 2], ~[4, 3, 5]]);\n     }\n \n     #[test]\n     fn test_rsplit() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert rsplit(~[], f) == ~[];\n-        assert rsplit(~[1, 2], f) == ~[~[1, 2]];\n-        assert rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]];\n-        assert rsplit(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]];\n+        fail_unless!(rsplit(~[], f) == ~[]);\n+        fail_unless!(rsplit(~[1, 2], f) == ~[~[1, 2]]);\n+        fail_unless!(rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(rsplit(~[1, 2, 3, 4, 3, 5], f) ==\n+            ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_rsplitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert rsplitn(~[], 1u, f) == ~[];\n-        assert rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n-        assert rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]];\n-        assert rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n-                       ~[~[1, 2, 3, 4], ~[5]];\n+        fail_unless!(rsplitn(~[], 1u, f) == ~[]);\n+        fail_unless!(rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n+        fail_unless!(rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+                       ~[~[1, 2, 3, 4], ~[5]]);\n     }\n \n     #[test]\n     fn test_partition() {\n         // FIXME (#4355 maybe): using v.partition here crashes\n-        assert partition(~[], |x: &int| *x < 3) == (~[], ~[]);\n-        assert partition(~[1, 2, 3], |x: &int| *x < 4) == (~[1, 2, 3], ~[]);\n-        assert partition(~[1, 2, 3], |x: &int| *x < 2) == (~[1], ~[2, 3]);\n-        assert partition(~[1, 2, 3], |x: &int| *x < 0) == (~[], ~[1, 2, 3]);\n+        fail_unless!(partition(~[], |x: &int| *x < 3) == (~[], ~[]));\n+        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 4) ==\n+            (~[1, 2, 3], ~[]));\n+        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 2) ==\n+            (~[1], ~[2, 3]));\n+        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 0) ==\n+            (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n-        assert (~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]);\n-        assert (~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n-               (~[1, 2, 3], ~[]);\n-        assert (~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n-               (~[1], ~[2, 3]);\n-        assert (~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n-               (~[], ~[1, 2, 3]);\n+        fail_unless!((~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]));\n+        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n+                     (~[1, 2, 3], ~[]));\n+        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n+                     (~[1], ~[2, 3]));\n+        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n+                     (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n-        assert concat(~[~[1], ~[2,3]]) == ~[1, 2, 3];\n+        fail_unless!(concat(~[~[1], ~[2,3]]) == ~[1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        assert connect(~[], &0) == ~[];\n-        assert connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3];\n-        assert connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3];\n+        fail_unless!(connect(~[], &0) == ~[]);\n+        fail_unless!(connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3]);\n+        fail_unless!(connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_windowed () {\n-        assert ~[~[1u,2u,3u],~[2u,3u,4u],~[3u,4u,5u],~[4u,5u,6u]]\n-            == windowed (3u, ~[1u,2u,3u,4u,5u,6u]);\n+        fail_unless!(~[~[1u,2u,3u],~[2u,3u,4u],~[3u,4u,5u],~[4u,5u,6u]]\n+                     == windowed (3u, ~[1u,2u,3u,4u,5u,6u]));\n \n-        assert ~[~[1u,2u,3u,4u],~[2u,3u,4u,5u],~[3u,4u,5u,6u]]\n-            == windowed (4u, ~[1u,2u,3u,4u,5u,6u]);\n+        fail_unless!(~[~[1u,2u,3u,4u],~[2u,3u,4u,5u],~[3u,4u,5u,6u]]\n+                     == windowed (4u, ~[1u,2u,3u,4u,5u,6u]));\n \n-        assert ~[] == windowed (7u, ~[1u,2u,3u,4u,5u,6u]);\n+        fail_unless!(~[] == windowed (7u, ~[1u,2u,3u,4u,5u,6u]));\n     }\n \n     #[test]\n@@ -3471,26 +3481,26 @@ mod tests {\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n         x.unshift(0);\n-        assert x == ~[0, 1, 2, 3];\n+        fail_unless!(x == ~[0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut a = ~[1, 2, 4];\n         a.insert(2, 3);\n-        assert a == ~[1, 2, 3, 4];\n+        fail_unless!(a == ~[1, 2, 3, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(0, 0);\n-        assert a == ~[0, 1, 2, 3];\n+        fail_unless!(a == ~[0, 1, 2, 3]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(3, 4);\n-        assert a == ~[1, 2, 3, 4];\n+        fail_unless!(a == ~[1, 2, 3, 4]);\n \n         let mut a = ~[];\n         a.insert(0, 1);\n-        assert a == ~[1];\n+        fail_unless!(a == ~[1]);\n     }\n \n     #[test]\n@@ -3505,15 +3515,15 @@ mod tests {\n     fn test_remove() {\n         let mut a = ~[1, 2, 3, 4];\n         a.remove(2);\n-        assert a == ~[1, 2, 4];\n+        fail_unless!(a == ~[1, 2, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.remove(0);\n-        assert a == ~[2, 3];\n+        fail_unless!(a == ~[2, 3]);\n \n         let mut a = ~[1];\n         a.remove(0);\n-        assert a == ~[];\n+        fail_unless!(a == ~[]);\n     }\n \n     #[test]\n@@ -3528,19 +3538,19 @@ mod tests {\n     fn test_capacity() {\n         let mut v = ~[0u64];\n         reserve(&mut v, 10u);\n-        assert capacity(&v) == 10u;\n+        fail_unless!(capacity(&v) == 10u);\n         let mut v = ~[0u32];\n         reserve(&mut v, 10u);\n-        assert capacity(&v) == 10u;\n+        fail_unless!(capacity(&v) == 10u);\n     }\n \n     #[test]\n     fn test_view() {\n         let v = ~[1, 2, 3, 4, 5];\n         let v = v.view(1u, 3u);\n-        assert(len(v) == 2u);\n-        assert(v[0] == 2);\n-        assert(v[1] == 3);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 2));\n+        fail_unless!((v[1] == 3));\n     }\n \n "}, {"sha": "81048a69ca91d848fa6130e0b4b4fff53a24a0fe", "filename": "src/libfuzzer/ast_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -29,13 +29,13 @@ pure fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n pure fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n \n fn main() {\n-    assert (builtin_equal(5, 5));\n-    assert (!builtin_equal(5, 4));\n-    assert (!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _)));\n-    assert (!vec_equal(~[5, 5], ~[5], builtin_equal_int));\n-    assert (!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int));\n-    assert (!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int));\n-    assert (vec_equal(~[5, 5], ~[5, 5], builtin_equal_int));\n+    fail_unless!((builtin_equal(5, 5)));\n+    fail_unless!((!builtin_equal(5, 4)));\n+    fail_unless!((!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _))));\n+    fail_unless!((!vec_equal(~[5, 5], ~[5], builtin_equal_int)));\n+    fail_unless!((!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int)));\n+    fail_unless!((!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int)));\n+    fail_unless!((vec_equal(~[5, 5], ~[5, 5], builtin_equal_int)));\n \n     error!(\"Pass\");\n }"}, {"sha": "7ea74b369404c149190ab11834ed393d2dc3919c", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -14,12 +14,12 @@ use uint::range;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint {\n-    assert n != 0u; r.next() as uint % n\n+    fail_unless!(n != 0u); r.next() as uint % n\n }\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n-    assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n+    fail_unless!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n }\n \n // k in n chance of being true"}, {"sha": "19afbc4b2b7ff881e89235aacd8e8dd3509052de", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -109,8 +109,7 @@ pub pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           | ast::expr_match(*) | ast::expr_while(*)  => { false }\n \n           // https://github.com/mozilla/rust/issues/929\n-          ast::expr_cast(*) | ast::expr_assert(*) |\n-          ast::expr_binary(*) | ast::expr_assign(*) |\n+          ast::expr_cast(*) | ast::expr_binary(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) => { false }\n \n           ast::expr_ret(option::None) => { false }\n@@ -371,13 +370,13 @@ pub fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n \n pub fn removeIfExists(filename: &Path) {\n     // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n+    fail_unless!(!contains(filename.to_str(), ~\" \"));\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n }\n \n pub fn removeDirIfExists(filename: &Path) {\n     // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n+    fail_unless!(!contains(filename.to_str(), ~\" \"));\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n }\n "}, {"sha": "25b1669d86f75854bcbf39d35f49e1416bb5810c", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -13,12 +13,12 @@ use std::rand;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint {\n-    assert n != 0u; r.next() as uint % n\n+    fail_unless!(n != 0u); r.next() as uint % n\n }\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n-    assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n+    fail_unless!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n }\n \n // 1 in n chance of being true\n@@ -49,12 +49,12 @@ fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n-    assert vec::len(v) != 0u;\n+    fail_unless!(vec::len(v) != 0u);\n     let total = 0u;\n     for {weight: weight, item: _} in v {\n         total += weight;\n     }\n-    assert total >= 0u;\n+    fail_unless!(total >= 0u);\n     let chosen = under(r, total);\n     let so_far = 0u;\n     for {weight: weight, item: item} in v {"}, {"sha": "eaac7dd1a0b54263680df892893fb06e0c26627f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -17,7 +17,7 @@ use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data, True, False};\n use lib;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, cstore};\n+use metadata::{encoder, csearch, cstore};\n use middle::trans::common::CrateContext;\n use middle::ty;\n use util::ppaux;\n@@ -94,10 +94,12 @@ pub mod jit {\n     use core::ptr;\n     use core::str;\n \n-    #[nolink]\n-    #[abi = \"rust-intrinsic\"]\n-    pub extern mod rusti {\n-        pub fn morestack_addr() -> *();\n+    pub mod rusti {\n+        #[nolink]\n+        #[abi = \"rust-intrinsic\"]\n+        pub extern {\n+            pub fn morestack_addr() -> *();\n+        }\n     }\n \n     pub struct Closure {\n@@ -812,6 +814,14 @@ pub fn link_binary(sess: Session,\n     let ula = cstore::get_used_link_args(cstore);\n     for ula.each |arg| { cc_args.push(/*bad*/copy *arg); }\n \n+    // Add all the link args for external crates.\n+    do cstore::iter_crate_data(cstore) |crate_num, _| {\n+        let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n+        do vec::consume(link_args) |_, link_arg| {\n+            cc_args.push(link_arg);\n+        }\n+    }\n+\n     // # Extern library linking\n \n     // User-supplied library search paths (-L on the cammand line) These are"}, {"sha": "2d98a84aee9172b4323b4adf2208d277e2c7ea88", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -118,7 +118,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n                                  -> Path {\n     use core::os;\n \n-    assert not_win32(os);\n+    fail_unless!(not_win32(os));\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n@@ -134,8 +134,8 @@ pub fn get_rpath_relative_to_output(os: session::os,\n \n // Find the relative path from one file to another\n pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n-    assert abs1.is_absolute;\n-    assert abs2.is_absolute;\n+    fail_unless!(abs1.is_absolute);\n+    fail_unless!(abs2.is_absolute);\n     let abs1 = abs1.normalize();\n     let abs2 = abs2.normalize();\n     debug!(\"finding relative path from %s to %s\",\n@@ -144,8 +144,8 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let split2 = /*bad*/copy abs2.components;\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n-    assert len1 > 0;\n-    assert len2 > 0;\n+    fail_unless!(len1 > 0);\n+    fail_unless!(len2 > 0);\n \n     let max_common_path = uint::min(len1, len2) - 1;\n     let mut start_idx = 0;\n@@ -215,7 +215,7 @@ mod test {\n     pub fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n-        assert flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"];\n+        fail_unless!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n@@ -226,21 +226,21 @@ mod test {\n         debug!(\"test_prefix_path: %s vs. %s\",\n                res.to_str(),\n                d.to_str());\n-        assert str::ends_with(res.to_str(), d.to_str());\n+        fail_unless!(str::ends_with(res.to_str(), d.to_str()));\n     }\n \n     #[test]\n     pub fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        assert res.is_absolute;\n+        fail_unless!(res.is_absolute);\n     }\n \n     #[test]\n     pub fn test_minimize1() {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n-        assert res == ~[Path(\"rpath1\"), Path(\"rpath2\")];\n+        fail_unless!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n     }\n \n     #[test]\n@@ -249,63 +249,63 @@ mod test {\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n                                     Path(\"3\")]);\n-        assert res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")];\n+        fail_unless!(res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n \n     #[test]\n     pub fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib\");\n+        fail_unless!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib\");\n+        fail_unless!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../../lib/whatever\");\n+        fail_unless!(res == Path(\"../../lib/whatever\"));\n     }\n \n     #[test]\n     pub fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib/whatever\");\n+        fail_unless!(res == Path(\"../lib/whatever\"));\n     }\n \n     #[test]\n     pub fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib\");\n+        fail_unless!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"2\");\n+        fail_unless!(res == Path(\"2\"));\n     }\n \n     #[test]\n     pub fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"..\");\n+        fail_unless!(res == Path(\"..\"));\n     }\n \n     #[test]\n@@ -318,7 +318,7 @@ mod test {\n         debug!(\"test_relative_tu8: %s vs. %s\",\n                res.to_str(),\n                Path(\".\").to_str());\n-        assert res == Path(\".\");\n+        fail_unless!(res == Path(\".\"));\n     }\n \n     #[test]\n@@ -328,7 +328,7 @@ mod test {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-      assert res.to_str() == ~\"$ORIGIN/../lib\";\n+      fail_unless!(res.to_str() == ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -337,7 +337,7 @@ mod test {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-        assert res.to_str() == ~\"$ORIGIN/../lib\";\n+        fail_unless!(res.to_str() == ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -348,7 +348,7 @@ mod test {\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),\n                                                &Path(\"lib/libstd.so\"));\n-        assert res.to_str() == ~\"@executable_path/../lib\";\n+        fail_unless!(res.to_str() == ~\"@executable_path/../lib\");\n     }\n \n     #[test]\n@@ -358,6 +358,6 @@ mod test {\n                res.to_str(),\n                os::make_absolute(&Path(\"lib\")).to_str());\n \n-        assert res == os::make_absolute(&Path(\"lib\"));\n+        fail_unless!(res == os::make_absolute(&Path(\"lib\")));\n     }\n }"}, {"sha": "e7e29ec6c72d5b35c8fb18a5c49390b2860ae469", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -902,7 +902,7 @@ pub mod test {\n             ~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n-        assert (attr::contains_name(cfg, ~\"test\"));\n+        fail_unless!((attr::contains_name(cfg, ~\"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -922,7 +922,7 @@ pub mod test {\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n-        assert (vec::len(test_items) == 1u);\n+        fail_unless!((vec::len(test_items) == 1u));\n     }\n }\n "}, {"sha": "52426401d7927b1eec627a47173722fb1c449843", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -378,43 +378,43 @@ pub mod test {\n     #[test]\n     pub fn bin_crate_type_attr_results_in_bin_output() {\n         let crate = make_crate(true, false);\n-        assert !building_library(unknown_crate, crate, false);\n+        fail_unless!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn lib_crate_type_attr_results_in_lib_output() {\n         let crate = make_crate(false, true);\n-        assert building_library(unknown_crate, crate, false);\n+        fail_unless!(building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn bin_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n-        assert !building_library(bin_crate, crate, false);\n+        fail_unless!(!building_library(bin_crate, crate, false));\n     }\n \n     #[test]\n     pub fn lib_option_overrides_bin_crate_type() {\n         let crate = make_crate(true, false);\n-        assert building_library(lib_crate, crate, false);\n+        fail_unless!(building_library(lib_crate, crate, false));\n     }\n \n     #[test]\n     pub fn bin_crate_type_is_default() {\n         let crate = make_crate(false, false);\n-        assert !building_library(unknown_crate, crate, false);\n+        fail_unless!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn test_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n-        assert !building_library(unknown_crate, crate, true);\n+        fail_unless!(!building_library(unknown_crate, crate, true));\n     }\n \n     #[test]\n     pub fn test_option_does_not_override_requested_lib_type() {\n         let crate = make_crate(false, false);\n-        assert building_library(lib_crate, crate, true);\n+        fail_unless!(building_library(lib_crate, crate, true));\n     }\n }\n "}, {"sha": "e7ffc6c55cbc564058773dde86a6f48d4b2bdc08", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -22,11 +22,11 @@ pub mod intrinsic {\n         }\n     }\n \n-    pub enum TyDesc = {\n+    pub struct TyDesc {\n         size: uint,\n         align: uint\n         // Remaining fields not listed\n-    };\n+    }\n \n     pub trait TyVisitor {\n         fn visit_bot(&self) -> bool;\n@@ -122,9 +122,13 @@ pub mod intrinsic {\n         fn visit_closure_ptr(&self, ck: uint) -> bool;\n     }\n \n-    #[abi = \"rust-intrinsic\"]\n-    pub extern mod rusti {\n-        pub fn get_tydesc<T>() -> *();\n-        pub fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor);\n+    pub mod rusti {\n+        use super::{TyDesc, TyVisitor};\n+\n+        #[abi = \"rust-intrinsic\"]\n+        pub extern {\n+            pub fn get_tydesc<T>() -> *();\n+            pub fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor);\n+        }\n     }\n }"}, {"sha": "4cb018ebdd1f6deb5d83c90649d2279bafaaa3e0", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1166, "deletions": 1005, "changes": 2171, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "38b76c4ace29f3180e377268c4553298c50f0f79", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -156,6 +156,9 @@ pub const tag_item_unnamed_field: uint = 0x76;\n pub const tag_items_data_item_struct_ctor: uint = 0x77;\n pub const tag_items_data_item_visibility: uint = 0x78;\n \n+pub const tag_link_args: uint = 0x79;\n+pub const tag_link_args_arg: uint = 0x7a;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "890a58243a1cdaa0da52be60dc6f51fa8e0148f2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -95,7 +95,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n                 }\n             }));\n \n-        assert !matches.is_empty();\n+        fail_unless!(!matches.is_empty());\n \n         if matches.len() != 1u {\n             diag.handler().warn("}, {"sha": "427867845fe73f6462e506edc6ed775b820f67aa", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -237,6 +237,13 @@ pub fn get_method_visibility(cstore: @mut cstore::CStore,\n     decoder::get_method_visibility(cdata, def_id.node)\n }\n \n+pub fn get_link_args_for_crate(cstore: @mut cstore::CStore,\n+                               crate_num: ast::crate_num)\n+                            -> ~[~str] {\n+    let cdata = cstore::get_crate_data(cstore, crate_num);\n+    decoder::get_link_args_for_crate(cdata)\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "2f82d99420c1a992e4753cb5d1bb39e707623e8d", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -106,7 +106,7 @@ pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n }\n \n pub fn add_used_library(cstore: @mut CStore, lib: @~str) -> bool {\n-    assert *lib != ~\"\";\n+    fail_unless!(*lib != ~\"\");\n \n     if cstore.used_libraries.contains(&*lib) { return false; }\n     cstore.used_libraries.push(/*bad*/ copy *lib);"}, {"sha": "6a2ba78bfe920f44e7e401c027a052f249ccf39c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1000,7 +1000,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            assert (vec::len(meta_items) == 1u);\n+            fail_unless!((vec::len(meta_items) == 1u));\n             let meta_item = meta_items[0];\n             attrs.push(\n                 codemap::spanned {\n@@ -1131,6 +1131,15 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n     }\n }\n \n+pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n+    let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n+    let mut result = ~[];\n+    for reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n+        result.push(reader::doc_as_str(arg_doc));\n+    }\n+    result\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "1b106cc121846262893107a18eeb3889cfabb643", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -74,6 +74,7 @@ struct Stats {\n     attr_bytes: uint,\n     dep_bytes: uint,\n     lang_item_bytes: uint,\n+    link_args_bytes: uint,\n     item_bytes: uint,\n     index_bytes: uint,\n     zero_bytes: uint,\n@@ -1064,7 +1065,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for vec::each(**bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n-            assert elt.pos < 0xffff_ffff;\n+            fail_unless!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n             write_fn(writer, elt.val);\n             ebml_w.end_tag();\n@@ -1074,7 +1075,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n     for bucket_locs.each |pos| {\n-        assert *pos < 0xffff_ffff;\n+        fail_unless!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n     ebml_w.end_tag();\n@@ -1084,7 +1085,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n fn write_str(writer: io::Writer, &&s: ~str) { writer.write_str(s); }\n \n fn write_int(writer: io::Writer, &&n: int) {\n-    assert n < 0x7fff_ffff;\n+    fail_unless!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n@@ -1145,8 +1146,8 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     fn synthesize_link_attr(ecx: @EncodeContext, +items: ~[@meta_item]) ->\n        attribute {\n \n-        assert !ecx.link_meta.name.is_empty();\n-        assert !ecx.link_meta.vers.is_empty();\n+        fail_unless!(!ecx.link_meta.name.is_empty());\n+        fail_unless!(!ecx.link_meta.vers.is_empty());\n \n         let name_item =\n             attr::mk_name_value_item_str(@~\"name\",\n@@ -1212,7 +1213,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n         for deps.each |n| {\n-            assert (n.cnum == expected_cnum);\n+            fail_unless!((n.cnum == expected_cnum));\n             expected_cnum += 1;\n         }\n \n@@ -1255,6 +1256,20 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n+fn encode_link_args(ecx: @EncodeContext,\n+                    ebml_w: writer::Encoder) {\n+    ebml_w.start_tag(tag_link_args);\n+\n+    let link_args = cstore::get_used_link_args(ecx.cstore);\n+    for link_args.each |link_arg| {\n+        ebml_w.start_tag(tag_link_args_arg);\n+        ebml_w.writer.write_str(link_arg.to_str());\n+        ebml_w.end_tag();\n+    }\n+\n+    ebml_w.end_tag();\n+}\n+\n fn encode_crate_dep(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n@@ -1291,6 +1306,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         attr_bytes: 0,\n         dep_bytes: 0,\n         lang_item_bytes: 0,\n+        link_args_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n         zero_bytes: 0,\n@@ -1329,6 +1345,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     encode_lang_items(ecx, ebml_w);\n     ecx.stats.lang_item_bytes = wr.pos - i;\n \n+    // Encode the link args.\n+    i = wr.pos;\n+    encode_link_args(ecx, ebml_w);\n+    ecx.stats.link_args_bytes = wr.pos - i;\n+\n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = wr.pos;\n@@ -1359,6 +1380,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         io::println(fmt!(\" attribute bytes: %u\", ecx.stats.attr_bytes));\n         io::println(fmt!(\"       dep bytes: %u\", ecx.stats.dep_bytes));\n         io::println(fmt!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes));\n+        io::println(fmt!(\" link args bytes: %u\", ecx.stats.link_args_bytes));\n         io::println(fmt!(\"      item bytes: %u\", ecx.stats.item_bytes));\n         io::println(fmt!(\"     index bytes: %u\", ecx.stats.index_bytes));\n         io::println(fmt!(\"      zero bytes: %u\", ecx.stats.zero_bytes));"}, {"sha": "08b9facf4861368c03c1cb262496aad5572f1c65", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -140,12 +140,12 @@ fn parse_sigil(st: @mut PState) -> ast::Sigil {\n }\n \n fn parse_vstore(st: @mut PState) -> ty::vstore {\n-    assert next(st) == '/';\n+    fail_unless!(next(st) == '/');\n \n     let c = peek(st);\n     if '0' <= c && c <= '9' {\n         let n = parse_int(st) as uint;\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         return ty::vstore_fixed(n);\n     }\n \n@@ -162,7 +162,7 @@ fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n \n     let self_ty = parse_opt(st, || parse_ty(st, conv) );\n \n-    assert next(st) == '[';\n+    fail_unless!(next(st) == '[');\n     let mut params: ~[ty::t] = ~[];\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n@@ -179,13 +179,13 @@ fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n       's' => ty::br_self,\n       'a' => {\n         let id = parse_int(st) as uint;\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         ty::br_anon(id)\n       }\n       '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n       'c' => {\n         let id = parse_int(st);\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n       _ => fail!(~\"parse_bound_region: bad input\")\n@@ -198,16 +198,16 @@ fn parse_region(st: @mut PState) -> ty::Region {\n         ty::re_bound(parse_bound_region(st))\n       }\n       'f' => {\n-        assert next(st) == '[';\n+        fail_unless!(next(st) == '[');\n         let id = parse_int(st);\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         let br = parse_bound_region(st);\n-        assert next(st) == ']';\n+        fail_unless!(next(st) == ']');\n         ty::re_free(id, br)\n       }\n       's' => {\n         let id = parse_int(st);\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         ty::re_scope(id)\n       }\n       't' => {\n@@ -259,18 +259,18 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'c' => return ty::mk_char(st.tcx),\n       't' => {\n-        assert (next(st) == '[');\n+        fail_unless!((next(st) == '['));\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n-        assert next(st) == ']';\n+        fail_unless!(next(st) == ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n-        assert next(st) == '[';\n+        fail_unless!(next(st) == '[');\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n         let vstore = parse_vstore(st);\n-        assert next(st) == ']';\n+        fail_unless!(next(st) == ']');\n         return ty::mk_trait(st.tcx, def, substs, vstore);\n       }\n       'p' => {\n@@ -299,18 +299,8 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         let v = parse_vstore(st);\n         return ty::mk_estr(st.tcx, v);\n       }\n-      'R' => {\n-        assert (next(st) == '[');\n-        let mut fields: ~[ty::field] = ~[];\n-        while peek(st) != ']' {\n-            let name = st.tcx.sess.ident_of(parse_str(st, '='));\n-            fields.push(ty::field { ident: name, mt: parse_mt(st, conv) });\n-        }\n-        st.pos = st.pos + 1u;\n-        return ty::mk_rec(st.tcx, fields);\n-      }\n       'T' => {\n-        assert (next(st) == '[');\n+        fail_unless!((next(st) == '['));\n         let mut params = ~[];\n         while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n@@ -329,9 +319,9 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       '#' => {\n         let pos = parse_hex(st);\n-        assert (next(st) == ':');\n+        fail_unless!((next(st) == ':'));\n         let len = parse_hex(st);\n-        assert (next(st) == '#');\n+        fail_unless!((next(st) == '#'));\n         let key = ty::creader_cache_key {cnum: st.crate,\n                                          pos: pos,\n                                          len: len };\n@@ -352,10 +342,10 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n-          assert (next(st) == '[');\n+          fail_unless!((next(st) == '['));\n           let did = parse_def(st, NominalType, conv);\n           let substs = parse_substs(st, conv);\n-          assert (next(st) == ']');\n+          fail_unless!((next(st) == ']'));\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n       c => { error!(\"unexpected char in type string: %c\", c); fail!();}\n@@ -470,7 +460,7 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n }\n \n fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n-    assert (next(st) == '[');\n+    fail_unless!((next(st) == '['));\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n         let mode = parse_mode(st);"}, {"sha": "caad6335ce512c36a0334b3cb6a901e6cd73ad03", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -283,15 +283,6 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n         enc_vstore(w, cx, v);\n       }\n       ty::ty_unboxed_vec(mt) => { w.write_char('U'); enc_mt(w, cx, mt); }\n-      ty::ty_rec(fields) => {\n-        w.write_str(&\"R[\");\n-        for fields.each |field| {\n-            w.write_str(*cx.tcx.sess.str_of(field.ident));\n-            w.write_char('=');\n-            enc_mt(w, cx, field.mt);\n-        }\n-        w.write_char(']');\n-      }\n       ty::ty_closure(ref f) => {\n         w.write_char('f');\n         enc_closure_ty(w, cx, f);"}, {"sha": "49a5be5468474903e054b4100a060998b1988215", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -176,7 +176,7 @@ pub impl ExtendedDecodeContext {\n          */\n \n         // from_id_range should be non-empty\n-        assert !ast_util::empty(self.from_id_range);\n+        fail_unless!(!ast_util::empty(self.from_id_range));\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n@@ -213,7 +213,7 @@ pub impl ExtendedDecodeContext {\n          * refer to the current crate and to the new, inlined node-id.\n          */\n \n-        assert did.crate == ast::local_crate;\n+        fail_unless!(did.crate == ast::local_crate);\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n     fn tr_span(&self, _span: span) -> span {\n@@ -1231,7 +1231,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     debug!(\"expected string: %s\", exp_str);\n     debug!(\"actual string  : %s\", out_str);\n \n-    assert exp_str == out_str;\n+    fail_unless!(exp_str == out_str);\n }\n \n #[test]\n@@ -1278,8 +1278,10 @@ fn test_simplification() {\n     ).get());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n-        assert pprust::item_to_str(item_out, ext_cx.parse_sess().interner)\n-            == pprust::item_to_str(item_exp, ext_cx.parse_sess().interner);\n+        fail_unless!(pprust::item_to_str(item_out,\n+                                         ext_cx.parse_sess().interner)\n+                     == pprust::item_to_str(item_exp,\n+                                            ext_cx.parse_sess().interner));\n       }\n       _ => fail!()\n     }"}, {"sha": "9d7a041ca099032910e052c6000a195a4b9e5293", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -162,8 +162,7 @@ pub fn check_expr(sess: Session,\n           expr_field(*) |\n           expr_index(*) |\n           expr_tup(*) |\n-          expr_struct(_, _, None) |\n-          expr_rec(_, None) => { }\n+          expr_struct(_, _, None) => { }\n           expr_addr_of(*) => {\n                 sess.span_err(\n                     e.span,"}, {"sha": "a60b0332b8fb4d485a60e9b694aea10ddedbfffa", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -132,7 +132,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n }\n \n pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n-    assert(!pats.is_empty());\n+    fail_unless!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), ~[wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n@@ -319,8 +319,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n           _ => Some(single)\n         }\n       }\n-      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) |\n-      pat_region(*) => {\n+      pat_box(_) | pat_uniq(_) | pat_tup(_) | pat_region(*) => {\n         Some(single)\n       }\n       pat_vec(elems, tail) => {\n@@ -352,7 +351,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n                  -> Option<ctor> {\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n-      ty::ty_rec(_) | ty::ty_struct(*) => {\n+      ty::ty_struct(*) => {\n         for m.each |r| {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n@@ -449,7 +448,6 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n     match /*bad*/copy ty::get(ty).sty {\n       ty::ty_tup(fs) => fs.len(),\n-      ty::ty_rec(fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match ctor { variant(id) => id,\n@@ -548,19 +546,6 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     _ => None\n                 }\n             }\n-            pat_rec(ref flds, _) => {\n-                let ty_flds = match /*bad*/copy ty::get(left_ty).sty {\n-                    ty::ty_rec(flds) => flds,\n-                    _ => fail!(~\"bad type for pat_rec\")\n-                };\n-                let args = vec::map(ty_flds, |ty_fld| {\n-                    match flds.find(|f| f.ident == ty_fld.ident) {\n-                        Some(f) => f.pat,\n-                        _ => wild()\n-                    }\n-                });\n-                Some(vec::append(args, vec::from_slice(r.tail())))\n-            }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n                 match cx.tcx.def_map.get(&pat_id) {\n@@ -722,9 +707,6 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n         false\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n-      pat_rec(fields, _) => {\n-        fields.any(|f| is_refutable(cx, f.pat))\n-      }\n       pat_struct(_, fields, _) => {\n         fields.any(|f| is_refutable(cx, f.pat))\n       }"}, {"sha": "441e01bbc344c7316b11e62fbe68a0af456877a8", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -117,8 +117,7 @@ pub fn classify(e: @expr,\n                   }\n               }\n \n-              ast::expr_struct(_, ref fs, None) |\n-              ast::expr_rec(ref fs, None) => {\n+              ast::expr_struct(_, ref fs, None) => {\n                 let cs = do vec::map((*fs)) |f| {\n                     if f.node.mutbl == ast::m_imm {\n                         classify(f.node.expr, def_map, tcx)"}, {"sha": "2bd08f109812fc64348b2db6157300999026dc6e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -73,7 +73,6 @@ pub enum lint {\n     deprecated_mode,\n     deprecated_pattern,\n     non_camel_case_types,\n-    structural_records,\n     type_limits,\n     default_methods,\n     deprecated_self,\n@@ -217,13 +216,6 @@ pub fn get_lint_dict() -> LintDict {\n             default: allow\n          }),\n \n-        (@~\"structural_records\",\n-         @LintSpec {\n-            lint: structural_records,\n-            desc: \"use of any structural records\",\n-            default: deny\n-         }),\n-\n         (@~\"legacy modes\",\n          @LintSpec {\n             lint: legacy_modes,\n@@ -486,7 +478,6 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_path_statement(cx, i);\n     check_item_non_camel_case_types(cx, i);\n     check_item_heap(cx, i);\n-    check_item_structural_records(cx, i);\n     check_item_deprecated_modes(cx, i);\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n@@ -729,24 +720,6 @@ fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n-fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n-    let visit = item_stopping_visitor(\n-        visit::mk_simple_visitor(@visit::SimpleVisitor {\n-            visit_expr: |e: @ast::expr| {\n-                match e.node {\n-                    ast::expr_rec(*) =>\n-                        cx.sess.span_lint(\n-                            structural_records, e.id, it.id,\n-                            e.span,\n-                            ~\"structural records are deprecated\"),\n-                    _ => ()\n-                }\n-            },\n-            .. *visit::default_simple_visitor()\n-        }));\n-    visit::visit_item(it, (), visit);\n-}\n-\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n@@ -899,7 +872,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n-        assert !ident.is_empty();\n+        fail_unless!(!ident.is_empty());\n         let ident = ident_without_trailing_underscores(*ident);\n         let ident = ident_without_leading_underscores(ident);\n         char::is_uppercase(str::char_at(ident, 0)) &&"}, {"sha": "5d652571ab1b6629da49e889a42c2d81dc888f31", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -615,16 +615,13 @@ fn visit_expr(expr: @expr, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n       }\n \n       // otherwise, live nodes are not required:\n-      expr_index(*) | expr_field(*) | expr_vstore(*) |\n-      expr_vec(*) | expr_rec(*) | expr_call(*) | expr_method_call(*) |\n-      expr_tup(*) | expr_log(*) | expr_binary(*) |\n-      expr_assert(*) | expr_addr_of(*) | expr_copy(*) |\n-      expr_loop_body(*) | expr_do_body(*) | expr_cast(*) |\n-      expr_unary(*) |\n-      expr_break(_) | expr_again(_) | expr_lit(_) | expr_ret(*) |\n-      expr_block(*) | expr_assign(*) |\n-      expr_swap(*) | expr_assign_op(*) | expr_mac(*) | expr_struct(*) |\n-      expr_repeat(*) | expr_paren(*) => {\n+      expr_index(*) | expr_field(*) | expr_vstore(*) | expr_vec(*) |\n+      expr_call(*) | expr_method_call(*) | expr_tup(*) | expr_log(*) |\n+      expr_binary(*) | expr_addr_of(*) | expr_copy(*) | expr_loop_body(*) |\n+      expr_do_body(*) | expr_cast(*) | expr_unary(*) | expr_break(_) |\n+      expr_again(_) | expr_lit(_) | expr_ret(*) | expr_block(*) |\n+      expr_assign(*) | expr_swap(*) | expr_assign_op(*) | expr_mac(*) |\n+      expr_struct(*) | expr_repeat(*) | expr_paren(*) => {\n           visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -780,7 +777,7 @@ pub impl Liveness {\n     fn live_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n-        assert ln.is_valid();\n+        fail_unless!(ln.is_valid());\n         let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n@@ -795,14 +792,14 @@ pub impl Liveness {\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        assert ln.is_valid();\n+        fail_unless!(ln.is_valid());\n         self.users[self.idx(ln, var)].used\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n-        assert ln.is_valid();\n+        fail_unless!(ln.is_valid());\n         let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n@@ -1287,13 +1284,6 @@ pub impl Liveness {\n             self.propagate_through_expr(element, succ)\n           }\n \n-          expr_rec(ref fields, with_expr) => {\n-            let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do (*fields).foldr(succ) |field, succ| {\n-                self.propagate_through_expr(field.node.expr, succ)\n-            }\n-          }\n-\n           expr_struct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n             do (*fields).foldr(succ) |field, succ| {\n@@ -1342,7 +1332,6 @@ pub impl Liveness {\n             self.propagate_through_exprs(~[l, r], succ)\n           }\n \n-          expr_assert(e) |\n           expr_addr_of(_, e) |\n           expr_copy(e) |\n           expr_loop_body(e) |\n@@ -1503,11 +1492,12 @@ pub impl Liveness {\n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n-            assert cond_ln == self.propagate_through_opt_expr(cond, ln);\n-            assert body_ln == self.with_loop_nodes(expr.id, succ, ln,\n+            fail_unless!(cond_ln == self.propagate_through_opt_expr(cond,\n+                                                                    ln));\n+            fail_unless!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n             || {\n                 self.propagate_through_block(body, cond_ln)\n-            });\n+            }));\n         }\n \n         cond_ln\n@@ -1618,18 +1608,14 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n       }\n \n       // no correctness conditions related to liveness\n-      expr_call(*) | expr_method_call(*) |\n-      expr_if(*) | expr_match(*) |\n-      expr_while(*) | expr_loop(*) |\n-      expr_index(*) | expr_field(*) | expr_vstore(*) |\n-      expr_vec(*) | expr_rec(*) | expr_tup(*) |\n-      expr_log(*) | expr_binary(*) |\n-      expr_assert(*) | expr_copy(*) |\n-      expr_loop_body(*) | expr_do_body(*) |\n-      expr_cast(*) | expr_unary(*) |\n-      expr_ret(*) | expr_break(*) | expr_again(*) | expr_lit(_) |\n-      expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) |\n-      expr_struct(*) | expr_repeat(*) | expr_paren(*) => {\n+      expr_call(*) | expr_method_call(*) | expr_if(*) | expr_match(*) |\n+      expr_while(*) | expr_loop(*) | expr_index(*) | expr_field(*) |\n+      expr_vstore(*) | expr_vec(*) | expr_tup(*) | expr_log(*) |\n+      expr_binary(*) | expr_copy(*) | expr_loop_body(*) | expr_do_body(*) |\n+      expr_cast(*) | expr_unary(*) | expr_ret(*) | expr_break(*) |\n+      expr_again(*) | expr_lit(_) | expr_block(*) | expr_swap(*) |\n+      expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n+      expr_paren(*) => {\n         visit::visit_expr(expr, self, vt);\n       }\n     }"}, {"sha": "00cab7961cada0b4238477eec5ab14b3ba682488", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -437,19 +437,16 @@ pub impl mem_categorization_ctxt {\n \n           ast::expr_paren(e) => self.cat_expr_unadjusted(e),\n \n-          ast::expr_addr_of(*) | ast::expr_call(*) |\n-          ast::expr_swap(*) | ast::expr_assign(*) |\n-          ast::expr_assign_op(*) | ast::expr_fn_block(*) |\n-          ast::expr_assert(*) | ast::expr_ret(*) |\n-          ast::expr_loop_body(*) | ast::expr_do_body(*) |\n-          ast::expr_unary(*) | ast::expr_method_call(*) |\n-          ast::expr_copy(*) | ast::expr_cast(*) |\n+          ast::expr_addr_of(*) | ast::expr_call(*) | ast::expr_swap(*) |\n+          ast::expr_assign(*) | ast::expr_assign_op(*) |\n+          ast::expr_fn_block(*) | ast::expr_ret(*) | ast::expr_loop_body(*) |\n+          ast::expr_do_body(*) | ast::expr_unary(*) |\n+          ast::expr_method_call(*) | ast::expr_copy(*) | ast::expr_cast(*) |\n           ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n-          ast::expr_if(*) | ast::expr_log(*) |\n-          ast::expr_binary(*) | ast::expr_while(*) |\n-          ast::expr_block(*) | ast::expr_loop(*) | ast::expr_match(*) |\n-          ast::expr_lit(*) | ast::expr_break(*) | ast::expr_mac(*) |\n-          ast::expr_again(*) | ast::expr_rec(*) | ast::expr_struct(*) |\n+          ast::expr_if(*) | ast::expr_log(*) | ast::expr_binary(*) |\n+          ast::expr_while(*) | ast::expr_block(*) | ast::expr_loop(*) |\n+          ast::expr_match(*) | ast::expr_lit(*) | ast::expr_break(*) |\n+          ast::expr_mac(*) | ast::expr_again(*) | ast::expr_struct(*) |\n           ast::expr_repeat(*) => {\n             return self.cat_rvalue(expr, expr_ty);\n           }\n@@ -943,7 +940,6 @@ pub impl mem_categorization_ctxt {\n               // nullary variant or identifier: ignore\n           }\n \n-          ast::pat_rec(ref field_pats, _) |\n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n@@ -1114,15 +1110,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n                    f_name: ast::ident,\n                    node_id: ast::node_id)\n                 -> Option<ast::mutability> {\n-    // Need to refactor so that records/class fields can be treated uniformly.\n+    // Need to refactor so that struct/enum fields can be treated uniformly.\n     match /*bad*/copy ty::get(base_ty).sty {\n-      ty::ty_rec(fields) => {\n-        for fields.each |f| {\n-            if f.ident == f_name {\n-                return Some(f.mt.mutbl);\n-            }\n-        }\n-      }\n       ty::ty_struct(did, _) => {\n         for ty::lookup_struct_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {"}, {"sha": "182697b290f76b029b67d2b911f2453230aea966", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -469,7 +469,6 @@ pub impl VisitContext {\n                 self.use_fn_args(expr.callee_id, *args, visitor);\n             }\n \n-            expr_rec(ref fields, opt_with) |\n             expr_struct(_, ref fields, opt_with) => {\n                 for fields.each |field| {\n                     self.consume_expr(field.node.expr, visitor);\n@@ -480,7 +479,6 @@ pub impl VisitContext {\n                     // then `with` is consumed, otherwise it is only read\n                     let with_ty = ty::expr_ty(self.tcx, *with_expr);\n                     let with_fields = match ty::get(with_ty).sty {\n-                        ty::ty_rec(ref f) => copy *f,\n                         ty::ty_struct(did, ref substs) => {\n                             ty::struct_fields(self.tcx, did, substs)\n                         }\n@@ -573,10 +571,6 @@ pub impl VisitContext {\n                 self.use_expr(b_expr, Read, visitor);\n             }\n \n-            expr_assert(cond_expr) => {\n-                self.consume_expr(cond_expr, visitor);\n-            }\n-\n             expr_while(cond_expr, ref blk) => {\n                 self.consume_expr(cond_expr, visitor);\n                 self.consume_block(blk, visitor);"}, {"sha": "866ec0ab515efccf791a2dc2abed3f7196dd5b7e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -36,13 +36,6 @@ use syntax::{ast, visit};\n \n pub type parent = Option<ast::node_id>;\n \n-/* Records the parameter ID of a region name. */\n-pub type binding = {\n-    node_id: ast::node_id,\n-    name: ~str,\n-    br: ty::bound_region\n-};\n-\n /**\n Encodes the bounding lifetime for a given AST node:\n \n@@ -470,7 +463,7 @@ pub impl DetermineRpCtxt {\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n     fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n-        assert id != 0;\n+        fail_unless!(id != 0);\n         let old_variance = self.region_paramd_items.find(&id);\n         let joined_variance = match old_variance {\n           None => variance,\n@@ -736,12 +729,6 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, cx, visitor);\n       }\n \n-      ast::ty_rec(ref fields) => {\n-        for (*fields).each |field| {\n-            visit_mt(field.node.mt, cx, visitor);\n-        }\n-      }\n-\n       ast::ty_path(path, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {"}, {"sha": "1ca3c045f57ecc182a13837a5dfa7829ad2697e7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -47,7 +47,7 @@ use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n use syntax::ast::{local, local_crate, lt, method, mode, module_ns, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n-use syntax::ast::{path, pat_box, pat_lit, pat_range, pat_rec, pat_struct};\n+use syntax::ast::{path, pat_box, pat_lit, pat_range, pat_struct};\n use syntax::ast::{pat_tup, pat_uniq, pat_wild, prim_ty, private, provided};\n use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n use syntax::ast::{struct_dtor, struct_field, struct_variant_kind, sty_by_ref};\n@@ -1411,7 +1411,7 @@ pub impl Resolver {\n                     match view_path.node {\n                         view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n-                            assert path_len != 0;\n+                            fail_unless!(path_len != 0);\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1 {\n@@ -2107,7 +2107,7 @@ pub impl Resolver {\n         // Decrement the count of unresolved imports.\n         match resolution_result {\n             Success(()) => {\n-                assert self.unresolved_imports >= 1;\n+                fail_unless!(self.unresolved_imports >= 1);\n                 self.unresolved_imports -= 1;\n             }\n             _ => {\n@@ -2123,7 +2123,7 @@ pub impl Resolver {\n         if !resolution_result.indeterminate() {\n             match *import_directive.subclass {\n                 GlobImport => {\n-                    assert module_.glob_count >= 1;\n+                    fail_unless!(module_.glob_count >= 1);\n                     module_.glob_count -= 1;\n                 }\n                 SingleImport(*) => {\n@@ -2258,7 +2258,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key(&target);\n+        fail_unless!(module_.import_resolutions.contains_key(&target));\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match value_result {\n@@ -2320,7 +2320,7 @@ pub impl Resolver {\n             }\n         }\n \n-        assert import_resolution.outstanding_references >= 1;\n+        fail_unless!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -2417,7 +2417,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key(&target);\n+        fail_unless!(module_.import_resolutions.contains_key(&target));\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match module_result {\n@@ -2442,7 +2442,7 @@ pub impl Resolver {\n           return Failed;\n         }\n \n-        assert import_resolution.outstanding_references >= 1;\n+        fail_unless!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single module import) successfully resolved \\\n@@ -2476,7 +2476,7 @@ pub impl Resolver {\n             return Indeterminate;\n         }\n \n-        assert containing_module.glob_count == 0;\n+        fail_unless!(containing_module.glob_count == 0);\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n@@ -2664,7 +2664,7 @@ pub impl Resolver {\n                                       span: span)\n                                    -> ResolveResult<@mut Module> {\n         let module_path_len = module_path.len();\n-        assert module_path_len > 0;\n+        fail_unless!(module_path_len > 0);\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n@@ -3016,7 +3016,7 @@ pub impl Resolver {\n         // If this is a search of all imports, we should be done with glob\n         // resolution at this point.\n         if name_search_type == SearchItemsAndAllImports {\n-            assert module_.glob_count == 0;\n+            fail_unless!(module_.glob_count == 0);\n         }\n \n         // Check the list of resolved imports."}, {"sha": "072a52a96b80921e5adc0eedce49f4c29a652075", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -459,8 +459,7 @@ pub fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) |\n-          ast::pat_struct(*) => Some(~[]),\n+          ast::pat_wild | ast::pat_tup(_) | ast::pat_struct(*) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n@@ -611,7 +610,7 @@ pub fn enter_rec_or_struct(bcx: block,\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n-            ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n+            ast::pat_struct(_, fpats, _) => {\n                 let mut pats = ~[];\n                 for vec::each(fields) |fname| {\n                     match fpats.find(|p| p.ident == *fname) {\n@@ -887,7 +886,6 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         match /*bad*/copy br.pats[col].node {\n-          ast::pat_rec(fs, _) => extend(&mut fields, fs),\n           ast::pat_struct(_, fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n               ty::ty_struct(*) => extend(&mut fields, fs),\n@@ -1221,7 +1219,7 @@ pub fn compile_submatch(bcx: block,\n     /*\n       For an empty match, a fall-through case must exist\n      */\n-    assert(m.len() > 0u || chk.is_some());\n+    fail_unless!((m.len() > 0u || chk.is_some()));\n     let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n@@ -1766,7 +1764,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 }\n             }\n         }\n-        ast::pat_rec(fields, _) | ast::pat_struct(_, fields, _) => {\n+        ast::pat_struct(_, fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);"}, {"sha": "e39de62cd297c169bb26f6d457fee3c6469d4f8c", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -11,10 +11,10 @@\n /*!\n  * # Representation of Algebraic Data Types\n  *\n- * This module determines how to represent enums, structs, tuples, and\n- * (deprecated) structural records based on their monomorphized types;\n- * it is responsible both for choosing a representation and\n- * translating basic operations on values of those types.\n+ * This module determines how to represent enums, structs, and tuples\n+ * based on their monomorphized types; it is responsible both for\n+ * choosing a representation and translating basic operations on\n+ * values of those types.\n  *\n  * Note that the interface treats everything as a general case of an\n  * enum, so structs/tuples/etc. have one pseudo-variant with\n@@ -131,11 +131,6 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n         ty::ty_tup(ref elems) => {\n             Univariant(mk_struct(cx, *elems), NonStruct)\n         }\n-        ty::ty_rec(ref fields) => {\n-            // XXX: Are these in the right order?\n-            Univariant(mk_struct(cx, fields.map(|f| f.mt.ty)),\n-                       StructWithoutDtor)\n-        }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n             let dt = ty::ty_dtor(cx.tcx, def_id).is_present();\n@@ -160,7 +155,7 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n                 Unit(cases[0].discr)\n             } else if cases.len() == 1 {\n                 // Equivalent to a struct/tuple/newtype.\n-                assert cases[0].discr == 0;\n+                fail_unless!(cases[0].discr == 0);\n                 Univariant(mk_struct(cx, cases[0].tys), NonStruct)\n             } else if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n@@ -307,18 +302,18 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n         Unit(the_discr) => {\n-            assert discr == the_discr;\n+            fail_unless!(discr == the_discr);\n         }\n         CEnum(min, max) => {\n-            assert min <= discr && discr <= max;\n+            fail_unless!(min <= discr && discr <= max);\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n         Univariant(_, StructWithDtor) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n             Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n         }\n         Univariant(*) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n         }\n         General(*) => {\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n@@ -333,7 +328,7 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n         Unit(*) | CEnum(*) => 0,\n-        Univariant(ref st, _dt) => { assert discr == 0; st.fields.len() }\n+        Univariant(ref st, _) => { fail_unless!(discr == 0); st.fields.len() }\n         General(ref cases) => cases[discr as uint].fields.len()\n     }\n }\n@@ -349,7 +344,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, dt) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n             let val = match dt {\n                 NonStruct => val,\n                 StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n@@ -416,12 +411,12 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n             C_struct(~[])\n         }\n         CEnum(min, max) => {\n-            assert vals.len() == 0;\n-            assert min <= discr && discr <= max;\n+            fail_unless!(vals.len() == 0);\n+            fail_unless!(min <= discr && discr <= max);\n             C_int(ccx, discr)\n         }\n         Univariant(ref st, dt) => {\n-            assert discr == 0;\n+            fail_unless!(discr == 0);\n             let s = C_struct(build_const_struct(ccx, st, vals));\n             match dt {\n                 NonStruct => s,\n@@ -457,7 +452,7 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n  */\n fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n-    assert vals.len() == st.fields.len();\n+    fail_unless!(vals.len() == st.fields.len());\n \n     let mut offset = 0;\n     let mut cfields = ~[];\n@@ -473,7 +468,7 @@ fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n             cfields.push(padding(target_offset - offset));\n             offset = target_offset;\n         }\n-        assert !is_undef(vals[i]);\n+        fail_unless!(!is_undef(vals[i]));\n         // If that assert fails, could change it to wrap in a struct?\n         // (See `const_struct_field` for why real fields must not be undef.)\n         cfields.push(vals[i]);"}, {"sha": "7af1fcc7e779b9927bcc6a85b4507372ccd2bcea", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -306,8 +306,8 @@ pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n     unsafe {\n         debug!(\"non_gc_box_cast\");\n         add_comment(bcx, ~\"non_gc_box_cast\");\n-        assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n-                gc_box_addrspace || bcx.unreachable);\n+        fail_unless!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n+                     gc_box_addrspace || bcx.unreachable);\n         let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n         PointerCast(bcx, val, non_gc_t)\n     }\n@@ -479,7 +479,7 @@ pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n         } else { did };\n-        assert did.crate == ast::local_crate;\n+        fail_unless!(did.crate == ast::local_crate);\n         let (val, _) =\n             monomorphize::monomorphic_fn(ccx, did, substs, None, None, None);\n \n@@ -639,7 +639,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n \n     let mut cx = cx;\n     match /*bad*/copy ty::get(t).sty {\n-      ty::ty_rec(*) | ty::ty_struct(*) => {\n+      ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n@@ -1301,7 +1301,7 @@ pub fn cleanup_and_leave(bcx: block,\n         }\n         cur = match cur.parent {\n           Some(next) => next,\n-          None => { assert upto.is_none(); break; }\n+          None => { fail_unless!(upto.is_none()); break; }\n         };\n     }\n     match leave {\n@@ -1488,7 +1488,7 @@ pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let llty = type_of::type_of(ccx, t);\n     if ty::type_has_params(t) { log(error, ty_to_str(ccx.tcx, t)); }\n-    assert !ty::type_has_params(t);\n+    fail_unless!(!ty::type_has_params(t));\n     let val = alloca(bcx, llty);\n     return val;\n }\n@@ -2443,7 +2443,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             // Want parent_id and not id, because id is the dtor's type\n             let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n             // This code shouldn't be reached if the class is generic\n-            assert !ty::type_has_params(class_ty);\n+            fail_unless!(!ty::type_has_params(class_ty));\n             let lldty = unsafe {\n                 T_fn(~[\n                     T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n@@ -2463,7 +2463,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             let llfn;\n             match /*bad*/copy (*v).node.kind {\n                 ast::tuple_variant_kind(args) => {\n-                    assert args.len() != 0u;\n+                    fail_unless!(args.len() != 0u);\n                     let pth = vec::append(/*bad*/copy *pth,\n                                           ~[path_name(enm.ident),\n                                             path_name((*v).node.name)]);"}, {"sha": "45104480b4c9d79eabd1d6661345f6711ccf2392", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -814,7 +814,7 @@ pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-        assert vals.len() == bbs.len();\n+        fail_unless!(vals.len() == bbs.len());\n         let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n@@ -1008,7 +1008,7 @@ pub fn Trap(cx: block) {\n         let T: ValueRef = str::as_c_str(~\"llvm.trap\", |buf| {\n             llvm::LLVMGetNamedFunction(M, buf)\n         });\n-        assert (T as int != 0);\n+        fail_unless!((T as int != 0));\n         let Args: ~[ValueRef] = ~[];\n         unsafe {\n             count_insn(cx, \"trap\");\n@@ -1022,7 +1022,7 @@ pub fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n-        assert !cx.unreachable;\n+        fail_unless!(!cx.unreachable);\n         count_insn(cx, \"landingpad\");\n         return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                       NumClauses as c_uint, noname());"}, {"sha": "d4ff0d74a47b7046450e8ad7817d0f24ae5beeda", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -130,9 +130,9 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             }\n             ast::def_variant(tid, vid) => {\n                 // nullary variants are not callable\n-                assert ty::enum_variant_with_id(bcx.tcx(),\n-                                                tid,\n-                                                vid).args.len() > 0u;\n+                fail_unless!(ty::enum_variant_with_id(bcx.tcx(),\n+                                                      tid,\n+                                                      vid).args.len() > 0u);\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n             }\n             ast::def_struct(def_id) => {\n@@ -280,7 +280,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        assert def_id.crate == ast::local_crate;\n+        fail_unless!(def_id.crate == ast::local_crate);\n \n         let mut (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, type_params,\n@@ -704,7 +704,8 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                assert !bcx.ccx().maps.moves_map.contains_key(&arg_expr.id);\n+                fail_unless!(!\n+                    bcx.ccx().maps.moves_map.contains_key(&arg_expr.id));\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n@@ -722,8 +723,8 @@ pub fn trans_arg_expr(bcx: block,\n                     ast::by_val => {\n                         // NB: avoid running the take glue.\n \n-                        assert !bcx.ccx().maps.moves_map.contains_key(\n-                            &arg_expr.id);\n+                        fail_unless!(!bcx.ccx().maps.moves_map.contains_key(\n+                            &arg_expr.id));\n                         val = arg_datum.to_value_llval(bcx);\n                     }\n "}, {"sha": "b7a8e38dbb873e35e18889014af9dfa596223de6", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -271,7 +271,7 @@ pub fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert sigil == ast::BorrowedSigil;\n+                fail_unless!(sigil == ast::BorrowedSigil);\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }"}, {"sha": "c4b80c504dabc2245899736038e613cefaa5992e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1339,7 +1339,7 @@ pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n         }\n-        _ => { assert !ty::type_has_params(t); t }\n+        _ => { fail_unless!(!ty::type_has_params(t)); t }\n     }\n }\n "}, {"sha": "8971d9f56699e1ccd70571096a2745ab29a33b37", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -70,7 +70,7 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n pub fn const_ptrcast(cx: @CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n-        assert cx.const_globals.insert(b as int, a);\n+        fail_unless!(cx.const_globals.insert(b as int, a));\n         b\n     }\n }\n@@ -100,7 +100,7 @@ pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n             Some(v) => v,\n             None => v\n         };\n-        assert llvm::LLVMIsGlobalConstant(v) == True;\n+        fail_unless!(llvm::LLVMIsGlobalConstant(v) == True);\n         let v = llvm::LLVMGetInitializer(v);\n         v\n     }\n@@ -290,7 +290,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_estr(*) => {assert len > 0; len - 1},\n+                  ty::ty_estr(*) => {fail_unless!(len > 0); len - 1},\n                   _ => len\n               };\n               if iv >= len {\n@@ -368,12 +368,6 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               let repr = adt::represent_type(cx, ety);\n               adt::trans_const(cx, repr, 0, es.map(|e| const_expr(cx, *e)))\n           }\n-          ast::expr_rec(ref fs, None) => {\n-              let ety = ty::expr_ty(cx.tcx, e);\n-              let repr = adt::represent_type(cx, ety);\n-              adt::trans_const(cx, repr, 0,\n-                               fs.map(|f| const_expr(cx, f.node.expr)))\n-          }\n           ast::expr_struct(_, ref fs, None) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n@@ -423,14 +417,14 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_path(pth) => {\n-            assert pth.types.len() == 0;\n+            fail_unless!(pth.types.len() == 0);\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(ast::def_fn(def_id, _purity)) => {\n                     let f = if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n                     } else {\n-                        assert ast_util::is_local(def_id);\n+                        fail_unless!(ast_util::is_local(def_id));\n                         base::get_item_val(cx, def_id.node)\n                     };\n                     let ety = ty::expr_ty_adjusted(cx.tcx, e);"}, {"sha": "e60223c9effb72d1d4e3162c8a0edaa9e6150f06", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -48,7 +48,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n             bcx = expr::trans_into(bcx, e, dest);\n         }\n         None => {\n-            assert dest == expr::Ignore || bcx.unreachable;\n+            fail_unless!(dest == expr::Ignore || bcx.unreachable);\n         }\n     }\n     return bcx;\n@@ -322,25 +322,6 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     return bcx;\n }\n \n-pub fn trans_check_expr(bcx: block,\n-                        chk_expr: @ast::expr,\n-                        pred_expr: @ast::expr,\n-                        s: &str)\n-                     -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n-    let expr_str = @(fmt!(\"%s %s failed\",\n-                          s, expr_to_str(pred_expr, bcx.ccx().sess.intr())));\n-    let Result {bcx, val} = {\n-        do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n-            expr::trans_to_datum(bcx, pred_expr).to_result()\n-        }\n-    };\n-    let val = bool_to_i1(bcx, val);\n-    do with_cond(bcx, Not(bcx, val)) |bcx| {\n-        trans_fail(bcx, Some(pred_expr.span), expr_str)\n-    }\n-}\n-\n pub fn trans_fail_expr(bcx: block,\n                        sp_opt: Option<span>,\n                        fail_expr: Option<@ast::expr>)"}, {"sha": "556c15c446d2f6f4b83e57efc2e26f5c5d0d371c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -253,19 +253,19 @@ pub impl Datum {\n                       action: CopyAction, datum: Datum) -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n-        assert datum.mode.is_by_ref();\n+        fail_unless!(datum.mode.is_by_ref());\n         self.store_to(bcx, id, action, datum.val)\n     }\n \n     fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n                     -> block {\n-        assert datum.mode.is_by_ref();\n+        fail_unless!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n     fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n                     -> block {\n-        assert datum.mode.is_by_ref();\n+        fail_unless!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n@@ -378,7 +378,7 @@ pub impl Datum {\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue. */\n \n-        assert self.source == RevokeClean;\n+        fail_unless!(self.source == RevokeClean);\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);\n@@ -399,7 +399,7 @@ pub impl Datum {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n-                    assert self.mode.is_by_ref();\n+                    fail_unless!(self.mode.is_by_ref());\n                     zero_mem(bcx, self.val, self.ty);\n                 }\n             }\n@@ -679,7 +679,7 @@ pub impl Datum {\n                 }\n \n                 let repr = adt::represent_type(ccx, self.ty);\n-                assert adt::is_newtypeish(repr);\n+                fail_unless!(adt::is_newtypeish(repr));\n                 let ty = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n                 return match self.mode {\n                     ByRef => {\n@@ -705,7 +705,7 @@ pub impl Datum {\n                         // changing the type, so I am putting this\n                         // code in place here to do the right\n                         // thing if this change ever goes through.\n-                        assert ty::type_is_immediate(ty);\n+                        fail_unless!(ty::type_is_immediate(ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n@@ -719,7 +719,7 @@ pub impl Datum {\n                 }\n \n                 let repr = adt::represent_type(ccx, self.ty);\n-                assert adt::is_newtypeish(repr);\n+                fail_unless!(adt::is_newtypeish(repr));\n                 let ty = fields[0].mt.ty;\n                 return match self.mode {\n                     ByRef => {\n@@ -746,7 +746,7 @@ pub impl Datum {\n                         // except for changing the type, so I am putting this\n                         // code in place here to do the right thing if this\n                         // change ever goes through.\n-                        assert ty::type_is_immediate(ty);\n+                        fail_unless!(ty::type_is_immediate(ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 }\n@@ -806,7 +806,7 @@ pub impl Datum {\n         // either we were asked to deref a specific number of times,\n         // in which case we should have, or we asked to deref as many\n         // times as we can\n-        assert derefs == max || max == uint::max_value;\n+        fail_unless!(derefs == max || max == uint::max_value);\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n@@ -826,7 +826,7 @@ pub impl DatumBlock {\n     }\n \n     fn assert_by_ref(&self) -> DatumBlock {\n-        assert self.datum.mode.is_by_ref();\n+        fail_unless!(self.datum.mode.is_by_ref());\n         *self\n     }\n "}, {"sha": "02b68afff4a82d2c5d5eaafaeef0d1c79f79f91c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -473,33 +473,6 @@ fn add_member(cx: @mut StructCtxt,\n     cx.total_size += size * 8;\n }\n \n-fn create_record(cx: @CrateContext, t: ty::t, fields: ~[ast::ty_field],\n-                 span: span) -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n-    let scx = create_structure(file_node,\n-                               cx.sess.str_of(\n-                                   ((/*bad*/copy cx.dbg_cx).get().names)\n-                                   (~\"rec\")),\n-                               line_from_span(cx.sess.codemap,\n-                                              span) as int);\n-    for fields.each |field| {\n-        let field_t = ty::get_field(cx.tcx, t, field.node.ident).mt.ty;\n-        let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n-        let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, *cx.sess.str_of(field.node.ident),\n-                   line_from_span(cx.sess.codemap, field.span) as int,\n-                   size as int, align as int, ty_md.node);\n-    }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n-}\n-\n fn create_boxed_type(cx: @CrateContext, outer: ty::t, _inner: ty::t,\n                      span: span, boxed: @Metadata<TyDescMetadata>)\n     -> @Metadata<TyDescMetadata> {\n@@ -628,16 +601,6 @@ fn create_ty(_cx: @CrateContext, _t: ty::t, _ty: @ast::Ty)\n                                         mutbl: mt.mutbl}) }\n           ty::ty_uniq(mt) { ast::ty_uniq({ty: t_to_ty(cx, mt.ty, span),\n                                           mutbl: mt.mutbl}) }\n-          ty::ty_rec(fields) {\n-            let fs = ~[];\n-            for field in fields {\n-                fs.push({node: {ident: field.ident,\n-                               mt: {ty: t_to_ty(cx, field.mt.ty, span),\n-                                    mutbl: field.mt.mutbl}},\n-                        span: span});\n-            }\n-            ast::ty_rec(fs)\n-          }\n           ty::ty_vec(mt) { ast::ty_vec({ty: t_to_ty(cx, mt.ty, span),\n                                         mutbl: mt.mutbl}) }\n           _ {\n@@ -673,10 +636,6 @@ fn create_ty(_cx: @CrateContext, _t: ty::t, _ty: @ast::Ty)\n         return create_ty(cx, t, inferred);\n       }\n \n-      ast::ty_rec(fields) {\n-        return create_record(cx, t, fields, ty.span);\n-      }\n-\n       ast::ty_vec(mt) {\n         let inner_t = ty::sequence_element_type(cx.tcx, t);\n         let inner_ast_t = t_to_ty(cx, inner_t, mt.ty.span);"}, {"sha": "b7942fa66dbbddac267a8a1a7add0bbcbe283d03", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -286,7 +286,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", ty_to_str(tcx, closure_ty));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert datum.appropriate_mode() == ByValue;\n+        fail_unless!(datum.appropriate_mode() == ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx), llenv);\n@@ -465,7 +465,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         ast::expr_binary(op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            assert !bcx.ccx().maps.method_map.contains_key(&expr.id);\n+            fail_unless!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n@@ -510,9 +510,6 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         ast::expr_log(_, lvl, a) => {\n             return controlflow::trans_log(expr, lvl, bcx, a);\n         }\n-        ast::expr_assert(a) => {\n-            return controlflow::trans_check_expr(bcx, expr, a, ~\"Assertion\");\n-        }\n         ast::expr_while(cond, ref body) => {\n             return controlflow::trans_while(bcx, cond, body);\n         }\n@@ -599,7 +596,6 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                 controlflow::trans_block(bcx, blk, dest)\n             };\n         }\n-        ast::expr_rec(ref fields, base) |\n         ast::expr_struct(_, ref fields, base) => {\n             return trans_rec_or_struct(bcx, (*fields), base, expr.id, dest);\n         }\n@@ -1141,10 +1137,6 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          node_id_opt: Option<ast::node_id>,\n                          op: fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n-        ty::ty_rec(ref fields) => {\n-            op(0, *fields)\n-        }\n-\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_mutable_fields(tcx, did, substs))\n         }\n@@ -1323,10 +1315,10 @@ fn trans_unary_datum(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n-    assert op != ast::deref;\n+    fail_unless!(op != ast::deref);\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert !bcx.ccx().maps.method_map.contains_key(&un_expr.id);\n+    fail_unless!(!bcx.ccx().maps.method_map.contains_key(&un_expr.id));\n \n     let un_ty = expr_ty(bcx, un_expr);\n     let sub_ty = expr_ty(bcx, sub_expr);"}, {"sha": "7f860bc0c855683d864992e82b1c658c91fb2993", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -398,7 +398,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name);\n+    fail_unless!(bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n     let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n@@ -486,7 +486,7 @@ pub fn trans_struct_drop(bcx: block,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the output pointer and the environment\n         // (self)\n-        assert(params.len() == 2);\n+        fail_unless!((params.len() == 2));\n \n         // If we need to take a reference to the class (because it's using\n         // the Drop trait), do so now.\n@@ -670,7 +670,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert !*ccx.finished_tydescs;\n+    fail_unless!(!*ccx.finished_tydescs);\n \n     let llty = type_of(ccx, t);\n "}, {"sha": "434fcd4cf31ef53948374c4b4a86a06a1f05ac16", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -22,19 +22,6 @@ use util::ppaux::ty_to_str;\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n-pub type metrics = {\n-    bcx: block,\n-    sz: ValueRef,\n-    align: ValueRef\n-};\n-\n-pub type tag_metrics = {\n-    bcx: block,\n-    sz: ValueRef,\n-    align: ValueRef,\n-    payload_align: ValueRef\n-};\n-\n // Returns the number of bytes clobbered by a Store to this type.\n pub fn llsize_of_store(cx: @CrateContext, t: TypeRef) -> uint {\n     unsafe {"}, {"sha": "f970d8f26b33b8bb1ed9290f11c55ebb19138493", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -56,8 +56,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         }\n     });\n \n-    for real_substs.each() |s| { assert !ty::type_has_params(*s); }\n-    for substs.each() |s| { assert !ty::type_has_params(*s); }\n+    for real_substs.each() |s| { fail_unless!(!ty::type_has_params(*s)); }\n+    for substs.each() |s| { fail_unless!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     // XXX: Bad copy.\n     let hash_id = make_mono_id(ccx, fn_id, copy substs, vtables, impl_did_opt,"}, {"sha": "85c0bc80292b6c44357a5a213082e55b9a922c32", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -200,20 +200,6 @@ pub impl Reflector {\n               self.visit(~\"rptr\", extra)\n           }\n \n-          ty::ty_rec(fields) => {\n-              let extra = ~[self.c_uint(vec::len(fields))]\n-                  + self.c_size_and_align(t);\n-              do self.bracketed(~\"rec\", extra) |this| {\n-                for fields.eachi |i, field| {\n-                    let extra = ~[this.c_uint(i),\n-                                  this.c_slice(\n-                                      bcx.ccx().sess.str_of(field.ident))]\n-                        + this.c_mt(field.mt);\n-                    this.visit(~\"rec_field\", extra);\n-                }\n-            }\n-          }\n-\n           ty::ty_tup(tys) => {\n               let extra = ~[self.c_uint(vec::len(tys))]\n                   + self.c_size_and_align(t);\n@@ -350,7 +336,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                  -> block {\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc);\n+    fail_unless!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n     let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {"}, {"sha": "68eb0852445e08be83132babdbebeef253960881", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -70,7 +70,7 @@ pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n }\n \n pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n-    assert !ty::type_needs_infer(t);\n+    fail_unless!(!ty::type_needs_infer(t));\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n     if t != t_norm {\n@@ -142,8 +142,7 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_unboxed_vec(mt) => T_vec(cx, sizing_type_of(cx, mt.ty)),\n \n-        ty::ty_tup(*) | ty::ty_rec(*) | ty::ty_struct(*)\n-        | ty::ty_enum(*) => {\n+        ty::ty_tup(*) | ty::ty_struct(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n             T_struct(adt::sizing_fields_of(cx, repr))\n         }\n@@ -240,7 +239,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n-      ty::ty_tup(*) | ty::ty_rec(*) => {\n+      ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n           T_struct(adt::fields_of(cx, repr))\n       }"}, {"sha": "710bb5eb346011ae99c329fa78575f56d2336be8", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -263,12 +263,9 @@ pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n \n pub fn mark_for_expr(cx: Context, e: @expr) {\n     match e.node {\n-      expr_vstore(_, _) |\n-      expr_vec(_, _) |\n-      expr_rec(_, _) | expr_struct(*) | expr_tup(_) |\n+      expr_vstore(_, _) | expr_vec(_, _) | expr_struct(*) | expr_tup(_) |\n       expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n-      expr_binary(add, _, _) |\n-      expr_copy(_) | expr_repeat(*) => {\n+      expr_binary(add, _, _) | expr_copy(_) | expr_repeat(*) => {\n         node_type_needs(cx, use_repr, e.id);\n       }\n       expr_cast(base, _) => {\n@@ -352,11 +349,10 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         mark_for_method_call(cx, e.id, e.callee_id);\n       }\n       expr_paren(e) => mark_for_expr(cx, e),\n-      expr_match(*) | expr_block(_) | expr_if(*) |\n-      expr_while(*) | expr_break(_) | expr_again(_) |\n-      expr_unary(_, _) | expr_lit(_) | expr_assert(_) |\n-      expr_mac(_) | expr_addr_of(_, _) |\n-      expr_ret(_) | expr_loop(_, _) |\n+\n+      expr_match(*) | expr_block(_) | expr_if(*) | expr_while(*) |\n+      expr_break(_) | expr_again(_) | expr_unary(_, _) | expr_lit(_) |\n+      expr_mac(_) | expr_addr_of(_, _) | expr_ret(_) | expr_loop(_, _) |\n       expr_loop_body(_) | expr_do_body(_) => ()\n     }\n }"}, {"sha": "082c64ced8ed7a486cb710b6855be70ce8892b7e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 80, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -506,7 +506,6 @@ pub enum sty {\n     ty_evec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n-    ty_rec(~[field]),\n     ty_bare_fn(BareFnTy),\n     ty_closure(ClosureTy),\n     ty_trait(def_id, substs, vstore),\n@@ -775,7 +774,6 @@ type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n pub type node_type_table = @mut SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n-    type val = {cnum: int, pos: uint, len: uint};\n     return oldmap::HashMap();\n }\n \n@@ -900,7 +898,6 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         flags |= rflags(r);\n         flags |= get(m.ty).flags;\n       }\n-      &ty_rec(ref flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n@@ -1029,8 +1026,6 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n-pub fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n-\n pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: ctxt, +fty: ClosureTy) -> t {\n@@ -1164,9 +1159,6 @@ pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_trait(_, ref substs, _) => {\n         for (*substs).tps.each |subty| { maybe_walk_ty(*subty, f); }\n       }\n-      ty_rec(fields) => {\n-        for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n-      }\n       ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n       ty_bare_fn(ref ft) => {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n@@ -1224,14 +1216,6 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_trait(did, ref substs, vst) => {\n             ty_trait(did, fold_substs(substs, fldop), vst)\n         }\n-        ty_rec(fields) => {\n-            let new_fields = do vec::map(fields) |fl| {\n-                let new_ty = fldop(fl.mt.ty);\n-                let new_mt = mt { ty: new_ty, mutbl: fl.mt.mutbl };\n-                field { ident: fl.ident, mt: new_mt }\n-            };\n-            ty_rec(new_fields)\n-        }\n         ty_tup(ts) => {\n             let new_ts = vec::map(ts, |tt| fldop(*tt));\n             ty_tup(new_ts)\n@@ -1479,9 +1463,7 @@ pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) |\n-      ty_closure(_) |\n-      ty_trait(*) |\n+      ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_closure(_) | ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n       => true,\n@@ -1514,7 +1496,6 @@ pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match /*bad*/copy get(ty).sty {\n-      ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n       _ => fail!(~\"get_element_type called on invalid type\")\n     }\n@@ -1640,9 +1621,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             encountered_box = true;\n             true\n           }\n-          ty_nil | ty_bot | ty_bool |\n-          ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_rec(_) | ty_tup(_) | ty_ptr(_) => {\n+          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty_tup(_) | ty_ptr(_) => {\n             true\n           }\n           ty_enum(did, ref substs) => {\n@@ -1963,12 +1943,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_NONE\n             }\n \n-            ty_rec(ref flds) => {\n-                flds.foldl(\n-                    TC_NONE,\n-                    |tc, f| tc + tc_mt(cx, f.mt, cache))\n-            }\n-\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let flds_tc = flds.foldl(\n@@ -2007,7 +1981,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // If this assertion failures, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n-                assert p.def_id.crate == ast::local_crate;\n+                fail_unless!(p.def_id.crate == ast::local_crate);\n \n                 param_bounds_to_contents(\n                     cx, cx.ty_param_bounds.get(&p.def_id.node))\n@@ -2152,10 +2126,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             n\n           }\n \n-          ty_rec(flds) => {\n-            flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n-          }\n-\n           ty_struct(did, ref substs) => {\n             let flds = struct_fields(cx, did, substs);\n             flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n@@ -2254,12 +2224,6 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false           // unsafe ptrs can always be NULL\n           }\n \n-          ty_rec(fields) => {\n-            do vec::any(fields) |field| {\n-                type_requires(cx, seen, r_ty, field.mt.ty)\n-            }\n-          }\n-\n           ty_trait(_, _, _) => {\n             false\n           }\n@@ -2328,14 +2292,6 @@ pub fn type_structurally_contains(cx: ctxt,\n         }\n         return false;\n       }\n-      ty_rec(fields) => {\n-        for fields.each |field| {\n-            if type_structurally_contains(cx, field.mt.ty, test) {\n-                return true;\n-            }\n-        }\n-        return false;\n-      }\n       ty_struct(did, ref substs) => {\n         for lookup_struct_fields(cx, did).each |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n@@ -2424,11 +2380,6 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n             if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n       }\n-      ty_rec(flds) => {\n-        for flds.each |f| {\n-            if !type_is_pod(cx, f.mt.ty) { result = false; }\n-        }\n-      }\n       ty_tup(elts) => {\n         for elts.each |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n@@ -2676,9 +2627,6 @@ impl to_bytes::IterBytes for sty {\n           ty_tup(ref ts) =>\n           to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n \n-          ty_rec(ref fs) =>\n-          to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n-\n           ty_bare_fn(ref ft) =>\n           to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n \n@@ -3118,7 +3066,6 @@ pub fn expr_kind(tcx: ctxt,\n \n         ast::expr_call(*) |\n         ast::expr_method_call(*) |\n-        ast::expr_rec(*) |\n         ast::expr_struct(*) |\n         ast::expr_tup(*) |\n         ast::expr_if(*) |\n@@ -3167,7 +3114,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_again(*) |\n         ast::expr_ret(*) |\n         ast::expr_log(*) |\n-        ast::expr_assert(*) |\n         ast::expr_while(*) |\n         ast::expr_loop(*) |\n         ast::expr_assign(*) |\n@@ -3221,23 +3167,6 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-pub fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n-    match vec::find(get_fields(rec_ty), |f| f.ident == id) {\n-      Some(f) => f,\n-      // Do we only call this when we know the field is legit?\n-      None => fail!(fmt!(\"get_field: ty doesn't have a field %s\",\n-                         *tcx.sess.str_of(id)))\n-    }\n-}\n-\n-pub fn get_fields(rec_ty:t) -> ~[field] {\n-    match /*bad*/copy get(rec_ty).sty {\n-      ty_rec(fields) => fields,\n-      // Can we check at the caller?\n-      _ => fail!(~\"get_fields: not a record type\")\n-    }\n-}\n-\n pub fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n     let mut i = 0u;\n     for meths.each |m| { if m.ident == id { return Some(i); } i += 1u; }\n@@ -3377,7 +3306,6 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_unboxed_vec(_) => ~\"unboxed vector\",\n       ty_ptr(_) => ~\"*-ptr\",\n       ty_rptr(_, _) => ~\"&-ptr\",\n-      ty_rec(_) => ~\"record\",\n       ty_bare_fn(_) => ~\"extern fn\",\n       ty_closure(_) => ~\"fn\",\n       ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n@@ -3590,7 +3518,7 @@ pub fn trait_supertraits(cx: ctxt,\n \n     // Not in the cache. It had better be in the metadata, which means it\n     // shouldn't be local.\n-    assert !is_local(id);\n+    fail_unless!(!is_local(id));\n \n     // Get the supertraits out of the metadata and create the\n     // InstantiatedTraitRef for each.\n@@ -3622,7 +3550,7 @@ pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n         // If the lookup in trait_method_cache fails, assume that the trait\n         // method we're trying to look up is in a different crate, and look\n         // for it there.\n-        assert id.crate != ast::local_crate;\n+        fail_unless!(id.crate != ast::local_crate);\n         let result = csearch::get_trait_methods(cx, id);\n \n         // Store the trait method in the local trait_method_cache so that\n@@ -3943,7 +3871,7 @@ pub fn lookup_item_type(cx: ctxt,\n         return tpt;\n       }\n       None => {\n-        assert did.crate != ast::local_crate;\n+        fail_unless!(did.crate != ast::local_crate);\n         let tyt = csearch::get_type(cx, did);\n         cx.tcache.insert(did, tyt);\n         return tyt;\n@@ -4142,7 +4070,7 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n-          ty_rec(_) | ty_tup(_) | ty_enum(_, _) => tycat_struct,\n+          ty_tup(_) | ty_enum(_, _) => tycat_struct,\n           ty_bot => tycat_bot,\n           _ => tycat_other\n         }"}, {"sha": "0b6c07832f634a5c767000b46e6f1615804fe3a7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -336,13 +336,6 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, *t));\n         ty::mk_tup(tcx, flds)\n       }\n-      ast::ty_rec(ref fields) => {\n-        let flds = do (*fields).map |f| {\n-            let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n-            field {ident: f.node.ident, mt: tm}\n-        };\n-        ty::mk_rec(tcx, flds)\n-      }\n       ast::ty_bare_fn(ref bf) => {\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n                                             bf.abi, &bf.decl))"}, {"sha": "1da4cbe7c91cc2fe6f3e8a929d8c9233d675ca6b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -414,41 +414,6 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       ast::pat_enum(path, subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_rec(fields, etc) => {\n-        let ex_fields = match structure_of(fcx, pat.span, expected) {\n-          ty::ty_rec(fields) => fields,\n-          _ => {\n-            tcx.sess.span_fatal\n-                (pat.span,\n-                fmt!(\"mismatched types: expected `%s` but found record\",\n-                     fcx.infcx().ty_to_str(expected)));\n-          }\n-        };\n-        let f_count = vec::len(fields);\n-        let ex_f_count = vec::len(ex_fields);\n-        if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            tcx.sess.span_fatal\n-                (pat.span, fmt!(\"mismatched types: expected a record \\\n-                      with %u fields, found one with %u \\\n-                      fields\",\n-                                ex_f_count, f_count));\n-        }\n-\n-        for fields.each |f| {\n-            match vec::find(ex_fields, |a| f.ident == a.ident) {\n-              Some(field) => {\n-                check_pat(pcx, f.pat, field.mt.ty);\n-              }\n-              None => {\n-                tcx.sess.span_fatal(pat.span,\n-                                    fmt!(\"mismatched types: did not \\\n-                                          expect a record with a field `%s`\",\n-                                          *tcx.sess.str_of(f.ident)));\n-              }\n-            }\n-        }\n-        fcx.write_ty(pat.id, expected);\n-      }\n       ast::pat_struct(path, fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);"}, {"sha": "b7c4fff801faf2a40e675b870a1e5bc5ed8688d7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -907,9 +907,8 @@ pub impl LookupContext/&self {\n             ty_infer(FloatVar(_)) |\n             ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n-            ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |\n-            ty_struct(*) | ty_tup(*) | ty_estr(*) | ty_evec(*) |\n-            ty_trait(*) | ty_closure(*) => {\n+            ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n+            ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))"}, {"sha": "6efa62c55cc2472c0be28e60a907689ee3604d88", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 98, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -606,14 +606,6 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_ty(t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n-        // If this is a record ty, check for duplicate fields\n-        match t.node {\n-            ast::ty_rec(ref fields) => {\n-              check_no_duplicate_fields(ccx.tcx, (*fields).map(|f|\n-                                              (f.node.ident, f.span)));\n-            }\n-            _ => ()\n-        }\n       }\n       ast::item_foreign_mod(m) => {\n         if syntax::attr::foreign_abi(it.attrs) ==\n@@ -1698,22 +1690,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let n_tys = tys.len();\n \n         match structure_of(fcx, expr.span, base_t) {\n-            ty::ty_rec(fields) => {\n-                match ty::field_idx(field, fields) {\n-                    Some(ix) => {\n-                        if n_tys > 0 {\n-                            tcx.sess.span_err(\n-                                expr.span,\n-                                ~\"can't provide type parameters \\\n-                                  to a field access\");\n-                        }\n-                        fcx.write_ty(expr.id, fields[ix].mt.ty);\n-                        fcx.write_autoderef_adjustment(base.id, derefs);\n-                        return bot;\n-                    }\n-                    _ => ()\n-                }\n-            }\n             ty::ty_struct(base_id, ref substs) => {\n                 // This is just for fields -- the same code handles\n                 // methods in both classes and traits\n@@ -1830,7 +1806,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         if check_completeness {\n             // Make sure the programmer specified all the fields.\n-            assert fields_found <= field_types.len();\n+            fail_unless!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n                 for field_types.each |class_field| {\n@@ -2333,10 +2309,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         check_expr(fcx, e);\n         fcx.write_nil(id);\n       }\n-      ast::expr_assert(e) => {\n-        bot = check_expr_has_type(fcx, e, ty::mk_bool(tcx));\n-        fcx.write_nil(id);\n-      }\n       ast::expr_copy(a) => {\n         bot = check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n@@ -2532,73 +2504,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_rec(ref fields, base) => {\n-        for base.each |b| { check_expr_with_opt_hint(fcx, *b, expected); }\n-        let expected = option::or(expected,\n-                                  base.map(|b| fcx.expr_ty(*b)));\n-        let flds = unpack_expected(fcx, expected, |sty|\n-            match *sty {\n-                ty::ty_rec(ref flds) => Some(copy *flds),\n-                _ => None\n-            }\n-        );\n-        let fields_t = fields.map(|f| {\n-            let hint_mt =\n-                flds.chain_ref(\n-                    |flds| vec::find(*flds, |tf| tf.ident == f.node.ident));\n-            let hint = hint_mt.map(|tf| tf.mt.ty);\n-            bot |= check_expr_with_opt_hint(fcx, f.node.expr, hint);\n-            let expr_t = fcx.expr_ty(f.node.expr);\n-            let expr_mt = ty::mt {ty: expr_t, mutbl: f.node.mutbl};\n-            // for the most precise error message,\n-            // should be f.node.expr.span, not f.span\n-            respan(f.node.expr.span, field {ident: f.node.ident, mt: expr_mt})\n-        });\n-        match base {\n-          None => {\n-            fn get_node(f: &spanned<field>) -> field { f.node }\n-            let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n-            fcx.write_ty(id, typ);\n-            /* Check for duplicate fields */\n-            /* Only do this check if there's no base expr -- the reason is\n-               that we're extending a record we know has no dup fields, and\n-               it would be ill-typed anyway if we duplicated one of its\n-               fields */\n-            check_no_duplicate_fields(tcx, (*fields).map(|f|\n-                                                    (f.node.ident, f.span)));\n-          }\n-          Some(bexpr) => {\n-            let bexpr_t = fcx.expr_ty(bexpr);\n-            let base_fields =  match structure_of(fcx, expr.span, bexpr_t) {\n-              ty::ty_rec(flds) => flds,\n-              _ => {\n-                  fcx.type_error_message(expr.span, |_actual| {\n-                      ~\"record update has non-record base\"\n-                  }, bexpr_t, None);\n-                fcx.write_ty(id, ty::mk_err(tcx));\n-                return true;\n-              }\n-            };\n-            fcx.write_ty(id, bexpr_t);\n-            for fields_t.each |f| {\n-                let mut found = false;\n-                for base_fields.each |bf| {\n-                    if f.node.ident == bf.ident {\n-                        demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n-                        found = true;\n-                    }\n-                }\n-                if !found {\n-                    tcx.sess.span_err(f.span,\n-                                        ~\"unknown field in record update: \" +\n-                                        *tcx.sess.str_of(f.node.ident));\n-                    fcx.write_ty(id, ty::mk_err(tcx));\n-                    return true;\n-                }\n-            }\n-          }\n-        }\n-      }\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(&id) {\n@@ -3266,8 +3171,8 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n-          assert tcx.intrinsic_defs.contains_key(&tydesc_name);\n-          assert ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name);\n+          fail_unless!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+          fail_unless!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(&tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(&ty_visitor_name);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,"}, {"sha": "818a444a4f38c339aaf8c03d255864570dff9069", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -692,7 +692,6 @@ pub mod guarantor {\n             ast::expr_again(*) |\n             ast::expr_ret(*) |\n             ast::expr_log(*) |\n-            ast::expr_assert(*) |\n             ast::expr_while(*) |\n             ast::expr_loop(*) |\n             ast::expr_assign(*) |\n@@ -701,7 +700,6 @@ pub mod guarantor {\n             ast::expr_cast(*) |\n             ast::expr_call(*) |\n             ast::expr_method_call(*) |\n-            ast::expr_rec(*) |\n             ast::expr_struct(*) |\n             ast::expr_tup(*) |\n             ast::expr_if(*) |\n@@ -713,8 +711,8 @@ pub mod guarantor {\n             ast::expr_copy(*) |\n             ast::expr_repeat(*) |\n             ast::expr_vec(*) => {\n-                assert !ty::expr_is_lval(\n-                    rcx.fcx.tcx(), rcx.fcx.ccx.method_map, expr);\n+                fail_unless!(!ty::expr_is_lval(\n+                    rcx.fcx.tcx(), rcx.fcx.ccx.method_map, expr));\n                 None\n             }\n         }\n@@ -875,7 +873,6 @@ pub mod guarantor {\n                 }\n             }\n             ast::pat_enum(*) => {}\n-            ast::pat_rec(ref fpats, _) |\n             ast::pat_struct(_, ref fpats, _) => {\n                 for fpats.each |fpat| {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);"}, {"sha": "7c9ca4ba85a4cb3eb0c7737b7e774b87bdbd93c7", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -178,7 +178,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n-            assert is_early;\n+            fail_unless!(is_early);\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n@@ -355,7 +355,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                                               is_early) {\n                                 Some(ref substs) => (/*bad*/copy *substs),\n                                 None => {\n-                                    assert is_early;\n+                                    fail_unless!(is_early);\n                                     // Bail out with a bogus answer\n                                     return Some(vtable_param(0, 0));\n                                 }"}, {"sha": "8abbb7a9909ff1002d578a5917f73d4395184575", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -28,7 +28,7 @@ use middle::ty::{lookup_item_type, param_bounds, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n-use middle::ty::{ty_rec, ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n+use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n use middle::ty::{type_is_ty_var};\n@@ -103,9 +103,8 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         }\n \n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n-        ty_estr(*) | ty_evec(*) | ty_rec(*) |\n-        ty_bare_fn(*) | ty_closure(*) | ty_tup(*) | ty_infer(*) |\n-        ty_param(*) | ty_self | ty_type | ty_opaque_box |\n+        ty_estr(*) | ty_evec(*) | ty_bare_fn(*) | ty_closure(*) | ty_tup(*) |\n+        ty_infer(*) | ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err => {\n             debug!(\"(getting base type) no base type; found %?\",\n                    get(original_type).sty);\n@@ -812,7 +811,7 @@ pub impl CoherenceChecker {\n     }\n \n     fn span_of_impl(&self, implementation: @Impl) -> span {\n-        assert implementation.did.crate == local_crate;\n+        fail_unless!(implementation.did.crate == local_crate);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(node_item(item, _)) => {\n                 return item.span;"}, {"sha": "1535156d96c729cb7ff7e8217ed72cb7dcb6f2ee", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -94,6 +94,12 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n                             (intrinsic_item.ident, (def_id, ty));\n                       }\n \n+                      ast::item_struct(*) => {\n+                        let ty = ty::mk_struct(ccx.tcx, def_id, substs);\n+                        ccx.tcx.intrinsic_defs.insert\n+                            (intrinsic_item.ident, (def_id, ty));\n+                      }\n+\n                       _ => {}\n                     }\n                 }"}, {"sha": "1f5e9707e2ddd2aabca34f3061916d0482aa88e6", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -546,17 +546,6 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_rec(as_), ty::ty_rec(bs)) => {\n-        if vec::same_length(as_, bs) {\n-            map_vec2(as_, bs, |a,b| {\n-                self.flds(*a, *b)\n-            }).chain(|flds| Ok(ty::mk_rec(tcx, flds)) )\n-        } else {\n-            Err(ty::terr_record_size(expected_found(self, as_.len(),\n-                                                    bs.len())))\n-        }\n-      }\n-\n       (ty::ty_tup(as_), ty::ty_tup(bs)) => {\n         if vec::same_length(as_, bs) {\n             map_vec2(as_, bs, |a, b| self.tys(*a, *b) )"}, {"sha": "9cb6c473d586ba9a464cc34904c3ef382a54dcb9", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -585,7 +585,7 @@ pub impl @mut InferCtxt {\n \n     /// Execute `f` and commit the bindings if successful\n     fn commit<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n-        assert !self.in_snapshot();\n+        fail_unless!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n         do indent {\n@@ -678,9 +678,9 @@ pub impl @mut InferCtxt {\n         let region_var = self.next_region_var_nb(span);\n \n         // add lb_region as a lower bound on the newly built variable\n-        assert self.region_vars.make_subregion(span,\n-                                               lb_region,\n-                                               region_var).is_ok();\n+        fail_unless!(self.region_vars.make_subregion(span,\n+                                                     lb_region,\n+                                                     region_var).is_ok());\n \n         return region_var;\n     }"}, {"sha": "e9843c8a075a07adb5a544cce9bf087c23187ea6", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -701,7 +701,7 @@ pub impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                assert self.var_spans.len() == *vid + 1;\n+                fail_unless!(self.var_spans.len() == *vid + 1);\n                 self.var_spans.pop();\n               }\n               AddConstraint(ref constraint) => {\n@@ -758,7 +758,7 @@ pub impl RegionVarBindings {\n \n     fn add_constraint(&mut self, +constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n \n@@ -774,7 +774,7 @@ pub impl RegionVarBindings {\n                       sub: Region,\n                       sup: Region) -> cres<()> {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n         match (sub, sup) {\n@@ -816,7 +816,7 @@ pub impl RegionVarBindings {\n                    b: Region)\n                 -> cres<Region> {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -842,7 +842,7 @@ pub impl RegionVarBindings {\n                    b: Region)\n                 -> cres<Region> {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -1376,7 +1376,7 @@ pub impl RegionVarBindings {\n \n         return match a_node.value {\n             NoValue => {\n-                assert a_node.classification == Contracting;\n+                fail_unless!(a_node.classification == Contracting);\n                 a_node.value = Value(b_region);\n                 true // changed\n             }\n@@ -1634,15 +1634,15 @@ pub impl RegionVarBindings {\n                   }\n \n                   ConstrainRegSubVar(region, _) => {\n-                    assert dir == Incoming;\n+                    fail_unless!(dir == Incoming);\n                     result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span\n                     });\n                   }\n \n                   ConstrainVarSubReg(_, region) => {\n-                    assert dir == Outgoing;\n+                    fail_unless!(dir == Outgoing);\n                     result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span"}, {"sha": "bcbe08c28811089460748634f53a4afeae0037e1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -114,9 +114,9 @@ pub impl ResolveState {\n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n-        assert vec::is_empty(self.v_seen);\n+        fail_unless!(vec::is_empty(self.v_seen));\n         let rty = indent(|| self.resolve_type(typ) );\n-        assert vec::is_empty(self.v_seen);\n+        fail_unless!(vec::is_empty(self.v_seen));\n         match self.err {\n           None => {\n             debug!(\"Resolved to %s + %s (modes=%x)\","}, {"sha": "867bcc30fa4ea30ab0a6441ee40374a7edfd5654", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -110,7 +110,7 @@ pub impl Env {\n                       m: &ast::_mod,\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n-            assert idx < names.len();\n+            fail_unless!(idx < names.len());\n             for m.items.each |item| {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n                     return search(self, *item, idx+1, names);"}, {"sha": "d692a66f69919af0dc547e43deaae61fb9dfa634", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -131,7 +131,7 @@ pub impl InferCtxt {\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            assert node_a.rank == node_b.rank;\n+            fail_unless!(node_a.rank == node_b.rank);\n             self.set(node_b.root, Redirect(node_a.root));\n             (node_a.root, node_a.rank + 1)\n         }"}, {"sha": "f0fc173101f2f7910427ea245295aded19ce59b6", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -59,8 +59,8 @@ impl region_scope for MethodRscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        assert self.region_parameterization.is_some() ||\n-            self.self_ty.is_borrowed();\n+        fail_unless!(self.region_parameterization.is_some() ||\n+            self.self_ty.is_borrowed());\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)\n@@ -94,7 +94,7 @@ impl region_scope for type_rscope {\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n         // if the self region is used, region parameterization should\n         // have inferred that this type is RP\n-        assert self.is_some();\n+        fail_unless!(self.is_some());\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)"}, {"sha": "7add8dd2dbe0d3d58fae7eb4daf5c958b38c7238", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -22,9 +22,8 @@ use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n-use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n-use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n-use middle::ty::{ty_unboxed_vec};\n+use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n+use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n use metadata::encoder;\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -414,10 +413,6 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_unboxed_vec(tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n       ty_type => ~\"type\",\n-      ty_rec(elems) => {\n-        let strs = elems.map(|fld| field_to_str(cx, *fld));\n-        ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n-      }\n       ty_tup(elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\""}, {"sha": "b5793cc0abde28d644f6c1b1f9c80a8b145dd592", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -145,7 +145,7 @@ fn should_prune_unconfigured_items() {\n     let source = ~\"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            assert vec::is_empty(ctxt.ast.node.module.items);\n+            fail_unless!(vec::is_empty(ctxt.ast.node.module.items));\n         }\n     }\n }\n@@ -155,7 +155,7 @@ fn srv_should_build_ast_map() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            assert !ctxt.ast_map.is_empty()\n+            fail_unless!(!ctxt.ast_map.is_empty())\n         };\n     }\n }\n@@ -171,6 +171,6 @@ fn srv_should_return_request_result() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         let result = exec(srv, |_ctxt| 1000 );\n-        assert result == 1000;\n+        fail_unless!(result == 1000);\n     }\n }"}, {"sha": "32966156eb108903765165dfb48970e98955a004", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -71,23 +71,23 @@ fn should_extract_crate_name_from_link_attribute() {\n     let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    assert attrs.name == Some(~\"snuggles\");\n+    fail_unless!(attrs.name == Some(~\"snuggles\"));\n }\n \n #[test]\n fn should_not_extract_crate_name_if_no_link_attribute() {\n     let source = ~\"\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    assert attrs.name == None;\n+    fail_unless!(attrs.name == None);\n }\n \n #[test]\n fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n     let source = ~\"#[link(whatever)]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    assert attrs.name == None;\n+    fail_unless!(attrs.name == None);\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n@@ -106,15 +106,15 @@ fn parse_desc_should_handle_undocumented_mods() {\n     let source = ~\"\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_desc(attrs);\n-    assert attrs == None;\n+    fail_unless!(attrs == None);\n }\n \n #[test]\n fn parse_desc_should_parse_simple_doc_attributes() {\n     let source = ~\"#[doc = \\\"basic\\\"]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_desc(attrs);\n-    assert attrs == Some(~\"basic\");\n+    fail_unless!(attrs == Some(~\"basic\"));\n }\n \n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n@@ -133,28 +133,28 @@ pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n fn should_parse_hidden_attribute() {\n     let source = ~\"#[doc(hidden)]\";\n     let attrs = test::parse_attributes(source);\n-    assert parse_hidden(attrs) == true;\n+    fail_unless!(parse_hidden(attrs) == true);\n }\n \n #[test]\n fn should_parse_hidden_attribute_with_other_docs() {\n     let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    assert parse_hidden(attrs) == true;\n+    fail_unless!(parse_hidden(attrs) == true);\n }\n \n #[test]\n fn should_not_parse_non_hidden_attribute() {\n     let source = ~\"#[doc = \\\"\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    assert parse_hidden(attrs) == false;\n+    fail_unless!(parse_hidden(attrs) == false);\n }\n \n #[test]\n fn should_concatenate_multiple_doc_comments() {\n     let source = ~\"/// foo\\n/// bar\";\n     let desc = parse_desc(test::parse_attributes(source));\n-    assert desc == Some(~\"foo\\nbar\");\n+    fail_unless!(desc == Some(~\"foo\\nbar\"));\n }\n \n "}, {"sha": "5e3fdf19ad3d8a608e110776f983f64a45b18c56", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -83,7 +83,7 @@ fn fold_crate(\n #[test]\n fn should_replace_top_module_name_with_crate_name() {\n     let doc = test::mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-    assert doc.cratemod().name() == ~\"bond\";\n+    fail_unless!(doc.cratemod().name() == ~\"bond\");\n }\n \n fn fold_item(\n@@ -126,31 +126,25 @@ fn parse_item_attrs<T:Owned>(\n #[test]\n fn should_should_extract_mod_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert doc.cratemod().mods()[0].desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_top_mod_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"];\");\n-    assert doc.cratemod().desc() == Some(~\"test\");\n-}\n-\n-#[test]\n-fn should_extract_foreign_mod_attributes() {\n-    let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n-    assert doc.cratemod().nmods()[0].desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_foreign_fn_attributes() {\n-    let doc = test::mk_doc(~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\");\n+    let doc = test::mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n+    fail_unless!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_fn_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-    assert doc.cratemod().fns()[0].desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n }\n \n fn fold_enum(\n@@ -202,13 +196,13 @@ fn fold_enum(\n fn should_extract_enum_docs() {\n     let doc = test::mk_doc(~\"#[doc = \\\"b\\\"]\\\n                             enum a { v }\");\n-    assert doc.cratemod().enums()[0].desc() == Some(~\"b\");\n+    fail_unless!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n }\n \n #[test]\n fn should_extract_variant_docs() {\n     let doc = test::mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n-    assert doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\");\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n }\n \n fn fold_trait(\n@@ -261,7 +255,7 @@ fn merge_method_attrs(\n     };\n \n     do vec::map2(docs, attrs) |doc, attrs| {\n-        assert doc.name == attrs.first();\n+        fail_unless!(doc.name == attrs.first());\n         let desc = attrs.second();\n \n         doc::MethodDoc {\n@@ -274,7 +268,7 @@ fn merge_method_attrs(\n #[test]\n fn should_extract_trait_docs() {\n     let doc = test::mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n-    assert doc.cratemod().traits()[0].desc() == Some(~\"whatever\");\n+    fail_unless!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n }\n \n #[test]\n@@ -284,7 +278,7 @@ fn should_extract_trait_method_docs() {\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    assert doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n }\n \n \n@@ -305,7 +299,7 @@ fn fold_impl(\n fn should_extract_impl_docs() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].desc() == Some(~\"whatever\");\n+    fail_unless!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n }\n \n #[test]\n@@ -315,7 +309,7 @@ fn should_extract_impl_method_docs() {\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool { }\\\n          }\");\n-    assert doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n }\n \n #[cfg(test)]"}, {"sha": "956d6ba2c5bfdf7ccf5b78193132eff7276a18c6", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -266,7 +266,7 @@ fn should_find_pandoc() {\n         ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert result == result::Ok(Some(~\"pandoc\"));\n+    fail_unless!(result == result::Ok(Some(~\"pandoc\")));\n }\n \n #[test]\n@@ -279,7 +279,7 @@ fn should_error_with_no_pandoc() {\n         ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert result == result::Err(~\"couldn't find pandoc\");\n+    fail_unless!(result == result::Err(~\"couldn't find pandoc\"));\n }\n \n #[cfg(test)]\n@@ -296,100 +296,100 @@ mod test {\n #[test]\n fn should_error_with_no_crates() {\n     let config = test::parse_config(~[~\"rustdoc\"]);\n-    assert config.get_err() == ~\"no crates specified\";\n+    fail_unless!(config.get_err() == ~\"no crates specified\");\n }\n \n #[test]\n fn should_error_with_multiple_crates() {\n     let config =\n         test::parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-    assert config.get_err() == ~\"multiple crates specified\";\n+    fail_unless!(config.get_err() == ~\"multiple crates specified\");\n }\n \n #[test]\n fn should_set_output_dir_to_cwd_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().output_dir == Path(\".\");\n+    fail_unless!(config.get().output_dir == Path(\".\"));\n }\n \n #[test]\n fn should_set_output_dir_if_provided() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n     ]);\n-    assert config.get().output_dir == Path(\"snuggles\");\n+    fail_unless!(config.get().output_dir == Path(\"snuggles\"));\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().output_format == PandocHtml;\n+    fail_unless!(config.get().output_format == PandocHtml);\n }\n \n #[test]\n fn should_set_output_format_to_markdown_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n     ]);\n-    assert config.get().output_format == Markdown;\n+    fail_unless!(config.get().output_format == Markdown);\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n     ]);\n-    assert config.get().output_format == PandocHtml;\n+    fail_unless!(config.get().output_format == PandocHtml);\n }\n \n #[test]\n fn should_error_on_bogus_format() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n     ]);\n-    assert config.get_err() == ~\"unknown output format 'bogus'\";\n+    fail_unless!(config.get_err() == ~\"unknown output format 'bogus'\");\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_by_default() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().output_style == DocPerMod;\n+    fail_unless!(config.get().output_style == DocPerMod);\n }\n \n #[test]\n fn should_set_output_style_to_one_doc_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n     ]);\n-    assert config.get().output_style == DocPerCrate;\n+    fail_unless!(config.get().output_style == DocPerCrate);\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n     ]);\n-    assert config.get().output_style == DocPerMod;\n+    fail_unless!(config.get().output_style == DocPerMod);\n }\n \n #[test]\n fn should_error_on_bogus_output_style() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n     ]);\n-    assert config.get_err() == ~\"unknown output style 'bogus'\";\n+    fail_unless!(config.get_err() == ~\"unknown output style 'bogus'\");\n }\n \n #[test]\n fn should_set_pandoc_command_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n     ]);\n-    assert config.get().pandoc_cmd == Some(~\"panda-bear-doc\");\n+    fail_unless!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n }\n \n #[test]\n fn should_set_pandoc_command_when_using_pandoc() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().pandoc_cmd == Some(~\"pandoc\");\n+    fail_unless!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n }"}, {"sha": "6a3a509ded4440c7f3cff4bda891b7f4f6c7a90e", "filename": "src/librustdoc/demo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdemo.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -26,9 +26,9 @@ use core::prelude::*;\n /// The base price of a muffin on a non-holiday\n const price_of_a_muffin: float = 70f;\n \n-type WaitPerson = {\n+struct WaitPerson {\n     hair_color: ~str\n-};\n+}\n \n /// The type of things that produce omnomnom\n enum OmNomNomy {"}, {"sha": "51574c2c3c7e53b5dac7e1409698e09cc0736d1f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -84,20 +84,21 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n #[test]\n fn should_promote_desc() {\n     let doc = test::mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-    assert doc.cratemod().mods()[0].brief() == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n }\n \n #[test]\n fn should_promote_trait_method_desc() {\n     let doc = test::mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].brief == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].brief ==\n+        Some(~\"desc\"));\n }\n \n #[test]\n fn should_promote_impl_method_desc() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n }\n \n #[cfg(test)]\n@@ -221,20 +222,20 @@ fn paragraphs(s: &str) -> ~[~str] {\n #[test]\n fn test_paragraphs_1() {\n     let paras = paragraphs(~\"1\\n\\n2\");\n-    assert paras == ~[~\"1\", ~\"2\"];\n+    fail_unless!(paras == ~[~\"1\", ~\"2\"]);\n }\n \n #[test]\n fn test_paragraphs_2() {\n     let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-    assert paras == ~[~\"1\\n1\", ~\"2\"];\n+    fail_unless!(paras == ~[~\"1\\n1\", ~\"2\"]);\n }\n \n #[test]\n fn should_promote_short_descs() {\n     let desc = Some(~\"desc\");\n     let brief = extract(copy desc);\n-    assert brief == desc;\n+    fail_unless!(brief == desc);\n }\n \n #[test]\n@@ -248,7 +249,7 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == None;\n+    fail_unless!(brief == None);\n }\n \n #[test]\n@@ -262,8 +263,8 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == Some(\n-        ~\"Warkworth Castle is a ruined medieval building in the town\");\n+    fail_unless!(brief == Some(\n+        ~\"Warkworth Castle is a ruined medieval building in the town\"));\n }\n \n #[test]\n@@ -277,8 +278,8 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == Some(\n-        ~\"Warkworth..Castle is a ruined medieval building in the town\");\n+    fail_unless!(brief == Some(\n+        ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n }\n \n #[test]\n@@ -292,6 +293,6 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == Some(\n-        ~\"Warkworth... Castle is a ruined medieval building in the town\");\n+    fail_unless!(brief == Some(\n+        ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n }"}, {"sha": "1eb8c0e6eca596c6311ca4dcb6839a8d4a8d6837", "filename": "src/librustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -27,5 +27,5 @@ fn escape(s: &str) -> ~str {\n fn should_escape_backslashes() {\n     let s = ~\"\\\\n\";\n     let r = escape(s);\n-    assert r == ~\"\\\\\\\\n\";\n+    fail_unless!(r == ~\"\\\\\\\\n\");\n }"}, {"sha": "fc784722b256e0c198edf2d7603eb2351c062880", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -185,8 +185,8 @@ fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n #[test]\n fn should_extract_const_name_and_id() {\n     let doc = test::mk_doc(~\"const a: int = 0;\");\n-    assert doc.cratemod().consts()[0].id() != 0;\n-    assert doc.cratemod().consts()[0].name() == ~\"a\";\n+    fail_unless!(doc.cratemod().consts()[0].id() != 0);\n+    fail_unless!(doc.cratemod().consts()[0].name() == ~\"a\");\n }\n \n fn enumdoc_from_enum(\n@@ -216,14 +216,14 @@ fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n #[test]\n fn should_extract_enums() {\n     let doc = test::mk_doc(~\"enum e { v }\");\n-    assert doc.cratemod().enums()[0].id() != 0;\n-    assert doc.cratemod().enums()[0].name() == ~\"e\";\n+    fail_unless!(doc.cratemod().enums()[0].id() != 0);\n+    fail_unless!(doc.cratemod().enums()[0].name() == ~\"e\");\n }\n \n #[test]\n fn should_extract_enum_variants() {\n     let doc = test::mk_doc(~\"enum e { v }\");\n-    assert doc.cratemod().enums()[0].variants[0].name == ~\"v\";\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n }\n \n fn traitdoc_from_trait(\n@@ -262,13 +262,13 @@ fn traitdoc_from_trait(\n #[test]\n fn should_extract_traits() {\n     let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert doc.cratemod().traits()[0].name() == ~\"i\";\n+    fail_unless!(doc.cratemod().traits()[0].name() == ~\"i\");\n }\n \n #[test]\n fn should_extract_trait_methods() {\n     let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].name == ~\"f\";\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n }\n \n fn impldoc_from_impl(\n@@ -295,7 +295,7 @@ fn impldoc_from_impl(\n #[test]\n fn should_extract_impl_methods() {\n     let doc = test::mk_doc(~\"impl int { fn f() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].name == ~\"f\";\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n }\n \n fn tydoc_from_ty(\n@@ -310,7 +310,7 @@ fn tydoc_from_ty(\n #[test]\n fn should_extract_tys() {\n     let doc = test::mk_doc(~\"type a = int;\");\n-    assert doc.cratemod().types()[0].name() == ~\"a\";\n+    fail_unless!(doc.cratemod().types()[0].name() == ~\"a\");\n }\n \n fn structdoc_from_struct(\n@@ -333,13 +333,13 @@ fn structdoc_from_struct(\n #[test]\n fn should_extract_structs() {\n     let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert doc.cratemod().structs()[0].name() == ~\"Foo\";\n+    fail_unless!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n }\n \n #[test]\n fn should_extract_struct_fields() {\n     let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert doc.cratemod().structs()[0].fields[0] == ~\"field\";\n+    fail_unless!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n }\n \n #[cfg(test)]\n@@ -359,40 +359,35 @@ mod test {\n     #[test]\n     pub fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n-        assert vec::is_empty(doc.cratemod().mods());\n-        assert vec::is_empty(doc.cratemod().fns());\n+        fail_unless!(vec::is_empty(doc.cratemod().mods()));\n+        fail_unless!(vec::is_empty(doc.cratemod().fns()));\n     }\n \n     #[test]\n     pub fn extract_mods() {\n         let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n-        assert doc.cratemod().mods()[0].name() == ~\"a\";\n-        assert doc.cratemod().mods()[0].mods()[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[0].mods()[1].name() == ~\"c\";\n-    }\n-\n-    #[test]\n-    pub fn extract_foreign_mods() {\n-        let doc = mk_doc(~\"extern mod a { }\");\n-        assert doc.cratemod().nmods()[0].name() == ~\"a\";\n+        fail_unless!(doc.cratemod().mods()[0].name() == ~\"a\");\n+        fail_unless!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n+        fail_unless!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_fns_from_foreign_mods() {\n-        let doc = mk_doc(~\"extern mod a { fn a(); }\");\n-        assert doc.cratemod().nmods()[0].fns[0].name() == ~\"a\";\n+        let doc = mk_doc(~\"extern { fn a(); }\");\n+        fail_unless!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n     pub fn extract_mods_deep() {\n         let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n-        assert doc.cratemod().mods()[0].mods()[0].mods()[0].name() == ~\"c\";\n+        fail_unless!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n+            ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(~\"mod a { }\");\n-        assert doc.cratemod().mods()[0].id() != 0;\n+        fail_unless!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n@@ -401,30 +396,30 @@ mod test {\n             ~\"fn a() { } \\\n               mod b { fn c() {\n              } }\");\n-        assert doc.cratemod().fns()[0].name() == ~\"a\";\n-        assert doc.cratemod().mods()[0].fns()[0].name() == ~\"c\";\n+        fail_unless!(doc.cratemod().fns()[0].name() == ~\"a\");\n+        fail_unless!(doc.cratemod().mods()[0].fns()[0].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(~\"fn a() { }\");\n-        assert doc.cratemod().fns()[0].id() != 0;\n+        fail_unless!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n     pub fn extract_should_use_default_crate_name() {\n         let source = ~\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n-        assert doc.cratemod().name() == ~\"burp\";\n+        fail_unless!(doc.cratemod().name() == ~\"burp\");\n     }\n \n     #[test]\n     pub fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");\n-            assert doc.cratemod().name() == ~\"name\";\n+            fail_unless!(doc.cratemod().name() == ~\"name\");\n         }\n     }\n }"}, {"sha": "e9d9732d51fd33a961357da61bc35f615f135a4d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -373,7 +373,7 @@ fn default_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }\n \n #[test]\n@@ -383,7 +383,7 @@ fn default_fold_should_produce_same_consts() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }\n \n #[test]\n@@ -393,7 +393,7 @@ fn default_fold_should_produce_same_enums() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }\n \n #[test]\n@@ -403,5 +403,5 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }"}, {"sha": "12d875945d92655458459159955af4cf54ee5aba", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -160,15 +160,16 @@ fn pandoc_header_id(header: &str) -> ~str {\n \n #[test]\n fn should_remove_punctuation_from_headers() {\n-    assert pandoc_header_id(~\"impl foo of bar<A>\") == ~\"impl-foo-of-bara\";\n-    assert pandoc_header_id(~\"impl of num::num for int\")\n-        == ~\"impl-of-numnum-for-int\";\n-    assert pandoc_header_id(~\"impl of num::num for int/&\")\n-        == ~\"impl-of-numnum-for-int\";\n-    assert pandoc_header_id(~\"impl of num::num for ^int\")\n-        == ~\"impl-of-numnum-for-int\";\n-    assert pandoc_header_id(~\"impl for & condvar\")\n-        == ~\"impl-for-condvar\";\n+    fail_unless!(pandoc_header_id(~\"impl foo of bar<A>\") ==\n+        ~\"impl-foo-of-bara\");\n+    fail_unless!(pandoc_header_id(~\"impl of num::num for int\")\n+        == ~\"impl-of-numnum-for-int\");\n+    fail_unless!(pandoc_header_id(~\"impl of num::num for int/&\")\n+        == ~\"impl-of-numnum-for-int\");\n+    fail_unless!(pandoc_header_id(~\"impl of num::num for ^int\")\n+        == ~\"impl-of-numnum-for-int\");\n+    fail_unless!(pandoc_header_id(~\"impl for & condvar\")\n+        == ~\"impl-for-condvar\");\n }\n \n #[test]\n@@ -177,18 +178,18 @@ fn should_index_mod_contents() {\n         config::DocPerCrate,\n         ~\"mod a { } fn b() { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"#module-a\"\n-    };\n-    assert (&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+    });\n+    fail_unless!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n         link: ~\"#function-b\"\n-    };\n+    });\n }\n \n #[test]\n@@ -197,18 +198,18 @@ fn should_index_mod_contents_multi_page() {\n         config::DocPerMod,\n         ~\"mod a { } fn b() { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"a.html\"\n-    };\n-    assert (&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+    });\n+    fail_unless!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n         link: ~\"#function-b\"\n-    };\n+    });\n }\n \n #[test]\n@@ -217,12 +218,12 @@ fn should_index_foreign_mod_pages() {\n         config::DocPerMod,\n         ~\"extern mod a { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Foreign module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"a.html\"\n-    };\n+    });\n }\n \n #[test]\n@@ -231,8 +232,8 @@ fn should_add_brief_desc_to_index() {\n         config::DocPerMod,\n         ~\"#[doc = \\\"test\\\"] mod a { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0].brief\n-        == Some(~\"test\");\n+    fail_unless!((&doc.cratemod().index).get().entries[0].brief\n+        == Some(~\"test\"));\n }\n \n #[test]\n@@ -241,13 +242,13 @@ fn should_index_foreign_mod_contents() {\n         config::DocPerCrate,\n         ~\"extern mod a { fn b(); }\"\n     );\n-    assert (&doc.cratemod().nmods()[0].index).get().entries[0]\n+    fail_unless!((&doc.cratemod().nmods()[0].index).get().entries[0]\n         == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n         link: ~\"#function-b\"\n-    };\n+    });\n }\n \n #[cfg(test)]"}, {"sha": "d7dd288ed89696c9a0f4d9b1f297136135a98609", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -91,9 +91,9 @@ fn should_write_modules_last() {\n     let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n     let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n \n-    assert idx_b < idx_d;\n-    assert idx_d < idx_a;\n-    assert idx_a < idx_c;\n+    fail_unless!(idx_b < idx_d);\n+    fail_unless!(idx_d < idx_a);\n+    fail_unless!(idx_a < idx_c);\n }\n \n struct Ctxt {\n@@ -175,10 +175,10 @@ fn should_write_title_for_each_page() {\n         let (page, markdown) = po.recv();\n         match page {\n           doc::CratePage(_) => {\n-            assert str::contains(markdown, ~\"% Crate core\");\n+            fail_unless!(str::contains(markdown, ~\"% Crate core\"));\n           }\n           doc::ItemPage(_) => {\n-            assert str::contains(markdown, ~\"% Module a\");\n+            fail_unless!(str::contains(markdown, ~\"% Module a\"));\n           }\n         }\n     }\n@@ -248,7 +248,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n         fullpath\n       }\n       &doc::ImplTag(ref doc) => {\n-        assert doc.self_ty.is_some();\n+        fail_unless!(doc.self_ty.is_some());\n         let self_ty = (&doc.self_ty).get();\n         let mut trait_part = ~\"\";\n         for doc.trait_types.eachi |i, trait_type| {\n@@ -314,7 +314,7 @@ fn write_mod(\n #[test]\n fn should_write_full_path_to_mod() {\n     let markdown = test::render(~\"mod a { mod b { mod c { } } }\");\n-    assert str::contains(markdown, ~\"# Module `a::b::c`\");\n+    fail_unless!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n }\n \n fn write_common(\n@@ -359,7 +359,7 @@ fn should_write_sections() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n }\n \n fn write_mod_contents(\n@@ -416,7 +416,7 @@ fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n #[test]\n fn should_write_crate_description() {\n     let markdown = test::render(~\"#[doc = \\\"this is the crate\\\"];\");\n-    assert str::contains(markdown, ~\"this is the crate\");\n+    fail_unless!(str::contains(markdown, ~\"this is the crate\"));\n }\n \n fn write_index(ctxt: &Ctxt, index: doc::Index) {\n@@ -440,32 +440,32 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n #[test]\n fn should_write_index() {\n     let markdown = test::render(~\"mod a { } mod b { }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n          * [Module `b`](#module-b)\\n\\n\"\n-    );\n+    ));\n }\n \n #[test]\n fn should_write_index_brief() {\n     let markdown = test::render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert str::contains(markdown, ~\"(#module-a) - test\\n\");\n+    fail_unless!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n }\n \n #[test]\n fn should_not_write_index_if_no_entries() {\n     let markdown = test::render(~\"\");\n-    assert !str::contains(markdown, ~\"\\n\\n\\n\");\n+    fail_unless!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n }\n \n #[test]\n fn should_write_index_for_foreign_mods() {\n     let markdown = test::render(~\"extern mod a { fn a(); }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n-    );\n+    ));\n }\n \n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n@@ -483,22 +483,22 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n #[test]\n fn should_write_foreign_mods() {\n     let markdown = test::render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n-    assert str::contains(markdown, ~\"Foreign module `a`\");\n-    assert str::contains(markdown, ~\"test\");\n+    fail_unless!(str::contains(markdown, ~\"Foreign module `a`\"));\n+    fail_unless!(str::contains(markdown, ~\"test\"));\n }\n \n #[test]\n fn should_write_foreign_fns() {\n     let markdown = test::render(\n         ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert str::contains(markdown, ~\"test\");\n+    fail_unless!(str::contains(markdown, ~\"test\"));\n }\n \n #[test]\n fn should_write_foreign_fn_headers() {\n     let markdown = test::render(\n         ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert str::contains(markdown, ~\"## Function `a`\");\n+    fail_unless!(str::contains(markdown, ~\"## Function `a`\"));\n }\n \n fn write_fn(\n@@ -542,19 +542,19 @@ fn code_block_indent(s: ~str) -> ~str {\n #[test]\n fn write_markdown_should_write_function_header() {\n     let markdown = test::render(~\"fn func() { }\");\n-    assert str::contains(markdown, ~\"## Function `func`\");\n+    fail_unless!(str::contains(markdown, ~\"## Function `func`\"));\n }\n \n #[test]\n fn should_write_the_function_signature() {\n     let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert str::contains(markdown, ~\"\\n    fn a()\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n }\n \n #[test]\n fn should_insert_blank_line_after_fn_signature() {\n     let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert str::contains(markdown, ~\"fn a()\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n }\n \n #[test]\n@@ -575,13 +575,13 @@ fn should_correctly_indent_fn_signature() {\n         ]\n     };\n     let markdown = test::write_markdown_str(doc);\n-    assert str::contains(markdown, ~\"    line 1\\n    line 2\");\n+    fail_unless!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n }\n \n #[test]\n fn should_leave_blank_line_between_fn_header_and_sig() {\n     let markdown = test::render(~\"fn a() { }\");\n-    assert str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\");\n+    fail_unless!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n }\n \n fn write_const(\n@@ -595,15 +595,15 @@ fn write_const(\n #[test]\n fn should_write_const_header() {\n     let markdown = test::render(~\"const a: bool = true;\");\n-    assert str::contains(markdown, ~\"## Const `a`\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n }\n \n #[test]\n fn should_write_const_description() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"b\\\"]\\\n          const a: bool = true;\");\n-    assert str::contains(markdown, ~\"\\n\\nb\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n }\n \n fn write_enum(\n@@ -617,14 +617,14 @@ fn write_enum(\n #[test]\n fn should_write_enum_header() {\n     let markdown = test::render(~\"enum a { b }\");\n-    assert str::contains(markdown, ~\"## Enum `a`\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n }\n \n #[test]\n fn should_write_enum_description() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-    assert str::contains(markdown, ~\"\\n\\nb\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n }\n \n fn write_variants(\n@@ -645,7 +645,7 @@ fn write_variants(\n }\n \n fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n-    assert doc.sig.is_some();\n+    fail_unless!(doc.sig.is_some());\n     let sig = (&doc.sig).get();\n     match copy doc.desc {\n       Some(desc) => {\n@@ -663,31 +663,31 @@ fn should_write_variant_list() {\n         ~\"enum a { \\\n          #[doc = \\\"test\\\"] b, \\\n          #[doc = \\\"test\\\"] c }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b` - test\\\n-         \\n* `c` - test\\n\\n\");\n+         \\n* `c` - test\\n\\n\"));\n }\n \n #[test]\n fn should_write_variant_list_without_descs() {\n     let markdown = test::render(~\"enum a { b, c }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b`\\\n-         \\n* `c`\\n\\n\");\n+         \\n* `c`\\n\\n\"));\n }\n \n #[test]\n fn should_write_variant_list_with_signatures() {\n     let markdown = test::render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b(int)`\\\n-         \\n* `c(int)` - a\\n\\n\");\n+         \\n* `c(int)` - a\\n\\n\"));\n }\n \n fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n@@ -714,28 +714,28 @@ fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n #[test]\n fn should_write_trait_header() {\n     let markdown = test::render(~\"trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"## Trait `i`\");\n+    fail_unless!(str::contains(markdown, ~\"## Trait `i`\"));\n }\n \n #[test]\n fn should_write_trait_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"desc\");\n+    fail_unless!(str::contains(markdown, ~\"desc\"));\n }\n \n #[test]\n fn should_write_trait_method_header() {\n     let markdown = test::render(\n         ~\"trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"### Method `a`\");\n+    fail_unless!(str::contains(markdown, ~\"### Method `a`\"));\n }\n \n #[test]\n fn should_write_trait_method_signature() {\n     let markdown = test::render(\n         ~\"trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"\\n    fn a()\");\n+    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\"));\n }\n \n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n@@ -746,34 +746,35 @@ fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n #[test]\n fn should_write_impl_header() {\n     let markdown = test::render(~\"impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"## Implementation for `int`\");\n+    fail_unless!(str::contains(markdown, ~\"## Implementation for `int`\"));\n }\n \n #[test]\n fn should_write_impl_header_with_trait() {\n     let markdown = test::render(~\"impl j for int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"## Implementation of `j` for `int`\");\n+    fail_unless!(str::contains(markdown,\n+        ~\"## Implementation of `j` for `int`\"));\n }\n \n #[test]\n fn should_write_impl_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"desc\");\n+    fail_unless!(str::contains(markdown, ~\"desc\"));\n }\n \n #[test]\n fn should_write_impl_method_header() {\n     let markdown = test::render(\n         ~\"impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"### Method `a`\");\n+    fail_unless!(str::contains(markdown, ~\"### Method `a`\"));\n }\n \n #[test]\n fn should_write_impl_method_signature() {\n     let markdown = test::render(\n         ~\"impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"\\n    fn a()\");\n+    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\"));\n }\n \n fn write_type(\n@@ -787,20 +788,20 @@ fn write_type(\n #[test]\n fn should_write_type_header() {\n     let markdown = test::render(~\"type t = int;\");\n-    assert str::contains(markdown, ~\"## Type `t`\");\n+    fail_unless!(str::contains(markdown, ~\"## Type `t`\"));\n }\n \n #[test]\n fn should_write_type_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-    assert str::contains(markdown, ~\"\\n\\ndesc\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n }\n \n #[test]\n fn should_write_type_signature() {\n     let markdown = test::render(~\"type t = int;\");\n-    assert str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n }\n \n fn write_struct(\n@@ -814,7 +815,7 @@ fn write_struct(\n #[test]\n fn should_write_struct_header() {\n     let markdown = test::render(~\"struct S { field: () }\");\n-    assert str::contains(markdown, ~\"## Struct `S`\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n }\n \n #[cfg(test)]\n@@ -901,12 +902,12 @@ mod test {\n     #[test]\n     pub fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        assert str::contains(markdown, ~\"# Module `moo`\");\n+        fail_unless!(str::contains(markdown, ~\"# Module `moo`\"));\n     }\n \n     #[test]\n     pub fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        assert str::contains(markdown, ~\"Module `morp`\\n\\n\");\n+        fail_unless!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n     }\n }"}, {"sha": "45fef5b80b8148f8a41366313d4f3f199e98940e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -92,7 +92,7 @@ fn pandoc_writer(\n     config: config::Config,\n     page: doc::Page\n ) -> Writer {\n-    assert config.pandoc_cmd.is_some();\n+    fail_unless!(config.pandoc_cmd.is_some());\n     let pandoc_cmd = (&config.pandoc_cmd).get();\n     let filename = make_local_filename(config, page);\n \n@@ -201,7 +201,7 @@ pub fn make_filename(\n                 config.output_style == config::DocPerMod {\n                 ~\"index\"\n             } else {\n-                assert doc.topmod.name() != ~\"\";\n+                fail_unless!(doc.topmod.name() != ~\"\");\n                 doc.topmod.name()\n             }\n           }\n@@ -229,7 +229,7 @@ fn should_use_markdown_file_name_based_off_crate() {\n     let doc = test::mk_doc(~\"test\", ~\"\");\n     let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n-    assert filename.to_str() == ~\"output/dir/test.md\";\n+    fail_unless!(filename.to_str() == ~\"output/dir/test.md\");\n }\n \n #[test]\n@@ -243,7 +243,7 @@ fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n     let doc = test::mk_doc(~\"\", ~\"\");\n     let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n-    assert filename.to_str() == ~\"output/dir/index.html\";\n+    fail_unless!(filename.to_str() == ~\"output/dir/index.html\");\n }\n \n #[test]\n@@ -258,7 +258,7 @@ fn should_name_mod_file_names_by_path() {\n     let modb = copy doc.cratemod().mods()[0].mods()[0];\n     let page = doc::ItemPage(doc::ModTag(modb));\n     let filename = make_local_filename(config, page);\n-    assert  filename == Path(\"output/dir/a_b.html\");\n+    fail_unless!(filename == Path(\"output/dir/a_b.html\"));\n }\n \n #[cfg(test)]"}, {"sha": "d5e877de71253b3deaf33cad2730ff87d3e0bcb0", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -154,31 +154,19 @@ fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n         config::DocPerCrate,\n         ~\"mod a { } mod b { mod c { } }\"\n     );\n-    assert doc.pages.len() == 1u;\n+    fail_unless!(doc.pages.len() == 1u);\n }\n \n #[test]\n fn should_make_a_page_for_every_mod() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    assert doc.pages.mods()[0].name() == ~\"a\";\n+    fail_unless!(doc.pages.mods()[0].name() == ~\"a\");\n }\n \n #[test]\n fn should_remove_mods_from_containing_mods() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_make_a_page_for_every_foreign_mod() {\n-    let doc = test::mk_doc(~\"extern mod a { }\");\n-    assert doc.pages.nmods()[0].name() == ~\"a\";\n-}\n-\n-#[test]\n-fn should_remove_foreign_mods_from_containing_mods() {\n-    let doc = test::mk_doc(~\"extern mod a { }\");\n-    assert vec::is_empty(doc.cratemod().nmods());\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()));\n }\n \n #[cfg(test)]"}, {"sha": "7b80b0b4ae8c921e16ff7dd17a6114c9cef234f1", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -93,6 +93,6 @@ fn test_run_passes() {\n         ];\n         let doc = extract::from_srv(srv.clone(), ~\"one\");\n         let doc = run_passes(srv, doc, passes);\n-        assert doc.cratemod().name() == ~\"onetwothree\";\n+        fail_unless!(doc.cratemod().name() == ~\"onetwothree\");\n     }\n }"}, {"sha": "58b25446dc1b37c0ea711d7e54617f618a7cb06b", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -98,10 +98,10 @@ fn should_record_mod_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n-            == ~[~\"a\", ~\"b\"];\n-        assert doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n-            == ~[~\"a\", ~\"d\"];\n+        fail_unless!(doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n+            == ~[~\"a\", ~\"b\"]);\n+        fail_unless!(doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n+            == ~[~\"a\", ~\"d\"]);\n     }\n }\n \n@@ -111,26 +111,7 @@ fn should_record_fn_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"];\n+        fail_unless!(doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"]);\n     }\n }\n \n-#[test]\n-fn should_record_foreign_mod_paths() {\n-    let source = ~\"mod a { extern mod b { } }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = run(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].nmods()[0].path() == ~[~\"a\"];\n-    }\n-}\n-\n-#[test]\n-fn should_record_foreign_fn_paths() {\n-    let source = ~\"extern mod a { fn b(); }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = run(srv.clone(), doc);\n-        assert doc.cratemod().nmods()[0].fns[0].path() == ~[~\"a\"];\n-    }\n-}"}, {"sha": "bbd975dd55ace9a26b8fbbcef7fb6e4c9aa7bcc2", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -66,7 +66,7 @@ fn should_prune_hidden_items() {\n     use core::vec;\n \n     let doc = test::mk_doc(~\"#[doc(hidden)] mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods())\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()))\n }\n \n #[cfg(test)]"}, {"sha": "17f11de8aebfcdc62885d9a3e11eda9bd6cd2541", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -69,7 +69,7 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n #[test]\n fn should_prune_items_without_pub_modifier() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods());\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()));\n }\n \n #[cfg(test)]"}, {"sha": "e64d4ccf69e7c33eb46f81f5f94d04a98a7d0e05", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -168,9 +168,9 @@ fn should_create_section_headers() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         doc.cratemod().mods()[0].item.sections[0].header,\n-        ~\"Header\");\n+        ~\"Header\"));\n }\n \n #[test]\n@@ -181,9 +181,9 @@ fn should_create_section_bodies() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         doc.cratemod().mods()[0].item.sections[0].body,\n-        ~\"Body\");\n+        ~\"Body\"));\n }\n \n #[test]\n@@ -194,7 +194,7 @@ fn should_not_create_sections_from_indented_headers() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert vec::is_empty(doc.cratemod().mods()[0].item.sections);\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n }\n \n #[test]\n@@ -206,12 +206,12 @@ fn should_remove_section_text_from_main_desc() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert !str::contains(\n+    fail_unless!(!str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n-        ~\"Header\");\n-    assert !str::contains(\n+        ~\"Header\"));\n+    fail_unless!(!str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n-        ~\"Body\");\n+        ~\"Body\"));\n }\n \n #[test]\n@@ -222,7 +222,7 @@ fn should_eliminate_desc_if_it_is_just_whitespace() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert doc.cratemod().mods()[0].desc() == None;\n+    fail_unless!(doc.cratemod().mods()[0].desc() == None);\n }\n \n #[test]\n@@ -233,7 +233,7 @@ fn should_sectionalize_trait_methods() {\n          # Header\\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].sections.len() == 1u;\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n }\n \n #[test]\n@@ -244,7 +244,7 @@ fn should_sectionalize_impl_methods() {\n          # Header\\n\\\n          Body\\\"]\\\n          fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sections.len() == 1u;\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n }\n \n #[cfg(test)]"}, {"sha": "0e6d83fa45f3b399e0bd1ee67c8295c74c5880c2", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -31,7 +31,7 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        assert doc.cratemod().items[0].name() == ~\"y\";\n-        assert doc.cratemod().items[1].name() == ~\"z\";\n+        fail_unless!(doc.cratemod().items[0].name() == ~\"y\");\n+        fail_unless!(doc.cratemod().items[1].name() == ~\"z\");\n     }\n }"}, {"sha": "cddd5068816cd424b713f392e42946f7a9c249f3", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -55,14 +55,14 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        assert doc.cratemod().items[0].name() == ~\"iconst\";\n-        assert doc.cratemod().items[1].name() == ~\"itype\";\n-        assert doc.cratemod().items[2].name() == ~\"ienum\";\n-        assert doc.cratemod().items[3].name() == ~\"istruct\";\n-        assert doc.cratemod().items[4].name() == ~\"itrait\";\n-        assert doc.cratemod().items[5].name() == ~\"__extensions__\";\n-        assert doc.cratemod().items[6].name() == ~\"ifn\";\n-        assert doc.cratemod().items[7].name() == ~\"imod\";\n-        assert doc.cratemod().items[8].name() == ~\"inmod\";\n+        fail_unless!(doc.cratemod().items[0].name() == ~\"iconst\");\n+        fail_unless!(doc.cratemod().items[1].name() == ~\"itype\");\n+        fail_unless!(doc.cratemod().items[2].name() == ~\"ienum\");\n+        fail_unless!(doc.cratemod().items[3].name() == ~\"istruct\");\n+        fail_unless!(doc.cratemod().items[4].name() == ~\"itrait\");\n+        fail_unless!(doc.cratemod().items[5].name() == ~\"__extensions__\");\n+        fail_unless!(doc.cratemod().items[6].name() == ~\"ifn\");\n+        fail_unless!(doc.cratemod().items[7].name() == ~\"imod\");\n+        fail_unless!(doc.cratemod().items[8].name() == ~\"inmod\");\n     }\n }"}, {"sha": "4f4c5ea65d4d8a8d1f2a5932a2bae81572df315e", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -67,10 +67,10 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].name() == ~\"w\";\n-        assert doc.cratemod().mods()[1].items[0].name() == ~\"x\";\n-        assert doc.cratemod().mods()[1].items[1].name() == ~\"y\";\n-        assert doc.cratemod().mods()[1].name() == ~\"z\";\n+        fail_unless!(doc.cratemod().mods()[0].name() == ~\"w\");\n+        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"x\");\n+        fail_unless!(doc.cratemod().mods()[1].items[1].name() == ~\"y\");\n+        fail_unless!(doc.cratemod().mods()[1].name() == ~\"z\");\n     }\n }\n \n@@ -84,10 +84,10 @@ fn should_be_stable() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].items[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[1].items[0].name() == ~\"d\";\n+        fail_unless!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n+        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].items[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[1].items[0].name() == ~\"d\";\n+        fail_unless!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n+        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n     }\n }"}, {"sha": "797f276de0a6ec8578c4712b6832945c9a68ee77", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -140,89 +140,89 @@ fn fold_impl(\n #[test]\n fn should_execute_op_on_enum_brief() {\n     let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert doc.cratemod().enums()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n     let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert doc.cratemod().enums()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_variant_desc() {\n     let doc = test::mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n-    assert doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\");\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert doc.cratemod().traits()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert doc.cratemod().traits()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_method_brief() {\n     let doc = test::mk_doc(\n         ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_method_desc() {\n     let doc = test::mk_doc(\n         ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_method_brief() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_method_desc() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_type_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert doc.cratemod().types()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_type_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert doc.cratemod().types()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n@@ -232,7 +232,7 @@ fn should_execute_on_item_section_headers() {\n          #    Header    \\n\\\n          Body\\\"]\\\n          fn a() { }\");\n-    assert doc.cratemod().fns()[0].sections()[0].header == ~\"Header\";\n+    fail_unless!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n }\n \n #[test]\n@@ -242,7 +242,7 @@ fn should_execute_on_item_section_bodies() {\n          # Header\\n\\\n          Body      \\\"]\\\n          fn a() { }\");\n-    assert doc.cratemod().fns()[0].sections()[0].body == ~\"Body\";\n+    fail_unless!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n }\n \n #[test]\n@@ -253,8 +253,8 @@ fn should_execute_on_trait_method_section_headers() {\n          # Header    \\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].sections[0].header\n-        == ~\"Header\";\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sections[0].header\n+        == ~\"Header\");\n }\n \n #[test]\n@@ -265,7 +265,8 @@ fn should_execute_on_trait_method_section_bodies() {\n          # Header\\n\\\n          Body     \\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].sections[0].body == ~\"Body\";\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n+        ~\"Body\");\n }\n \n #[test]\n@@ -276,8 +277,8 @@ fn should_execute_on_impl_method_section_headers() {\n          # Header   \\n\\\n          Body\\\"]\\\n          fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sections[0].header\n-        == ~\"Header\";\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sections[0].header\n+        == ~\"Header\");\n }\n \n #[test]\n@@ -288,7 +289,8 @@ fn should_execute_on_impl_method_section_bodies() {\n          # Header\\n\\\n          Body    \\\"]\\\n          fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sections[0].body == ~\"Body\";\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n+        ~\"Body\");\n }\n \n #[cfg(test)]"}, {"sha": "58d629163e2ea93f17465f80849f31bd62f059a6", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -31,7 +31,7 @@ fn should_trim_text() {\n     let doc = test::mk_doc(~\"#[doc = \\\" desc \\\"] \\\n                             mod m {\n                             }\");\n-    assert doc.cratemod().mods()[0].desc() == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n }\n \n #[cfg(test)]"}, {"sha": "e5f304ee8aca153b30c1963b006c32fe3741c399", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -86,13 +86,14 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n #[test]\n fn should_add_fn_sig() {\n     let doc = test::mk_doc(~\"fn a<T>() -> int { }\");\n-    assert doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n }\n \n #[test]\n fn should_add_foreign_fn_sig() {\n     let doc = test::mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n-    assert doc.cratemod().nmods()[0].fns[0].sig == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().nmods()[0].fns[0].sig ==\n+        Some(~\"fn a<T>() -> int\"));\n }\n \n fn fold_const(\n@@ -121,7 +122,7 @@ fn fold_const(\n #[test]\n fn should_add_const_types() {\n     let doc = test::mk_doc(~\"const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].sig == Some(~\"bool\");\n+    fail_unless!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n }\n \n fn fold_enum(\n@@ -165,7 +166,8 @@ fn fold_enum(\n #[test]\n fn should_add_variant_sigs() {\n     let doc = test::mk_doc(~\"enum a { b(int) }\");\n-    assert doc.cratemod().enums()[0].variants[0].sig == Some(~\"b(int)\");\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].sig ==\n+        Some(~\"b(int)\"));\n }\n \n fn fold_trait(\n@@ -255,8 +257,8 @@ fn get_method_sig(\n #[test]\n fn should_add_trait_method_sigs() {\n     let doc = test::mk_doc(~\"trait i { fn a<T>() -> int; }\");\n-    assert doc.cratemod().traits()[0].methods[0].sig\n-        == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sig\n+        == Some(~\"fn a<T>() -> int\"));\n }\n \n fn fold_impl(\n@@ -296,26 +298,26 @@ fn fold_impl(\n #[test]\n fn should_add_impl_trait_types() {\n     let doc = test::mk_doc(~\"impl j for int { fn a<T>() { } }\");\n-    assert doc.cratemod().impls()[0].trait_types[0] == ~\"j\";\n+    fail_unless!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n }\n \n #[test]\n fn should_not_add_impl_trait_types_if_none() {\n     let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert vec::len(doc.cratemod().impls()[0].trait_types) == 0;\n+    fail_unless!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n }\n \n #[test]\n fn should_add_impl_self_ty() {\n     let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].self_ty == Some(~\"int\");\n+    fail_unless!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n }\n \n #[test]\n fn should_add_impl_method_sigs() {\n     let doc = test::mk_doc(~\"impl int { fn a<T>() -> int { fail!() } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sig\n-        == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sig\n+        == Some(~\"fn a<T>() -> int\"));\n }\n \n fn fold_type(\n@@ -354,7 +356,7 @@ fn fold_type(\n #[test]\n fn should_add_type_signatures() {\n     let doc = test::mk_doc(~\"type t<T> = int;\");\n-    assert doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\");\n+    fail_unless!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n }\n \n fn fold_struct(\n@@ -407,21 +409,22 @@ fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n #[test]\n fn should_add_struct_defs() {\n     let doc = test::mk_doc(~\"struct S { field: () }\");\n-    assert (&doc.cratemod().structs()[0].sig).get().contains(\"struct S {\");\n+    fail_unless!((&doc.cratemod().structs()[0].sig).get().contains(\n+        \"struct S {\"));\n }\n \n #[test]\n fn should_not_serialize_struct_drop_blocks() {\n     // All we care about are the fields\n     let doc = test::mk_doc(~\"struct S { field: (), drop { } }\");\n-    assert !(&doc.cratemod().structs()[0].sig).get().contains(\"drop\");\n+    fail_unless!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n }\n \n #[test]\n fn should_not_serialize_struct_attrs() {\n     // All we care about are the fields\n     let doc = test::mk_doc(~\"#[wut] struct S { field: () }\");\n-    assert !(&doc.cratemod().structs()[0].sig).get().contains(\"wut\");\n+    fail_unless!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n }\n \n #[cfg(test)]"}, {"sha": "6edf53785cbb9b1a7e7da54c346a14b6afc885cd", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -83,7 +83,7 @@ fn unindent(s: &str) -> ~str {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {\n-                assert str::len(*line) >= min_indent;\n+                fail_unless!(str::len(*line) >= min_indent);\n                 str::slice(*line, min_indent, str::len(*line))\n             }\n         };\n@@ -97,14 +97,14 @@ fn unindent(s: &str) -> ~str {\n fn should_unindent() {\n     let s = ~\"    line1\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\nline2\";\n+    fail_unless!(r == ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_unindent_multiple_paragraphs() {\n     let s = ~\"    line1\\n\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\n\\nline2\";\n+    fail_unless!(r == ~\"line1\\n\\nline2\");\n }\n \n #[test]\n@@ -113,7 +113,7 @@ fn should_leave_multiple_indent_levels() {\n     // base indentation and should be preserved\n     let s = ~\"    line1\\n\\n        line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\n\\n    line2\";\n+    fail_unless!(r == ~\"line1\\n\\n    line2\");\n }\n \n #[test]\n@@ -125,12 +125,12 @@ fn should_ignore_first_line_indent() {\n     //          and continue here\"]\n     let s = ~\"line1\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\nline2\";\n+    fail_unless!(r == ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n     let s = ~\"line1\\n\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\n\\n    line2\";\n+    fail_unless!(r == ~\"line1\\n\\n    line2\");\n }"}, {"sha": "b63a0a92e6c15b72104bef0c2e1ac5a86fc331e1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -787,19 +787,19 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n \n #[test]\n fn test_is_cmd() {\n-    assert is_cmd(~\"build\");\n-    assert is_cmd(~\"clean\");\n-    assert is_cmd(~\"do\");\n-    assert is_cmd(~\"info\");\n-    assert is_cmd(~\"install\");\n-    assert is_cmd(~\"prefer\");\n-    assert is_cmd(~\"test\");\n-    assert is_cmd(~\"uninstall\");\n-    assert is_cmd(~\"unprefer\");\n+    fail_unless!(is_cmd(~\"build\"));\n+    fail_unless!(is_cmd(~\"clean\"));\n+    fail_unless!(is_cmd(~\"do\"));\n+    fail_unless!(is_cmd(~\"info\"));\n+    fail_unless!(is_cmd(~\"install\"));\n+    fail_unless!(is_cmd(~\"prefer\"));\n+    fail_unless!(is_cmd(~\"test\"));\n+    fail_unless!(is_cmd(~\"uninstall\"));\n+    fail_unless!(is_cmd(~\"unprefer\"));\n }\n \n #[test]\n fn test_parse_name() {\n-    assert parse_name(~\"org.mozilla.servo\").get() == ~\"servo\";\n-    assert parse_name(~\"org. mozilla.servo 2131\").is_err();\n+    fail_unless!(parse_name(~\"org.mozilla.servo\").get() == ~\"servo\");\n+    fail_unless!(parse_name(~\"org. mozilla.servo 2131\").is_err());\n }"}, {"sha": "e7503f0082c2e1233f1a5d1c94738c0b3b67ab7b", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -44,7 +44,7 @@ pub impl Condvar/&self {\n      */\n     #[inline(always)]\n     fn wait_on(&self, condvar_id: uint) {\n-        assert !*self.failed;\n+        fail_unless!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n         // This is why we need to wrap sync::condvar.\n         check_poison(self.is_mutex, *self.failed);\n@@ -60,7 +60,7 @@ pub impl Condvar/&self {\n      */\n     #[inline(always)]\n     fn signal_on(&self, condvar_id: uint) -> bool {\n-        assert !*self.failed;\n+        fail_unless!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n@@ -74,7 +74,7 @@ pub impl Condvar/&self {\n      */\n     #[inline(always)]\n     fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        assert !*self.failed;\n+        fail_unless!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n     }\n }\n@@ -230,7 +230,7 @@ struct PoisonOnFail {\n impl Drop for PoisonOnFail {\n     fn finalize(&self) {\n         unsafe {\n-            /* assert !*self.failed;\n+            /* fail_unless!(!*self.failed);\n                -- might be false in case of cond.wait() */\n             if task::failing() {\n                 *self.failed = true;\n@@ -384,7 +384,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n         // of this cast is removing the mutability.)\n         let new_data = unsafe { cast::transmute_immut(data) };\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n-        assert ptr::ref_eq(&state.data, new_data);\n+        fail_unless!(ptr::ref_eq(&state.data, new_data));\n         // Produce new token\n         RWReadMode((new_data, new_token))\n     }\n@@ -476,13 +476,13 @@ mod tests {\n             let arc_v = p.recv();\n \n             let v = *arc::get::<~[int]>(&arc_v);\n-            assert v[3] == 4;\n+            fail_unless!(v[3] == 4);\n         };\n \n         let c = p.recv();\n         c.send(arc::clone(&arc_v));\n \n-        assert (*arc::get(&arc_v))[2] == 3;\n+        fail_unless!((*arc::get(&arc_v))[2] == 3);\n \n         log(info, arc_v);\n     }\n@@ -503,7 +503,7 @@ mod tests {\n         }\n         do arc.access_cond |state, cond| {\n             comm::send_one(c.take(), ());\n-            assert !*state;\n+            fail_unless!(!*state);\n             while !*state {\n                 cond.wait();\n             }\n@@ -519,7 +519,8 @@ mod tests {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n-                assert *one == 0; // Parent should fail when it wakes up.\n+                // Parent should fail when it wakes up.\n+                fail_unless!(*one == 0);\n             }\n         }\n \n@@ -536,11 +537,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.access |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.access |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -549,11 +550,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.write |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.read |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -562,11 +563,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.write |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -576,12 +577,12 @@ mod tests {\n         do task::try || {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n-                    assert *one == 2;\n+                    fail_unless!(*one == 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -590,11 +591,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.read |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.read |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -603,11 +604,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.read |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -618,12 +619,12 @@ mod tests {\n             do arc2.write_downgrade |write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 do (&read_mode).read |one| {\n-                    assert *one == 2;\n+                    fail_unless!(*one == 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test]\n@@ -651,7 +652,7 @@ mod tests {\n             do task::task().future_result(|+r| children.push(r)).spawn\n                 || {\n                 do arc3.read |num| {\n-                    assert *num >= 0;\n+                    fail_unless!(*num >= 0);\n                 }\n             }\n         }\n@@ -661,7 +662,7 @@ mod tests {\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| { assert *num == 10; }\n+        do arc.read |num| { fail_unless!(*num == 10); }\n     }\n     #[test]\n     pub fn test_rw_downgrade() {\n@@ -682,7 +683,7 @@ mod tests {\n             do task::spawn || {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n-                    assert *state == 31337;\n+                    fail_unless!(*state == 31337);\n                     rc2.send(());\n                 }\n             }\n@@ -694,15 +695,15 @@ mod tests {\n         do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n-                assert *state == 0;\n+                fail_unless!(*state == 0);\n                 *state = 42;\n                 cond.signal();\n             }\n             wp1.recv();\n             do arc2.write |state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n-                assert *state == 31337;\n+                fail_unless!(*state == 31337);\n                 *state = 42;\n             }\n             wc2.send(());\n@@ -715,7 +716,7 @@ mod tests {\n                 while *state == 0 {\n                     cond.wait();\n                 }\n-                assert *state == 42;\n+                fail_unless!(*state == 42);\n                 *state = 31337;\n                 // send to other readers\n                 for vec::each(reader_convos) |x| {\n@@ -733,7 +734,7 @@ mod tests {\n                     }\n                 }\n                 wc1.send(()); // tell writer to try again\n-                assert *state == 31337;\n+                fail_unless!(*state == 31337);\n             }\n         }\n "}, {"sha": "9ed6d285ce687681e6fbc4452199593360f8d8a1", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -46,18 +46,26 @@ use core::sys;\n use core::uint;\n use core::vec;\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn move_val_init<T>(dst: &mut T, -src: T);\n-    fn needs_drop<T>() -> bool;\n+pub mod rusti {\n+    #[abi = \"rust-intrinsic\"]\n+    pub extern {\n+        fn move_val_init<T>(dst: &mut T, -src: T);\n+        fn needs_drop<T>() -> bool;\n+    }\n }\n \n-extern mod rustrt {\n-    #[rust_stack]\n-    unsafe fn rust_call_tydesc_glue(root: *u8,\n-                                    tydesc: *TypeDesc,\n-                                    field: size_t);\n+pub mod rustrt {\n+    use core::libc::size_t;\n+    use core::sys::TypeDesc;\n+\n+    pub extern {\n+        #[rust_stack]\n+        unsafe fn rust_call_tydesc_glue(root: *u8,\n+                                        tydesc: *TypeDesc,\n+                                        field: size_t);\n+    }\n }\n+\n // This probably belongs somewhere else. Needs to be kept in sync with\n // changes to glue...\n const tydesc_drop_glue_index: size_t = 3 as size_t;"}, {"sha": "0bd9e1eac51a381cb5137ae679c89965810b2b48", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -153,23 +153,23 @@ mod tests {\n \n     #[test]\n     pub fn test_to_base64() {\n-        assert (~\"\").to_base64()       == ~\"\";\n-        assert (~\"f\").to_base64()      == ~\"Zg==\";\n-        assert (~\"fo\").to_base64()     == ~\"Zm8=\";\n-        assert (~\"foo\").to_base64()    == ~\"Zm9v\";\n-        assert (~\"foob\").to_base64()   == ~\"Zm9vYg==\";\n-        assert (~\"fooba\").to_base64()  == ~\"Zm9vYmE=\";\n-        assert (~\"foobar\").to_base64() == ~\"Zm9vYmFy\";\n+        fail_unless!((~\"\").to_base64()       == ~\"\");\n+        fail_unless!((~\"f\").to_base64()      == ~\"Zg==\");\n+        fail_unless!((~\"fo\").to_base64()     == ~\"Zm8=\");\n+        fail_unless!((~\"foo\").to_base64()    == ~\"Zm9v\");\n+        fail_unless!((~\"foob\").to_base64()   == ~\"Zm9vYg==\");\n+        fail_unless!((~\"fooba\").to_base64()  == ~\"Zm9vYmE=\");\n+        fail_unless!((~\"foobar\").to_base64() == ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     pub fn test_from_base64() {\n-        assert (~\"\").from_base64() == str::to_bytes(~\"\");\n-        assert (~\"Zg==\").from_base64() == str::to_bytes(~\"f\");\n-        assert (~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\");\n-        assert (~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\");\n-        assert (~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\");\n-        assert (~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\");\n-        assert (~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\");\n+        fail_unless!((~\"\").from_base64() == str::to_bytes(~\"\"));\n+        fail_unless!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n+        fail_unless!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));\n+        fail_unless!((~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\"));\n+        fail_unless!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n+        fail_unless!((~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\"));\n+        fail_unless!((~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\"));\n     }\n }"}, {"sha": "5c3f37faca71ec73c3ab7c816b98036d6f94003d", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -162,7 +162,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n             lo\n         };\n \n-        assert borrow == 0;     // <=> assert (self >= other);\n+        fail_unless!(borrow == 0);     // <=> fail_unless!((self >= other));\n         return BigUint::new(diff);\n     }\n }\n@@ -351,7 +351,7 @@ pub impl BigUint {\n             n <<= 1;\n             shift += 1;\n         }\n-        assert shift < BigDigit::bits;\n+        fail_unless!(shift < BigDigit::bits);\n         let (d, m) = divmod_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n@@ -390,7 +390,7 @@ pub impl BigUint {\n             for vec::rev_each(an) |elt| {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n-                assert di < BigDigit::base;\n+                fail_unless!(di < BigDigit::base);\n                 carry = (ai % (bn as uint)) as BigDigit;\n                 d = ~[di as BigDigit] + d;\n             }\n@@ -434,7 +434,7 @@ pub impl BigUint {\n     }\n \n     pure fn to_str_radix(&self, radix: uint) -> ~str {\n-        assert 1 < radix && radix <= 16;\n+        fail_unless!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n@@ -509,7 +509,7 @@ pub impl BigUint {\n \n #[cfg(target_arch = \"x86_64\")]\n priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert 1 < radix && radix <= 16;\n+    fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n         3  => (3486784401, 20),\n@@ -534,7 +534,7 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert 1 < radix && radix <= 16;\n+    fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),\n         3  => (59049, 10),\n@@ -787,7 +787,7 @@ pub impl BigInt {\n         if ss < os { return -1; }\n         if ss > os { return  1; }\n \n-        assert ss == os;\n+        fail_unless!(ss == os);\n         match ss {\n             Zero  => 0,\n             Plus  => self.data.cmp(&other.data),\n@@ -874,7 +874,7 @@ mod biguint_tests {\n     #[test]\n     fn test_from_slice() {\n         fn check(slice: &[BigDigit], data: &[BigDigit]) {\n-            assert data == BigUint::from_slice(slice).data;\n+            fail_unless!(data == BigUint::from_slice(slice).data);\n         }\n         check(~[1], ~[1]);\n         check(~[0, 0, 0], ~[]);\n@@ -892,30 +892,30 @@ mod biguint_tests {\n             for vec::slice(data, i, data.len()).eachi |j0, nj| {\n                 let j = j0 + i;\n                 if i == j {\n-                    assert ni.cmp(nj) == 0;\n-                    assert nj.cmp(ni) == 0;\n-                    assert ni == nj;\n-                    assert !(ni != nj);\n-                    assert ni <= nj;\n-                    assert ni >= nj;\n-                    assert !(ni < nj);\n-                    assert !(ni > nj);\n+                    fail_unless!(ni.cmp(nj) == 0);\n+                    fail_unless!(nj.cmp(ni) == 0);\n+                    fail_unless!(ni == nj);\n+                    fail_unless!(!(ni != nj));\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(ni >= nj);\n+                    fail_unless!(!(ni < nj));\n+                    fail_unless!(!(ni > nj));\n                 } else {\n-                    assert ni.cmp(nj) < 0;\n-                    assert nj.cmp(ni) > 0;\n+                    fail_unless!(ni.cmp(nj) < 0);\n+                    fail_unless!(nj.cmp(ni) > 0);\n \n-                    assert !(ni == nj);\n-                    assert ni != nj;\n+                    fail_unless!(!(ni == nj));\n+                    fail_unless!(ni != nj);\n \n-                    assert ni <= nj;\n-                    assert !(ni >= nj);\n-                    assert ni < nj;\n-                    assert !(ni > nj);\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(!(ni >= nj));\n+                    fail_unless!(ni < nj);\n+                    fail_unless!(!(ni > nj));\n \n-                    assert !(nj <= ni);\n-                    assert nj >= ni;\n-                    assert !(nj < ni);\n-                    assert nj > ni;\n+                    fail_unless!(!(nj <= ni));\n+                    fail_unless!(nj >= ni);\n+                    fail_unless!(!(nj < ni));\n+                    fail_unless!(nj > ni);\n                 }\n             }\n         }\n@@ -924,7 +924,7 @@ mod biguint_tests {\n     #[test]\n     fn test_shl() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert BigUint::new(v) << shift == BigUint::new(ans);\n+            fail_unless!(BigUint::new(v) << shift == BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -969,7 +969,7 @@ mod biguint_tests {\n     #[ignore(cfg(target_arch = \"mips\"))]\n     fn test_shr() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert BigUint::new(v) >> shift == BigUint::new(ans);\n+            fail_unless!(BigUint::new(v) >> shift == BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -1011,8 +1011,8 @@ mod biguint_tests {\n     fn test_convert_int() {\n         fn check(v: ~[BigDigit], i: int) {\n             let b = BigUint::new(v);\n-            assert b == IntConvertible::from_int(i);\n-            assert b.to_int() == i;\n+            fail_unless!(b == IntConvertible::from_int(i));\n+            fail_unless!(b.to_int() == i);\n         }\n \n         check(~[], 0);\n@@ -1021,17 +1021,17 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        assert BigUint::new(~[0, -1]).to_int() == int::max_value;\n-        assert BigUint::new(~[0, 0, 1]).to_int() == int::max_value;\n-        assert BigUint::new(~[0, 0, -1]).to_int() == int::max_value;\n+        fail_unless!(BigUint::new(~[0, -1]).to_int() == int::max_value);\n+        fail_unless!(BigUint::new(~[0, 0, 1]).to_int() == int::max_value);\n+        fail_unless!(BigUint::new(~[0, 0, -1]).to_int() == int::max_value);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(v: ~[BigDigit], u: uint) {\n             let b = BigUint::new(v);\n-            assert b == BigUint::from_uint(u);\n-            assert b.to_uint() == u;\n+            fail_unless!(b == BigUint::from_uint(u));\n+            fail_unless!(b.to_uint() == u);\n         }\n \n         check(~[], 0);\n@@ -1041,8 +1041,8 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        assert BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value;\n-        assert BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value;\n+        fail_unless!(BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value);\n+        fail_unless!(BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value);\n     }\n \n     const sum_triples: &static/[(&static/[BigDigit],\n@@ -1067,8 +1067,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            assert a + b == c;\n-            assert b + a == c;\n+            fail_unless!(a + b == c);\n+            fail_unless!(b + a == c);\n         }\n     }\n \n@@ -1080,8 +1080,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            assert c - a == b;\n-            assert c - b == a;\n+            fail_unless!(c - a == b);\n+            fail_unless!(c - b == a);\n         }\n     }\n \n@@ -1131,8 +1131,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            assert a * b == c;\n-            assert b * a == c;\n+            fail_unless!(a * b == c);\n+            fail_unless!(b * a == c);\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1142,8 +1142,8 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            assert a == b * c + d;\n-            assert a == c * b + d;\n+            fail_unless!(a == b * c + d);\n+            fail_unless!(a == c * b + d);\n         }\n     }\n \n@@ -1156,10 +1156,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if a.is_not_zero() {\n-                assert c.divmod(&a) == (b, Zero::zero());\n+                fail_unless!(c.divmod(&a) == (b, Zero::zero()));\n             }\n             if b.is_not_zero() {\n-                assert c.divmod(&b) == (a, Zero::zero());\n+                fail_unless!(c.divmod(&b) == (a, Zero::zero()));\n             }\n         }\n \n@@ -1170,7 +1170,7 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if b.is_not_zero() { assert a.divmod(&b) == (c, d); }\n+            if b.is_not_zero() { fail_unless!(a.divmod(&b) == (c, d)); }\n         }\n     }\n \n@@ -1237,7 +1237,7 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert n.to_str_radix(radix) == str;\n+                fail_unless!(n.to_str_radix(radix) == str);\n             }\n         }\n     }\n@@ -1248,13 +1248,13 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert Some(n) == BigUint::from_str_radix(str, radix);\n+                fail_unless!(Some(n) == BigUint::from_str_radix(str, radix));\n             }\n         }\n \n-        assert BigUint::from_str_radix(~\"Z\", 10) == None;\n-        assert BigUint::from_str_radix(~\"_\", 2) == None;\n-        assert BigUint::from_str_radix(~\"-1\", 10) == None;\n+        fail_unless!(BigUint::from_str_radix(~\"Z\", 10) == None);\n+        fail_unless!(BigUint::from_str_radix(~\"_\", 2) == None);\n+        fail_unless!(BigUint::from_str_radix(~\"-1\", 10) == None);\n     }\n \n     #[test]\n@@ -1272,7 +1272,7 @@ mod biguint_tests {\n             let ans = match BigUint::from_str_radix(s, 10) {\n                 Some(x) => x, None => fail!()\n             };\n-            assert n == ans;\n+            fail_unless!(n == ans);\n         }\n \n         check(3, \"6\");\n@@ -1294,7 +1294,7 @@ mod bigint_tests {\n         fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n             let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n             let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n-            assert inp == ans;\n+            fail_unless!(inp == ans);\n         }\n         check(Plus, 1, Plus, 1);\n         check(Plus, 0, Zero, 0);\n@@ -1314,30 +1314,30 @@ mod bigint_tests {\n             for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n                 let j = i + j0;\n                 if i == j {\n-                    assert ni.cmp(nj) == 0;\n-                    assert nj.cmp(ni) == 0;\n-                    assert ni == nj;\n-                    assert !(ni != nj);\n-                    assert ni <= nj;\n-                    assert ni >= nj;\n-                    assert !(ni < nj);\n-                    assert !(ni > nj);\n+                    fail_unless!(ni.cmp(nj) == 0);\n+                    fail_unless!(nj.cmp(ni) == 0);\n+                    fail_unless!(ni == nj);\n+                    fail_unless!(!(ni != nj));\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(ni >= nj);\n+                    fail_unless!(!(ni < nj));\n+                    fail_unless!(!(ni > nj));\n                 } else {\n-                    assert ni.cmp(nj) < 0;\n-                    assert nj.cmp(ni) > 0;\n+                    fail_unless!(ni.cmp(nj) < 0);\n+                    fail_unless!(nj.cmp(ni) > 0);\n \n-                    assert !(ni == nj);\n-                    assert ni != nj;\n+                    fail_unless!(!(ni == nj));\n+                    fail_unless!(ni != nj);\n \n-                    assert ni <= nj;\n-                    assert !(ni >= nj);\n-                    assert ni < nj;\n-                    assert !(ni > nj);\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(!(ni >= nj));\n+                    fail_unless!(ni < nj);\n+                    fail_unless!(!(ni > nj));\n \n-                    assert !(nj <= ni);\n-                    assert nj >= ni;\n-                    assert !(nj < ni);\n-                    assert nj > ni;\n+                    fail_unless!(!(nj <= ni));\n+                    fail_unless!(nj >= ni);\n+                    fail_unless!(!(nj < ni));\n+                    fail_unless!(nj > ni);\n                 }\n             }\n         }\n@@ -1346,8 +1346,8 @@ mod bigint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check(b: BigInt, i: int) {\n-            assert b == IntConvertible::from_int(i);\n-            assert b.to_int() == i;\n+            fail_unless!(b == IntConvertible::from_int(i));\n+            fail_unless!(b.to_int() == i);\n         }\n \n         check(Zero::zero(), 0);\n@@ -1356,29 +1356,29 @@ mod bigint_tests {\n             Plus, BigUint::from_uint(int::max_value as uint)\n         ), int::max_value);\n \n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Plus, BigUint::from_uint(int::max_value as uint + 1)\n-        ).to_int() == int::max_value;\n-        assert BigInt::from_biguint(\n+        ).to_int() == int::max_value);\n+        fail_unless!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::max_value;\n+        ).to_int() == int::max_value);\n \n         check(BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint)\n         ), int::min_value);\n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint + 1)\n-        ).to_int() == int::min_value;\n-        assert BigInt::from_biguint(\n+        ).to_int() == int::min_value);\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::min_value;\n+        ).to_int() == int::min_value);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(b: BigInt, u: uint) {\n-            assert b == BigInt::from_uint(u);\n-            assert b.to_uint() == u;\n+            fail_unless!(b == BigInt::from_uint(u));\n+            fail_unless!(b.to_uint() == u);\n         }\n \n         check(Zero::zero(), 0);\n@@ -1387,16 +1387,16 @@ mod bigint_tests {\n         check(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n             uint::max_value);\n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == uint::max_value;\n+        ).to_uint() == uint::max_value);\n \n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::from_uint(uint::max_value)\n-        ).to_uint() == 0;\n-        assert BigInt::from_biguint(\n+        ).to_uint() == 0);\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == 0;\n+        ).to_uint() == 0);\n     }\n \n     const sum_triples: &static/[(&static/[BigDigit],\n@@ -1421,14 +1421,14 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            assert a + b == c;\n-            assert b + a == c;\n-            assert c + (-a) == b;\n-            assert c + (-b) == a;\n-            assert a + (-c) == (-b);\n-            assert b + (-c) == (-a);\n-            assert (-a) + (-b) == (-c);\n-            assert a + (-a) == Zero::zero();\n+            fail_unless!(a + b == c);\n+            fail_unless!(b + a == c);\n+            fail_unless!(c + (-a) == b);\n+            fail_unless!(c + (-b) == a);\n+            fail_unless!(a + (-c) == (-b));\n+            fail_unless!(b + (-c) == (-a));\n+            fail_unless!((-a) + (-b) == (-c));\n+            fail_unless!(a + (-a) == Zero::zero());\n         }\n     }\n \n@@ -1440,14 +1440,14 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            assert c - a == b;\n-            assert c - b == a;\n-            assert (-b) - a == (-c);\n-            assert (-a) - b == (-c);\n-            assert b - (-a) == c;\n-            assert a - (-b) == c;\n-            assert (-c) - (-a) == (-b);\n-            assert a - a == Zero::zero();\n+            fail_unless!(c - a == b);\n+            fail_unless!(c - b == a);\n+            fail_unless!((-b) - a == (-c));\n+            fail_unless!((-a) - b == (-c));\n+            fail_unless!(b - (-a) == c);\n+            fail_unless!(a - (-b) == c);\n+            fail_unless!((-c) - (-a) == (-b));\n+            fail_unless!(a - a == Zero::zero());\n         }\n     }\n \n@@ -1497,11 +1497,11 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            assert a * b == c;\n-            assert b * a == c;\n+            fail_unless!(a * b == c);\n+            fail_unless!(b * a == c);\n \n-            assert (-a) * b == -c;\n-            assert (-b) * a == -c;\n+            fail_unless!((-a) * b == -c);\n+            fail_unless!((-b) * a == -c);\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1511,8 +1511,8 @@ mod bigint_tests {\n             let c = BigInt::from_slice(Plus, cVec);\n             let d = BigInt::from_slice(Plus, dVec);\n \n-            assert a == b * c + d;\n-            assert a == c * b + d;\n+            fail_unless!(a == b * c + d);\n+            fail_unless!(a == c * b + d);\n         }\n     }\n \n@@ -1521,12 +1521,12 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n             let (d, m) = a.divmod(b);\n             if m.is_not_zero() {\n-                assert m.sign == b.sign;\n+                fail_unless!(m.sign == b.sign);\n             }\n-            assert m.abs() <= b.abs();\n-            assert *a == b * d + m;\n-            assert d == *ans_d;\n-            assert m == *ans_m;\n+            fail_unless!(m.abs() <= b.abs());\n+            fail_unless!(*a == b * d + m);\n+            fail_unless!(d == *ans_d);\n+            fail_unless!(m == *ans_m);\n         }\n \n         fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n@@ -1572,12 +1572,12 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n             let (q, r) = a.quotrem(b);\n             if r.is_not_zero() {\n-                assert r.sign == a.sign;\n+                fail_unless!(r.sign == a.sign);\n             }\n-            assert r.abs() <= b.abs();\n-            assert *a == b * q + r;\n-            assert q == *ans_q;\n-            assert r == *ans_r;\n+            fail_unless!(r.abs() <= b.abs());\n+            fail_unless!(*a == b * q + r);\n+            fail_unless!(q == *ans_q);\n+            fail_unless!(r == *ans_r);\n         }\n \n         fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n@@ -1612,8 +1612,8 @@ mod bigint_tests {\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert ans == IntConvertible::from_int::<BigInt>(\n-                n).to_str_radix(10);\n+            fail_unless!(ans == IntConvertible::from_int::<BigInt>(\n+                n).to_str_radix(10));\n         }\n         check(10, \"10\");\n         check(1, \"1\");\n@@ -1627,7 +1627,7 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n             let ans = ans.map(|&n| IntConvertible::from_int(n));\n-            assert BigInt::from_str_radix(s, 10) == ans;\n+            fail_unless!(BigInt::from_str_radix(s, 10) == ans);\n         }\n         check(\"10\", Some(10));\n         check(\"1\", Some(1));\n@@ -1640,11 +1640,11 @@ mod bigint_tests {\n \n     #[test]\n     fn test_neg() {\n-        assert -BigInt::new(Plus,  ~[1, 1, 1]) ==\n-            BigInt::new(Minus, ~[1, 1, 1]);\n-        assert -BigInt::new(Minus, ~[1, 1, 1]) ==\n-            BigInt::new(Plus,  ~[1, 1, 1]);\n-        assert -Zero::zero::<BigInt>() == Zero::zero::<BigInt>();\n+        fail_unless!(-BigInt::new(Plus,  ~[1, 1, 1]) ==\n+            BigInt::new(Minus, ~[1, 1, 1]));\n+        fail_unless!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n+            BigInt::new(Plus,  ~[1, 1, 1]));\n+        fail_unless!(-Zero::zero::<BigInt>() == Zero::zero::<BigInt>());\n     }\n }\n "}, {"sha": "55ec29d2337ca6439ecd7d2da5c5c9d7a6a8f4d8", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 115, "deletions": 114, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -132,7 +132,7 @@ pub impl BigBitv {\n     fn process(&mut self, b: &BigBitv, nbits: uint,\n                op: fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n-        assert (self.storage.len() == len);\n+        fail_unless!((self.storage.len() == len));\n         let mut changed = false;\n         for uint::range(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -300,7 +300,7 @@ pub impl Bitv {\n     /// Retrieve the value at index `i`\n     #[inline(always)]\n     pure fn get(&self, i: uint) -> bool {\n-       assert (i < self.nbits);\n+       fail_unless!((i < self.nbits));\n        match self.rep {\n          Big(ref b)   => b.get(i),\n          Small(ref s) => s.get(i)\n@@ -314,7 +314,7 @@ pub impl Bitv {\n      */\n     #[inline(always)]\n     fn set(&mut self, i: uint, x: bool) {\n-      assert (i < self.nbits);\n+      fail_unless!((i < self.nbits));\n       match self.rep {\n         Big(ref mut b)   => b.set(i, x),\n         Small(ref mut s) => s.set(i, x)\n@@ -482,7 +482,7 @@ pub impl Bitv {\n      * the bitvector and vector must have the same length\n      */\n     fn eq_vec(&self, v: ~[uint]) -> bool {\n-        assert self.nbits == v.len();\n+        fail_unless!(self.nbits == v.len());\n         let mut i = 0;\n         while i < self.nbits {\n             let w0 = self.get(i);\n@@ -723,7 +723,7 @@ impl Set<uint> for BitvSet {\n         let nbits = self.capacity();\n         if value >= nbits {\n             let newsize = uint::max(value, nbits * 2) / uint::bits + 1;\n-            assert newsize > self.bitv.storage.len();\n+            fail_unless!(newsize > self.bitv.storage.len());\n             self.bitv.storage.grow(newsize, &0);\n         }\n         self.size += 1;\n@@ -882,10 +882,10 @@ mod tests {\n     #[test]\n     pub fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n-        assert zerolen.to_str() == ~\"\";\n+        fail_unless!(zerolen.to_str() == ~\"\");\n \n         let eightbits = Bitv::new(8u, false);\n-        assert eightbits.to_str() == ~\"00000000\";\n+        fail_unless!(eightbits.to_str() == ~\"00000000\");\n     }\n \n     #[test]\n@@ -894,24 +894,24 @@ mod tests {\n         let mut exp;\n         act = Bitv::new(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n-        assert act.eq_vec(exp);\n+        fail_unless!(act.eq_vec(exp));\n     }\n \n     #[test]\n     pub fn test_1_element() {\n         let mut act;\n         act = Bitv::new(1u, false);\n-        assert act.eq_vec(~[0u]);\n+        fail_unless!(act.eq_vec(~[0u]));\n         act = Bitv::new(1u, true);\n-        assert act.eq_vec(~[1u]);\n+        fail_unless!(act.eq_vec(~[1u]));\n     }\n \n     #[test]\n     pub fn test_2_elements() {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert b.to_str() == ~\"10\";\n+        fail_unless!(b.to_str() == ~\"10\");\n     }\n \n     #[test]\n@@ -920,11 +920,11 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(10u, false);\n-        assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        fail_unless!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u])));\n         // all 1\n \n         act = Bitv::new(10u, true);\n-        assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+        fail_unless!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n@@ -933,7 +933,7 @@ mod tests {\n         act.set(2u, true);\n         act.set(3u, true);\n         act.set(4u, true);\n-        assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n+        fail_unless!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n@@ -942,15 +942,15 @@ mod tests {\n         act.set(7u, true);\n         act.set(8u, true);\n         act.set(9u, true);\n-        assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n+        fail_unless!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n         act.set(9u, true);\n-        assert (act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n+        fail_unless!((act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u])));\n     }\n \n     #[test]\n@@ -959,14 +959,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(31u, false);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n@@ -981,7 +981,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n@@ -996,7 +996,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n@@ -1010,7 +1010,7 @@ mod tests {\n         act.set(28u, true);\n         act.set(29u, true);\n         act.set(30u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n@@ -1020,7 +1020,7 @@ mod tests {\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u]));\n@@ -1032,14 +1032,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(32u, false);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(32u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1054,7 +1054,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1069,7 +1069,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1084,7 +1084,7 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1095,7 +1095,7 @@ mod tests {\n         act.set(17u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u]));\n@@ -1107,14 +1107,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(33u, false);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(33u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1129,7 +1129,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1144,7 +1144,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1159,7 +1159,7 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n@@ -1171,7 +1171,7 @@ mod tests {\n         act.set(30u, true);\n         act.set(31u, true);\n         act.set(32u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n@@ -1181,14 +1181,14 @@ mod tests {\n     pub fn test_equal_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(11u, false);\n-        assert !v0.equal(&v1);\n+        fail_unless!(!v0.equal(&v1));\n     }\n \n     #[test]\n     pub fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(110u, false);\n-        assert !v0.equal(&v1);\n+        fail_unless!(!v0.equal(&v1));\n     }\n \n     #[test]\n@@ -1199,7 +1199,7 @@ mod tests {\n         let mut b = bitv::Bitv::new(1, true);\n         b.set(0, true);\n \n-        assert a.equal(&b);\n+        fail_unless!(a.equal(&b));\n     }\n \n     #[test]\n@@ -1214,37 +1214,38 @@ mod tests {\n             b.set(i, true);\n         }\n \n-        assert a.equal(&b);\n+        fail_unless!(a.equal(&b));\n     }\n \n     #[test]\n     pub fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n-        assert bitv.to_str() == str;\n+        fail_unless!(bitv.to_str() == str);\n     }\n \n     #[test]\n     pub fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n-        assert bv.to_bytes() == ~[0b10100000];\n+        fail_unless!(bv.to_bytes() == ~[0b10100000]);\n \n         let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        assert bv.to_bytes() == ~[0b00100000, 0b10000000];\n+        fail_unless!(bv.to_bytes() == ~[0b00100000, 0b10000000]);\n     }\n \n     #[test]\n     pub fn test_from_bools() {\n-        assert from_bools([true, false, true, true]).to_str() == ~\"1011\";\n+        fail_unless!(from_bools([true, false, true, true]).to_str() ==\n+            ~\"1011\");\n     }\n \n     #[test]\n     pub fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n-        assert from_bytes([0b00100110]).to_bools() == bools;\n+        fail_unless!(from_bytes([0b00100110]).to_bools() == bools);\n     }\n \n     #[test]\n@@ -1255,10 +1256,10 @@ mod tests {\n         b1.set(1, true);\n         b2.set(1, true);\n         b2.set(2, true);\n-        assert b1.difference(&b2);\n-        assert b1[0];\n-        assert !b1[1];\n-        assert !b1[2];\n+        fail_unless!(b1.difference(&b2));\n+        fail_unless!(b1[0]);\n+        fail_unless!(!b1[1]);\n+        fail_unless!(!b1[2]);\n     }\n \n     #[test]\n@@ -1269,10 +1270,10 @@ mod tests {\n         b1.set(40, true);\n         b2.set(40, true);\n         b2.set(80, true);\n-        assert b1.difference(&b2);\n-        assert b1[0];\n-        assert !b1[40];\n-        assert !b1[80];\n+        fail_unless!(b1.difference(&b2));\n+        fail_unless!(b1[0]);\n+        fail_unless!(!b1[40]);\n+        fail_unless!(!b1[80]);\n     }\n \n     #[test]\n@@ -1296,131 +1297,131 @@ mod tests {\n     #[test]\n     pub fn test_bitv_set_basic() {\n         let mut b = BitvSet::new();\n-        assert b.insert(3);\n-        assert !b.insert(3);\n-        assert b.contains(&3);\n-        assert b.insert(400);\n-        assert !b.insert(400);\n-        assert b.contains(&400);\n-        assert b.len() == 2;\n+        fail_unless!(b.insert(3));\n+        fail_unless!(!b.insert(3));\n+        fail_unless!(b.contains(&3));\n+        fail_unless!(b.insert(400));\n+        fail_unless!(!b.insert(400));\n+        fail_unless!(b.contains(&400));\n+        fail_unless!(b.len() == 2);\n     }\n \n     #[test]\n     fn test_bitv_set_intersection() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        assert a.insert(11);\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(77);\n-        assert a.insert(103);\n-        assert a.insert(5);\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(77));\n+        fail_unless!(a.insert(103));\n+        fail_unless!(a.insert(5));\n \n-        assert b.insert(2);\n-        assert b.insert(11);\n-        assert b.insert(77);\n-        assert b.insert(5);\n-        assert b.insert(3);\n+        fail_unless!(b.insert(2));\n+        fail_unless!(b.insert(11));\n+        fail_unless!(b.insert(77));\n+        fail_unless!(b.insert(5));\n+        fail_unless!(b.insert(3));\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_bitv_set_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(200);\n-        assert a.insert(500);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(200));\n+        fail_unless!(a.insert(500));\n \n-        assert b.insert(3);\n-        assert b.insert(200);\n+        fail_unless!(b.insert(3));\n+        fail_unless!(b.insert(200));\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n         for a.difference(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_bitv_set_symmetric_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n \n-        assert b.insert(3);\n-        assert b.insert(9);\n-        assert b.insert(14);\n-        assert b.insert(220);\n+        fail_unless!(b.insert(3));\n+        fail_unless!(b.insert(9));\n+        fail_unless!(b.insert(14));\n+        fail_unless!(b.insert(220));\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n         for a.symmetric_difference(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     pub fn test_bitv_set_union() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n-        assert a.insert(160);\n-        assert a.insert(19);\n-        assert a.insert(24);\n-\n-        assert b.insert(1);\n-        assert b.insert(5);\n-        assert b.insert(9);\n-        assert b.insert(13);\n-        assert b.insert(19);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(160));\n+        fail_unless!(a.insert(19));\n+        fail_unless!(a.insert(24));\n+\n+        fail_unless!(b.insert(1));\n+        fail_unless!(b.insert(5));\n+        fail_unless!(b.insert(9));\n+        fail_unless!(b.insert(13));\n+        fail_unless!(b.insert(19));\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n         for a.union(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     pub fn test_bitv_remove() {\n         let mut a = BitvSet::new();\n \n-        assert a.insert(1);\n-        assert a.remove(&1);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.remove(&1));\n \n-        assert a.insert(100);\n-        assert a.remove(&100);\n+        fail_unless!(a.insert(100));\n+        fail_unless!(a.remove(&100));\n \n-        assert a.insert(1000);\n-        assert a.remove(&1000);\n-        assert a.capacity() == uint::bits;\n+        fail_unless!(a.insert(1000));\n+        fail_unless!(a.remove(&1000));\n+        fail_unless!(a.capacity() == uint::bits);\n     }\n \n     fn rng() -> rand::Rng {"}, {"sha": "8e75f694fa3d4698adab5e959945fa9215fbd632", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -119,7 +119,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n-    assert ofs < len(t);\n+    fail_unless!(ofs < len(t));\n     return unsafe { *ptr::mut_offset(t.base, ofs) };\n }\n \n@@ -129,7 +129,7 @@ pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n-    assert ofs < len(t);\n+    fail_unless!(ofs < len(t));\n     unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }\n \n@@ -156,7 +156,7 @@ mod tests {\n         unsafe {\n             let mem = libc::malloc(n);\n \n-            assert mem as int != 0;\n+            fail_unless!(mem as int != 0);\n \n             return unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n                                          || unsafe { free(mem) }) };\n@@ -169,9 +169,9 @@ mod tests {\n \n         set(cv, 3u, 8u8);\n         set(cv, 4u, 9u8);\n-        assert get(cv, 3u) == 8u8;\n-        assert get(cv, 4u) == 9u8;\n-        assert len(cv) == 16u;\n+        fail_unless!(get(cv, 3u) == 8u8);\n+        fail_unless!(get(cv, 4u) == 9u8);\n+        fail_unless!(len(cv) == 16u);\n     }\n \n     #[test]\n@@ -199,7 +199,7 @@ mod tests {\n \n         set(cv, 0u, 32u8);\n         set(cv, 1u, 33u8);\n-        assert unsafe { *p } == 32u8;\n+        fail_unless!(unsafe { *p } == 32u8);\n         set(cv, 2u, 34u8); /* safety */\n     }\n "}, {"sha": "b6362f83f4426386088612a02259594db7d720f3", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -53,15 +53,15 @@ impl FuzzyEq<f64> for f64 {\n \n #[test]\n fn test_fuzzy_equals() {\n-    assert (&1.0f).fuzzy_eq(&1.0);\n-    assert (&1.0f32).fuzzy_eq(&1.0f32);\n-    assert (&1.0f64).fuzzy_eq(&1.0f64);\n+    fail_unless!((&1.0f).fuzzy_eq(&1.0));\n+    fail_unless!((&1.0f32).fuzzy_eq(&1.0f32));\n+    fail_unless!((&1.0f64).fuzzy_eq(&1.0f64));\n }\n \n #[test]\n fn test_fuzzy_eq_eps() {\n-    assert (&1.2f).fuzzy_eq_eps(&0.9, &0.5);\n-    assert !(&1.5f).fuzzy_eq_eps(&0.9, &0.5);\n+    fail_unless!((&1.2f).fuzzy_eq_eps(&0.9, &0.5));\n+    fail_unless!(!(&1.5f).fuzzy_eq_eps(&0.9, &0.5));\n }\n \n #[test]\n@@ -87,16 +87,16 @@ mod test_complex{\n         let a = Complex {r: 0.9, i: 0.9};\n         let b = Complex {r: 0.9, i: 0.9};\n \n-        assert (a.fuzzy_eq(&b));\n+        fail_unless!((a.fuzzy_eq(&b)));\n     }\n \n     #[test]\n     fn test_fuzzy_eq_eps() {\n         let other = Complex {r: 0.9, i: 0.9};\n \n-        assert (&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5);\n-        assert (&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5);\n-        assert !(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5);\n-        assert !(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5);\n+        fail_unless!((&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5));\n+        fail_unless!((&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n+        fail_unless!(!(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5));\n+        fail_unless!(!(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n     }\n }"}, {"sha": "99f6fa4c8cf59124b5c292bd471929d5b0fe48c5", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -107,7 +107,7 @@ mod test {\n         left.send(~\"abc\");\n         right.send(123);\n \n-        assert left.recv() == 123;\n-        assert right.recv() == ~\"abc\";\n+        fail_unless!(left.recv() == 123);\n+        fail_unless!(right.recv() == ~\"abc\");\n     }\n }"}, {"sha": "9a9c19ca1768ccca601c4912daff46de7b900206", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -14,15 +14,19 @@ use core::cast::reinterpret_cast;\n use core::ptr;\n use core::sys;\n \n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    pub unsafe fn debug_tydesc(td: *sys::TypeDesc);\n-    pub unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n-    pub unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n-    pub unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n-    pub unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n-    pub unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n-    pub unsafe fn rust_dbg_breakpoint();\n+pub mod rustrt {\n+    use core::sys;\n+\n+    #[abi = \"cdecl\"]\n+    pub extern {\n+        pub unsafe fn debug_tydesc(td: *sys::TypeDesc);\n+        pub unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n+        pub unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n+        pub unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n+        pub unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n+        pub unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n+        pub unsafe fn rust_dbg_breakpoint();\n+    }\n }\n \n pub fn debug_tydesc<T>() {"}, {"sha": "33b0fd4eb6819c8db025443280bbf56d3f2ce6da", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -95,7 +95,7 @@ pub impl<T> Deque<T> {\n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n-    assert nelts == elts.len();\n+    fail_unless!(nelts == elts.len());\n     let mut rv = ~[];\n \n     do rv.grow_fn(nelts + 1) |i| {\n@@ -121,46 +121,46 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let mut d = Deque::new();\n-        assert d.len() == 0u;\n+        fail_unless!(d.len() == 0u);\n         d.add_front(17);\n         d.add_front(42);\n         d.add_back(137);\n-        assert d.len() == 3u;\n+        fail_unless!(d.len() == 3u);\n         d.add_back(137);\n-        assert d.len() == 4u;\n+        fail_unless!(d.len() == 4u);\n         log(debug, d.peek_front());\n-        assert *d.peek_front() == 42;\n+        fail_unless!(*d.peek_front() == 42);\n         log(debug, d.peek_back());\n-        assert *d.peek_back() == 137;\n+        fail_unless!(*d.peek_back() == 137);\n         let mut i: int = d.pop_front();\n         log(debug, i);\n-        assert i == 42;\n+        fail_unless!(i == 42);\n         i = d.pop_back();\n         log(debug, i);\n-        assert i == 137;\n+        fail_unless!(i == 137);\n         i = d.pop_back();\n         log(debug, i);\n-        assert i == 137;\n+        fail_unless!(i == 137);\n         i = d.pop_back();\n         log(debug, i);\n-        assert i == 17;\n-        assert d.len() == 0u;\n+        fail_unless!(i == 17);\n+        fail_unless!(d.len() == 0u);\n         d.add_back(3);\n-        assert d.len() == 1u;\n+        fail_unless!(d.len() == 1u);\n         d.add_front(2);\n-        assert d.len() == 2u;\n+        fail_unless!(d.len() == 2u);\n         d.add_back(4);\n-        assert d.len() == 3u;\n+        fail_unless!(d.len() == 3u);\n         d.add_front(1);\n-        assert d.len() == 4u;\n+        fail_unless!(d.len() == 4u);\n         log(debug, d.get(0));\n         log(debug, d.get(1));\n         log(debug, d.get(2));\n         log(debug, d.get(3));\n-        assert *d.get(0) == 1;\n-        assert *d.get(1) == 2;\n-        assert *d.get(2) == 3;\n-        assert *d.get(3) == 4;\n+        fail_unless!(*d.get(0) == 1);\n+        fail_unless!(*d.get(1) == 2);\n+        fail_unless!(*d.get(2) == 3);\n+        fail_unless!(*d.get(3) == 4);\n     }\n \n     #[test]\n@@ -171,62 +171,62 @@ mod tests {\n         let d: @int = @175;\n \n         let mut deq = Deque::new();\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_back(d);\n-        assert deq.len() == 4;\n-        assert *deq.peek_front() == b;\n-        assert *deq.peek_back() == d;\n-        assert deq.pop_front() == b;\n-        assert deq.pop_back() == d;\n-        assert deq.pop_back() == c;\n-        assert deq.pop_back() == a;\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.peek_front() == b);\n+        fail_unless!(*deq.peek_back() == d);\n+        fail_unless!(deq.pop_front() == b);\n+        fail_unless!(deq.pop_back() == d);\n+        fail_unless!(deq.pop_back() == c);\n+        fail_unless!(deq.pop_back() == a);\n+        fail_unless!(deq.len() == 0);\n         deq.add_back(c);\n-        assert deq.len() == 1;\n+        fail_unless!(deq.len() == 1);\n         deq.add_front(b);\n-        assert deq.len() == 2;\n+        fail_unless!(deq.len() == 2);\n         deq.add_back(d);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_front(a);\n-        assert deq.len() == 4;\n-        assert *deq.get(0) == a;\n-        assert *deq.get(1) == b;\n-        assert *deq.get(2) == c;\n-        assert *deq.get(3) == d;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.get(0) == a);\n+        fail_unless!(*deq.get(1) == b);\n+        fail_unless!(*deq.get(2) == c);\n+        fail_unless!(*deq.get(3) == d);\n     }\n \n     fn test_parameterized<T:Copy + Eq + Durable>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_back(d);\n-        assert deq.len() == 4;\n-        assert *deq.peek_front() == b;\n-        assert *deq.peek_back() == d;\n-        assert deq.pop_front() == b;\n-        assert deq.pop_back() == d;\n-        assert deq.pop_back() == c;\n-        assert deq.pop_back() == a;\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.peek_front() == b);\n+        fail_unless!(*deq.peek_back() == d);\n+        fail_unless!(deq.pop_front() == b);\n+        fail_unless!(deq.pop_back() == d);\n+        fail_unless!(deq.pop_back() == c);\n+        fail_unless!(deq.pop_back() == a);\n+        fail_unless!(deq.len() == 0);\n         deq.add_back(c);\n-        assert deq.len() == 1;\n+        fail_unless!(deq.len() == 1);\n         deq.add_front(b);\n-        assert deq.len() == 2;\n+        fail_unless!(deq.len() == 2);\n         deq.add_back(d);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_front(a);\n-        assert deq.len() == 4;\n-        assert *deq.get(0) == a;\n-        assert *deq.get(1) == b;\n-        assert *deq.get(2) == c;\n-        assert *deq.get(3) == d;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.get(0) == a);\n+        fail_unless!(*deq.get(1) == b);\n+        fail_unless!(*deq.get(2) == c);\n+        fail_unless!(*deq.get(3) == d);\n     }\n \n     #[deriving_eq]"}, {"sha": "44461ae06fff401908bb3e16f3a6aa22e8c7db15", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -182,22 +182,22 @@ pub mod reader {\n     pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert d.end == d.start + 1u;\n+        fail_unless!(d.end == d.start + 1u);\n         (*d.data)[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert d.end == d.start + 2u;\n+        fail_unless!(d.end == d.start + 2u);\n         io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert d.end == d.start + 4u;\n+        fail_unless!(d.end == d.start + 4u);\n         io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert d.end == d.start + 8u;\n+        fail_unless!(d.end == d.start + 8u);\n         io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n@@ -550,7 +550,7 @@ pub mod writer {\n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n-            assert v <= 0xFFFF_FFFF_u;\n+            fail_unless!(v <= 0xFFFF_FFFF_u);\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n \n@@ -694,7 +694,7 @@ mod tests {\n             let deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&deser);\n             debug!(\"v1 == %?\", v1);\n-            assert v == v1;\n+            fail_unless!(v == v1);\n         }\n \n         test_v(Some(22));"}, {"sha": "734e6e835815c29377eee549eff4cc4039d1334a", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -358,8 +358,8 @@ pub mod flatteners {\n \n     impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n-            assert size_of::<T>() != 0;\n-            assert size_of::<T>() == buf.len();\n+            fail_unless!(size_of::<T>() != 0);\n+            fail_unless!(size_of::<T>() == buf.len());\n             let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n             let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n             copy *addr_of_value\n@@ -368,7 +368,7 @@ pub mod flatteners {\n \n     impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n-            assert size_of::<T>() != 0;\n+            fail_unless!(size_of::<T>() != 0);\n             let val: *T = ptr::to_unsafe_ptr(&val);\n             let byte_value = val as *u8;\n             unsafe { vec::from_buf(byte_value, size_of::<T>()) }\n@@ -521,11 +521,11 @@ pub mod bytepipes {\n             let mut left = count;\n             let mut bytes = ~[];\n             while !self.reader.eof() && left > 0 {\n-                assert left <= count;\n-                assert left > 0;\n+                fail_unless!(left <= count);\n+                fail_unless!(left > 0);\n                 let new_bytes = self.reader.read_bytes(left);\n                 bytes.push_all(new_bytes);\n-                assert new_bytes.len() <= left;\n+                fail_unless!(new_bytes.len() <= left);\n                 left -= new_bytes.len();\n             }\n \n@@ -578,7 +578,7 @@ pub mod bytepipes {\n                 return Some(bytes);\n             } else if self.buf.len() > 0 {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                assert count > bytes.len();\n+                fail_unless!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n                     Some(rest) => {\n                         bytes.push_all(rest);\n@@ -589,7 +589,7 @@ pub mod bytepipes {\n             } else if self.buf.is_empty() {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n-                        assert !buf.is_empty();\n+                        fail_unless!(!buf.is_empty());\n                         self.buf = buf;\n                         return self.try_recv(count);\n                     }\n@@ -657,7 +657,7 @@ mod test {\n         let port = serial::reader_port(reader);\n \n         let res: int = port.recv();\n-        assert res == 10i;\n+        fail_unless!(res == 10i);\n     }\n \n     #[test]\n@@ -671,7 +671,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            assert i == port.recv()\n+            fail_unless!(i == port.recv())\n         }\n     }\n \n@@ -686,7 +686,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            assert @i == port.recv()\n+            fail_unless!(@i == port.recv())\n         }\n     }\n \n@@ -703,7 +703,7 @@ mod test {\n         let port = pod::reader_port(reader);\n \n         let res: int = port.recv();\n-        assert res == 10;\n+        fail_unless!(res == 10);\n     }\n \n     #[test]\n@@ -717,7 +717,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            assert i == port.recv()\n+            fail_unless!(i == port.recv())\n         }\n     }\n \n@@ -801,7 +801,7 @@ mod test {\n                 kill_ch.send(None)\n             };\n \n-            assert listen_res.is_ok();\n+            fail_unless!(listen_res.is_ok());\n         }\n \n         // Client task\n@@ -814,7 +814,7 @@ mod test {\n             debug!(\"connecting\");\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n-            assert connect_result.is_ok();\n+            fail_unless!(connect_result.is_ok());\n             let sock = result::unwrap(connect_result);\n             let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n@@ -835,7 +835,7 @@ mod test {\n             debug!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n             debug!(\"accepted\");\n-            assert accept_result.is_ok();\n+            fail_unless!(accept_result.is_ok());\n             let sock = result::unwrap(accept_result);\n             res_chan.send(());\n \n@@ -847,7 +847,7 @@ mod test {\n             for int::range(0, 10) |i| {\n                 let j = port.recv();\n                 debug!(\"receieved %?\", j);\n-                assert i == j;\n+                fail_unless!(i == j);\n             }\n \n             // The test is over!\n@@ -893,7 +893,7 @@ mod test {\n             let bytes = ~[];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            assert res.is_none();\n+            fail_unless!(res.is_none());\n         }\n \n         #[test]\n@@ -910,7 +910,7 @@ mod test {\n             let bytes = ~[0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            assert res.is_none();\n+            fail_unless!(res.is_none());\n         }\n \n         #[test]\n@@ -928,7 +928,7 @@ mod test {\n             let bytes = CONTINUE.to_vec() + ~[0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            assert res.is_none();\n+            fail_unless!(res.is_none());\n         }\n \n         #[test]\n@@ -941,7 +941,7 @@ mod test {\n         }\n \n         fn test_try_recv_none4<P:BytePort>(+loader: PortLoader<P>) {\n-            assert do task::try || {\n+            fail_unless!(do task::try || {\n                 const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,\n                 // then undeserializable garbage\n@@ -954,7 +954,7 @@ mod test {\n                 let port = loader(bytes);\n \n                 let _res: Option<int> = port.try_recv();\n-            }.is_err();\n+            }.is_err());\n         }\n \n         #[test]"}, {"sha": "5dc264cb8784b8360087e0a86434808af315f541", "filename": "src/libstd/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -154,39 +154,39 @@ pub mod test {\n     #[test]\n     pub fn test_from_value() {\n         let f = from_value(~\"snail\");\n-        assert f.get() == ~\"snail\";\n+        fail_unless!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n     pub fn test_from_port() {\n         let (ch, po) = oneshot::init();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n-        assert f.get() == ~\"whale\";\n+        fail_unless!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n     pub fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n-        assert f.get() == ~\"brail\";\n+        fail_unless!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n     pub fn test_interface_get() {\n         let f = from_value(~\"fail\");\n-        assert f.get() == ~\"fail\";\n+        fail_unless!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let f = from_value(22);\n-        assert *f.get_ref() == 22;\n+        fail_unless!(*f.get_ref() == 22);\n     }\n \n     #[test]\n     pub fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n-        assert f.get() == ~\"bale\";\n+        fail_unless!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n@@ -203,7 +203,7 @@ pub mod test {\n         let f = do spawn { copy expected };\n         do task::spawn || {\n             let actual = f.get();\n-            assert actual == expected;\n+            fail_unless!(actual == expected);\n         }\n     }\n }"}, {"sha": "2090a3728db52c8d953f654a55e37c2e7f3f774d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -480,7 +480,7 @@ pub mod groups {\n     pub fn reqopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup { short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -493,7 +493,7 @@ pub mod groups {\n     pub fn optopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -506,7 +506,7 @@ pub mod groups {\n     pub fn optflag(short_name: &str, long_name: &str,\n                    desc: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: ~\"\",\n@@ -519,7 +519,7 @@ pub mod groups {\n     pub fn optflagopt(short_name: &str, long_name: &str,\n                       desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -535,7 +535,7 @@ pub mod groups {\n     pub fn optmulti(short_name: &str, long_name: &str,\n                     desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -647,11 +647,11 @@ mod tests {\n \n     pub fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n-          ArgumentMissing(_) => assert ft == ArgumentMissing_,\n-          UnrecognizedOption(_) => assert ft == UnrecognizedOption_,\n-          OptionMissing(_) => assert ft == OptionMissing_,\n-          OptionDuplicated(_) => assert ft == OptionDuplicated_,\n-          UnexpectedArgument(_) => assert ft == UnexpectedArgument_\n+          ArgumentMissing(_) => fail_unless!(ft == ArgumentMissing_),\n+          UnrecognizedOption(_) => fail_unless!(ft == UnrecognizedOption_),\n+          OptionMissing(_) => fail_unless!(ft == OptionMissing_),\n+          OptionDuplicated(_) => fail_unless!(ft == OptionDuplicated_),\n+          UnexpectedArgument(_) => fail_unless!(ft == UnexpectedArgument_)\n         }\n     }\n \n@@ -664,8 +664,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"test\")));\n+            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => { fail!(~\"test_reqopt_long failed\"); }\n         }\n@@ -711,8 +711,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -760,8 +760,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"test\")));\n+            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -773,7 +773,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -807,8 +807,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -820,7 +820,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -855,7 +855,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -866,7 +866,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -902,7 +902,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -913,7 +913,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -927,7 +927,7 @@ mod tests {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert (m.free[0] == ~\"20\");\n+            fail_unless!((m.free[0] == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -952,7 +952,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"v\") == 1);\n+            fail_unless!((opt_count(m, ~\"v\") == 1));\n           }\n           _ => fail!()\n         }\n@@ -965,7 +965,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"v\") == 2);\n+            fail_unless!((opt_count(m, ~\"v\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -978,7 +978,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"v\") == 2);\n+            fail_unless!((opt_count(m, ~\"v\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -991,7 +991,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"verbose\") == 1);\n+            fail_unless!((opt_count(m, ~\"verbose\") == 1));\n           }\n           _ => fail!()\n         }\n@@ -1004,7 +1004,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"verbose\") == 2);\n+            fail_unless!((opt_count(m, ~\"verbose\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -1018,8 +1018,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"test\")));\n+            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -1031,7 +1031,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -1054,11 +1054,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert (opt_present(m, ~\"test\"));\n-              assert (opt_str(m, ~\"test\") == ~\"20\");\n+              fail_unless!((opt_present(m, ~\"test\")));\n+              fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n               let pair = opt_strs(m, ~\"test\");\n-              assert (pair[0] == ~\"20\");\n-              assert (pair[1] == ~\"30\");\n+              fail_unless!((pair[0] == ~\"20\"));\n+              fail_unless!((pair[1] == ~\"30\"));\n           }\n           _ => fail!()\n         }\n@@ -1071,8 +1071,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -1084,7 +1084,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1107,11 +1107,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n             let pair = opt_strs(m, ~\"t\");\n-            assert (pair[0] == ~\"20\");\n-            assert (pair[1] == ~\"30\");\n+            fail_unless!((pair[0] == ~\"20\"));\n+            fail_unless!((pair[1] == ~\"30\"));\n           }\n           _ => fail!()\n         }\n@@ -1152,20 +1152,20 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (m.free[0] == ~\"prog\");\n-            assert (m.free[1] == ~\"free1\");\n-            assert (opt_str(m, ~\"s\") == ~\"20\");\n-            assert (m.free[2] == ~\"free2\");\n-            assert (opt_present(m, ~\"flag\"));\n-            assert (opt_str(m, ~\"long\") == ~\"30\");\n-            assert (opt_present(m, ~\"f\"));\n+            fail_unless!((m.free[0] == ~\"prog\"));\n+            fail_unless!((m.free[1] == ~\"free1\"));\n+            fail_unless!((opt_str(m, ~\"s\") == ~\"20\"));\n+            fail_unless!((m.free[2] == ~\"free2\"));\n+            fail_unless!((opt_present(m, ~\"flag\")));\n+            fail_unless!((opt_str(m, ~\"long\") == ~\"30\"));\n+            fail_unless!((opt_present(m, ~\"f\")));\n             let pair = opt_strs(m, ~\"m\");\n-            assert (pair[0] == ~\"40\");\n-            assert (pair[1] == ~\"50\");\n+            fail_unless!((pair[0] == ~\"40\"));\n+            fail_unless!((pair[1] == ~\"50\"));\n             let pair = opt_strs(m, ~\"n\");\n-            assert (pair[0] == ~\"-A B\");\n-            assert (pair[1] == ~\"-60 70\");\n-            assert (!opt_present(m, ~\"notpresent\"));\n+            fail_unless!((pair[0] == ~\"-A B\"));\n+            fail_unless!((pair[1] == ~\"-60 70\"));\n+            fail_unless!((!opt_present(m, ~\"notpresent\")));\n           }\n           _ => fail!()\n         }\n@@ -1179,17 +1179,17 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert opts_present(matches, ~[~\"e\"]);\n-        assert opts_present(matches, ~[~\"encrypt\"]);\n-        assert opts_present(matches, ~[~\"encrypt\", ~\"e\"]);\n-        assert opts_present(matches, ~[~\"e\", ~\"encrypt\"]);\n-        assert !opts_present(matches, ~[~\"thing\"]);\n-        assert !opts_present(matches, ~[]);\n+        fail_unless!(opts_present(matches, ~[~\"e\"]));\n+        fail_unless!(opts_present(matches, ~[~\"encrypt\"]));\n+        fail_unless!(opts_present(matches, ~[~\"encrypt\", ~\"e\"]));\n+        fail_unless!(opts_present(matches, ~[~\"e\", ~\"encrypt\"]));\n+        fail_unless!(!opts_present(matches, ~[~\"thing\"]));\n+        fail_unless!(!opts_present(matches, ~[]));\n \n-        assert opts_str(matches, ~[~\"e\"]) == ~\"foo\";\n-        assert opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\";\n-        assert opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\";\n-        assert opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\";\n+        fail_unless!(opts_str(matches, ~[~\"e\"]) == ~\"foo\");\n+        fail_unless!(opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\");\n+        fail_unless!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\");\n+        fail_unless!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\");\n     }\n \n     #[test]\n@@ -1200,68 +1200,68 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert opts_present(matches, ~[~\"L\"]);\n-        assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";\n-        assert opts_present(matches, ~[~\"M\"]);\n-        assert opts_str(matches, ~[~\"M\"]) == ~\".\";\n+        fail_unless!(opts_present(matches, ~[~\"L\"]));\n+        fail_unless!(opts_str(matches, ~[~\"L\"]) == ~\"foo\");\n+        fail_unless!(opts_present(matches, ~[~\"M\"]));\n+        fail_unless!(opts_str(matches, ~[~\"M\"]) == ~\".\");\n \n     }\n \n     #[test]\n     pub fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"b\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some bananas\",\n                         hasarg: Yes,\n-                        occur: Req }\n+                        occur: Req })\n     }\n \n     #[test]\n     pub fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"a\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some apples\",\n                         hasarg: Yes,\n-                        occur: Optional }\n+                        occur: Optional })\n     }\n \n     #[test]\n     pub fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n-        assert opt == OptGroup { short_name: ~\"k\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n                         desc: ~\"some kiwis\",\n                         hasarg: No,\n-                        occur: Optional }\n+                        occur: Optional })\n     }\n \n     #[test]\n     pub fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"p\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some pineapples\",\n                         hasarg: Maybe,\n-                        occur: Optional }\n+                        occur: Optional })\n     }\n \n     #[test]\n     pub fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"l\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some limes\",\n                         hasarg: Yes,\n-                        occur: Multi }\n+                        occur: Multi })\n     }\n \n     #[test]\n@@ -1270,7 +1270,7 @@ mod tests {\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n \n-        assert groups::long_to_short(&verbose) == short;\n+        fail_unless!(groups::long_to_short(&verbose) == short);\n     }\n \n     #[test]\n@@ -1295,8 +1295,8 @@ mod tests {\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         // FIXME #4681: sort options here?\n-        assert getopts(sample_args, short)\n-            == groups::getopts(sample_args, verbose);\n+        fail_unless!(getopts(sample_args, short)\n+            == groups::getopts(sample_args, verbose));\n     }\n \n     #[test]\n@@ -1327,7 +1327,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", generated_usage);\n-        assert generated_usage == expected;\n+        fail_unless!(generated_usage == expected);\n     }\n \n     #[test]\n@@ -1356,7 +1356,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", usage);\n-        assert usage == expected\n+        fail_unless!(usage == expected)\n     }\n }\n "}, {"sha": "01e0b58f77e5cbb2077b3c5e7a15d4bcf028d77b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 177, "deletions": 144, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1229,45 +1229,45 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert to_str(&Null) == ~\"null\";\n+        fail_unless!(to_str(&Null) == ~\"null\");\n     }\n \n     #[test]\n     fn test_write_number() {\n-        assert to_str(&Number(3f)) == ~\"3\";\n-        assert to_str(&Number(3.1f)) == ~\"3.1\";\n-        assert to_str(&Number(-1.5f)) == ~\"-1.5\";\n-        assert to_str(&Number(0.5f)) == ~\"0.5\";\n+        fail_unless!(to_str(&Number(3f)) == ~\"3\");\n+        fail_unless!(to_str(&Number(3.1f)) == ~\"3.1\");\n+        fail_unless!(to_str(&Number(-1.5f)) == ~\"-1.5\");\n+        fail_unless!(to_str(&Number(0.5f)) == ~\"0.5\");\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(&String(~\"\")) == ~\"\\\"\\\"\";\n-        assert to_str(&String(~\"foo\")) == ~\"\\\"foo\\\"\";\n+        fail_unless!(to_str(&String(~\"\")) == ~\"\\\"\\\"\");\n+        fail_unless!(to_str(&String(~\"foo\")) == ~\"\\\"foo\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert to_str(&Boolean(true)) == ~\"true\";\n-        assert to_str(&Boolean(false)) == ~\"false\";\n+        fail_unless!(to_str(&Boolean(true)) == ~\"true\");\n+        fail_unless!(to_str(&Boolean(false)) == ~\"false\");\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(&List(~[])) == ~\"[]\";\n-        assert to_str(&List(~[Boolean(true)])) == ~\"[true]\";\n-        assert to_str(&List(~[\n+        fail_unless!(to_str(&List(~[])) == ~\"[]\");\n+        fail_unless!(to_str(&List(~[Boolean(true)])) == ~\"[true]\");\n+        fail_unless!(to_str(&List(~[\n             Boolean(false),\n             Null,\n             List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n-        ])) == ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\";\n+        ])) == ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert to_str(&mk_object(~[])) == ~\"{}\";\n-        assert to_str(&mk_object(~[(~\"a\", Boolean(true))]))\n-            == ~\"{\\\"a\\\":true}\";\n+        fail_unless!(to_str(&mk_object(~[])) == ~\"{}\");\n+        fail_unless!(to_str(&mk_object(~[(~\"a\", Boolean(true))]))\n+            == ~\"{\\\"a\\\":true}\");\n         let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n@@ -1278,7 +1278,7 @@ mod tests {\n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n         let b = result::unwrap(from_str(to_str(&a)));\n-        assert a == b;\n+        fail_unless!(a == b);\n     }\n \n     // two fns copied from libsyntax/util/testing.rs.\n@@ -1347,165 +1347,195 @@ mod tests {\n \n     #[test]\n     fn test_trailing_characters() {\n-        assert from_str(~\"nulla\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"truea\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"falsea\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"1a\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"[]a\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"{}a\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+        fail_unless!(from_str(~\"nulla\") ==\n+            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"truea\") ==\n+            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"falsea\") ==\n+            Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"1a\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"[]a\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"{}a\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        assert from_str(~\"n\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"nul\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+        fail_unless!(from_str(~\"n\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"nul\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert from_str(~\"t\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"truz\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+        fail_unless!(from_str(~\"t\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"truz\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert from_str(~\"f\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"faz\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n+        fail_unless!(from_str(~\"f\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"faz\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"}));\n \n-        assert from_str(~\"null\") == Ok(Null);\n-        assert from_str(~\"true\") == Ok(Boolean(true));\n-        assert from_str(~\"false\") == Ok(Boolean(false));\n-        assert from_str(~\" null \") == Ok(Null);\n-        assert from_str(~\" true \") == Ok(Boolean(true));\n-        assert from_str(~\" false \") == Ok(Boolean(false));\n+        fail_unless!(from_str(~\"null\") == Ok(Null));\n+        fail_unless!(from_str(~\"true\") == Ok(Boolean(true)));\n+        fail_unless!(from_str(~\"false\") == Ok(Boolean(false)));\n+        fail_unless!(from_str(~\" null \") == Ok(Null));\n+        fail_unless!(from_str(~\" true \") == Ok(Boolean(true)));\n+        fail_unless!(from_str(~\" false \") == Ok(Boolean(false)));\n     }\n \n     #[test]\n     fn test_read_number() {\n-        assert from_str(~\"+\") ==\n-            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\".\") ==\n-            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n-\n-        assert from_str(~\"-\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"});\n-        assert from_str(~\"00\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"});\n-        assert from_str(~\"1.\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"});\n-        assert from_str(~\"1e\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"});\n-        assert from_str(~\"1e+\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"});\n-\n-        assert from_str(~\"3\") == Ok(Number(3f));\n-        assert from_str(~\"3.1\") == Ok(Number(3.1f));\n-        assert from_str(~\"-1.2\") == Ok(Number(-1.2f));\n-        assert from_str(~\"0.4\") == Ok(Number(0.4f));\n-        assert from_str(~\"0.4e5\") == Ok(Number(0.4e5f));\n-        assert from_str(~\"0.4e+15\") == Ok(Number(0.4e15f));\n-        assert from_str(~\"0.4e-01\") == Ok(Number(0.4e-01f));\n-        assert from_str(~\" 3 \") == Ok(Number(3f));\n+        fail_unless!(from_str(~\"+\") ==\n+            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\".\") ==\n+            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n+\n+        fail_unless!(from_str(~\"-\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"00\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"1.\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"1e\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"1e+\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n+\n+        fail_unless!(from_str(~\"3\") == Ok(Number(3f)));\n+        fail_unless!(from_str(~\"3.1\") == Ok(Number(3.1f)));\n+        fail_unless!(from_str(~\"-1.2\") == Ok(Number(-1.2f)));\n+        fail_unless!(from_str(~\"0.4\") == Ok(Number(0.4f)));\n+        fail_unless!(from_str(~\"0.4e5\") == Ok(Number(0.4e5f)));\n+        fail_unless!(from_str(~\"0.4e+15\") == Ok(Number(0.4e15f)));\n+        fail_unless!(from_str(~\"0.4e-01\") == Ok(Number(0.4e-01f)));\n+        fail_unless!(from_str(~\" 3 \") == Ok(Number(3f)));\n     }\n \n     #[test]\n     fn test_read_str() {\n-        assert from_str(~\"\\\"\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n-        assert from_str(~\"\\\"lol\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n-\n-        assert from_str(~\"\\\"\\\"\") == Ok(String(~\"\"));\n-        assert from_str(~\"\\\"foo\\\"\") == Ok(String(~\"foo\"));\n-        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(~\"\\\"\"));\n-        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(String(~\"\\x08\"));\n-        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(String(~\"\\n\"));\n-        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(String(~\"\\r\"));\n-        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(String(~\"\\t\"));\n-        assert from_str(~\" \\\"foo\\\" \") == Ok(String(~\"foo\"));\n+        fail_unless!(from_str(~\"\\\"\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"\n+        }));\n+        fail_unless!(from_str(~\"\\\"lol\") ==\n+            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"\n+        }));\n+\n+        fail_unless!(from_str(~\"\\\"\\\"\") == Ok(String(~\"\")));\n+        fail_unless!(from_str(~\"\\\"foo\\\"\") == Ok(String(~\"foo\")));\n+        fail_unless!(from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(~\"\\\"\")));\n+        fail_unless!(from_str(~\"\\\"\\\\b\\\"\") == Ok(String(~\"\\x08\")));\n+        fail_unless!(from_str(~\"\\\"\\\\n\\\"\") == Ok(String(~\"\\n\")));\n+        fail_unless!(from_str(~\"\\\"\\\\r\\\"\") == Ok(String(~\"\\r\")));\n+        fail_unless!(from_str(~\"\\\"\\\\t\\\"\") == Ok(String(~\"\\t\")));\n+        fail_unless!(from_str(~\" \\\"foo\\\" \") == Ok(String(~\"foo\")));\n     }\n \n     #[test]\n     fn test_unicode_hex_escapes_in_str() {\n-        assert from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(~\"\\u12ab\"));\n-        assert from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(~\"\\uAB12\"));\n+        fail_unless!(from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(~\"\\u12ab\")));\n+        fail_unless!(from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n     fn test_read_list() {\n-        assert from_str(~\"[\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n-        assert from_str(~\"[1\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n-        assert from_str(~\"[1,\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n-        assert from_str(~\"[1,]\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"[6 7]\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n-\n-        assert from_str(~\"[]\") == Ok(List(~[]));\n-        assert from_str(~\"[ ]\") == Ok(List(~[]));\n-        assert from_str(~\"[true]\") == Ok(List(~[Boolean(true)]));\n-        assert from_str(~\"[ false ]\") == Ok(List(~[Boolean(false)]));\n-        assert from_str(~\"[null]\") == Ok(List(~[Null]));\n-        assert from_str(~\"[3, 1]\") == Ok(List(~[Number(3f), Number(1f)]));\n-        assert from_str(~\"\\n[3, 2]\\n\") == Ok(List(~[Number(3f), Number(2f)]));\n-        assert from_str(~\"[2, [4, 1]]\") ==\n-               Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])]));\n+        fail_unless!(from_str(~\"[\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"}));\n+        fail_unless!(from_str(~\"[1\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"}));\n+        fail_unless!(from_str(~\"[1,\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"}));\n+        fail_unless!(from_str(~\"[1,]\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"[6 7]\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"}));\n+\n+        fail_unless!(from_str(~\"[]\") == Ok(List(~[])));\n+        fail_unless!(from_str(~\"[ ]\") == Ok(List(~[])));\n+        fail_unless!(from_str(~\"[true]\") == Ok(List(~[Boolean(true)])));\n+        fail_unless!(from_str(~\"[ false ]\") == Ok(List(~[Boolean(false)])));\n+        fail_unless!(from_str(~\"[null]\") == Ok(List(~[Null])));\n+        fail_unless!(from_str(~\"[3, 1]\") ==\n+                     Ok(List(~[Number(3f), Number(1f)])));\n+        fail_unless!(from_str(~\"\\n[3, 2]\\n\") ==\n+                     Ok(List(~[Number(3f), Number(2f)])));\n+        fail_unless!(from_str(~\"[2, [4, 1]]\") ==\n+               Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n     }\n \n     #[test]\n     fn test_read_object() {\n-        assert from_str(~\"{\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{ \") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{1\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"key must be a string\"});\n-        assert from_str(~\"{ \\\"a\\\"\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{\\\"a\\\"\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{\\\"a\\\" \") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n-\n-        assert from_str(~\"{\\\"a\\\" 1\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"});\n-        assert from_str(~\"{\\\"a\\\":\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n-        assert from_str(~\"{\\\"a\\\":1\") ==\n-            Err(Error {line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{\\\"a\\\":1 1\") ==\n-            Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n-        assert from_str(~\"{\\\"a\\\":1,\") ==\n-            Err(Error {line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n-\n-        assert result::unwrap(from_str(~\"{}\")) == mk_object(~[]);\n-        assert result::unwrap(from_str(~\"{\\\"a\\\": 3}\")) ==\n-                  mk_object(~[(~\"a\", Number(3.0f))]);\n-\n-        assert result::unwrap(from_str(~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")) ==\n+        fail_unless!(from_str(~\"{\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 2u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{ \") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 3u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{1\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 2u,\n+                msg: @~\"key must be a string\"}));\n+        fail_unless!(from_str(~\"{ \\\"a\\\"\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 6u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\"\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 5u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\" \") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 6u,\n+                msg: @~\"EOF while parsing object\"}));\n+\n+        fail_unless!(from_str(~\"{\\\"a\\\" 1\") ==\n+            Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":\") ==\n+            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":1\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 7u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":1 1\") ==\n+            Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":1,\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 8u,\n+                msg: @~\"EOF while parsing object\"}));\n+\n+        fail_unless!(result::unwrap(from_str(~\"{}\")) == mk_object(~[]));\n+        fail_unless!(result::unwrap(from_str(~\"{\\\"a\\\": 3}\")) ==\n+                  mk_object(~[(~\"a\", Number(3.0f))]));\n+\n+        fail_unless!(result::unwrap(from_str(\n+                ~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")) ==\n                   mk_object(~[\n                       (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]);\n-        assert result::unwrap(\n+                      (~\"b\", Boolean(true))]));\n+        fail_unless!(result::unwrap(\n                       from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")) ==\n                   mk_object(~[\n                       (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]);\n-        assert result::unwrap(from_str(~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")) ==\n+                      (~\"b\", Boolean(true))]));\n+        fail_unless!(result::unwrap(from_str(\n+                ~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")) ==\n                   mk_object(~[\n                       (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[Boolean(true)]))\n-                  ]);\n-        assert result::unwrap(from_str(\n+                  ]));\n+        fail_unless!(result::unwrap(from_str(\n                       ~\"{\" +\n                           ~\"\\\"a\\\": 1.0, \" +\n                           ~\"\\\"b\\\": [\" +\n@@ -1523,12 +1553,15 @@ mod tests {\n                               (~\"c\", mk_object(~[(~\"d\", Null)]))\n                           ])\n                       ]))\n-                  ]);\n+                  ]));\n     }\n \n     #[test]\n     fn test_multiline_errors() {\n-        assert from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            Err(Error {line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n+        fail_unless!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n+            Err(Error {\n+                line: 3u,\n+                col: 8u,\n+                msg: @~\"EOF while parsing object\"}));\n     }\n }"}, {"sha": "5ab1722ae8399731177641613bcf659ae26e8caf", "filename": "src/libstd/list.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -165,37 +165,37 @@ mod tests {\n         let full1 = from_vec(~[1]);\n         let full2 = from_vec(~['r', 'u']);\n \n-        assert is_empty(empty);\n-        assert !is_empty(full1);\n-        assert !is_empty(full2);\n+        fail_unless!(is_empty(empty));\n+        fail_unless!(!is_empty(full1));\n+        fail_unless!(!is_empty(full2));\n     }\n \n     #[test]\n     pub fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n-        assert (head(l) == 0);\n+        fail_unless!((head(l) == 0));\n \n         let tail_l = tail(l);\n-        assert (head(tail_l) == 1);\n+        fail_unless!((head(tail_l) == 1));\n \n         let tail_tail_l = tail(tail_l);\n-        assert (head(tail_tail_l) == 2);\n+        fail_unless!((head(tail_tail_l) == 2));\n     }\n \n     #[test]\n     pub fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n-        assert (empty == @list::Nil::<int>);\n+        fail_unless!((empty == @list::Nil::<int>));\n     }\n \n     #[test]\n     pub fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n-        assert (list::foldl(0u, l, add) == 10u);\n-        assert (list::foldl(0u, empty, add) == 0u);\n+        fail_unless!((list::foldl(0u, l, add) == 10u));\n+        fail_unless!((list::foldl(0u, empty, add) == 0u));\n     }\n \n     #[test]\n@@ -204,47 +204,47 @@ mod tests {\n             *a - *b\n         }\n         let l = from_vec(~[1, 2, 3, 4]);\n-        assert (list::foldl(0, l, sub) == -10);\n+        fail_unless!((list::foldl(0, l, sub) == -10));\n     }\n \n     #[test]\n     pub fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n-        assert (list::find(l, match_) == option::Some(2));\n+        fail_unless!((list::find(l, match_) == option::Some(2)));\n     }\n \n     #[test]\n     pub fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert (list::find(l, match_) == option::None::<int>);\n-        assert (list::find(empty, match_) == option::None::<int>);\n+        fail_unless!((list::find(l, match_) == option::None::<int>));\n+        fail_unless!((list::find(empty, match_) == option::None::<int>));\n     }\n \n     #[test]\n     pub fn test_has() {\n         let l = from_vec(~[5, 8, 6]);\n         let empty = @list::Nil::<int>;\n-        assert (list::has(l, 5));\n-        assert (!list::has(l, 7));\n-        assert (list::has(l, 8));\n-        assert (!list::has(empty, 5));\n+        fail_unless!((list::has(l, 5)));\n+        fail_unless!((!list::has(l, 7)));\n+        fail_unless!((list::has(l, 8)));\n+        fail_unless!((!list::has(empty, 5)));\n     }\n \n     #[test]\n     pub fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert (list::len(l) == 3u);\n-        assert (list::len(empty) == 0u);\n+        fail_unless!((list::len(l) == 3u));\n+        fail_unless!((list::len(empty) == 0u));\n     }\n \n     #[test]\n     pub fn test_append() {\n-        assert from_vec(~[1,2,3,4])\n-            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4]));\n+        fail_unless!(from_vec(~[1,2,3,4])\n+            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n     }\n }\n "}, {"sha": "eb4bd6fe23f477ac78b0736e8863fb4e388696e4", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -125,15 +125,17 @@ pub pure fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    assert md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\";\n-    assert md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\";\n-    assert md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\";\n-    assert md4_text(~\"message digest\") == ~\"d9130a8164549fe818874806e1c7014b\";\n-    assert md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n-        ~\"d79e1c308aa5bbcdeea8ed63df412da9\";\n-    assert md4_text(~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n-                     0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\";\n-    assert md4_text(~\"1234567890123456789012345678901234567890123456789\\\n+    fail_unless!(md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n+    fail_unless!(md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n+    fail_unless!(md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\");\n+    fail_unless!(md4_text(~\"message digest\") ==\n+        ~\"d9130a8164549fe818874806e1c7014b\");\n+    fail_unless!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n+        ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n+    fail_unless!(md4_text(\n+        ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n+        0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n+    fail_unless!(md4_text(~\"1234567890123456789012345678901234567890123456789\\\n                      0123456789012345678901234567890\") ==\n-        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\";\n+        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n }"}, {"sha": "8021162188f7931c77051185e46ba6391c50c9f7", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -377,7 +377,7 @@ mod test {\n     #[test]\n     fn test_ip_ipv4_parse_and_format_ip() {\n         let localhost_str = ~\"127.0.0.1\";\n-        assert (format_addr(&v4::parse_addr(localhost_str))\n+        fail_unless!(format_addr(&v4::parse_addr(localhost_str))\n                 == localhost_str)\n     }\n     #[test]\n@@ -386,14 +386,14 @@ mod test {\n         let format_result = format_addr(&v6::parse_addr(localhost_str));\n         log(debug, fmt!(\"results: expected: '%s' actual: '%s'\",\n             localhost_str, format_result));\n-        assert format_result == localhost_str;\n+        fail_unless!(format_result == localhost_str);\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         match v4::try_parse_addr(~\"b4df00d\") {\n           result::Err(ref err_info) => {\n             log(debug, fmt!(\"got error as expected %?\", err_info));\n-            assert true;\n+            fail_unless!(true);\n           }\n           result::Ok(ref addr) => {\n             fail!(fmt!(\"Expected failure, but got addr %?\", addr));\n@@ -406,7 +406,7 @@ mod test {\n         match v6::try_parse_addr(~\"::,~2234k;\") {\n           result::Err(ref err_info) => {\n             log(debug, fmt!(\"got error as expected %?\", err_info));\n-            assert true;\n+            fail_unless!(true);\n           }\n           result::Ok(ref addr) => {\n             fail!(fmt!(\"Expected failure, but got addr %?\", addr));\n@@ -437,14 +437,14 @@ mod test {\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts\n-        assert !results.is_empty();\n+        fail_unless!(!results.is_empty());\n     }\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr_bad_input() {\n         let localhost_name = ~\"sjkl234m,./sdf\";\n         let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n-        assert result::is_err(&ga_result);\n+        fail_unless!(result::is_err(&ga_result));\n     }\n }"}, {"sha": "5328975f82abaf6cdfef54bb1498b185e40fd2e3", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -32,12 +32,16 @@ use core::result;\n use core::uint;\n use core::vec;\n \n-#[nolink]\n-extern mod rustrt {\n-    unsafe fn rust_uv_current_kernel_malloc(size: libc::c_uint)\n-                                         -> *libc::c_void;\n-    unsafe fn rust_uv_current_kernel_free(mem: *libc::c_void);\n-    unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+pub mod rustrt {\n+    use core::libc;\n+\n+    #[nolink]\n+    pub extern {\n+        unsafe fn rust_uv_current_kernel_malloc(size: libc::c_uint)\n+                                             -> *libc::c_void;\n+        unsafe fn rust_uv_current_kernel_free(mem: *libc::c_void);\n+        unsafe fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n+    }\n }\n \n /**\n@@ -871,7 +875,7 @@ impl io::Reader for TcpSocketBuf {\n         let mut count: uint = 0;\n \n         loop {\n-          assert count < len;\n+          fail_unless!(count < len);\n \n           // If possible, copy up to `len` bytes from the internal\n           // `data.buf` into `buf`\n@@ -891,7 +895,7 @@ impl io::Reader for TcpSocketBuf {\n                 }\n           }\n \n-          assert count <= len;\n+          fail_unless!(count <= len);\n           if count == len {\n               break;\n           }\n@@ -1583,15 +1587,15 @@ pub mod test {\n             server_port,\n             expected_req,\n             hl_loop);\n-        assert actual_resp_result.is_ok();\n+        fail_unless!(actual_resp_result.is_ok());\n         let actual_resp = actual_resp_result.get();\n         let actual_req = server_result_po.recv();\n         debug!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert str::contains(actual_req, expected_req);\n-        assert str::contains(actual_resp, expected_resp);\n+        fail_unless!(str::contains(actual_req, expected_req));\n+        fail_unless!(str::contains(actual_resp, expected_resp));\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1624,9 +1628,9 @@ pub mod test {\n \n         debug!(\"testing peer address\");\n         // This is what we are actually testing!\n-        assert net::ip::format_addr(&sock.get_peer_addr()) ==\n-            ~\"127.0.0.1\";\n-        assert net::ip::get_port(&sock.get_peer_addr()) == 8887;\n+        fail_unless!(net::ip::format_addr(&sock.get_peer_addr()) ==\n+            ~\"127.0.0.1\");\n+        fail_unless!(net::ip::get_port(&sock.get_peer_addr()) == 8887);\n \n         // Fulfill the protocol the test server expects\n         let resp_bytes = str::to_bytes(~\"ping\");\n@@ -1687,7 +1691,7 @@ pub mod test {\n             hl_loop);\n         match listen_err {\n           AddressInUse => {\n-            assert true;\n+            fail_unless!(true);\n           }\n           _ => {\n             fail!(~\"expected address_in_use listen error,\"+\n@@ -1706,7 +1710,7 @@ pub mod test {\n                             hl_loop);\n         match listen_err {\n           AccessDenied => {\n-            assert true;\n+            fail_unless!(true);\n           }\n           _ => {\n             fail!(~\"expected address_in_use listen error,\"+\n@@ -1743,7 +1747,7 @@ pub mod test {\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, iotask);\n         if result::is_err(&conn_result) {\n-            assert false;\n+            fail_unless!(false);\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n@@ -1758,8 +1762,8 @@ pub mod test {\n                        expected_req, actual_req));\n         log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp));\n-        assert str::contains(actual_req, expected_req);\n-        assert str::contains(actual_resp, expected_resp);\n+        fail_unless!(str::contains(actual_req, expected_req));\n+        fail_unless!(str::contains(actual_resp, expected_resp));\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n@@ -1790,15 +1794,15 @@ pub mod test {\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, hl_loop);\n         if result::is_err(&conn_result) {\n-            assert false;\n+            fail_unless!(false);\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n \n         let buf_reader = sock_buf as Reader;\n         let actual_response = str::from_bytes(buf_reader.read_whole_stream());\n         debug!(\"Actual response: %s\", actual_response);\n-        assert expected_resp == actual_response;\n+        fail_unless!(expected_resp == actual_response);\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {"}, {"sha": "0bb8fdd373871a52d3f1fcd767abcebf3915b133", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 169, "deletions": 167, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -733,83 +733,83 @@ impl to_bytes::IterBytes for Url {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n-    assert u == ~\"hello\";\n-    assert v == ~\" sweet world\";\n+    fail_unless!(u == ~\"hello\");\n+    fail_unless!(v == ~\" sweet world\");\n \n     let (u,v) = split_char_first(~\"hello sweet world\", ',');\n-    assert u == ~\"hello sweet world\";\n-    assert v == ~\"\";\n+    fail_unless!(u == ~\"hello sweet world\");\n+    fail_unless!(v == ~\"\");\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert u == Some(UserInfo::new(~\"user\", Some(~\"pass\")));\n-    assert h == ~\"rust-lang.org\";\n-    assert p.is_none();\n-    assert r == ~\"/something\";\n+    fail_unless!(u == Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n+    fail_unless!(h == ~\"rust-lang.org\");\n+    fail_unless!(p.is_none());\n+    fail_unless!(r == ~\"/something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n-    assert u.is_none();\n-    assert h == ~\"rust-lang.org\";\n-    assert p == Some(~\"8000\");\n-    assert r == ~\"?something\";\n+    fail_unless!(u.is_none());\n+    fail_unless!(h == ~\"rust-lang.org\");\n+    fail_unless!(p == Some(~\"8000\"));\n+    fail_unless!(r == ~\"?something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n-    assert u.is_none();\n-    assert h == ~\"rust-lang.org\";\n-    assert p.is_none();\n-    assert r == ~\"#blah\";\n+    fail_unless!(u.is_none());\n+    fail_unless!(h == ~\"rust-lang.org\");\n+    fail_unless!(p.is_none());\n+    fail_unless!(r == ~\"#blah\");\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n+    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-    assert p == Some(~\"8000\");\n+    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    fail_unless!(p == Some(~\"8000\"));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert u == Some(UserInfo::new(~\"us\", Some(~\"p\")));\n-    assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-    assert p == Some(~\"8000\");\n+    fail_unless!(u == Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n+    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    fail_unless!(p == Some(~\"8000\"));\n \n     // invalid authorities;\n-    assert get_authority(\"//user:pass@rust-lang:something\").is_err();\n-    assert get_authority(\"//user@rust-lang:something:/path\").is_err();\n-    assert get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err();\n-    assert get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err();\n+    fail_unless!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n+    fail_unless!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n+    fail_unless!(get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n+    fail_unless!(get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n-    assert h == ~\"\";\n+    fail_unless!(h == ~\"\");\n     let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n-    assert h == ~\"\";\n+    fail_unless!(h == ~\"\");\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert p == ~\"/something+ orother\";\n-    assert r == ~\"\";\n+    fail_unless!(p == ~\"/something+ orother\");\n+    fail_unless!(r == ~\"\");\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert p == ~\"test@email.com\";\n-    assert r == ~\"#fragment\";\n+    fail_unless!(p == ~\"test@email.com\");\n+    fail_unless!(r == ~\"#fragment\");\n     let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n-    assert p == ~\"/gen/:addr=\";\n-    assert r == ~\"?q=v\";\n+    fail_unless!(p == ~\"/gen/:addr=\");\n+    fail_unless!(r == ~\"?q=v\");\n \n     //failure cases\n-    assert get_path(~\"something?q\", true).is_err();\n+    fail_unless!(get_path(~\"something?q\", true).is_err());\n }\n \n #[cfg(test)]\n@@ -826,260 +826,262 @@ mod tests {\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert u.scheme == ~\"http\";\n+        fail_unless!(u.scheme == ~\"http\");\n         let userinfo = u.user.get_ref();\n-        assert userinfo.user == ~\"user\";\n-        assert userinfo.pass.get_ref() == &~\"pass\";\n-        assert u.host == ~\"rust-lang.org\";\n-        assert u.path == ~\"/doc\";\n-        assert u.query == ~[(~\"s\", ~\"v\")];\n-        assert u.fragment.get_ref() == &~\"something\";\n+        fail_unless!(userinfo.user == ~\"user\");\n+        fail_unless!(userinfo.pass.get_ref() == &~\"pass\");\n+        fail_unless!(u.host == ~\"rust-lang.org\");\n+        fail_unless!(u.path == ~\"/doc\");\n+        fail_unless!(u.query == ~[(~\"s\", ~\"v\")]);\n+        fail_unless!(u.fragment.get_ref() == &~\"something\");\n     }\n \n     #[test]\n     pub fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n-        assert url.host == ~\"0.42.42.42\";\n-        assert url.path == ~\"/\";\n+        fail_unless!(url.host == ~\"0.42.42.42\");\n+        fail_unless!(url.path == ~\"/\");\n     }\n \n     #[test]\n     pub fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert url.path == ~\"/file_name.html\";\n+        fail_unless!(url.path == ~\"/file_name.html\");\n     }\n \n     #[test]\n     pub fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert url.path == ~\"/file-name.html\";\n+        fail_unless!(url.path == ~\"/file-name.html\");\n     }\n \n     #[test]\n     pub fn test_no_scheme() {\n-        assert get_scheme(\"noschemehere.html\").is_err();\n+        fail_unless!(get_scheme(\"noschemehere.html\").is_err());\n     }\n \n     #[test]\n     pub fn test_invalid_scheme_errors() {\n-        assert from_str(\"99://something\").is_err();\n-        assert from_str(\"://something\").is_err();\n+        fail_unless!(from_str(\"99://something\").is_err());\n+        fail_unless!(from_str(\"://something\").is_err());\n     }\n \n     #[test]\n     pub fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert from_str(url).unwrap().to_str() == should_be;\n+        fail_unless!(from_str(url).unwrap().to_str() == should_be);\n     }\n \n     #[test]\n     pub fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n-        assert u.path == ~\"/doc uments\";\n-        assert u.query == ~[(~\"ba%d \", ~\"#&+\")];\n+        fail_unless!(u.path == ~\"/doc uments\");\n+        fail_unless!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n     }\n \n     #[test]\n     pub fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_encode() {\n-        assert encode(\"\") == ~\"\";\n-        assert encode(\"http://example.com\") == ~\"http://example.com\";\n-        assert encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n-        assert encode(\" \") == ~\"%20\";\n-        assert encode(\"!\") == ~\"!\";\n-        assert encode(\"\\\"\") == ~\"\\\"\";\n-        assert encode(\"#\") == ~\"#\";\n-        assert encode(\"$\") == ~\"$\";\n-        assert encode(\"%\") == ~\"%25\";\n-        assert encode(\"&\") == ~\"&\";\n-        assert encode(\"'\") == ~\"%27\";\n-        assert encode(\"(\") == ~\"(\";\n-        assert encode(\")\") == ~\")\";\n-        assert encode(\"*\") == ~\"*\";\n-        assert encode(\"+\") == ~\"+\";\n-        assert encode(\",\") == ~\",\";\n-        assert encode(\"/\") == ~\"/\";\n-        assert encode(\":\") == ~\":\";\n-        assert encode(\";\") == ~\";\";\n-        assert encode(\"=\") == ~\"=\";\n-        assert encode(\"?\") == ~\"?\";\n-        assert encode(\"@\") == ~\"@\";\n-        assert encode(\"[\") == ~\"[\";\n-        assert encode(\"]\") == ~\"]\";\n+        fail_unless!(encode(\"\") == ~\"\");\n+        fail_unless!(encode(\"http://example.com\") == ~\"http://example.com\");\n+        fail_unless!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n+        fail_unless!(encode(\" \") == ~\"%20\");\n+        fail_unless!(encode(\"!\") == ~\"!\");\n+        fail_unless!(encode(\"\\\"\") == ~\"\\\"\");\n+        fail_unless!(encode(\"#\") == ~\"#\");\n+        fail_unless!(encode(\"$\") == ~\"$\");\n+        fail_unless!(encode(\"%\") == ~\"%25\");\n+        fail_unless!(encode(\"&\") == ~\"&\");\n+        fail_unless!(encode(\"'\") == ~\"%27\");\n+        fail_unless!(encode(\"(\") == ~\"(\");\n+        fail_unless!(encode(\")\") == ~\")\");\n+        fail_unless!(encode(\"*\") == ~\"*\");\n+        fail_unless!(encode(\"+\") == ~\"+\");\n+        fail_unless!(encode(\",\") == ~\",\");\n+        fail_unless!(encode(\"/\") == ~\"/\");\n+        fail_unless!(encode(\":\") == ~\":\");\n+        fail_unless!(encode(\";\") == ~\";\");\n+        fail_unless!(encode(\"=\") == ~\"=\");\n+        fail_unless!(encode(\"?\") == ~\"?\");\n+        fail_unless!(encode(\"@\") == ~\"@\");\n+        fail_unless!(encode(\"[\") == ~\"[\");\n+        fail_unless!(encode(\"]\") == ~\"]\");\n     }\n \n     #[test]\n     pub fn test_encode_component() {\n-        assert encode_component(\"\") == ~\"\";\n-        assert encode_component(\"http://example.com\") ==\n-            ~\"http%3A%2F%2Fexample.com\";\n-        assert encode_component(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n-        assert encode_component(\" \") == ~\"%20\";\n-        assert encode_component(\"!\") == ~\"%21\";\n-        assert encode_component(\"#\") == ~\"%23\";\n-        assert encode_component(\"$\") == ~\"%24\";\n-        assert encode_component(\"%\") == ~\"%25\";\n-        assert encode_component(\"&\") == ~\"%26\";\n-        assert encode_component(\"'\") == ~\"%27\";\n-        assert encode_component(\"(\") == ~\"%28\";\n-        assert encode_component(\")\") == ~\"%29\";\n-        assert encode_component(\"*\") == ~\"%2A\";\n-        assert encode_component(\"+\") == ~\"%2B\";\n-        assert encode_component(\",\") == ~\"%2C\";\n-        assert encode_component(\"/\") == ~\"%2F\";\n-        assert encode_component(\":\") == ~\"%3A\";\n-        assert encode_component(\";\") == ~\"%3B\";\n-        assert encode_component(\"=\") == ~\"%3D\";\n-        assert encode_component(\"?\") == ~\"%3F\";\n-        assert encode_component(\"@\") == ~\"%40\";\n-        assert encode_component(\"[\") == ~\"%5B\";\n-        assert encode_component(\"]\") == ~\"%5D\";\n+        fail_unless!(encode_component(\"\") == ~\"\");\n+        fail_unless!(encode_component(\"http://example.com\") ==\n+            ~\"http%3A%2F%2Fexample.com\");\n+        fail_unless!(encode_component(\"foo bar% baz\") ==\n+            ~\"foo%20bar%25%20baz\");\n+        fail_unless!(encode_component(\" \") == ~\"%20\");\n+        fail_unless!(encode_component(\"!\") == ~\"%21\");\n+        fail_unless!(encode_component(\"#\") == ~\"%23\");\n+        fail_unless!(encode_component(\"$\") == ~\"%24\");\n+        fail_unless!(encode_component(\"%\") == ~\"%25\");\n+        fail_unless!(encode_component(\"&\") == ~\"%26\");\n+        fail_unless!(encode_component(\"'\") == ~\"%27\");\n+        fail_unless!(encode_component(\"(\") == ~\"%28\");\n+        fail_unless!(encode_component(\")\") == ~\"%29\");\n+        fail_unless!(encode_component(\"*\") == ~\"%2A\");\n+        fail_unless!(encode_component(\"+\") == ~\"%2B\");\n+        fail_unless!(encode_component(\",\") == ~\"%2C\");\n+        fail_unless!(encode_component(\"/\") == ~\"%2F\");\n+        fail_unless!(encode_component(\":\") == ~\"%3A\");\n+        fail_unless!(encode_component(\";\") == ~\"%3B\");\n+        fail_unless!(encode_component(\"=\") == ~\"%3D\");\n+        fail_unless!(encode_component(\"?\") == ~\"%3F\");\n+        fail_unless!(encode_component(\"@\") == ~\"%40\");\n+        fail_unless!(encode_component(\"[\") == ~\"%5B\");\n+        fail_unless!(encode_component(\"]\") == ~\"%5D\");\n     }\n \n     #[test]\n     pub fn test_decode() {\n-        assert decode(\"\") == ~\"\";\n-        assert decode(\"abc/def 123\") == ~\"abc/def 123\";\n-        assert decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\";\n-        assert decode(\"%20\") == ~\" \";\n-        assert decode(\"%21\") == ~\"%21\";\n-        assert decode(\"%22\") == ~\"%22\";\n-        assert decode(\"%23\") == ~\"%23\";\n-        assert decode(\"%24\") == ~\"%24\";\n-        assert decode(\"%25\") == ~\"%\";\n-        assert decode(\"%26\") == ~\"%26\";\n-        assert decode(\"%27\") == ~\"'\";\n-        assert decode(\"%28\") == ~\"%28\";\n-        assert decode(\"%29\") == ~\"%29\";\n-        assert decode(\"%2A\") == ~\"%2A\";\n-        assert decode(\"%2B\") == ~\"%2B\";\n-        assert decode(\"%2C\") == ~\"%2C\";\n-        assert decode(\"%2F\") == ~\"%2F\";\n-        assert decode(\"%3A\") == ~\"%3A\";\n-        assert decode(\"%3B\") == ~\"%3B\";\n-        assert decode(\"%3D\") == ~\"%3D\";\n-        assert decode(\"%3F\") == ~\"%3F\";\n-        assert decode(\"%40\") == ~\"%40\";\n-        assert decode(\"%5B\") == ~\"%5B\";\n-        assert decode(\"%5D\") == ~\"%5D\";\n+        fail_unless!(decode(\"\") == ~\"\");\n+        fail_unless!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n+        fail_unless!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n+        fail_unless!(decode(\"%20\") == ~\" \");\n+        fail_unless!(decode(\"%21\") == ~\"%21\");\n+        fail_unless!(decode(\"%22\") == ~\"%22\");\n+        fail_unless!(decode(\"%23\") == ~\"%23\");\n+        fail_unless!(decode(\"%24\") == ~\"%24\");\n+        fail_unless!(decode(\"%25\") == ~\"%\");\n+        fail_unless!(decode(\"%26\") == ~\"%26\");\n+        fail_unless!(decode(\"%27\") == ~\"'\");\n+        fail_unless!(decode(\"%28\") == ~\"%28\");\n+        fail_unless!(decode(\"%29\") == ~\"%29\");\n+        fail_unless!(decode(\"%2A\") == ~\"%2A\");\n+        fail_unless!(decode(\"%2B\") == ~\"%2B\");\n+        fail_unless!(decode(\"%2C\") == ~\"%2C\");\n+        fail_unless!(decode(\"%2F\") == ~\"%2F\");\n+        fail_unless!(decode(\"%3A\") == ~\"%3A\");\n+        fail_unless!(decode(\"%3B\") == ~\"%3B\");\n+        fail_unless!(decode(\"%3D\") == ~\"%3D\");\n+        fail_unless!(decode(\"%3F\") == ~\"%3F\");\n+        fail_unless!(decode(\"%40\") == ~\"%40\");\n+        fail_unless!(decode(\"%5B\") == ~\"%5B\");\n+        fail_unless!(decode(\"%5D\") == ~\"%5D\");\n     }\n \n     #[test]\n     pub fn test_decode_component() {\n-        assert decode_component(\"\") == ~\"\";\n-        assert decode_component(\"abc/def 123\") == ~\"abc/def 123\";\n-        assert decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\";\n-        assert decode_component(\"%20\") == ~\" \";\n-        assert decode_component(\"%21\") == ~\"!\";\n-        assert decode_component(\"%22\") == ~\"\\\"\";\n-        assert decode_component(\"%23\") == ~\"#\";\n-        assert decode_component(\"%24\") == ~\"$\";\n-        assert decode_component(\"%25\") == ~\"%\";\n-        assert decode_component(\"%26\") == ~\"&\";\n-        assert decode_component(\"%27\") == ~\"'\";\n-        assert decode_component(\"%28\") == ~\"(\";\n-        assert decode_component(\"%29\") == ~\")\";\n-        assert decode_component(\"%2A\") == ~\"*\";\n-        assert decode_component(\"%2B\") == ~\"+\";\n-        assert decode_component(\"%2C\") == ~\",\";\n-        assert decode_component(\"%2F\") == ~\"/\";\n-        assert decode_component(\"%3A\") == ~\":\";\n-        assert decode_component(\"%3B\") == ~\";\";\n-        assert decode_component(\"%3D\") == ~\"=\";\n-        assert decode_component(\"%3F\") == ~\"?\";\n-        assert decode_component(\"%40\") == ~\"@\";\n-        assert decode_component(\"%5B\") == ~\"[\";\n-        assert decode_component(\"%5D\") == ~\"]\";\n+        fail_unless!(decode_component(\"\") == ~\"\");\n+        fail_unless!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n+        fail_unless!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n+        fail_unless!(decode_component(\"%20\") == ~\" \");\n+        fail_unless!(decode_component(\"%21\") == ~\"!\");\n+        fail_unless!(decode_component(\"%22\") == ~\"\\\"\");\n+        fail_unless!(decode_component(\"%23\") == ~\"#\");\n+        fail_unless!(decode_component(\"%24\") == ~\"$\");\n+        fail_unless!(decode_component(\"%25\") == ~\"%\");\n+        fail_unless!(decode_component(\"%26\") == ~\"&\");\n+        fail_unless!(decode_component(\"%27\") == ~\"'\");\n+        fail_unless!(decode_component(\"%28\") == ~\"(\");\n+        fail_unless!(decode_component(\"%29\") == ~\")\");\n+        fail_unless!(decode_component(\"%2A\") == ~\"*\");\n+        fail_unless!(decode_component(\"%2B\") == ~\"+\");\n+        fail_unless!(decode_component(\"%2C\") == ~\",\");\n+        fail_unless!(decode_component(\"%2F\") == ~\"/\");\n+        fail_unless!(decode_component(\"%3A\") == ~\":\");\n+        fail_unless!(decode_component(\"%3B\") == ~\";\");\n+        fail_unless!(decode_component(\"%3D\") == ~\"=\");\n+        fail_unless!(decode_component(\"%3F\") == ~\"?\");\n+        fail_unless!(decode_component(\"%40\") == ~\"@\");\n+        fail_unless!(decode_component(\"%5B\") == ~\"[\");\n+        fail_unless!(decode_component(\"%5D\") == ~\"]\");\n     }\n \n     #[test]\n     pub fn test_encode_form_urlencoded() {\n         let mut m = LinearMap::new();\n-        assert encode_form_urlencoded(&m) == ~\"\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"\");\n \n         m.insert(~\"\", ~[]);\n         m.insert(~\"foo\", ~[]);\n-        assert encode_form_urlencoded(&m) == ~\"\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"\");\n \n         let mut m = LinearMap::new();\n         m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n-        assert encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\");\n \n         let mut m = LinearMap::new();\n         m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n-        assert encode_form_urlencoded(&m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n+        fail_unless!(encode_form_urlencoded(&m) ==\n+            ~\"foo+bar=abc&foo+bar=12+%3D+34\");\n     }\n \n     #[test]\n     pub fn test_decode_form_urlencoded() {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*\n-        assert decode_form_urlencoded(~[]).len() == 0;\n+        fail_unless!(decode_form_urlencoded(~[]).len() == 0);\n \n         let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n         let form = decode_form_urlencoded(s);\n-        assert form.len() == 2;\n-        assert form.get_ref(&~\"a\") == &~[~\"1\"];\n-        assert form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"];\n+        fail_unless!(form.len() == 2);\n+        fail_unless!(form.get_ref(&~\"a\") == &~[~\"1\"]);\n+        fail_unless!(form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"]);\n         */\n     }\n }"}, {"sha": "0f6434f1b2ba5f3adaddaf9faa563ccba494a7df", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -427,59 +427,59 @@ mod tests {\n         debug!(\"uint -> uint\");\n         let hm_uu: HashMap<uint, uint> =\n             HashMap::<uint, uint>();\n-        assert (hm_uu.insert(10u, 12u));\n-        assert (hm_uu.insert(11u, 13u));\n-        assert (hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(&11) == 13u);\n-        assert (hm_uu.get(&12) == 14u);\n-        assert (hm_uu.get(&10) == 12u);\n-        assert (!hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(&12) == 14u);\n-        assert (!hm_uu.insert(12u, 12u));\n-        assert (hm_uu.get(&12) == 12u);\n+        fail_unless!((hm_uu.insert(10u, 12u)));\n+        fail_unless!((hm_uu.insert(11u, 13u)));\n+        fail_unless!((hm_uu.insert(12u, 14u)));\n+        fail_unless!((hm_uu.get(&11) == 13u));\n+        fail_unless!((hm_uu.get(&12) == 14u));\n+        fail_unless!((hm_uu.get(&10) == 12u));\n+        fail_unless!((!hm_uu.insert(12u, 14u)));\n+        fail_unless!((hm_uu.get(&12) == 14u));\n+        fail_unless!((!hm_uu.insert(12u, 12u)));\n+        fail_unless!((hm_uu.get(&12) == 12u));\n         let ten: ~str = ~\"ten\";\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n         debug!(\"str -> uint\");\n         let hm_su: HashMap<~str, uint> =\n             HashMap::<~str, uint>();\n-        assert (hm_su.insert(~\"ten\", 12u));\n-        assert (hm_su.insert(eleven, 13u));\n-        assert (hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(&eleven) == 13u);\n-        assert (hm_su.get(&~\"eleven\") == 13u);\n-        assert (hm_su.get(&~\"twelve\") == 14u);\n-        assert (hm_su.get(&~\"ten\") == 12u);\n-        assert (!hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(&~\"twelve\") == 14u);\n-        assert (!hm_su.insert(~\"twelve\", 12u));\n-        assert (hm_su.get(&~\"twelve\") == 12u);\n+        fail_unless!((hm_su.insert(~\"ten\", 12u)));\n+        fail_unless!((hm_su.insert(eleven, 13u)));\n+        fail_unless!((hm_su.insert(~\"twelve\", 14u)));\n+        fail_unless!((hm_su.get(&eleven) == 13u));\n+        fail_unless!((hm_su.get(&~\"eleven\") == 13u));\n+        fail_unless!((hm_su.get(&~\"twelve\") == 14u));\n+        fail_unless!((hm_su.get(&~\"ten\") == 12u));\n+        fail_unless!((!hm_su.insert(~\"twelve\", 14u)));\n+        fail_unless!((hm_su.get(&~\"twelve\") == 14u));\n+        fail_unless!((!hm_su.insert(~\"twelve\", 12u)));\n+        fail_unless!((hm_su.get(&~\"twelve\") == 12u));\n         debug!(\"uint -> str\");\n         let hm_us: HashMap<uint, ~str> =\n             HashMap::<uint, ~str>();\n-        assert (hm_us.insert(10u, ~\"twelve\"));\n-        assert (hm_us.insert(11u, ~\"thirteen\"));\n-        assert (hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(&11) == ~\"thirteen\";\n-        assert hm_us.get(&12) == ~\"fourteen\";\n-        assert hm_us.get(&10) == ~\"twelve\";\n-        assert (!hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(&12) == ~\"fourteen\";\n-        assert (!hm_us.insert(12u, ~\"twelve\"));\n-        assert hm_us.get(&12) == ~\"twelve\";\n+        fail_unless!((hm_us.insert(10u, ~\"twelve\")));\n+        fail_unless!((hm_us.insert(11u, ~\"thirteen\")));\n+        fail_unless!((hm_us.insert(12u, ~\"fourteen\")));\n+        fail_unless!(hm_us.get(&11) == ~\"thirteen\");\n+        fail_unless!(hm_us.get(&12) == ~\"fourteen\");\n+        fail_unless!(hm_us.get(&10) == ~\"twelve\");\n+        fail_unless!((!hm_us.insert(12u, ~\"fourteen\")));\n+        fail_unless!(hm_us.get(&12) == ~\"fourteen\");\n+        fail_unless!((!hm_us.insert(12u, ~\"twelve\")));\n+        fail_unless!(hm_us.get(&12) == ~\"twelve\");\n         debug!(\"str -> str\");\n         let hm_ss: HashMap<~str, ~str> =\n             HashMap::<~str, ~str>();\n-        assert (hm_ss.insert(ten, ~\"twelve\"));\n-        assert (hm_ss.insert(eleven, ~\"thirteen\"));\n-        assert (hm_ss.insert(twelve, ~\"fourteen\"));\n-        assert hm_ss.get(&~\"eleven\") == ~\"thirteen\";\n-        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n-        assert hm_ss.get(&~\"ten\") == ~\"twelve\";\n-        assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n-        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n-        assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n-        assert hm_ss.get(&~\"twelve\") == ~\"twelve\";\n+        fail_unless!((hm_ss.insert(ten, ~\"twelve\")));\n+        fail_unless!((hm_ss.insert(eleven, ~\"thirteen\")));\n+        fail_unless!((hm_ss.insert(twelve, ~\"fourteen\")));\n+        fail_unless!(hm_ss.get(&~\"eleven\") == ~\"thirteen\");\n+        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"fourteen\");\n+        fail_unless!(hm_ss.get(&~\"ten\") == ~\"twelve\");\n+        fail_unless!((!hm_ss.insert(~\"twelve\", ~\"fourteen\")));\n+        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"fourteen\");\n+        fail_unless!((!hm_ss.insert(~\"twelve\", ~\"twelve\")));\n+        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"twelve\");\n         debug!(\"*** finished test_simple\");\n     }\n \n@@ -498,33 +498,33 @@ mod tests {\n             HashMap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n-            assert (hm_uu.insert(i, i * i));\n+            fail_unless!((hm_uu.insert(i, i * i)));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            assert (hm_uu.get(&i) == i * i);\n+            fail_unless!((hm_uu.get(&i) == i * i));\n             i += 1u;\n         }\n-        assert (hm_uu.insert(num_to_insert, 17u));\n-        assert (hm_uu.get(&num_to_insert) == 17u);\n+        fail_unless!((hm_uu.insert(num_to_insert, 17u)));\n+        fail_unless!((hm_uu.get(&num_to_insert) == 17u));\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            assert (hm_uu.get(&i) == i * i);\n+            fail_unless!((hm_uu.get(&i) == i * i));\n             i += 1u;\n         }\n         debug!(\"str -> str\");\n         let hm_ss: HashMap<~str, ~str> =\n             HashMap::<~str, ~str>();\n         i = 0u;\n         while i < num_to_insert {\n-            assert hm_ss.insert(uint::to_str_radix(i, 2u),\n-                                uint::to_str_radix(i * i, 2u));\n+            fail_unless!(hm_ss.insert(uint::to_str_radix(i, 2u),\n+                                uint::to_str_radix(i * i, 2u)));\n             debug!(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n                    uint::to_str_radix(i*i, 2u));\n@@ -536,22 +536,22 @@ mod tests {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n                    hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n-                             uint::to_str_radix(i * i, 2u);\n+            fail_unless!(hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n+                             uint::to_str_radix(i * i, 2u));\n             i += 1u;\n         }\n-        assert (hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n+        fail_unless!(hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n                              uint::to_str_radix(17u, 2u)));\n-        assert hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n-            uint::to_str_radix(17u, 2u);\n+        fail_unless!(hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n+            uint::to_str_radix(17u, 2u));\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n                    hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n-                             uint::to_str_radix(i * i, 2u);\n+            fail_unless!(hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n+                             uint::to_str_radix(i * i, 2u));\n             i += 1u;\n         }\n         debug!(\"*** finished test_growth\");\n@@ -565,55 +565,55 @@ mod tests {\n             HashMap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n-            assert (hm.insert(i, i * i));\n+            fail_unless!((hm.insert(i, i * i)));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n-        assert (hm.len() == num_to_insert);\n+        fail_unless!((hm.len() == num_to_insert));\n         debug!(\"-----\");\n         debug!(\"removing evens\");\n         i = 0u;\n         while i < num_to_insert {\n             let v = hm.remove(&i);\n-            assert v;\n+            fail_unless!(v);\n             i += 2u;\n         }\n-        assert (hm.len() == num_to_insert / 2u);\n+        fail_unless!((hm.len() == num_to_insert / 2u));\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 2u;\n         }\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 2u;\n         }\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            assert (hm.insert(i, i * i));\n+            fail_unless!((hm.insert(i, i * i)));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 2u;\n         }\n-        assert (hm.len() == num_to_insert);\n+        fail_unless!((hm.len() == num_to_insert));\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 1u;\n         }\n         debug!(\"-----\");\n-        assert (hm.len() == num_to_insert);\n+        fail_unless!((hm.len() == num_to_insert));\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 1u;\n         }\n         debug!(\"*** finished test_removal\");\n@@ -623,30 +623,30 @@ mod tests {\n     fn test_contains_key() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert (!map.contains_key(&key));\n+        fail_unless!((!map.contains_key(&key)));\n         map.insert(key, ~\"val\");\n-        assert (map.contains_key(&key));\n+        fail_unless!((map.contains_key(&key)));\n     }\n \n     #[test]\n     fn test_find() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert map.find(&key).is_none();\n+        fail_unless!(map.find(&key).is_none());\n         map.insert(key, ~\"val\");\n-        assert map.find(&key).get() == ~\"val\";\n+        fail_unless!(map.find(&key).get() == ~\"val\");\n     }\n \n     #[test]\n     fn test_clear() {\n         let key = ~\"k\";\n         let mut map = HashMap::<~str, ~str>();\n         map.insert(key, ~\"val\");\n-        assert (map.len() == 1);\n-        assert (map.contains_key(&key));\n+        fail_unless!((map.len() == 1));\n+        fail_unless!((map.contains_key(&key)));\n         map.clear();\n-        assert (map.len() == 0);\n-        assert (!map.contains_key(&key));\n+        fail_unless!((map.len() == 0));\n+        fail_unless!((!map.contains_key(&key)));\n     }\n \n     #[test]\n@@ -656,10 +656,10 @@ mod tests {\n             (~\"b\", 2),\n             (~\"c\", 3)\n         ]);\n-        assert map.len() == 3u;\n-        assert map.get(&~\"a\") == 1;\n-        assert map.get(&~\"b\") == 2;\n-        assert map.get(&~\"c\") == 3;\n+        fail_unless!(map.len() == 3u);\n+        fail_unless!(map.get(&~\"a\") == 1);\n+        fail_unless!(map.get(&~\"b\") == 2);\n+        fail_unless!(map.get(&~\"c\") == 3);\n     }\n \n     #[test]\n@@ -685,11 +685,11 @@ mod tests {\n         map.update_with_key(~\"cat\",      2, addMoreToCount);\n \n         // check the total counts\n-        assert map.find(&~\"cat\").get() == 10;\n-        assert map.find(&~\"ferret\").get() == 3;\n-        assert map.find(&~\"mongoose\").get() == 1;\n+        fail_unless!(map.find(&~\"cat\").get() == 10);\n+        fail_unless!(map.find(&~\"ferret\").get() == 3);\n+        fail_unless!(map.find(&~\"mongoose\").get() == 1);\n \n         // sadly, no mythical animals were counted!\n-        assert map.find(&~\"unicorn\").is_none();\n+        fail_unless!(map.find(&~\"unicorn\").is_none());\n     }\n }"}, {"sha": "a33effba8e0cf86f35b71830479784fdbac51916", "filename": "src/libstd/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -68,7 +68,7 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n                             cast::reinterpret_cast(&slice);\n                         log(info, fmt!(\"slice: %?\",\n                                        (base, vec::len(slice), end - base)));\n-                        assert(vec::len(slice) == end - base);\n+                        fail_unless!((vec::len(slice) == end - base));\n                         f(base, slice)\n                     }\n                 };\n@@ -79,12 +79,12 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n         log(info, ~\"tasks spawned\");\n \n         log(info, fmt!(\"num_tasks: %?\", (num_tasks, futures.len())));\n-        assert(num_tasks == futures.len());\n+        fail_unless!((num_tasks == futures.len()));\n \n         let r = do futures.map() |ys| {\n             ys.get()\n         };\n-        assert(r.len() == futures.len());\n+        fail_unless!((r.len() == futures.len()));\n         r\n     }\n }\n@@ -115,7 +115,7 @@ pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n     });\n     let r = vec::concat(slices);\n     log(info, (r.len(), xs.len()));\n-    assert(r.len() == xs.len());\n+    fail_unless!((r.len() == xs.len()));\n     r\n }\n "}, {"sha": "676bc68e4e513af44be76e6295478a385747915a", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -197,87 +197,87 @@ mod tests {\n         let mut sorted = merge_sort(data, le);\n         let mut heap = from_vec(data);\n         while !heap.is_empty() {\n-            assert heap.top() == sorted.last();\n-            assert heap.pop() == sorted.pop();\n+            fail_unless!(heap.top() == sorted.last());\n+            fail_unless!(heap.pop() == sorted.pop());\n         }\n     }\n \n     #[test]\n     fn test_push() {\n         let mut heap = from_vec(~[2, 4, 9]);\n-        assert heap.len() == 3;\n-        assert *heap.top() == 9;\n+        fail_unless!(heap.len() == 3);\n+        fail_unless!(*heap.top() == 9);\n         heap.push(11);\n-        assert heap.len() == 4;\n-        assert *heap.top() == 11;\n+        fail_unless!(heap.len() == 4);\n+        fail_unless!(*heap.top() == 11);\n         heap.push(5);\n-        assert heap.len() == 5;\n-        assert *heap.top() == 11;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(*heap.top() == 11);\n         heap.push(27);\n-        assert heap.len() == 6;\n-        assert *heap.top() == 27;\n+        fail_unless!(heap.len() == 6);\n+        fail_unless!(*heap.top() == 27);\n         heap.push(3);\n-        assert heap.len() == 7;\n-        assert *heap.top() == 27;\n+        fail_unless!(heap.len() == 7);\n+        fail_unless!(*heap.top() == 27);\n         heap.push(103);\n-        assert heap.len() == 8;\n-        assert *heap.top() == 103;\n+        fail_unless!(heap.len() == 8);\n+        fail_unless!(*heap.top() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = from_vec(~[~2, ~4, ~9]);\n-        assert heap.len() == 3;\n-        assert *heap.top() == ~9;\n+        fail_unless!(heap.len() == 3);\n+        fail_unless!(*heap.top() == ~9);\n         heap.push(~11);\n-        assert heap.len() == 4;\n-        assert *heap.top() == ~11;\n+        fail_unless!(heap.len() == 4);\n+        fail_unless!(*heap.top() == ~11);\n         heap.push(~5);\n-        assert heap.len() == 5;\n-        assert *heap.top() == ~11;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(*heap.top() == ~11);\n         heap.push(~27);\n-        assert heap.len() == 6;\n-        assert *heap.top() == ~27;\n+        fail_unless!(heap.len() == 6);\n+        fail_unless!(*heap.top() == ~27);\n         heap.push(~3);\n-        assert heap.len() == 7;\n-        assert *heap.top() == ~27;\n+        fail_unless!(heap.len() == 7);\n+        fail_unless!(*heap.top() == ~27);\n         heap.push(~103);\n-        assert heap.len() == 8;\n-        assert *heap.top() == ~103;\n+        fail_unless!(heap.len() == 8);\n+        fail_unless!(*heap.top() == ~103);\n     }\n \n     #[test]\n     fn test_push_pop() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        assert heap.len() == 5;\n-        assert heap.push_pop(6) == 6;\n-        assert heap.len() == 5;\n-        assert heap.push_pop(0) == 5;\n-        assert heap.len() == 5;\n-        assert heap.push_pop(4) == 5;\n-        assert heap.len() == 5;\n-        assert heap.push_pop(1) == 4;\n-        assert heap.len() == 5;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(6) == 6);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(0) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(4) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(1) == 4);\n+        fail_unless!(heap.len() == 5);\n     }\n \n     #[test]\n     fn test_replace() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        assert heap.len() == 5;\n-        assert heap.replace(6) == 5;\n-        assert heap.len() == 5;\n-        assert heap.replace(0) == 6;\n-        assert heap.len() == 5;\n-        assert heap.replace(4) == 5;\n-        assert heap.len() == 5;\n-        assert heap.replace(1) == 4;\n-        assert heap.len() == 5;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(6) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(0) == 6);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(4) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(1) == 4);\n+        fail_unless!(heap.len() == 5);\n     }\n \n     fn check_to_vec(data: ~[int]) {\n         let heap = from_vec(data);\n-        assert merge_sort(heap.to_vec(), le) == merge_sort(data, le);\n-        assert heap.to_sorted_vec() == merge_sort(data, le);\n+        fail_unless!(merge_sort(heap.to_vec(), le) == merge_sort(data, le));\n+        fail_unless!(heap.to_sorted_vec() == merge_sort(data, le));\n     }\n \n     #[test]\n@@ -305,7 +305,7 @@ mod tests {\n     #[test]\n     fn test_empty_maybe_pop() {\n         let mut heap = new::<int>();\n-        assert heap.maybe_pop().is_none();\n+        fail_unless!(heap.maybe_pop().is_none());\n     }\n \n     #[test]\n@@ -316,7 +316,7 @@ mod tests {\n     #[test]\n     fn test_empty_maybe_top() {\n         let empty = new::<int>();\n-        assert empty.maybe_top().is_none();\n+        fail_unless!(empty.maybe_top().is_none());\n     }\n \n     #[test]"}, {"sha": "b2b30c1057ef971d970b14be13168a684c1f5c87", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -16,14 +16,18 @@ use core::prelude::*;\n use core::str;\n use core::task;\n \n-extern mod rustrt {\n-    pub unsafe fn linenoise(prompt: *c_char) -> *c_char;\n-    pub unsafe fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n-    pub unsafe fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n-    pub unsafe fn linenoiseHistorySave(file: *c_char) -> c_int;\n-    pub unsafe fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n-    pub unsafe fn linenoiseSetCompletionCallback(callback: *u8);\n-    pub unsafe fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+pub mod rustrt {\n+    use core::libc::{c_char, c_int};\n+\n+    pub extern {\n+        pub unsafe fn linenoise(prompt: *c_char) -> *c_char;\n+        pub unsafe fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n+        pub unsafe fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n+        pub unsafe fn linenoiseHistorySave(file: *c_char) -> c_int;\n+        pub unsafe fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n+        pub unsafe fn linenoiseSetCompletionCallback(callback: *u8);\n+        pub unsafe fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+    }\n }\n \n /// Add a line to history"}, {"sha": "d511ac9744eb385bd0dd9de5be9492c25e0276d8", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -704,7 +704,7 @@ pub mod node {\n      */\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n-        assert(byte_start + byte_len <= str::len(*str));\n+        fail_unless!((byte_start + byte_len <= str::len(*str)));\n         let candidate = @Leaf(Leaf {\n             byte_offset: byte_start,\n             byte_len: byte_len,\n@@ -1313,17 +1313,17 @@ mod tests {\n \n     #[test]\n     fn trivial() {\n-        assert char_len(empty()) == 0u;\n-        assert byte_len(empty()) == 0u;\n+        fail_unless!(char_len(empty()) == 0u);\n+        fail_unless!(byte_len(empty()) == 0u);\n     }\n \n     #[test]\n     fn of_string1() {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert char_len(r) == str::char_len(*sample);\n-        assert rope_to_string(r) == *sample;\n+        fail_unless!(char_len(r) == str::char_len(*sample));\n+        fail_unless!(rope_to_string(r) == *sample);\n     }\n \n     #[test]\n@@ -1338,8 +1338,8 @@ mod tests {\n         }\n         let sample = @*buf;\n         let r      = of_str(sample);\n-        assert char_len(r) == str::char_len(*sample);\n-        assert rope_to_string(r) == *sample;\n+        fail_unless!(char_len(r) == str::char_len(*sample));\n+        fail_unless!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n         let string_len  = str::len(*sample);\n@@ -1359,7 +1359,7 @@ mod tests {\n             }\n         }\n \n-        assert equal;\n+        fail_unless!(equal);\n     }\n \n     #[test]\n@@ -1384,7 +1384,7 @@ mod tests {\n             }\n         }\n \n-        assert len == str::char_len(*sample);\n+        fail_unless!(len == str::char_len(*sample));\n     }\n \n     #[test]\n@@ -1405,11 +1405,11 @@ mod tests {\n         while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n \n \n-        assert eq(r1, r2);\n+        fail_unless!(eq(r1, r2));\n         let r3 = bal(r2);\n-        assert char_len(r1) == char_len(r3);\n+        fail_unless!(char_len(r1) == char_len(r3));\n \n-        assert eq(r1, r3);\n+        fail_unless!(eq(r1, r3));\n     }\n \n     #[test]\n@@ -1426,23 +1426,23 @@ mod tests {\n         for uint::range(0u, char_len(r)) |i| {\n             r2 = append_char(r2, char_at(r, i));\n         }\n-        assert eq(r, r2);\n+        fail_unless!(eq(r, r2));\n \n         let mut r3 = empty();\n         for uint::range(0u, char_len(r)) |i| {\n             r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n         }\n-        assert eq(r, r3);\n+        fail_unless!(eq(r, r3));\n \n         //Additional sanity checks\n         let balr = bal(r);\n         let bal2 = bal(r2);\n         let bal3 = bal(r3);\n-        assert eq(r, balr);\n-        assert eq(r, bal2);\n-        assert eq(r, bal3);\n-        assert eq(r2, r3);\n-        assert eq(bal2, bal3);\n+        fail_unless!(eq(r, balr));\n+        fail_unless!(eq(r, bal2));\n+        fail_unless!(eq(r, bal3));\n+        fail_unless!(eq(r2, r3));\n+        fail_unless!(eq(bal2, bal3));\n     }\n \n     #[test]\n@@ -1457,6 +1457,6 @@ mod tests {\n         //Same rope, obtained with rope::concat\n         let r2 = concat(vec::from_elem(10u, chunk));\n \n-        assert eq(r, r2);\n+        fail_unless!(eq(r, r2));\n     }\n }"}, {"sha": "bf4091e1e902d593d4a17fa84803121172df5cac", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b1ef0233d97e2e4afe7bd3e9c3dde0047c4e6573", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "84600ac74eeb94da3d488605f4dbfcb293402a2f", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "37be1c86e917b3a6166eff58004bad367eb38bb9", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "2a62ebadd2b73d5b31498084cf1a278fb6b48231", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "d143c665d8310a22c6b078cdf9d55c33e27db878", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "09cab72ab21735f6bc099d5b1a24e50898588cea", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "cd023962c8846e49347038a975ef272f4a5db454", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "fb63755a572ee555551a2bd0273dee1f5641e940", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "7286ce5e2bdff5b32e629dc8a72e5272a33da2e2", "filename": "src/libstd/test.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "d6e19515ba6552afd94cd36d2dc32346367f33e7", "filename": "src/libstd/time.rs", "status": "modified", "additions": 204, "deletions": 196, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "60469d0b0f2359ddc4ac78a395fd66084b0ea538", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "f06f64dde010b6e53667500d26d5758e066a31ac", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 215, "deletions": 214, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b3581e2690c8a0d9f5d689b2f06054c9b66e7732", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "522a613f02d4fe0102779ec93779ad681ae625b4", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "fa415e0875b3e09f7654b1f3f86db6ca0ebfc20b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 166, "deletions": 153, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "a6ccd69dd06558d4506c217888f9b1fce497ea32", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "686ae3900ff43e4d249f885141cf22ddb3f94419", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "a525c0df5fa08eb38c4d1083cad22667a012e10d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "5d071b8d517f3a48ba7b6b62e49ab551fe2d8a75", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "f76f10f3de16c4ee805f8f5b9cb02afcd71b1dd7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "8a8583420f8fc9c55d7f112357cb0d988b4dda6c", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "001e1b0daf63fe8a96894ca01f62a81d7fe9a523", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "c66e726bbf772672570c17bea4e1884f87da56c3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b8371c9e8d9623918a26830b0116ab42d3548ddd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "494ef3a81a0d2aa641d4de91979f914aff041690", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "ab57d177112936cf81459bd4ba89cfe3155e89a4", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "48d3fbe8889e1356018e35012083a3904dec0be3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "6f2d2c554aa93f020e901c883393363affb6fb7a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "384cf4f0e95179ce49c7bbb38e0fb4b9b9ae4051", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 42, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "8557ef22fc61231458cc96d17b6178df6c7c6f37", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "4a8176abc6f1d5a1974554c11fdc1d864a423c6c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 57, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "2c852084aa7eddfe463c8e683c0c5ecd0ac6f5b4", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "6048256b90bfeb8d6760c37fd977632d993d6fe7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "d8c97218d6fedd01f2719e011035c25ee859c10e", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "d59057f01f2de7e5c24ec207c17eb4c2557f5563", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "1561ec51ede0e0a3aec843091052a9452395df02", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "63275a05598eb94ffa186408215552778bce7200", "filename": "src/test/auxiliary/issue_3882.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fissue_3882.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fauxiliary%2Fissue_3882.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3882.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "a1896c660eb6f71392786bbf33600d49d43d6e3a", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "ab441277c62a3382739d9dc22aa43dcdf98a8aea", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "4117add8926a0cda2058a8babc0917fe4c91d148", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "9efcc05e9964fcdb5017e12dd2b28c45581dd9cb", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "5ae1f796304324470d4d6ca1b8603be2735d366f", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "db1aaf9bcdbd4d185f7f75fb9ee5f414b8d28de5", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "6ce9fce881a6a6d73a733b919a9bbaf3b9649094", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "77cd7890f2987150b4f580de334a43dc4adb0779", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "930e3d8a6089812b27593924be101cccc2bfc578", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "78234ca0dfa22197c3915cb5281a3f3e92dd72e0", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "de58ae8ab0d3a24ecfa5834fd02e124799f1dd67", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "1e21af7b3f054d8761ff0f94a21d283532b9affe", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b1375cc7980c84c7cb0d7cf1cebd68487ca1dc7a", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "25ae03087321b8c59549e95edbbb556e4ad14b7c", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "4a90d2f4b7fcf7caef2bd5f3c2257c15ce0d2698", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "1ef5ae1607957e7655b99b1be657f9a4c2086fd7", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "9c175ed42b6654a846885ed4109a134a2a2ed07c", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "e56a179e7741e9bf23bcda8b5f0330cee1a35a14", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b5c8f509167e324ffe2e74ad30b538254ddc43c9", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "914b5caa01139767339d8a75c53736a2019871aa", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "2cf363e13ee09d4893a53569667ae1ccaebda3fd", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "1c2a3e1742672239ecaa23882d86d1d87cf50765", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b8c2274076c3331cdc4204bf5c6b83e2a0ef2c82", "filename": "src/test/compile-fail/crateresolve5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "89821f97513960e1f8c48520cd04ffa8648798ce", "filename": "src/test/compile-fail/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "e5c304efd671fa75cb28ab6f1c3fbc318b6f6c84", "filename": "src/test/compile-fail/empty-linkname.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-linkname.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "30ad2c361b1f1910136f709a59e909f4bfee06b5", "filename": "src/test/compile-fail/empty-linkname2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fempty-linkname2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fempty-linkname2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-linkname2.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "952bf8c060a8afe715cee4112fdf5e08e0575c2d", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "9122abab713214a418b9718d9128525732ddbab1", "filename": "src/test/compile-fail/foreign-unsafe-fn-called.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "32fafe296466c135cacaa445ed587136bed9f020", "filename": "src/test/compile-fail/foreign-unsafe-fn.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "5cd1eb874713da0399d2e1f4eb356cfbb652c0d6", "filename": "src/test/compile-fail/issue-1763.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1763.rs?ref=ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7"}, {"sha": "bf130addb6bf6fb057d28a653adba25854d7795a", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "6d31deea3ff35ebcc29f7f25824b544e26d61b95", "filename": "src/test/compile-fail/issue-2467.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "83fdb86628b65415c1e8fffb1baedbd6d64b1430", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "5e6fa6e95f87d9d212ca5261d4fa58b2c69ad204", "filename": "src/test/compile-fail/issue-2969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "4efbec92948e10358238cc38c75048d38d65607d", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "117156748ae7c974ca9ad7d8f417e15697ef1534", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "00425825e3ff2cb2487391215623609e68d03968", "filename": "src/test/compile-fail/issue-3296.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3296.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3296.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3296.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "779265e5a292fe3a65f2574d2d1aedf582016494", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "632b15dadd46b1912cfefd4e2cf0e3df6665ba84", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "0de7276fc8cd32ddb088645e922e1a5e10c90799", "filename": "src/test/compile-fail/issue-818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fissue-818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-818.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "e0651a68fa9d45bca4f6c4dc73c13207b2e8e024", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "fbbac6e0a641a81e70bbdad5269c872b043f997e", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "cdd3b19f0ae37d362753826ad9375f6aa62dacaf", "filename": "src/test/compile-fail/main-wrong-type.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "832e6d8a6a79a77f55835d3f0218dc1c6714119e", "filename": "src/test/compile-fail/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "d742ad04d768c18c38bc1b38d9371f762e6cf5f8", "filename": "src/test/compile-fail/mod_file_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "2f71f4d22f903c8b567f3641f771412905dcf77f", "filename": "src/test/compile-fail/mod_file_with_path_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "fd15321e1d02bfe7b3487c52c93c9ba767042e6f", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "6d79e23e999a7893da0d4679d36c36ac96dc4133", "filename": "src/test/compile-fail/mutable-huh-variance-rec.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs?ref=ceeccf8aeafbae7387c5b69743ff0ca8bfe86dd7"}, {"sha": "a0c1bf040e317668331dadf37f0814b04db32e52", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "4cb78e7032bcb698ccd62fbadc753d709475222d", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "77e6432f9969be9f95af8d7aa83020f96895d179", "filename": "src/test/compile-fail/nolink-with-link-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fnolink-with-link-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fnolink-with-link-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnolink-with-link-args.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "0623f93a38bfb0a129ef7969d565669709f0c970", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "0ab53da0c4ae7fd08e9c5836b099d549677d66a4", "filename": "src/test/compile-fail/omitted-arg-wrong-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "1df102a751a3cc598298b9b602ec093ddfe4a8e1", "filename": "src/test/compile-fail/private-struct-field-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "86a14587006ecf8ae22279f6109bae3334de5f1c", "filename": "src/test/compile-fail/private-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "e5638e11ae91899eb9e4852c1ffa02cf680a80b0", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "43a54981dcb7126ee49e0d76968305cf0081f95c", "filename": "src/test/compile-fail/pure-loop-body.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b0f080f360ba5262e678b2fb03bfa8cc648afbda", "filename": "src/test/compile-fail/redundant-link-args.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fredundant-link-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fredundant-link-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fredundant-link-args.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "f5e304dbe722c51c7e174aee637456992ff3562c", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "2a72744c9b6fe50ef4bec845218ce73e2d8ba03c", "filename": "src/test/compile-fail/regions-in-type-items.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "82d75bcf5db747d39e2f2a6dcc3a196b9687d5f6", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "59329195b712cacf9b96653ca0d5e38f40696a78", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "7b2a760270c5cd0795d0458afc071fa155218256", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "f4e41d951aa2aab4d30c4fc5b5053f16f6ecef01", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "cd395fe4dd15a6e5a73c1cfc5ada3e73153975b4", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "b13835a89d4f834177fed8546755d8ec6dafa91f", "filename": "src/test/compile-fail/tag-type-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "6474a58c1cdb98a5b53691974989c42d32c10c26", "filename": "src/test/compile-fail/terr-in-field.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fterr-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fterr-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-in-field.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "ad14688f08c62d5dd0be869e6e64cc15573bd0c2", "filename": "src/test/compile-fail/terr-sorts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "a2b4e8d9782fd7a84ebf6754daece3991e0f6201", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "c825118fa984cacb69b8214e6d4642e7a4420b44", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "adec8dc6d0d9da7616d897b72f2e7ff86629f00d", "filename": "src/test/compile-fail/warn-ctypes-err-attr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fwarn-ctypes-err-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fwarn-ctypes-err-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-ctypes-err-attr.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "28d21bb94290453635d977283f71a154ee401d5b", "filename": "src/test/compile-fail/warn-ctypes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fwarn-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fwarn-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-ctypes.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "e5c2603c569148e224be7db09b04699eadcaca89", "filename": "src/test/compile-fail/warn-foreign-int-types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "67253c9753ede7388ba65276199eb0f97e8e3227", "filename": "src/test/pretty/alt-naked-expr-long.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe"}]}