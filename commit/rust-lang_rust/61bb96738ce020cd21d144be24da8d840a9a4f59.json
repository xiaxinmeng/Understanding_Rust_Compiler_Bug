{"sha": "61bb96738ce020cd21d144be24da8d840a9a4f59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYmI5NjczOGNlMDIwY2QyMWQxNDRiZTI0ZGE4ZDg0MGE5YTRmNTk=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-02T11:38:17Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-02T11:38:17Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup2", "tree": {"sha": "9f5fed09b6f7691952fd13d97af18efd31b1f817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f5fed09b6f7691952fd13d97af18efd31b1f817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61bb96738ce020cd21d144be24da8d840a9a4f59", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmEwt7QACgkQHKDfKvWd\naKV9ehAAme5AADZh4+midHVEAKbpB9SHsAOhQWCno377Ad6Cvk1012naquI6jhlG\n0YkTL/SIvl5IeVRgtg7fyq1RbJtbtwUXFA1mX70HMZMT1YJiltTI36HdbPE+QysF\nR5Rh6VXBoIR8kcLB3q1+OGzKACWoBiOHHddmL9/UKbO//fzGFBNiJyszh/NlAVV9\n3Naf66PNI7VQGim/oMiCUpO5aWS81swMg47Dl3SDEDsedqeEQkRSWuz8Q2oM9b9i\nBYvnUbFDHCYed9TX3Ht627eUJpCCUYlqVeFSsw8BAIfmUxTPwFrkkyqQ/ibWbT+1\nH0YaASmpXPG1BRXL/30L6qmNG0Zu2BL2tL8xvA9vQQVhPoPJlPjYyKCIytpq0tkt\nODEtPiZogcwyC08yT78fL5DrVt+fi8+pYPvhsSwwGR+060zBBVjeNbCzhfLIbNTL\n8HAsYcmL0o9HrUU1gXyCsWn+TTZ/NHUJPsLKbEer6l4OyLlIUCfuN0FIWvc3DgT1\nzOtW6XJUj1ISuKHtGrqQ9aGzRY8vUEHgKkbKf1QutGSJ1CKWqa6Cm/gEMfW5J14k\nQuC/AICuiKhOZ+Zf+fhW5BN2dqULB4eGUMYoOFAjms3ZlXN3lfhIXkHFWL3r5wbt\nv6AezH/OPKrz45NK+e4r+th4m0yaA/IymhmjH4Cf5+n4x54uLu4=\n=2MuO\n-----END PGP SIGNATURE-----", "payload": "tree 9f5fed09b6f7691952fd13d97af18efd31b1f817\nparent 78bf4acc3a18848e21896bae97859c5811b320d4\nparent 849f0a144b019f0484c557d19684233ea8eed186\nauthor flip1995 <philipp.krones@embecosm.com> 1630582697 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1630582697 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup2\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61bb96738ce020cd21d144be24da8d840a9a4f59", "html_url": "https://github.com/rust-lang/rust/commit/61bb96738ce020cd21d144be24da8d840a9a4f59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61bb96738ce020cd21d144be24da8d840a9a4f59/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78bf4acc3a18848e21896bae97859c5811b320d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/78bf4acc3a18848e21896bae97859c5811b320d4", "html_url": "https://github.com/rust-lang/rust/commit/78bf4acc3a18848e21896bae97859c5811b320d4"}, {"sha": "849f0a144b019f0484c557d19684233ea8eed186", "url": "https://api.github.com/repos/rust-lang/rust/commits/849f0a144b019f0484c557d19684233ea8eed186", "html_url": "https://github.com/rust-lang/rust/commit/849f0a144b019f0484c557d19684233ea8eed186"}], "stats": {"total": 3155, "additions": 2552, "deletions": 603}, "files": [{"sha": "5d7dfa36f37a2ba220ab26fdb29ee11d07e212d7", "filename": ".github/ISSUE_TEMPLATE/blank_issue.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -2,3 +2,16 @@\n name: Blank Issue\n about: Create a blank issue.\n ---\n+\n+\n+<!--\n+Additional labels can be added to this issue by including the following command:\n+\n+@rustbot label +<label>\n+\n+Common labels for this issue type are:\n+* C-an-interesting-project\n+* C-enhancement\n+* C-question\n+* C-tracking-issue\n+-->"}, {"sha": "41e6abea1c6a5e25f6265c3fbf606343d5d9e5dc", "filename": ".github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -20,28 +20,23 @@ Instead, this happened: *explanation*\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```\n \n <!--\n-Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n-environment. E.g. `RUST_BACKTRACE=1 cargo clippy`.\n+Additional labels can be added to this issue by including the following command:\n+\n+@rustbot label +<label>\n+\n+Common labels for this issue type are:\n+* `I-suggestion-causes-error`\n -->\n-<details><summary>Backtrace</summary>\n-  <p>\n-  \n-  ```\n-  <backtrace>\n-  ```\n-  \n-  </p>\n-</details>"}, {"sha": "d9ea2db34edd7cf74a9789f17801005a3e0762e9", "filename": ".github/ISSUE_TEMPLATE/false_negative.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_negative.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -22,14 +22,14 @@ Instead, this happened: *explanation*\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```"}, {"sha": "edf9e04e3b1a281c80a35397a9e6902401eff36a", "filename": ".github/ISSUE_TEMPLATE/false_positive.md", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -22,14 +22,22 @@ Instead, this happened: *explanation*\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```\n+\n+<!--\n+Additional labels can be added to this issue by including the following command:\n+\n+@rustbot label +<label>\n+\n+Common labels for this issue type are:\n+* I-suggestion-causes-error\n+-->"}, {"sha": "6c1bed663c6cb37f74bb9dfd9f4226560bc8837c", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -20,17 +20,16 @@ http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n \n ### Meta\n \n-- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n-- `rustc -Vv`:\n-  ```\n-  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-  binary: rustc\n-  commit-hash: f455e46eae1a227d735091091144601b467e1565\n-  commit-date: 2020-06-20\n-  host: x86_64-unknown-linux-gnu\n-  release: 1.46.0-nightly\n-  LLVM version: 10.0\n-  ```\n+**Rust version (`rustc -Vv`):**\n+```\n+rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+binary: rustc\n+commit-hash: f455e46eae1a227d735091091144601b467e1565\n+commit-date: 2020-06-20\n+host: x86_64-unknown-linux-gnu\n+release: 1.46.0-nightly\n+LLVM version: 10.0\n+```\n \n ### Error output\n "}, {"sha": "9a5416153abdb62856d4ad34305f806294aa43f9", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -42,9 +42,6 @@ jobs:\n       run: cargo build --features deny-warnings\n       working-directory: clippy_dev\n \n-    - name: Test limit_stderr_length\n-      run: cargo dev limit_stderr_length\n-\n     - name: Test update_lints\n       run: cargo dev update_lints --check\n "}, {"sha": "57088370343716d587a402d7dc7598f13de819e7", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -2712,7 +2712,6 @@ Released 2018-09-13\n [`integer_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic\n [`integer_division`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_division\n [`into_iter_on_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_ref\n-[`invalid_atomic_ordering`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_atomic_ordering\n [`invalid_null_ptr_usage`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_null_ptr_usage\n [`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons\n@@ -2754,6 +2753,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n@@ -2795,6 +2795,7 @@ Released 2018-09-13\n [`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n [`mistyped_literal_suffixes`]: https://rust-lang.github.io/rust-clippy/master/index.html#mistyped_literal_suffixes\n [`mixed_case_hex_literals`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n+[`mod_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#mod_module_files\n [`module_inception`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\n [`module_name_repetitions`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions\n [`modulo_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#modulo_arithmetic\n@@ -2828,6 +2829,7 @@ Released 2018-09-13\n [`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update\n [`neg_cmp_op_on_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_cmp_op_on_partial_ord\n [`neg_multiply`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_multiply\n+[`negative_feature_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#negative_feature_names\n [`never_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#never_loop\n [`new_ret_no_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_ret_no_self\n [`new_without_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n@@ -2881,6 +2883,7 @@ Released 2018-09-13\n [`redundant_closure_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_closure_for_method_calls`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_for_method_calls\n [`redundant_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_else\n+[`redundant_feature_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_feature_names\n [`redundant_field_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n [`redundant_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern\n [`redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching\n@@ -2903,6 +2906,7 @@ Released 2018-09-13\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`self_named_constructors`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_constructors\n+[`self_named_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_module_files\n [`semicolon_if_nothing_returned`]: https://rust-lang.github.io/rust-clippy/master/index.html#semicolon_if_nothing_returned\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse"}, {"sha": "aaf404eadea11e9ac52730c83a8331fa1ded4e4e", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -45,13 +45,13 @@ or in Travis CI.\n One way to use Clippy is by installing Clippy through rustup as a cargo\n subcommand.\n \n-#### Step 1: Install rustup\n+#### Step 1: Install Rustup\n \n-You can install [rustup](https://rustup.rs/) on supported platforms. This will help\n+You can install [Rustup](https://rustup.rs/) on supported platforms. This will help\n us install Clippy and its dependencies.\n \n-If you already have rustup installed, update to ensure you have the latest\n-rustup and compiler:\n+If you already have Rustup installed, update to ensure you have the latest\n+Rustup and compiler:\n \n ```terminal\n rustup update"}, {"sha": "e05db7af58677cd0f30c84fabf39fd7c40780df0", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -17,7 +17,6 @@ pub mod fmt;\n pub mod new_lint;\n pub mod serve;\n pub mod setup;\n-pub mod stderr_length_check;\n pub mod update_lints;\n \n static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {"}, {"sha": "8fdeba9842af3e6f80070aa055e2a28dd70ff000", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -3,7 +3,7 @@\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};\n-use clippy_dev::{bless, fmt, new_lint, serve, setup, stderr_length_check, update_lints};\n+use clippy_dev::{bless, fmt, new_lint, serve, setup, update_lints};\n fn main() {\n     let matches = get_clap_config();\n \n@@ -33,9 +33,6 @@ fn main() {\n                 Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n             }\n         },\n-        (\"limit_stderr_length\", _) => {\n-            stderr_length_check::check();\n-        },\n         (\"setup\", Some(sub_command)) => match sub_command.subcommand() {\n             (\"intellij\", Some(matches)) => setup::intellij::setup_rustc_src(\n                 matches\n@@ -152,10 +149,6 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                         .takes_value(true),\n                 ),\n         )\n-        .subcommand(\n-            SubCommand::with_name(\"limit_stderr_length\")\n-                .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n-        )\n         .subcommand(\n             SubCommand::with_name(\"setup\")\n                 .about(\"Support for setting up your personal development environment\")"}, {"sha": "e02b6f7da5f7b66e7653403d2f823984eb000ce4", "filename": "clippy_dev/src/stderr_length_check.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/78bf4acc3a18848e21896bae97859c5811b320d4/clippy_dev%2Fsrc%2Fstderr_length_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bf4acc3a18848e21896bae97859c5811b320d4/clippy_dev%2Fsrc%2Fstderr_length_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fstderr_length_check.rs?ref=78bf4acc3a18848e21896bae97859c5811b320d4", "patch": "@@ -1,51 +0,0 @@\n-use crate::clippy_project_root;\n-use std::ffi::OsStr;\n-use std::fs;\n-use std::path::{Path, PathBuf};\n-use walkdir::WalkDir;\n-\n-// The maximum length allowed for stderr files.\n-//\n-// We limit this because small files are easier to deal with than bigger files.\n-const LENGTH_LIMIT: usize = 200;\n-\n-pub fn check() {\n-    let exceeding_files: Vec<_> = exceeding_stderr_files();\n-\n-    if !exceeding_files.is_empty() {\n-        eprintln!(\"Error: stderr files exceeding limit of {} lines:\", LENGTH_LIMIT);\n-        for (path, count) in exceeding_files {\n-            println!(\"{}: {}\", path.display(), count);\n-        }\n-        std::process::exit(1);\n-    }\n-}\n-\n-fn exceeding_stderr_files() -> Vec<(PathBuf, usize)> {\n-    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n-    WalkDir::new(clippy_project_root().join(\"tests/ui\"))\n-        .into_iter()\n-        .filter_map(Result::ok)\n-        .filter(|f| !f.file_type().is_dir())\n-        .filter_map(|e| {\n-            let p = e.into_path();\n-            let count = count_linenumbers(&p);\n-            if p.extension() == Some(OsStr::new(\"stderr\")) && count > LENGTH_LIMIT {\n-                Some((p, count))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect()\n-}\n-\n-#[must_use]\n-fn count_linenumbers(filepath: &Path) -> usize {\n-    match fs::read(filepath) {\n-        Ok(content) => bytecount::count(&content, b'\\n'),\n-        Err(e) => {\n-            eprintln!(\"Failed to read file: {}\", e);\n-            0\n-        },\n-    }\n-}"}, {"sha": "cdc192a47e48abebb325f95437ce48a1ee00dee6", "filename": "clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,9 +1,11 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{ast_utils, is_direct_expn_of};\n-use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, higher, is_direct_expn_of, ty::implements_trait};\n+use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_hir::{Expr, ExprKind, Lit};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -28,45 +30,77 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BoolAssertComparison => [BOOL_ASSERT_COMPARISON]);\n \n-fn is_bool_lit(e: &Expr) -> bool {\n+fn is_bool_lit(e: &Expr<'_>) -> bool {\n     matches!(\n         e.kind,\n         ExprKind::Lit(Lit {\n-            kind: LitKind::Bool(_),\n+            node: LitKind::Bool(_),\n             ..\n         })\n     ) && !e.span.from_expansion()\n }\n \n-impl EarlyLintPass for BoolAssertComparison {\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n+fn is_impl_not_trait_with_bool_out(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(e);\n+\n+    cx.tcx\n+        .lang_items()\n+        .not_trait()\n+        .filter(|trait_id| implements_trait(cx, ty, *trait_id, &[]))\n+        .and_then(|trait_id| {\n+            cx.tcx.associated_items(trait_id).find_by_name_and_kind(\n+                cx.tcx,\n+                Ident::from_str(\"Output\"),\n+                ty::AssocKind::Type,\n+                trait_id,\n+            )\n+        })\n+        .map_or(false, |assoc_item| {\n+            let proj = cx.tcx.mk_projection(assoc_item.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n+            let nty = cx.tcx.normalize_erasing_regions(cx.param_env, proj);\n+\n+            nty.is_bool()\n+        })\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let macros = [\"assert_eq\", \"debug_assert_eq\"];\n         let inverted_macros = [\"assert_ne\", \"debug_assert_ne\"];\n \n         for mac in macros.iter().chain(inverted_macros.iter()) {\n-            if let Some(span) = is_direct_expn_of(e.span, mac) {\n-                if let Some([a, b]) = ast_utils::extract_assert_macro_args(e) {\n-                    let nb_bool_args = is_bool_lit(a) as usize + is_bool_lit(b) as usize;\n+            if let Some(span) = is_direct_expn_of(expr.span, mac) {\n+                if let Some(args) = higher::extract_assert_macro_args(expr) {\n+                    if let [a, b, ..] = args[..] {\n+                        let nb_bool_args = is_bool_lit(a) as usize + is_bool_lit(b) as usize;\n+\n+                        if nb_bool_args != 1 {\n+                            // If there are two boolean arguments, we definitely don't understand\n+                            // what's going on, so better leave things as is...\n+                            //\n+                            // Or there is simply no boolean and then we can leave things as is!\n+                            return;\n+                        }\n \n-                    if nb_bool_args != 1 {\n-                        // If there are two boolean arguments, we definitely don't understand\n-                        // what's going on, so better leave things as is...\n-                        //\n-                        // Or there is simply no boolean and then we can leave things as is!\n+                        if !is_impl_not_trait_with_bool_out(cx, a) || !is_impl_not_trait_with_bool_out(cx, b) {\n+                            // At this point the expression which is not a boolean\n+                            // literal does not implement Not trait with a bool output,\n+                            // so we cannot suggest to rewrite our code\n+                            return;\n+                        }\n+\n+                        let non_eq_mac = &mac[..mac.len() - 3];\n+                        span_lint_and_sugg(\n+                            cx,\n+                            BOOL_ASSERT_COMPARISON,\n+                            span,\n+                            &format!(\"used `{}!` with a literal bool\", mac),\n+                            \"replace it with\",\n+                            format!(\"{}!(..)\", non_eq_mac),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                         return;\n                     }\n-\n-                    let non_eq_mac = &mac[..mac.len() - 3];\n-                    span_lint_and_sugg(\n-                        cx,\n-                        BOOL_ASSERT_COMPARISON,\n-                        span,\n-                        &format!(\"used `{}!` with a literal bool\", mac),\n-                        \"replace it with\",\n-                        format!(\"{}!(..)\", non_eq_mac),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return;\n                 }\n             }\n         }"}, {"sha": "a07cd5e5f4e53940be988f8fe12b8f968174d755", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                 return;\n             };\n             if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n-            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n+            if !is_local_used(cx, needle, arg_id);\n             then {\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n                         filter_recv.kind {"}, {"sha": "f5683856889f22fdcfe01012c530ff859cef08a0", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{higher, is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n@@ -56,11 +56,11 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n                         check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n                     }\n                 }\n-            }\n+            },\n             Some(IfLetOrMatch::IfLet(_, pat, body, els)) => {\n                 check_arm(cx, false, pat, body, None, els);\n-            }\n-            None => {}\n+            },\n+            None => {},\n         }\n     }\n }\n@@ -71,7 +71,7 @@ fn check_arm<'tcx>(\n     outer_pat: &'tcx Pat<'tcx>,\n     outer_then_body: &'tcx Expr<'tcx>,\n     outer_guard: Option<&'tcx Guard<'tcx>>,\n-    outer_else_body: Option<&'tcx Expr<'tcx>>\n+    outer_else_body: Option<&'tcx Expr<'tcx>>,\n ) {\n     let inner_expr = strip_singleton_blocks(outer_then_body);\n     if_chain! {\n@@ -106,14 +106,12 @@ fn check_arm<'tcx>(\n             (Some(a), Some(b)) => SpanlessEq::new(cx).eq_expr(a, b),\n         };\n         // the binding must not be used in the if guard\n-        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n-        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !used_visitor.check_expr(e));\n-        // ...or anywhere in the inner expression\n+        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !is_local_used(cx, *e, binding_id));        // ...or anywhere in the inner expression\n         if match inner {\n             IfLetOrMatch::IfLet(_, _, body, els) => {\n-                !used_visitor.check_expr(body) && els.map_or(true, |e| !used_visitor.check_expr(e))\n+                !is_local_used(cx, body, binding_id) && els.map_or(true, |e| !is_local_used(cx, e, binding_id))\n             },\n-            IfLetOrMatch::Match(_, arms, ..) => !arms.iter().any(|arm| used_visitor.check_arm(arm)),\n+            IfLetOrMatch::Match(_, arms, ..) => !arms.iter().any(|arm| is_local_used(cx, arm, binding_id)),\n         };\n         then {\n             let msg = format!(\n@@ -154,16 +152,26 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n enum IfLetOrMatch<'hir> {\n     Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n     /// scrutinee, pattern, then block, else block\n-    IfLet(&'hir Expr<'hir>, &'hir Pat<'hir>, &'hir Expr<'hir>, Option<&'hir Expr<'hir>>),\n+    IfLet(\n+        &'hir Expr<'hir>,\n+        &'hir Pat<'hir>,\n+        &'hir Expr<'hir>,\n+        Option<&'hir Expr<'hir>>,\n+    ),\n }\n \n impl<'hir> IfLetOrMatch<'hir> {\n     fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n         match expr.kind {\n             ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n-            _ => higher::IfLet::hir(cx, expr).map(|higher::IfLet { let_expr, let_pat, if_then, if_else }| {\n-                Self::IfLet(let_expr, let_pat, if_then, if_else)\n-            })\n+            _ => higher::IfLet::hir(cx, expr).map(\n+                |higher::IfLet {\n+                     let_expr,\n+                     let_pat,\n+                     if_then,\n+                     if_else,\n+                 }| { Self::IfLet(let_expr, let_pat, if_then, if_else) },\n+            ),\n         }\n     }\n }"}, {"sha": "d58e49491203c1da290327d0af845d72d2018024", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -148,7 +148,7 @@ declare_clippy_lint! {\n     /// };\n     /// ```\n     pub BRANCHES_SHARING_CODE,\n-    complexity,\n+    nursery,\n     \"`if` statement with shared code in all blocks\"\n }\n "}, {"sha": "8416b8440dfbe0bf99988c21d09aea8b60799d18", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -105,9 +105,6 @@ declare_clippy_lint! {\n     /// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n     /// gets you.\n     ///\n-    /// ### Known problems\n-    /// Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// #[derive(Copy)]"}, {"sha": "ac6824672f66cbf90c13b7f7d9e6dfab2d009d4d", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -9,8 +9,9 @@ use clippy_utils::{\n use core::fmt::Write;\n use rustc_errors::Applicability;\n use rustc_hir::{\n+    hir_id::HirIdSet,\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Pat, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -338,6 +339,8 @@ struct InsertSearcher<'cx, 'tcx> {\n     edits: Vec<Edit<'tcx>>,\n     /// A stack of loops the visitor is currently in.\n     loops: Vec<HirId>,\n+    /// Local variables created in the expression. These don't need to be captured.\n+    locals: HirIdSet,\n }\n impl<'tcx> InsertSearcher<'_, 'tcx> {\n     /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n@@ -385,13 +388,16 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 }\n             },\n             StmtKind::Expr(e) => self.visit_expr(e),\n-            StmtKind::Local(Local { init: Some(e), .. }) => {\n-                self.allow_insert_closure &= !self.in_tail_pos;\n-                self.in_tail_pos = false;\n-                self.is_single_insert = false;\n-                self.visit_expr(e);\n+            StmtKind::Local(l) => {\n+                self.visit_pat(l.pat);\n+                if let Some(e) = l.init {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.in_tail_pos = false;\n+                    self.is_single_insert = false;\n+                    self.visit_expr(e);\n+                }\n             },\n-            _ => {\n+            StmtKind::Item(_) => {\n                 self.allow_insert_closure &= !self.in_tail_pos;\n                 self.is_single_insert = false;\n             },\n@@ -473,6 +479,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     // Each branch may contain it's own insert expression.\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n+                        self.visit_pat(arm.pat);\n                         if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n                             self.visit_non_tail_expr(guard);\n                         }\n@@ -498,7 +505,8 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 },\n                 _ => {\n                     self.allow_insert_closure &= !self.in_tail_pos;\n-                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    self.allow_insert_closure &=\n+                        can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops, &self.locals);\n                     // Sub expressions are no longer in the tail position.\n                     self.is_single_insert = false;\n                     self.in_tail_pos = false;\n@@ -507,6 +515,12 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n             },\n         }\n     }\n+\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+        p.each_binding_or_first(&mut |_, id, _, _| {\n+            self.locals.insert(id);\n+        });\n+    }\n }\n \n struct InsertSearchResults<'tcx> {\n@@ -632,6 +646,7 @@ fn find_insert_calls(\n         in_tail_pos: true,\n         is_single_insert: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n     };\n     s.visit_expr(expr);\n     let allow_insert_closure = s.allow_insert_closure;"}, {"sha": "ae66edc2a9e12c789a92898235d94afe5602d094", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -171,7 +171,8 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 // skip if there is a `self` parameter binding to a type\n                 // that contains `Self` (i.e.: `self: Box<Self>`), see #4804\n                 if let Some(trait_self_ty) = self.trait_self_ty {\n-                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(self.cx.tcx, cmt.place.ty(), trait_self_ty) {\n+                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(self.cx.tcx, cmt.place.ty(), trait_self_ty)\n+                    {\n                         return;\n                     }\n                 }"}, {"sha": "eef1407a80cf15e2209993cc948e44e229dc63be", "filename": "clippy_lints/src/feature_name.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffeature_name.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,164 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n+use rustc_hir::{Crate, CRATE_HIR_ID};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::DUMMY_SP;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for feature names with prefix `use-`, `with-` or suffix `-support`\n+    ///\n+    /// ### Why is this bad?\n+    /// These prefixes and suffixes have no significant meaning.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with feature name redundancy\n+    /// [features]\n+    /// default = [\"use-abc\", \"with-def\", \"ghi-support\"]\n+    /// use-abc = []  // redundant\n+    /// with-def = []   // redundant\n+    /// ghi-support = []   // redundant\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\", \"ghi\"]\n+    /// abc = []\n+    /// def = []\n+    /// ghi = []\n+    /// ```\n+    ///\n+    pub REDUNDANT_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a redundant feature name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for negative feature names with prefix `no-` or `not-`\n+    ///\n+    /// ### Why is this bad?\n+    /// Features are supposed to be additive, and negatively-named features violate it.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with negative feature names\n+    /// [features]\n+    /// default = []\n+    /// no-abc = []\n+    /// not-def = []\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\"]\n+    /// abc = []\n+    /// def = []\n+    ///\n+    /// ```\n+    pub NEGATIVE_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a negative feature name\"\n+}\n+\n+declare_lint_pass!(FeatureName => [REDUNDANT_FEATURE_NAMES, NEGATIVE_FEATURE_NAMES]);\n+\n+static PREFIXES: [&str; 8] = [\"no-\", \"no_\", \"not-\", \"not_\", \"use-\", \"use_\", \"with-\", \"with_\"];\n+static SUFFIXES: [&str; 2] = [\"-support\", \"_support\"];\n+\n+fn is_negative_prefix(s: &str) -> bool {\n+    s.starts_with(\"no\")\n+}\n+\n+fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n+    let is_negative = is_prefix && is_negative_prefix(substring);\n+    span_lint_and_help(\n+        cx,\n+        if is_negative {\n+            NEGATIVE_FEATURE_NAMES\n+        } else {\n+            REDUNDANT_FEATURE_NAMES\n+        },\n+        DUMMY_SP,\n+        &format!(\n+            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n+            substring,\n+            if is_prefix { \"prefix\" } else { \"suffix\" },\n+            feature,\n+            if is_negative { \"negative\" } else { \"redundant\" }\n+        ),\n+        None,\n+        &format!(\n+            \"consider renaming the feature to \\\"{}\\\"{}\",\n+            if is_prefix {\n+                feature.strip_prefix(substring)\n+            } else {\n+                feature.strip_suffix(substring)\n+            }\n+            .unwrap(),\n+            if is_negative {\n+                \", but make sure the feature adds functionality\"\n+            } else {\n+                \"\"\n+            }\n+        ),\n+    );\n+}\n+\n+impl LateLintPass<'_> for FeatureName {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        if is_lint_allowed(cx, REDUNDANT_FEATURE_NAMES, CRATE_HIR_ID)\n+            && is_lint_allowed(cx, NEGATIVE_FEATURE_NAMES, CRATE_HIR_ID)\n+        {\n+            return;\n+        }\n+\n+        let metadata = unwrap_cargo_metadata!(cx, REDUNDANT_FEATURE_NAMES, false);\n+\n+        for package in metadata.packages {\n+            let mut features: Vec<&String> = package.features.keys().collect();\n+            features.sort();\n+            for feature in features {\n+                let prefix_opt = {\n+                    let i = PREFIXES.partition_point(|prefix| prefix < &feature.as_str());\n+                    if i > 0 && feature.starts_with(PREFIXES[i - 1]) {\n+                        Some(PREFIXES[i - 1])\n+                    } else {\n+                        None\n+                    }\n+                };\n+                if let Some(prefix) = prefix_opt {\n+                    lint(cx, feature, prefix, true);\n+                }\n+\n+                let suffix_opt: Option<&str> = {\n+                    let i = SUFFIXES.partition_point(|suffix| {\n+                        suffix.bytes().rev().cmp(feature.bytes().rev()) == std::cmp::Ordering::Less\n+                    });\n+                    if i > 0 && feature.ends_with(SUFFIXES[i - 1]) {\n+                        Some(SUFFIXES[i - 1])\n+                    } else {\n+                        None\n+                    }\n+                };\n+                if let Some(suffix) = suffix_opt {\n+                    lint(cx, feature, suffix, false);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_prefixes_sorted() {\n+    let mut sorted_prefixes = PREFIXES;\n+    sorted_prefixes.sort_unstable();\n+    assert_eq!(PREFIXES, sorted_prefixes);\n+    let mut sorted_suffixes = SUFFIXES;\n+    sorted_suffixes.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n+    assert_eq!(SUFFIXES, sorted_suffixes);\n+}"}, {"sha": "7f2c7b707f0b1290968371fbb65e45b4dd32b86d", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{path_to_local_id, visitors::LocalUsedVisitor};\n+use clippy_utils::{path_to_local_id, visitors::is_local_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -65,11 +65,10 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n                 if let hir::ExprKind::If(hir::Expr { kind: hir::ExprKind::DropTemps(cond), ..}, then, else_) = if_.kind;\n-                let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n-                if !used_visitor.check_expr(cond);\n+                if !is_local_used(cx, *cond, canonical_id);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n-                if !used_visitor.check_expr(value);\n+                if !is_local_used(cx, value, canonical_id);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n@@ -148,15 +147,13 @@ fn check_assign<'tcx>(\n         if let hir::ExprKind::Assign(var, value, _) = expr.kind;\n         if path_to_local_id(var, decl);\n         then {\n-            let mut v = LocalUsedVisitor::new(cx, decl);\n-\n-            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| v.check_stmt(stmt)) {\n-                return None;\n+            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| is_local_used(cx, stmt, decl)) {\n+                None\n+            } else {\n+                Some(value)\n             }\n-\n-            return Some(value);\n+        } else {\n+            None\n         }\n     }\n-\n-    None\n }"}, {"sha": "5ce5f809f4692566902a79346b5b5cd4f5c85523", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -211,6 +211,7 @@ mod exhaustive_items;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n+mod feature_name;\n mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n@@ -272,6 +273,7 @@ mod missing_const_for_fn;\n mod missing_doc;\n mod missing_enforced_import_rename;\n mod missing_inline;\n+mod module_style;\n mod modulo_arithmetic;\n mod multiple_crate_versions;\n mod mut_key;\n@@ -625,6 +627,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         exit::EXIT,\n         explicit_write::EXPLICIT_WRITE,\n         fallible_impl_from::FALLIBLE_IMPL_FROM,\n+        feature_name::NEGATIVE_FEATURE_NAMES,\n+        feature_name::REDUNDANT_FEATURE_NAMES,\n         float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n         float_literal::EXCESSIVE_PRECISION,\n         float_literal::LOSSY_FLOAT_LITERAL,\n@@ -770,6 +774,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_FILTER_MAP,\n         methods::MANUAL_FIND_MAP,\n         methods::MANUAL_SATURATING_ARITHMETIC,\n+        methods::MANUAL_SPLIT_ONCE,\n         methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n@@ -822,6 +827,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n         missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES,\n         missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n+        module_style::MOD_MODULE_FILES,\n+        module_style::SELF_NAMED_MODULE_FILES,\n         modulo_arithmetic::MODULO_ARITHMETIC,\n         multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n         mut_key::MUTABLE_KEY_TYPE,\n@@ -1031,6 +1038,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n         LintId::of(missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES),\n         LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n+        LintId::of(module_style::MOD_MODULE_FILES),\n+        LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n         LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n         LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n         LintId::of(panic_unimplemented::PANIC),\n@@ -1122,7 +1131,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(non_expressive_names::SIMILAR_NAMES),\n-        LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n         LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(ranges::RANGE_MINUS_ONE),\n@@ -1193,7 +1201,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(comparison_chain::COMPARISON_CHAIN),\n-        LintId::of(copies::BRANCHES_SHARING_CODE),\n         LintId::of(copies::IFS_SAME_COND),\n         LintId::of(copies::IF_SAME_THEN_ELSE),\n         LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n@@ -1316,6 +1323,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(methods::MAP_IDENTITY),\n@@ -1581,7 +1589,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(booleans::NONMINIMAL_BOOL),\n         LintId::of(casts::CHAR_LIT_AS_U8),\n         LintId::of(casts::UNNECESSARY_CAST),\n-        LintId::of(copies::BRANCHES_SHARING_CODE),\n         LintId::of(double_comparison::DOUBLE_COMPARISONS),\n         LintId::of(double_parens::DOUBLE_PARENS),\n         LintId::of(duration_subsec::DURATION_SUBSEC),\n@@ -1614,6 +1621,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ITER_COUNT),\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n         LintId::of(methods::OPTION_FILTER_MAP),\n@@ -1779,13 +1787,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n         LintId::of(cargo_common_metadata::CARGO_COMMON_METADATA),\n+        LintId::of(feature_name::NEGATIVE_FEATURE_NAMES),\n+        LintId::of(feature_name::REDUNDANT_FEATURE_NAMES),\n         LintId::of(multiple_crate_versions::MULTIPLE_CRATE_VERSIONS),\n         LintId::of(wildcard_dependencies::WILDCARD_DEPENDENCIES),\n     ]);\n \n     store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n         LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n         LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n+        LintId::of(copies::BRANCHES_SHARING_CODE),\n         LintId::of(disallowed_method::DISALLOWED_METHOD),\n         LintId::of(disallowed_type::DISALLOWED_TYPE),\n         LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n@@ -1797,6 +1808,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(mutex_atomic::MUTEX_INTEGER),\n         LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n+        LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n         LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n         LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n         LintId::of(regex::TRIVIAL_REGEX),\n@@ -1835,7 +1847,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(serde_api::SerdeApi));\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n-    store.register_late_pass(move || Box::new(types::Types::new(vec_box_size_threshold, type_complexity_threshold)));\n+    let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n+    store.register_late_pass(move || Box::new(types::Types::new(\n+        vec_box_size_threshold,\n+        type_complexity_threshold,\n+        avoid_breaking_exported_api,\n+    )));\n     store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n     store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n     store.register_late_pass(|| Box::new(eq_op::EqOp));\n@@ -2092,7 +2109,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n     store.register_late_pass(|| Box::new(manual_map::ManualMap));\n     store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n-    store.register_early_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n+    store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n+    store.register_early_pass(move || Box::new(module_style::ModStyle));\n     store.register_late_pass(|| Box::new(unused_async::UnusedAsync));\n     let disallowed_types = conf.disallowed_types.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move || Box::new(disallowed_type::DisallowedType::new(&disallowed_types)));\n@@ -2102,6 +2120,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n     store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n     store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n+    store.register_late_pass(move || Box::new(feature_name::FeatureName));\n }\n \n #[rustfmt::skip]\n@@ -2180,7 +2199,6 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\");\n     ls.register_renamed(\"clippy::panic_params\", \"non_fmt_panics\");\n     ls.register_renamed(\"clippy::unknown_clippy_lints\", \"unknown_lints\");\n-    ls.register_renamed(\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\");\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "68bef2f4c8bbb351e808dcd6c78193e8896a5bc6", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -66,9 +66,7 @@ pub(super) fn check<'tcx>(\n fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n-            !LocalUsedVisitor::new(cx, id).check_expr(body)\n-        },\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => !is_local_used(cx, body, id),\n         _ => false,\n     }\n }"}, {"sha": "5b6e27085d580986bd892ac46552dc6b2d253e11", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -2,6 +2,7 @@ use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -37,7 +38,8 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n-            if let Some(higher::IfLet { let_pat, let_expr, if_else: None, .. }) = higher::IfLet::hir(cx, inner_expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n+                = higher::IfLet::hir(cx, inner_expr);\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n             if path_to_local_id(let_expr, pat_hir_id);\n@@ -46,6 +48,8 @@ pub(super) fn check<'tcx>(\n             let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n+            // Ensure epxr in `if let` is not used afterwards\n+            if !is_local_used(cx, if_then, pat_hir_id);\n             then {\n                 let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message"}, {"sha": "df848e68802c552292a9147397fa313468d6d5de", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "f90ed7397e18e19c4d1d9899521684d2d69a0577", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -26,7 +26,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n         then {\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n-            let mut applicability = Applicability::MachineApplicable;\n+            let mut applicability = Applicability::MaybeIncorrect;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = &*method.ident.name.as_str();\n             let sugg = if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n@@ -113,7 +113,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                                     (stmt.span, String::new()),\n                                     (iter_call.span, iter_replacement)\n                                 ],\n-                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                                Applicability::MaybeIncorrect,\n                             );\n                         },\n                     );"}, {"sha": "f17e76d9682c9e24d54bd659f941542ef67b6ae4", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -2,10 +2,8 @@ use super::NEEDLESS_RANGE_LOOP;\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n-use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{\n-    contains_name, higher, is_integer_const, match_trait_method, path_to_local_id, paths, sugg, SpanlessEq,\n-};\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -256,43 +254,36 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n             if let QPath::Resolved(None, seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n-            let index_used_directly = path_to_local_id(idx, self.var);\n-            let indexed_indirectly = {\n-                let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                walk_expr(&mut used_visitor, idx);\n-                used_visitor.used\n-            };\n-            if indexed_indirectly || index_used_directly;\n+            if is_local_used(self.cx, idx, self.var);\n             then {\n                 if self.prefer_mutable {\n                     self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                 }\n+                let index_used_directly = matches!(idx.kind, ExprKind::Path(_));\n                 let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n                         let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n                         let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }\n                     Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                        if indexed_indirectly {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                        }\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n                                 (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n+                        } else {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }"}, {"sha": "385a3f546b9d00732a8d667e286c7505b649da98", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -5,12 +5,14 @@ use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs,\n+    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -119,7 +121,9 @@ fn manage_lint<'tcx>(\n         None => return,\n     };\n \n-    if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id) {\n+    if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+    {\n         return;\n     }\n \n@@ -128,10 +132,6 @@ fn manage_lint<'tcx>(\n         return;\n     }\n \n-    if !can_move_expr_to_closure(cx, some_expr) {\n-        return;\n-    }\n-\n     // Determine which binding mode to use.\n     let explicit_ref = some_pat.contains_explicit_ref_binding();\n     let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n@@ -142,6 +142,30 @@ fn manage_lint<'tcx>(\n         None => \"\",\n     };\n \n+    match can_move_expr_to_closure(cx, some_expr) {\n+        Some(captures) => {\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if let Some(binding_ref_mutability) = binding_ref {\n+                let e = peel_hir_expr_while(scrut, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match captures.get(l) {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                            return;\n+                        },\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n+        },\n+        None => return,\n+    };\n+\n     let mut app = Applicability::MachineApplicable;\n \n     // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n@@ -213,7 +237,7 @@ fn manage_lint<'tcx>(\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id (arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },"}, {"sha": "131ed1d8925f07b7c53d0bffb31c9f8805d466c6", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::higher;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild,\n     meets_msrv, msrvs, path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n@@ -959,9 +959,7 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                         // Looking for unused bindings (i.e.: `_e`)\n                         for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_')\n-                                    && !LocalUsedVisitor::new(cx, id).check_expr(arm.body)\n-                                {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n                                     ident_bind_name = (&ident.name.as_str()).to_string();\n                                     matching_wild = true;\n                                 }"}, {"sha": "bcf8d93b602ef2a7d03703f7864723af5806fca0", "filename": "clippy_lints/src/methods/filter_next.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::is_trait_method;\n use clippy_utils::source::snippet;\n+use clippy_utils::ty::implements_trait;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -16,7 +16,10 @@ pub(super) fn check<'tcx>(\n     filter_arg: &'tcx hir::Expr<'_>,\n ) {\n     // lint if caller of `.filter().next()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n+    let recv_impls_iterator = cx.tcx.get_diagnostic_item(sym::Iterator).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(recv), id, &[])\n+    });\n+    if recv_impls_iterator {\n         let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find(..)` instead\";\n         let filter_snippet = snippet(cx, filter_arg.span, \"..\");"}, {"sha": "e273186d0519022d5a7c1a9219cf1aa9625fd4a7", "filename": "clippy_lints/src/methods/manual_split_once.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,213 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, adjustment::Adjust};\n+use rustc_span::{symbol::sym, Span, SyntaxContext};\n+\n+use super::MANUAL_SPLIT_ONCE;\n+\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+        return;\n+    }\n+\n+    let ctxt = expr.span.ctxt();\n+    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(x) => x,\n+        None => return,\n+    };\n+    let (method_name, msg) = if method_name == \"splitn\" {\n+        (\"split_once\", \"manual implementation of `split_once`\")\n+    } else {\n+        (\"rsplit_once\", \"manual implementation of `rsplit_once`\")\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+    let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+    let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+    match usage.kind {\n+        IterUsageKind::NextTuple => {\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({})\", self_snip, method_name, pat_snip),\n+                app,\n+            );\n+        },\n+        IterUsageKind::Next => {\n+            let self_deref = {\n+                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n+                if adjust.is_empty() {\n+                    String::new()\n+                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n+                    || adjust\n+                        .iter()\n+                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n+                {\n+                    format!(\"&{}\", \"*\".repeat(adjust.len() - 1))\n+                } else {\n+                    \"*\".repeat(adjust.len() - 2)\n+                }\n+            };\n+            let sugg = if usage.unwrap_kind.is_some() {\n+                format!(\n+                    \"{}.{}({}).map_or({}{}, |x| x.0)\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            } else {\n+                format!(\n+                    \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            };\n+\n+            span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n+        },\n+        IterUsageKind::Second => {\n+            let access_str = match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n+                Some(UnwrapKind::QuestionMark) => \"?.1\",\n+                None => \".map(|x| x.1)\",\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str),\n+                app,\n+            );\n+        },\n+    }\n+}\n+\n+enum IterUsageKind {\n+    Next,\n+    Second,\n+    NextTuple,\n+}\n+\n+enum UnwrapKind {\n+    Unwrap,\n+    QuestionMark,\n+}\n+\n+struct IterUsage {\n+    kind: IterUsageKind,\n+    unwrap_kind: Option<UnwrapKind>,\n+    span: Span,\n+}\n+\n+fn parse_iter_usage(\n+    cx: &LateContext<'tcx>,\n+    ctxt: SyntaxContext,\n+    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+) -> Option<IterUsage> {\n+    let (kind, span) = match iter.next() {\n+        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+                (name, args)\n+            } else {\n+                return None;\n+            };\n+            let did = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n+            let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n+\n+            match (&*name.ident.as_str(), args) {\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Next, e.span),\n+                (\"next_tuple\", []) => {\n+                    if_chain! {\n+                        if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n+                        if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n+                        if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did);\n+                        if let ty::Tuple(subs) = subs.type_at(0).kind();\n+                        if subs.len() == 2;\n+                        then {\n+                            return Some(IterUsage { kind: IterUsageKind::NextTuple, span: e.span, unwrap_kind: None });\n+                        } else {\n+                            return None;\n+                        }\n+                    }\n+                },\n+                (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                    if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                        let span = if name.ident.as_str() == \"nth\" {\n+                            e.span\n+                        } else {\n+                            if_chain! {\n+                                if let Some((_, Node::Expr(next_expr))) = iter.next();\n+                                if let ExprKind::MethodCall(next_name, _, [_], _) = next_expr.kind;\n+                                if next_name.ident.name == sym::next;\n+                                if next_expr.span.ctxt() == ctxt;\n+                                if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n+                                if cx.tcx.trait_of_item(next_id) == Some(iter_id);\n+                                then {\n+                                    next_expr.span\n+                                } else {\n+                                    return None;\n+                                }\n+                            }\n+                        };\n+                        match idx {\n+                            0 => (IterUsageKind::Next, span),\n+                            1 => (IterUsageKind::Second, span),\n+                            _ => return None,\n+                        }\n+                    } else {\n+                        return None;\n+                    }\n+                },\n+                _ => return None,\n+            }\n+        },\n+        _ => return None,\n+    };\n+\n+    let (unwrap_kind, span) = if let Some((_, Node::Expr(e))) = iter.next() {\n+        match e.kind {\n+            ExprKind::Call(\n+                Expr {\n+                    kind: ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)),\n+                    ..\n+                },\n+                _,\n+            ) => {\n+                let parent_span = e.span.parent().unwrap();\n+                if parent_span.ctxt() == ctxt {\n+                    (Some(UnwrapKind::QuestionMark), parent_span)\n+                } else {\n+                    (None, span)\n+                }\n+            },\n+            _ if e.span.ctxt() != ctxt => (None, span),\n+            ExprKind::MethodCall(name, _, [_], _)\n+                if name.ident.name == sym::unwrap\n+                    && cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| is_diag_item_method(cx, id, sym::option_type)) =>\n+            {\n+                (Some(UnwrapKind::Unwrap), e.span)\n+            },\n+            _ => (None, span),\n+        }\n+    } else {\n+        (None, span)\n+    };\n+\n+    Some(IterUsage {\n+        kind,\n+        unwrap_kind,\n+        span,\n+    })\n+}"}, {"sha": "e89b2d295b92345f4f1173e0e19911c559cc3bca", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -33,6 +33,7 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n+mod manual_split_once;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n@@ -64,6 +65,7 @@ mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n@@ -1771,6 +1773,29 @@ declare_clippy_lint! {\n     \"manual implementation of `str::repeat`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `str::splitn(2, _)`\n+    ///\n+    /// **Why is this bad?** `split_once` is both clearer in intent and slightly more efficient.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    ///  let (key, value) = _.splitn(2, '=').next_tuple()?;\n+    ///  let value = _.splitn(2, '=').nth(1)?;\n+    ///\n+    /// // Good\n+    /// let (key, value) = _.split_once('=')?;\n+    /// let value = _.split_once('=')?.1;\n+    /// ```\n+    pub MANUAL_SPLIT_ONCE,\n+    complexity,\n+    \"replace `.splitn(2, pat)` with `.split_once(pat)`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1848,7 +1873,8 @@ impl_lint_pass!(Methods => [\n     IMPLICIT_CLONE,\n     SUSPICIOUS_SPLITN,\n     MANUAL_STR_REPEAT,\n-    EXTEND_WITH_DRAIN\n+    EXTEND_WITH_DRAIN,\n+    MANUAL_SPLIT_ONCE\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2176,8 +2202,18 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                 }\n             },\n-            (\"splitn\" | \"splitn_mut\" | \"rsplitn\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                suspicious_splitn::check(cx, name, expr, recv, count_arg);\n+            (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n+                        manual_split_once::check(cx, name, expr, recv, pat_arg);\n+                    }\n+                }\n+            },\n+            (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                }\n             },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {"}, {"sha": "1c546a15bf62b331a5993e378aee11e7c832dc72", "filename": "clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,4 +1,3 @@\n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_note;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n@@ -8,25 +7,18 @@ use rustc_span::source_map::Spanned;\n \n use super::SUSPICIOUS_SPLITN;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    count_arg: &Expr<'_>,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, count: u128) {\n     if_chain! {\n-        if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg);\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n         let lang_items = cx.tcx.lang_items();\n         if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n-            if (matches!(self_arg.kind, ExprKind::Array([]))\n+            if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-            ) && matches!(count_arg.kind, ExprKind::Lit(_))\n+\n             {\n                 return;\n             }"}, {"sha": "55d2e29e8bc1e89886496ca2177db3e4d9f0587f", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -55,6 +56,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.doc_str().is_some());\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "80a930d0c547b368460ba8e0e965261b1f7da7d9", "filename": "clippy_lints/src/module_style.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodule_style.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,178 @@\n+use std::{\n+    ffi::OsString,\n+    path::{Component, Path},\n+};\n+\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_lint::{EarlyContext, EarlyLintPass, Level, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{FileName, RealFileName, SourceFile, Span, SyntaxContext};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks that module layout uses only self named module files, bans mod.rs files.\n+    ///\n+    /// ### Why is this bad?\n+    /// Having multiple module layout styles in a project can be confusing.\n+    ///\n+    /// ### Example\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///     mod.rs\n+    ///   lib.rs\n+    /// ```\n+    /// Use instead:\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///   stuff.rs\n+    ///   lib.rs\n+    /// ```\n+    pub MOD_MODULE_FILES,\n+    restriction,\n+    \"checks that module layout is consistent\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks that module layout uses only mod.rs files.\n+    ///\n+    /// ### Why is this bad?\n+    /// Having multiple module layout styles in a project can be confusing.\n+    ///\n+    /// ### Example\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///   stuff.rs\n+    ///   lib.rs\n+    /// ```\n+    /// Use instead:\n+    /// ```text\n+    /// src/\n+    ///   stuff/\n+    ///     stuff_files.rs\n+    ///     mod.rs\n+    ///   lib.rs\n+    /// ```\n+\n+    pub SELF_NAMED_MODULE_FILES,\n+    restriction,\n+    \"checks that module layout is consistent\"\n+}\n+\n+pub struct ModStyle;\n+\n+impl_lint_pass!(ModStyle => [MOD_MODULE_FILES, SELF_NAMED_MODULE_FILES]);\n+\n+impl EarlyLintPass for ModStyle {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, _: &ast::Crate) {\n+        if cx.builder.lint_level(MOD_MODULE_FILES).0 == Level::Allow\n+            && cx.builder.lint_level(SELF_NAMED_MODULE_FILES).0 == Level::Allow\n+        {\n+            return;\n+        }\n+\n+        let files = cx.sess.source_map().files();\n+\n+        let trim_to_src = if let RealFileName::LocalPath(p) = &cx.sess.opts.working_dir {\n+            p.to_string_lossy()\n+        } else {\n+            return;\n+        };\n+\n+        // `folder_segments` is all unique folder path segments `path/to/foo.rs` gives\n+        // `[path, to]` but not foo\n+        let mut folder_segments = FxHashSet::default();\n+        // `mod_folders` is all the unique folder names that contain a mod.rs file\n+        let mut mod_folders = FxHashSet::default();\n+        // `file_map` maps file names to the full path including the file name\n+        // `{ foo => path/to/foo.rs, .. }\n+        let mut file_map = FxHashMap::default();\n+        for file in files.iter() {\n+            match &file.name {\n+                FileName::Real(RealFileName::LocalPath(lp))\n+                    if lp.to_string_lossy().starts_with(trim_to_src.as_ref()) =>\n+                {\n+                    let p = lp.to_string_lossy();\n+                    let path = Path::new(p.trim_start_matches(trim_to_src.as_ref()));\n+                    if let Some(stem) = path.file_stem() {\n+                        file_map.insert(stem.to_os_string(), (file, path.to_owned()));\n+                    }\n+                    process_paths_for_mod_files(path, &mut folder_segments, &mut mod_folders);\n+                    check_self_named_mod_exists(cx, path, file);\n+                }\n+                _ => {},\n+            }\n+        }\n+\n+        for folder in &folder_segments {\n+            if !mod_folders.contains(folder) {\n+                if let Some((file, path)) = file_map.get(folder) {\n+                    let mut correct = path.clone();\n+                    correct.pop();\n+                    correct.push(folder);\n+                    correct.push(\"mod.rs\");\n+                    cx.struct_span_lint(\n+                        SELF_NAMED_MODULE_FILES,\n+                        Span::new(file.start_pos, file.start_pos, SyntaxContext::root()),\n+                        |build| {\n+                            let mut lint =\n+                                build.build(&format!(\"`mod.rs` files are required, found `{}`\", path.display()));\n+                            lint.help(&format!(\"move `{}` to `{}`\", path.display(), correct.display(),));\n+                            lint.emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// For each `path` we add each folder component to `folder_segments` and if the file name\n+/// is `mod.rs` we add it's parent folder to `mod_folders`.\n+fn process_paths_for_mod_files(\n+    path: &Path,\n+    folder_segments: &mut FxHashSet<OsString>,\n+    mod_folders: &mut FxHashSet<OsString>,\n+) {\n+    let mut comp = path.components().rev().peekable();\n+    let _ = comp.next();\n+    if path.ends_with(\"mod.rs\") {\n+        mod_folders.insert(comp.peek().map(|c| c.as_os_str().to_owned()).unwrap_or_default());\n+    }\n+    let folders = comp\n+        .filter_map(|c| {\n+            if let Component::Normal(s) = c {\n+                Some(s.to_os_string())\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+    folder_segments.extend(folders);\n+}\n+\n+/// Checks every path for the presence of `mod.rs` files and emits the lint if found.\n+fn check_self_named_mod_exists(cx: &EarlyContext<'_>, path: &Path, file: &SourceFile) {\n+    if path.ends_with(\"mod.rs\") {\n+        let mut mod_file = path.to_path_buf();\n+        mod_file.pop();\n+        mod_file.set_extension(\"rs\");\n+\n+        cx.struct_span_lint(\n+            MOD_MODULE_FILES,\n+            Span::new(file.start_pos, file.start_pos, SyntaxContext::root()),\n+            |build| {\n+                let mut lint = build.build(&format!(\"`mod.rs` files are not allowed, found `{}`\", path.display()));\n+                lint.help(&format!(\"move `{}` to `{}`\", path.display(), mod_file.display(),));\n+                lint.emit();\n+            },\n+        );\n+    }\n+}"}, {"sha": "ee50891cc3103b6903537bbcaf6bbe1ecb304b78", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -87,10 +87,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "c5a5cde4b110fccbb874801a53cd72dcc9b2e747", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -96,28 +96,63 @@ impl<'tcx> LateLintPass<'tcx> for NoEffect {\n             if has_no_effect(cx, expr) {\n                 span_lint_hir(cx, NO_EFFECT, expr.hir_id, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n-                let mut snippet = String::new();\n-                for e in reduced {\n+                for e in &reduced {\n                     if e.span.from_expansion() {\n                         return;\n                     }\n-                    if let Some(snip) = snippet_opt(cx, e.span) {\n-                        snippet.push_str(&snip);\n-                        snippet.push(';');\n-                    } else {\n-                        return;\n+                }\n+                if let ExprKind::Index(..) = &expr.kind {\n+                    let snippet;\n+                    if_chain! {\n+                        if let Some(arr) = snippet_opt(cx, reduced[0].span);\n+                        if let Some(func) = snippet_opt(cx, reduced[1].span);\n+                        then {\n+                            snippet = format!(\"assert!({}.len() > {});\", &arr, &func);\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                    span_lint_hir_and_then(\n+                        cx,\n+                        UNNECESSARY_OPERATION,\n+                        expr.hir_id,\n+                        stmt.span,\n+                        \"unnecessary operation\",\n+                        |diag| {\n+                            diag.span_suggestion(\n+                                stmt.span,\n+                                \"statement can be written as\",\n+                                snippet,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        },\n+                    );\n+                } else {\n+                    let mut snippet = String::new();\n+                    for e in reduced {\n+                        if let Some(snip) = snippet_opt(cx, e.span) {\n+                            snippet.push_str(&snip);\n+                            snippet.push(';');\n+                        } else {\n+                            return;\n+                        }\n                     }\n+                    span_lint_hir_and_then(\n+                        cx,\n+                        UNNECESSARY_OPERATION,\n+                        expr.hir_id,\n+                        stmt.span,\n+                        \"unnecessary operation\",\n+                        |diag| {\n+                            diag.span_suggestion(\n+                                stmt.span,\n+                                \"statement can be reduced to\",\n+                                snippet,\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n+                    );\n                 }\n-                span_lint_hir_and_then(\n-                    cx,\n-                    UNNECESSARY_OPERATION,\n-                    expr.hir_id,\n-                    stmt.span,\n-                    \"statement can be reduced\",\n-                    |diag| {\n-                        diag.span_suggestion(stmt.span, \"replace it with\", snippet, Applicability::MachineApplicable);\n-                    },\n-                );\n             }\n         }\n     }"}, {"sha": "80b4f544b1a467b0c9507ea8b21060ada0428772", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -2,12 +2,13 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n+use clippy_utils::{\n+    can_move_expr_to_closure, eager_or_lazy, in_macro, is_else_clause, is_lang_ctor, peel_hir_expr_while, CaptureKind,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, UnOp};\n+use rustc_hir::{def::Res, BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -58,7 +59,7 @@ declare_clippy_lint! {\n     /// }, |foo| foo);\n     /// ```\n     pub OPTION_IF_LET_ELSE,\n-    pedantic,\n+    nursery,\n     \"reimplementation of Option::map_or\"\n }\n \n@@ -125,20 +126,29 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(cx, expr);\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n+            = higher::IfLet::hir(cx, expr);\n         if !is_else_clause(cx.tcx, expr);\n         if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(if_then);\n-        if !contains_return_break_continue_macro(if_else);\n+        if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n+        if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n+        if some_captures\n+            .iter()\n+            .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n+            .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_expr(if_then)?;\n             let none_body = extract_body_from_expr(if_else)?;\n-            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n+            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n+                \"map_or\"\n+            } else {\n+                \"map_or_else\"\n+            };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n@@ -150,6 +160,24 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n                 _ => let_expr,\n             };\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if as_ref || as_mut {\n+                let e = peel_hir_expr_while(cond_expr, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(local_id), .. })) = e.kind {\n+                    match some_captures.get(local_id)\n+                        .or_else(|| (method_sugg == \"map_or_else\").then(|| ()).and_then(|_| none_captures.get(local_id)))\n+                    {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if as_mut => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),"}, {"sha": "17c9e3e7541cadf72f6ed3f868b9bb10267c1eb0", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -97,7 +97,8 @@ impl QuestionMark {\n \n     fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(cx, expr);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n+                = higher::IfLet::hir(cx, expr);\n             if Self::is_option(cx, let_expr);\n \n             if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;"}, {"sha": "cfa12ef3a321dd7ba04fbd992c819aaa24436ed7", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -625,7 +625,10 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 .flat_map(HybridBitSet::iter)\n                 .collect();\n \n-            if ContainsRegion(self.cx.tcx).visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+            if ContainsRegion(self.cx.tcx)\n+                .visit_ty(self.body.local_decls[*dest].ty)\n+                .is_break()\n+            {\n                 mutable_variables.push(*dest);\n             }\n "}, {"sha": "9588de8459cfe3f337b2351cc6afc5b6c6e8b800", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -295,6 +295,7 @@ declare_clippy_lint! {\n pub struct Types {\n     vec_box_size_threshold: u64,\n     type_complexity_threshold: u64,\n+    avoid_breaking_exported_api: bool,\n }\n \n impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, RC_MUTEX, TYPE_COMPLEXITY]);\n@@ -308,19 +309,31 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n             false\n         };\n \n+        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(id));\n+\n         self.check_fn_decl(\n             cx,\n             decl,\n             CheckTyContext {\n                 is_in_trait_impl,\n+                is_exported,\n                 ..CheckTyContext::default()\n             },\n         );\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let is_exported = cx.access_levels.is_exported(item.def_id);\n+\n         match item.kind {\n-            ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(cx, ty, CheckTyContext::default()),\n+            ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_exported,\n+                    ..CheckTyContext::default()\n+                },\n+            ),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n@@ -342,15 +355,31 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.check_ty(cx, field.ty, CheckTyContext::default());\n+        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n+\n+        self.check_ty(\n+            cx,\n+            field.ty,\n+            CheckTyContext {\n+                is_exported,\n+                ..CheckTyContext::default()\n+            },\n+        );\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &TraitItem<'_>) {\n+        let is_exported = cx.access_levels.is_exported(item.def_id);\n+\n+        let context = CheckTyContext {\n+            is_exported,\n+            ..CheckTyContext::default()\n+        };\n+\n         match item.kind {\n             TraitItemKind::Const(ty, _) | TraitItemKind::Type(_, Some(ty)) => {\n-                self.check_ty(cx, ty, CheckTyContext::default());\n+                self.check_ty(cx, ty, context);\n             },\n-            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, CheckTyContext::default()),\n+            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, context),\n             TraitItemKind::Type(..) => (),\n         }\n     }\n@@ -370,10 +399,11 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n }\n \n impl Types {\n-    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64) -> Self {\n+    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64, avoid_breaking_exported_api: bool) -> Self {\n         Self {\n             vec_box_size_threshold,\n             type_complexity_threshold,\n+            avoid_breaking_exported_api,\n         }\n     }\n \n@@ -410,17 +440,24 @@ impl Types {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n-                    let mut triggered = false;\n-                    triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n-                    triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n-                    triggered |= linked_list::check(cx, hir_ty, def_id);\n-                    triggered |= rc_mutex::check(cx, hir_ty, qpath, def_id);\n-\n-                    if triggered {\n-                        return;\n+                    if self.is_type_change_allowed(context) {\n+                        // All lints that are being checked in this block are guarded by\n+                        // the `avoid_breaking_exported_api` configuration. When adding a\n+                        // new lint, please also add the name to the configuration documentation\n+                        // in `clippy_lints::utils::conf.rs`\n+\n+                        let mut triggered = false;\n+                        triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n+                        triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n+                        triggered |= linked_list::check(cx, hir_ty, def_id);\n+                        triggered |= rc_mutex::check(cx, hir_ty, qpath, def_id);\n+\n+                        if triggered {\n+                            return;\n+                        }\n                     }\n                 }\n                 match *qpath {\n@@ -487,11 +524,21 @@ impl Types {\n             _ => {},\n         }\n     }\n+\n+    /// This function checks if the type is allowed to change in the current context\n+    /// based on the `avoid_breaking_exported_api` configuration\n+    fn is_type_change_allowed(&self, context: CheckTyContext) -> bool {\n+        !(context.is_exported && self.avoid_breaking_exported_api)\n+    }\n }\n \n+#[allow(clippy::struct_excessive_bools)]\n #[derive(Clone, Copy, Default)]\n struct CheckTyContext {\n     is_in_trait_impl: bool,\n+    /// `true` for types on local variables.\n     is_local: bool,\n+    /// `true` for types that are part of the public API.\n+    is_exported: bool,\n     is_nested_call: bool,\n }"}, {"sha": "12db7afb81ca113dd822582d6b16c65e815a3b39", "filename": "clippy_lints/src/types/rc_mutex.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_ty_param_diagnostic_item;\n use if_chain::if_chain;\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n@@ -11,13 +11,14 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n     if_chain! {\n         if cx.tcx.is_diagnostic_item(sym::Rc, def_id) ;\n         if let Some(_) = is_ty_param_diagnostic_item(cx, qpath, sym!(mutex_type)) ;\n-\n-        then{\n-            span_lint(\n+        then {\n+            span_lint_and_help(\n                 cx,\n                 RC_MUTEX,\n                 hir_ty.span,\n-                \"found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\",\n+                \"usage of `Rc<Mutex<_>>`\",\n+                None,\n+                \"consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\",\n             );\n             return true;\n         }"}, {"sha": "ac7bdd6a1ebebf318c6e8eab2a46bbcb999b2328", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -54,7 +54,13 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         _ => return false,\n     };\n     let inner_span = match get_qpath_generic_tys(inner_qpath).next() {\n-        Some(ty) => ty.span,\n+        Some(ty) => {\n+            // Box<Box<dyn T>> is smaller than Box<dyn T> because of wide pointers\n+            if matches!(ty.kind, TyKind::TraitObject(..)) {\n+                return false;\n+            }\n+            ty.span\n+        },\n         None => return false,\n     };\n     if inner_sym == outer_sym {"}, {"sha": "61670fe124e36f54055be9a58e1465e51ecfd9b1", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -218,7 +218,10 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n \n fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    matches!(ty.kind(), ty::Ref(..)) || ty.walk(cx.tcx).any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+    matches!(ty.kind(), ty::Ref(..))\n+        || ty\n+            .walk(cx.tcx)\n+            .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {"}, {"sha": "e7e249c79a2fad0f6f97e1a8110d62b41f763029", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::visitors::is_local_used;\n use if_chain::if_chain;\n use rustc_hir::{Impl, ImplItem, ImplItemKind, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -50,8 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n-            let self_hir_id = self_param.pat.hir_id;\n-            if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body);\n+            if !is_local_used(cx, body, self_param.pat.hir_id);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "881dc3219308b6128fa4e5fde30bc5fc8807366a", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -31,9 +31,6 @@ impl TryConf {\n     }\n }\n \n-/// Note that the configuration parsing currently doesn't support documentation that will\n-/// that spans over several lines. This will be possible with the new implementation\n-/// See (rust-clippy#7172)\n macro_rules! define_Conf {\n     ($(\n         $(#[doc = $doc:literal])+\n@@ -130,13 +127,12 @@ macro_rules! define_Conf {\n     };\n }\n \n-// N.B., this macro is parsed by util/lintlib.py\n define_Conf! {\n-    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION.\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_VEC, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "91533695eb309244da09432c806061bf69118009", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -82,7 +82,7 @@ This lint has the following configuration variables:\n /// `default`\n macro_rules! CONFIGURATION_VALUE_TEMPLATE {\n     () => {\n-        \"* {name}: `{ty}`: {doc} (defaults to `{default}`)\\n\"\n+        \"* `{name}`: `{ty}`: {doc} (defaults to `{default}`)\\n\"\n     };\n }\n "}, {"sha": "9302e5c21faa4f7606d485726bcbf256aba1cfb8", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -21,7 +21,7 @@ fn docs_link(diag: &mut DiagnosticBuilder<'_>, lint: &'static Lint) {\n                 \"for further information visit https://rust-lang.github.io/rust-clippy/{}/index.html#{}\",\n                 &option_env!(\"RUST_RELEASE_NUM\").map_or(\"master\".to_string(), |n| {\n                     // extract just major + minor version and ignore patch versions\n-                    format!(\"rust-{}\", n.rsplitn(2, '.').nth(1).unwrap())\n+                    format!(\"rust-{}\", n.rsplit_once('.').unwrap().1)\n                 }),\n                 lint\n             ));"}, {"sha": "d20739a9f74cc2d4da91903bf59865a11a4cf9aa", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -92,7 +92,14 @@ impl<'hir> IfLet<'hir> {\n             let hir = cx.tcx.hir();\n             let mut iter = hir.parent_iter(expr.hir_id);\n             if let Some((_, Node::Block(Block { stmts: [], .. }))) = iter.next() {\n-                if let Some((_, Node::Expr(Expr { kind: ExprKind::Loop(_, _, LoopSource::While, _), .. }))) = iter.next() {\n+                if let Some((\n+                    _,\n+                    Node::Expr(Expr {\n+                        kind: ExprKind::Loop(_, _, LoopSource::While, _),\n+                        ..\n+                    }),\n+                )) = iter.next()\n+                {\n                     // while loop desugar\n                     return None;\n                 }"}, {"sha": "7e03cf56e8a86d32f3191026a9c0369a9e9a7a3b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 258, "deletions": 27, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -2,6 +2,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(rustc_private)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n@@ -62,23 +63,27 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n+use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node, Param, Pat,\n+    PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n-use rustc_middle::ty::{layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::binding::BindingMode;\n+use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -89,7 +94,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_recursively_primitive_type};\n+use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -255,7 +260,17 @@ pub fn in_macro(span: Span) -> bool {\n }\n \n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Block(Block { stmts: [], expr: None, .. }, _) | ExprKind::Tup([]))\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: None,\n+                ..\n+            },\n+            _\n+        ) | ExprKind::Tup([])\n+    )\n }\n \n /// Checks if given pattern is a wildcard (`_`)\n@@ -630,11 +645,46 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n }\n \n /// Checks if the top level expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+/// Currently checks for:\n+/// * Break/Continue outside the given loop HIR ids.\n+/// * Yield/Return statments.\n+/// * Inline assembly.\n+/// * Usages of a field of a local where the type of the local can be partially moved.\n+///\n+/// For example, given the following function:\n+///\n+/// ```\n+/// fn f<'a>(iter: &mut impl Iterator<Item = (usize, &'a mut String)>) {\n+///     for item in iter {\n+///         let s = item.1;\n+///         if item.0 > 10 {\n+///             continue;\n+///         } else {\n+///             s.clear();\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// When called on the expression `item.0` this will return false unless the local `item` is in the\n+/// `ignore_locals` set. The type `(usize, &mut String)` can have the second element moved, so it\n+/// isn't always safe to move into a closure when only a single field is needed.\n+///\n+/// When called on the `continue` expression this will return false unless the outer loop expression\n+/// is in the `loop_ids` set.\n+///\n+/// Note that this check is not recursive, so passing the `if` expression will always return true\n+/// even though sub-expressions might return false.\n+pub fn can_move_expr_to_closure_no_visit(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    loop_ids: &[HirId],\n+    ignore_locals: &HirIdSet,\n+) -> bool {\n     match expr.kind {\n         ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n         | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n-            if jump_targets.contains(&id) =>\n+            if loop_ids.contains(&id) =>\n         {\n             true\n         },\n@@ -646,25 +696,163 @@ pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Exp\n         | ExprKind::LlvmInlineAsm(_) => false,\n         // Accessing a field of a local value can only be done if the type isn't\n         // partially moved.\n-        ExprKind::Field(base_expr, _)\n-            if matches!(\n-                base_expr.kind,\n-                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n-        {\n+        ExprKind::Field(\n+            &Expr {\n+                hir_id,\n+                kind:\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        Path {\n+                            res: Res::Local(local_id),\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            },\n+            _,\n+        ) if !ignore_locals.contains(local_id) && can_partially_move_ty(cx, cx.typeck_results().node_type(hir_id)) => {\n             // TODO: check if the local has been partially moved. Assume it has for now.\n             false\n-        }\n+        },\n         _ => true,\n     }\n }\n \n-/// Checks if the expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+/// How a local is captured by a closure\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureKind {\n+    Value,\n+    Ref(Mutability),\n+}\n+impl CaptureKind {\n+    pub fn is_imm_ref(self) -> bool {\n+        self == Self::Ref(Mutability::Not)\n+    }\n+}\n+impl std::ops::BitOr for CaptureKind {\n+    type Output = Self;\n+    fn bitor(self, rhs: Self) -> Self::Output {\n+        match (self, rhs) {\n+            (CaptureKind::Value, _) | (_, CaptureKind::Value) => CaptureKind::Value,\n+            (CaptureKind::Ref(Mutability::Mut), CaptureKind::Ref(_))\n+            | (CaptureKind::Ref(_), CaptureKind::Ref(Mutability::Mut)) => CaptureKind::Ref(Mutability::Mut),\n+            (CaptureKind::Ref(Mutability::Not), CaptureKind::Ref(Mutability::Not)) => CaptureKind::Ref(Mutability::Not),\n+        }\n+    }\n+}\n+impl std::ops::BitOrAssign for CaptureKind {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+/// Given an expression referencing a local, determines how it would be captured in a closure.\n+/// Note as this will walk up to parent expressions until the capture can be determined it should\n+/// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n+/// function argument (other than a receiver).\n+pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+    fn pat_capture_kind(cx: &LateContext<'_>, pat: &Pat<'_>) -> CaptureKind {\n+        let mut capture = CaptureKind::Ref(Mutability::Not);\n+        pat.each_binding_or_first(&mut |_, id, span, _| match cx\n+            .typeck_results()\n+            .extract_binding_mode(cx.sess(), id, span)\n+            .unwrap()\n+        {\n+            BindingMode::BindByValue(_) if !is_copy(cx, cx.typeck_results().node_type(id)) => {\n+                capture = CaptureKind::Value;\n+            },\n+            BindingMode::BindByReference(Mutability::Mut) if capture != CaptureKind::Value => {\n+                capture = CaptureKind::Ref(Mutability::Mut);\n+            },\n+            _ => (),\n+        });\n+        capture\n+    }\n+\n+    debug_assert!(matches!(\n+        e.kind,\n+        ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(_), .. }))\n+    ));\n+\n+    let map = cx.tcx.hir();\n+    let mut child_id = e.hir_id;\n+    let mut capture = CaptureKind::Value;\n+    let mut capture_expr_ty = e;\n+\n+    for (parent_id, parent) in map.parent_iter(e.hir_id) {\n+        if let [Adjustment {\n+            kind: Adjust::Deref(_) | Adjust::Borrow(AutoBorrow::Ref(..)),\n+            target,\n+        }, ref adjust @ ..] = *cx\n+            .typeck_results()\n+            .adjustments()\n+            .get(child_id)\n+            .map_or(&[][..], |x| &**x)\n+        {\n+            if let rustc_ty::RawPtr(TypeAndMut { mutbl: mutability, .. }) | rustc_ty::Ref(_, _, mutability) =\n+                *adjust.last().map_or(target, |a| a.target).kind()\n+            {\n+                return CaptureKind::Ref(mutability);\n+            }\n+        }\n+\n+        match parent {\n+            Node::Expr(e) => match e.kind {\n+                ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n+                ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n+                ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n+                    return CaptureKind::Ref(Mutability::Mut);\n+                },\n+                ExprKind::Field(..) => {\n+                    if capture == CaptureKind::Value {\n+                        capture_expr_ty = e;\n+                    }\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    let mut mutability = Mutability::Not;\n+                    for capture in arms.iter().map(|arm| pat_capture_kind(cx, arm.pat)) {\n+                        match capture {\n+                            CaptureKind::Value => break,\n+                            CaptureKind::Ref(Mutability::Mut) => mutability = Mutability::Mut,\n+                            CaptureKind::Ref(Mutability::Not) => (),\n+                        }\n+                    }\n+                    return CaptureKind::Ref(mutability);\n+                },\n+                _ => break,\n+            },\n+            Node::Local(l) => match pat_capture_kind(cx, l.pat) {\n+                CaptureKind::Value => break,\n+                capture @ CaptureKind::Ref(_) => return capture,\n+            },\n+            _ => break,\n+        }\n+\n+        child_id = parent_id;\n+    }\n+\n+    if capture == CaptureKind::Value && is_copy(cx, cx.typeck_results().expr_ty(capture_expr_ty)) {\n+        // Copy types are never automatically captured by value.\n+        CaptureKind::Ref(Mutability::Not)\n+    } else {\n+        capture\n+    }\n+}\n+\n+/// Checks if the expression can be moved into a closure as is. This will return a list of captures\n+/// if so, otherwise, `None`.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<HirIdMap<CaptureKind>> {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n+        // Stack of potential break targets contained in the expression.\n         loops: Vec<HirId>,\n+        /// Local variables created in the expression. These don't need to be captured.\n+        locals: HirIdSet,\n+        /// Whether this expression can be turned into a closure.\n         allow_closure: bool,\n+        /// Locals which need to be captured, and whether they need to be by value, reference, or\n+        /// mutable reference.\n+        captures: HirIdMap<CaptureKind>,\n     }\n     impl Visitor<'tcx> for V<'_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n@@ -676,24 +864,67 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n             if !self.allow_closure {\n                 return;\n             }\n-            if let ExprKind::Loop(b, ..) = e.kind {\n-                self.loops.push(e.hir_id);\n-                self.visit_block(b);\n-                self.loops.pop();\n-            } else {\n-                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n-                walk_expr(self, e);\n+\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, &Path { res: Res::Local(l), .. })) => {\n+                    if !self.locals.contains(&l) {\n+                        let cap = capture_local_usage(self.cx, e);\n+                        self.captures.entry(l).and_modify(|e| *e |= cap).or_insert(cap);\n+                    }\n+                },\n+                ExprKind::Closure(..) => {\n+                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id).to_def_id();\n+                    for capture in self.cx.typeck_results().closure_min_captures_flattened(closure_id) {\n+                        let local_id = match capture.place.base {\n+                            PlaceBase::Local(id) => id,\n+                            PlaceBase::Upvar(var) => var.var_path.hir_id,\n+                            _ => continue,\n+                        };\n+                        if !self.locals.contains(&local_id) {\n+                            let capture = match capture.info.capture_kind {\n+                                UpvarCapture::ByValue(_) => CaptureKind::Value,\n+                                UpvarCapture::ByRef(borrow) => match borrow.kind {\n+                                    BorrowKind::ImmBorrow => CaptureKind::Ref(Mutability::Not),\n+                                    BorrowKind::UniqueImmBorrow | BorrowKind::MutBorrow => {\n+                                        CaptureKind::Ref(Mutability::Mut)\n+                                    },\n+                                },\n+                            };\n+                            self.captures\n+                                .entry(local_id)\n+                                .and_modify(|e| *e |= capture)\n+                                .or_insert(capture);\n+                        }\n+                    }\n+                },\n+                ExprKind::Loop(b, ..) => {\n+                    self.loops.push(e.hir_id);\n+                    self.visit_block(b);\n+                    self.loops.pop();\n+                },\n+                _ => {\n+                    self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops, &self.locals);\n+                    walk_expr(self, e);\n+                },\n             }\n         }\n+\n+        fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+            p.each_binding_or_first(&mut |_, id, _, _| {\n+                self.locals.insert(id);\n+            });\n+        }\n     }\n \n     let mut v = V {\n         cx,\n         allow_closure: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n+        captures: HirIdMap::default(),\n     };\n     v.visit_expr(expr);\n-    v.allow_closure\n+    v.allow_closure.then(|| v.captures)\n }\n \n /// Returns the method names and argument list of nested method call expressions that make up\n@@ -1708,7 +1939,7 @@ pub fn peel_hir_expr_while<'tcx>(\n pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n     let mut remaining = count;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) if remaining != 0 => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) if remaining != 0 => {\n             remaining -= 1;\n             Some(e)\n         },\n@@ -1722,7 +1953,7 @@ pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>,\n pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     let mut count = 0;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, e) => {\n+        ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) => {\n             count += 1;\n             Some(e)\n         },"}, {"sha": "14234d9c9cbf0d6ce4384f7ae8b97a9294afc387", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -13,6 +13,7 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,53,0 { OR_PATTERNS }\n+    1,52,0 { STR_SPLIT_ONCE }\n     1,50,0 { BOOL_THEN }\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }"}, {"sha": "d7e46c2d3eb9d2826966f19fc3d8f98b058a150d", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -68,6 +68,7 @@ pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n+pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal-lints\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]"}, {"sha": "7f7fbdc9f21423feea5d974733fa0a75e8ed2c85", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, TyCtxt, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n+use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;"}, {"sha": "503effbdad5725069eb4ddc268a08c80ae7b9014", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -4,6 +4,7 @@ use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visito\n use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use std::ops::ControlFlow;\n \n /// returns `true` if expr contains match expr desugared from try\n fn contains_try(expr: &hir::Expr<'_>) -> bool {\n@@ -133,62 +134,6 @@ where\n     }\n }\n \n-pub struct LocalUsedVisitor<'hir> {\n-    hir: Map<'hir>,\n-    pub local_hir_id: HirId,\n-    pub used: bool,\n-}\n-\n-impl<'hir> LocalUsedVisitor<'hir> {\n-    pub fn new(cx: &LateContext<'hir>, local_hir_id: HirId) -> Self {\n-        Self {\n-            hir: cx.tcx.hir(),\n-            local_hir_id,\n-            used: false,\n-        }\n-    }\n-\n-    fn check<T>(&mut self, t: T, visit: fn(&mut Self, T)) -> bool {\n-        visit(self, t);\n-        std::mem::replace(&mut self.used, false)\n-    }\n-\n-    pub fn check_arm(&mut self, arm: &'hir Arm<'_>) -> bool {\n-        self.check(arm, Self::visit_arm)\n-    }\n-\n-    pub fn check_body(&mut self, body: &'hir Body<'_>) -> bool {\n-        self.check(body, Self::visit_body)\n-    }\n-\n-    pub fn check_expr(&mut self, expr: &'hir Expr<'_>) -> bool {\n-        self.check(expr, Self::visit_expr)\n-    }\n-\n-    pub fn check_stmt(&mut self, stmt: &'hir Stmt<'_>) -> bool {\n-        self.check(stmt, Self::visit_stmt)\n-    }\n-}\n-\n-impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n-    type Map = Map<'v>;\n-\n-    fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n-        if self.used {\n-            return;\n-        }\n-        if path_to_local_id(expr, self.local_hir_id) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.hir)\n-    }\n-}\n-\n /// A type which can be visited.\n pub trait Visitable<'tcx> {\n     /// Calls the corresponding `visit_*` function on the visitor.\n@@ -203,7 +148,22 @@ macro_rules! visitable_ref {\n         }\n     };\n }\n+visitable_ref!(Arm, visit_arm);\n visitable_ref!(Block, visit_block);\n+visitable_ref!(Body, visit_body);\n+visitable_ref!(Expr, visit_expr);\n+visitable_ref!(Stmt, visit_stmt);\n+\n+// impl<'tcx, I: IntoIterator> Visitable<'tcx> for I\n+// where\n+//     I::Item: Visitable<'tcx>,\n+// {\n+//     fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+//         for x in self {\n+//             x.visit(visitor);\n+//         }\n+//     }\n+// }\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n@@ -260,3 +220,48 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n     v.visit_expr(&cx.tcx.hir().body(body).value);\n     v.found\n }\n+\n+/// Calls the given function for each usage of the given local.\n+pub fn for_each_local_usage<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    visitable: impl Visitable<'tcx>,\n+    id: HirId,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<'tcx, B, F> {\n+        map: Map<'tcx>,\n+        id: HirId,\n+        f: F,\n+        res: ControlFlow<B>,\n+    }\n+    impl<'tcx, B, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>> Visitor<'tcx> for V<'tcx, B, F> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.map)\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.res.is_continue() {\n+                if path_to_local_id(e, self.id) {\n+                    self.res = (self.f)(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut v = V {\n+        map: cx.tcx.hir(),\n+        id,\n+        f,\n+        res: ControlFlow::CONTINUE,\n+    };\n+    visitable.visit(&mut v);\n+    v.res\n+}\n+\n+/// Checks if the given local is used.\n+pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n+    for_each_local_usage(cx, visitable, id, |_| ControlFlow::BREAK).is_break()\n+}"}, {"sha": "392b70ee3a963cf58ba1181944ee8b5e10e1d9b9", "filename": "doc/adding_lints.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -559,11 +559,12 @@ in the following steps:\n 1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n     like this:\n     ```rust\n-    /// Lint: LINT_NAME. <The configuration field doc comment>\n+    /// Lint: LINT_NAME.\n+    ///\n+    /// <The configuration field doc comment>\n     (configuration_ident: Type = DefaultValue),\n     ```\n-    The configuration value and identifier should usually be the same. The doc comment will be\n-    automatically added to the lint documentation.\n+    The doc comment will be automatically added to the lint documentation.\n 2. Adding the configuration value to the lint impl struct:\n     1. This first requires the definition of a lint impl struct. Lint impl structs are usually\n         generated with the `declare_lint_pass!` macro. This struct needs to be defined manually"}, {"sha": "1a6b7c8cb47a9db623f64fe5868d29d5f1dd5a40", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -11,6 +11,7 @@ You may need following tooltips to catch up with common operations.\n \n Useful Rustc dev guide links:\n - [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n+- [Diagnostic items](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html)\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n@@ -75,20 +76,21 @@ impl LateLintPass<'_> for MyStructLint {\n \n # Checking if a type implements a specific trait\n \n-There are two ways to do this, depending if the target trait is part of lang items.\n+There are three ways to do this, depending on if the target trait has a diagnostic item, lang item or neither.\n \n ```rust\n-use clippy_utils::{implements_trait, match_trait_method, paths};\n+use clippy_utils::{implements_trait, is_trait_method, match_trait_method, paths};\n+use rustc_span::symbol::sym;\n \n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        // 1. Using expression and Clippy's convenient method\n-        // we use `match_trait_method` function from Clippy's toolbox\n-        if match_trait_method(cx, expr, &paths::INTO) {\n-            // `expr` implements `Into` trait\n+        // 1. Using diagnostic items with the expression\n+        // we use `is_trait_method` function from Clippy's utils\n+        if is_trait_method(cx, expr, sym::Iterator) {\n+            // method call in `expr` belongs to `Iterator` trait\n         }\n \n-        // 2. Using type context `TyCtxt`\n+        // 2. Using lang items with the expression type\n         let ty = cx.typeck_results().expr_ty(expr);\n         if cx.tcx.lang_items()\n             // we are looking for the `DefId` of `Drop` trait in lang items\n@@ -97,15 +99,20 @@ impl LateLintPass<'_> for MyStructLint {\n             .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n                 // `expr` implements `Drop` trait\n             }\n+\n+        // 3. Using the type path with the expression\n+        // we use `match_trait_method` function from Clippy's utils\n+        if match_trait_method(cx, expr, &paths::INTO) {\n+            // `expr` implements `Into` trait\n+        }\n     }\n }\n ```\n \n-> Prefer using lang items, if the target trait is available there.\n-\n-A list of defined paths for Clippy can be found in [paths.rs][paths]\n+> Prefer using diagnostic and lang items, if the target trait has one.\n \n We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n+A list of defined paths for Clippy can be found in [paths.rs][paths]\n \n # Checking if a type defines a specific method\n "}, {"sha": "ada033de6e3abe08ea16c946228514b4f95298ff", "filename": "lintcheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/lintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/lintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -19,6 +19,7 @@ serde_json = {version = \"1.0\"}\n tar = {version = \"0.4.30\"}\n toml = {version = \"0.5\"}\n ureq = {version = \"2.0.0-rc3\"}\n+walkdir = {version = \"2.3.2\"}\n \n [features]\n deny-warnings = []"}, {"sha": "f1e03ba42966d9bd31e3597f6d00ef0e0e1fe7b3", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -21,6 +21,7 @@ use clap::{App, Arg, ArgMatches};\n use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n+use walkdir::{DirEntry, WalkDir};\n \n #[cfg(not(windows))]\n const CLIPPY_DRIVER_PATH: &str = \"target/debug/clippy-driver\";\n@@ -193,32 +194,41 @@ impl CrateSource {\n                 }\n             },\n             CrateSource::Path { name, path, options } => {\n-                use fs_extra::dir;\n-\n-                // simply copy the entire directory into our target dir\n-                let copy_dest = PathBuf::from(format!(\"{}/\", LINTCHECK_SOURCES));\n+                // copy path into the dest_crate_root but skip directories that contain a CACHEDIR.TAG file.\n+                // The target/ directory contains a CACHEDIR.TAG file so it is the most commonly skipped directory\n+                // as a result of this filter.\n+                let dest_crate_root = PathBuf::from(LINTCHECK_SOURCES).join(name);\n+                if dest_crate_root.exists() {\n+                    println!(\"Deleting existing directory at {:?}\", dest_crate_root);\n+                    std::fs::remove_dir_all(&dest_crate_root).unwrap();\n+                }\n \n-                // the source path of the crate we copied,  ${copy_dest}/crate_name\n-                let crate_root = copy_dest.join(name); // .../crates/local_crate\n+                println!(\"Copying {:?} to {:?}\", path, dest_crate_root);\n \n-                if crate_root.exists() {\n-                    println!(\n-                        \"Not copying {} to {}, destination already exists\",\n-                        path.display(),\n-                        crate_root.display()\n-                    );\n-                } else {\n-                    println!(\"Copying {} to {}\", path.display(), copy_dest.display());\n+                fn is_cache_dir(entry: &DirEntry) -> bool {\n+                    std::fs::read(entry.path().join(\"CACHEDIR.TAG\"))\n+                        .map(|x| x.starts_with(b\"Signature: 8a477f597d28d172789f06886806bc55\"))\n+                        .unwrap_or(false)\n+                }\n \n-                    dir::copy(path, &copy_dest, &dir::CopyOptions::new()).unwrap_or_else(|_| {\n-                        panic!(\"Failed to copy from {}, to  {}\", path.display(), crate_root.display())\n-                    });\n+                for entry in WalkDir::new(path).into_iter().filter_entry(|e| !is_cache_dir(e)) {\n+                    let entry = entry.unwrap();\n+                    let entry_path = entry.path();\n+                    let relative_entry_path = entry_path.strip_prefix(path).unwrap();\n+                    let dest_path = dest_crate_root.join(relative_entry_path);\n+                    let metadata = entry_path.symlink_metadata().unwrap();\n+\n+                    if metadata.is_dir() {\n+                        std::fs::create_dir(dest_path).unwrap();\n+                    } else if metadata.is_file() {\n+                        std::fs::copy(entry_path, dest_path).unwrap();\n+                    }\n                 }\n \n                 Crate {\n                     version: String::from(\"local\"),\n                     name: name.clone(),\n-                    path: crate_root,\n+                    path: dest_crate_root,\n                     options: options.clone(),\n                 }\n             },"}, {"sha": "6116acffe07f4a4db75c12de2600a2f7547e8587", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -39,6 +39,7 @@ fn third_party_crates() -> String {\n         \"clippy_lints\",\n         \"clippy_utils\",\n         \"if_chain\",\n+        \"itertools\",\n         \"quote\",\n         \"regex\",\n         \"serde\","}, {"sha": "97d51462a946fc3dd4d1c59acf17e5583b540858", "filename": "tests/ui-cargo/feature_name/fail/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Ffeature_name%2Ffail%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,21 @@\n+\n+# Content that triggers the lint goes here\n+\n+[package]\n+name = \"feature_name\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[workspace]\n+\n+[features]\n+use-qwq = []\n+use_qwq = []\n+with-owo = []\n+with_owo = []\n+qvq-support = []\n+qvq_support = []\n+no-qaq = []\n+no_qaq = []\n+not-orz = []\n+not_orz = []"}, {"sha": "64f01a98c90e9c0ab647d28b3a693cc86fd67ab9", "filename": "tests/ui-cargo/feature_name/fail/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: --crate-name=feature_name\n+#![warn(clippy::redundant_feature_names)]\n+#![warn(clippy::negative_feature_names)]\n+\n+fn main() {\n+    // test code goes here\n+}"}, {"sha": "b9e6cb49bc982fbcb1f1b909d0d65a7eaaf61076", "filename": "tests/ui-cargo/feature_name/fail/src/main.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Ffeature_name%2Ffail%2Fsrc%2Fmain.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,44 @@\n+error: the \"no-\" prefix in the feature name \"no-qaq\" is negative\n+   |\n+   = note: `-D clippy::negative-feature-names` implied by `-D warnings`\n+   = help: consider renaming the feature to \"qaq\", but make sure the feature adds functionality\n+\n+error: the \"no_\" prefix in the feature name \"no_qaq\" is negative\n+   |\n+   = help: consider renaming the feature to \"qaq\", but make sure the feature adds functionality\n+\n+error: the \"not-\" prefix in the feature name \"not-orz\" is negative\n+   |\n+   = help: consider renaming the feature to \"orz\", but make sure the feature adds functionality\n+\n+error: the \"not_\" prefix in the feature name \"not_orz\" is negative\n+   |\n+   = help: consider renaming the feature to \"orz\", but make sure the feature adds functionality\n+\n+error: the \"-support\" suffix in the feature name \"qvq-support\" is redundant\n+   |\n+   = note: `-D clippy::redundant-feature-names` implied by `-D warnings`\n+   = help: consider renaming the feature to \"qvq\"\n+\n+error: the \"_support\" suffix in the feature name \"qvq_support\" is redundant\n+   |\n+   = help: consider renaming the feature to \"qvq\"\n+\n+error: the \"use-\" prefix in the feature name \"use-qwq\" is redundant\n+   |\n+   = help: consider renaming the feature to \"qwq\"\n+\n+error: the \"use_\" prefix in the feature name \"use_qwq\" is redundant\n+   |\n+   = help: consider renaming the feature to \"qwq\"\n+\n+error: the \"with-\" prefix in the feature name \"with-owo\" is redundant\n+   |\n+   = help: consider renaming the feature to \"owo\"\n+\n+error: the \"with_\" prefix in the feature name \"with_owo\" is redundant\n+   |\n+   = help: consider renaming the feature to \"owo\"\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "cf947312bd4798b38f721d1fa879a00d4cb461b2", "filename": "tests/ui-cargo/feature_name/pass/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Ffeature_name%2Fpass%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,9 @@\n+\n+# This file should not trigger the lint\n+\n+[package]\n+name = \"feature_name\"\n+version = \"0.1.0\"\n+publish = false\n+\n+[workspace]"}, {"sha": "64f01a98c90e9c0ab647d28b3a693cc86fd67ab9", "filename": "tests/ui-cargo/feature_name/pass/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Fpass%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Ffeature_name%2Fpass%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Ffeature_name%2Fpass%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: --crate-name=feature_name\n+#![warn(clippy::redundant_feature_names)]\n+#![warn(clippy::negative_feature_names)]\n+\n+fn main() {\n+    // test code goes here\n+}"}, {"sha": "27b61c09fb48b597ee0f28be1fa6e19a48578613", "filename": "tests/ui-cargo/module_style/fail_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "91cd540a28fddc60cc7427a55ad9713bae39c034", "filename": "tests/ui-cargo/module_style/fail_mod/src/bad/inner.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub mod stuff;"}, {"sha": "7713fa9d35c4a357a2ac0696d72e9989c320e194", "filename": "tests/ui-cargo/module_style/fail_mod/src/bad/inner/stuff.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,3 @@\n+pub mod most;\n+\n+pub struct Inner;"}, {"sha": "5a5eaf9670f9012a40b67a6599ac5b0665cee131", "filename": "tests/ui-cargo/module_style/fail_mod/src/bad/inner/stuff/most.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff%2Fmost.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff%2Fmost.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Finner%2Fstuff%2Fmost.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub struct Snarks;"}, {"sha": "a12734db7cb5f3175c32bfb2c518ee5f78a7b27f", "filename": "tests/ui-cargo/module_style/fail_mod/src/bad/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fbad%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,3 @@\n+pub mod inner;\n+\n+pub struct Thing;"}, {"sha": "3e985d4e904c16984bb29ea97697979027380a79", "filename": "tests/ui-cargo/module_style/fail_mod/src/main.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,9 @@\n+#![warn(clippy::self_named_module_files)]\n+\n+mod bad;\n+\n+fn main() {\n+    let _ = bad::Thing;\n+    let _ = bad::inner::stuff::Inner;\n+    let _ = bad::inner::stuff::most::Snarks;\n+}"}, {"sha": "af4c298b310852bf997a072838f58a71efcfe3fb", "filename": "tests/ui-cargo/module_style/fail_mod/src/main.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_mod%2Fsrc%2Fmain.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,19 @@\n+error: `mod.rs` files are required, found `/bad/inner.rs`\n+  --> $DIR/bad/inner.rs:1:1\n+   |\n+LL | pub mod stuff;\n+   | ^\n+   |\n+   = note: `-D clippy::self-named-module-files` implied by `-D warnings`\n+   = help: move `/bad/inner.rs` to `/bad/inner/mod.rs`\n+\n+error: `mod.rs` files are required, found `/bad/inner/stuff.rs`\n+  --> $DIR/bad/inner/stuff.rs:1:1\n+   |\n+LL | pub mod most;\n+   | ^\n+   |\n+   = help: move `/bad/inner/stuff.rs` to `/bad/inner/stuff/mod.rs`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "27b61c09fb48b597ee0f28be1fa6e19a48578613", "filename": "tests/ui-cargo/module_style/fail_no_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "f19ab10d5fb06c14bd8138abdfe9d782e61dc85d", "filename": "tests/ui-cargo/module_style/fail_no_mod/src/bad/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fbad%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fbad%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fbad%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub struct Thing;"}, {"sha": "c6e9045b8dc47c6c0d0911a6e26eacbb23d4c0ea", "filename": "tests/ui-cargo/module_style/fail_no_mod/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,7 @@\n+#![warn(clippy::mod_module_files)]\n+\n+mod bad;\n+\n+fn main() {\n+    let _ = bad::Thing;\n+}"}, {"sha": "11e15db7fb96b47829251b95126dae9af8791466", "filename": "tests/ui-cargo/module_style/fail_no_mod/src/main.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Ffail_no_mod%2Fsrc%2Fmain.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,11 @@\n+error: `mod.rs` files are not allowed, found `/bad/mod.rs`\n+  --> $DIR/bad/mod.rs:1:1\n+   |\n+LL | pub struct Thing;\n+   | ^\n+   |\n+   = note: `-D clippy::mod-module-files` implied by `-D warnings`\n+   = help: move `/bad/mod.rs` to `/bad.rs`\n+\n+error: aborting due to previous error\n+"}, {"sha": "27b61c09fb48b597ee0f28be1fa6e19a48578613", "filename": "tests/ui-cargo/module_style/pass_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "f19ab10d5fb06c14bd8138abdfe9d782e61dc85d", "filename": "tests/ui-cargo/module_style/pass_mod/src/bad/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fbad%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fbad%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fbad%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub struct Thing;"}, {"sha": "9e08715fc0522b411db17af915e310cd7557671e", "filename": "tests/ui-cargo/module_style/pass_mod/src/main.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,10 @@\n+#![warn(clippy::self_named_module_files)]\n+\n+mod bad;\n+mod more;\n+\n+fn main() {\n+    let _ = bad::Thing;\n+    let _ = more::foo::Foo;\n+    let _ = more::inner::Inner;\n+}"}, {"sha": "4a835673a596bcd05404f43d34082bf2785f2a9d", "filename": "tests/ui-cargo/module_style/pass_mod/src/more/foo.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Ffoo.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub struct Foo;"}, {"sha": "aa84f78cc2ca19a90feb696d2daecdbce92793d7", "filename": "tests/ui-cargo/module_style/pass_mod/src/more/inner/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Finner%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Finner%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Finner%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub struct Inner;"}, {"sha": "d79569f78ffbe60eea689a3c7afe69aaa9b1ff85", "filename": "tests/ui-cargo/module_style/pass_mod/src/more/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_mod%2Fsrc%2Fmore%2Fmod.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,2 @@\n+pub mod foo;\n+pub mod inner;"}, {"sha": "3c0896dd2cda7d921dceca29a1ca11f6b94df6f8", "filename": "tests/ui-cargo/module_style/pass_no_mod/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2FCargo.toml?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"pass\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "f19ab10d5fb06c14bd8138abdfe9d782e61dc85d", "filename": "tests/ui-cargo/module_style/pass_no_mod/src/good.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fgood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fgood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fgood.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1 @@\n+pub struct Thing;"}, {"sha": "50211a340b91b38e8d5a1f27daca27c84ad7e839", "filename": "tests/ui-cargo/module_style/pass_no_mod/src/main.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmodule_style%2Fpass_no_mod%2Fsrc%2Fmain.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,7 @@\n+#![warn(clippy::mod_module_files)]\n+\n+mod good;\n+\n+fn main() {\n+    let _ = good::Thing;\n+}"}, {"sha": "86a637ce3093c5ee936983cdc49c5477cab6cd52", "filename": "tests/ui/auxiliary/option_helpers.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Foption_helpers.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -53,3 +53,12 @@ impl IteratorFalsePositives {\n         self.foo as usize\n     }\n }\n+\n+#[derive(Copy, Clone)]\n+pub struct IteratorMethodFalsePositives;\n+\n+impl IteratorMethodFalsePositives {\n+    pub fn filter(&self, _s: i32) -> std::vec::IntoIter<i32> {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "ec4d6f3ff840113829343f89f7ff45f2d9e45f8b", "filename": "tests/ui/bool_assert_comparison.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::bool_assert_comparison)]\n \n+use std::ops::Not;\n+\n macro_rules! a {\n     () => {\n         true\n@@ -11,14 +13,67 @@ macro_rules! b {\n     };\n }\n \n+// Implements the Not trait but with an output type\n+// that's not bool. Should not suggest a rewrite\n+#[derive(Debug)]\n+enum ImplNotTraitWithoutBool {\n+    VariantX(bool),\n+    VariantY(u32),\n+}\n+\n+impl PartialEq<bool> for ImplNotTraitWithoutBool {\n+    fn eq(&self, other: &bool) -> bool {\n+        match *self {\n+            ImplNotTraitWithoutBool::VariantX(b) => b == *other,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Not for ImplNotTraitWithoutBool {\n+    type Output = Self;\n+\n+    fn not(self) -> Self::Output {\n+        match self {\n+            ImplNotTraitWithoutBool::VariantX(b) => ImplNotTraitWithoutBool::VariantX(!b),\n+            ImplNotTraitWithoutBool::VariantY(0) => ImplNotTraitWithoutBool::VariantY(1),\n+            ImplNotTraitWithoutBool::VariantY(_) => ImplNotTraitWithoutBool::VariantY(0),\n+        }\n+    }\n+}\n+\n+// This type implements the Not trait with an Output of\n+// type bool. Using assert!(..) must be suggested\n+#[derive(Debug)]\n+struct ImplNotTraitWithBool;\n+\n+impl PartialEq<bool> for ImplNotTraitWithBool {\n+    fn eq(&self, other: &bool) -> bool {\n+        false\n+    }\n+}\n+\n+impl Not for ImplNotTraitWithBool {\n+    type Output = bool;\n+\n+    fn not(self) -> Self::Output {\n+        true\n+    }\n+}\n+\n fn main() {\n+    let a = ImplNotTraitWithoutBool::VariantX(true);\n+    let b = ImplNotTraitWithBool;\n+\n     assert_eq!(\"a\".len(), 1);\n     assert_eq!(\"a\".is_empty(), false);\n     assert_eq!(\"\".is_empty(), true);\n     assert_eq!(true, \"\".is_empty());\n     assert_eq!(a!(), b!());\n     assert_eq!(a!(), \"\".is_empty());\n     assert_eq!(\"\".is_empty(), b!());\n+    assert_eq!(a, true);\n+    assert_eq!(b, true);\n \n     assert_ne!(\"a\".len(), 1);\n     assert_ne!(\"a\".is_empty(), false);\n@@ -27,6 +82,8 @@ fn main() {\n     assert_ne!(a!(), b!());\n     assert_ne!(a!(), \"\".is_empty());\n     assert_ne!(\"\".is_empty(), b!());\n+    assert_ne!(a, true);\n+    assert_ne!(b, true);\n \n     debug_assert_eq!(\"a\".len(), 1);\n     debug_assert_eq!(\"a\".is_empty(), false);\n@@ -35,6 +92,8 @@ fn main() {\n     debug_assert_eq!(a!(), b!());\n     debug_assert_eq!(a!(), \"\".is_empty());\n     debug_assert_eq!(\"\".is_empty(), b!());\n+    debug_assert_eq!(a, true);\n+    debug_assert_eq!(b, true);\n \n     debug_assert_ne!(\"a\".len(), 1);\n     debug_assert_ne!(\"a\".is_empty(), false);\n@@ -43,17 +102,21 @@ fn main() {\n     debug_assert_ne!(a!(), b!());\n     debug_assert_ne!(a!(), \"\".is_empty());\n     debug_assert_ne!(\"\".is_empty(), b!());\n+    debug_assert_ne!(a, true);\n+    debug_assert_ne!(b, true);\n \n     // assert with error messages\n     assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n     assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+    assert_eq!(a, true, \"tadam {}\", false);\n \n     debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", 1);\n     debug_assert_eq!(\"a\".len(), 1, \"tadam {}\", true);\n     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n+    debug_assert_eq!(a, true, \"tadam {}\", false);\n }"}, {"sha": "da9b56aa7795d4e9c2396dabf655764996fab801", "filename": "tests/ui/bool_assert_comparison.stderr", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbool_assert_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbool_assert_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_assert_comparison.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,112 +1,136 @@\n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:16:5\n+  --> $DIR/bool_assert_comparison.rs:69:5\n    |\n LL |     assert_eq!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n    |\n    = note: `-D clippy::bool-assert-comparison` implied by `-D warnings`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:17:5\n+  --> $DIR/bool_assert_comparison.rs:70:5\n    |\n LL |     assert_eq!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:18:5\n+  --> $DIR/bool_assert_comparison.rs:71:5\n    |\n LL |     assert_eq!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n+error: used `assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:76:5\n+   |\n+LL |     assert_eq!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n error: used `assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:24:5\n+  --> $DIR/bool_assert_comparison.rs:79:5\n    |\n LL |     assert_ne!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:25:5\n+  --> $DIR/bool_assert_comparison.rs:80:5\n    |\n LL |     assert_ne!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:26:5\n+  --> $DIR/bool_assert_comparison.rs:81:5\n    |\n LL |     assert_ne!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n+error: used `assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:86:5\n+   |\n+LL |     assert_ne!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n+\n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:32:5\n+  --> $DIR/bool_assert_comparison.rs:89:5\n    |\n LL |     debug_assert_eq!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:33:5\n+  --> $DIR/bool_assert_comparison.rs:90:5\n    |\n LL |     debug_assert_eq!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:34:5\n+  --> $DIR/bool_assert_comparison.rs:91:5\n    |\n LL |     debug_assert_eq!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n+error: used `debug_assert_eq!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:96:5\n+   |\n+LL |     debug_assert_eq!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n error: used `debug_assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:40:5\n+  --> $DIR/bool_assert_comparison.rs:99:5\n    |\n LL |     debug_assert_ne!(\"a\".is_empty(), false);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:41:5\n+  --> $DIR/bool_assert_comparison.rs:100:5\n    |\n LL |     debug_assert_ne!(\"\".is_empty(), true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_ne!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:42:5\n+  --> $DIR/bool_assert_comparison.rs:101:5\n    |\n LL |     debug_assert_ne!(true, \"\".is_empty());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n+error: used `debug_assert_ne!` with a literal bool\n+  --> $DIR/bool_assert_comparison.rs:106:5\n+   |\n+LL |     debug_assert_ne!(b, true);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n+\n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:50:5\n+  --> $DIR/bool_assert_comparison.rs:111:5\n    |\n LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:51:5\n+  --> $DIR/bool_assert_comparison.rs:112:5\n    |\n LL |     assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:52:5\n+  --> $DIR/bool_assert_comparison.rs:113:5\n    |\n LL |     assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:56:5\n+  --> $DIR/bool_assert_comparison.rs:118:5\n    |\n LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", 1);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:57:5\n+  --> $DIR/bool_assert_comparison.rs:119:5\n    |\n LL |     debug_assert_eq!(\"a\".is_empty(), false, \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n error: used `debug_assert_eq!` with a literal bool\n-  --> $DIR/bool_assert_comparison.rs:58:5\n+  --> $DIR/bool_assert_comparison.rs:120:5\n    |\n LL |     debug_assert_eq!(false, \"a\".is_empty(), \"tadam {}\", true);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `debug_assert!(..)`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "1d6366972dacfb529ce1e2295934d95adab58878", "filename": "tests/ui/box_vec.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_vec.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,6 +1,10 @@\n #![warn(clippy::all)]\n-#![allow(clippy::boxed_local, clippy::needless_pass_by_value)]\n-#![allow(clippy::blacklisted_name)]\n+#![allow(\n+    clippy::boxed_local,\n+    clippy::needless_pass_by_value,\n+    clippy::blacklisted_name,\n+    unused\n+)]\n \n macro_rules! boxit {\n     ($init:expr, $x:ty) => {\n@@ -11,22 +15,22 @@ macro_rules! boxit {\n fn test_macro() {\n     boxit!(Vec::new(), Vec<u8>);\n }\n-pub fn test(foo: Box<Vec<bool>>) {\n-    println!(\"{:?}\", foo.get(0))\n-}\n+fn test(foo: Box<Vec<bool>>) {}\n \n-pub fn test2(foo: Box<dyn Fn(Vec<u32>)>) {\n+fn test2(foo: Box<dyn Fn(Vec<u32>)>) {\n     // pass if #31 is fixed\n     foo(vec![1, 2, 3])\n }\n \n-pub fn test_local_not_linted() {\n+fn test_local_not_linted() {\n     let _: Box<Vec<bool>>;\n }\n \n-fn main() {\n-    test(Box::new(Vec::new()));\n-    test2(Box::new(|v| println!(\"{:?}\", v)));\n-    test_macro();\n-    test_local_not_linted();\n+// All of these test should be allowed because they are part of the\n+// public api and `avoid_breaking_exported_api` is `false` by default.\n+pub fn pub_test(foo: Box<Vec<bool>>) {}\n+pub fn pub_test_ret() -> Box<Vec<bool>> {\n+    Box::new(Vec::new())\n }\n+\n+fn main() {}"}, {"sha": "58c1f13fb877b1ba77deda63048b0ed41bf36314", "filename": "tests/ui/box_vec.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbox_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fbox_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_vec.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,8 +1,8 @@\n error: you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\n-  --> $DIR/box_vec.rs:14:18\n+  --> $DIR/box_vec.rs:18:14\n    |\n-LL | pub fn test(foo: Box<Vec<bool>>) {\n-   |                  ^^^^^^^^^^^^^^\n+LL | fn test(foo: Box<Vec<bool>>) {}\n+   |              ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::box-vec` implied by `-D warnings`\n    = help: `Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation"}, {"sha": "8a36ec833d76d3aa331b120d356507efe46168e1", "filename": "tests/ui/entry.fixed", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -142,14 +142,13 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n-    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-        e.insert(v);\n-        foo();\n-    }\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n+    m.entry(k).or_insert_with(|| {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n+        v\n+    });\n }\n \n fn main() {}"}, {"sha": "d972a201ad76460e401c6a0ff613eab5e4f53af9", "filename": "tests/ui/entry.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -146,13 +146,12 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n     if !m.contains_key(&k) {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n         m.insert(k, v);\n-        foo();\n     }\n }\n "}, {"sha": "1076500498d32fe321a2de82c68e91514cae9ac8", "filename": "tests/ui/entry.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -165,21 +165,23 @@ LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n    | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry.rs:153:5\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:151:5\n    |\n LL | /     if !m.contains_key(&k) {\n+LL | |         let x = (String::new(), String::new());\n+LL | |         let _ = x.0;\n LL | |         m.insert(k, v);\n-LL | |         foo();\n LL | |     }\n    | |_____^\n    |\n help: try this\n    |\n-LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-LL +         e.insert(v);\n-LL +         foo();\n-LL +     }\n+LL ~     m.entry(k).or_insert_with(|| {\n+LL +         let x = (String::new(), String::new());\n+LL +         let _ = x.0;\n+LL +         v\n+LL +     });\n    |\n \n error: aborting due to 10 previous errors"}, {"sha": "94979104556bc882267d230b41c535319d712bd8", "filename": "tests/ui/entry_btree.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry_btree.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry_btree.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.fixed?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "080c1d959e89425d326ae8c05e8053128a347425", "filename": "tests/ui/entry_btree.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry_btree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry_btree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5c6fcdf1a28c01f1ba0cbdd646bfb48453cde0e3", "filename": "tests/ui/entry_btree.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry_btree.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fentry_btree.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,20 @@\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry_btree.rs:12:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL +         e.insert(v);\n+LL +         foo();\n+LL +     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "690ea810a6214072f1a1614304624f22cb30befc", "filename": "tests/ui/linkedlist.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Flinkedlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Flinkedlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkedlist.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,6 +1,6 @@\n #![feature(associated_type_defaults)]\n #![warn(clippy::linkedlist)]\n-#![allow(dead_code, clippy::needless_pass_by_value)]\n+#![allow(unused, dead_code, clippy::needless_pass_by_value)]\n \n extern crate alloc;\n use alloc::collections::linked_list::LinkedList;\n@@ -20,24 +20,29 @@ impl Foo for LinkedList<u8> {\n     const BAR: Option<LinkedList<u8>> = None;\n }\n \n-struct Bar;\n+pub struct Bar {\n+    priv_linked_list_field: LinkedList<u8>,\n+    pub pub_linked_list_field: LinkedList<u8>,\n+}\n impl Bar {\n     fn foo(_: LinkedList<u8>) {}\n }\n \n-pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n-    println!(\"{:?}\", my_favourite_linked_list)\n-}\n-\n-pub fn test_ret() -> Option<LinkedList<u8>> {\n-    unimplemented!();\n+// All of these test should be trigger the lint because they are not\n+// part of the public api\n+fn test(my_favorite_linked_list: LinkedList<u8>) {}\n+fn test_ret() -> Option<LinkedList<u8>> {\n+    None\n }\n-\n-pub fn test_local_not_linted() {\n+fn test_local_not_linted() {\n     let _: LinkedList<u8>;\n }\n \n-fn main() {\n-    test(LinkedList::new());\n-    test_local_not_linted();\n+// All of these test should be allowed because they are part of the\n+// public api and `avoid_breaking_exported_api` is `false` by default.\n+pub fn pub_test(the_most_awesome_linked_list: LinkedList<u8>) {}\n+pub fn pub_test_ret() -> Option<LinkedList<u8>> {\n+    None\n }\n+\n+fn main() {}"}, {"sha": "51327df13211879da10fb77801a1c6a2e44be1c2", "filename": "tests/ui/linkedlist.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Flinkedlist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Flinkedlist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkedlist.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -40,28 +40,36 @@ LL |     const BAR: Option<LinkedList<u8>>;\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/linkedlist.rs:25:15\n+  --> $DIR/linkedlist.rs:24:29\n+   |\n+LL |     priv_linked_list_field: LinkedList<u8>,\n+   |                             ^^^^^^^^^^^^^^\n+   |\n+   = help: a `VecDeque` might work\n+\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n+  --> $DIR/linkedlist.rs:28:15\n    |\n LL |     fn foo(_: LinkedList<u8>) {}\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/linkedlist.rs:28:39\n+  --> $DIR/linkedlist.rs:33:34\n    |\n-LL | pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n-   |                                       ^^^^^^^^^^^^^^\n+LL | fn test(my_favorite_linked_list: LinkedList<u8>) {}\n+   |                                  ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/linkedlist.rs:32:29\n+  --> $DIR/linkedlist.rs:34:25\n    |\n-LL | pub fn test_ret() -> Option<LinkedList<u8>> {\n-   |                             ^^^^^^^^^^^^^^\n+LL | fn test_ret() -> Option<LinkedList<u8>> {\n+   |                         ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "7db6b730963c94f6399e4ff2a69921b2a0d3ff61", "filename": "tests/ui/manual_flatten.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -91,6 +91,19 @@ fn main() {\n         }\n     }\n \n+    struct Test {\n+        a: usize,\n+    }\n+\n+    let mut vec_of_struct = [Some(Test { a: 1 }), None];\n+\n+    // Usage of `if let` expression should not trigger lint\n+    for n in vec_of_struct.iter_mut() {\n+        if let Some(z) = n {\n+            *n = None;\n+        }\n+    }\n+\n     // Using manual flatten should not trigger the lint\n     for n in vec![Some(1), Some(2), Some(3)].iter().flatten() {\n         println!(\"{}\", n);"}, {"sha": "8cc12149403d32aa22aaba2618c187eb65ea5c20", "filename": "tests/ui/manual_map_option_2.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n+\n+fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n+    let _ = Some(0).map(|x| {\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        });\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = s.as_ref().map(|x| {\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        });\n+}"}, {"sha": "0862b201ead4b7290f600e6b27454a8a1b72dc4a", "filename": "tests/ui/manual_map_option_2.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::toplevel_ref_arg)]\n+\n+fn main() {\n+    // Lint. `y` is declared within the arm, so it isn't captured by the map closure\n+    let _ = match Some(0) {\n+        Some(x) => Some({\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured by the map\n+    // closure\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let s = || s;\n+            (clone, s())\n+        }),\n+        None => None,\n+    };\n+\n+    // Don't lint. `s` is borrowed until partway through the arm, but needs to be captured as a mutable\n+    // reference by the map closure\n+    let mut s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            let clone = x.clone();\n+            let ref mut s = s;\n+            (clone, s)\n+        }),\n+        None => None,\n+    };\n+\n+    // Lint. `s` is captured by reference, so no lifetime issues.\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some({\n+            if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+        }),\n+        None => None,\n+    };\n+}"}, {"sha": "711ff6c4a4b095dfc5da5efd75116e4b2fa5445d", "filename": "tests/ui/manual_map_option_2.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,43 @@\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:8:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             let y = (String::new(), String::new());\n+LL | |             (x, y.0)\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-map` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     let _ = Some(0).map(|x| {\n+LL +             let y = (String::new(), String::new());\n+LL +             (x, y.0)\n+LL ~         });\n+   |\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:50:13\n+   |\n+LL |       let _ = match &s {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     let _ = s.as_ref().map(|x| {\n+LL +             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n+LL ~         });\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3a0332939d409a8237572e97d489bce948b44817", "filename": "tests/ui/manual_split_once.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0));\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let (_, _) = \"key=value\".split_once('=').unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = &\"key=value\";\n+    let _ = s.split_once('=').map_or(*s, |x| x.0);\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.split_once(\"key=value\").map_or(s, |x| x.0);\n+        let _ = s.split_once(\"key=value\")?.1;\n+        let _ = s.split_once(\"key=value\")?.1;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+}"}, {"sha": "e6093b63fe8d428e348760d6a496a3ae4d433090", "filename": "tests/ui/manual_split_once.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = \"key=value\".splitn(2, '=').next();\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+    let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.splitn(2, '=').next().unwrap();\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.splitn(2, '=').nth(0).unwrap();\n+\n+    let s = &\"key=value\";\n+    let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.splitn(2, \"key=value\").next()?;\n+        let _ = s.splitn(2, \"key=value\").nth(1)?;\n+        let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}"}, {"sha": "4f15196b469e1f73d713f527edca2c57b22af889", "filename": "tests/ui/manual_split_once.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -0,0 +1,82 @@\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:13:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0))`\n+   |\n+   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:15:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:16:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:17:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:18:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:19:18\n+   |\n+LL |     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=')`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:22:13\n+   |\n+LL |     let _ = s.splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:25:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:28:13\n+   |\n+LL |     let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:31:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\").map_or(s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:32:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:33:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:49:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "c441b35b9920390c89edfc6ac504716cf25eae2f", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -32,7 +32,7 @@ use std::ops::Mul;\n use std::rc::{self, Rc};\n use std::sync::{self, Arc};\n \n-use option_helpers::IteratorFalsePositives;\n+use option_helpers::{IteratorFalsePositives, IteratorMethodFalsePositives};\n \n struct Lt<'a> {\n     foo: &'a u32,\n@@ -131,6 +131,9 @@ fn filter_next() {\n     // Check that we don't lint if the caller is not an `Iterator`.\n     let foo = IteratorFalsePositives { foo: 0 };\n     let _ = foo.filter().next();\n+\n+    let foo = IteratorMethodFalsePositives {};\n+    let _ = foo.filter(42).next();\n }\n \n fn main() {"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/missing-doc-crate.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/78bf4acc3a18848e21896bae97859c5811b320d4/tests%2Fui%2Fmissing-doc-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78bf4acc3a18848e21896bae97859c5811b320d4/tests%2Fui%2Fmissing-doc-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-crate.stderr?ref=78bf4acc3a18848e21896bae97859c5811b320d4"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/missing_const_for_fn/cant_be_const.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/78bf4acc3a18848e21896bae97859c5811b320d4/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78bf4acc3a18848e21896bae97859c5811b320d4/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_const_for_fn%2Fcant_be_const.stderr?ref=78bf4acc3a18848e21896bae97859c5811b320d4"}, {"sha": "d1815d0aec331692f66945f584d298fdb9e8d839", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n@@ -86,4 +87,65 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = Some(0).map_or(0, |x| loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        });\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = Some(0).map_or_else(|| s.len(), |x| s.len() + x);\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = Some(0).map_or(1, |x| {\n+        let s = s;\n+        s.len() + x\n+    });\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n+\n+    let mut s = Some(String::new());\n+    // Don't lint, `Some` branch mutably borrows `s`, but else branch also borrows  `s`\n+    let _ = if let Some(x) = &mut s {\n+        x.push_str(\"test\");\n+        x.len()\n+    } else {\n+        let _s = &s;\n+        10\n+    };\n+\n+    async fn _f1(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn _f2() {\n+        // Don't lint. `await` can't be moved into a closure.\n+        let _ = if let Some(x) = Some(0) { _f1(x).await } else { 0 };\n+    }\n }"}, {"sha": "a15627338cb4aaeaa8460c83d03f5e30f5c86c2d", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n@@ -105,4 +106,71 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = if let Some(x) = Some(0) {\n+        loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        }\n+    } else {\n+        0\n+    };\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        1\n+    };\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n+\n+    let mut s = Some(String::new());\n+    // Don't lint, `Some` branch mutably borrows `s`, but else branch also borrows  `s`\n+    let _ = if let Some(x) = &mut s {\n+        x.push_str(\"test\");\n+        x.len()\n+    } else {\n+        let _s = &s;\n+        10\n+    };\n+\n+    async fn _f1(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn _f2() {\n+        // Don't lint. `await` can't be moved into a closure.\n+        let _ = if let Some(x) = Some(0) { _f1(x).await } else { 0 };\n+    }\n }"}, {"sha": "ed748ee8b39e4422c034f9a96982316dbb256745", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:7:5\n+  --> $DIR/option_if_let_else.rs:8:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,19 +11,19 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:26:13\n+  --> $DIR/option_if_let_else.rs:27:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:27:13\n+  --> $DIR/option_if_let_else.rs:28:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -43,13 +43,13 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:33:13\n+  --> $DIR/option_if_let_else.rs:34:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:34:13\n+  --> $DIR/option_if_let_else.rs:35:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:40:13\n+  --> $DIR/option_if_let_else.rs:41:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -89,7 +89,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:49:5\n+  --> $DIR/option_if_let_else.rs:50:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -108,7 +108,7 @@ LL +     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:62:13\n+  --> $DIR/option_if_let_else.rs:63:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |     };\n    | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:71:13\n+  --> $DIR/option_if_let_else.rs:72:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -143,10 +143,58 @@ LL ~     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:100:13\n+  --> $DIR/option_if_let_else.rs:101:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 11 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:110:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         loop {\n+LL | |             if x == 0 {\n+LL | |                 break x;\n+...  |\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(0, |x| loop {\n+LL +             if x == 0 {\n+LL +                 break x;\n+LL +             }\n+LL ~         });\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:138:13\n+   |\n+LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or_else(|| s.len(), |x| s.len() + x)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:142:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         let s = s;\n+LL | |         s.len() + x\n+LL | |     } else {\n+LL | |         1\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(1, |x| {\n+LL +         let s = s;\n+LL +         s.len() + x\n+LL ~     });\n+   |\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/rc_buffer_redefined_string.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/78bf4acc3a18848e21896bae97859c5811b320d4/tests%2Fui%2Frc_buffer_redefined_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78bf4acc3a18848e21896bae97859c5811b320d4/tests%2Fui%2Frc_buffer_redefined_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_buffer_redefined_string.stderr?ref=78bf4acc3a18848e21896bae97859c5811b320d4"}, {"sha": "18e8a2e01e0227cc02478346c42822a45e4b1314", "filename": "tests/ui/rc_mutex.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_mutex.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,13 +1,17 @@\n #![warn(clippy::rc_mutex)]\n-#![allow(clippy::blacklisted_name)]\n+#![allow(unused, clippy::blacklisted_name)]\n \n use std::rc::Rc;\n use std::sync::Mutex;\n \n-pub struct MyStruct {\n+pub struct MyStructWithPrivItem {\n     foo: Rc<Mutex<i32>>,\n }\n \n+pub struct MyStructWithPubItem {\n+    pub foo: Rc<Mutex<i32>>,\n+}\n+\n pub struct SubT<T> {\n     foo: T,\n }\n@@ -17,18 +21,16 @@ pub enum MyEnum {\n     Two,\n }\n \n-pub fn test1<T>(foo: Rc<Mutex<T>>) {}\n-\n-pub fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+// All of these test should be trigger the lint because they are not\n+// part of the public api\n+fn test1<T>(foo: Rc<Mutex<T>>) {}\n+fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n \n-pub fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n+// All of these test should be allowed because they are part of the\n+// public api and `avoid_breaking_exported_api` is `false` by default.\n+pub fn pub_test1<T>(foo: Rc<Mutex<T>>) {}\n+pub fn pub_test2(foo: Rc<Mutex<MyEnum>>) {}\n+pub fn pub_test3(foo: Rc<Mutex<SubT<usize>>>) {}\n \n-fn main() {\n-    test1(Rc::new(Mutex::new(1)));\n-    test2(Rc::new(Mutex::new(MyEnum::One)));\n-    test3(Rc::new(Mutex::new(SubT { foo: 1 })));\n-\n-    let _my_struct = MyStruct {\n-        foo: Rc::new(Mutex::new(1)),\n-    };\n-}\n+fn main() {}"}, {"sha": "fe84361d781622b746522ed52e138bac237b2f46", "filename": "tests/ui/rc_mutex.stderr", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Frc_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Frc_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_mutex.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,28 +1,35 @@\n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n+error: usage of `Rc<Mutex<_>>`\n   --> $DIR/rc_mutex.rs:8:10\n    |\n LL |     foo: Rc<Mutex<i32>>,\n    |          ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::rc-mutex` implied by `-D warnings`\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n-  --> $DIR/rc_mutex.rs:20:22\n+error: usage of `Rc<Mutex<_>>`\n+  --> $DIR/rc_mutex.rs:26:18\n    |\n-LL | pub fn test1<T>(foo: Rc<Mutex<T>>) {}\n-   |                      ^^^^^^^^^^^^\n+LL | fn test1<T>(foo: Rc<Mutex<T>>) {}\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n-  --> $DIR/rc_mutex.rs:22:19\n+error: usage of `Rc<Mutex<_>>`\n+  --> $DIR/rc_mutex.rs:27:15\n+   |\n+LL | fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+   |               ^^^^^^^^^^^^^^^^^\n    |\n-LL | pub fn test2(foo: Rc<Mutex<MyEnum>>) {}\n-   |                   ^^^^^^^^^^^^^^^^^\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n-error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n-  --> $DIR/rc_mutex.rs:24:19\n+error: usage of `Rc<Mutex<_>>`\n+  --> $DIR/rc_mutex.rs:28:15\n+   |\n+LL | fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n+   |               ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | pub fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n \n error: aborting due to 4 previous errors\n "}, {"sha": "52fbc91e325555a9c808f57a47e76cc48e893363", "filename": "tests/ui/redundant_allocation.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -77,4 +77,24 @@ mod outer_arc {\n     }\n }\n \n+// https://github.com/rust-lang/rust-clippy/issues/7487\n+mod box_dyn {\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub trait T {}\n+\n+    struct S {\n+        a: Box<Box<dyn T>>,\n+        b: Rc<Box<dyn T>>,\n+        c: Arc<Box<dyn T>>,\n+    }\n+\n+    pub fn test_box(_: Box<Box<dyn T>>) {}\n+    pub fn test_rc(_: Rc<Box<dyn T>>) {}\n+    pub fn test_arc(_: Arc<Box<dyn T>>) {}\n+    pub fn test_rc_box(_: Rc<Box<Box<dyn T>>>) {}\n+}\n+\n fn main() {}"}, {"sha": "c3b10e5f5e679df879418117c4840aa6268b07dd", "filename": "tests/ui/redundant_allocation.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fredundant_allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Fredundant_allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -134,5 +134,14 @@ LL |     pub fn arc_test9<T>(foo: Arc<Rc<T>>) -> Arc<Rc<SubT<T>>> {\n    = note: `Rc<SubT<T>>` is already on the heap, `Arc<Rc<SubT<T>>>` makes an extra allocation\n    = help: consider using just `Arc<SubT<T>>` or `Rc<SubT<T>>`\n \n-error: aborting due to 15 previous errors\n+error: usage of `Rc<Box<Box<dyn T>>>`\n+  --> $DIR/redundant_allocation.rs:97:27\n+   |\n+LL |     pub fn test_rc_box(_: Rc<Box<Box<dyn T>>>) {}\n+   |                           ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Box<Box<dyn T>>` is already on the heap, `Rc<Box<Box<dyn T>>>` makes an extra allocation\n+   = help: consider using just `Rc<Box<dyn T>>` or `Box<Box<dyn T>>`\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "bf0ec8deb3458bccdc65a4151a8237241f6a0626", "filename": "tests/ui/unnecessary_operation.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Funnecessary_operation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Funnecessary_operation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_operation.fixed?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -62,10 +62,10 @@ fn main() {\n     get_number();\n     5;get_number();\n     42;get_number();\n-    [42, 55];get_usize();\n+    assert!([42, 55].len() > get_usize());\n     42;get_number();\n     get_number();\n-    [42; 55];get_usize();\n+    assert!([42; 55].len() > get_usize());\n     get_number();\n     String::from(\"blah\");\n "}, {"sha": "f66d08ecb8281bb9f5cd357b6482ebb8b9f9d714", "filename": "tests/ui/unnecessary_operation.stderr", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Funnecessary_operation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61bb96738ce020cd21d144be24da8d840a9a4f59/tests%2Fui%2Funnecessary_operation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_operation.stderr?ref=61bb96738ce020cd21d144be24da8d840a9a4f59", "patch": "@@ -1,128 +1,128 @@\n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:51:5\n    |\n LL |     Tuple(get_number());\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n    |\n    = note: `-D clippy::unnecessary-operation` implied by `-D warnings`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:52:5\n    |\n LL |     Struct { field: get_number() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:53:5\n    |\n LL |     Struct { ..get_struct() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_struct();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_struct();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:54:5\n    |\n LL |     Enum::Tuple(get_number());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:55:5\n    |\n LL |     Enum::Struct { field: get_number() };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:56:5\n    |\n LL |     5 + get_number();\n-   |     ^^^^^^^^^^^^^^^^^ help: replace it with: `5;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `5;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:57:5\n    |\n LL |     *&get_number();\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:58:5\n    |\n LL |     &get_number();\n-   |     ^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:59:5\n    |\n LL |     (5, 6, get_number());\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `5;6;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `5;6;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:60:5\n    |\n LL |     box get_number();\n-   |     ^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:61:5\n    |\n LL |     get_number()..;\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:62:5\n    |\n LL |     ..get_number();\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:63:5\n    |\n LL |     5..get_number();\n-   |     ^^^^^^^^^^^^^^^^ help: replace it with: `5;get_number();`\n+   |     ^^^^^^^^^^^^^^^^ help: statement can be reduced to: `5;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:64:5\n    |\n LL |     [42, get_number()];\n-   |     ^^^^^^^^^^^^^^^^^^^ help: replace it with: `42;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `42;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:65:5\n    |\n LL |     [42, 55][get_usize()];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `[42, 55];get_usize();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: statement can be written as: `assert!([42, 55].len() > get_usize());`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:66:5\n    |\n LL |     (42, get_number()).1;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `42;get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `42;get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:67:5\n    |\n LL |     [get_number(); 55];\n-   |     ^^^^^^^^^^^^^^^^^^^ help: replace it with: `get_number();`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:68:5\n    |\n LL |     [42; 55][get_usize()];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `[42; 55];get_usize();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: statement can be written as: `assert!([42; 55].len() > get_usize());`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:69:5\n    |\n LL | /     {\n LL | |         get_number()\n LL | |     };\n-   | |______^ help: replace it with: `get_number();`\n+   | |______^ help: statement can be reduced to: `get_number();`\n \n-error: statement can be reduced\n+error: unnecessary operation\n   --> $DIR/unnecessary_operation.rs:72:5\n    |\n LL | /     FooString {\n LL | |         s: String::from(\"blah\"),\n LL | |     };\n-   | |______^ help: replace it with: `String::from(\"blah\");`\n+   | |______^ help: statement can be reduced to: `String::from(\"blah\");`\n \n error: aborting due to 20 previous errors\n "}]}