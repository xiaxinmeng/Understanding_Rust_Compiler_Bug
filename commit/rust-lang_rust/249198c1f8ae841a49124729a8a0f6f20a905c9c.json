{"sha": "249198c1f8ae841a49124729a8a0f6f20a905c9c", "node_id": "C_kwDOAAsO6NoAKDI0OTE5OGMxZjhhZTg0MWE0OTEyNDcyOWE4YTBmNmYyMGE5MDVjOWM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-30T19:42:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-30T19:42:21Z"}, "message": "Rollup merge of #109758 - nnethercote:parallel-cleanups, r=cjgillot\n\nParallel compiler cleanups\n\nA few small improvements I found while looking closely at this code.\n\nr? `@cjgillot`\n\ncc `@Zoxc,` `@SparrowLii`", "tree": {"sha": "2ac471632bcb935aa8b918cd7c41984fd01dbc25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ac471632bcb935aa8b918cd7c41984fd01dbc25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/249198c1f8ae841a49124729a8a0f6f20a905c9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkJeYdCRBK7hj4Ov3rIwAAqWwIAK4fdmF4Hu/bueK+KpfHO68K\nf4/f+dhyFpID8FTwuX6clLDuDW/brU3SqJxLIyUVjcc+WpFbUYFCqR2gVrciEW97\nuAf8C6QtJNZA1Fs40F5NUdpzS6188VjNF/38EdscNYRoeAOoxpkgVnkFhBV47IKt\neozLGbXaWUVYvsLkMuYOaCYZn3xXz8GlPsVUZC8cet+ZfLYIiB9/+NcAPsMxIvwf\ng7cy4zcA28T/Bx3BLouxyUJoz2a8z8Fls9TEGqXSr70aE2T0Bz4OFcEETWtBqSqq\nPjCg8rkWk1yRWSvhYpwOQeiVsMbkTiO0MnbHCjSQSPhMvC5drtFYbjhhZxejLXU=\n=Umco\n-----END PGP SIGNATURE-----\n", "payload": "tree 2ac471632bcb935aa8b918cd7c41984fd01dbc25\nparent 7cd96ae2d7b596a95f53e3edabed589b899e5407\nparent 08dec8969fe526c4419d066dc01344031a0ddc1f\nauthor Michael Goulet <michael@errs.io> 1680205341 -0700\ncommitter GitHub <noreply@github.com> 1680205341 -0700\n\nRollup merge of #109758 - nnethercote:parallel-cleanups, r=cjgillot\n\nParallel compiler cleanups\n\nA few small improvements I found while looking closely at this code.\n\nr? `@cjgillot`\n\ncc `@Zoxc,` `@SparrowLii`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/249198c1f8ae841a49124729a8a0f6f20a905c9c", "html_url": "https://github.com/rust-lang/rust/commit/249198c1f8ae841a49124729a8a0f6f20a905c9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/249198c1f8ae841a49124729a8a0f6f20a905c9c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd96ae2d7b596a95f53e3edabed589b899e5407", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd96ae2d7b596a95f53e3edabed589b899e5407", "html_url": "https://github.com/rust-lang/rust/commit/7cd96ae2d7b596a95f53e3edabed589b899e5407"}, {"sha": "08dec8969fe526c4419d066dc01344031a0ddc1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/08dec8969fe526c4419d066dc01344031a0ddc1f", "html_url": "https://github.com/rust-lang/rust/commit/08dec8969fe526c4419d066dc01344031a0ddc1f"}], "stats": {"total": 81, "additions": 45, "deletions": 36}, "files": [{"sha": "f88c055a9b56972558c25a6799cd58069fbd910c", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=249198c1f8ae841a49124729a8a0f6f20a905c9c", "patch": "@@ -5,7 +5,7 @@ use std::collections::hash_map::RawEntryMut;\n use std::hash::{Hash, Hasher};\n use std::mem;\n \n-#[derive(Clone, Default)]\n+#[derive(Default)]\n #[cfg_attr(parallel_compiler, repr(align(64)))]\n struct CacheAligned<T>(T);\n \n@@ -21,7 +21,6 @@ const SHARD_BITS: usize = 0;\n pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n-#[derive(Clone)]\n pub struct Sharded<T> {\n     shards: [CacheAligned<Lock<T>>; SHARDS],\n }"}, {"sha": "4e2126fff7be9e730b073ddd4e95a50ab21252e6", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=249198c1f8ae841a49124729a8a0f6f20a905c9c", "patch": "@@ -1,21 +1,46 @@\n-//! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n+//! This module defines various operations and types that are implemented in\n+//! one way for the serial compiler, and another way the parallel compiler.\n //!\n-//! `Lrc` is an alias of `Arc` if cfg!(parallel_compiler) is true, `Rc` otherwise.\n+//! Operations\n+//! ----------\n+//! The parallel versions of operations use Rayon to execute code in parallel,\n+//! while the serial versions degenerate straightforwardly to serial execution.\n+//! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `Lock` is a mutex.\n-//! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n+//! serial version and `Erased + Send + Sync` for the parallel version.\n //!\n-//! `RwLock` is a read-write lock.\n-//! It internally uses `parking_lot::RwLock` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! Types\n+//! -----\n+//! The parallel versions of types provide various kinds of synchronization,\n+//! while the serial compiler versions do not.\n //!\n-//! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n+//! The following table shows how the types are implemented internally. Except\n+//! where noted otherwise, the type in column one is defined as a\n+//! newtype around the type from column two or three.\n //!\n-//! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n+//! | Type                    | Serial version      | Parallel version                |\n+//! | ----------------------- | ------------------- | ------------------------------- |\n+//! | `Lrc<T>`                | `rc::Rc<T>`         | `sync::Arc<T>`                  |\n+//! |` Weak<T>`               | `rc::Weak<T>`       | `sync::Weak<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `AtomicBool`            | `Cell<bool>`        | `atomic::AtomicBool`            |\n+//! | `AtomicU32`             | `Cell<u32>`         | `atomic::AtomicU32`             |\n+//! | `AtomicU64`             | `Cell<u64>`         | `atomic::AtomicU64`             |\n+//! | `AtomicUsize`           | `Cell<usize>`       | `atomic::AtomicUsize`           |\n+//! |                         |                     |                                 |\n+//! | `Lock<T>`               | `RefCell<T>`        | `parking_lot::Mutex<T>`         |\n+//! | `RwLock<T>`             | `RefCell<T>`        | `parking_lot::RwLock<T>`        |\n+//! | `MTLock<T>`        [^1] | `T`                 | `Lock<T>`                       |\n+//! | `MTLockRef<'a, T>` [^2] | `&'a mut MTLock<T>` | `&'a MTLock<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `ParallelIterator`      | `Iterator`          | `rayon::iter::ParallelIterator` |\n //!\n-//! `rustc_erase_owner!` erases an OwningRef owner into Erased or Erased + Send + Sync\n-//! depending on the value of cfg!(parallel_compiler).\n+//! [^1] `MTLock` is similar to `Lock`, but the serial version avoids the cost\n+//! of a `RefCell`. This is appropriate when interior mutability is not\n+//! required.\n+//!\n+//! [^2] `MTLockRef` is a typedef.\n \n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n@@ -209,7 +234,7 @@ cfg_if! {\n             }\n         }\n \n-        pub type MTRef<'a, T> = &'a mut T;\n+        pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(T);\n@@ -267,7 +292,7 @@ cfg_if! {\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n-        pub type MTRef<'a, T> = &'a T;\n+        pub type MTLockRef<'a, T> = &'a MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(Lock<T>);\n@@ -553,18 +578,6 @@ impl<T> RwLock<T> {\n         self.write()\n     }\n \n-    #[cfg(not(parallel_compiler))]\n-    #[inline(always)]\n-    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n-        ReadGuard::clone(rg)\n-    }\n-\n-    #[cfg(parallel_compiler)]\n-    #[inline(always)]\n-    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n-        ReadGuard::rwlock(&rg).read()\n-    }\n-\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn leak(&self) -> &T {"}, {"sha": "7ca18fca18c147815037bef92d16c02f4f2676d0", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=249198c1f8ae841a49124729a8a0f6f20a905c9c", "patch": "@@ -174,7 +174,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::{par_for_each_in, MTLock, MTRef};\n+use rustc_data_structures::sync::{par_for_each_in, MTLock, MTLockRef};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n@@ -341,8 +341,8 @@ pub fn collect_crate_mono_items(\n     let recursion_limit = tcx.recursion_limit();\n \n     {\n-        let visited: MTRef<'_, _> = &mut visited;\n-        let inlining_map: MTRef<'_, _> = &mut inlining_map;\n+        let visited: MTLockRef<'_, _> = &mut visited;\n+        let inlining_map: MTLockRef<'_, _> = &mut inlining_map;\n \n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_for_each_in(roots, |root| {\n@@ -407,10 +407,10 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n-    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n+    visited: MTLockRef<'_, FxHashSet<MonoItem<'tcx>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     recursion_limit: Limit,\n-    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+    inlining_map: MTLockRef<'_, InliningMap<'tcx>>,\n ) {\n     if !visited.lock_mut().insert(starting_point.node) {\n         // We've been here already, no need to search again."}, {"sha": "d3efc22a194515a0a67d6e94fe3709216d1072e9", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249198c1f8ae841a49124729a8a0f6f20a905c9c/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=249198c1f8ae841a49124729a8a0f6f20a905c9c", "patch": "@@ -21,9 +21,6 @@ pub trait QueryCache: Sized {\n     type Value: Copy + Debug;\n \n     /// Checks if the query is already computed and in the cache.\n-    /// It returns the shard index and a lock guard to the shard,\n-    /// which will be used if the query is not in the cache and we need\n-    /// to compute it.\n     fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n \n     fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex);"}]}