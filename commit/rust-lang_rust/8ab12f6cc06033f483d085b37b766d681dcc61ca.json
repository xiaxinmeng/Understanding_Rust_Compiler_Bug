{"sha": "8ab12f6cc06033f483d085b37b766d681dcc61ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYjEyZjZjYzA2MDMzZjQ4M2QwODViMzdiNzY2ZDY4MWRjYzYxY2E=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-23T20:39:15Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-23T20:39:15Z"}, "message": "Optimize snapshot usage.\n\nThis commit implements a suggestion from @estebank that optimizes the\nuse of snapshots.\n\nInstead of creating a snapshot for each recursion in `parse_path_segment`\nand then replacing `self` with them until the first invocation where if\nleading angle brackets are detected, `self` is not replaced and instead the\nsnapshot is used to inform how parsing should continue.\n\nNow, a snapshot is created in the first invocation that acts as a backup\nof the parser state before any generic arguments are parsed (and\ntherefore, before recursion starts). This backup replaces `self` if after\nall parsing of generic arguments has concluded we can determine that\nthere are leading angle brackets. Parsing can then proceed from the\nbackup state making use of the now known number of unmatched leading\nangle brackets to recover.", "tree": {"sha": "cc6c44cd4045b90a09ef94cfb3b9f8faa0b9c6c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc6c44cd4045b90a09ef94cfb3b9f8faa0b9c6c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ab12f6cc06033f483d085b37b766d681dcc61ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlxI0xIACgkQAXYLT59T\n8VQipQ//dNMe33dB+SnjYcufCOzNKo8HligiZONTEA0zhbZ0QIvYCEYKwN2tS/Y+\nkt27+s+ntm1hVmwf1KC2OPf/ZNxAMYzUBcgkP/MV6SJ++6+vhskMHXtuConoLZTQ\na8dOMrPKlPNEYHc2c+2nZnJDITk9YyHSEWU2s15oQkERTNaHzyOLjOUaV7A472bR\nvaFS/8vRTsvErrR2IixDtKAOsrWlFDHG7hcmCB9IqwfzZBNTLhzZbcg/GavNuML7\nCi91/EczUiq4OynFfA9TNXx4KukJLZ7xgRlh4oSLJM8KDIYF+OzWFWMPTkExS8E2\n98yzsYnbVyadAhugOOf2AImq3xwgkgrmyEyZENv3hgwJ+m/O1wLQj1/WXsj0u8ZD\n5GExQxk8Uhh/JdELwBfzFM499JhSbKIYlUXDC04UBI2YiuKAuPeIw3jnbrIq5SCz\na3BII6IF69QgQsl5U9YMEvcXBRtbqSBDH6BzprVgGeQ4OdRJVkDaUtBmf+dmPdaE\nqjJKiGVmvgsoHNTAuohOGWrWESz0/TPPzen5/DyUzAL0IfgQl6B+fo/4lJDKIOah\nIhnVUk/dFiSPOwd89WmEUhbbX1Yp/qhorje5UVbfcG4Fd6TqV7nezh5sky89cOl0\nGSceeCJs/a3OURDzH55wsLTy/Hiv2cC7vfwXGLkm1LfK8Rzo7WU=\n=a4UC\n-----END PGP SIGNATURE-----", "payload": "tree cc6c44cd4045b90a09ef94cfb3b9f8faa0b9c6c4\nparent 22f794b00fa8d84c9e827f8c8af762ee60074a8a\nauthor David Wood <david@davidtw.co> 1548275955 +0100\ncommitter David Wood <david@davidtw.co> 1548275955 +0100\n\nOptimize snapshot usage.\n\nThis commit implements a suggestion from @estebank that optimizes the\nuse of snapshots.\n\nInstead of creating a snapshot for each recursion in `parse_path_segment`\nand then replacing `self` with them until the first invocation where if\nleading angle brackets are detected, `self` is not replaced and instead the\nsnapshot is used to inform how parsing should continue.\n\nNow, a snapshot is created in the first invocation that acts as a backup\nof the parser state before any generic arguments are parsed (and\ntherefore, before recursion starts). This backup replaces `self` if after\nall parsing of generic arguments has concluded we can determine that\nthere are leading angle brackets. Parsing can then proceed from the\nbackup state making use of the now known number of unmatched leading\nangle brackets to recover.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab12f6cc06033f483d085b37b766d681dcc61ca", "html_url": "https://github.com/rust-lang/rust/commit/8ab12f6cc06033f483d085b37b766d681dcc61ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ab12f6cc06033f483d085b37b766d681dcc61ca/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f794b00fa8d84c9e827f8c8af762ee60074a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f794b00fa8d84c9e827f8c8af762ee60074a8a", "html_url": "https://github.com/rust-lang/rust/commit/22f794b00fa8d84c9e827f8c8af762ee60074a8a"}], "stats": {"total": 125, "additions": 57, "deletions": 68}, "files": [{"sha": "d03a346c3d55bf9b33c2c0a3b85e67b0a256599e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 57, "deletions": 68, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/8ab12f6cc06033f483d085b37b766d681dcc61ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab12f6cc06033f483d085b37b766d681dcc61ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8ab12f6cc06033f483d085b37b766d681dcc61ca", "patch": "@@ -5428,87 +5428,76 @@ impl<'a> Parser<'a> {\n         //\n         // In doing this, we have managed to work out how many unmatched leading left angle\n         // brackets there are, but we cannot recover as the unmatched angle brackets have\n-        // already been consumed. To remedy this, whenever `parse_generic_args` is invoked, we\n-        // make a snapshot of the current parser state and invoke it on that and inspect\n-        // the result:\n-        //\n-        // - If success (ie. when it found a matching `>` character) then the snapshot state\n-        //   is kept (this is required to propagate the count upwards).\n-        //\n-        // - If error and in was in a recursive call, then the snapshot state is kept (this is\n-        //   required to propagate the count upwards).\n-        //\n-        // - If error and this was the first invocation (before any recursion had taken place)\n-        //   then we choose not to keep the snapshot state - that way we haven't actually\n-        //   consumed any of the `<` characters, but can still inspect the count from the\n-        //   snapshot to know how many `<` characters to remove. Using this information, we can\n-        //   emit an error and consume the extra `<` characters before attempting to parse\n-        //   the generic arguments again (this time hopefullt successfully as the unmatched `<`\n-        //   characters are gone).\n+        // already been consumed. To remedy this, we keep a snapshot of the parser state\n+        // before we do the above. We can then inspect whether we ended up with a parsing error\n+        // and unmatched left angle brackets and if so, restore the parser state before we\n+        // consumed any `<` characters to emit an error and consume the erroneous tokens to\n+        // recover by attempting to parse again.\n         //\n         // In practice, the recursion of this function is indirect and there will be other\n         // locations that consume some `<` characters - as long as we update the count when\n         // this happens, it isn't an issue.\n-        let mut snapshot = self.clone();\n+\n+        let is_first_invocation = style == PathStyle::Expr;\n+        // Take a snapshot before attempting to parse - we can restore this later.\n+        let snapshot = if is_first_invocation {\n+            Some(self.clone())\n+        } else {\n+            None\n+        };\n+\n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n-        match snapshot.parse_generic_args() {\n-            Ok(value) => {\n-                debug!(\n-                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot success) \\\n-                     snapshot.count={:?}\",\n-                    snapshot.unmatched_angle_bracket_count,\n-                );\n-                mem::replace(self, snapshot);\n-                Ok(value)\n-            },\n-            Err(mut e) => {\n+        match self.parse_generic_args() {\n+            Ok(value) => Ok(value),\n+            Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n+                // Cancel error from being unable to find `>`. We know the error\n+                // must have been this due to a non-zero unmatched angle bracket\n+                // count.\n+                e.cancel();\n+\n+                // Swap `self` with our backup of the parser state before attempting to parse\n+                // generic arguments.\n+                let snapshot = mem::replace(self, snapshot.unwrap());\n+\n                 debug!(\n                     \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n                      snapshot.count={:?}\",\n                     snapshot.unmatched_angle_bracket_count,\n                 );\n-                if style == PathStyle::Expr && snapshot.unmatched_angle_bracket_count > 0 {\n-                    // Cancel error from being unable to find `>`. We know the error\n-                    // must have been this due to a non-zero unmatched angle bracket\n-                    // count.\n-                    e.cancel();\n-\n-                    // Eat the unmatched angle brackets.\n-                    for _ in 0..snapshot.unmatched_angle_bracket_count {\n-                        self.eat_lt();\n-                    }\n \n-                    // Make a span over ${unmatched angle bracket count} characters.\n-                    let span = lo.with_hi(\n-                        lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n-                    );\n-                    let plural = snapshot.unmatched_angle_bracket_count > 1;\n-                    self.diagnostic()\n-                        .struct_span_err(\n-                            span,\n-                            &format!(\n-                                \"unmatched angle bracket{}\",\n-                                if plural { \"s\" } else { \"\" }\n-                            ),\n-                        )\n-                        .span_suggestion_with_applicability(\n-                            span,\n-                            &format!(\n-                                \"remove extra angle bracket{}\",\n-                                if plural { \"s\" } else { \"\" }\n-                            ),\n-                            String::new(),\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n-\n-                    // Try again without unmatched angle bracket characters.\n-                    self.parse_generic_args()\n-                } else {\n-                    mem::replace(self, snapshot);\n-                    Err(e)\n+                // Eat the unmatched angle brackets.\n+                for _ in 0..snapshot.unmatched_angle_bracket_count {\n+                    self.eat_lt();\n                 }\n+\n+                // Make a span over ${unmatched angle bracket count} characters.\n+                let span = lo.with_hi(\n+                    lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n+                );\n+                let plural = snapshot.unmatched_angle_bracket_count > 1;\n+                self.diagnostic()\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"unmatched angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                    )\n+                    .span_suggestion_with_applicability(\n+                        span,\n+                        &format!(\n+                            \"remove extra angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+\n+                // Try again without unmatched angle bracket characters.\n+                self.parse_generic_args()\n             },\n+            Err(e) => Err(e),\n         }\n     }\n "}]}