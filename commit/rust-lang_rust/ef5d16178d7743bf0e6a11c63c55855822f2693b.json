{"sha": "ef5d16178d7743bf0e6a11c63c55855822f2693b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNWQxNjE3OGQ3NzQzYmYwZTZhMTFjNjNjNTU4NTU4MjJmMjY5M2I=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-11T10:42:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-11T10:42:06Z"}, "message": "Merge pull request #144 from bjorn3/wip_linker\n\nLinker", "tree": {"sha": "d8a6af5a486e7e3cb863db7c209d3212824121c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a6af5a486e7e3cb863db7c209d3212824121c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef5d16178d7743bf0e6a11c63c55855822f2693b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb6Ad+CRBK7hj4Ov3rIwAAdHIIAA4RZP3z2T+hZzoB3GmAkNwh\ndmQGbCVGFGN8L2VwTGDQIrfWJVZrum321RzqIWh4efl+lr6AA6fYSMAdjo23tzwZ\nVBQV51xzWQqo9HNqtTPNhh4AkcXs1o0/kzApM3R+16ftwygrpxX5BF2kn4gA6PR8\ntHnpDQTq5nTdAozS3EUnOVgxxON5ZKzwwadQ8B+O6tkL0D6JUTJmjW/loz6UrYy3\n6CQjDBaFklnKJG5GnmOXB+2U9zOivNN7hJYf/2YFQO2k1eH7vqKb5RV042GwsK3X\nYY+ekeFz8zlB6V6oXdEHBZNV0E5ZYpEkAvCsrhteTZyEas9LSsmXlJhI42c880M=\n=H+1D\n-----END PGP SIGNATURE-----\n", "payload": "tree d8a6af5a486e7e3cb863db7c209d3212824121c4\nparent 104e9ffe89913a4c5f4fe937296626f329af1893\nparent 29e1d617d41f53c22989ec4b54624b582bf37057\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1541932926 +0100\ncommitter GitHub <noreply@github.com> 1541932926 +0100\n\nMerge pull request #144 from bjorn3/wip_linker\n\nLinker"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5d16178d7743bf0e6a11c63c55855822f2693b", "html_url": "https://github.com/rust-lang/rust/commit/ef5d16178d7743bf0e6a11c63c55855822f2693b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef5d16178d7743bf0e6a11c63c55855822f2693b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "104e9ffe89913a4c5f4fe937296626f329af1893", "url": "https://api.github.com/repos/rust-lang/rust/commits/104e9ffe89913a4c5f4fe937296626f329af1893", "html_url": "https://github.com/rust-lang/rust/commit/104e9ffe89913a4c5f4fe937296626f329af1893"}, {"sha": "29e1d617d41f53c22989ec4b54624b582bf37057", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e1d617d41f53c22989ec4b54624b582bf37057", "html_url": "https://github.com/rust-lang/rust/commit/29e1d617d41f53c22989ec4b54624b582bf37057"}], "stats": {"total": 1532, "additions": 1499, "deletions": 33}, "files": [{"sha": "bb14d457f37cf698c99af2e80674a0f3544f1f9e", "filename": "Cargo.lock", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -87,6 +87,14 @@ dependencies = [\n  \"vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"cloudabi\"\n+version = \"0.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cranelift\"\n version = \"0.23.0\"\n@@ -258,6 +266,20 @@ dependencies = [\n  \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"fuchsia-zircon\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"fuchsia-zircon-sys\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"gcc\"\n version = \"0.3.55\"\n@@ -361,6 +383,31 @@ dependencies = [\n  \"proc-macro2 0.4.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"raw-cpuid\"\n version = \"6.0.0\"\n@@ -415,6 +462,14 @@ dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"remove_dir_all\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-demangle\"\n version = \"0.1.9\"\n@@ -427,12 +482,15 @@ dependencies = [\n  \"ar 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cranelift 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-faerie 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-module 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"cranelift-simplejit 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\",\n  \"faerie 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"target-lexicon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempfile 3.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -559,6 +617,19 @@ dependencies = [\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"tempfile\"\n+version = \"3.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.0.4\"\n@@ -676,6 +747,7 @@ dependencies = [\n \"checksum cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f159dfd43363c4d08055a07703eb7a3406b0dac4d0584d96965a3262db3c9d16\"\n \"checksum cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"082bb9b28e00d3c9d39cc03e64ce4cea0f1bb9b3fde493f0cbc008472d22bdf4\"\n \"checksum clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e\"\n+\"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n \"checksum cranelift 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n \"checksum cranelift-bforest 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n \"checksum cranelift-codegen 0.23.0 (git+https://github.com/CraneStation/cranelift.git)\" = \"<none>\"\n@@ -692,6 +764,8 @@ dependencies = [\n \"checksum faerie 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7f869e12bcad2b4ff6ac60e01c2354957312fbf0c10dc938f340d58932b3db52\"\n \"checksum failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6dd377bcc1b1b7ce911967e3ec24fa19c3224394ec05b54aa7b083d498341ac7\"\n \"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596\"\n+\"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n+\"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \"checksum gcc 0.3.55 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2\"\n \"checksum goblin 0.0.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c65cd533b33e3d04c6e393225fa8919ddfcf5862ca8919c7f9a167c312ef41c2\"\n \"checksum heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea04fa3ead4e05e51a7c806fc07271fdbde4e246a6c6d1efd52e72230b771b82\"\n@@ -707,12 +781,16 @@ dependencies = [\n \"checksum proc-macro2 0.4.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab2fc21ba78ac73e4ff6b3818ece00be4e175ffbef4d0a717d978b48b24150c4\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53fa22a1994bd0f9372d7a816207d8a2677ad0325b073f5c5332760f0fb62b5c\"\n+\"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c\"\n+\"checksum rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1961a422c4d189dfb50ffa9320bf1f2a9bd54ecb92792fb9477f99a1045f3372\"\n+\"checksum rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0905b6b7079ec73b314d4c748701f6931eb79fd97c668caa3f1899b22b32c6db\"\n \"checksum raw-cpuid 6.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41219962ecab392f1e68db9e7ebd972800d4045a128cc23462b384e8c312cde1\"\n \"checksum redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c214e91d3ecf43e9a4e41e578973adeb14b474f2bee858742d127af75a0112b1\"\n \"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76\"\n \"checksum regex 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee84f70c8c08744ea9641a731c7fadb475bf2ecc52d7f627feb833e0b3990467\"\n \"checksum regex-syntax 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fbc557aac2b708fe84121caf261346cc2eed71978024337e42eb46b8a252ac6e\"\n \"checksum region 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cff177f64744f6f2a2054d231279383e59b0857b4d58dc2e8881e60b58aec8e5\"\n+\"checksum remove_dir_all 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3488ba1b9a2084d38645c4c08276a1752dcbf2c7130d74f1569681ad5d2799c5\"\n \"checksum rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcfe5b13211b4d78e5c2cadfebd7769197d95c639c35a50057eb4c05de811395\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7153dd96dade874ab973e098cb62fcdbb89a03682e46b144fd09550998d4a4a7\"\n@@ -729,6 +807,7 @@ dependencies = [\n \"checksum syn 0.15.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90c39a061e2f412a9f869540471ab679e85e50c6b05604daf28bc3060f75c430\"\n \"checksum synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73687139bf99285483c96ac0add482c3776528beac1d97d444f6e91f203a2015\"\n \"checksum target-lexicon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4af5e2227f0b887d591d3724b796a96eff04226104d872f5b3883fcd427d64b9\"\n+\"checksum tempfile 3.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55c1195ef8513f3273d55ff59fe5da6940287a0d7a98331254397f464833675b\"\n \"checksum termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4096add70612622289f2fdcdbd5086dc81c1e2675e6ae58d6c4f62a16c6d7f2f\"\n \"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n \"checksum textwrap 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6\""}, {"sha": "cc71244fc4d2ff9269f94e60ceaef48e849bbe01", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -25,6 +25,9 @@ faerie = \"0.6.0\"\n ar = \"0.6.0\"\n bitflags = \"1.0.3\"\n byteorder = \"1.2.6\"\n+cc = \"1.0.25\"\n+libc = \"0.2.43\"\n+tempfile = \"3.0.4\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/CraneStation/cranelift.git\"]"}, {"sha": "4917dff7ce6e1e32b5aee66cde79728f0c29999f", "filename": "build.sh", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -14,11 +14,7 @@ fi\n \n build_example_bin() {\n     $RUSTC $2 --crate-name $1 --crate-type bin\n-\n-    pushd target/out\n-    gcc $1 libmini_core.rlib -o $1_bin\n-    sh -c ./$1_bin || true\n-    popd\n+    sh -c ./target/out/$1 || true\n }\n \n if [[ \"$1\" == \"--release\" ]]; then\n@@ -54,23 +50,27 @@ rm -r target || true\n time xargo build\n popd\n \n-$RUSTC --sysroot ~/.xargo/HOST example/alloc_example.rs --crate-type bin\n # TODO linux linker doesn't accept duplicate definitions\n-#gcc -Wl,--gc-sections target/out/alloc_example ~/.xargo/HOST/lib/rustlib/*/lib/libcore-*.rlib ~/.xargo/HOST/lib/rustlib/*/lib/liballoc-*.rlib ~/.xargo/HOST/lib/rustlib/*/lib/liballoc_system-*.rlib -o target/out/alloc_example_exe\n-#hyperfine ./target/out/alloc_example_exe\n+#$RUSTC --sysroot ~/.xargo/HOST example/alloc_example.rs --crate-type bin\n+#./target/out/alloc_example\n \n $RUSTC --sysroot ~/.xargo/HOST example/mod_bench.rs --crate-type bin\n-gcc -Wl,--gc-sections target/out/mod_bench -lc -o target/out/mod_bench_exe\n+\n+echo \"[BUILD] RUSTFLAGS=-Zmir-opt-level=3\"\n+pushd xargo\n+rm -r ~/.xargo/HOST || true\n+rm -r target || true\n+time RUSTFLAGS=\"-Zmir-opt-level=3 $RUSTFLAGS\" xargo build\n+popd\n \n $RUSTC --sysroot ~/.xargo/HOST example/mod_bench.rs --crate-type bin -Zmir-opt-level=3 --crate-name mod_bench_inline\n-gcc -Wl,--gc-sections target/out/mod_bench_inline -lc -o target/out/mod_bench_inline_exe\n \n rustc example/mod_bench.rs --crate-type bin -Copt-level=0 -o target/out/mod_bench_llvm_0 -Cpanic=abort\n rustc example/mod_bench.rs --crate-type bin -Copt-level=1 -o target/out/mod_bench_llvm_1 -Cpanic=abort\n rustc example/mod_bench.rs --crate-type bin -Copt-level=2 -o target/out/mod_bench_llvm_2 -Cpanic=abort\n rustc example/mod_bench.rs --crate-type bin -Copt-level=3 -o target/out/mod_bench_llvm_3 -Cpanic=abort\n echo\n echo \"[Bench] mod_bench\"\n-hyperfine ./target/out/mod_bench{,_inline}_exe ./target/out/mod_bench_llvm_*\n+hyperfine ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n cat target/out/log.txt | sort | uniq -c"}, {"sha": "1e57ff0f2c41cd401fd37f43d0a588603bfd8a03", "filename": "src/archive.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -0,0 +1,99 @@\n+use std::collections::HashMap;\n+use std::fs::File;\n+use std::path::PathBuf;\n+\n+use crate::prelude::*;\n+\n+pub struct ArchiveConfig<'a> {\n+    pub sess: &'a Session,\n+    pub dst: PathBuf,\n+    pub src: Option<PathBuf>,\n+    pub lib_search_paths: Vec<PathBuf>,\n+}\n+\n+pub struct ArchiveBuilder<'a> {\n+    cfg: ArchiveConfig<'a>,\n+    src_archive: Option<ar::Archive<File>>,\n+    src_entries: HashMap<String, usize>,\n+    builder: ar::Builder<File>,\n+    update_symbols: bool,\n+}\n+\n+impl<'a> ArchiveBuilder<'a> {\n+    pub fn new(cfg: ArchiveConfig<'a>) -> Self {\n+        let (src_archive, src_entries) = if let Some(src) = &cfg.src {\n+            let mut archive = ar::Archive::new(File::open(src).unwrap());\n+            let mut entries = HashMap::new();\n+\n+            let mut i = 0;\n+            while let Some(entry) = archive.next_entry() {\n+                let entry = entry.unwrap();\n+                entries.insert(\n+                    String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n+                    i,\n+                );\n+                i += 1;\n+            }\n+\n+            (Some(archive), entries)\n+        } else {\n+            (None, HashMap::new())\n+        };\n+\n+        let builder = ar::Builder::new(File::create(&cfg.dst).unwrap());\n+\n+        ArchiveBuilder {\n+            cfg,\n+            src_archive,\n+            src_entries,\n+            builder,\n+            update_symbols: false,\n+        }\n+    }\n+\n+    pub fn src_files(&self) -> Vec<String> {\n+        self.src_entries.keys().cloned().collect()\n+    }\n+\n+    pub fn remove_file(&mut self, name: &str) {\n+        assert!(\n+            self.src_entries.remove(name).is_some(),\n+            \"Tried to remove file not existing in src archive\",\n+        );\n+    }\n+\n+    pub fn update_symbols(&mut self) {\n+        self.update_symbols = true;\n+    }\n+\n+    pub fn build(mut self) {\n+        // Add files from original archive\n+        if let Some(mut src_archive) = self.src_archive {\n+            for (_entry_name, entry_idx) in self.src_entries.into_iter() {\n+                let entry = src_archive.jump_to_entry(entry_idx).unwrap();\n+                let orig_header = entry.header();\n+                let mut header =\n+                    ar::Header::new(orig_header.identifier().to_vec(), orig_header.size());\n+                header.set_mtime(orig_header.mtime());\n+                header.set_uid(orig_header.uid());\n+                header.set_gid(orig_header.gid());\n+                header.set_mode(orig_header.mode());\n+                self.builder.append(&header, entry).unwrap();\n+            }\n+        }\n+\n+        // Finalize archive\n+        std::mem::drop(self.builder);\n+\n+        // Run ranlib to be able to link the archive\n+        let status = std::process::Command::new(\"ranlib\")\n+            .arg(self.cfg.dst)\n+            .status()\n+            .expect(\"Couldn't run ranlib\");\n+        assert!(\n+            status.success(),\n+            \"Ranlib exited with code {:?}\",\n+            status.code()\n+        );\n+    }\n+}"}, {"sha": "f5415584eff0b26c7c852d8946ce7d155e3a6555", "filename": "src/lib.rs", "status": "modified", "additions": 160, "deletions": 6, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -17,6 +17,9 @@ extern crate rustc_mir;\n extern crate rustc_target;\n #[macro_use]\n extern crate rustc_data_structures;\n+extern crate rustc_fs_util;\n+#[macro_use]\n+extern crate log;\n \n extern crate ar;\n #[macro_use]\n@@ -37,11 +40,19 @@ use std::sync::mpsc;\n use syntax::symbol::Symbol;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::cstore::MetadataLoader;\n-use rustc::session::{config::OutputFilenames, CompileIncomplete};\n+use rustc::middle::cstore::{\n+    self, CrateSource, LibSource, LinkagePreference, MetadataLoader, NativeLibrary,\n+};\n+use rustc::middle::lang_items::LangItem;\n+use rustc::middle::weak_lang_items;\n+use rustc::session::{\n+    config::{self, OutputFilenames, OutputType},\n+    CompileIncomplete,\n+};\n use rustc::ty::query::Providers;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::out_filename;\n+use rustc_codegen_utils::linker::LinkerInfo;\n \n use cranelift::codegen::settings;\n use cranelift_faerie::*;\n@@ -60,11 +71,13 @@ macro_rules! unimpl {\n mod abi;\n mod allocator;\n mod analyze;\n+mod archive;\n mod base;\n mod common;\n mod constant;\n mod intrinsics;\n mod link;\n+mod link_copied;\n mod main_shim;\n mod metadata;\n mod pretty_clif;\n@@ -88,7 +101,7 @@ mod prelude {\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n         TypeAndMut, TypeFoldable,\n     };\n-    pub use rustc_codegen_utils::CompiledModule;\n+    pub use rustc_codegen_utils::{CompiledModule, ModuleKind};\n     pub use rustc_data_structures::{\n         fx::{FxHashMap, FxHashSet},\n         indexed_vec::Idx,\n@@ -108,7 +121,7 @@ mod prelude {\n     pub use crate::abi::*;\n     pub use crate::base::{trans_operand, trans_place};\n     pub use crate::common::*;\n-    pub use crate::{Caches, CodegenResults};\n+    pub use crate::{Caches, CodegenResults, CrateInfo};\n }\n \n pub struct Caches<'tcx> {\n@@ -127,10 +140,132 @@ impl<'tcx> Caches<'tcx> {\n \n struct CraneliftCodegenBackend;\n \n+pub struct CrateInfo {\n+    panic_runtime: Option<CrateNum>,\n+    compiler_builtins: Option<CrateNum>,\n+    profiler_runtime: Option<CrateNum>,\n+    sanitizer_runtime: Option<CrateNum>,\n+    is_no_builtins: FxHashSet<CrateNum>,\n+    native_libraries: FxHashMap<CrateNum, Lrc<Vec<NativeLibrary>>>,\n+    crate_name: FxHashMap<CrateNum, String>,\n+    used_libraries: Lrc<Vec<NativeLibrary>>,\n+    link_args: Lrc<Vec<String>>,\n+    used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n+    used_crates_static: Vec<(CrateNum, LibSource)>,\n+    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n+    wasm_imports: FxHashMap<String, String>,\n+    lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n+    missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n+}\n+\n+impl CrateInfo {\n+    pub fn new(tcx: TyCtxt) -> CrateInfo {\n+        let mut info = CrateInfo {\n+            panic_runtime: None,\n+            compiler_builtins: None,\n+            profiler_runtime: None,\n+            sanitizer_runtime: None,\n+            is_no_builtins: Default::default(),\n+            native_libraries: Default::default(),\n+            used_libraries: tcx.native_libraries(LOCAL_CRATE),\n+            link_args: tcx.link_args(LOCAL_CRATE),\n+            crate_name: Default::default(),\n+            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n+            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n+            used_crate_source: Default::default(),\n+            wasm_imports: Default::default(),\n+            lang_item_to_crate: Default::default(),\n+            missing_lang_items: Default::default(),\n+        };\n+        let lang_items = tcx.lang_items();\n+\n+        let load_wasm_items = tcx\n+            .sess\n+            .crate_types\n+            .borrow()\n+            .iter()\n+            .any(|c| *c != config::CrateType::Rlib)\n+            && tcx.sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\";\n+\n+        if load_wasm_items {\n+            info.load_wasm_imports(tcx, LOCAL_CRATE);\n+        }\n+\n+        let crates = tcx.crates();\n+\n+        let n_crates = crates.len();\n+        info.native_libraries.reserve(n_crates);\n+        info.crate_name.reserve(n_crates);\n+        info.used_crate_source.reserve(n_crates);\n+        info.missing_lang_items.reserve(n_crates);\n+\n+        for &cnum in crates.iter() {\n+            info.native_libraries\n+                .insert(cnum, tcx.native_libraries(cnum));\n+            info.crate_name\n+                .insert(cnum, tcx.crate_name(cnum).to_string());\n+            info.used_crate_source\n+                .insert(cnum, tcx.used_crate_source(cnum));\n+            if tcx.is_panic_runtime(cnum) {\n+                info.panic_runtime = Some(cnum);\n+            }\n+            if tcx.is_compiler_builtins(cnum) {\n+                info.compiler_builtins = Some(cnum);\n+            }\n+            if tcx.is_profiler_runtime(cnum) {\n+                info.profiler_runtime = Some(cnum);\n+            }\n+            if tcx.is_sanitizer_runtime(cnum) {\n+                info.sanitizer_runtime = Some(cnum);\n+            }\n+            if tcx.is_no_builtins(cnum) {\n+                info.is_no_builtins.insert(cnum);\n+            }\n+            if load_wasm_items {\n+                info.load_wasm_imports(tcx, cnum);\n+            }\n+            let missing = tcx.missing_lang_items(cnum);\n+            for &item in missing.iter() {\n+                if let Ok(id) = lang_items.require(item) {\n+                    info.lang_item_to_crate.insert(item, id.krate);\n+                }\n+            }\n+\n+            // No need to look for lang items that are whitelisted and don't\n+            // actually need to exist.\n+            let missing = missing\n+                .iter()\n+                .cloned()\n+                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n+                .collect();\n+            info.missing_lang_items.insert(cnum, missing);\n+        }\n+\n+        return info;\n+    }\n+\n+    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n+        self.wasm_imports.extend(\n+            tcx.wasm_import_module_map(cnum)\n+                .iter()\n+                .map(|(&id, module)| {\n+                    let instance = Instance::mono(tcx, id);\n+                    let import_name = tcx.symbol_name(instance);\n+\n+                    (import_name.to_string(), module.clone())\n+                }),\n+        );\n+    }\n+}\n+\n pub struct CodegenResults {\n     artifact: faerie::Artifact,\n+    modules: Vec<CompiledModule>,\n+    allocator_module: Option<CompiledModule>,\n     metadata: Vec<u8>,\n     crate_name: Symbol,\n+    crate_info: CrateInfo,\n+    linker_info: LinkerInfo,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -261,10 +396,29 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n             tcx.sess.abort_if_errors();\n \n+            let artifact = faerie_module.finish().artifact;\n+\n+            let tmp_file = tcx\n+                .output_filenames(LOCAL_CRATE)\n+                .temp_path(OutputType::Object, None);\n+            let obj = artifact.emit().unwrap();\n+            std::fs::write(&tmp_file, obj).unwrap();\n+\n             return Box::new(CodegenResults {\n-                artifact: faerie_module.finish().artifact,\n+                artifact,\n                 metadata: metadata.raw_data,\n                 crate_name: tcx.crate_name(LOCAL_CRATE),\n+                crate_info: CrateInfo::new(tcx),\n+                linker_info: LinkerInfo::new(tcx),\n+                modules: vec![CompiledModule {\n+                    name: \"dummy\".to_string(),\n+                    kind: ModuleKind::Regular,\n+                    object: Some(tmp_file),\n+                    bytecode: None,\n+                    bytecode_compressed: None,\n+                }],\n+                //modules: vec![],\n+                allocator_module: None,\n             });\n         }\n     }\n@@ -284,7 +438,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             let output_name = out_filename(sess, crate_type, &outputs, &res.crate_name.as_str());\n             match crate_type {\n                 CrateType::Rlib => link::link_rlib(sess, &res, output_name),\n-                CrateType::Executable => link::link_bin(sess, &res, output_name),\n+                CrateType::Executable => link::link_bin(sess, &res, &output_name),\n                 _ => sess.fatal(&format!(\"Unsupported crate type: {:?}\", crate_type)),\n             }\n         }"}, {"sha": "5fccac47123809b9c9bf88273096be963e18626b", "filename": "src/link.rs", "status": "modified", "additions": 370, "deletions": 16, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink.rs?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -1,9 +1,23 @@\n+use std::env;\n use std::fs::File;\n-use std::path::PathBuf;\n+use std::io;\n+use std::path::{Path, PathBuf};\n \n+use tempfile::Builder as TempFileBuilder;\n+\n+use rustc::session::config::{self, CrateType, DebugInfo, RUST_CGU_EXT};\n+use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n+use rustc_codegen_utils::command::Command;\n+use rustc_codegen_utils::linker::*;\n+use rustc_fs_util::fix_windows_verbatim_for_gcc;\n+use rustc_target::spec::{LinkerFlavor, PanicStrategy, RelroLevel};\n+\n+use crate::prelude::*;\n+\n+use crate::link_copied::*;\n \n-pub(crate) fn link_rlib(sess: &Session, res: &crate::CodegenResults, output_name: PathBuf) {\n+pub(crate) fn link_rlib(sess: &Session, res: &CodegenResults, output_name: PathBuf) {\n     let file = File::create(&output_name).unwrap();\n     let mut builder = ar::Builder::new(file);\n \n@@ -42,21 +56,361 @@ pub(crate) fn link_rlib(sess: &Session, res: &crate::CodegenResults, output_name\n     }\n }\n \n-pub(crate) fn link_bin(sess: &Session, res: &crate::CodegenResults, output_name: PathBuf) {\n+pub(crate) fn link_bin(sess: &Session, codegen_results: &CodegenResults, out_filename: &Path) {\n+    let tmpdir = match TempFileBuilder::new().prefix(\"rustc\").tempdir() {\n+        Ok(tmpdir) => tmpdir,\n+        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n+    };\n+\n     // TODO: link executable\n-    let obj = res.artifact.emit().unwrap();\n-    std::fs::write(output_name, obj).unwrap();\n+    let obj = codegen_results.artifact.emit().unwrap();\n+    std::fs::write(tmpdir.path().join(\"out\".to_string() + RUST_CGU_EXT), obj).unwrap();\n+\n+    let (linker, flavor) = linker_and_flavor(sess);\n+    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n+\n+    let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n+    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n+        if sess.crt_static() {\n+            cmd.args(args);\n+        }\n+    }\n+    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n+\n+    for obj in &sess.target.target.options.pre_link_objects_exe {\n+        cmd.arg(root.join(obj));\n+    }\n+\n+    if sess.crt_static() {\n+        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n+            cmd.arg(root.join(obj));\n+        }\n+    }\n+\n+    if sess.target.target.options.is_like_emscripten {\n+        cmd.arg(\"-s\");\n+        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n+            \"DISABLE_EXCEPTION_CATCHING=1\"\n+        } else {\n+            \"DISABLE_EXCEPTION_CATCHING=0\"\n+        });\n+    }\n+\n+    {\n+        let target_cpu = \"x86_64-apple-darwin\"; //::llvm_util::target_cpu(sess);\n+        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n+        link_args(&mut *linker, flavor, sess, CrateType::Executable, tmpdir.path(),\n+                  out_filename, codegen_results);\n+        cmd = linker.finalize();\n+    }\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.arg(root.join(obj));\n+    }\n+    if sess.crt_static() {\n+        for obj in &sess.target.target.options.post_link_objects_crt {\n+            cmd.arg(root.join(obj));\n+        }\n+    }\n+    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    for &(ref k, ref v) in &sess.target.target.options.link_env {\n+        cmd.env(k, v);\n+    }\n+\n+    if sess.opts.debugging_opts.print_link_args {\n+        println!(\"{:?}\", &cmd);\n+    }\n+\n+    // May have not found libraries in the right formats.\n+    sess.abort_if_errors();\n+\n+    // Invoke the system linker\n+    //\n+    // Note that there's a terribly awful hack that really shouldn't be present\n+    // in any compiler. Here an environment variable is supported to\n+    // automatically retry the linker invocation if the linker looks like it\n+    // segfaulted.\n+    //\n+    // Gee that seems odd, normally segfaults are things we want to know about!\n+    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n+    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n+    // pain to land PRs when they spuriously fail due to a segfault.\n+    //\n+    // The issue #38878 has some more debugging information on it as well, but\n+    // this unfortunately looks like it's just a race condition in macOS's linker\n+    // with some thread pool working in the background. It seems that no one\n+    // currently knows a fix for this so in the meantime we're left with this...\n+    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n+    let mut prog;\n+    let mut i = 0;\n+    loop {\n+        i += 1;\n+        prog = exec_linker(sess, &mut cmd, out_filename, tmpdir.path());\n+        let output = match prog {\n+            Ok(ref output) => output,\n+            Err(_) => break,\n+        };\n+        if output.status.success() {\n+            break\n+        }\n+        let mut out = output.stderr.clone();\n+        out.extend(&output.stdout);\n+        let out = String::from_utf8_lossy(&out);\n+\n+        // Check to see if the link failed with \"unrecognized command line option:\n+        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n+        // reperform the link step without the -no-pie option. This is safe because\n+        // if the linker doesn't support -no-pie then it should not default to\n+        // linking executables as pie. Different versions of gcc seem to use\n+        // different quotes in the error message so don't check for them.\n+        if sess.target.target.options.linker_is_gnu &&\n+           flavor != LinkerFlavor::Ld &&\n+           (out.contains(\"unrecognized command line option\") ||\n+            out.contains(\"unknown argument\")) &&\n+           out.contains(\"-no-pie\") &&\n+           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n+            for arg in cmd.take_args() {\n+                if arg.to_string_lossy() != \"-no-pie\" {\n+                    cmd.arg(arg);\n+                }\n+            }\n+            continue;\n+        }\n+        if !retry_on_segfault || i > 3 {\n+            break\n+        }\n+        let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n+        let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n+        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n+            break\n+        }\n+    }\n+\n+    match prog {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                let mut output = prog.stderr.clone();\n+                output.extend_from_slice(&prog.stdout);\n+                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                         pname.display(),\n+                                         prog.status))\n+                    .note(&format!(\"{:?}\", &cmd))\n+                    .note(&String::from_utf8_lossy(&output))\n+                    .emit();\n+                sess.abort_if_errors();\n+            }\n+        },\n+        Err(e) => {\n+            let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n+\n+            let mut linker_error = {\n+                if linker_not_found {\n+                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n+                } else {\n+                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n+                }\n+            };\n+\n+            linker_error.note(&e.to_string());\n+\n+            if !linker_not_found {\n+                linker_error.note(&format!(\"{:?}\", &cmd));\n+            }\n+\n+            linker_error.emit();\n+\n+            if sess.target.target.options.is_like_msvc && linker_not_found {\n+                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n+                    but `link.exe` was not found\");\n+                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n+                    was installed with the Visual C++ option\");\n+            }\n+            sess.abort_if_errors();\n+        }\n+    }\n+\n+\n+    // On macOS, debuggers need this utility to get run to do some munging of\n+    // the symbols. Note, though, that if the object files are being preserved\n+    // for their debug information there's no need for us to run dsymutil.\n+    if sess.target.target.options.is_like_osx &&\n+        sess.opts.debuginfo != DebugInfo::None\n+    {\n+        match Command::new(\"dsymutil\").arg(out_filename).output() {\n+            Ok(..) => {}\n+            Err(e) => sess.fatal(&format!(\"failed to run dsymutil: {}\", e)),\n+        }\n+    }\n }\n \n-/*\n-res.artifact\n-    .declare_with(\n-        &metadata_name,\n-        faerie::artifact::Decl::Data {\n-            global: true,\n-            writable: false,\n+fn link_args(cmd: &mut dyn Linker,\n+             flavor: LinkerFlavor,\n+             sess: &Session,\n+             crate_type: config::CrateType,\n+             tmpdir: &Path,\n+             out_filename: &Path,\n+             codegen_results: &CodegenResults) {\n+\n+    // Linker plugins should be specified early in the list of arguments\n+    cmd.cross_lang_lto();\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+\n+    // target descriptor\n+    let t = &sess.target.target;\n+\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n+    }\n+    cmd.output_filename(out_filename);\n+\n+    // If we're building a dynamic library then some platforms need to make sure\n+    // that all symbols are exported correctly from the dynamic library.\n+    if crate_type != config::CrateType::Executable ||\n+       sess.target.target.options.is_like_emscripten {\n+        cmd.export_symbols(tmpdir, crate_type);\n+    }\n+\n+    let obj = codegen_results.allocator_module\n+        .as_ref()\n+        .and_then(|m| m.object.as_ref());\n+    if let Some(obj) = obj {\n+        cmd.add_object(obj);\n+    }\n+\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    if !sess.opts.cg.link_dead_code {\n+        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        cmd.gc_sections(keep_metadata);\n+    }\n+\n+    let used_link_args = &codegen_results.crate_info.link_args;\n+\n+    if crate_type == config::CrateType::Executable {\n+        let mut position_independent_executable = false;\n+\n+        if t.options.position_independent_executables {\n+            let empty_vec = Vec::new();\n+            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n+            let more_args = &sess.opts.cg.link_arg;\n+            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n+\n+            if !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n+                position_independent_executable = true;\n+            }\n+        }\n+\n+        if position_independent_executable {\n+            cmd.position_independent_executable();\n+        } else {\n+            // recent versions of gcc can be configured to generate position\n+            // independent executables by default. We have to pass -no-pie to\n+            // explicitly turn that off. Not applicable to ld.\n+            if sess.target.target.options.linker_is_gnu\n+                && flavor != LinkerFlavor::Ld {\n+                cmd.no_position_independent_executable();\n+            }\n+        }\n+    }\n+\n+    let relro_level = match sess.opts.debugging_opts.relro_level {\n+        Some(level) => level,\n+        None => t.options.relro_level,\n+    };\n+    match relro_level {\n+        RelroLevel::Full => {\n+            cmd.full_relro();\n+        },\n+        RelroLevel::Partial => {\n+            cmd.partial_relro();\n+        },\n+        RelroLevel::Off => {\n+            cmd.no_relro();\n         },\n-        res.metadata.clone(),\n-    )\n-    .unwrap();\n-*/\n+        RelroLevel::None => {\n+        },\n+    }\n+\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n+\n+    // Pass debuginfo flags down to the linker.\n+    cmd.debuginfo();\n+\n+    // We want to, by default, prevent the compiler from accidentally leaking in\n+    // any system libraries, so we may explicitly ask linkers to not link to any\n+    // libraries by default. Note that this does not happen for windows because\n+    // windows pulls in some large number of libraries and I couldn't quite\n+    // figure out which subset we wanted.\n+    //\n+    // This is all naturally configurable via the standard methods as well.\n+    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) &&\n+        t.options.no_default_libraries\n+    {\n+        cmd.no_default_libraries();\n+    }\n+\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    //  1. The local object that LLVM just generated\n+    //  2. Local native libraries\n+    //  3. Upstream rust libraries\n+    //  4. Upstream native libraries\n+    //\n+    // The rationale behind this ordering is that those items lower down in the\n+    // list can't depend on items higher up in the list. For example nothing can\n+    // depend on what we just generated (e.g. that'd be a circular dependency).\n+    // Upstream rust libraries are not allowed to depend on our local native\n+    // libraries as that would violate the structure of the DAG, in that\n+    // scenario they are required to link to them as well in a shared fashion.\n+    //\n+    // Note that upstream rust libraries may contain native dependencies as\n+    // well, but they also can't depend on what we just started to add to the\n+    // link line. And finally upstream native libraries can't depend on anything\n+    // in this DAG so far because they're only dylibs and dylibs can only depend\n+    // on other dylibs (e.g. other native deps).\n+    add_local_native_libraries(cmd, sess, codegen_results);\n+    add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n+\n+    // Tell the linker what we're doing.\n+    if crate_type != config::CrateType::Executable {\n+        cmd.build_dylib(out_filename);\n+    }\n+    if crate_type == config::CrateType::Executable && sess.crt_static() {\n+        cmd.build_static_executable();\n+    }\n+\n+    if sess.opts.debugging_opts.pgo_gen.is_some() {\n+        cmd.pgo_gen();\n+    }\n+\n+    // Finally add all the linker arguments provided on the command line along\n+    // with any #[link_args] attributes found inside the crate\n+    if let Some(ref args) = sess.opts.cg.link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.cg.link_arg);\n+    cmd.args(&used_link_args);\n+}"}, {"sha": "986fe71e906b32898b1e716f6ab2fb314a002fff", "filename": "src/link_copied.rs", "status": "added", "additions": 777, "deletions": 0, "changes": 777, "blob_url": "https://github.com/rust-lang/rust/blob/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Flink_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5d16178d7743bf0e6a11c63c55855822f2693b/src%2Flink_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flink_copied.rs?ref=ef5d16178d7743bf0e6a11c63c55855822f2693b", "patch": "@@ -0,0 +1,777 @@\n+//! All functions here are copied from https://github.com/rust-lang/rust/blob/942864a000efd74b73e36bda5606b2cdb55ecf39/src/librustc_codegen_llvm/back/link.rs\n+\n+use std::env;\n+use std::fmt;\n+use std::fs;\n+use std::io;\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+use std::process::{Output, Stdio};\n+\n+use cc::windows_registry;\n+\n+use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n+use rustc::middle::dependency_format::Linkage;\n+use rustc::session::config::{self, OutputType, RUST_CGU_EXT};\n+use rustc::session::search_paths::PathKind;\n+use rustc::session::Session;\n+use rustc::util::common::time;\n+use rustc_codegen_utils::command::Command;\n+use rustc_codegen_utils::linker::*;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_fs_util::fix_windows_verbatim_for_gcc;\n+use rustc_target::spec::LinkerFlavor;\n+use syntax::attr;\n+\n+use crate::prelude::*;\n+\n+use crate::archive::{ArchiveBuilder, ArchiveConfig};\n+use crate::metadata::METADATA_FILENAME;\n+\n+\n+// cg_clif doesn't have bytecode, so this is just a dummy\n+const RLIB_BYTECODE_EXTENSION: &str = \".cg_clif_bytecode_dummy\";\n+\n+fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n+    let mut search = Vec::new();\n+    sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n+        search.push(path.to_path_buf());\n+    });\n+    return search;\n+}\n+\n+fn archive_config<'a>(sess: &'a Session,\n+                      output: &Path,\n+                      input: Option<&Path>) -> ArchiveConfig<'a> {\n+    ArchiveConfig {\n+        sess,\n+        dst: output.to_path_buf(),\n+        src: input.map(|p| p.to_path_buf()),\n+        lib_search_paths: archive_search_paths(sess),\n+    }\n+}\n+\n+// The third parameter is for env vars, used on windows to set up the\n+// path for MSVC to find its DLLs, and gcc to find its bundled\n+// toolchain\n+pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n+    let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n+\n+    // If our linker looks like a batch script on Windows then to execute this\n+    // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n+    // emscripten where the linker is `emcc.bat` and needs to be spawned as\n+    // `cmd /c emcc.bat ...`.\n+    //\n+    // This worked historically but is needed manually since #42436 (regression\n+    // was tagged as #42791) and some more info can be found on #44443 for\n+    // emscripten itself.\n+    let mut cmd = match linker.to_str() {\n+        Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n+        _ => match flavor {\n+            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n+            LinkerFlavor::Msvc\n+                if sess.opts.cg.linker.is_none() && sess.target.target.options.linker.is_none() =>\n+            {\n+                Command::new(msvc_tool.as_ref().map(|t| t.path()).unwrap_or(linker))\n+            },\n+            _ => Command::new(linker),\n+        }\n+    };\n+\n+    // The compiler's sysroot often has some bundled tools, so add it to the\n+    // PATH for the child.\n+    let mut new_path = sess.host_filesearch(PathKind::All)\n+                           .get_tools_search_paths();\n+    let mut msvc_changed_path = false;\n+    if sess.target.target.options.is_like_msvc {\n+        if let Some(ref tool) = msvc_tool {\n+            cmd.args(tool.args());\n+            for &(ref k, ref v) in tool.env() {\n+                if k == \"PATH\" {\n+                    new_path.extend(env::split_paths(v));\n+                    msvc_changed_path = true;\n+                } else {\n+                    cmd.env(k, v);\n+                }\n+            }\n+        }\n+    }\n+\n+    if !msvc_changed_path {\n+        if let Some(path) = env::var_os(\"PATH\") {\n+            new_path.extend(env::split_paths(&path));\n+        }\n+    }\n+    cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n+\n+    (linker.to_path_buf(), cmd)\n+}\n+\n+pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n+    fn infer_from(\n+        sess: &Session,\n+        linker: Option<PathBuf>,\n+        flavor: Option<LinkerFlavor>,\n+    ) -> Option<(PathBuf, LinkerFlavor)> {\n+        match (linker, flavor) {\n+            (Some(linker), Some(flavor)) => Some((linker, flavor)),\n+            // only the linker flavor is known; use the default linker for the selected flavor\n+            (None, Some(flavor)) => Some((PathBuf::from(match flavor {\n+                LinkerFlavor::Em  => if cfg!(windows) { \"emcc.bat\" } else { \"emcc\" },\n+                LinkerFlavor::Gcc => \"cc\",\n+                LinkerFlavor::Ld => \"ld\",\n+                LinkerFlavor::Msvc => \"link.exe\",\n+                LinkerFlavor::Lld(_) => \"lld\",\n+            }), flavor)),\n+            (Some(linker), None) => {\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                    sess.fatal(\"couldn't extract file stem from specified linker\");\n+                }).to_owned();\n+\n+                let flavor = if stem == \"emcc\" {\n+                    LinkerFlavor::Em\n+                } else if stem == \"gcc\" || stem.ends_with(\"-gcc\") {\n+                    LinkerFlavor::Gcc\n+                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n+                    LinkerFlavor::Ld\n+                } else if stem == \"link\" || stem == \"lld-link\" {\n+                    LinkerFlavor::Msvc\n+                } else if stem == \"lld\" || stem == \"rust-lld\" {\n+                    LinkerFlavor::Lld(sess.target.target.options.lld_flavor)\n+                } else {\n+                    // fall back to the value in the target spec\n+                    sess.target.target.linker_flavor\n+                };\n+\n+                Some((linker, flavor))\n+            },\n+            (None, None) => None,\n+        }\n+    }\n+\n+    // linker and linker flavor specified via command line have precedence over what the target\n+    // specification specifies\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.opts.cg.linker.clone(),\n+        sess.opts.debugging_opts.linker_flavor,\n+    ) {\n+        return ret;\n+    }\n+\n+    if let Some(ret) = infer_from(\n+        sess,\n+        sess.target.target.options.linker.clone().map(PathBuf::from),\n+        Some(sess.target.target.linker_flavor),\n+    ) {\n+        return ret;\n+    }\n+\n+    bug!(\"Not enough information provided to determine how to invoke the linker\");\n+}\n+\n+pub fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n+    -> io::Result<Output>\n+{\n+    // When attempting to spawn the linker we run a risk of blowing out the\n+    // size limits for spawning a new process with respect to the arguments\n+    // we pass on the command line.\n+    //\n+    // Here we attempt to handle errors from the OS saying \"your list of\n+    // arguments is too big\" by reinvoking the linker again with an `@`-file\n+    // that contains all the arguments. The theory is that this is then\n+    // accepted on all linkers and the linker will read all its options out of\n+    // there instead of looking at the command line.\n+    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n+        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n+            Ok(child) => {\n+                let output = child.wait_with_output();\n+                flush_linked_file(&output, out_filename)?;\n+                return output;\n+            }\n+            Err(ref e) if command_line_too_big(e) => {\n+                info!(\"command line to linker was too big: {}\", e);\n+            }\n+            Err(e) => return Err(e)\n+        }\n+    }\n+\n+    info!(\"falling back to passing arguments to linker via an @-file\");\n+    let mut cmd2 = cmd.clone();\n+    let mut args = String::new();\n+    for arg in cmd2.take_args() {\n+        args.push_str(&Escape {\n+            arg: arg.to_str().unwrap(),\n+            is_like_msvc: sess.target.target.options.is_like_msvc,\n+        }.to_string());\n+        args.push_str(\"\\n\");\n+    }\n+    let file = tmpdir.join(\"linker-arguments\");\n+    let bytes = if sess.target.target.options.is_like_msvc {\n+        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n+        // start the stream with a UTF-16 BOM\n+        for c in iter::once(0xFEFF).chain(args.encode_utf16()) {\n+            // encode in little endian\n+            out.push(c as u8);\n+            out.push((c >> 8) as u8);\n+        }\n+        out\n+    } else {\n+        args.into_bytes()\n+    };\n+    fs::write(&file, &bytes)?;\n+    cmd2.arg(format!(\"@{}\", file.display()));\n+    info!(\"invoking linker {:?}\", cmd2);\n+    let output = cmd2.output();\n+    flush_linked_file(&output, out_filename)?;\n+    return output;\n+\n+    #[cfg(unix)]\n+    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    #[cfg(windows)]\n+    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n+        -> io::Result<()>\n+    {\n+        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n+        // even long after process exit, causing nasty, non-reproducible output bugs.\n+        //\n+        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n+        //\n+        // \u0410 full writeup of the original Chrome bug can be found at\n+        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n+\n+        if let &Ok(ref out) = command_output {\n+            if out.status.success() {\n+                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n+                    of.sync_all()?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[cfg(unix)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(::libc::E2BIG)\n+    }\n+\n+    #[cfg(windows)]\n+    fn command_line_too_big(err: &io::Error) -> bool {\n+        const ERROR_FILENAME_EXCED_RANGE: i32 = 206;\n+        err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n+    }\n+\n+    struct Escape<'a> {\n+        arg: &'a str,\n+        is_like_msvc: bool,\n+    }\n+\n+    impl<'a> fmt::Display for Escape<'a> {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            if self.is_like_msvc {\n+                // This is \"documented\" at\n+                // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx\n+                //\n+                // Unfortunately there's not a great specification of the\n+                // syntax I could find online (at least) but some local\n+                // testing showed that this seemed sufficient-ish to catch\n+                // at least a few edge cases.\n+                write!(f, \"\\\"\")?;\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\"' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+                write!(f, \"\\\"\")?;\n+            } else {\n+                // This is documented at https://linux.die.net/man/1/ld, namely:\n+                //\n+                // > Options in file are separated by whitespace. A whitespace\n+                // > character may be included in an option by surrounding the\n+                // > entire option in either single or double quotes. Any\n+                // > character (including a backslash) may be included by\n+                // > prefixing the character to be included with a backslash.\n+                //\n+                // We put an argument on each line, so all we need to do is\n+                // ensure the line is interpreted as one whole argument.\n+                for c in self.arg.chars() {\n+                    match c {\n+                        '\\\\' |\n+                        ' ' => write!(f, \"\\\\{}\", c)?,\n+                        c => write!(f, \"{}\", c)?,\n+                    }\n+                }\n+            }\n+            Ok(())\n+        }\n+    }\n+}\n+\n+// # Rust Crate linking\n+//\n+// Rust crates are not considered at all when creating an rlib output. All\n+// dependencies will be linked when producing the final output (instead of\n+// the intermediate rlib version)\n+pub fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n+                            sess: &Session,\n+                            codegen_results: &CodegenResults,\n+                            crate_type: config::CrateType,\n+                            tmpdir: &Path) {\n+    // All of the heavy lifting has previously been accomplished by the\n+    // dependency_format module of the compiler. This is just crawling the\n+    // output of that module, adding crates as necessary.\n+    //\n+    // Linking to a rlib involves just passing it to the linker (the linker\n+    // will slurp up the object files inside), and linking to a dynamic library\n+    // involves just passing the right -l flag.\n+\n+    let formats = sess.dependency_formats.borrow();\n+    let data = formats.get(&crate_type).unwrap();\n+\n+    // Invoke get_used_crates to ensure that we get a topological sorting of\n+    // crates.\n+    let deps = &codegen_results.crate_info.used_crates_dynamic;\n+\n+    // There's a few internal crates in the standard library (aka libcore and\n+    // libstd) which actually have a circular dependence upon one another. This\n+    // currently arises through \"weak lang items\" where libcore requires things\n+    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n+    // circular dependence to work correctly in all situations we'll need to be\n+    // sure to correctly apply the `--start-group` and `--end-group` options to\n+    // GNU linkers, otherwise if we don't use any other symbol from the standard\n+    // library it'll get discarded and the whole application won't link.\n+    //\n+    // In this loop we're calculating the `group_end`, after which crate to\n+    // pass `--end-group` and `group_start`, before which crate to pass\n+    // `--start-group`. We currently do this by passing `--end-group` after\n+    // the first crate (when iterating backwards) that requires a lang item\n+    // defined somewhere else. Once that's set then when we've defined all the\n+    // necessary lang items we'll pass `--start-group`.\n+    //\n+    // Note that this isn't amazing logic for now but it should do the trick\n+    // for the current implementation of the standard library.\n+    let mut group_end = None;\n+    let mut group_start = None;\n+    let mut end_with = FxHashSet::default();\n+    let info = &codegen_results.crate_info;\n+    for &(cnum, _) in deps.iter().rev() {\n+        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n+            end_with.extend(missing.iter().cloned());\n+            if end_with.len() > 0 && group_end.is_none() {\n+                group_end = Some(cnum);\n+            }\n+        }\n+        end_with.retain(|item| info.lang_item_to_crate.get(item) != Some(&cnum));\n+        if end_with.len() == 0 && group_end.is_some() {\n+            group_start = Some(cnum);\n+            break\n+        }\n+    }\n+\n+    // If we didn't end up filling in all lang items from upstream crates then\n+    // we'll be filling it in with our crate. This probably means we're the\n+    // standard library itself, so skip this for now.\n+    if group_end.is_some() && group_start.is_none() {\n+        group_end = None;\n+    }\n+\n+    let mut compiler_builtins = None;\n+\n+    for &(cnum, _) in deps.iter() {\n+        if group_start == Some(cnum) {\n+            cmd.group_start();\n+        }\n+\n+        // We may not pass all crates through to the linker. Some crates may\n+        // appear statically in an existing dylib, meaning we'll pick up all the\n+        // symbols from the dylib.\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        match data[cnum.as_usize() - 1] {\n+            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n+                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+            }\n+            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n+                link_sanitizer_runtime(cmd, sess, codegen_results, tmpdir, cnum);\n+            }\n+            // compiler-builtins are always placed last to ensure that they're\n+            // linked correctly.\n+            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n+                assert!(compiler_builtins.is_none());\n+                compiler_builtins = Some(cnum);\n+            }\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static => {\n+                add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+            }\n+            Linkage::Dynamic => {\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n+            }\n+        }\n+\n+        if group_end == Some(cnum) {\n+            cmd.group_end();\n+        }\n+    }\n+\n+    // compiler-builtins are always placed last to ensure that they're\n+    // linked correctly.\n+    // We must always link the `compiler_builtins` crate statically. Even if it\n+    // was already \"included\" in a dylib (e.g. `libstd` when `-C prefer-dynamic`\n+    // is used)\n+    if let Some(cnum) = compiler_builtins {\n+        add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+    }\n+\n+    // Converts a library file-stem into a cc -l argument\n+    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n+        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n+            &stem[3..]\n+        } else {\n+            stem\n+        }\n+    }\n+\n+    // We must link the sanitizer runtime using -Wl,--whole-archive but since\n+    // it's packed in a .rlib, it contains stuff that are not objects that will\n+    // make the linker error. So we must remove those bits from the .rlib before\n+    // linking it.\n+    fn link_sanitizer_runtime(cmd: &mut dyn Linker,\n+                              sess: &Session,\n+                              codegen_results: &CodegenResults,\n+                              tmpdir: &Path,\n+                              cnum: CrateNum) {\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+        if sess.target.target.options.is_like_osx {\n+            // On Apple platforms, the sanitizer is always built as a dylib, and\n+            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n+            // rpath to the library as well (the rpath should be absolute, see\n+            // PR #41352 for details).\n+            //\n+            // FIXME: Remove this logic into librustc_*san once Cargo supports it\n+            let rpath = cratepath.parent().unwrap();\n+            let rpath = rpath.to_str().expect(\"non-utf8 component in path\");\n+            cmd.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let cfg = archive_config(sess, &dst, Some(cratepath));\n+        let mut archive = ArchiveBuilder::new(cfg);\n+        archive.update_symbols();\n+\n+        for f in archive.src_files() {\n+            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                archive.remove_file(&f);\n+                continue\n+            }\n+        }\n+\n+        archive.build();\n+\n+        cmd.link_whole_rlib(&dst);\n+    }\n+\n+    // Adds the static \"rlib\" versions of all crates to the command line.\n+    // There's a bit of magic which happens here specifically related to LTO and\n+    // dynamic libraries. Specifically:\n+    //\n+    // * For LTO, we remove upstream object files.\n+    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    //\n+    // When performing LTO, almost(*) all of the bytecode from the upstream\n+    // libraries has already been included in our object file output. As a\n+    // result we need to remove the object files in the upstream libraries so\n+    // the linker doesn't try to include them twice (or whine about duplicate\n+    // symbols). We must continue to include the rest of the rlib, however, as\n+    // it may contain static native libraries which must be linked in.\n+    //\n+    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+    // their bytecode wasn't included. The object files in those libraries must\n+    // still be passed to the linker.\n+    //\n+    // When making a dynamic library, linkers by default don't include any\n+    // object files in an archive if they're not necessary to resolve the link.\n+    // We basically want to convert the archive (rlib) to a dylib, though, so we\n+    // *do* want everything included in the output, regardless of whether the\n+    // linker thinks it's needed or not. As a result we must use the\n+    // --whole-archive option (or the platform equivalent). When using this\n+    // option the linker will fail if there are non-objects in the archive (such\n+    // as our own metadata and/or bytecode). All in all, for rlibs to be\n+    // entirely included in dylibs, we need to remove all non-object files.\n+    //\n+    // Note, however, that if we're not doing LTO or we're not producing a dylib\n+    // (aka we're making an executable), we can just pass the rlib blindly to\n+    // the linker (fast) because it's fine if it's not actually included as\n+    // we're at the end of the dependency chain.\n+    fn add_static_crate(cmd: &mut dyn Linker,\n+                        sess: &Session,\n+                        codegen_results: &CodegenResults,\n+                        tmpdir: &Path,\n+                        crate_type: config::CrateType,\n+                        cnum: CrateNum) {\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+        // See the comment above in `link_staticlib` and `link_rlib` for why if\n+        // there's a static library that's not relevant we skip all object\n+        // files.\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+        let skip_native = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+\n+        if (!are_upstream_rust_objects_already_included(sess) ||\n+            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n+           crate_type != config::CrateType::Dylib &&\n+           !skip_native {\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            return\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let name = cratepath.file_name().unwrap().to_str().unwrap();\n+        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+\n+        time(sess, &format!(\"altering {}.rlib\", name), || {\n+            let cfg = archive_config(sess, &dst, Some(cratepath));\n+            let mut archive = ArchiveBuilder::new(cfg);\n+            archive.update_symbols();\n+\n+            let mut any_objects = false;\n+            for f in archive.src_files() {\n+                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                    archive.remove_file(&f);\n+                    continue\n+                }\n+\n+                let canonical = f.replace(\"-\", \"_\");\n+                let canonical_name = name.replace(\"-\", \"_\");\n+\n+                // Look for `.rcgu.o` at the end of the filename to conclude\n+                // that this is a Rust-related object file.\n+                fn looks_like_rust(s: &str) -> bool {\n+                    let path = Path::new(s);\n+                    let ext = path.extension().and_then(|s| s.to_str());\n+                    if ext != Some(OutputType::Object.extension()) {\n+                        return false\n+                    }\n+                    let ext2 = path.file_stem()\n+                        .and_then(|s| Path::new(s).extension())\n+                        .and_then(|s| s.to_str());\n+                    ext2 == Some(RUST_CGU_EXT)\n+                }\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) &&\n+                    looks_like_rust(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto = are_upstream_rust_objects_already_included(sess) &&\n+                    is_rust_object &&\n+                    (sess.target.target.options.no_builtins ||\n+                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    archive.remove_file(&f);\n+                } else {\n+                    any_objects = true;\n+                }\n+            }\n+\n+            if !any_objects {\n+                return\n+            }\n+            archive.build();\n+\n+            // If we're creating a dylib, then we need to include the\n+            // whole of each object in our archive into that artifact. This is\n+            // because a `dylib` can be reused as an intermediate artifact.\n+            //\n+            // Note, though, that we don't want to include the whole of a\n+            // compiler-builtins crate (e.g. compiler-rt) because it'll get\n+            // repeatedly linked anyway.\n+            if crate_type == config::CrateType::Dylib &&\n+                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n+                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            } else {\n+                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            }\n+        });\n+    }\n+\n+    // Same thing as above, but for dynamic crates instead of static crates.\n+    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+        // If we're performing LTO, then it should have been previously required\n+        // that all upstream rust dependencies were available in an rlib format.\n+        assert!(!are_upstream_rust_objects_already_included(sess));\n+\n+        // Just need to tell the linker about where the library lives and\n+        // what its name is\n+        let parent = cratepath.parent();\n+        if let Some(dir) = parent {\n+            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+        }\n+        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n+        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n+                            parent.unwrap_or(Path::new(\"\")));\n+    }\n+}\n+\n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the command line). These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n+                              sess: &Session,\n+                              codegen_results: &CodegenResults) {\n+    sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n+        match k {\n+            PathKind::Framework => { cmd.framework_path(path); }\n+            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n+        }\n+    });\n+\n+    let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n+        relevant_lib(sess, l)\n+    });\n+\n+    let search_path = archive_search_paths(sess);\n+    for lib in relevant_libs {\n+        let name = match lib.name {\n+            Some(ref l) => l,\n+            None => continue,\n+        };\n+        match lib.kind {\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+            NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&name.as_str()),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&name.as_str(),\n+                                                                        &search_path)\n+        }\n+    }\n+}\n+\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native dependencies are all non-static\n+// dependencies. We've got two cases then:\n+//\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+// native dependency because the rlib is just an archive.\n+//\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+// have the dependency present on the system somewhere. Thus, we don't\n+// gain a whole lot from not linking in the dynamic dependency to this\n+// crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate are purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n+                                 sess: &Session,\n+                                 codegen_results: &CodegenResults,\n+                                 crate_type: config::CrateType) {\n+    // Be sure to use a topological sorting of crates because there may be\n+    // interdependencies between native libraries. When passing -nodefaultlibs,\n+    // for example, almost all native libraries depend on libc, so we have to\n+    // make sure that's all the way at the right (liblibc is near the base of\n+    // the dependency chain).\n+    //\n+    // This passes RequireStatic, but the actual requirement doesn't matter,\n+    // we're just getting an ordering of crate numbers, we're not worried about\n+    // the paths.\n+    let formats = sess.dependency_formats.borrow();\n+    let data = formats.get(&crate_type).unwrap();\n+\n+    let crates = &codegen_results.crate_info.used_crates_static;\n+    for &(cnum, _) in crates {\n+        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n+            let name = match lib.name {\n+                Some(ref l) => l,\n+                None => continue,\n+            };\n+            if !relevant_lib(sess, &lib) {\n+                continue\n+            }\n+            match lib.kind {\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&name.as_str()),\n+                NativeLibraryKind::NativeStaticNobundle => {\n+                    // Link \"static-nobundle\" native libs only if the crate they originate from\n+                    // is being linked statically to the current crate.  If it's linked dynamically\n+                    // or is an rlib already included via some other dylib crate, the symbols from\n+                    // native libs will have already been included in that dylib.\n+                    if data[cnum.as_usize() - 1] == Linkage::Static {\n+                        cmd.link_staticlib(&name.as_str())\n+                    }\n+                },\n+                // ignore statically included native libraries here as we've\n+                // already included them when we included the rust library\n+                // previously\n+                NativeLibraryKind::NativeStatic => {}\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns a boolean indicating whether the specified crate should be ignored\n+/// during LTO.\n+///\n+/// Crates ignored during LTO are not lumped together in the \"massive object\n+/// file\" that we create and are linked in their normal rlib states. See\n+/// comments below for what crates do not participate in LTO.\n+///\n+/// It's unusual for a crate to not participate in LTO. Typically only\n+/// compiler-specific and unstable crates have a reason to not participate in\n+/// LTO.\n+fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n+    // If our target enables builtin function lowering in LLVM then the\n+    // crates providing these functions don't participate in LTO (e.g.\n+    // no_builtins or compiler builtins crates).\n+    !sess.target.target.options.no_builtins &&\n+        (info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum))\n+}\n+\n+fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n+    match lib.cfg {\n+        Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, None),\n+        None => true,\n+    }\n+}\n+\n+fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+    match sess.lto() {\n+        Lto::Fat => true,\n+        Lto::Thin => {\n+            // If we defer LTO to the linker, we haven't run LTO ourselves, so\n+            // any upstream object files have not been copied yet.\n+            !sess.opts.debugging_opts.cross_lang_lto.enabled()\n+        }\n+        Lto::No |\n+        Lto::ThinLocal => false,\n+    }\n+}"}]}