{"sha": "799eef691969c2f6ecf33359f0b1e1691a060648", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5OWVlZjY5MTk2OWMyZjZlY2YzMzM1OWYwYjFlMTY5MWEwNjA2NDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-18T13:11:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-18T13:11:03Z"}, "message": "Auto merge of #5818 - flip1995:rustup, r=flip1995\n\nRename TypeckTables to TypeckResults.\n\nr? @ghost\n\nchangelog: none", "tree": {"sha": "bcf7fb0c0e0ef7763e919158b4085f48825fe398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcf7fb0c0e0ef7763e919158b4085f48825fe398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/799eef691969c2f6ecf33359f0b1e1691a060648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/799eef691969c2f6ecf33359f0b1e1691a060648", "html_url": "https://github.com/rust-lang/rust/commit/799eef691969c2f6ecf33359f0b1e1691a060648", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/799eef691969c2f6ecf33359f0b1e1691a060648/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a945c741375740d89c3c2029f3a46adeb7e510f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a945c741375740d89c3c2029f3a46adeb7e510f", "html_url": "https://github.com/rust-lang/rust/commit/9a945c741375740d89c3c2029f3a46adeb7e510f"}, {"sha": "0f501ac1db5152fac4712e0357fc498aed6f7313", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f501ac1db5152fac4712e0357fc498aed6f7313", "html_url": "https://github.com/rust-lang/rust/commit/0f501ac1db5152fac4712e0357fc498aed6f7313"}], "stats": {"total": 896, "additions": 471, "deletions": 425}, "files": [{"sha": "e84481f9b5385a2a538cbfc1b3ffb75a0afc702d", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n                     _ => (),\n                 }\n \n-                let (l_ty, r_ty) = (cx.tables().expr_ty(l), cx.tables().expr_ty(r));\n+                let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n                 if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                     self.expr_span = Some(expr.span);\n@@ -96,8 +96,8 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n                 }\n             },\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, arg) => {\n-                let ty = cx.tables().expr_ty(arg);\n-                if constant_simple(cx, cx.tables(), expr).is_none() {\n+                let ty = cx.typeck_results().expr_ty(arg);\n+                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n                     if ty.is_integral() {\n                         span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n                         self.expr_span = Some(expr.span);"}, {"sha": "982d5ecf8d02f03aae9cc3fd52b19be5685fb266", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n             }\n             if_chain! {\n                 if let ExprKind::Unary(_, ref lit) = e.kind;\n-                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables(), lit);\n+                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), lit);\n                 if is_true;\n                 then {\n                     lint_true(true);\n@@ -121,7 +121,7 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         if let ExprKind::DropTemps(ref expr) = expr.kind;\n         if let ExprKind::Unary(UnOp::UnNot, ref expr) = expr.kind;\n         // bind the first argument of the `assert!` macro\n-        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.tables(), expr);\n+        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // arm 1 pattern\n         if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind;\n         if let ExprKind::Lit(ref lit) = lit_expr.kind;"}, {"sha": "dab1e96e282f051c75f8184b718f745fb711cace", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -82,8 +82,8 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n             hir::ExprKind::Assign(assignee, e, _) => {\n                 if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n                     let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n-                        let ty = cx.tables().expr_ty(assignee);\n-                        let rty = cx.tables().expr_ty(rhs);\n+                        let ty = cx.typeck_results().expr_ty(assignee);\n+                        let rty = cx.typeck_results().expr_ty(rhs);\n                         macro_rules! ops {\n                             ($op:expr,\n                              $cx:expr,\n@@ -167,7 +167,7 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.tables().expr_ty(assignee).is_primitive_ty()\n+                            && cx.typeck_results().expr_ty(assignee).is_primitive_ty()\n                         {\n                             match op.node {\n                                 hir::BinOpKind::Add"}, {"sha": "277fe350055ec357a81f6a4a0f0a95f03e74fca6", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -53,7 +53,7 @@ const ATOMIC_TYPES: [&str; 12] = [\n ];\n \n fn type_is_atomic(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.tables().expr_ty(expr).kind {\n+    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind {\n         ATOMIC_TYPES\n             .iter()\n             .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))"}, {"sha": "27a7fa8862237196e2cd6c08efeeb95a90aa7b4c", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -461,15 +461,15 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n \n fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n-        is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n+        is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext<'_>, item: &ImplItem<'_>) -> bool {\n     match item.kind {\n-        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value),\n+        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n@@ -478,31 +478,34 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n     match item.kind {\n         TraitItemKind::Fn(_, TraitFn::Required(_)) => true,\n         TraitItemKind::Fn(_, TraitFn::Provided(eid)) => {\n-            is_relevant_expr(cx, cx.tcx.body_tables(eid), &cx.tcx.hir().body(eid).value)\n+            is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n         },\n         _ => false,\n     }\n }\n \n-fn is_relevant_block(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n+fn is_relevant_block(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>, block: &Block<'_>) -> bool {\n     block.stmts.first().map_or(\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e)),\n+        block\n+            .expr\n+            .as_ref()\n+            .map_or(false, |e| is_relevant_expr(cx, typeck_results, e)),\n         |stmt| match &stmt.kind {\n             StmtKind::Local(_) => true,\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, typeck_results, expr),\n             _ => false,\n         },\n     )\n }\n \n-fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n+fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n-        ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n-        ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),\n+        ExprKind::Block(block, _) => is_relevant_block(cx, typeck_results, block),\n+        ExprKind::Ret(Some(e)) => is_relevant_expr(cx, typeck_results, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.kind {\n-                tables\n+                typeck_results\n                     .qpath_res(qpath, path_expr.hir_id)\n                     .opt_def_id()\n                     .map_or(true, |fun_id| !match_def_path(cx, fun_id, &paths::BEGIN_PANIC))"}, {"sha": "b10b1e0a65ab94e0b3ea232fdad304ba689ab776", "filename": "clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -59,8 +59,8 @@ impl LateLintPass<'_> for AwaitHoldingLock {\n                 hir_id: body.value.hir_id,\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-            let tables = cx.tcx.typeck_tables_of(def_id);\n-            check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n+            let typeck_results = cx.tcx.typeck(def_id);\n+            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n         }\n     }\n }"}, {"sha": "81a34021e8a018aa78faf6cf5b57deb9ba40bf23", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -319,7 +319,7 @@ fn check_ineffective_gt(cx: &LateContext<'_>, span: Span, m: u128, c: u128, op:\n }\n \n fn fetch_int_literal(cx: &LateContext<'_>, lit: &Expr<'_>) -> Option<u128> {\n-    match constant(cx, cx.tables(), lit)?.0 {\n+    match constant(cx, cx.typeck_results(), lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,\n     }"}, {"sha": "18529f2113e77bc16a36b798f3a71ac1539c2917", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -111,8 +111,12 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             match &e.kind {\n                 ExprKind::Unary(UnOp::UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n                 ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n-                    BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n-                    BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n+                    BinOpKind::Or => {\n+                        return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?));\n+                    },\n+                    BinOpKind::And => {\n+                        return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?));\n+                    },\n                     _ => (),\n                 },\n                 ExprKind::Lit(lit) => match lit.node {\n@@ -248,7 +252,7 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n             })\n         },\n         ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n-            let type_of_receiver = cx.tables().expr_ty(&args[0]);\n+            let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n             {\n@@ -450,7 +454,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n                 self.bool_expr(e)\n             },\n             ExprKind::Unary(UnOp::UnNot, inner) => {\n-                if self.cx.tables().node_types()[inner.hir_id].is_bool() {\n+                if self.cx.typeck_results().node_types()[inner.hir_id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n@@ -465,7 +469,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n }\n \n fn implements_ord<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n "}, {"sha": "dde799fcae4cc4165b82ca6f153c97d4286f5cbb", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                     if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n                     if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n-                               walk_ptrs_ty(cx.tables().expr_ty(&filter_args[0])),\n+                               walk_ptrs_ty(cx.typeck_results().expr_ty(&filter_args[0])),\n                                &paths::SLICE_ITER);\n                     then {\n                         let needle = match get_path_name(l) {\n@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables().expr_ty(needle)).kind {\n+                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) ="}, {"sha": "14ef8c319eff1c63b322e21c935fd0c94af8381c", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -60,7 +60,7 @@ impl CognitiveComplexity {\n         let mut helper = CCHelper { cc: 1, returns: 0 };\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n-        let ret_ty = cx.tables().node_type(expr.hir_id);\n+        let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n             returns\n         } else {"}, {"sha": "99f161a0510f4286c7f682016562dd7e99439a6a", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n                 }\n \n                 // Check that the type being compared implements `core::cmp::Ord`\n-                let ty = cx.tables().expr_ty(lhs1);\n+                let ty = cx.typeck_results().expr_ty(lhs1);\n                 let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));\n \n                 if !is_ord {"}, {"sha": "49ff86a205d96cb20bb7a5d4a4a510b2e6f5d7f4", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -174,12 +174,12 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n \n pub fn constant<'tcx>(\n     lcx: &LateContext<'tcx>,\n-    tables: &ty::TypeckTables<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         lcx,\n-        tables,\n+        typeck_results,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n         substs: lcx.tcx.intern_substs(&[]),\n@@ -189,20 +189,20 @@ pub fn constant<'tcx>(\n \n pub fn constant_simple<'tcx>(\n     lcx: &LateContext<'tcx>,\n-    tables: &ty::TypeckTables<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,\n ) -> Option<Constant> {\n-    constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`.\n+/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n pub fn constant_context<'a, 'tcx>(\n     lcx: &'a LateContext<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n ) -> ConstEvalLateContext<'a, 'tcx> {\n     ConstEvalLateContext {\n         lcx,\n-        tables,\n+        typeck_results,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n         substs: lcx.tcx.intern_substs(&[]),\n@@ -211,7 +211,7 @@ pub fn constant_context<'a, 'tcx>(\n \n pub struct ConstEvalLateContext<'a, 'tcx> {\n     lcx: &'a LateContext<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     needed_resolution: bool,\n     substs: SubstsRef<'tcx>,\n@@ -224,21 +224,21 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             return self.ifthenelse(cond, then, otherwise);\n         }\n         match e.kind {\n-            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.tables.expr_ty(e)),\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n             ExprKind::Block(ref block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty_opt(e))),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n             ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n-                let n = match self.tables.expr_ty(e).kind {\n+                let n = match self.typeck_results.expr_ty(e).kind {\n                     ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n             ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnOp::UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n-                UnOp::UnNeg => self.constant_negate(&o, self.tables.expr_ty(e)),\n+                UnOp::UnNot => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::UnNeg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::UnDeref => Some(o),\n             }),\n             ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 if_chain! {\n                     if args.is_empty();\n                     if let ExprKind::Path(qpath) = &callee.kind;\n-                    let res = self.tables.qpath_res(qpath, callee.hir_id);\n+                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n                     if let Some(def_id) = res.opt_def_id();\n                     let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n                     let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n@@ -319,10 +319,10 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n \n     /// Lookup a possibly constant expression from a `ExprKind::Path`.\n     fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n-        let res = self.tables.qpath_res(qpath, id);\n+        let res = self.typeck_results.qpath_res(qpath, id);\n         match res {\n             Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.tables.node_substs(id);\n+                let substs = self.typeck_results.node_substs(id);\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty_opt(left)?.kind {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match self.typeck_results.expr_ty_opt(left)?.kind {\n                 ty::Int(ity) => {\n                     let l = sext(self.lcx.tcx, l, ity);\n                     let r = sext(self.lcx.tcx, r, ity);\n@@ -494,23 +494,25 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::{ConstValue, Scalar};\n     match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => match result.ty.kind {\n-            ty::Bool => Some(Constant::Bool(d == 1)),\n-            ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n-            ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                d.try_into().expect(\"invalid f32 bit representation\"),\n-            ))),\n-            ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                d.try_into().expect(\"invalid f64 bit representation\"),\n-            ))),\n-            ty::RawPtr(type_and_mut) => {\n-                if let ty::Uint(_) = type_and_mut.ty.kind {\n-                    return Some(Constant::RawPtr(d));\n-                }\n-                None\n-            },\n-            // FIXME: implement other conversions.\n-            _ => None,\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => {\n+            match result.ty.kind {\n+                ty::Bool => Some(Constant::Bool(d == 1)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n+                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+                    d.try_into().expect(\"invalid f32 bit representation\"),\n+                ))),\n+                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                    d.try_into().expect(\"invalid f64 bit representation\"),\n+                ))),\n+                ty::RawPtr(type_and_mut) => {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind {\n+                        return Some(Constant::RawPtr(d));\n+                    }\n+                    None\n+                },\n+                // FIXME: implement other conversions.\n+                _ => None,\n+            }\n         },\n         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n             ty::Ref(_, tam, _) => match tam.kind {"}, {"sha": "1f8bff8d71e0f33d77c8e1c3b06237196d98baf6", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -320,7 +320,7 @@ fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty\n             },\n             PatKind::Binding(.., ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.tables().pat_ty(pat));\n+                    v.insert(cx.typeck_results().pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {\n                     bindings_impl(cx, as_pat, map);"}, {"sha": "ea2447681293de4d1e438e15330fdc7d239f8a7e", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n \n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n-                        let expr_ty = cx.tables().expr_ty(expr);\n+                        let expr_ty = cx.typeck_results().expr_ty(expr);\n                         if let ty::Adt(..) = expr_ty.kind {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg("}, {"sha": "b5fb51af1c7f31f6192ac279d107f274cf5156bc", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -74,7 +74,7 @@ fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var\n     match method_name {\n         \"deref\" => {\n             let impls_deref_trait = cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n+                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n             });\n             if impls_deref_trait {\n                 span_lint_and_sugg(\n@@ -90,7 +90,7 @@ fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var\n         },\n         \"deref_mut\" => {\n             let impls_deref_mut_trait = cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n+                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n             });\n             if impls_deref_mut_trait {\n                 span_lint_and_sugg("}, {"sha": "57ff569f14b0f7bb18d54817b5a38742172254f2", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n                 let lint;\n                 let msg;\n                 let arg = &args[0];\n-                let arg_ty = cx.tables().expr_ty(arg);\n+                let arg_ty = cx.typeck_results().expr_ty(arg);\n \n                 if let ty::Ref(..) = arg_ty.kind {\n                     if match_def_path(cx, def_id, &paths::DROP) {"}, {"sha": "1dfb2eaa579728d98bf628f9e3b467f9ca6725c5", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -43,8 +43,8 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n-            if match_type(cx, walk_ptrs_ty(cx.tables().expr_ty(&args[0])), &paths::DURATION);\n-            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables(), right);\n+            if match_type(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0])), &paths::DURATION);\n+            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {\n                     (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\","}, {"sha": "d616502a82a0c07adbbbda1150fb47580ca3558e", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -106,7 +106,7 @@ fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n         then {\n             let map = &params[0];\n-            let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(map));\n+            let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(map));\n \n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))"}, {"sha": "140cd21c34e67916b9922565cbaf11ec46a9adef", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -103,8 +103,8 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n-                        let lty = cx.tables().expr_ty(l);\n-                        let rty = cx.tables().expr_ty(r);\n+                        let lty = cx.typeck_results().expr_ty(l);\n+                        let rty = cx.typeck_results().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n                         let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n@@ -126,7 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                             )\n                         } else if lcpy\n                             && !rcpy\n-                            && implements_trait(cx, lty, trait_id, &[cx.tables().expr_ty(right).into()])\n+                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -145,7 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                             )\n                         } else if !lcpy\n                             && rcpy\n-                            && implements_trait(cx, cx.tables().expr_ty(left), trait_id, &[rty.into()])\n+                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -166,10 +166,10 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     },\n                     // &foo == bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), _) => {\n-                        let lty = cx.tables().expr_ty(l);\n+                        let lty = cx.typeck_results().expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n-                            && implements_trait(cx, lty, trait_id, &[cx.tables().expr_ty(right).into()])\n+                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n                         {\n                             span_lint_and_then(\n                                 cx,\n@@ -190,10 +190,10 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     },\n                     // foo == &bar\n                     (_, &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n-                        let rty = cx.tables().expr_ty(r);\n+                        let rty = cx.typeck_results().expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)\n-                            && implements_trait(cx, cx.tables().expr_ty(left), trait_id, &[rty.into()])\n+                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n                         {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();"}, {"sha": "dbd1ff514f0e13292b6d7a8a0aa2efc7b2e220d6", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n }\n \n fn check(cx: &LateContext<'_>, e: &Expr<'_>, span: Span) {\n-    if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), e) {\n+    if let Some(Constant::Int(0)) = constant_simple(cx, cx.typeck_results(), e) {\n         span_lint(\n             cx,\n             ERASING_OP,"}, {"sha": "82549c12d0a207c31b839bcc726dba37d9e61e07", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n \n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n         cx.tcx.infer_ctxt().enter(|infcx| {\n-            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.tables()).consume_body(body);\n+            ExprUseVisitor::new(&mut v, &infcx, fn_def_id, cx.param_env, cx.typeck_results()).consume_body(body);\n         });\n \n         for node in v.set {"}, {"sha": "87254c1dbc490a9fac3706194fa35d9759f4d4cc", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -97,7 +97,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             // Are the expression or the arguments type-adjusted? Then we need the closure\n             if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n \n-            let fn_ty = cx.tables().expr_ty(caller);\n+            let fn_ty = cx.typeck_results().expr_ty(caller);\n \n             if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n \n@@ -128,7 +128,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             // Are the expression or the arguments type-adjusted? Then we need the closure\n             if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n \n-            let method_def_id = cx.tables().type_dependent_def_id(ex.hir_id).unwrap();\n+            let method_def_id = cx.typeck_results().type_dependent_def_id(ex.hir_id).unwrap();\n             if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n \n             if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n@@ -153,7 +153,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n /// Tries to determine the type for universal function call to be used instead of the closure\n fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n     let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n-    let actual_type_of_self = &cx.tables().node_type(self_arg.hir_id);\n+    let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n         if match_borrow_depth(expected_type_of_self, &actual_type_of_self)"}, {"sha": "c00638ecc0c1d26619ef188f3b66da2f1e6a5bc4", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n         match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n-                let typ = self.cx.tables().expr_ty(func);\n+                let typ = self.cx.typeck_results().expr_ty(func);\n                 match typ.kind {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n@@ -149,7 +149,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprKind::MethodCall(..) => {\n-                let borrowed_table = self.cx.tables();\n+                let borrowed_table = self.cx.typeck_results();\n                 if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n                 }"}, {"sha": "000762334f61eb022944aa0ca69fb84e3a21bf41", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -73,7 +73,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n     struct FindPanicUnwrap<'a, 'tcx> {\n         lcx: &'a LateContext<'tcx>,\n-        tables: &'tcx ty::TypeckTables<'tcx>,\n+        typeck_results: &'tcx ty::TypeckResults<'tcx>,\n         result: Vec<Span>,\n     }\n \n@@ -96,7 +96,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n+                let reciever_ty = walk_ptrs_ty(self.typeck_results.expr_ty(&arglists[0][0]));\n                 if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n                     || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n                 {\n@@ -124,7 +124,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                 let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n                     lcx: cx,\n-                    tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n+                    typeck_results: cx.tcx.typeck(impl_item_def_id),\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(&body.value);"}, {"sha": "358b9f6dcd0a5eb3cd66c092c3d238c1ee1376a9", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -61,7 +61,7 @@ declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            let ty = cx.tables().expr_ty(expr);\n+            let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;"}, {"sha": "93f6ec92ec71328512aeb92b4b6b5976139fc45b", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -112,7 +112,7 @@ declare_lint_pass!(FloatingPointArithmetic => [\n // Returns the specialized log method for a given base if base is constant\n // and is one of 2, 10 and e\n fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&'static str> {\n-    if let Some((value, _)) = constant(cx, cx.tables(), base) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), base) {\n         if F32(2.0) == value || F64(2.0) == value {\n             return Some(\"log2\");\n         } else if F32(10.0) == value || F64(10.0) == value {\n@@ -136,7 +136,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     if_chain! {\n         // if the expression is a float literal and it is unsuffixed then\n         // add a suffix so the suggestion is valid and unambiguous\n-        if let ty::Float(float_ty) = cx.tables().expr_ty(expr).kind;\n+        if let ty::Float(float_ty) = cx.typeck_results().expr_ty(expr).kind;\n         if let ExprKind::Lit(lit) = &expr.kind;\n         if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n         then {\n@@ -188,7 +188,10 @@ fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n         rhs,\n     ) = &args[0].kind\n     {\n-        let recv = match (constant(cx, cx.tables(), lhs), constant(cx, cx.tables(), rhs)) {\n+        let recv = match (\n+            constant(cx, cx.typeck_results(), lhs),\n+            constant(cx, cx.typeck_results(), rhs),\n+        ) {\n             (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n             (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n             _ => return,\n@@ -233,7 +236,7 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n \n fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n-    if let Some((value, _)) = constant(cx, cx.tables(), &args[0]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[0]) {\n         let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n             \"exp\"\n         } else if F32(2.0) == value || F64(2.0) == value {\n@@ -254,7 +257,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n \n     // Check argument\n-    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n         let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n             (\n                 SUBOPTIMAL_FLOPS,\n@@ -294,7 +297,7 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n }\n \n fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n-    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), &args[1]) {\n         if value == Int(2) {\n             if let Some(parent) = get_parent_expr(cx, expr) {\n                 if let Some(grandparent) = get_parent_expr(cx, parent) {\n@@ -382,8 +385,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n                 _\n             ) = add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n-            if let Some((lvalue, _)) = constant(cx, cx.tables(), &largs[1]);\n-            if let Some((rvalue, _)) = constant(cx, cx.tables(), &rargs[1]);\n+            if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), &largs[1]);\n+            if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), &rargs[1]);\n             if Int(2) == lvalue && Int(2) == rvalue;\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\")));\n@@ -413,11 +416,11 @@ fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n-        if cx.tables().expr_ty(lhs).is_floating_point();\n-        if let Some((value, _)) = constant(cx, cx.tables(), rhs);\n+        if cx.typeck_results().expr_ty(lhs).is_floating_point();\n+        if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n         if let ExprKind::MethodCall(ref path, _, ref method_args, _) = lhs.kind;\n-        if cx.tables().expr_ty(&method_args[0]).is_floating_point();\n+        if cx.typeck_results().expr_ty(&method_args[0]).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n             span_lint_and_sugg(\n@@ -439,8 +442,8 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n fn is_float_mul_expr<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n         if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n-        if cx.tables().expr_ty(lhs).is_floating_point();\n-        if cx.tables().expr_ty(rhs).is_floating_point();\n+        if cx.typeck_results().expr_ty(lhs).is_floating_point();\n+        if cx.typeck_results().expr_ty(rhs).is_floating_point();\n         then {\n             return Some((lhs, rhs));\n         }\n@@ -527,7 +530,7 @@ fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) ->\n \n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match constant_simple(cx, cx.tables(), expr) {\n+    match constant_simple(cx, cx.typeck_results(), expr) {\n         Some(Constant::Int(i)) => i == 0,\n         Some(Constant::F32(f)) => f == 0.0,\n         Some(Constant::F64(f)) => f == 0.0,\n@@ -662,8 +665,8 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             mul_lhs,\n             mul_rhs,\n         ) = &div_lhs.kind;\n-        if let Some((rvalue, _)) = constant(cx, cx.tables(), div_rhs);\n-        if let Some((lvalue, _)) = constant(cx, cx.tables(), mul_rhs);\n+        if let Some((rvalue, _)) = constant(cx, cx.typeck_results(), div_rhs);\n+        if let Some((lvalue, _)) = constant(cx, cx.typeck_results(), mul_rhs);\n         then {\n             // TODO: also check for constant values near PI/180 or 180/PI\n             if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&\n@@ -699,7 +702,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n-            let recv_ty = cx.tables().expr_ty(&args[0]);\n+            let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {\n                 match &*path.ident.name.as_str() {"}, {"sha": "572c839502f4f20acc62d6a6182e918706421622", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -90,7 +90,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n-            let ty = walk_ptrs_ty(cx.tables().pat_ty(&pats[0]));\n+            let ty = walk_ptrs_ty(cx.typeck_results().pat_ty(&pats[0]));\n             if ty.kind != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n                 return None;\n             }"}, {"sha": "3ee0b3f74b8c5a3bf96e3877fa6fbe91d757f9b8", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -392,11 +392,11 @@ impl<'tcx> Functions {\n                 .collect::<FxHashSet<_>>();\n \n             if !raw_ptrs.is_empty() {\n-                let tables = cx.tcx.body_tables(body.id());\n+                let typeck_results = cx.tcx.typeck_body(body.id());\n                 let mut v = DerefVisitor {\n                     cx,\n                     ptrs: raw_ptrs,\n-                    tables,\n+                    typeck_results,\n                 };\n \n                 intravisit::walk_expr(&mut v, expr);\n@@ -494,13 +494,8 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<\n         return false; // ignore `_` patterns\n     }\n     let def_id = pat.hir_id.owner.to_def_id();\n-    if cx.tcx.has_typeck_tables(def_id) {\n-        is_mutable_ty(\n-            cx,\n-            &cx.tcx.typeck_tables_of(def_id.expect_local()).pat_ty(pat),\n-            pat.span,\n-            tys,\n-        )\n+    if cx.tcx.has_typeck_results(def_id) {\n+        is_mutable_ty(cx, &cx.tcx.typeck(def_id.expect_local()).pat_ty(pat), pat.span, tys)\n     } else {\n         false\n     }\n@@ -539,7 +534,7 @@ fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n struct DerefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     ptrs: FxHashSet<hir::HirId>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n@@ -548,7 +543,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Call(ref f, args) => {\n-                let ty = self.tables.expr_ty(f);\n+                let ty = self.typeck_results.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n                     for arg in args {\n@@ -557,7 +552,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                 }\n             },\n             hir::ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(self.cx, base_type) {\n@@ -614,10 +609,10 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                 let mut tys = FxHashSet::default();\n                 for arg in args {\n                     let def_id = arg.hir_id.owner.to_def_id();\n-                    if self.cx.tcx.has_typeck_tables(def_id)\n+                    if self.cx.tcx.has_typeck_results(def_id)\n                         && is_mutable_ty(\n                             self.cx,\n-                            self.cx.tcx.typeck_tables_of(def_id.expect_local()).expr_ty(arg),\n+                            self.cx.tcx.typeck(def_id.expect_local()).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )"}, {"sha": "48ebcf5ebcd9c03db387dfa8a249d4ebd3cc189f", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n \n             // Argument 0 (the struct we're calling the method on) is a vector\n             if let Some(struct_calling_on) = args.get(0);\n-            let struct_ty = cx.tables().expr_ty(struct_calling_on);\n+            let struct_ty = cx.typeck_results().expr_ty(struct_calling_on);\n             if is_type_diagnostic_item(cx, struct_ty, sym!(vec_type));\n \n             // Argument to \"get\" is a subtraction"}, {"sha": "4c62637858cde2b64cd942f9a45741772c9ee7fb", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -62,8 +62,8 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n     // `1 << 0` is a common pattern in bit manipulation code\n     if_chain! {\n         if let BinOpKind::Shl = cmp.node;\n-        if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables(), right);\n-        if let Some(Constant::Int(1)) = constant_simple(cx, cx.tables(), left);\n+        if let Some(Constant::Int(0)) = constant_simple(cx, cx.typeck_results(), right);\n+        if let Some(Constant::Int(1)) = constant_simple(cx, cx.typeck_results(), left);\n         then {\n             return true;\n         }\n@@ -74,8 +74,8 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n \n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables(), e) {\n-        let check = match cx.tables().expr_ty(e).kind {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e) {\n+        let check = match cx.typeck_results().expr_ty(e).kind {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n             ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,"}, {"sha": "2e55094d90c6f33f5ca4e24c68dea3239fe1ac31", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -146,7 +146,7 @@ fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Opt\n     if_chain! {\n         if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n         if path.ident.to_string() == \"lock\";\n-        let ty = cx.tables().expr_ty(&args[0]);\n+        let ty = cx.typeck_results().expr_ty(&args[0]);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n         then {\n             Some(&args[0])"}, {"sha": "5b22df5fe491e70e3afcadb2933e176a6492ff47", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.tables().expr_ty(&result_types[0]), sym!(result_type));\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym!(result_type));\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {"}, {"sha": "5f931a0addedf6b3781460b545d15a7ec46dc629", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                 };\n \n                 // Check if the variable in the condition statement is an integer\n-                if !cx.tables().expr_ty(cond_var).is_integral() {\n+                if !cx.typeck_results().expr_ty(cond_var).is_integral() {\n                     return;\n                 }\n \n@@ -93,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                     ExprKind::Lit(ref cond_lit) => {\n                         // Check if the constant is zero\n                         if let LitKind::Int(0, _) = cond_lit.node {\n-                            if cx.tables().expr_ty(cond_left).is_signed() {\n+                            if cx.typeck_results().expr_ty(cond_left).is_signed() {\n                             } else {\n                                 print_lint_and_sugg(cx, &var_name, expr);\n                             };"}, {"sha": "a1f58e54ae38e97ec6d8c5e17b64e7227b61fd1e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n-            let ty = cx.tables().expr_ty(array);\n+            let ty = cx.typeck_results().expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind {\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.kind {\n                     // Index is a constant uint.\n-                    if let Some(..) = constant(cx, cx.tables(), index) {\n+                    if let Some(..) = constant(cx, cx.typeck_results(), index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays.\n                         return;\n                     }\n@@ -169,14 +169,18 @@ fn to_const_range<'tcx>(\n     range: higher::Range<'_>,\n     array_size: u128,\n ) -> (Option<u128>, Option<u128>) {\n-    let s = range.start.map(|expr| constant(cx, cx.tables(), expr).map(|(c, _)| c));\n+    let s = range\n+        .start\n+        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => Some(x),\n         Some(_) => None,\n         None => Some(0),\n     };\n \n-    let e = range.end.map(|expr| constant(cx, cx.tables(), expr).map(|(c, _)| c));\n+    let e = range\n+        .end\n+        .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => {\n             if range.limits == RangeLimits::Closed {"}, {"sha": "e511d3ea330466b9b85dba31dcc59504904d6857", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -231,13 +231,13 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n             }\n             if method.ident.name == sym!(last) && args.len() == 1 {\n                 let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(false, |id| {\n-                    !implements_trait(cx, cx.tables().expr_ty(&args[0]), id, &[])\n+                    !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n                 });\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }\n             } else if method.ident.name == sym!(collect) {\n-                let ty = cx.tables().expr_ty(expr);\n+                let ty = cx.typeck_results().expr_ty(expr);\n                 if INFINITE_COLLECTORS.iter().any(|path| match_type(cx, ty, path)) {\n                     return is_infinite(cx, &args[0]);\n                 }"}, {"sha": "31181c10d23dbed70a1927e5bba2d3b0ada51069", "filename": "clippy_lints/src/integer_division.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finteger_division.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -50,7 +50,7 @@ fn is_integer_division<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>)\n         if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n         if let hir::BinOpKind::Div = &binop.node;\n         then {\n-            let (left_ty, right_ty) = (cx.tables().expr_ty(left), cx.tables().expr_ty(right));\n+            let (left_ty, right_ty) = (cx.typeck_results().expr_ty(left), cx.typeck_results().expr_ty(right));\n             return left_ty.is_integral() && right_ty.is_integral();\n         }\n     }"}, {"sha": "a7c715879232b980b078c1e00399e0cb2ec8017b", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n-            if let ty::Array(element_type, cst) = cx.tables().expr_ty(expr).kind;\n+            if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind;\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "00d0b8b4e5b7f3c98303e03bd1819f025da3677c", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -300,7 +300,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         return false;\n     }\n \n-    let ty = &walk_ptrs_ty(cx.tables().expr_ty(expr));\n+    let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n     match ty.kind {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx"}, {"sha": "8243b0a29bc68b3642828e3c7295b45f8627c614", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n-                    let has_interior_mutability = !cx.tables().node_type(canonical_id).is_freeze(\n+                    let has_interior_mutability = !cx.typeck_results().node_type(canonical_id).is_freeze(\n                         cx.tcx.at(span),\n                         cx.param_env,\n                     );"}, {"sha": "ae2f6131b5b8fb0bdf653081ca3c0f905c9c9886", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n             if let PatKind::Wild = local.pat.kind;\n             if let Some(ref init) = local.init;\n             then {\n-                let init_ty = cx.tables().expr_ty(init);\n+                let init_ty = cx.typeck_results().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n                         SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n@@ -94,7 +94,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\"\n                     )\n-                } else if is_must_use_ty(cx, cx.tables().expr_ty(init)) {\n+                } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n                     span_lint_and_help(\n                         cx,\n                         LET_UNDERSCORE_MUST_USE,"}, {"sha": "7e3876ff49b462fcc71810ad11684343cf9a188f", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -535,7 +535,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n                 if_chain! {\n                     if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n                     if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n-                    if implements_trait(cx, cx.tables().expr_ty(iter_expr), iter_def_id, &[]);\n+                    if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n                     then {\n                         return;\n                     }\n@@ -981,8 +981,8 @@ fn detect_manual_memcpy<'tcx>(\n                         if_chain! {\n                             if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n                             if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.tables().expr_ty(seqexpr_left))\n-                                && is_slice_like(cx, cx.tables().expr_ty(seqexpr_right));\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_right));\n                             if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n                             if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n \n@@ -1250,8 +1250,8 @@ fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr:\n                     lint_iter_method(cx, args, arg, method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let receiver_ty = cx.tables().expr_ty(&args[0]);\n-                let receiver_ty_adjusted = cx.tables().expr_ty_adjusted(&args[0]);\n+                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n@@ -1296,7 +1296,7 @@ fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr:\n \n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n-    let ty = cx.tables().expr_ty(arg);\n+    let ty = cx.typeck_results().expr_ty(arg);\n     if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n             cx,\n@@ -1400,8 +1400,9 @@ fn check_for_loop_explicit_counter<'tcx>(\n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n-    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR)\n-        .map_or(false, |id| implements_trait(cx, cx.tables().expr_ty(arg), id, &[]));\n+    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n+    });\n     if impls_iterator {\n         format!(\n             \"{}\",\n@@ -1412,7 +1413,7 @@ fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut\n         // (&mut x).into_iter() ==> x.iter_mut()\n         match &arg.kind {\n             ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.tables().expr_ty(&arg_inner)).is_some() =>\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n             {\n                 let meth_name = match mutability {\n                     Mutability::Mut => \"iter_mut\",\n@@ -1445,7 +1446,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.tables().expr_ty(arg).kind {\n+            let (new_pat_span, kind, ty, mutbl) = match cx.typeck_results().expr_ty(arg).kind {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n@@ -1590,7 +1591,14 @@ fn check_for_mutation<'tcx>(\n     };\n     let def_id = body.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables()).walk_expr(body);\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            def_id.expect_local(),\n+            cx.param_env,\n+            cx.typeck_results(),\n+        )\n+        .walk_expr(body);\n     });\n     delegate.mutation_span()\n }\n@@ -1684,7 +1692,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             if index_used_directly {\n                                 self.indexed_directly.insert(\n                                     seqvar.segments[0].ident.name,\n-                                    (Some(extent), self.cx.tables().node_type(seqexpr.hir_id)),\n+                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                                 );\n                             }\n                             return false;  // no need to walk further *on the variable*\n@@ -1696,7 +1704,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             if index_used_directly {\n                                 self.indexed_directly.insert(\n                                     seqvar.segments[0].ident.name,\n-                                    (None, self.cx.tables().node_type(seqexpr.hir_id)),\n+                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                                 );\n                             }\n                             return false;  // no need to walk further *on the variable*\n@@ -1764,7 +1772,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             ExprKind::Call(ref f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n-                    let ty = self.cx.tables().expr_ty_adjusted(expr);\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = ty.kind {\n                         if mutbl == Mutability::Mut {\n@@ -1775,7 +1783,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n+                let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = ty.kind {\n@@ -1862,7 +1870,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n-    let ty = cx.tables().expr_ty(e);\n+    let ty = cx.typeck_results().expr_ty(e);\n     is_iterable_array(ty, cx) ||\n     is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n@@ -2221,7 +2229,7 @@ fn path_name(e: &Expr<'_>) -> Option<Name> {\n }\n \n fn check_infinite_loop<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n-    if constant(cx, cx.tables(), cond).is_some() {\n+    if constant(cx, cx.typeck_results(), cond).is_some() {\n         // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n     }\n@@ -2357,7 +2365,7 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         then {\n-            let ty = cx.tables().node_type(ty.hir_id);\n+            let ty = cx.typeck_results().node_type(ty.hir_id);\n             if is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n                 is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||"}, {"sha": "641e6a17043246937384a2ae7c946d44a91fc634", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n-            let ty = cx.tables().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                         match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n                                 if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.tables().expr_ty(inner).kind {\n+                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n@@ -79,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                 if ident_eq(name, &obj[0]) && method.ident.as_str() == \"clone\"\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n-                                    let obj_ty = cx.tables().expr_ty(&obj[0]);\n+                                    let obj_ty = cx.typeck_results().expr_ty(&obj[0]);\n                                     if let ty::Ref(_, ty, _) = obj_ty.kind {\n                                         let copy = is_copy(cx, ty);\n                                         lint(cx, e.span, args[0].span, copy);"}, {"sha": "d4c2e66ff4b1e4a85dcc80a21feaf8c0e2ba4e3d", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -63,7 +63,7 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if args.len() == 2 && method.ident.as_str() == \"map\";\n-        let caller_ty = cx.tables().expr_ty(&args[0]);\n+        let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if match_trait_method(cx, expr, &paths::ITERATOR)\n             || is_type_diagnostic_item(cx, caller_ty, sym!(result_type))\n             || is_type_diagnostic_item(cx, caller_ty, sym!(option_type));\n@@ -119,7 +119,7 @@ fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n /// Returns true iff an expression returns the same thing as a parameter's pattern\n fn match_expr_param(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n     if let PatKind::Binding(_, _, ident, _) = pat.kind {\n-        match_var(expr, ident.name) && !(cx.tables().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n+        match_var(expr, ident.name) && !(cx.typeck_results().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n     } else {\n         false\n     }"}, {"sha": "198251c58ddc50dde677ebcc7397924f1981b26f", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -101,7 +101,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n }\n \n fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n \n     if let ty::FnDef(id, _) = ty.kind {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_bound_vars() {\n@@ -112,7 +112,7 @@ fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n }\n \n fn is_unit_expression(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-    is_unit_type(cx.tables().expr_ty(expr))\n+    is_unit_type(cx.typeck_results().expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n@@ -205,13 +205,14 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n-    let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(option_type)) {\n-        (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(var_arg), sym!(result_type)) {\n-        (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n-    } else {\n-        return;\n-    };\n+    let (map_type, variant, lint) =\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(option_type)) {\n+            (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n+        } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(result_type)) {\n+            (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n+        } else {\n+            return;\n+        };\n     let fn_arg = &map_args[1];\n \n     if is_unit_function(cx, fn_arg) {"}, {"sha": "4f8f2cb171d5bf2358c772e46e172176fa0f36fa", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -88,13 +88,13 @@ fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Opti\n }\n \n fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     is_type_diagnostic_item(cx, ty, sym!(vec_type))\n }\n \n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n     match_type(cx, ty, &utils::paths::RANGE_FULL)\n }"}, {"sha": "ea6fb9e902576ee17d43ffd250a6b5277fd4fbfe", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -620,7 +620,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             return; \n         };\n \n-        let ty = cx.tables().expr_ty(ex);\n+        let ty = cx.typeck_results().expr_ty(ex);\n         if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n@@ -712,7 +712,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n-    if cx.tables().expr_ty(ex).kind == ty::Bool {\n+    if cx.typeck_results().expr_ty(ex).kind == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -775,8 +775,8 @@ fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n }\n \n fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.tables().expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.tables().expr_ty(ex));\n+    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {\n             if let Some((start, end)) = overlapping(&type_ranges) {\n@@ -794,7 +794,7 @@ fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms\n }\n \n fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ex_ty = walk_ptrs_ty(cx.tables().expr_ty(ex));\n+    let ex_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(ex));\n     if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n@@ -835,7 +835,7 @@ fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n }\n \n fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.tables().expr_ty(ex);\n+    let ty = cx.typeck_results().expr_ty(ex);\n     if !ty.is_enum() {\n         // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n         // don't complain about not enumerating the mall.\n@@ -1010,8 +1010,8 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n                 \"as_mut\"\n             };\n \n-            let output_ty = cx.tables().expr_ty(expr);\n-            let input_ty = cx.tables().expr_ty(ex);\n+            let output_ty = cx.typeck_results().expr_ty(expr);\n+            let input_ty = cx.typeck_results().expr_ty(ex);\n \n             let cast = if_chain! {\n                 if let ty::Adt(_, substs) = input_ty.kind;\n@@ -1079,7 +1079,7 @@ fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n     if_chain! {\n         if arms.len() == 2;\n-        if cx.tables().expr_ty(expr).is_bool();\n+        if cx.typeck_results().expr_ty(expr).is_bool();\n         if is_wild(&arms[1].pat);\n         if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n         if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n@@ -1154,13 +1154,13 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n     match match_body.kind {\n         ExprKind::Block(block, _) => {\n             // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.tables().expr_ty(&match_body).is_unit() {\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(&match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n         _ => {\n             // expr_ty(body) == ()\n-            if cx.tables().expr_ty(&match_body).is_unit() {\n+            if cx.typeck_results().expr_ty(&match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n@@ -1255,11 +1255,11 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n             {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs = match lhs {\n-                        Some(lhs) => constant(cx, cx.tables(), lhs)?.0,\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n                         None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n                     };\n                     let rhs = match rhs {\n-                        Some(rhs) => constant(cx, cx.tables(), rhs)?.0,\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n                     let rhs = match range_end {\n@@ -1273,7 +1273,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                 }\n \n                 if let PatKind::Lit(ref value) = pat.kind {\n-                    let value = constant(cx, cx.tables(), value)?.0;\n+                    let value = constant(cx, cx.typeck_results(), value)?.0;\n                     return Some(SpannedRange {\n                         span: pat.span,\n                         node: (value.clone(), Bound::Included(value)),"}, {"sha": "c71c2ee7d70afeaf8ab5e63718b781197ef49654", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_DISCRIMINANT);\n             // type is non-enum\n-            let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);\n+            let ty_param = cx.typeck_results().node_substs(func.hir_id).type_at(0);\n             if !ty_param.is_enum();\n \n             then {"}, {"sha": "8c6fd10f98a1e178c4fa6bbdb7b731592208f1f6", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> LateLintPass<'tcx> for MemForget {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                        let forgot_ty = cx.tables().expr_ty(&args[0]);\n+                        let forgot_ty = cx.typeck_results().expr_ty(&args[0]);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {\n                             span_lint(cx, MEM_FORGET, e.span, \"usage of `mem::forget` on `Drop` type\");"}, {"sha": "bb0acecc5a92d1a7a5d8fefdfad4ada9372ef443", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -138,7 +138,7 @@ fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &E\n fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n     if_chain! {\n         // check if replacement is mem::MaybeUninit::uninit().assume_init()\n-        if let Some(method_def_id) = cx.tables().type_dependent_def_id(src.hir_id);\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(src.hir_id);\n         if cx.tcx.is_diagnostic_item(sym::assume_init, method_def_id);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n@@ -179,7 +179,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'\n                     applicability,\n                 );\n             } else if cx.tcx.is_diagnostic_item(sym::mem_zeroed, repl_def_id) &&\n-                    !cx.tables().expr_ty(src).is_primitive() {\n+                    !cx.typeck_results().expr_ty(src).is_primitive() {\n                 span_lint_and_help(\n                     cx,\n                     MEM_REPLACE_WITH_UNINIT,"}, {"sha": "498f12518f8a33745325056f1264dcdb5f6565d2", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -157,7 +157,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n     fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-        if !match_type(cx, cx.tables().expr_ty(&args[0]), Self::TYPE_QPATH) {\n+        if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n             return;\n         }\n "}, {"sha": "e5f815772eba946fe32d5221d39c8620e83d553d", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -11,9 +11,9 @@ use rustc_middle::ty::{self, Ty};\n /// Checks for the `INEFFICIENT_TO_STRING` lint\n pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n-        if let Some(to_string_meth_did) = cx.tables().type_dependent_def_id(expr.hir_id);\n+        if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n-        if let Some(substs) = cx.tables().node_substs_opt(expr.hir_id);\n+        if let Some(substs) = cx.typeck_results().node_substs_opt(expr.hir_id);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;"}, {"sha": "40a625758616455c3d0e174c7a6fc747fca11cf7", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -11,7 +11,7 @@ pub fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];\n \n-    let ty = cx.tables().expr_ty(arith_lhs);\n+    let ty = cx.typeck_results().expr_ty(arith_lhs);\n     if !ty.is_integral() {\n         return;\n     }\n@@ -101,7 +101,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n         }\n     }\n \n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants"}, {"sha": "97cc58023f55e61d62d01d4685e139d909e55c28", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 65, "deletions": 54, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -1433,7 +1433,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n-                let self_ty = cx.tables().expr_ty_adjusted(&args[0]);\n+                let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.ident.name == sym!(clone) {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n@@ -1639,7 +1639,7 @@ fn lint_or_fun_call<'tcx>(\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n             let path = &*last_path_segment(qpath).ident.as_str();\n             if [\"default\", \"new\"].contains(&path);\n-            let arg_ty = cx.tables().expr_ty(arg);\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n             if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n             if implements_trait(cx, arg_ty, default_trait_id, &[]);\n \n@@ -1679,7 +1679,7 @@ fn lint_or_fun_call<'tcx>(\n     ) {\n         if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n-                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n \n                 match ty.kind {\n                     ty::Slice(_) | ty::Array(_, _) => return,\n@@ -1707,7 +1707,7 @@ fn lint_or_fun_call<'tcx>(\n             if { finder.visit_expr(&arg); finder.found };\n             if !contains_return(&arg);\n \n-            let self_ty = cx.tables().expr_ty(self_expr);\n+            let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n                 know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n@@ -1786,7 +1786,7 @@ fn lint_expect_fun_call(\n                     if call_args.len() == 1\n                         && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n                         && {\n-                            let arg_type = cx.tables().expr_ty(&call_args[0]);\n+                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n                             base_type.kind == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n                         }\n@@ -1805,7 +1805,7 @@ fn lint_expect_fun_call(\n     // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n-        let arg_ty = cx.tables().expr_ty(arg);\n+        let arg_ty = cx.typeck_results().expr_ty(arg);\n         if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n             return false;\n         }\n@@ -1835,15 +1835,16 @@ fn lint_expect_fun_call(\n                     false\n                 }\n             },\n-            hir::ExprKind::MethodCall(..) => cx\n-                .tables()\n-                .type_dependent_def_id(arg.hir_id)\n-                .map_or(false, |method_id| {\n-                    matches!(\n-                        cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n-                        ty::Ref(ty::ReStatic, ..)\n-                    )\n-                }),\n+            hir::ExprKind::MethodCall(..) => {\n+                cx.typeck_results()\n+                    .type_dependent_def_id(arg.hir_id)\n+                    .map_or(false, |method_id| {\n+                        matches!(\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n+                            ty::Ref(ty::ReStatic, ..)\n+                        )\n+                    })\n+            },\n             hir::ExprKind::Path(ref p) => matches!(\n                 cx.qpath_res(p, arg.hir_id),\n                 hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n@@ -1891,7 +1892,7 @@ fn lint_expect_fun_call(\n         return;\n     }\n \n-    let receiver_type = cx.tables().expr_ty_adjusted(&args[0]);\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n     let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n         \"||\"\n     } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n@@ -1957,7 +1958,7 @@ fn lint_expect_fun_call(\n \n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind {\n         if let ty::Ref(_, innermost, _) = inner.kind {\n             span_lint_and_then(\n@@ -2005,7 +2006,9 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     // &*x is a nop, &x.clone() is not\n                     hir::ExprKind::AddrOf(..) => return,\n                     // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => return,\n+                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n+                        return;\n+                    },\n \n                     _ => {},\n                 },\n@@ -2021,11 +2024,11 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n             }\n \n             // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.tables().expr_ty(arg) == ty {\n+            if cx.typeck_results().expr_ty(arg) == ty {\n                 snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n             } else {\n                 let deref_count = cx\n-                    .tables()\n+                    .typeck_results()\n                     .expr_adjustments(arg)\n                     .iter()\n                     .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n@@ -2045,7 +2048,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n }\n \n fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(arg));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.kind {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -2079,7 +2082,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n-        let self_ty = walk_ptrs_ty(cx.tables().expr_ty(target));\n+        let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(target));\n         let ref_str = if self_ty.kind == ty::Str {\n             \"\"\n         } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n@@ -2107,15 +2110,15 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n }\n \n fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n     if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n-        let source_type = cx.tables().expr_ty(source);\n+        let source_type = cx.typeck_results().expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n         if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n@@ -2135,8 +2138,8 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir:\n \n fn lint_iter_cloned_collect<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n-        if is_type_diagnostic_item(cx, cx.tables().expr_ty(expr), sym!(vec_type));\n-        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0]));\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym!(vec_type));\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n         then {\n@@ -2243,7 +2246,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args:\n \n fn lint_step_by<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &args[1]) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &args[1]) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,\n@@ -2267,7 +2270,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         parent_expr_opt = get_parent_expr(cx, parent_expr);\n     }\n \n-    if derefs_to_slice(cx, caller_expr, cx.tables().expr_ty(caller_expr)).is_some() {\n+    if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n         // caller is a Slice\n         if_chain! {\n             if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n@@ -2288,8 +2291,11 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n                 );\n             }\n         }\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(caller_expr), sym!(vec_type))\n-        || matches!(&walk_ptrs_ty(cx.tables().expr_ty(caller_expr)).kind, ty::Array(_, _))\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n+        || matches!(\n+            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind,\n+            ty::Array(_, _)\n+        )\n     {\n         // caller is a Vec or an Array\n         let mut applicability = Applicability::MachineApplicable;\n@@ -2316,11 +2322,11 @@ fn lint_iter_nth<'tcx>(\n ) {\n     let iter_args = nth_and_iter_args[1];\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables().expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(&iter_args[0]), sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vec_type)) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.tables().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n         \"VecDeque\"\n     } else {\n         let nth_args = nth_and_iter_args[0];\n@@ -2341,7 +2347,7 @@ fn lint_iter_nth<'tcx>(\n fn lint_iter_nth_zero<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n         if match_trait_method(cx, expr, &paths::ITERATOR);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.tables(), &nth_args[1]);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &nth_args[1]);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n@@ -2361,7 +2367,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n-    let expr_ty = cx.tables().expr_ty(&get_args[0]);\n+    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n     let get_args_str = if get_args.len() > 1 {\n         snippet_with_applicability(cx, get_args[1].span, \"_\", &mut applicability)\n     } else {\n@@ -2463,7 +2469,7 @@ fn derefs_to_slice<'tcx>(\n     }\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-        if path.ident.name == sym!(iter) && may_slice(cx, cx.tables().expr_ty(&args[0])) {\n+        if path.ident.name == sym!(iter) && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n             None\n@@ -2486,7 +2492,7 @@ fn derefs_to_slice<'tcx>(\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&unwrap_args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&unwrap_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))\n@@ -2514,7 +2520,7 @@ fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::E\n \n /// lint use of `expect()` for `Option`s and `Result`s\n fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&expect_args[0]));\n+    let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&expect_args[0]));\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))\n@@ -2540,8 +2546,8 @@ fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::E\n fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.tables().expr_ty(&ok_args[0]), sym!(result_type));\n-        let result_type = cx.tables().expr_ty(&ok_args[0]);\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym!(result_type));\n+        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n \n@@ -2579,7 +2585,7 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n         let msg = \"called `map(..).flatten()` on an `Option`. \\\n                     This is more succinctly expressed by calling `.and_then(..)`\";\n         let self_snippet = snippet(cx, map_args[0].span, \"..\");\n@@ -2605,8 +2611,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2656,8 +2662,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n-    let is_option = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_or_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(result_type));\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -3014,7 +3020,7 @@ fn lint_chars_cmp(\n         if segment.ident.name == sym!(Some);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = walk_ptrs_ty(cx.tables().expr_ty_adjusted(&args[0][0]));\n+            let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty_adjusted(&args[0][0]));\n \n             if self_ty.kind != ty::Str {\n                 return false;\n@@ -3142,8 +3148,8 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let recvr = &as_ref_args[0];\n-        let rcv_ty = cx.tables().expr_ty(recvr);\n-        let res_ty = cx.tables().expr_ty(expr);\n+        let rcv_ty = cx.typeck_results().expr_ty(recvr);\n+        let res_ty = cx.typeck_results().expr_ty(expr);\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n         let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n         if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n@@ -3212,7 +3218,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Ex\n         if args.is_empty();\n         if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.tables().expr_ty_adjusted(outer));\n+        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(outer));\n         then {\n             span_lint(\n                 cx,\n@@ -3254,7 +3260,7 @@ fn lint_option_as_ref_deref<'tcx>(\n ) {\n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n-    let option_ty = cx.tables().expr_ty(&as_ref_args[0]);\n+    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n     if !is_type_diagnostic_item(cx, option_ty, sym!(option_type)) {\n         return;\n     }\n@@ -3284,10 +3290,15 @@ fn lint_option_as_ref_deref<'tcx>(\n                         if let hir::ExprKind::Path(qpath) = &args[0].kind;\n                         if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, args[0].hir_id);\n                         if closure_body.params[0].pat.hir_id == local_id;\n-                        let adj = cx.tables().expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n+                        let adj = cx\n+                            .typeck_results()\n+                            .expr_adjustments(&args[0])\n+                            .iter()\n+                            .map(|x| &x.kind)\n+                            .collect::<Box<[_]>>();\n                         if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n                         then {\n-                            let method_did = cx.tables().type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n                             deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n                         } else {\n                             false\n@@ -3577,7 +3588,7 @@ fn contains_return(expr: &hir::Expr<'_>) -> bool {\n fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.tables().expr_ty(&args[0]).kind;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind;\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {\n@@ -3587,7 +3598,7 @@ fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir:\n }\n \n fn lint_filetype_is_file(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.tables().expr_ty(&args[0]);\n+    let ty = cx.typeck_results().expr_ty(&args[0]);\n \n     if !match_type(cx, ty, &paths::FILE_TYPE) {\n         return;"}, {"sha": "95fa28e1c0f75507fb99feb648e68347458f5a2d", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -20,8 +20,8 @@ pub(super) fn lint<'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.tables().expr_ty(&map_args[0]), sym!(option_type)) {\n-        if !is_copy(cx, cx.tables().expr_ty(&unwrap_args[1])) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n+        if !is_copy(cx, cx.typeck_results().expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument\n "}, {"sha": "dae39aaf5e2165e6ffa9e31e5f8ffc5ffd0062c4", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for MinMaxPass {\n                 }\n                 match (\n                     outer_max,\n-                    Constant::partial_cmp(cx.tcx, cx.tables().expr_ty(ie), &outer_c, &inner_c),\n+                    Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(ie), &outer_c, &inner_c),\n                 ) {\n                     (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n@@ -62,7 +62,7 @@ enum MinMax {\n fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if let ExprKind::Call(ref path, ref args) = expr.kind {\n         if let ExprKind::Path(ref qpath) = path.kind {\n-            cx.tables()\n+            cx.typeck_results()\n                 .qpath_res(qpath, path.hir_id)\n                 .opt_def_id()\n                 .and_then(|def_id| {\n@@ -86,10 +86,10 @@ fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Opt\n     if args.len() != 2 {\n         return None;\n     }\n-    constant_simple(cx, cx.tables(), &args[0]).map_or_else(\n-        || constant_simple(cx, cx.tables(), &args[1]).map(|c| (m, c, &args[0])),\n+    constant_simple(cx, cx.typeck_results(), &args[0]).map_or_else(\n+        || constant_simple(cx, cx.typeck_results(), &args[1]).map(|c| (m, c, &args[0])),\n         |c| {\n-            if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n+            if constant_simple(cx, cx.typeck_results(), &args[1]).is_none() {\n                 // otherwise ignore\n                 Some((m, c, &args[1]))\n             } else {"}, {"sha": "fc10e5077b8391c429a958d91fed858aab8f88f2", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -496,7 +496,7 @@ fn get_lint_and_message(\n fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n-        if let Some((value, _)) = constant(cx, cx.tables(), expr);\n+        if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n         then {\n             let needs_lint = match value {\n                 Constant::F32(num) => num.is_nan(),\n@@ -517,15 +517,15 @@ fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n }\n \n fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.tables(), expr) {\n+    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n         res\n     } else {\n         false\n     }\n }\n \n fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.tables(), expr) {\n+    match constant(cx, cx.typeck_results(), expr) {\n         Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n@@ -557,7 +557,7 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &walk_ptrs_ty(cx.tables().expr_ty(expr)).kind;\n+    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind;\n \n     if let ty::Array(arr_ty, _) = value {\n         return matches!(arr_ty.kind, ty::Float(_));\n@@ -567,7 +567,7 @@ fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&walk_ptrs_ty(cx.tables().expr_ty(expr)).kind, ty::Array(_, _))\n+    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n@@ -593,15 +593,15 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.typeck_results().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.typeck_results().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -612,7 +612,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n         _ => return,\n     };\n \n-    let other_ty = cx.tables().expr_ty(other);\n+    let other_ty = cx.typeck_results().expr_ty(other);\n \n     let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n     let with_deref = arg_ty"}, {"sha": "b1d788b5c683f4587cebc071623e2326e001160a", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -37,8 +37,8 @@ struct OperandInfo {\n }\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n-    match constant(cx, cx.tables(), operand) {\n-        Some((Constant::Int(v), _)) => match cx.tables().expr_ty(expr).kind {\n+    match constant(cx, cx.typeck_results(), operand) {\n+        Some((Constant::Int(v), _)) => match cx.typeck_results().expr_ty(expr).kind {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {\n@@ -106,7 +106,7 @@ fn check_const_operands<'tcx>(\n }\n \n fn check_non_const_operands<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, operand: &Expr<'_>) {\n-    let operand_type = cx.tables().expr_ty(operand);\n+    let operand_type = cx.typeck_results().expr_ty(operand);\n     if might_have_negative_value(operand_type) {\n         span_lint_and_then(\n             cx,"}, {"sha": "9f8f401cc0f67d4e869fb002e914d4bfa18f1d7d", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }\n-        check_ty(cx, local.span, cx.tables().pat_ty(&*local.pat));\n+        check_ty(cx, local.span, cx.typeck_results().pat_ty(&*local.pat));\n     }\n }\n "}, {"sha": "b02e86bca27195c2a39a7639176adee31fbf2368", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.tables().expr_ty(e).kind {\n+            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "b8dc5081632972827f9fc9203246dabc8649d096", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -37,14 +37,14 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                     check_arguments(\n                         cx,\n                         arguments,\n-                        cx.tables().expr_ty(fn_expr),\n+                        cx.typeck_results().expr_ty(fn_expr),\n                         &rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false)),\n                     );\n                 }\n             },\n             ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n-                let def_id = cx.tables().type_dependent_def_id(e.hir_id).unwrap();\n-                let substs = cx.tables().node_substs(e.hir_id);\n+                let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n+                let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n                 check_arguments(cx, arguments, method_type, &path.ident.as_str())\n             },"}, {"sha": "7f529f0404c00af727db852f1725efe0e3647569", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 return;\n             },\n             ExprKind::Path(_) => {\n-                if let Some(adj) = self.cx.tables().adjustments().get(expr.hir_id) {\n+                if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj\n                         .iter()\n                         .any(|a| matches!(a.target.kind, ty::Ref(_, _, Mutability::Mut)))"}, {"sha": "568898aa5c9b7773f4e0fb53679def984114065b", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -66,7 +66,7 @@ declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n \n impl<'tcx> LateLintPass<'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let ty = cx.tables().expr_ty(expr);\n+        let ty = cx.typeck_results().expr_ty(expr);\n         if let ty::Adt(_, subst) = ty.kind {\n             if is_type_diagnostic_item(cx, ty, sym!(mutex_type)) {\n                 let mutex_param = subst.type_at(0);"}, {"sha": "8e44f2ec2408c8807cc55d5889040346c3c65a76", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -229,7 +229,10 @@ fn check_comparison<'a, 'tcx>(\n     use self::Expression::{Bool, Other};\n \n     if let ExprKind::Binary(op, ref left_side, ref right_side) = e.kind {\n-        let (l_ty, r_ty) = (cx.tables().expr_ty(left_side), cx.tables().expr_ty(right_side));\n+        let (l_ty, r_ty) = (\n+            cx.typeck_results().expr_ty(left_side),\n+            cx.typeck_results().expr_ty(right_side),\n+        );\n         if l_ty.is_bool() && r_ty.is_bool() {\n             let mut applicability = Applicability::MachineApplicable;\n "}, {"sha": "415ab556c9fd4eb830e88f4a230fcc2296d59410", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -46,8 +46,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.tables().expr_ty(inner).kind {\n-                for adj3 in cx.tables().expr_adjustments(e).windows(3) {\n+            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind {\n+                for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n                     }, Adjustment {\n@@ -85,7 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = cx.tables().pat_ty(pat).kind;\n+            if let ty::Ref(_, tam, mutbl) = cx.typeck_results().pat_ty(pat).kind;\n             if mutbl == Mutability::Not;\n             if let ty::Ref(_, _, mutbl) = tam.kind;\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out"}, {"sha": "8118cb32cf28e7e136b4bd9331a95e5743a40f9e", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -134,7 +134,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         } = {\n             let mut ctx = MovedVariablesCtxt::default();\n             cx.tcx.infer_ctxt().enter(|infcx| {\n-                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.tables()).consume_body(body);\n+                euv::ExprUseVisitor::new(&mut ctx, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+                    .consume_body(body);\n             });\n             ctx\n         };"}, {"sha": "ce3f066eff5e7d5d6c8227563c818a826fc98ff1", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -47,7 +47,7 @@ declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n-            let ty = cx.tables().expr_ty(expr);\n+            let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint("}, {"sha": "95613a1b82ef0f32101c061c696730dabea56ea7", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n \n             then {\n \n-                let ty = cx.tables().expr_ty(left);\n+                let ty = cx.typeck_results().expr_ty(left);\n \n                 let implements_ord = {\n                     if let Some(id) = utils::get_trait_def_id(cx, &paths::ORD) {"}, {"sha": "6b6c950e0abee23231a72782d11db11e1771e9a7", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -44,8 +44,8 @@ impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n-        if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.tables().expr_ty_opt(lit));\n-        if cx.tables().expr_ty(exp).is_integral();\n+        if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.typeck_results().expr_ty_opt(lit));\n+        if cx.typeck_results().expr_ty(exp).is_integral();\n         then {\n             span_lint(cx, NEG_MULTIPLY, span, \"Negation by multiplying with `-1`\");\n         }"}, {"sha": "b1b5b3439a0e384e6335d7c40665fdcc631d8d73", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -48,7 +48,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n-        ExprKind::Path(..) => !has_drop(cx, cx.tables().expr_ty(expr)),\n+        ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n         ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n@@ -61,7 +61,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         | ExprKind::AddrOf(_, _, ref inner)\n         | ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            !has_drop(cx, cx.tables().expr_ty(expr))\n+            !has_drop(cx, cx.typeck_results().expr_ty(expr))\n                 && fields.iter().all(|field| has_no_effect(cx, &field.expr))\n                 && base.as_ref().map_or(true, |base| has_no_effect(cx, base))\n         },\n@@ -70,7 +70,8 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..) => {\n-                        !has_drop(cx, cx.tables().expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n+                        !has_drop(cx, cx.typeck_results().expr_ty(expr))\n+                            && args.iter().all(|arg| has_no_effect(cx, arg))\n                     },\n                     _ => false,\n                 }\n@@ -137,7 +138,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n         | ExprKind::AddrOf(_, _, ref inner)\n         | ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            if has_drop(cx, cx.tables().expr_ty(expr)) {\n+            if has_drop(cx, cx.typeck_results().expr_ty(expr)) {\n                 None\n             } else {\n                 Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n@@ -148,7 +149,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n-                        if !has_drop(cx, cx.tables().expr_ty(expr)) =>\n+                        if !has_drop(cx, cx.typeck_results().expr_ty(expr)) =>\n                     {\n                         Some(args.iter().collect())\n                     },"}, {"sha": "031d69e86a13edb2c7c5406127dcf67f6d6bd65d", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -237,13 +237,13 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             }\n \n             let ty = if needs_check_adjustment {\n-                let adjustments = cx.tables().expr_adjustments(dereferenced_expr);\n+                let adjustments = cx.typeck_results().expr_adjustments(dereferenced_expr);\n                 if let Some(i) = adjustments\n                     .iter()\n                     .position(|adj| matches!(adj.kind, Adjust::Borrow(_) | Adjust::Deref(_)))\n                 {\n                     if i == 0 {\n-                        cx.tables().expr_ty(dereferenced_expr)\n+                        cx.typeck_results().expr_ty(dereferenced_expr)\n                     } else {\n                         adjustments[i - 1].target\n                     }\n@@ -252,7 +252,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                     return;\n                 }\n             } else {\n-                cx.tables().expr_ty(dereferenced_expr)\n+                cx.typeck_results().expr_ty(dereferenced_expr)\n             };\n \n             verify_ty_bound(cx, ty, Source::Expr { expr: expr.span });"}, {"sha": "e99d0317ba2e8ca1b6e3bcf5744ec4071931c1da", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n-            let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n+            let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n@@ -58,7 +58,7 @@ enum OpenOption {\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n-        let obj_ty = walk_ptrs_ty(cx.tables().expr_ty(&arguments[0]));\n+        let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {"}, {"sha": "9494efe736cce2a37f7efafdf211b62a6e075214", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -72,7 +72,8 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n-        path.ident.name.to_ident_string() == \"ok\" && match_type(cx, &cx.tables().expr_ty(&receiver), &paths::RESULT)\n+        path.ident.name.to_ident_string() == \"ok\"\n+            && match_type(cx, &cx.typeck_results().expr_ty(&receiver), &paths::RESULT)\n     } else {\n         false\n     }"}, {"sha": "4d4a9676654826b36360539531c092a5b85de056", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -36,8 +36,8 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n             if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n             if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n-            if cx.tables().expr_ty(ident1).is_integral();\n-            if cx.tables().expr_ty(ident2).is_integral();\n+            if cx.typeck_results().expr_ty(ident1).is_integral();\n+            if cx.typeck_results().expr_ty(ident2).is_integral();\n             then {\n                 if let BinOpKind::Lt = op.node {\n                     if let BinOpKind::Add = op2.node {\n@@ -61,8 +61,8 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n             if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n             if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n-            if cx.tables().expr_ty(ident1).is_integral();\n-            if cx.tables().expr_ty(ident2).is_integral();\n+            if cx.typeck_results().expr_ty(ident1).is_integral();\n+            if cx.typeck_results().expr_ty(ident2).is_integral();\n             then {\n                 if let BinOpKind::Gt = op.node {\n                     if let BinOpKind::Add = op2.node {"}, {"sha": "66a145a7f14b39b2cd81eec5c976033afd5bc3a3", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n-            if match_type(cx, walk_ptrs_ty(cx.tables().expr_ty(&args[0])), &paths::PATH_BUF);\n+            if match_type(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0])), &paths::PATH_BUF);\n             if let Some(get_index_arg) = args.get(1);\n             if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n             if let LitKind::Str(ref path_lit, _) = lit.node;"}, {"sha": "ef26fc667b22591f7b0cba87600407a8081b2848", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n             if let Some(init) = &local.init {\n-                if let Some(init_ty) = cx.tables().node_type_opt(init.hir_id) {\n+                if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n                     let pat = &local.pat;\n                     if in_external_macro(cx.sess(), pat.span) {\n                         return;\n@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n             match source {\n                 MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n-                    if let Some(expr_ty) = cx.tables().node_type_opt(expr.hir_id) {\n+                    if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n                         'pattern_checks: for arm in arms {\n                             let pat = &arm.pat;\n                             if in_external_macro(cx.sess(), pat.span) {\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n         _: Span,\n         hir_id: HirId,\n     ) {\n-        if let Some(fn_sig) = cx.tables().liberated_fn_sigs().get(hir_id) {\n+        if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n             for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n                 apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n             }"}, {"sha": "0a2d1b5fbe6ac56b2fe0e1f27aecb0db8e5a71fa", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -105,12 +105,12 @@ fn expr_as_ptr_offset_call<'tcx>(\n \n // Is the type of the expression a usize?\n fn is_expr_ty_usize<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables().expr_ty(expr) == cx.tcx.types.usize\n+    cx.typeck_results().expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n fn is_expr_ty_raw_ptr<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables().expr_ty(expr).is_unsafe_ptr()\n+    cx.typeck_results().expr_ty(expr).is_unsafe_ptr()\n }\n \n fn build_suggestion<'tcx>("}, {"sha": "fb12c565afd863048bbcbc895f1abb4fbf36b082", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -135,13 +135,13 @@ impl QuestionMark {\n     }\n \n     fn moves_by_default(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.tables().expr_ty(expression);\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n \n         !expr_ty.is_copy_modulo_regions(cx.tcx.at(expression.span), cx.param_env)\n     }\n \n     fn is_option(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        let expr_ty = cx.tables().expr_ty(expression);\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n \n         is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n     }"}, {"sha": "4c1f2e8e01a8c9b485399aa994a8a1ada33ff8aa", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -280,10 +280,10 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n     if_chain! {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(cx, expr);\n-        let ty = cx.tables().expr_ty(start);\n+        let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind;\n-        if let Some((start_idx, _)) = constant(cx, cx.tables(), start);\n-        if let Some((end_idx, _)) = constant(cx, cx.tables(), end);\n+        if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);\n+        if let Some((end_idx, _)) = constant(cx, cx.typeck_results(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {"}, {"sha": "dfc158661cbf68cd0b6b2c9c1600077076d272f6", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -89,7 +89,7 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n }\n \n fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n-    constant(cx, cx.tables(), e).and_then(|(c, _)| match c {\n+    constant(cx, cx.typeck_results(), e).and_then(|(c, _)| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n     })"}, {"sha": "77c206002ea790684217a3cc6404b69d7a14b7b3", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -41,10 +41,10 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(repeat);\n-            if let Some(Constant::Int(1)) = constant_context(cx, cx.tables()).expr(&args[1]);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&args[1]);\n             if !in_macro(args[0].span);\n             then {\n-                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "6f03e92bde36fcb64a353e23ab731379f14c2ca7", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -164,7 +164,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n }\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n-    let var_ty = cx.tables().node_type_opt(pat_id);\n+    let var_ty = cx.typeck_results().node_type_opt(pat_id);\n     var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n }\n "}, {"sha": "bada6fa7c522fca28060f7544026edd753a53746", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.tables().expr_ty(e)), sym!(string_type))\n+    is_type_diagnostic_item(cx, walk_ptrs_ty(cx.typeck_results().expr_ty(e)), sym!(string_type))\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {"}, {"sha": "754f87e6b55e2585f9b79b4c7993e78b6049df21", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -194,7 +194,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                let ty = walk_ptrs_ty(cx.tables().expr_ty(lhs1));\n+                let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n                     || matches!(ty.kind, ty::Array(_, _))"}, {"sha": "6750452941f28a1b15dc11cb02e4ad301ed3b2bd", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n-                            let char_arg_ty = cx.tables().expr_ty_adjusted(char_arg);\n+                            let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n                             if char_arg_ty.kind == ty::Char;\n                             then {\n                                 Some((true, char_arg, radix_arg))"}, {"sha": "d55eb1a0c938702386e9b25e80447a0ffa4f10ed", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -302,8 +302,8 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);\n             then {\n-                let from_ty = cx.tables().expr_ty(&args[0]);\n-                let to_ty = cx.tables().expr_ty(e);\n+                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let to_ty = cx.typeck_results().expr_ty(e);\n \n                 match (&from_ty.kind, &to_ty.kind) {\n                     _ if from_ty == to_ty => span_lint("}, {"sha": "fbf7f0b2517ac19bea082525b49467bd2898add0", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n             then {\n \n                 // Catching transmute over constants that resolve to `null`.\n-                let mut const_eval_context = constant_context(cx, cx.tables());\n+                let mut const_eval_context = constant_context(cx, cx.typeck_results());\n                 if_chain! {\n                     if let ExprKind::Path(ref _qpath) = args[0].kind;\n                     let x = const_eval_context.expr(&args[0]);"}, {"sha": "d3b351f30ef7c9c0b4f8211fd711f01e8221e972", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let Some(return_type) = find_err_return_type(cx, &expr.kind);\n \n             then {\n-                let err_type = cx.tables().expr_ty(err_arg);\n+                let err_type = cx.typeck_results().expr_ty(err_arg);\n                 let origin_snippet = if err_arg.span.from_expansion() {\n                     snippet_with_macro_callsite(cx, err_arg.span, \"_\")\n                 } else {\n@@ -114,7 +114,7 @@ fn find_err_return_type_arm<'tcx>(cx: &LateContext<'tcx>, arm: &'tcx Arm<'_>) ->\n         if match_qpath(from_error_fn, &paths::TRY_FROM_ERROR);\n         if let Some(from_error_arg) = from_error_args.get(0);\n         then {\n-            Some(cx.tables().expr_ty(from_error_arg))\n+            Some(cx.typeck_results().expr_ty(from_error_arg))\n         } else {\n             None\n         }"}, {"sha": "c3dea44752133bf9d8a24fee5e402c427651ef76", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckTables};\n+use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -595,7 +595,7 @@ declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n impl<'tcx> LateLintPass<'tcx> for LetUnitValue {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n-            if is_unit(cx.tables().pat_ty(&local.pat)) {\n+            if is_unit(cx.typeck_results().pat_ty(&local.pat)) {\n                 if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                     return;\n                 }\n@@ -680,7 +680,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n                 if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n                     if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n                         let op = cmp.node;\n-                        if op.is_comparison() && is_unit(cx.tables().expr_ty(left)) {\n+                        if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n                             let result = match &*symbol.as_str() {\n                                 \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n                                 \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n@@ -704,7 +704,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitCmp {\n         }\n         if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n             let op = cmp.node;\n-            if op.is_comparison() && is_unit(cx.tables().expr_ty(left)) {\n+            if op.is_comparison() && is_unit(cx.typeck_results().expr_ty(left)) {\n                 let result = match op {\n                     BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n                     _ => \"false\",\n@@ -774,7 +774,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n                 let args_to_recover = args\n                     .iter()\n                     .filter(|arg| {\n-                        if is_unit(cx.tables().expr_ty(arg)) && !is_unit_literal(arg) {\n+                        if is_unit(cx.typeck_results().expr_ty(arg)) && !is_unit_literal(arg) {\n                             !matches!(&arg.kind, ExprKind::Match(.., MatchSource::TryDesugar))\n                         } else {\n                             false\n@@ -1232,7 +1232,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     }\n \n     // don't lint for positive constants\n-    let const_val = constant(cx, &cx.tables(), op);\n+    let const_val = constant(cx, &cx.typeck_results(), op);\n     if_chain! {\n         if let Some((const_val, _)) = const_val;\n         if let Constant::Int(n) = const_val;\n@@ -1398,7 +1398,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n         if let ExprKind::Cast(ref ex, _) = expr.kind {\n-            let (cast_from, cast_to) = (cx.tables().expr_ty(ex), cx.tables().expr_ty(expr));\n+            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n             if let ExprKind::Lit(ref lit) = ex.kind {\n                 if_chain! {\n@@ -1786,7 +1786,7 @@ impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n             if let ExprKind::Cast(e, _) = &expr.kind;\n             if let ExprKind::Lit(l) = &e.kind;\n             if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == cx.tables().expr_ty(expr).kind;\n+            if ty::Uint(UintTy::U8) == cx.typeck_results().expr_ty(expr).kind;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n@@ -1862,8 +1862,8 @@ enum AbsurdComparisonResult {\n \n fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let precast_ty = cx.tables().expr_ty(cast_exp);\n-        let cast_ty = cx.tables().expr_ty(expr);\n+        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n \n         return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n     }\n@@ -1883,7 +1883,7 @@ fn detect_absurd_comparison<'tcx>(\n \n     // absurd comparison only makes sense on primitive types\n     // primitive types don't implement comparison operators with each other\n-    if cx.tables().expr_ty(lhs) != cx.tables().expr_ty(rhs) {\n+    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n         return None;\n     }\n \n@@ -1921,9 +1921,9 @@ fn detect_absurd_comparison<'tcx>(\n fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     use crate::types::ExtremeType::{Maximum, Minimum};\n \n-    let ty = cx.tables().expr_ty(expr);\n+    let ty = cx.typeck_results().expr_ty(expr);\n \n-    let cv = constant(cx, cx.tables(), expr)?.0;\n+    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n \n     let which = match (&ty.kind, cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n@@ -2053,8 +2053,8 @@ impl Ord for FullInt {\n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let pre_cast_ty = cx.tables().expr_ty(cast_exp);\n-        let cast_ty = cx.tables().expr_ty(expr);\n+        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n         if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n             return None;\n@@ -2084,9 +2084,9 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n }\n \n fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.tables(), expr)?.0;\n+    let val = constant(cx, cx.typeck_results(), expr)?.0;\n     if let Constant::Int(const_int) = val {\n-        match cx.tables().expr_ty(expr).kind {\n+        match cx.typeck_results().expr_ty(expr).kind {\n             ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n             ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n@@ -2472,7 +2472,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n /// Looks for default-hasher-dependent constructors like `HashMap::new`.\n struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     target: &'b ImplicitHasherType<'tcx>,\n     suggestions: BTreeMap<Span, String>,\n }\n@@ -2481,7 +2481,7 @@ impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_tables: cx.maybe_typeck_tables(),\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n             target,\n             suggestions: BTreeMap::new(),\n         }\n@@ -2492,9 +2492,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n     type Map = Map<'tcx>;\n \n     fn visit_body(&mut self, body: &'tcx Body<'_>) {\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.cx.tcx.body_tables(body.id()));\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n         walk_body(self, body);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n@@ -2503,7 +2503,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n             then {\n-                if !TyS::same_type(self.target.ty(), self.maybe_typeck_tables.unwrap().expr_ty(e)) {\n+                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n                     return;\n                 }\n \n@@ -2589,7 +2589,7 @@ impl<'tcx> LateLintPass<'tcx> for RefToMut {\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.tables().node_type(e.hir_id).kind;\n+            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind;\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "ac6f3d125bb422a2734be9b31d21e39d4c04fed9", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -72,7 +72,7 @@ fn get_projection_pred<'tcx>(\n \n fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Vec<(usize, String)> {\n     let mut args_to_check = Vec::new();\n-    if let Some(def_id) = cx.tables().type_dependent_def_id(expr.hir_id) {\n+    if let Some(def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n         let fn_sig = cx.tcx.fn_sig(def_id);\n         let generics = cx.tcx.predicates_of(def_id);\n         let fn_mut_preds = get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().fn_mut_trait());\n@@ -110,7 +110,7 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Span, Option<Span>)> {\n     if_chain! {\n         if let ExprKind::Closure(_, _fn_decl, body_id, span, _) = arg.kind;\n-        if let ty::Closure(_def_id, substs) = &cx.tables().node_type(arg.hir_id).kind;\n+        if let ty::Closure(_def_id, substs) = &cx.typeck_results().node_type(arg.hir_id).kind;\n         let ret_ty = substs.as_closure().sig().output();\n         let ty = cx.tcx.erase_late_bound_regions(&ret_ty);\n         if ty.is_unit();"}, {"sha": "28b393b9f11f0b67a952af15e2909a6926e134df", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -65,14 +65,14 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            match cx.tables().expr_ty_adjusted(expr).kind {\n+            match cx.typeck_results().expr_ty_adjusted(expr).kind {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => ty.is_trait(),\n                 _ => false,\n             }\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            matches!(cx.tables().expr_ty(expr).kind, ty::FnDef(..))\n+            matches!(cx.typeck_results().expr_ty(expr).kind, ty::FnDef(..))\n         }\n \n         if_chain! {\n@@ -98,7 +98,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n             if match_def_path(cx, def_id, &paths::PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::RC_PTR_EQ) ||\n                 match_def_path(cx, def_id, &paths::ARC_PTR_EQ);\n-            let ty_param = cx.tables().node_substs(func.hir_id).type_at(0);\n+            let ty_param = cx.typeck_results().node_substs(func.hir_id).type_at(0);\n             if ty_param.is_trait();\n             then {\n                 span_lint_and_help(\n@@ -115,8 +115,8 @@ impl LateLintPass<'_> for UnnamedAddress {\n         if_chain! {\n             if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n             if is_comparison(binop.node);\n-            if cx.tables().expr_ty_adjusted(left).is_fn_ptr() &&\n-                cx.tables().expr_ty_adjusted(right).is_fn_ptr();\n+            if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr() &&\n+                cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();\n             if is_fn_def(cx, left) || is_fn_def(cx, right);\n             then {\n                 span_lint("}, {"sha": "59993d25bb4706b9b204729693ff0921cd0b5422", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -176,7 +176,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n-        if utils::match_type(cx, &cx.tables().expr_ty(vec), &paths::VEC);\n+        if utils::match_type(cx, &cx.typeck_results().expr_ty(vec), &paths::VEC);\n         if let closure_body = cx.tcx.hir().body(*closure_body_id);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},"}, {"sha": "f2bbde28c2abc81793b852069926c0a718e85342", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -114,7 +114,7 @@ fn collect_unwrap_info<'tcx>(\n         if_chain! {\n             if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n-            let ty = cx.tables().expr_ty(&args[0]);\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, &name) || is_relevant_result_call(cx, ty, &name);\n             then {"}, {"sha": "a48ad3185e9c2f440de3f95fd5bb0b9eb40e6ae8", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -63,8 +63,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n \n             ExprKind::MethodCall(ref name, .., ref args, _) => {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n-                    let a = cx.tables().expr_ty(e);\n-                    let b = cx.tables().expr_ty(&args[0]);\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n                     if TyS::same_type(a, b) {\n                         let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n                         span_lint_and_sugg(\n@@ -79,8 +79,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     }\n                 }\n                 if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n-                    let a = cx.tables().expr_ty(e);\n-                    let b = cx.tables().expr_ty(&args[0]);\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n                     if TyS::same_type(a, b) {\n                         let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n                         span_lint_and_sugg(\n@@ -96,8 +96,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n                 if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\" {\n                     if_chain! {\n-                        let a = cx.tables().expr_ty(e);\n-                        let b = cx.tables().expr_ty(&args[0]);\n+                        let a = cx.typeck_results().expr_ty(e);\n+                        let b = cx.typeck_results().expr_ty(&args[0]);\n                         if is_type_diagnostic_item(cx, a, sym!(result_type));\n                         if let ty::Adt(_, substs) = a.kind;\n                         if let Some(a_type) = substs.types().next();\n@@ -122,8 +122,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;\n                     if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-                    let a = cx.tables().expr_ty(e);\n-                    let b = cx.tables().expr_ty(&args[0]);\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n \n                     then {\n                         if_chain! {"}, {"sha": "f81a132c7e7b4748d82dfab656c71170de8ec78d", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -56,7 +56,7 @@ pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Optio\n         Some(expr)\n     }\n \n-    let def_path = match cx.tables().expr_ty(expr).kind {\n+    let def_path = match cx.typeck_results().expr_ty(expr).kind {\n         ty::Adt(def, _) => cx.tcx.def_path(def.did),\n         _ => return None,\n     };"}, {"sha": "28fb6ed12a05ac90e0616be3af474a5b344b436d", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n-use rustc_middle::ty::TypeckTables;\n+use rustc_middle::ty::TypeckResults;\n use rustc_span::Symbol;\n use std::hash::Hash;\n \n@@ -22,7 +22,7 @@ use std::hash::Hash;\n pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     /// If is true, never consider as equal expressions containing function\n     /// calls.\n     ignore_fn: bool,\n@@ -32,7 +32,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_tables: cx.maybe_typeck_tables(),\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n             ignore_fn: false,\n         }\n     }\n@@ -71,10 +71,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             return false;\n         }\n \n-        if let Some(tables) = self.maybe_typeck_tables {\n+        if let Some(typeck_results) = self.maybe_typeck_results {\n             if let (Some(l), Some(r)) = (\n-                constant_simple(self.cx, tables, left),\n-                constant_simple(self.cx, tables, right),\n+                constant_simple(self.cx, typeck_results, left),\n+                constant_simple(self.cx, typeck_results, right),\n             ) {\n                 if l == r {\n                     return true;\n@@ -137,9 +137,9 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n@@ -272,18 +272,18 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let old_maybe_typeck_tables = self.maybe_typeck_tables;\n+                let old_maybe_typeck_results = self.maybe_typeck_results;\n \n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n-                self.maybe_typeck_tables = Some(self.cx.tcx.body_tables(ll_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n+                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n \n-                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n-                self.maybe_typeck_tables = Some(self.cx.tcx.body_tables(rl_id.body));\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n+                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 let eq_ty = self.eq_ty(lt, rt);\n-                self.maybe_typeck_tables = old_maybe_typeck_tables;\n+                self.maybe_typeck_results = old_maybe_typeck_results;\n                 eq_ty && ll == rl\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n@@ -348,15 +348,15 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n pub struct SpanlessHash<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_tables: Option<&'tcx TypeckTables<'tcx>>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     s: StableHasher,\n }\n \n impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_tables: cx.maybe_typeck_tables(),\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n             s: StableHasher::new(),\n         }\n     }\n@@ -386,8 +386,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n     pub fn hash_expr(&mut self, e: &Expr<'_>) {\n         let simple_const = self\n-            .maybe_typeck_tables\n-            .and_then(|tables| constant_simple(self.cx, tables, e));\n+            .maybe_typeck_results\n+            .and_then(|typeck_results| constant_simple(self.cx, typeck_results, e));\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n         // discriminant depending on which path we're choosing next\n@@ -458,7 +458,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     CaptureBy::Ref => 1,\n                 }\n                 .hash(&mut self.s);\n-                // closures inherit TypeckTables\n+                // closures inherit TypeckResults\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n             ExprKind::Field(ref e, ref f) => {\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(path.ident.name);\n             },\n         }\n-        // self.maybe_typeck_tables.unwrap().qpath_res(p, id).hash(&mut self.s);\n+        // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n     pub fn hash_path(&mut self, p: &Path<'_>) {\n@@ -725,10 +725,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_body(&mut self, body_id: BodyId) {\n-        // swap out TypeckTables when hashing a body\n-        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.cx.tcx.body_tables(body_id));\n+        // swap out TypeckResults when hashing a body\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body_id));\n         self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n-        self.maybe_typeck_tables = old_maybe_typeck_tables;\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {"}, {"sha": "d8fa1fa278e296b8cc9c18cbb6483a88f224d706", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n         }\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n-                println!(\"local variable of type {}\", cx.tables().node_type(local.hir_id));\n+                println!(\"local variable of type {}\", cx.typeck_results().node_type(local.hir_id));\n                 println!(\"pattern:\");\n                 print_pat(cx, &local.pat, 0);\n                 if let Some(ref e) = local.init {\n@@ -144,8 +144,12 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n-    println!(\"{}ty: {}\", ind, cx.tables().expr_ty(expr));\n-    println!(\"{}adjustments: {:?}\", ind, cx.tables().adjustments().get(expr.hir_id));\n+    println!(\"{}ty: {}\", ind, cx.typeck_results().expr_ty(expr));\n+    println!(\n+        \"{}adjustments: {:?}\",\n+        ind,\n+        cx.typeck_results().adjustments().get(expr.hir_id)\n+    );\n     match expr.kind {\n         hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);"}, {"sha": "6c2356799142db6b609fb6c2a77be4c00f8266a2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -405,7 +405,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n-            let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+            let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n             if match_type(cx, ty, &paths::EARLY_CONTEXT)\n                 || match_type(cx, ty, &paths::LATE_CONTEXT);\n             then {\n@@ -438,7 +438,7 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n             let args = arg_lists[1];\n             if args.len() == 1;\n             let self_arg = &args[0];\n-            let self_ty = walk_ptrs_ty(cx.tables().expr_ty(self_arg));\n+            let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(self_arg));\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {\n                 span_lint_and_sugg("}, {"sha": "4b163fba52890a7aa341940f30d61198f732db94", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -144,7 +144,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n-    let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n+    let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n@@ -278,10 +278,8 @@ pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -\n     match qpath {\n         hir::QPath::Resolved(_, path) => path.res,\n         hir::QPath::TypeRelative(..) => {\n-            if cx.tcx.has_typeck_tables(id.owner.to_def_id()) {\n-                cx.tcx\n-                    .typeck_tables_of(id.owner.to_def_id().expect_local())\n-                    .qpath_res(qpath, id)\n+            if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n+                cx.tcx.typeck(id.owner.to_def_id().expect_local()).qpath_res(qpath, id)\n             } else {\n                 Res::Err\n             }\n@@ -772,7 +770,7 @@ pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool\n     let parent_item = map.get_parent_item(e.hir_id);\n     if let Some((Constant::Int(v), _)) = map\n         .maybe_body_owned_by(parent_item)\n-        .and_then(|body_id| constant(cx, cx.tcx.body_tables(body_id), e))\n+        .and_then(|body_id| constant(cx, cx.tcx.typeck_body(body_id), e))\n     {\n         value == v\n     } else {\n@@ -799,7 +797,7 @@ pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n /// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n /// information on adjustments and coercions.\n pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    cx.tables().adjustments().get(e.hir_id).is_some()\n+    cx.typeck_results().adjustments().get(e.hir_id).is_some()\n }\n \n /// Returns the pre-expansion span if is this comes from an expansion of the\n@@ -916,7 +914,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.tables().node_type(pat.hir_id).kind {\n+            match &cx.typeck_results().node_type(pat.hir_id).kind {\n                 ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n                     !head.is_empty() || middle.is_none() || !tail.is_empty()\n@@ -1299,7 +1297,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 None\n             }\n         },\n-        ExprKind::MethodCall(_, _, _, _) => cx.tables().type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n         _ => None,\n     };\n \n@@ -1359,14 +1357,14 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n /// Returns the `DefId` of the callee if the given expression is a function or method call.\n pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n     match &expr.kind {\n-        ExprKind::MethodCall(..) => cx.tables().type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n         ExprKind::Call(\n             Expr {\n                 kind: ExprKind::Path(qpath),\n                 ..\n             },\n             ..,\n-        ) => cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id(),\n+        ) => cx.typeck_results().qpath_res(qpath, expr.hir_id).opt_def_id(),\n         _ => None,\n     }\n }"}, {"sha": "4a64b935ac9b4c4c4ef5ec09b9a89934e5c382e1", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -18,7 +18,14 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n     };\n     let def_id = expr.hir_id.owner.to_def_id();\n     cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut delegate, &infcx, def_id.expect_local(), cx.param_env, cx.tables()).walk_expr(expr);\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            def_id.expect_local(),\n+            cx.param_env,\n+            cx.typeck_results(),\n+        )\n+        .walk_expr(expr);\n     });\n \n     if delegate.skip {"}, {"sha": "f2e76442a19bae5775d72f5343183bf10ac4066f", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.tables().expr_ty_adjusted(expr).kind;\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind;\n             if let ty::Slice(..) = ty.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n@@ -50,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let Some((_, arg, _)) = higher::for_loop(expr);\n             if let Some(vec_args) = higher::vec_macro(cx, arg);\n-            if is_copy(cx, vec_type(cx.tables().expr_ty_adjusted(arg)));\n+            if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`\n                 let span = arg.span\n@@ -70,7 +70,7 @@ fn check_vec_macro<'tcx>(cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx\n     let mut applicability = Applicability::MachineApplicable;\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, cx.tables(), len).is_some() {\n+            if constant(cx, cx.typeck_results(), len).is_some() {\n                 format!(\n                     \"&[{}; {}]\",\n                     snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),"}, {"sha": "58e7c354b27da1e2ab90ec3d74f3028fe891008c", "filename": "clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n-            if let Some(method_def_id) = cx.tables().type_dependent_def_id(expr.hir_id);\n+            if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = args[2].kind;"}, {"sha": "32574d9d6c9a821fcf0f5db89339ba81e4829908", "filename": "clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -62,7 +62,7 @@ fn is_file_read_to_end<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) ->\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_end\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.tables().expr_ty(&exprs[0]);\n+        let ty = cx.typeck_results().expr_ty(&exprs[0]);\n         if match_type(cx, ty, &paths::FILE);\n         then {\n             return true\n@@ -76,7 +76,7 @@ fn is_file_read_to_string<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>)\n         if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_string\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n-        let ty = cx.tables().expr_ty(&exprs[0]);\n+        let ty = cx.typeck_results().expr_ty(&exprs[0]);\n         if match_type(cx, ty, &paths::FILE);\n         then {\n             return true"}, {"sha": "4b81a27632d8d03df056ef17a1a48b79b7f39bed", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -36,8 +36,8 @@ impl<'tcx> LateLintPass<'tcx> for ZeroDiv {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            if let Some(lhs_value) = constant_simple(cx, cx.tables(), left);\n-            if let Some(rhs_value) = constant_simple(cx, cx.tables(), right);\n+            if let Some(lhs_value) = constant_simple(cx, cx.typeck_results(), left);\n+            if let Some(rhs_value) = constant_simple(cx, cx.typeck_results(), right);\n             if Constant::F32(0.0) == lhs_value || Constant::F64(0.0) == lhs_value;\n             if Constant::F32(0.0) == rhs_value || Constant::F64(0.0) == rhs_value;\n             then {"}, {"sha": "9dd4c8a5f7a703b935629d733e7b1cfa0735b8e7", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/799eef691969c2f6ecf33359f0b1e1691a060648/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/799eef691969c2f6ecf33359f0b1e1691a060648/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=799eef691969c2f6ecf33359f0b1e1691a060648", "patch": "@@ -23,15 +23,15 @@ Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for ex\n - is it a primitive type?\n - does it implement a trait?\n \n-This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckTables`][TypeckTables] struct,\n+This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n that gives you access to the underlying structure [`TyS`][TyS].\n \n Example of use:\n ```rust\n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         // Get type of `expr`\n-        let ty = cx.tables().expr_ty(expr);\n+        let ty = cx.typeck_results().expr_ty(expr);\n         // Match its kind to enter its type\n         match ty.kind {\n             ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n@@ -41,14 +41,14 @@ impl LateLintPass<'_> for MyStructLint {\n }\n ```\n \n-Similarly in [`TypeckTables`][TypeckTables] methods, you have the [`pat_ty()`][pat_ty] method\n+Similarly in [`TypeckResults`][TypeckResults] methods, you have the [`pat_ty()`][pat_ty] method\n to retrieve a type from a pattern.\n \n Two noticeable items here:\n - `cx` is the lint context [`LateContext`][LateContext].\n   The two most useful data structures in this context are `tcx` and `tables`,\n   allowing us to jump to type definitions and other compilation stages such as HIR.\n-- `tables` is [`TypeckTables`][TypeckTables] and is created by type checking step,\n+- `tables` is [`TypeckResults`][TypeckResults] and is created by type checking step,\n   it includes useful information such as types of expressions, ways to resolve methods and so on.\n \n # Checking if an expr is calling a specific method\n@@ -87,7 +87,7 @@ impl LateLintPass<'_> for MyStructLint {\n         }\n \n         // 2. Using type context `TyCtxt`\n-        let ty = cx.tables().expr_ty(expr);\n+        let ty = cx.typeck_results().expr_ty(expr);\n         if cx.tcx.lang_items()\n             // we are looking for the `DefId` of `Drop` trait in lang items\n             .drop_trait()\n@@ -192,9 +192,9 @@ assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n \n [TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n [TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n-[TypeckTables]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html\n-[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckTables.html#method.expr_ty\n+[TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n+[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n [LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n [TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n-[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckTables.html#method.pat_ty\n+[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n [paths]: ../clippy_lints/src/utils/paths.rs"}]}