{"sha": "fbc1d91f79eefa3a54f06288073186ff8e017f16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzFkOTFmNzllZWZhM2E1NGYwNjI4ODA3MzE4NmZmOGUwMTdmMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-18T08:10:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-18T08:10:29Z"}, "message": "Auto merge of #1004 - JohnTitor:use-memory, r=RalfJung\n\nUse memory field instead of memory()\n\nRustup for rust-lang/rust#65319", "tree": {"sha": "efed309520fa4c2e1876dccbe64ec6ba6067d213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efed309520fa4c2e1876dccbe64ec6ba6067d213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc1d91f79eefa3a54f06288073186ff8e017f16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc1d91f79eefa3a54f06288073186ff8e017f16", "html_url": "https://github.com/rust-lang/rust/commit/fbc1d91f79eefa3a54f06288073186ff8e017f16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc1d91f79eefa3a54f06288073186ff8e017f16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "089c7e82596abdbc0fd5f21fee9e9438b453ec65", "url": "https://api.github.com/repos/rust-lang/rust/commits/089c7e82596abdbc0fd5f21fee9e9438b453ec65", "html_url": "https://github.com/rust-lang/rust/commit/089c7e82596abdbc0fd5f21fee9e9438b453ec65"}, {"sha": "17449fbce6da59668987bc8527ea6f84f038dd0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/17449fbce6da59668987bc8527ea6f84f038dd0c", "html_url": "https://github.com/rust-lang/rust/commit/17449fbce6da59668987bc8527ea6f84f038dd0c"}], "stats": {"total": 146, "additions": 73, "deletions": 73}, "files": [{"sha": "0f59c13723c7dc5f129899b6b5c42f96bcf9f81b", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -1 +1 @@\n-d28a9c38fe14396e86ae274c7847e20ee0f78ca9\n+fa0f7d0080d8e7e9eb20aa9cbf8013f96c81287f"}, {"sha": "77bc096e31983c8a4d8035bf6ba4b0bcfe653fba", "filename": "src/eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -93,7 +93,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n \n     // First argument: pointer to `main()`.\n     let main_ptr = ecx\n-        .memory_mut()\n+        .memory\n         .create_fn_alloc(FnVal::Instance(main_instance));\n     let dest = ecx.local_place(args.next().unwrap())?;\n     ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n@@ -128,7 +128,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         let mut arg = arg.into_bytes();\n         arg.push(0);\n         argvs.push(\n-            ecx.memory_mut()\n+            ecx.memory\n                 .allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()),\n         );\n     }\n@@ -142,7 +142,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         let place = ecx.mplace_field(argvs_place, idx as u64)?;\n         ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n     }\n-    ecx.memory_mut()\n+    ecx.memory\n         .mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n     // Write a pointer to that place as the argument.\n     let argv = argvs_place.ptr;\n@@ -157,15 +157,15 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     {\n         let tcx = &{ ecx.tcx.tcx };\n         let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n-        let cmd_ptr = ecx.memory_mut().allocate(\n+        let cmd_ptr = ecx.memory.allocate(\n             Size::from_bytes(cmd_utf16.len() as u64 * 2),\n             Align::from_bytes(2).unwrap(),\n             MiriMemoryKind::Env.into(),\n         );\n         ecx.machine.cmd_line = Some(cmd_ptr);\n         // Store the UTF-16 string.\n         let char_size = Size::from_bytes(2);\n-        let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n+        let cmd_alloc = ecx.memory.get_mut(cmd_ptr.alloc_id)?;\n         let mut cur_ptr = cmd_ptr;\n         for &c in cmd_utf16.iter() {\n             cmd_alloc.write_scalar(\n@@ -211,7 +211,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) {\n     // Process the result.\n     match res {\n         Ok(()) => {\n-            let leaks = ecx.memory().leak_report();\n+            let leaks = ecx.memory.leak_report();\n             // Disable the leak test on some platforms where we do not\n             // correctly implement TLS destructors.\n             let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();"}, {"sha": "08e28e909ab28e760d43cd2509ca17db3f83e283", "filename": "src/helpers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -57,7 +57,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Test if this immediate equals 0.\n     fn is_null(&self, val: Scalar<Tag>) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_ref();\n-        let null = Scalar::from_int(0, this.memory().pointer_size());\n+        let null = Scalar::from_int(0, this.memory.pointer_size());\n         this.ptr_eq(val, null)\n     }\n \n@@ -94,7 +94,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let this = self.eval_context_mut();\n \n-        let ptr = this.memory().check_ptr_access(\n+        let ptr = this.memory.check_ptr_access(\n             ptr,\n             Size::from_bytes(len as u64),\n             Align::from_bytes(1).unwrap()\n@@ -108,12 +108,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 .map_err(|err| err_unsup_format!(\"getrandom failed: {}\", err))?;\n         }\n         else {\n-            let rng = this.memory_mut().extra.rng.get_mut();\n+            let rng = this.memory.extra.rng.get_mut();\n             rng.fill_bytes(&mut data);\n         }\n \n         let tcx = &{this.tcx.tcx};\n-        this.memory_mut().get_mut(ptr.alloc_id)?.write_bytes(tcx, ptr, &data)\n+        this.memory.get_mut(ptr.alloc_id)?.write_bytes(tcx, ptr, &data)\n     }\n \n     /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter"}, {"sha": "d20346ba468a1dfc9268bb85f723a5b0c4b8dd08", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -164,7 +164,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.memory().extra.validate\n+        ecx.memory.extra.validate\n     }\n \n     #[inline(always)]\n@@ -349,7 +349,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn stack_push(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n+        Ok(ecx.memory.extra.stacked_borrows.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n@@ -358,7 +358,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n         Ok(ecx\n-            .memory()\n+            .memory\n             .extra\n             .stacked_borrows\n             .borrow_mut()"}, {"sha": "9c02c56fd6a1ade2ad7ac37097253f17a2157b1f", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -34,7 +34,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     /// Test if the pointer is in-bounds of a live allocation.\n     #[inline]\n     fn pointer_inbounds(&self, ptr: Pointer<Tag>) -> InterpResult<'tcx> {\n-        let (size, _align) = self.memory().get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n+        let (size, _align) = self.memory.get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n         ptr.check_inbounds_alloc(size, CheckInAllocMsg::InboundsTest)\n     }\n "}, {"sha": "bd9263d8bf2b7953655f22cbd520b3ff26d6e7f8", "filename": "src/shims/env.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -26,7 +26,7 @@ impl EnvVars {\n             for (name, value) in env::vars() {\n                 if !excluded_env_vars.contains(&name) {\n                     let var_ptr =\n-                        alloc_env_var(name.as_bytes(), value.as_bytes(), ecx.memory_mut());\n+                        alloc_env_var(name.as_bytes(), value.as_bytes(), &mut ecx.memory);\n                     ecx.machine.env_vars.map.insert(name.into_bytes(), var_ptr);\n                 }\n             }\n@@ -52,7 +52,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n-        let name = this.memory().read_c_str(name_ptr)?;\n+        let name = this.memory.read_c_str(name_ptr)?;\n         Ok(match this.machine.env_vars.map.get(name) {\n             // The offset is used to strip the \"{name}=\" part of the string.\n             Some(var_ptr) => {\n@@ -71,18 +71,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n         let value_ptr = this.read_scalar(value_op)?.not_undef()?;\n-        let value = this.memory().read_c_str(value_ptr)?;\n+        let value = this.memory.read_c_str(value_ptr)?;\n         let mut new = None;\n         if !this.is_null(name_ptr)? {\n-            let name = this.memory().read_c_str(name_ptr)?;\n+            let name = this.memory.read_c_str(name_ptr)?;\n             if !name.is_empty() && !name.contains(&b'=') {\n                 new = Some((name.to_owned(), value.to_owned()));\n             }\n         }\n         if let Some((name, value)) = new {\n-            let var_ptr = alloc_env_var(&name, &value, this.memory_mut());\n+            let var_ptr = alloc_env_var(&name, &value, &mut this.memory);\n             if let Some(var) = this.machine.env_vars.map.insert(name.to_owned(), var_ptr) {\n-                this.memory_mut()\n+                this.memory\n                     .deallocate(var, None, MiriMemoryKind::Env.into())?;\n             }\n             Ok(0)\n@@ -97,14 +97,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let name_ptr = this.read_scalar(name_op)?.not_undef()?;\n         let mut success = None;\n         if !this.is_null(name_ptr)? {\n-            let name = this.memory().read_c_str(name_ptr)?.to_owned();\n+            let name = this.memory.read_c_str(name_ptr)?.to_owned();\n             if !name.is_empty() && !name.contains(&b'=') {\n                 success = Some(this.machine.env_vars.map.remove(&name));\n             }\n         }\n         if let Some(old) = success {\n             if let Some(var) = old {\n-                this.memory_mut()\n+                this.memory\n                     .deallocate(var, None, MiriMemoryKind::Env.into())?;\n             }\n             Ok(0)\n@@ -140,7 +140,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // This is ok because the buffer was strictly larger than `bytes`, so after\n                     // adding the null terminator, the buffer size is larger or equal to\n                     // `bytes.len()`, meaning that `bytes` actually fit inside tbe buffer.\n-                    this.memory_mut()\n+                    this.memory\n                         .get_mut(buf.alloc_id)?\n                         .write_bytes(tcx, buf, &bytes)?;\n                     return Ok(Scalar::Ptr(buf));\n@@ -159,7 +159,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"chdir\")?;\n \n         let path_bytes = this\n-            .memory()\n+            .memory\n             .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let path = Path::new("}, {"sha": "563acde00e1e13466713caacaf590aca6f579504", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -48,11 +48,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else {\n             let align = this.min_align(size, kind);\n             let ptr = this\n-                .memory_mut()\n+                .memory\n                 .allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n                 // We just allocated this, the access cannot fail\n-                this.memory_mut()\n+                this.memory\n                     .get_mut(ptr.alloc_id)\n                     .unwrap()\n                     .write_repeat(tcx, ptr, 0, Size::from_bytes(size))\n@@ -66,7 +66,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         if !this.is_null(ptr)? {\n             let ptr = this.force_ptr(ptr)?;\n-            this.memory_mut().deallocate(ptr, None, kind.into())?;\n+            this.memory.deallocate(ptr, None, kind.into())?;\n         }\n         Ok(())\n     }\n@@ -84,13 +84,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr =\n-                    this.memory_mut()\n+                    this.memory\n                         .allocate(Size::from_bytes(new_size), new_align, kind.into());\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n         } else {\n             let old_ptr = this.force_ptr(old_ptr)?;\n-            let memory = this.memory_mut();\n+            let memory = &mut this.memory;\n             if new_size == 0 {\n                 memory.deallocate(old_ptr, None, kind.into())?;\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n@@ -179,7 +179,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if size == 0 {\n                     this.write_null(ret.into())?;\n                 } else {\n-                    let ptr = this.memory_mut().allocate(\n+                    let ptr = this.memory.allocate(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::C.into(),\n@@ -208,7 +208,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = this.memory_mut().allocate(\n+                let ptr = this.memory.allocate(\n                     Size::from_bytes(size),\n                     Align::from_bytes(align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n@@ -224,13 +224,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = this.memory_mut().allocate(\n+                let ptr = this.memory.allocate(\n                     Size::from_bytes(size),\n                     Align::from_bytes(align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 );\n                 // We just allocated this, the access cannot fail\n-                this.memory_mut()\n+                this.memory\n                     .get_mut(ptr.alloc_id)\n                     .unwrap()\n                     .write_repeat(tcx, ptr, 0, Size::from_bytes(size))\n@@ -248,7 +248,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = this.force_ptr(ptr)?;\n-                this.memory_mut().deallocate(\n+                this.memory.deallocate(\n                     ptr,\n                     Some((\n                         Size::from_bytes(old_size),\n@@ -269,7 +269,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let align = Align::from_bytes(align).unwrap();\n-                let new_ptr = this.memory_mut().reallocate(\n+                let new_ptr = this.memory.reallocate(\n                     ptr,\n                     Some((Size::from_bytes(old_size), align)),\n                     Size::from_bytes(new_size),\n@@ -304,11 +304,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"dlsym\" => {\n                 let _handle = this.read_scalar(args[0])?;\n                 let symbol = this.read_scalar(args[1])?.not_undef()?;\n-                let symbol_name = this.memory().read_c_str(symbol)?;\n+                let symbol_name = this.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 if let Some(dlsym) = Dlsym::from_str(symbol_name)? {\n-                    let ptr = this.memory_mut().create_fn_alloc(FnVal::Other(dlsym));\n+                    let ptr = this.memory.create_fn_alloc(FnVal::Other(dlsym));\n                     this.write_scalar(Scalar::from(ptr), dest)?;\n                 } else {\n                     this.write_null(dest)?;\n@@ -325,7 +325,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // We abort on panic, so not much is going on here, but we still have to call the closure.\n                 let f = this.read_scalar(args[0])?.not_undef()?;\n                 let data = this.read_scalar(args[1])?.not_undef()?;\n-                let f_instance = this.memory().get_fn(f)?.as_instance()?;\n+                let f_instance = this.memory.get_fn(f)?.as_instance()?;\n                 this.write_null(dest)?;\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n@@ -369,8 +369,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let n = Size::from_bytes(this.read_scalar(args[2])?.to_usize(this)?);\n \n                 let result = {\n-                    let left_bytes = this.memory().read_bytes(left, n)?;\n-                    let right_bytes = this.memory().read_bytes(right, n)?;\n+                    let left_bytes = this.memory.read_bytes(left, n)?;\n+                    let right_bytes = this.memory.read_bytes(right, n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -388,7 +388,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n                 let num = this.read_scalar(args[2])?.to_usize(this)?;\n                 if let Some(idx) = this\n-                    .memory()\n+                    .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n                     .iter()\n                     .rev()\n@@ -406,7 +406,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n                 let num = this.read_scalar(args[2])?.to_usize(this)?;\n                 let idx = this\n-                    .memory()\n+                    .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n                     .iter()\n                     .position(|&c| c == val);\n@@ -477,7 +477,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = this.memory().read_bytes(buf, Size::from_bytes(n))?;\n+                    let buf_cont = this.memory.read_bytes(buf, Size::from_bytes(n))?;\n                     // We need to flush to make sure this actually appears on the screen\n                     let res = if fd == 1 {\n                         // Stdout is buffered, flush to make sure it appears on the screen.\n@@ -519,7 +519,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             \"strlen\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let n = this.memory().read_c_str(ptr)?.len();\n+                let n = this.memory.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -649,7 +649,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n                 let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n-                    Some(dtor_ptr) => Some(this.memory().get_fn(dtor_ptr)?.as_instance()?),\n+                    Some(dtor_ptr) => Some(this.memory.get_fn(dtor_ptr)?.as_instance()?),\n                     None => None,\n                 };\n \n@@ -671,10 +671,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n \n                 let key_ptr = this\n-                    .memory()\n+                    .memory\n                     .check_ptr_access(key_ptr, key_layout.size, key_layout.align.abi)?\n                     .expect(\"cannot be a ZST\");\n-                this.memory_mut().get_mut(key_ptr.alloc_id)?.write_scalar(\n+                this.memory.get_mut(key_ptr.alloc_id)?.write_scalar(\n                     tcx,\n                     key_ptr,\n                     Scalar::from_uint(key, key_layout.size).into(),\n@@ -859,13 +859,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .check_mplace_access(system_info, None)?\n                     .expect(\"cannot be a ZST\");\n                 // Initialize with `0`.\n-                this.memory_mut()\n+                this.memory\n                     .get_mut(system_info_ptr.alloc_id)?\n                     .write_repeat(tcx, system_info_ptr, 0, system_info.layout.size)?;\n                 // Set number of processors.\n                 let dword_size = Size::from_bytes(4);\n                 let offset = 2 * dword_size + 3 * tcx.pointer_size();\n-                this.memory_mut()\n+                this.memory\n                     .get_mut(system_info_ptr.alloc_id)?\n                     .write_scalar(\n                         tcx,\n@@ -920,7 +920,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     use std::io::{self, Write};\n \n                     let buf_cont = this\n-                        .memory()\n+                        .memory\n                         .read_bytes(buf, Size::from_bytes(u64::from(n)))?;\n                     let res = if handle == -11 {\n                         io::stdout().write(buf_cont)\n@@ -995,7 +995,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let tcx = &{ this.tcx.tcx };\n         let errno_ptr = this.machine.last_error.unwrap();\n-        this.memory_mut().get_mut(errno_ptr.alloc_id)?.write_scalar(\n+        this.memory.get_mut(errno_ptr.alloc_id)?.write_scalar(\n             tcx,\n             errno_ptr,\n             scalar.into(),\n@@ -1007,7 +1007,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let tcx = &{ this.tcx.tcx };\n         let errno_ptr = this.machine.last_error.unwrap();\n-        this.memory()\n+        this.memory\n             .get(errno_ptr.alloc_id)?\n             .read_scalar(tcx, errno_ptr, Size::from_bits(32))?\n             .not_undef()"}, {"sha": "3a16e2868958d379a343dc0fd49e7de15ac3533f", "filename": "src/shims/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -95,7 +95,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         let path_bytes = this\n-            .memory()\n+            .memory\n             .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n         let path = std::str::from_utf8(path_bytes)\n             .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?;\n@@ -171,7 +171,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.remove_handle_and(fd, |mut handle, this| {\n             // Don't use `?` to avoid returning before reinserting the handle\n             let bytes = this.force_ptr(buf_scalar).and_then(|buf| {\n-                this.memory_mut()\n+                this.memory\n                     .get_mut(buf.alloc_id)?\n                     .get_bytes_mut(tcx, buf, Size::from_bytes(count))\n                     .map(|buffer| handle.file.read(buffer))\n@@ -203,7 +203,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n \n         this.remove_handle_and(fd, |mut handle, this| {\n-            let bytes = this.memory().get(buf.alloc_id).and_then(|alloc| {\n+            let bytes = this.memory.get(buf.alloc_id).and_then(|alloc| {\n                 alloc\n                     .get_bytes(tcx, buf, Size::from_bytes(count))\n                     .map(|bytes| handle.file.write(bytes).map(|bytes| bytes as i64))\n@@ -219,7 +219,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"unlink\")?;\n \n         let path_bytes = this\n-            .memory()\n+            .memory\n             .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n         let path = std::str::from_utf8(path_bytes)\n             .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?;"}, {"sha": "1fa2b5a0d01fc298df31c21de9d2b160c3d4a035", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -68,7 +68,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n                 let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+                this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_scalar(val, dest)?;\n             }\n@@ -83,7 +83,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n                 let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+                this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_scalar(val, place.into())?;\n             }\n@@ -104,7 +104,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n                 let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+                this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_scalar(old, dest)?; // old value is returned\n                 this.write_scalar(new, place.into())?;\n@@ -120,7 +120,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n                 let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+                this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 // binary_op will bail if either of them is not a scalar\n                 let eq = this.overflowing_binary_op(mir::BinOp::Eq, old, expect_old)?.0;\n@@ -173,7 +173,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n                 let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+                this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_immediate(*old, dest)?; // old value is returned\n                 let (op, neg) = match intrinsic_name.split('_').nth(1).unwrap() {\n@@ -207,12 +207,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 let size = Size::from_bytes(count * elem_size);\n                 let src = this.read_scalar(args[0])?.not_undef()?;\n-                let src = this.memory().check_ptr_access(src, size, elem_align)?;\n+                let src = this.memory.check_ptr_access(src, size, elem_align)?;\n                 let dest = this.read_scalar(args[1])?.not_undef()?;\n-                let dest = this.memory().check_ptr_access(dest, size, elem_align)?;\n+                let dest = this.memory.check_ptr_access(dest, size, elem_align)?;\n \n                 if let (Some(src), Some(dest)) = (src, dest) {\n-                    this.memory_mut().copy(\n+                    this.memory.copy(\n                         src,\n                         dest,\n                         size,\n@@ -359,7 +359,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             assert!(mplace.meta.is_none());\n                             // not a zst, must be valid pointer\n                             let ptr = mplace.ptr.to_ptr()?;\n-                            this.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, dest.layout.size)?;\n+                            this.memory.get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, dest.layout.size)?;\n                         }\n                     }\n                 }\n@@ -548,7 +548,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             let mplace = this.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n                             let ptr = mplace.ptr.to_ptr()?;\n-                            this.memory_mut()\n+                            this.memory\n                                 .get_mut(ptr.alloc_id)?\n                                 .mark_definedness(ptr, dest.layout.size, false);\n                         }\n@@ -563,9 +563,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let count = this.read_scalar(args[2])?.to_usize(this)?;\n                 let byte_count = ty_layout.size * count;\n-                match this.memory().check_ptr_access(ptr, byte_count, ty_layout.align.abi)? {\n+                match this.memory.check_ptr_access(ptr, byte_count, ty_layout.align.abi)? {\n                     Some(ptr) => {\n-                        this.memory_mut()\n+                        this.memory\n                             .get_mut(ptr.alloc_id)?\n                             .write_repeat(tcx, ptr, val_byte, byte_count)?;\n                     }"}, {"sha": "60974958c42ab6e1c662806e807e07c7750af33f", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -75,7 +75,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ptr_scalar = this.read_scalar(ptr_op)?.not_undef()?;\n \n         if let Ok(ptr) = this.force_ptr(ptr_scalar) {\n-            let cur_align = this.memory().get(ptr.alloc_id)?.align.bytes() as usize;\n+            let cur_align = this.memory.get(ptr.alloc_id)?.align.bytes() as usize;\n             if cur_align >= req_align {\n                 // if the allocation alignment is at least the required alignment we use the\n                 // libcore implementation"}, {"sha": "d219c1c7583459a8252fc1e7cfe90a46f67b42c8", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d91f79eefa3a54f06288073186ff8e017f16/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=fbc1d91f79eefa3a54f06288073186ff8e017f16", "patch": "@@ -533,14 +533,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra) } else { None };\n-        let ptr = this.memory().check_ptr_access(place.ptr, size, place.align)\n+        let ptr = this.memory.check_ptr_access(place.ptr, size, place.align)\n             .expect(\"validity checks should have excluded dangling/unaligned pointer\")\n             .expect(\"we shouldn't get here for ZST\");\n         trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n-        let alloc = this.memory().get(ptr.alloc_id)?;\n+        let alloc = this.memory.get(ptr.alloc_id)?;\n         let stacked_borrows = alloc.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n@@ -592,7 +592,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Compute new borrow.\n         let new_tag = match kind {\n             RefKind::Raw { .. } => Tag::Untagged,\n-            _ => Tag::Tagged(this.memory().extra.stacked_borrows.borrow_mut().new_ptr()),\n+            _ => Tag::Tagged(this.memory.extra.stacked_borrows.borrow_mut().new_ptr()),\n         };\n \n         // Reborrow."}]}