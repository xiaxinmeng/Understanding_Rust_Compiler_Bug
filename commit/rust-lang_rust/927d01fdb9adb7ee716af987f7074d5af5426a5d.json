{"sha": "927d01fdb9adb7ee716af987f7074d5af5426a5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyN2QwMWZkYjlhZGI3ZWU3MTZhZjk4N2Y3MDc0ZDVhZjU0MjZhNWQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2019-01-28T23:00:42Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2019-01-28T23:00:42Z"}, "message": "avoid committing to autoderef in object method probing", "tree": {"sha": "84b258b82f3f809f17c2cc7ab9eafa2e8252bfe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b258b82f3f809f17c2cc7ab9eafa2e8252bfe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/927d01fdb9adb7ee716af987f7074d5af5426a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/927d01fdb9adb7ee716af987f7074d5af5426a5d", "html_url": "https://github.com/rust-lang/rust/commit/927d01fdb9adb7ee716af987f7074d5af5426a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/927d01fdb9adb7ee716af987f7074d5af5426a5d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c", "html_url": "https://github.com/rust-lang/rust/commit/0ceb30de6d5bb82b14159f37dd66a3fd6bcd756c"}], "stats": {"total": 88, "additions": 81, "deletions": 7}, "files": [{"sha": "be6a2ffa3eb7f87027d1199fbdd10b02c845a109", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/927d01fdb9adb7ee716af987f7074d5af5426a5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927d01fdb9adb7ee716af987f7074d5af5426a5d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=927d01fdb9adb7ee716af987f7074d5af5426a5d", "patch": "@@ -537,13 +537,28 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         match self_ty.value.value.sty {\n             ty::Dynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n-                    let InferOk { value: instantiated_self_ty, obligations: _ } =\n-                        self.fcx.probe_instantiate_query_response(\n-                            self.span, &self.orig_steps_var_values, self_ty)\n-                        .unwrap_or_else(|_| {\n-                            span_bug!(self.span, \"{:?} was applicable but now isn't?\", self_ty)\n-                        });\n-                    self.assemble_inherent_candidates_from_object(instantiated_self_ty);\n+                    // Subtle: we can't use `instantiate_query_response` here: using it will\n+                    // commit to all of the type equalities assumed by inference going through\n+                    // autoderef (see the `method-probe-no-guessing` test).\n+                    //\n+                    // However, in this code, it is OK if we end up with an object type that is\n+                    // \"more general\" than the object type that we are evaluating. For *every*\n+                    // object type `MY_OBJECT`, a function call that goes through a trait-ref\n+                    // of the form `<MY_OBJECT as SuperTraitOf(MY_OBJECT)>::func` is a valid\n+                    // `ObjectCandidate`, and it should be discoverable \"exactly\" through one\n+                    // of the iterations in the autoderef loop, so there is no problem with it\n+                    // being discoverable in another one of these iterations.\n+                    //\n+                    // Using `instantiate_canonical_with_fresh_inference_vars` on our\n+                    // `Canonical<QueryResponse<Ty<'tcx>>>` and then *throwing away* the\n+                    // `CanonicalVarValues` will exactly give us such a generalization - it\n+                    // will still match the original object type, but it won't pollute our\n+                    // type variables in any form, so just do that!\n+                    let (QueryResponse { value: generalized_self_ty, .. }, _ignored_var_values) =\n+                        self.fcx.instantiate_canonical_with_fresh_inference_vars(\n+                            self.span, &self_ty);\n+\n+                    self.assemble_inherent_candidates_from_object(generalized_self_ty);\n                     self.assemble_inherent_impl_candidates_for_type(p.def_id());\n                 }\n             }"}, {"sha": "8c8165a1004499fcd78606bfff539bd4497ab199", "filename": "src/test/run-pass/methods/method-probe-no-guessing-dyn-trait.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/927d01fdb9adb7ee716af987f7074d5af5426a5d/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-probe-no-guessing-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927d01fdb9adb7ee716af987f7074d5af5426a5d/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-probe-no-guessing-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-probe-no-guessing-dyn-trait.rs?ref=927d01fdb9adb7ee716af987f7074d5af5426a5d", "patch": "@@ -0,0 +1,59 @@\n+// Check that method matching does not make \"guesses\" depending on\n+// Deref impls that don't eventually end up being picked.\n+\n+use std::ops::Deref;\n+\n+// An impl with less derefs will get called over an impl with more derefs,\n+// so `(t: Foo<_>).my_fn()` will use `<Foo<u32> as MyTrait1>::my_fn(t)`,\n+// and does *not* force the `_` to equal `()`, because the Deref impl\n+// was *not* used.\n+\n+trait MyTrait1 {\n+    fn my_fn(&self) {}\n+}\n+\n+impl MyTrait1 for Foo<u32> {}\n+\n+struct Foo<T>(T);\n+\n+impl Deref for Foo<()> {\n+    type Target = dyn MyTrait1 + 'static;\n+    fn deref(&self) -> &(dyn MyTrait1 + 'static) {\n+        panic!()\n+    }\n+}\n+\n+// ...but if there is no impl with less derefs, the \"guess\" will be\n+// forced, so `(t: Bar<_>).my_fn2()` is `<dyn MyTrait2 as MyTrait2>::my_fn2(*t)`,\n+// and because the deref impl is used, the `_` is forced to equal `u8`.\n+\n+trait MyTrait2 {\n+    fn my_fn2(&self) {}\n+}\n+\n+impl MyTrait2 for u32 {}\n+struct Bar<T>(T, u32);\n+impl Deref for Bar<u8> {\n+    type Target = dyn MyTrait2 + 'static;\n+    fn deref(&self) -> &(dyn MyTrait2 + 'static) {\n+        &self.1\n+    }\n+}\n+\n+// actually invoke things\n+\n+fn main() {\n+    let mut foo: Option<Foo<_>> = None;\n+    let mut bar: Option<Bar<_>> = None;\n+    let mut first_iter = true;\n+    loop {\n+        if !first_iter {\n+            foo.as_ref().unwrap().my_fn();\n+            bar.as_ref().unwrap().my_fn2();\n+            break;\n+        }\n+        foo = Some(Foo(0));\n+        bar = Some(Bar(Default::default(), 0));\n+        first_iter = false;\n+    }\n+}"}]}