{"sha": "073d7ffc2745386f42048847ec7209e47cbdab8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3M2Q3ZmZjMjc0NTM4NmY0MjA0ODg0N2VjNzIwOWU0N2NiZGFiOGY=", "commit": {"author": {"name": "Alan Williams", "email": "mralert@gmail.com", "date": "2014-05-03T21:27:36Z"}, "committer": {"name": "Alan Williams", "email": "mralert@gmail.com", "date": "2014-05-04T09:57:54Z"}, "message": "Implement fallbacks for functions unavailable in older versions of Windows", "tree": {"sha": "92fccddce6bc9f670929d825418411439e063f9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92fccddce6bc9f670929d825418411439e063f9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/073d7ffc2745386f42048847ec7209e47cbdab8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/073d7ffc2745386f42048847ec7209e47cbdab8f", "html_url": "https://github.com/rust-lang/rust/commit/073d7ffc2745386f42048847ec7209e47cbdab8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/073d7ffc2745386f42048847ec7209e47cbdab8f/comments", "author": {"login": "MrAlert", "id": 148235, "node_id": "MDQ6VXNlcjE0ODIzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/148235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrAlert", "html_url": "https://github.com/MrAlert", "followers_url": "https://api.github.com/users/MrAlert/followers", "following_url": "https://api.github.com/users/MrAlert/following{/other_user}", "gists_url": "https://api.github.com/users/MrAlert/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrAlert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrAlert/subscriptions", "organizations_url": "https://api.github.com/users/MrAlert/orgs", "repos_url": "https://api.github.com/users/MrAlert/repos", "events_url": "https://api.github.com/users/MrAlert/events{/privacy}", "received_events_url": "https://api.github.com/users/MrAlert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MrAlert", "id": 148235, "node_id": "MDQ6VXNlcjE0ODIzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/148235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MrAlert", "html_url": "https://github.com/MrAlert", "followers_url": "https://api.github.com/users/MrAlert/followers", "following_url": "https://api.github.com/users/MrAlert/following{/other_user}", "gists_url": "https://api.github.com/users/MrAlert/gists{/gist_id}", "starred_url": "https://api.github.com/users/MrAlert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MrAlert/subscriptions", "organizations_url": "https://api.github.com/users/MrAlert/orgs", "repos_url": "https://api.github.com/users/MrAlert/repos", "events_url": "https://api.github.com/users/MrAlert/events{/privacy}", "received_events_url": "https://api.github.com/users/MrAlert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f25c8b78d1192aea69ee9779f512eb9ee78e575", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f25c8b78d1192aea69ee9779f512eb9ee78e575", "html_url": "https://github.com/rust-lang/rust/commit/1f25c8b78d1192aea69ee9779f512eb9ee78e575"}], "stats": {"total": 105, "additions": 89, "deletions": 16}, "files": [{"sha": "e96ddfbf7bdc104d8550c0807e57e8c9c9e73196", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/073d7ffc2745386f42048847ec7209e47cbdab8f/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073d7ffc2745386f42048847ec7209e47cbdab8f/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=073d7ffc2745386f42048847ec7209e47cbdab8f", "patch": "@@ -250,7 +250,6 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use funcs::extra::kernel32::{FlushFileBuffers, SetEndOfFile, CreateFileW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{CreateDirectoryW, FindFirstFileW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{FindNextFileW, FindClose, DeleteFileW};\n-#[cfg(windows)] pub use funcs::extra::kernel32::{GetFinalPathNameByHandleW, CreateSymbolicLinkW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{CreateHardLinkW, CreateEventW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{FlushFileBuffers, CreateNamedPipeW};\n #[cfg(windows)] pub use funcs::extra::kernel32::{SetNamedPipeHandleState, WaitNamedPipeW};\n@@ -1733,6 +1732,7 @@ pub mod consts {\n             pub static ERROR_INVALID_HANDLE : c_int = 6;\n             pub static ERROR_BROKEN_PIPE: c_int = 109;\n             pub static ERROR_DISK_FULL : c_int = 112;\n+            pub static ERROR_CALL_NOT_IMPLEMENTED : c_int = 120;\n             pub static ERROR_INSUFFICIENT_BUFFER : c_int = 122;\n             pub static ERROR_INVALID_NAME : c_int = 123;\n             pub static ERROR_ALREADY_EXISTS : c_int = 183;\n@@ -4185,9 +4185,9 @@ pub mod funcs {\n                                                LPSTARTUPINFO,\n                                                LPPROCESS_INFORMATION,\n                                                LPMEMORY_BASIC_INFORMATION,\n-                                               LPSYSTEM_INFO, BOOLEAN,\n-                                               HANDLE, LPHANDLE, LARGE_INTEGER,\n-                                               PLARGE_INTEGER, LPFILETIME};\n+                                               LPSYSTEM_INFO, HANDLE, LPHANDLE,\n+                                               LARGE_INTEGER, PLARGE_INTEGER,\n+                                               LPFILETIME};\n \n             extern \"system\" {\n                 pub fn GetEnvironmentVariableW(n: LPCWSTR,\n@@ -4297,9 +4297,6 @@ pub mod funcs {\n                 pub fn MoveFileExW(lpExistingFileName: LPCWSTR,\n                                    lpNewFileName: LPCWSTR,\n                                    dwFlags: DWORD) -> BOOL;\n-                pub fn CreateSymbolicLinkW(lpSymlinkFileName: LPCWSTR,\n-                                           lpTargetFileName: LPCWSTR,\n-                                           dwFlags: DWORD) -> BOOLEAN;\n                 pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,\n                                        lpTargetFileName: LPCWSTR,\n                                        lpSecurityAttributes: LPSECURITY_ATTRIBUTES)\n@@ -4312,10 +4309,6 @@ pub mod funcs {\n                                    dwCreationDisposition: DWORD,\n                                    dwFlagsAndAttributes: DWORD,\n                                    hTemplateFile: HANDLE) -> HANDLE;\n-                pub fn GetFinalPathNameByHandleW(hFile: HANDLE,\n-                                                 lpszFilePath: LPCWSTR,\n-                                                 cchFilePath: DWORD,\n-                                                 dwFlags: DWORD) -> DWORD;\n                 pub fn ReadFile(hFile: HANDLE,\n                                 lpBuffer: LPVOID,\n                                 nNumberOfBytesToRead: DWORD,"}, {"sha": "ea105b267c1ed24590650dc745f9aaefacc0dc06", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/073d7ffc2745386f42048847ec7209e47cbdab8f/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073d7ffc2745386f42048847ec7209e47cbdab8f/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=073d7ffc2745386f42048847ec7209e47cbdab8f", "patch": "@@ -408,6 +408,7 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n \n pub fn readlink(p: &CString) -> IoResult<Path> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n+    use std::os::win32::compat::kernel32::GetFinalPathNameByHandleW;\n     let handle = unsafe {\n         as_utf16_p(p.as_str().unwrap(), |p| {\n             libc::CreateFileW(p,\n@@ -425,10 +426,10 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     // Specify (sz - 1) because the documentation states that it's the size\n     // without the null pointer\n     let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n-        libc::GetFinalPathNameByHandleW(handle,\n-                                        buf as *u16,\n-                                        sz - 1,\n-                                        libc::VOLUME_NAME_DOS)\n+        GetFinalPathNameByHandleW(handle,\n+                                  buf as *u16,\n+                                  sz - 1,\n+                                  libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n         Some(ref s) if s.starts_with(r\"\\\\?\\\") => Ok(Path::new(s.slice_from(4))),\n@@ -440,9 +441,10 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n }\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n+    use std::os::win32::compat::kernel32::CreateSymbolicLinkW;\n     super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n         as_utf16_p(dst.as_str().unwrap(), |dst| {\n-            unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n+            unsafe { CreateSymbolicLinkW(dst, src, 0) }\n         }) as libc::BOOL\n     }))\n }"}, {"sha": "5152399bf7ebaad59d6ebc1c786fd33bd506d2de", "filename": "src/libstd/os.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/073d7ffc2745386f42048847ec7209e47cbdab8f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073d7ffc2745386f42048847ec7209e47cbdab8f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=073d7ffc2745386f42048847ec7209e47cbdab8f", "patch": "@@ -145,6 +145,84 @@ pub mod win32 {\n         t.push(0u16);\n         f(t.as_ptr())\n     }\n+\n+    pub mod compat {\n+        use kinds::Copy;\n+        use option::Option;\n+        use c_str::ToCStr;\n+        use intrinsics::{atomic_store_relaxed, transmute};\n+        use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+        use os::win32::as_utf16_p;\n+\n+        #[link_name=\"kernel32\"]\n+        extern \"system\" {\n+            fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n+            fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n+        }\n+\n+        unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n+            as_utf16_p(module, |module| {\n+                symbol.with_c_str(|symbol| {\n+                    let handle = GetModuleHandleW(module);\n+                    let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n+                    atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n+                })\n+            })\n+        }\n+\n+        macro_rules! compat_fn(\n+            ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n+                                          -> $rettype:ty $fallback:block) => (\n+                #[inline(always)]\n+                pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+                    static mut ptr: extern \"system\" fn($($argname: $argtype),*) -> $rettype = thunk;\n+\n+                    extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n+                        unsafe {\n+                            ::os::win32::compat::store_func(&mut ptr,\n+                                                                 stringify!($module),\n+                                                                 stringify!($symbol),\n+                                                                 fallback);\n+                            ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                        }\n+                    }\n+\n+                    extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $fallback\n+\n+                    ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                }\n+            );\n+\n+            ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*) $fallback:block) => (\n+                compat_fn!($module::$symbol($($argname: $argtype),*) -> () $fallback)\n+            )\n+        )\n+\n+        pub mod kernel32 {\n+            use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n+            use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n+\n+            #[link_name=\"kernel32\"]\n+            extern \"system\" {\n+                fn SetLastError(dwErrCode: DWORD);\n+            }\n+\n+            compat_fn!(kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n+                                                     _lpTargetFileName: LPCWSTR,\n+                                                     _dwFlags: DWORD) -> BOOLEAN {\n+                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n+                0\n+            })\n+\n+            compat_fn!(kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n+                                                           _lpszFilePath: LPCWSTR,\n+                                                           _cchFilePath: DWORD,\n+                                                           _dwFlags: DWORD) -> DWORD {\n+                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n+                0\n+            })\n+        }\n+    }\n }\n \n /*"}]}