{"sha": "d244234607417e850e264afc9fbf7a4842ebad19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNDQyMzQ2MDc0MTdlODUwZTI2NGFmYzlmYmY3YTQ4NDJlYmFkMTk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-09T01:10:57Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "factor out treatment of 1-length chains\n\nAnd create `Chain` and `ChainItem` structs", "tree": {"sha": "c0352621babacdd70f4d01425b0a45e632fd7685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0352621babacdd70f4d01425b0a45e632fd7685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d244234607417e850e264afc9fbf7a4842ebad19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d244234607417e850e264afc9fbf7a4842ebad19", "html_url": "https://github.com/rust-lang/rust/commit/d244234607417e850e264afc9fbf7a4842ebad19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d244234607417e850e264afc9fbf7a4842ebad19/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "html_url": "https://github.com/rust-lang/rust/commit/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6"}], "stats": {"total": 106, "additions": 57, "deletions": 49}, "files": [{"sha": "3a851899f08aa8be0cd5608b929f963240c25546", "filename": "src/chains.rs", "status": "modified", "additions": 57, "deletions": 49, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d244234607417e850e264afc9fbf7a4842ebad19/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d244234607417e850e264afc9fbf7a4842ebad19/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=d244234607417e850e264afc9fbf7a4842ebad19", "patch": "@@ -84,29 +84,56 @@ use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n     debug!(\"rewrite_chain {:?}\", shape);\n+    let chain = Chain::from_ast(expr, context);\n+    if chain.children.is_empty() {\n+        return rewrite_try(&chain.parent.expr, chain.parent.tries, context, shape);\n+    }\n     match context.config.indent_style() {\n-        IndentStyle::Block => rewrite_chain_block(expr, context, shape),\n-        IndentStyle::Visual => rewrite_chain_visual(expr, context, shape),\n+        IndentStyle::Block => rewrite_chain_block(chain, context, shape),\n+        IndentStyle::Visual => rewrite_chain_visual(chain, context, shape),\n     }\n }\n \n-fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let total_span = expr.span;\n-    let (parent, subexpr_list) = make_subexpr_list(expr, context);\n+// An expression plus trailing `?`s to be formatted together.\n+struct ChainItem {\n+    expr: ast::Expr,\n+    tries: usize,\n+}\n+\n+struct Chain {\n+    parent: ChainItem,\n+    // TODO do we need to clone the exprs?\n+    children: Vec<ast::Expr>,\n+    span: Span,\n+}\n \n-    // Bail out if the chain is just try sugar, i.e., an expression followed by\n-    // any number of `?`s.\n-    if chain_only_try(&subexpr_list) {\n-        return rewrite_try(&parent, subexpr_list.len(), context, shape);\n+impl Chain {\n+    fn from_ast(expr: &ast::Expr, context: &RewriteContext) -> Chain {\n+        let (parent, mut subexpr_list) = make_subexpr_list(expr, context);\n+        let tries = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n+        let new_len = subexpr_list.len() - tries;\n+        subexpr_list.truncate(new_len);\n+        Chain {\n+            parent: ChainItem {\n+                expr: parent,\n+                tries,\n+            },\n+            children: subexpr_list,\n+            span: expr.span,\n+        }\n     }\n+}\n+\n+fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    let (parent, subexpr_list) = (&chain.parent.expr, &chain.children);\n+\n     let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n-    let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = shape;\n     let parent_rewrite = parent\n         .rewrite(context, parent_shape)\n-        .map(|parent_rw| parent_rw + &\"?\".repeat(prefix_try_num))?;\n+        .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n     let parent_is_block = is_block_expr(context, &parent, &parent_rewrite);\n@@ -132,7 +159,7 @@ fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape)\n     let other_child_shape = nested_shape.with_max_width(context.config);\n \n     let first_child_shape = if extend {\n-        let offset = trimmed_last_line_width(&parent_rewrite) + prefix_try_num;\n+        let offset = trimmed_last_line_width(&parent_rewrite) + chain.parent.tries;\n         if parent_is_block {\n             parent_shape.offset_left(offset)?\n         } else {\n@@ -148,9 +175,8 @@ fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape)\n         first_child_shape, other_child_shape\n     );\n \n-    let subexpr_num = subexpr_list.len();\n     let last_subexpr = &subexpr_list[suffix_try_num];\n-    let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n+    let subexpr_list = &subexpr_list[suffix_try_num..];\n \n     let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n     let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n@@ -161,7 +187,7 @@ fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape)\n         } else {\n             other_child_shape\n         };\n-        let rewrite = rewrite_chain_subexpr(expr, total_span, context, shape)?;\n+        let rewrite = rewrite_chain_subexpr(expr, chain.span, context, shape)?;\n         is_block_like.push(is_block_expr(context, expr, &rewrite));\n         rewrites.push(rewrite);\n     }\n@@ -226,12 +252,12 @@ fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape)\n \n     // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n     // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n-    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, last_shape);\n+    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, chain.span, context, last_shape);\n     let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n         parent_shape.offset_left(almost_total).map(|shape| {\n-            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n+            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, chain.span, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n                 // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n@@ -313,17 +339,10 @@ fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape)\n     Some(result)\n }\n \n-fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let total_span = expr.span;\n-    let (parent, subexpr_list) = make_subexpr_list(expr, context);\n+fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    let (parent, subexpr_list) = (&chain.parent.expr, &chain.children);\n \n-    // Bail out if the chain is just try sugar, i.e., an expression followed by\n-    // any number of `?`s.\n-    if chain_only_try(&subexpr_list) {\n-        return rewrite_try(&parent, subexpr_list.len(), context, shape);\n-    }\n     let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n-    let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n@@ -333,7 +352,7 @@ fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape\n     };\n     let parent_rewrite = parent\n         .rewrite(context, parent_shape)\n-        .map(|parent_rw| parent_rw + &\"?\".repeat(prefix_try_num))?;\n+        .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n     let parent_is_block = is_block_expr(context, &parent, &parent_rewrite);\n@@ -364,9 +383,8 @@ fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape\n         first_child_shape, other_child_shape\n     );\n \n-    let subexpr_num = subexpr_list.len();\n     let last_subexpr = &subexpr_list[suffix_try_num];\n-    let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n+    let subexpr_list = &subexpr_list[suffix_try_num..];\n \n     let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n     let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n@@ -377,7 +395,7 @@ fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape\n         } else {\n             other_child_shape\n         };\n-        let rewrite = rewrite_chain_subexpr(expr, total_span, context, shape)?;\n+        let rewrite = rewrite_chain_subexpr(expr, chain.span, context, shape)?;\n         is_block_like.push(is_block_expr(context, expr, &rewrite));\n         rewrites.push(rewrite);\n     }\n@@ -442,12 +460,12 @@ fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape\n \n     // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n     // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n-    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, last_shape);\n+    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, chain.span, context, last_shape);\n     let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n         parent_shape.offset_left(almost_total).map(|shape| {\n-            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n+            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, chain.span, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n                 // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n@@ -509,17 +527,6 @@ fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape\n     wrap_str(result, context.config.max_width(), shape)\n }\n \n-// True if the chain is only `?`s.\n-fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n-    exprs.iter().all(|e| {\n-        if let ast::ExprKind::Try(_) = e.node {\n-            true\n-        } else {\n-            false\n-        }\n-    })\n-}\n-\n fn rewrite_try(\n     expr: &ast::Expr,\n     try_count: usize,\n@@ -566,12 +573,19 @@ fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool\n         | ast::ExprKind::Unary(_, ref expr)\n         | ast::ExprKind::Closure(_, _, _, _, ref expr, _) => is_block_expr(context, expr, repr),\n         ast::ExprKind::MethodCall(_, ref exprs) => {\n+            // TODO maybe should be like Call\n             is_block_expr(context, exprs.last().unwrap(), repr)\n         }\n         _ => false,\n     }\n }\n \n+fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n+    shape\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config)\n+}\n+\n // Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n // E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr, Vec<ast::Expr>) {\n@@ -585,12 +599,6 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n     (parent, subexpr_list)\n }\n \n-fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n-    IndentStyle::Block => shape\n-        .block_indent(context.config.tab_spaces())\n-        .with_max_width(context.config),\n-}\n-\n // Returns the expression's subexpression, if it exists. When the subexpr\n // is a try! macro, we'll convert it to shorthand when the option is set.\n fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {"}]}