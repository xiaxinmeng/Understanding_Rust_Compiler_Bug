{"sha": "8854b78b555d9a03a3b2ff248230696ec94e24c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NTRiNzhiNTU1ZDlhMDNhM2IyZmYyNDgyMzA2OTZlYzk0ZTI0YzA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-05T20:40:01Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-10T22:16:31Z"}, "message": "rustpkg: Make checked-out source files read-only, and overhaul where temporary files are stored\n\nrustpkg now makes source files that it checks out automatically read-only, and stores\nthem under build/.\n\nAlso, refactored the `PkgSrc` type to keep track of separate source and destination\nworkspaces, as well as to have a `build_workspace` method that returns the workspace\nto put temporary files in (usually the source, sometimes the destination -- see\ncomments for more details).\n\nCloses #6480", "tree": {"sha": "fb4dc516d3d580750926a045b5ecc589b01b5e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb4dc516d3d580750926a045b5ecc589b01b5e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8854b78b555d9a03a3b2ff248230696ec94e24c0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8854b78b555d9a03a3b2ff248230696ec94e24c0", "html_url": "https://github.com/rust-lang/rust/commit/8854b78b555d9a03a3b2ff248230696ec94e24c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8854b78b555d9a03a3b2ff248230696ec94e24c0/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b8a41a28769b5a8dfcbb5382d577d6102b3ce28", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8a41a28769b5a8dfcbb5382d577d6102b3ce28", "html_url": "https://github.com/rust-lang/rust/commit/8b8a41a28769b5a8dfcbb5382d577d6102b3ce28"}], "stats": {"total": 832, "additions": 539, "deletions": 293}, "files": [{"sha": "53829e4519641dec11e03fa6ec37091a761b1e51", "filename": "doc/rustpkg.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -137,6 +137,9 @@ and builds it in any workspace(s) where it finds one.\n Supposing such packages are found in workspaces X, Y, and Z,\n the command leaves behind files in `X`'s, `Y`'s, and `Z`'s `build` directories,\n but not in their `lib` or `bin` directories.\n+(The exception is when rustpkg fetches a package `foo`'s sources from a remote repository.\n+In that case, it stores both the sources *and* the build artifacts for `foo`\n+in the workspace that `foo` will install to (see ##install below)).\n \n ## clean\n \n@@ -148,7 +151,11 @@ but not in their `lib` or `bin` directories.\n If `RUST_PATH` is declared as an environment variable, then rustpkg installs the\n libraries and executables into the `lib` and `bin` subdirectories\n of the first entry in `RUST_PATH`.\n-Otherwise, it installs them into `foo`'s `lib` and `bin` directories.\n+Otherwise, if the current working directory CWD is a workspace,\n+it installs them into CWD's `lib` and `bin` subdirectories.\n+Otherwise, if the current working directory is CWD,\n+it installs them into the .rust/lib and .rust/bin subdirectories of CWD\n+(creating them if necessary). \n \n ## test\n "}, {"sha": "390a09d4aa33e8dc9eb85a187d48b83d132504b5", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -16,6 +16,8 @@ use target::*;\n use version::Version;\n use workcache_support::*;\n \n+pub use source_control::{safe_git_clone, git_clone_url};\n+\n use std::os;\n use extra::arc::{Arc,RWArc};\n use extra::workcache;\n@@ -68,23 +70,27 @@ pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n     let cx = default_context(sysroot);\n     let pkg_src = PkgSrc {\n-            workspace: root.clone(),\n-            start_dir: root.push(\"src\").push(name),\n-            id: PkgId{ version: version, ..PkgId::new(name)},\n-            // n.b. This assumes the package only has one crate\n-            libs: ~[mk_crate(lib)],\n-            mains: ~[],\n-            tests: ~[],\n-            benchs: ~[]\n-        };\n+        source_workspace: root.clone(),\n+        build_in_destination: false,\n+        destination_workspace: root.clone(),\n+        start_dir: root.push(\"src\").push(name),\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n+        // n.b. This assumes the package only has one crate\n+        libs: ~[mk_crate(lib)],\n+        mains: ~[],\n+        tests: ~[],\n+        benchs: ~[]\n+    };\n     pkg_src.build(&cx, ~[]);\n }\n \n pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n                  main: Path) {\n     let cx = default_context(sysroot);\n     let pkg_src = PkgSrc {\n-        workspace: root.clone(),\n+        source_workspace: root.clone(),\n+        build_in_destination: false,\n+        destination_workspace: root.clone(),\n         start_dir: root.push(\"src\").push(name),\n         id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[],\n@@ -100,7 +106,7 @@ pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n pub fn install_pkg(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n     let cx = default_context(sysroot);\n     let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n-    cx.install(PkgSrc::new(workspace, false, pkgid), &Everything);\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid), &Everything);\n }\n \n fn mk_crate(p: Path) -> Crate {"}, {"sha": "f40f48e851fbaceb7caa5c55490a7e60aabc94b7", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -50,3 +50,7 @@ condition! {\n condition! {\n     pub failed_to_create_temp_dir: (~str) -> Path;\n }\n+\n+condition! {\n+    pub git_checkout_failed: (~str, Path) -> ();\n+}"}, {"sha": "c06e197787c3eb22990dfab828536585a007601e", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -102,10 +102,7 @@ impl PkgId {\n     }\n \n     pub fn prefixes_iter(&self) -> Prefixes {\n-        Prefixes {\n-            components: self.path.components().to_owned(),\n-            remaining: ~[]\n-        }\n+        prefixes_iter(&self.path)\n     }\n \n     // This is the workcache function name for the *installed*\n@@ -116,6 +113,13 @@ impl PkgId {\n     }\n }\n \n+pub fn prefixes_iter(p: &Path) -> Prefixes {\n+    Prefixes {\n+        components: p.components().to_owned(),\n+        remaining: ~[]\n+    }\n+}\n+\n struct Prefixes {\n     priv components: ~[~str],\n     priv remaining: ~[~str]"}, {"sha": "86566020812eeec313747042dfd28a274dfa02ae", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 157, "deletions": 101, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -17,10 +17,11 @@ use std::os;\n use context::*;\n use crate::Crate;\n use messages::*;\n-use source_control::{git_clone, git_clone_general};\n-use path_util::{find_dir_using_rust_path_hack, default_workspace, make_dir_rwx_recursive};\n+use source_control::{safe_git_clone, git_clone_url, DirToUse, CheckedOutSources};\n+use source_control::make_read_only;\n+use path_util::{find_dir_using_rust_path_hack, make_dir_rwx_recursive};\n+use path_util::{target_build_dir, versionize};\n use util::compile_crate;\n-use workspace::is_workspace;\n use workcache_support;\n use workcache_support::crate_tag;\n use extra::workcache;\n@@ -30,7 +31,17 @@ use extra::workcache;\n #[deriving(Clone)]\n pub struct PkgSrc {\n     /// Root of where the package source code lives\n-    workspace: Path,\n+    source_workspace: Path,\n+    /// If build_in_destination is true, temporary results should\n+    /// go in the build/ subdirectory of the destination workspace.\n+    /// (Otherwise, they go in the build/ subdirectory of the\n+    /// source workspace.) This happens if the \"RUST_PATH hack\" is\n+    /// in effect, or if sources were fetched from a remote\n+    /// repository.\n+    build_in_destination: bool,\n+    /// Where to install the results. May or may not be the same\n+    /// as source_workspace\n+    destination_workspace: Path,\n     // Directory to start looking in for packages -- normally\n     // this is workspace/src/id but it may be just workspace\n     start_dir: Path,\n@@ -41,11 +52,15 @@ pub struct PkgSrc {\n     benchs: ~[Crate],\n }\n \n+pub enum BuildSort { InPlace, Discovered }\n+\n impl ToStr for PkgSrc {\n     fn to_str(&self) -> ~str {\n-        format!(\"Package ID {} in start dir {} [workspace = {}]\",\n+        format!(\"Package ID {} in start dir {} [workspaces = {} -> {}]\",\n                 self.id.to_str(),\n-                self.start_dir.to_str(), self.workspace.to_str())\n+                self.start_dir.to_str(),\n+                self.source_workspace.to_str(),\n+                self.destination_workspace.to_str())\n     }\n }\n condition! {\n@@ -55,66 +70,121 @@ condition! {\n \n impl PkgSrc {\n \n-    pub fn new(workspace: Path, use_rust_path_hack: bool, id: PkgId) -> PkgSrc {\n+    pub fn new(mut source_workspace: Path,\n+               destination_workspace: Path,\n+               use_rust_path_hack: bool,\n+               id: PkgId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n         debug2!(\"Checking package source for package ID {}, \\\n-               workspace = {} use_rust_path_hack = {:?}\",\n-               id.to_str(), workspace.to_str(), use_rust_path_hack);\n+                workspace = {} -> {}, use_rust_path_hack = {:?}\",\n+                id.to_str(),\n+                source_workspace.to_str(),\n+                destination_workspace.to_str(),\n+                use_rust_path_hack);\n+\n+        let mut destination_workspace = destination_workspace.clone();\n \n         let mut to_try = ~[];\n+        let mut output_names = ~[];\n+        let build_dir = target_build_dir(&source_workspace);\n+\n         if use_rust_path_hack {\n-            to_try.push(workspace.clone());\n+            to_try.push(source_workspace.clone());\n         } else {\n-            let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n+            // We search for sources under both src/ and build/ , because build/ is where\n+            // automatically-checked-out sources go.\n+            let result = source_workspace.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n                                                          id.short_name, id.version.to_str()));\n             to_try.push(result);\n-            to_try.push(workspace.push(\"src\").push_rel(&id.path));\n+            to_try.push(source_workspace.push(\"src\").push_rel(&id.path));\n+\n+            let result = build_dir.push(\"src\").push_rel(&id.path.pop()).push(format!(\"{}-{}\",\n+                                                         id.short_name, id.version.to_str()));\n+            to_try.push(result.clone());\n+            output_names.push(result);\n+            let other_result = build_dir.push(\"src\").push_rel(&id.path);\n+            to_try.push(other_result.clone());\n+            output_names.push(other_result);\n+\n         }\n \n         debug2!(\"Checking dirs: {:?}\", to_try.map(|s| s.to_str()).connect(\":\"));\n \n         let path = to_try.iter().find(|&d| os::path_exists(d));\n \n+        // See the comments on the definition of PkgSrc\n+        let mut build_in_destination = use_rust_path_hack;\n+        debug2!(\"1. build_in_destination = {:?}\", build_in_destination);\n+\n         let dir: Path = match path {\n             Some(d) => (*d).clone(),\n             None => {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n                 for (prefix, suffix) in id.prefixes_iter() {\n                     let package_id = PkgId::new(prefix.to_str());\n-                    let path = workspace.push(\"src\").push_rel(&package_id.path);\n+                    let path = build_dir.push_rel(&package_id.path);\n                     debug2!(\"in loop: checking if {} is a directory\", path.to_str());\n                     if os::path_is_dir(&path) {\n-                        let ps = PkgSrc::new(workspace.clone(),\n+                        let ps = PkgSrc::new(source_workspace,\n+                                             destination_workspace,\n                                              use_rust_path_hack,\n                                              PkgId::new(prefix.to_str()));\n-                        debug2!(\"pkgsrc: Returning [{}|{}|{}]\", workspace.to_str(),\n-                                ps.start_dir.push_rel(&suffix).to_str(), ps.id.to_str());\n-\n-                        return PkgSrc {\n-                            workspace: workspace,\n-                            start_dir: ps.start_dir.push_rel(&suffix),\n-                            id: ps.id,\n-                            libs: ~[],\n-                            mains: ~[],\n-                            tests: ~[],\n-                            benchs: ~[]\n+                        match ps {\n+                            PkgSrc {\n+                                source_workspace: source,\n+                                destination_workspace: destination,\n+                                start_dir: start,\n+                                id: id, _ } => {\n+                                let result = PkgSrc {\n+                                    source_workspace: source.clone(),\n+                                    build_in_destination: build_in_destination,\n+                                    destination_workspace: destination,\n+                                    start_dir: start.push_rel(&suffix),\n+                                    id: id,\n+                                    libs: ~[],\n+                                    mains: ~[],\n+                                    tests: ~[],\n+                                    benchs: ~[]\n+                                };\n+                                debug2!(\"pkgsrc: Returning {}\", result.to_str());\n+                                return result;\n+                            }\n                         }\n \n                     };\n                 }\n \n                 // Ok, no prefixes work, so try fetching from git\n                 let mut ok_d = None;\n-                for w in to_try.iter() {\n+                for w in output_names.iter() {\n                     debug2!(\"Calling fetch_git on {}\", w.to_str());\n-                    let gf = PkgSrc::fetch_git(w, &id);\n-                    for p in gf.iter() {\n+                    let target_dir_opt = PkgSrc::fetch_git(w, &id);\n+                    for p in target_dir_opt.iter() {\n                         ok_d = Some(p.clone());\n+                        build_in_destination = true;\n+                        debug2!(\"2. build_in_destination = {:?}\", build_in_destination);\n                         break;\n                     }\n-                    if ok_d.is_some() { break; }\n+                    match ok_d {\n+                        Some(ref d) => {\n+                            if d.is_parent_of(&id.path)\n+                                || d.is_parent_of(&versionize(&id.path, &id.version)) {\n+                                // Strip off the package ID\n+                                source_workspace = d.clone();\n+                                for _ in id.path.components().iter() {\n+                                    source_workspace = source_workspace.pop();\n+                                }\n+                                // Strip off the src/ part\n+                                source_workspace = source_workspace.pop();\n+                                // Strip off the build/<target-triple> part to get the workspace\n+                                destination_workspace = source_workspace.pop().pop();\n+                            }\n+                            break;\n+                        }\n+                        None => ()\n+                    }\n                 }\n                 match ok_d {\n                     Some(d) => d,\n@@ -138,18 +208,20 @@ impl PkgSrc {\n                 }\n             }\n         };\n+        debug2!(\"3. build_in_destination = {:?}\", build_in_destination);\n+        debug2!(\"source: {} dest: {}\", source_workspace.to_str(), destination_workspace.to_str());\n+\n         debug2!(\"For package id {}, returning {}\", id.to_str(), dir.to_str());\n \n         if !os::path_is_dir(&dir) {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n \n-        debug2!(\"pkgsrc: Returning \\\\{{}|{}|{}\\\\}\", workspace.to_str(),\n-               dir.to_str(), id.to_str());\n-\n         PkgSrc {\n-            workspace: workspace,\n+            source_workspace: source_workspace.clone(),\n+            build_in_destination: build_in_destination,\n+            destination_workspace: destination_workspace,\n             start_dir: dir,\n             id: id,\n             libs: ~[],\n@@ -165,56 +237,53 @@ impl PkgSrc {\n     /// refers to a git repo on the local version, also check it out.\n     /// (right now we only support git)\n     pub fn fetch_git(local: &Path, pkgid: &PkgId) -> Option<Path> {\n-        use conditions::failed_to_create_temp_dir::cond;\n+        use conditions::git_checkout_failed::cond;\n \n         // We use a temporary directory because if the git clone fails,\n         // it creates the target directory anyway and doesn't delete it\n \n-        let scratch_dir = extra::tempfile::mkdtemp(&os::tmpdir(), \"rustpkg\");\n-        let clone_target = match scratch_dir {\n-            Some(d) => d.push(\"rustpkg_temp\"),\n-            None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n-        };\n-\n         debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-               pkgid.to_str(), pkgid.path.to_str(),\n-               os::getcwd().to_str(),\n-               os::path_exists(&pkgid.path));\n-\n-        if os::path_exists(&pkgid.path) {\n-            debug2!(\"{} exists locally! Cloning it into {}\",\n-                   pkgid.path.to_str(), local.to_str());\n-            // Ok to use local here; we know it will succeed\n-            git_clone(&pkgid.path, local, &pkgid.version);\n-            return Some(local.clone());\n-        }\n+                pkgid.to_str(), pkgid.path.to_str(),\n+                os::getcwd().to_str(),\n+                os::path_exists(&pkgid.path));\n+\n+        match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n+            CheckedOutSources => {\n+                make_read_only(local);\n+                Some(local.clone())\n+            }\n+            DirToUse(clone_target) => {\n+                if pkgid.path.components().len() < 2 {\n+                    // If a non-URL, don't bother trying to fetch\n+                    return None;\n+                }\n \n-        if pkgid.path.components().len() < 2 {\n-            // If a non-URL, don't bother trying to fetch\n-            return None;\n-        }\n+                let url = format!(\"https://{}\", pkgid.path.to_str());\n+                debug2!(\"Fetching package: git clone {} {} [version={}]\",\n+                        url, clone_target.to_str(), pkgid.version.to_str());\n \n-        let url = format!(\"https://{}\", pkgid.path.to_str());\n-        debug2!(\"Fetching package: git clone {} {} [version={}]\",\n-                  url, clone_target.to_str(), pkgid.version.to_str());\n+                let mut failed = false;\n \n-        if git_clone_general(url, &clone_target, &pkgid.version) {\n-            // Since the operation succeeded, move clone_target to local.\n-            // First, create all ancestor directories.\n-            if make_dir_rwx_recursive(&local.pop())\n-                && os::rename_file(&clone_target, local) {\n-                 Some(local.clone())\n-            }\n-            else {\n-                 None\n+                do cond.trap(|_| {\n+                    failed = true;\n+                }).inside {\n+                    git_clone_url(url, &clone_target, &pkgid.version);\n+                };\n+\n+                if failed {\n+                    return None;\n+                }\n+\n+                // Move clone_target to local.\n+                // First, create all ancestor directories.\n+                let moved = make_dir_rwx_recursive(&local.pop())\n+                    && os::rename_file(&clone_target, local);\n+                if moved { Some(local.clone()) }\n+                    else { None }\n             }\n         }\n-        else {\n-            None\n-        }\n     }\n \n-\n     // If a file named \"pkg.rs\" in the start directory exists,\n     // return the path for it. Otherwise, None\n     pub fn package_script_option(&self) -> Option<Path> {\n@@ -292,7 +361,6 @@ impl PkgSrc {\n \n     fn build_crates(&self,\n                     ctx: &BuildContext,\n-                    destination_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n@@ -311,7 +379,7 @@ impl PkgSrc {\n                 let subpath_str = path_str.clone();\n                 let subcx = ctx.clone();\n                 let id = self.id.clone();\n-                let sub_dir = destination_dir.clone();\n+                let sub_dir = self.build_workspace().clone();\n                 let sub_flags = crate.flags.clone();\n                 do prep.exec |exec| {\n                     let result = compile_crate(&subcx,\n@@ -351,42 +419,30 @@ impl PkgSrc {\n     // Encodable.\n     pub fn build(&self,\n                  build_context: &BuildContext,\n-                 cfgs: ~[~str]) -> ~str {\n-        use conditions::not_a_workspace::cond;\n-\n-        // Determine the destination workspace (which depends on whether\n-        // we're using the rust_path_hack)\n-        let destination_workspace = if is_workspace(&self.workspace) {\n-            debug2!(\"{} is indeed a workspace\", self.workspace.to_str());\n-            self.workspace.clone()\n-        } else {\n-            // It would be nice to have only one place in the code that checks\n-            // for the use_rust_path_hack flag...\n-            if build_context.context.use_rust_path_hack {\n-                let rs = default_workspace();\n-                debug2!(\"Using hack: {}\", rs.to_str());\n-                rs\n-            } else {\n-                cond.raise(format!(\"Package root {} is not a workspace; pass in --rust_path_hack \\\n-                                        if you want to treat it as a package source\",\n-                                self.workspace.to_str()))\n-            }\n-        };\n-\n+                 cfgs: ~[~str]) {\n         let libs = self.libs.clone();\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n         debug2!(\"Building libs in {}, destination = {}\",\n-               destination_workspace.to_str(), destination_workspace.to_str());\n-        self.build_crates(build_context, &destination_workspace, libs, cfgs, Lib);\n+               self.source_workspace.to_str(), self.build_workspace().to_str());\n+        self.build_crates(build_context, libs, cfgs, Lib);\n         debug2!(\"Building mains\");\n-        self.build_crates(build_context, &destination_workspace, mains, cfgs, Main);\n+        self.build_crates(build_context, mains, cfgs, Main);\n         debug2!(\"Building tests\");\n-        self.build_crates(build_context, &destination_workspace, tests, cfgs, Test);\n+        self.build_crates(build_context, tests, cfgs, Test);\n         debug2!(\"Building benches\");\n-        self.build_crates(build_context, &destination_workspace, benchs, cfgs, Bench);\n-        destination_workspace.to_str()\n+        self.build_crates(build_context, benchs, cfgs, Bench);\n+    }\n+\n+    /// Return the workspace to put temporary files in. See the comment on `PkgSrc`\n+    pub fn build_workspace<'a>(&'a self) -> &'a Path {\n+        if self.build_in_destination {\n+            &self.destination_workspace\n+        }\n+        else {\n+            &self.source_workspace\n+        }\n     }\n \n     /// Debugging"}, {"sha": "fbb2255ad1ccb3684e585a05b0244c8f81230c75", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -16,6 +16,7 @@ pub use version::{Version, NoVersion, split_version_general, try_parsing_version\n pub use rustc::metadata::filesearch::rust_path;\n use rustc::driver::driver::host_triple;\n \n+use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os::mkdir_recursive;\n use std::os;\n@@ -447,9 +448,30 @@ pub fn user_set_rust_path() -> bool {\n }\n \n /// Append the version string onto the end of the path's filename\n-fn versionize(p: &Path, v: &Version) -> Path {\n+pub fn versionize(p: &Path, v: &Version) -> Path {\n     let q = p.file_path().to_str();\n     p.with_filename(format!(\"{}-{}\", q, v.to_str()))\n }\n \n \n+#[cfg(target_os = \"win32\")]\n+pub fn chmod_read_only(p: &Path) -> bool {\n+    #[fixed_stack_segment];\n+    unsafe {\n+        do p.to_str().with_c_str |src_buf| {\n+            libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_os = \"win32\"))]\n+pub fn chmod_read_only(p: &Path) -> bool {\n+    #[fixed_stack_segment];\n+    unsafe {\n+        do p.to_str().with_c_str |src_buf| {\n+            libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0\n+                as libc::c_int\n+        }\n+    }\n+}\n+"}, {"sha": "e6ce5ba9d499481b444ec2a4bfb078ea042ae3a3", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 71, "deletions": 75, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -39,8 +39,9 @@ use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n use path_util::{U_RWX, in_rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n-use source_control::is_git_dir;\n+use source_control::{CheckedOutSources, is_git_dir, make_read_only};\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n+use workspace::determine_destination;\n use context::{Context, BuildContext,\n                        RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n                        LLVMAssemble, LLVMCompileBitcode};\n@@ -183,7 +184,7 @@ pub trait CtxMethods {\n     /// Returns a pair of the selected package ID, and the destination workspace\n     fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)>;\n     /// Returns the destination workspace\n-    fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild) -> Path;\n+    fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild);\n     fn clean(&self, workspace: &Path, id: &PkgId);\n     fn info(&self);\n     /// Returns a pair. First component is a list of installed paths,\n@@ -208,34 +209,47 @@ impl CtxMethods for BuildContext {\n                 None if self.context.use_rust_path_hack => {\n                     let cwd = os::getcwd();\n                     let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n-                    let mut pkg_src = PkgSrc::new(cwd, true, pkgid);\n-                    let dest_ws = self.build(&mut pkg_src, what);\n-                    Some((pkg_src.id, dest_ws))\n+                    let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, pkgid);\n+                    self.build(&mut pkg_src, what);\n+                    match pkg_src {\n+                        PkgSrc { destination_workspace: ws,\n+                                 id: id, _ } => {\n+                            Some((id, ws))\n+                        }\n+                    }\n                 }\n                 None => { usage::build(); None }\n                 Some((ws, pkgid)) => {\n-                    let mut pkg_src = PkgSrc::new(ws, false, pkgid);\n-                    let dest_ws = self.build(&mut pkg_src, what);\n-                    Some((pkg_src.id, dest_ws))\n+                    let mut pkg_src = PkgSrc::new(ws.clone(), ws, false, pkgid);\n+                    self.build(&mut pkg_src, what);\n+                    match pkg_src {\n+                        PkgSrc { destination_workspace: ws,\n+                                 id: id, _ } => {\n+                            Some((id, ws))\n+                        }\n+                    }\n                 }\n             }\n         } else {\n             // The package id is presumed to be the first command-line\n             // argument\n             let pkgid = PkgId::new(args[0].clone());\n-            let mut dest_ws = None;\n+            let mut dest_ws = default_workspace();\n             do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                 debug2!(\"found pkg {} in workspace {}, trying to build\",\n                        pkgid.to_str(), workspace.to_str());\n-                let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n-                dest_ws = Some(self.build(&mut pkg_src, what));\n+                dest_ws = determine_destination(os::getcwd(),\n+                                                self.context.use_rust_path_hack,\n+                                                workspace);\n+                let mut pkg_src = PkgSrc::new(workspace.clone(), dest_ws.clone(),\n+                                              false, pkgid.clone());\n+                self.build(&mut pkg_src, what);\n                 true\n             };\n-            assert!(dest_ws.is_some());\n             // n.b. If this builds multiple packages, it only returns the workspace for\n             // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n             // anyway and there are no tests for it, so maybe take it out\n-            Some((pkgid, dest_ws.unwrap()))\n+            Some((pkgid, dest_ws))\n         }\n     }\n     fn run(&self, cmd: &str, args: ~[~str]) {\n@@ -278,11 +292,12 @@ impl CtxMethods for BuildContext {\n                             let cwd = os::getcwd();\n                             let inferred_pkgid =\n                                 PkgId::new(cwd.components[cwd.components.len() - 1]);\n-                            self.install(PkgSrc::new(cwd, true, inferred_pkgid), &Everything);\n+                            self.install(PkgSrc::new(cwd, default_workspace(),\n+                                                     true, inferred_pkgid), &Everything);\n                         }\n                         None  => { usage::install(); return; }\n                         Some((ws, pkgid))                => {\n-                            let pkg_src = PkgSrc::new(ws, false, pkgid);\n+                            let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, pkgid);\n                             self.install(pkg_src, &Everything);\n                       }\n                   }\n@@ -295,14 +310,17 @@ impl CtxMethods for BuildContext {\n                     debug2!(\"package ID = {}, found it in {:?} workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n-                        let rp = rust_path();\n-                        assert!(!rp.is_empty());\n-                        let src = PkgSrc::new(rp[0].clone(), false, pkgid.clone());\n+                        let d = default_workspace();\n+                        let src = PkgSrc::new(d.clone(), d, false, pkgid.clone());\n                         self.install(src, &Everything);\n                     }\n                     else {\n                         for workspace in workspaces.iter() {\n+                            let dest = determine_destination(os::getcwd(),\n+                                                             self.context.use_rust_path_hack,\n+                                                             workspace);\n                             let src = PkgSrc::new(workspace.clone(),\n+                                                  dest,\n                                                   self.context.use_rust_path_hack,\n                                                   pkgid.clone());\n                             self.install(src, &Everything);\n@@ -382,12 +400,10 @@ impl CtxMethods for BuildContext {\n         fail2!(\"`do` not yet implemented\");\n     }\n \n-    /// Returns the destination workspace\n-    /// In the case of a custom build, we don't know, so we just return the source workspace\n-    /// what_to_build says: \"Just build the lib.rs file in one subdirectory,\n-    /// don't walk anything recursively.\" Or else, everything.\n-    fn build(&self, pkg_src: &mut PkgSrc, what_to_build: &WhatToBuild) -> Path {\n-        let workspace = pkg_src.workspace.clone();\n+    fn build(&self, pkg_src: &mut PkgSrc, what_to_build: &WhatToBuild) {\n+        use conditions::git_checkout_failed::cond;\n+\n+        let workspace = pkg_src.source_workspace.clone();\n         let pkgid = pkg_src.id.clone();\n \n         debug2!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n@@ -399,12 +415,20 @@ impl CtxMethods for BuildContext {\n         // then clone it into the first entry in RUST_PATH, and repeat\n         if !in_rust_path(&workspace) && is_git_dir(&workspace.push_rel(&pkgid.path)) {\n             let out_dir = default_workspace().push(\"src\").push_rel(&pkgid.path);\n-            source_control::git_clone(&workspace.push_rel(&pkgid.path),\n-                                      &out_dir, &pkgid.version);\n+            let git_result = source_control::safe_git_clone(&workspace.push_rel(&pkgid.path),\n+                                                            &pkgid.version,\n+                                                            &out_dir);\n+            match git_result {\n+                CheckedOutSources => make_read_only(&out_dir),\n+                _ => cond.raise((pkgid.path.to_str(), out_dir.clone()))\n+            };\n             let default_ws = default_workspace();\n             debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.to_str(),\n                    pkgid.to_str());\n-            return self.build(&mut PkgSrc::new(default_ws, false, pkgid.clone()), what_to_build);\n+            return self.build(&mut PkgSrc::new(default_ws.clone(),\n+                                               default_ws,\n+                                               false,\n+                                               pkgid.clone()), what_to_build);\n         }\n \n         // Is there custom build logic? If so, use it\n@@ -469,17 +493,12 @@ impl CtxMethods for BuildContext {\n                         PkgSrc::push_crate(&mut pkg_src.benchs, 0, p);\n                     } else {\n                         warn(format!(\"Not building any crates for dependency {}\", p.to_str()));\n-                        return workspace.clone();\n+                        return;\n                     }\n                 }\n             }\n             // Build it!\n-            let rs_path = pkg_src.build(self, cfgs);\n-            Path(rs_path)\n-        }\n-        else {\n-            // Just return the source workspace\n-            workspace.clone()\n+            pkg_src.build(self, cfgs);\n         }\n     }\n \n@@ -509,11 +528,13 @@ impl CtxMethods for BuildContext {\n         let id = pkg_src.id.clone();\n \n         let mut installed_files = ~[];\n-        let inputs = ~[];\n+        let mut inputs = ~[];\n+\n+        debug2!(\"Installing package source: {}\", pkg_src.to_str());\n \n         // workcache only knows about *crates*. Building a package\n         // just means inferring all the crates in it, then building each one.\n-        let destination_workspace = self.build(&mut pkg_src, what).to_str();\n+        self.build(&mut pkg_src, what);\n \n         let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n                       pkg_src.tests.clone(), pkg_src.benchs.clone()];\n@@ -522,41 +543,35 @@ impl CtxMethods for BuildContext {\n             for c in cs.iter() {\n                 let path = pkg_src.start_dir.push_rel(&c.file).normalize();\n                 debug2!(\"Recording input: {}\", path.to_str());\n-                installed_files.push(path);\n+                inputs.push((~\"file\", path.to_str()));\n             }\n         }\n-        // See #7402: This still isn't quite right yet; we want to\n-        // install to the first workspace in the RUST_PATH if there's\n-        // a non-default RUST_PATH. This code installs to the same\n-        // workspace the package was built in.\n-        let actual_workspace = if path_util::user_set_rust_path() {\n-            default_workspace()\n-        }\n-            else {\n-            Path(destination_workspace)\n-        };\n-        debug2!(\"install: destination workspace = {}, id = {}, installing to {}\",\n-               destination_workspace, id.to_str(), actual_workspace.to_str());\n-        let result = self.install_no_build(&Path(destination_workspace),\n-                                           &actual_workspace,\n+\n+        let result = self.install_no_build(pkg_src.build_workspace(),\n+                                           &pkg_src.destination_workspace,\n                                            &id).map(|s| Path(*s));\n         debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n                id.to_str(), result.to_str());\n         installed_files = installed_files + result;\n-        note(format!(\"Installed package {} to {}\", id.to_str(), actual_workspace.to_str()));\n+        note(format!(\"Installed package {} to {}\",\n+                     id.to_str(),\n+                     pkg_src.destination_workspace.to_str()));\n         (installed_files, inputs)\n     }\n \n     // again, working around lack of Encodable for Path\n     fn install_no_build(&self,\n-                        source_workspace: &Path,\n+                        build_workspace: &Path,\n                         target_workspace: &Path,\n                         id: &PkgId) -> ~[~str] {\n         use conditions::copy_failed::cond;\n \n+        debug2!(\"install_no_build: assuming {} comes from {} with target {}\",\n+               id.to_str(), build_workspace.to_str(), target_workspace.to_str());\n+\n         // Now copy stuff into the install dirs\n-        let maybe_executable = built_executable_in_workspace(id, source_workspace);\n-        let maybe_library = built_library_in_workspace(id, source_workspace);\n+        let maybe_executable = built_executable_in_workspace(id, build_workspace);\n+        let maybe_library = built_library_in_workspace(id, build_workspace);\n         let target_exec = target_executable_in_workspace(id, target_workspace);\n         let target_lib = maybe_library.as_ref()\n             .map(|_| target_library_in_workspace(id, target_workspace));\n@@ -602,11 +617,11 @@ impl CtxMethods for BuildContext {\n                                              didn't install it!\", lib.to_str()));\n                     let target_lib = target_lib\n                         .pop().push(lib.filename().expect(\"weird target lib\"));\n-                    debug2!(\"Copying: {} -> {}\", lib.to_str(), sub_target_lib.to_str());\n                     if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                          os::copy_file(lib, &target_lib)) {\n                         cond.raise(((*lib).clone(), target_lib.clone()));\n                     }\n+                    debug2!(\"3. discovering output {}\", target_lib.to_str());\n                     exe_thing.discover_output(\"binary\",\n                                               target_lib.to_str(),\n                                               workcache_support::digest_only_date(&target_lib));\n@@ -841,25 +856,6 @@ pub fn main_args(args: &[~str]) -> int {\n     return 0;\n }\n \n-/**\n- * Get the working directory of the package script.\n- * Assumes that the package script has been compiled\n- * in is the working directory.\n- */\n-pub fn work_dir() -> Path {\n-    os::self_exe_path().unwrap()\n-}\n-\n-/**\n- * Get the source directory of the package (i.e.\n- * where the crates are located). Assumes\n- * that the cwd is changed to it before\n- * running this executable.\n- */\n-pub fn src_dir() -> Path {\n-    os::getcwd()\n-}\n-\n fn declare_package_script_dependency(prep: &mut workcache::Prep, pkg_src: &PkgSrc) {\n     match pkg_src.package_script_option() {\n         Some(ref p) => prep.declare_input(\"file\", p.to_str(),"}, {"sha": "877247bccadf72758a2711fe8234a641f13b3a4f", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -12,62 +12,99 @@\n \n use std::{io, os, run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n+use extra::tempfile;\n use version::*;\n+use path_util::chmod_read_only;\n \n-/// For a local git repo\n-pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n-    assert!(os::path_is_dir(source));\n-    assert!(is_git_dir(source));\n-    if !os::path_exists(target) {\n-        debug2!(\"Running: git clone {} {}\", source.to_str(), target.to_str());\n-        let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n-        if outp.status != 0 {\n-            io::println(str::from_utf8_owned(outp.output.clone()));\n-            io::println(str::from_utf8_owned(outp.error));\n-            fail2!(\"Couldn't `git clone` {}\", source.to_str());\n-        }\n-        else {\n-            match v {\n-                &ExactRevision(ref s) => {\n-                    debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n-                           *s, target.to_str(), target.push(\".git\").to_str());\n-                    let outp = run::process_output(\"git\",\n-                                   [format!(\"--work-tree={}\", target.to_str()),\n-                                    format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n-                                    ~\"checkout\", format!(\"{}\", *s)]);\n-                    if outp.status != 0 {\n-                        io::println(str::from_utf8_owned(outp.output.clone()));\n-                        io::println(str::from_utf8_owned(outp.error));\n-                        fail2!(\"Couldn't `git checkout {}` in {}\",\n-                              *s, target.to_str());\n+/// Attempts to clone `source`, a local git repository, into `target`, a local\n+/// directory that doesn't exist.\n+/// Returns `DirToUse(p)` if the clone fails, where `p` is a newly created temporary\n+/// directory (that the callee may use, for example, to check out remote sources into).\n+/// Returns `CheckedOutSources` if the clone succeeded.\n+pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n+    use conditions::failed_to_create_temp_dir::cond;\n+\n+    let scratch_dir = tempfile::mkdtemp(&os::tmpdir(), \"rustpkg\");\n+    let clone_target = match scratch_dir {\n+        Some(d) => d.push(\"rustpkg_temp\"),\n+        None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n+    };\n+\n+    if os::path_exists(source) {\n+        debug2!(\"{} exists locally! Cloning it into {}\",\n+                source.to_str(), target.to_str());\n+        // Ok to use target here; we know it will succeed\n+        assert!(os::path_is_dir(source));\n+        assert!(is_git_dir(source));\n+\n+        if !os::path_exists(target) {\n+            debug2!(\"Running: git clone {} {}\", source.to_str(), target.to_str());\n+            let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n+            if outp.status != 0 {\n+                io::println(str::from_utf8_owned(outp.output.clone()));\n+                io::println(str::from_utf8_owned(outp.error));\n+                return DirToUse(target.clone());\n+            }\n+                else {\n+                match v {\n+                    &ExactRevision(ref s) => {\n+                        debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n+                                *s, target.to_str(), target.push(\".git\").to_str());\n+                        let outp = run::process_output(\"git\",\n+                            [format!(\"--work-tree={}\", target.to_str()),\n+                             format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                             ~\"checkout\", format!(\"{}\", *s)]);\n+                        if outp.status != 0 {\n+                            io::println(str::from_utf8_owned(outp.output.clone()));\n+                            io::println(str::from_utf8_owned(outp.error));\n+                            return DirToUse(target.clone());\n+                        }\n                     }\n+                    _ => ()\n                 }\n-                _ => ()\n             }\n+        } else {\n+            // Check that no version was specified. There's no reason to not handle the\n+            // case where a version was requested, but I haven't implemented it.\n+            assert!(*v == NoVersion);\n+            debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n+                    target.to_str(), target.push(\".git\").to_str(), source.to_str());\n+            let args = [format!(\"--work-tree={}\", target.to_str()),\n+                        format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n+                        ~\"pull\", ~\"--no-edit\", source.to_str()];\n+            let outp = run::process_output(\"git\", args);\n+            assert!(outp.status == 0);\n         }\n-    }\n-    else {\n-        // Check that no version was specified. There's no reason to not handle the\n-        // case where a version was requested, but I haven't implemented it.\n-        assert!(*v == NoVersion);\n-        debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n-               target.to_str(), target.push(\".git\").to_str(), source.to_str());\n-        let args = [format!(\"--work-tree={}\", target.to_str()),\n-                    format!(\"--git-dir={}\", target.push(\".git\").to_str()),\n-                    ~\"pull\", ~\"--no-edit\", source.to_str()];\n-        let outp = run::process_output(\"git\", args);\n-        assert!(outp.status == 0);\n+        CheckedOutSources\n+    } else {\n+        DirToUse(clone_target)\n     }\n }\n \n+pub enum CloneResult {\n+    DirToUse(Path), // Created this empty directory to use as the temp dir for git\n+    CheckedOutSources // Successfully checked sources out into the given target dir\n+}\n+\n+pub fn make_read_only(target: &Path) {\n+    // Now, make all the files in the target dir read-only\n+    do os::walk_dir(target) |p| {\n+        if !os::path_is_dir(p) {\n+            assert!(chmod_read_only(p));\n+        };\n+        true\n+    };\n+}\n+\n /// Source can be either a URL or a local file path.\n-/// true if successful\n-pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n+pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n+    use conditions::git_checkout_failed::cond;\n+\n     let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n     if outp.status != 0 {\n          debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n          debug2!(\"{}\", str::from_utf8_owned(outp.error));\n-         false\n+         cond.raise((source.to_owned(), target.clone()))\n     }\n     else {\n         match v {\n@@ -77,15 +114,12 @@ pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n                     if outp.status != 0 {\n                         debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n                         debug2!(\"{}\", str::from_utf8_owned(outp.error));\n-                        false\n-                    }\n-                    else {\n-                        true\n+                        cond.raise((source.to_owned(), target.clone()))\n                     }\n-                }\n-                _ => true\n             }\n+            _ => ()\n         }\n+    }\n }\n \n fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput {"}, {"sha": "fea81abe0b6b84440b18ba6557ca3bd5cba25413", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 140, "deletions": 41, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -11,7 +11,7 @@\n // rustpkg unit tests\n \n use context::{BuildContext, Context, RustcFlags};\n-use std::{io, libc, os, run, str, task};\n+use std::{io, os, run, str, task};\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::mkdtemp;\n@@ -27,13 +27,15 @@ use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx, U_RWX,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n-               built_library_in_workspace, built_executable_in_workspace, target_build_dir};\n+               built_library_in_workspace, built_executable_in_workspace, target_build_dir,\n+               chmod_read_only};\n use rustc::back::link::get_cc_prog;\n use rustc::metadata::filesearch::rust_path;\n use rustc::driver::driver::{build_session, build_session_options, host_triple, optgroups};\n use syntax::diagnostic;\n use target::*;\n use package_source::PkgSrc;\n+use source_control::{CheckedOutSources, DirToUse, safe_git_clone};\n use util::datestamp;\n \n fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n@@ -83,6 +85,13 @@ fn writeFile(file_path: &Path, contents: &str) {\n     out.write_line(contents);\n }\n \n+fn mk_emptier_workspace(tag: &str) -> Path {\n+    let workspace = mkdtemp(&os::tmpdir(), tag).expect(\"couldn't create temp dir\");\n+    let package_dir = workspace.push(\"src\");\n+    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    workspace\n+}\n+\n fn mk_empty_workspace(short_name: &Path, version: &Version, tag: &str) -> Path {\n     let workspace_dir = mkdtemp(&os::tmpdir(), tag).expect(\"couldn't create temp dir\");\n     mk_workspace(&workspace_dir, short_name, version);\n@@ -192,6 +201,18 @@ fn is_rwx(p: &Path) -> bool {\n     }\n }\n \n+fn is_read_only(p: &Path) -> bool {\n+    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+\n+    match p.get_mode() {\n+        None => return false,\n+        Some(m) =>\n+            ((m & S_IRUSR as uint) == S_IRUSR as uint\n+            && (m & S_IWUSR as uint) == 0 as uint\n+            && (m & S_IXUSR as uint) == 0 as uint)\n+    }\n+}\n+\n fn test_sysroot() -> Path {\n     // Totally gross hack but it's just for test cases.\n     // Infer the sysroot from the exe name and pray that it's right.\n@@ -499,8 +520,8 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n                 Ok(w)  => w.write_line(\"/* hi */\")\n             }\n         }\n-        None => fail2!(format!(\"frob_source_file failed to find a source file in {}\",\n-                           pkg_src_dir.to_str()))\n+        None => fail2!(\"frob_source_file failed to find a source file in {}\",\n+                           pkg_src_dir.to_str())\n     }\n }\n \n@@ -528,7 +549,10 @@ fn test_install_valid() {\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n     debug2!(\"temp_workspace = {}\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n-    let src = PkgSrc::new(temp_workspace.clone(), false, temp_pkg_id.clone());\n+    let src = PkgSrc::new(temp_workspace.clone(),\n+                          temp_workspace.clone(),\n+                          false,\n+                          temp_pkg_id.clone());\n     ctxt.install(src, &Everything);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n@@ -557,7 +581,10 @@ fn test_install_invalid() {\n \n     // Uses task::try because of #9001\n     let result = do task::try {\n-        let pkg_src = PkgSrc::new(temp_workspace.clone(), false, pkgid.clone());\n+        let pkg_src = PkgSrc::new(temp_workspace.clone(),\n+                                  temp_workspace.clone(),\n+                                  false,\n+                                  pkgid.clone());\n         ctxt.install(pkg_src, &Everything);\n     };\n     // Not the best test -- doesn't test that we failed in the right way.\n@@ -568,8 +595,6 @@ fn test_install_invalid() {\n // Tests above should (maybe) be converted to shell out to rustpkg, too\n #[test]\n fn test_install_git() {\n-    let sysroot = test_sysroot();\n-    debug2!(\"sysroot = {}\", sysroot.to_str());\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     debug2!(\"repo = {}\", repo.to_str());\n@@ -724,12 +749,10 @@ fn test_package_request_version() {\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n             == repo.push_many([~\".rust\", ~\"bin\", ~\"test_pkg_version\"]));\n \n-    let dir = &repo.push_many([~\".rust\",\n-                               ~\"src\",\n-                               ~\"mockgithub.com\",\n-                               ~\"catamorphism\",\n-                               ~\"test_pkg_version-0.3\"]);\n-\n+    let dir = target_build_dir(&repo.push(\".rust\"))\n+        .push_rel(&Path(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n+    debug2!(\"dir = {}\", dir.to_str());\n+    assert!(os::path_is_dir(&dir));\n     assert!(os::path_exists(&dir.push(\"version-0.3-file.txt\")));\n     assert!(!os::path_exists(&dir.push(\"version-0.4-file.txt\")));\n }\n@@ -988,8 +1011,7 @@ fn no_rebuilding_dep() {\n         Fail(_) => fail2!(\"no_rebuilding_dep failed for some other reason\")\n     }\n \n-    let bar_date_2 = datestamp(&lib_output_file_name(&workspace,\n-                                                   \"bar\"));\n+    let bar_date_2 = datestamp(&bar_lib);\n     assert_eq!(bar_date_1, bar_date_2);\n }\n \n@@ -1713,13 +1735,11 @@ fn test_target_specific_install_dir() {\n }\n \n #[test]\n+#[ignore(reason = \"See #7240\")]\n fn test_dependencies_terminate() {\n- //   let a_id = PkgId::new(\"a\");\n     let b_id = PkgId::new(\"b\");\n-//    let workspace = create_local_package_with_dep(&b_id, &a_id);\n     let workspace = create_local_package(&b_id);\n     let b_dir = workspace.push_many([~\"src\", ~\"b-0.1\"]);\n-  //  writeFile(&b_dir.push(\"lib.rs\"), \"extern mod a; pub fn f() {}\");\n     let b_subdir = b_dir.push(\"test\");\n     assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n     writeFile(&b_subdir.push(\"test.rs\"),\n@@ -1860,6 +1880,107 @@ fn test_no_rebuilding() {\n     }\n }\n \n+#[test]\n+fn test_installed_read_only() {\n+    // Install sources from a \"remote\" (actually a local github repo)\n+    // Check that afterward, sources are read-only and installed under build/\n+    let temp_pkg_id = git_repo_pkg();\n+    let repo = init_git_repo(&temp_pkg_id.path);\n+    debug2!(\"repo = {}\", repo.to_str());\n+    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n+    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n+\n+    writeFile(&repo_subdir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n+\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n+\n+    let ws = repo.push(\".rust\");\n+    // Check that all files exist\n+    debug2!(\"Checking for files in {}\", ws.to_str());\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n+    debug2!(\"exec = {}\", exec.to_str());\n+    assert!(os::path_exists(&exec));\n+    assert!(is_rwx(&exec));\n+    let built_lib =\n+        built_library_in_workspace(&temp_pkg_id,\n+                                   &ws).expect(\"test_install_git: built lib should exist\");\n+    assert!(os::path_exists(&built_lib));\n+    assert!(is_rwx(&built_lib));\n+\n+    // Make sure sources are (a) under \"build\" and (b) read-only\n+    let src1 = target_build_dir(&ws).push_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n+    let src2 = target_build_dir(&ws).push_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n+    assert!(os::path_exists(&src1));\n+    assert!(os::path_exists(&src2));\n+    assert!(is_read_only(&src1));\n+    assert!(is_read_only(&src2));\n+}\n+\n+#[test]\n+fn test_installed_local_changes() {\n+    let temp_pkg_id = git_repo_pkg();\n+    let repo = init_git_repo(&temp_pkg_id.path);\n+    debug2!(\"repo = {}\", repo.to_str());\n+    let repo_subdir = repo.push_many([~\"mockgithub.com\", ~\"catamorphism\", ~\"test-pkg\"]);\n+    debug2!(\"repo_subdir = {}\", repo_subdir.to_str());\n+    assert!(os::mkdir_recursive(&repo.push_many([\".rust\", \"src\"]), U_RWX));\n+\n+    writeFile(&repo_subdir.push(\"main.rs\"),\n+              \"fn main() { let _x = (); }\");\n+    writeFile(&repo_subdir.push(\"lib.rs\"),\n+              \"pub fn f() { let _x = (); }\");\n+    add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n+\n+    command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n+\n+\n+    // We installed the dependency.\n+    // Now start a new workspace and clone it into it\n+    let hacking_workspace = mk_emptier_workspace(\"hacking_workspace\");\n+    let target_dir = hacking_workspace.push_many([~\"src\",\n+                                                  ~\"mockgithub.com\",\n+                                                  ~\"catamorphism\",\n+                                                  ~\"test-pkg-0.1\"]);\n+    debug2!(\"---- git clone {} {}\", repo_subdir.to_str(), target_dir.to_str());\n+\n+    let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n+\n+    match c_res {\n+        DirToUse(_) => fail2!(\"test_installed_local_changes failed\"),\n+        CheckedOutSources => ()\n+    };\n+\n+    // Make a local change to it\n+    writeFile(&target_dir.push(\"lib.rs\"),\n+              \"pub fn g() { let _x = (); }\");\n+\n+    // Finally, make *another* package that uses it\n+    let importer_pkg_id = fake_pkg();\n+    let main_subdir = create_local_package_in(&importer_pkg_id, &hacking_workspace);\n+    writeFile(&main_subdir.push(\"main.rs\"),\n+              \"extern mod test = \\\"mockgithub.com/catamorphism/test-pkg\\\"; \\\n+              use test::g;\n+              fn main() { g(); }\");\n+    // And make sure we can build it\n+\n+    command_line_test([~\"build\", importer_pkg_id.path.to_str()], &hacking_workspace);\n+}\n+\n+#[test]\n+fn test_7402() {\n+    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    let dest_workspace = mkdtemp(&os::tmpdir(), \"more_rust\").expect(\"test_7402\");\n+    let rust_path = Some(~[(~\"RUST_PATH\",\n+                            format!(\"{}:{}\", dest_workspace.to_str(), dir.to_str()))]);\n+    let cwd = os::getcwd();\n+    command_line_test_with_env([~\"install\", ~\"foo\"], &cwd, rust_path);\n+    assert_executable_exists(&dest_workspace, \"foo\");\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};\n@@ -1869,25 +1990,3 @@ fn is_executable(p: &Path) -> bool {\n         Some(mode) => mode & S_IXUSR as uint == S_IXUSR as uint\n     }\n }\n-\n-#[cfg(target_os = \"win32\")]\n-fn chmod_read_only(p: &Path) -> bool {\n-    #[fixed_stack_segment];\n-    unsafe {\n-        do p.to_str().with_c_str |src_buf| {\n-            libc::chmod(src_buf, libc::consts::os::posix88::S_IRUSR as c_int) == 0 as libc::c_int\n-        }\n-    }\n-}\n-\n-#[cfg(not(target_os = \"win32\"))]\n-fn chmod_read_only(p: &Path) -> bool {\n-    #[fixed_stack_segment];\n-    unsafe {\n-        do p.to_str().with_c_str |src_buf| {\n-            libc::chmod(src_buf,\n-                        libc::consts::os::posix88::S_IRUSR as libc::mode_t) == 0\n-                as libc::c_int\n-        }\n-    }\n-}"}, {"sha": "d66dd847405cf9d7c3051c6f4b1ad351da7ed14a", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -27,8 +27,8 @@ use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n-use path_util::{installed_library_in_workspace, U_RWX, system_library, target_build_dir};\n-use path_util::default_workspace;\n+use path_util::{U_RWX, system_library, target_build_dir};\n+use path_util::{default_workspace, built_library_in_workspace};\n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n@@ -298,14 +298,15 @@ pub fn compile_input(context: &BuildContext,\n                                           crate);\n     // Discover the output\n     let discovered_output = if what == Lib  {\n-        installed_library_in_workspace(&pkg_id.path, workspace)\n+        built_library_in_workspace(pkg_id, workspace) // Huh???\n     }\n     else {\n         result\n     };\n     debug2!(\"About to discover output {}\", discovered_output.to_str());\n     for p in discovered_output.iter() {\n         if os::path_exists(p) {\n+            debug2!(\"4. discovering output {}\", p.to_str());\n             exec.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n         }\n         // Nothing to do if it doesn't exist -- that could happen if we had the\n@@ -443,7 +444,13 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         let dest_workspace = if workspaces.is_empty() {\n                             default_workspace()\n                         } else { workspaces[0] };\n-                        let pkg_src = PkgSrc::new(dest_workspace,\n+                        // In this case, the source and destination workspaces are the same:\n+                        // Either it's a remote package, so the local sources don't exist\n+                        // and the `PkgSrc` constructor will detect that;\n+                        // or else it's already in a workspace and we'll build into that\n+                        // workspace\n+                        let pkg_src = PkgSrc::new(dest_workspace.clone(),\n+                                                  dest_workspace,\n                         // Use the rust_path_hack to search for dependencies iff\n                         // we were already using it\n                                                   self.context.context.use_rust_path_hack,\n@@ -453,14 +460,18 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         debug2!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n+                        debug2!(\"discovered outputs = {:?} discovered_inputs = {:?}\",\n+                               outputs_disc, inputs_disc);\n                         // It must have installed *something*...\n                         assert!(!outputs_disc.is_empty());\n-                        let target_workspace = outputs_disc[0].pop();\n                         for dep in outputs_disc.iter() {\n                             debug2!(\"Discovering a binary input: {}\", dep.to_str());\n                             self.exec.discover_input(\"binary\",\n                                                      dep.to_str(),\n                                                      digest_only_date(dep));\n+                            // Also, add an additional search path\n+                            debug2!(\"Installed {} into {}\", dep.to_str(), dep.pop().to_str());\n+                            (self.save)(dep.pop());\n                         }\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {\n@@ -477,9 +488,6 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                 fail2!(\"Bad kind: {}\", *what);\n                             }\n                         }\n-                        // Also, add an additional search path\n-                        debug2!(\"Installed {} into {}\", lib_name, target_workspace.to_str());\n-                        (self.save)(target_workspace);\n                     }\n                 }\n             }"}, {"sha": "d5dab15c02ac674c2f2741bbf556627bd0f14fb3", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8854b78b555d9a03a3b2ff248230696ec94e24c0/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=8854b78b555d9a03a3b2ff248230696ec94e24c0", "patch": "@@ -13,12 +13,11 @@\n use std::{os,util};\n use std::path::Path;\n use context::Context;\n-use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack};\n+use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack, default_workspace};\n+use path_util::rust_path;\n use util::option_to_vec;\n use package_id::PkgId;\n \n-use path_util::rust_path;\n-\n pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n@@ -75,3 +74,14 @@ pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {\n     }\n     None\n }\n+\n+/// If `workspace` is the same as `cwd`, and use_rust_path_hack is false,\n+/// return `workspace`; otherwise, return the first workspace in the RUST_PATH.\n+pub fn determine_destination(cwd: Path, use_rust_path_hack: bool, workspace: &Path) -> Path {\n+    if workspace == &cwd && !use_rust_path_hack {\n+        workspace.clone()\n+    }\n+    else {\n+        default_workspace()\n+    }\n+}"}]}