{"sha": "26aaf08ff4238b9117440f8717ab33a45ee45d4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YWFmMDhmZjQyMzhiOTExNzQ0MGY4NzE3YWIzM2E0NWVlNDVkNGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-17T23:53:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-17T23:53:07Z"}, "message": "rustc: Remove the impl map", "tree": {"sha": "4415d09ecca0abb19cbba4b19e4a45304a59a5c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4415d09ecca0abb19cbba4b19e4a45304a59a5c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26aaf08ff4238b9117440f8717ab33a45ee45d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26aaf08ff4238b9117440f8717ab33a45ee45d4e", "html_url": "https://github.com/rust-lang/rust/commit/26aaf08ff4238b9117440f8717ab33a45ee45d4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26aaf08ff4238b9117440f8717ab33a45ee45d4e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10c997a746178085b6b447a76e237dd08c5446fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c997a746178085b6b447a76e237dd08c5446fa", "html_url": "https://github.com/rust-lang/rust/commit/10c997a746178085b6b447a76e237dd08c5446fa"}], "stats": {"total": 191, "additions": 5, "deletions": 186}, "files": [{"sha": "46add230d9aa133b992855abb5ca028d445f7744", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=26aaf08ff4238b9117440f8717ab33a45ee45d4e", "patch": "@@ -177,7 +177,6 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let { def_map: def_map,\n           exp_map: exp_map,\n           exp_map2: exp_map2,\n-          impl_map: impl_map,\n           trait_map: trait_map } =\n         time(time_passes, ~\"resolution\", ||\n              middle::resolve3::resolve_crate(sess, lang_items, crate));\n@@ -232,9 +231,10 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     if upto == cu_no_trans { return {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n \n-    let maps = {mutbl_map: mutbl_map, root_map: root_map,\n+    let maps = {mutbl_map: mutbl_map,\n+                root_map: root_map,\n                 last_use_map: last_use_map,\n-                impl_map: impl_map, method_map: method_map,\n+                method_map: method_map,\n                 vtable_map: vtable_map};\n \n     let (llmod, link_meta) = time(time_passes, ~\"translation\", ||"}, {"sha": "2389f43b5d5385489c9d3531202d0ffd6dd62625", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=26aaf08ff4238b9117440f8717ab33a45ee45d4e", "patch": "@@ -46,7 +46,6 @@ type encode_parms = {\n     reachable: hashmap<ast::node_id, ()>,\n     reexports: ~[(~str, def_id)],\n     reexports2: middle::resolve3::ExportMap2,\n-    impl_map: fn@(ast::node_id) -> ~[(ident, def_id)],\n     item_symbols: hashmap<ast::node_id, ~str>,\n     discrim_symbols: hashmap<ast::node_id, ~str>,\n     link_meta: link_meta,\n@@ -60,7 +59,6 @@ enum encode_ctxt = {\n     reachable: hashmap<ast::node_id, ()>,\n     reexports: ~[(~str, def_id)],\n     reexports2: middle::resolve3::ExportMap2,\n-    impl_map: fn@(ast::node_id) -> ~[(ident, def_id)],\n     item_symbols: hashmap<ast::node_id, ~str>,\n     discrim_symbols: hashmap<ast::node_id, ~str>,\n     link_meta: link_meta,\n@@ -1049,7 +1047,6 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         reachable: parms.reachable,\n         reexports: parms.reexports,\n         reexports2: parms.reexports2,\n-        impl_map: parms.impl_map,\n         item_symbols: parms.item_symbols,\n         discrim_symbols: parms.discrim_symbols,\n         link_meta: parms.link_meta,"}, {"sha": "a25fe2872223b63ea8c125efce72c9afe8cf876a", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=26aaf08ff4238b9117440f8717ab33a45ee45d4e", "patch": "@@ -50,7 +50,6 @@ type maps = {\n     mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n     last_use_map: middle::liveness::last_use_map,\n-    impl_map: middle::resolve3::ImplMap,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n };\n@@ -727,9 +726,6 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    // impl_map is not used except when emitting metadata,\n-    // don't need to keep it.\n-\n     do option::iter(maps.method_map.find(id)) |mme| {\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);"}, {"sha": "cf2bc350d318c0b3dd14cc4f30155104242a2074", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 2, "deletions": 166, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=26aaf08ff4238b9117440f8717ab33a45ee45d4e", "patch": "@@ -84,9 +84,6 @@ type MethodInfo = {\n };\n \n type Impl = { did: def_id, ident: ident, methods: ~[@MethodInfo] };\n-type ImplScope = @~[@Impl];\n-type ImplScopes = @list<ImplScope>;\n-type ImplMap = hashmap<node_id,ImplScopes>;\n \n // Trait method resolution\n type TraitMap = @hashmap<node_id,@DVec<def_id>>;\n@@ -452,9 +449,6 @@ struct Module {\n     // The index of the import we're resolving.\n     let mut resolved_import_count: uint;\n \n-    // The list of implementation scopes, rooted from this module.\n-    let mut impl_scopes: ImplScopes;\n-\n     new(parent_link: ParentLink, def_id: option<def_id>) {\n         self.parent_link = parent_link;\n         self.def_id = def_id;\n@@ -469,8 +463,6 @@ struct Module {\n         self.import_resolutions = atom_hashmap();\n         self.glob_count = 0u;\n         self.resolved_import_count = 0u;\n-\n-        self.impl_scopes = @nil;\n     }\n \n     fn all_imports_resolved() -> bool {\n@@ -708,7 +700,6 @@ struct Resolver {\n     let namespaces: ~[Namespace];\n \n     let def_map: DefMap;\n-    let impl_map: ImplMap;\n     let export_map: ExportMap;\n     let export_map2: ExportMap2;\n     let trait_map: TraitMap;\n@@ -749,7 +740,6 @@ struct Resolver {\n         self.namespaces = ~[ ModuleNS, TypeNS, ValueNS, ImplNS ];\n \n         self.def_map = int_hash();\n-        self.impl_map = int_hash();\n         self.export_map = int_hash();\n         self.export_map2 = int_hash();\n         self.trait_map = @int_hash();\n@@ -766,9 +756,6 @@ struct Resolver {\n         self.record_exports();\n         self.session.abort_if_errors();\n \n-        self.build_impl_scopes();\n-        self.session.abort_if_errors();\n-\n         self.resolve_crate();\n         self.session.abort_if_errors();\n \n@@ -2809,106 +2796,6 @@ struct Resolver {\n         }\n     }\n \n-    // Implementation scope creation\n-    //\n-    // This is a fairly simple pass that simply gathers up all the typeclass\n-    // implementations in scope and threads a series of singly-linked series\n-    // of impls through the tree.\n-\n-    fn build_impl_scopes() {\n-        let root_module = (*self.graph_root).get_module();\n-        self.build_impl_scopes_for_module_subtree(root_module);\n-    }\n-\n-    fn build_impl_scopes_for_module_subtree(module_: @Module) {\n-        // If this isn't a local crate, then bail out. We don't need to\n-        // resolve implementations for external crates.\n-\n-        match module_.def_id {\n-            some(def_id) if def_id.crate == local_crate => {\n-                // OK. Continue.\n-            }\n-            none => {\n-                // Resolve implementation scopes for the root module.\n-            }\n-            some(_) => {\n-                // Bail out.\n-                debug!{\"(building impl scopes for module subtree) not \\\n-                        resolving implementations for `%s`\",\n-                       self.module_to_str(module_)};\n-                return;\n-            }\n-        }\n-\n-        self.build_impl_scope_for_module(module_);\n-\n-        for module_.children.each |_atom, child_name_bindings| {\n-            match (*child_name_bindings).get_module_if_available() {\n-                none => {\n-                    // Nothing to do.\n-                }\n-                some(child_module) => {\n-                    self.build_impl_scopes_for_module_subtree(child_module);\n-                }\n-            }\n-        }\n-\n-        for module_.anonymous_children.each |_node_id, child_module| {\n-            self.build_impl_scopes_for_module_subtree(child_module);\n-        }\n-    }\n-\n-    fn build_impl_scope_for_module(module_: @Module) {\n-        let mut impl_scope = ~[];\n-\n-        debug!{\"(building impl scope for module) processing module %s (%?)\",\n-               self.module_to_str(module_),\n-               copy module_.def_id};\n-\n-        // Gather up all direct children implementations in the module.\n-        for module_.children.each |_impl_name, child_name_bindings| {\n-            if child_name_bindings.impl_defs.len() >= 1u {\n-                impl_scope += child_name_bindings.impl_defs;\n-            }\n-        }\n-\n-        debug!{\"(building impl scope for module) found %u impl(s) as direct \\\n-                children\",\n-               impl_scope.len()};\n-\n-        // Gather up all imports.\n-        for module_.import_resolutions.each |_impl_name, import_resolution| {\n-            for (*import_resolution.impl_target).each |impl_target| {\n-                debug!{\"(building impl scope for module) found impl def\"};\n-                impl_scope += impl_target.bindings.impl_defs;\n-            }\n-        }\n-\n-        debug!{\"(building impl scope for module) found %u impl(s) in total\",\n-               impl_scope.len()};\n-\n-        // Determine the parent's implementation scope.\n-        let mut parent_impl_scopes;\n-        match module_.parent_link {\n-            NoParentLink => {\n-                parent_impl_scopes = @nil;\n-            }\n-            ModuleParentLink(parent_module_node, _) |\n-            BlockParentLink(parent_module_node, _) => {\n-                parent_impl_scopes = parent_module_node.impl_scopes;\n-            }\n-        }\n-\n-        // Create the new implementation scope, if it was nonempty, and chain\n-        // it up to the parent.\n-\n-        if impl_scope.len() >= 1u {\n-            module_.impl_scopes = @cons(@impl_scope, parent_impl_scopes);\n-        } else {\n-            module_.impl_scopes = parent_impl_scopes;\n-        }\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs.\n@@ -3095,11 +2982,6 @@ struct Resolver {\n     fn resolve_crate() unsafe {\n         debug!{\"(resolving crate) starting\"};\n \n-        // To avoid a failure in metadata encoding later, we have to add the\n-        // crate-level implementation scopes\n-\n-        self.impl_map.insert(0, (*self.graph_root).get_module().impl_scopes);\n-\n         // XXX: This is awful!\n         let this = ptr::addr_of(self);\n         visit_crate(*self.crate, (), mk_vt(@{\n@@ -3669,8 +3551,6 @@ struct Resolver {\n \n         // Write the implementations in scope into the module metadata.\n         debug!{\"(resolving module) resolving module ID %d\", id};\n-        self.impl_map.insert(id, self.current_module.impl_scopes);\n-\n         visit_mod(module_, span, id, (), visitor);\n     }\n \n@@ -4385,13 +4265,8 @@ struct Resolver {\n     }\n \n     fn resolve_expr(expr: @expr, visitor: ResolveVisitor) {\n-        // First, write the implementations in scope into a table if the\n-        // expression might need them.\n-\n-        self.record_impls_for_expr_if_necessary(expr);\n-\n-        // Then record candidate traits for this expression if it could result\n-        // in the invocation of a method call.\n+        // First, record candidate traits for this expression if it could\n+        // result in the invocation of a method call.\n \n         self.record_candidate_traits_for_expr_if_necessary(expr);\n \n@@ -4506,19 +4381,6 @@ struct Resolver {\n         }\n     }\n \n-    fn record_impls_for_expr_if_necessary(expr: @expr) {\n-        match expr.node {\n-            expr_field(*) | expr_path(*) | expr_cast(*) | expr_binary(*) |\n-            expr_unary(*) | expr_assign_op(*) | expr_index(*) => {\n-                self.impl_map.insert(expr.id,\n-                                     self.current_module.impl_scopes);\n-            }\n-            _ => {\n-                // Nothing to do.\n-            }\n-        }\n-    }\n-\n     fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n         match expr.node {\n             expr_field(_, ident, _) => {\n@@ -4855,38 +4717,13 @@ struct Resolver {\n                    module_repr, value_repr, type_repr, impl_repr};\n         }\n     }\n-\n-    fn dump_impl_scopes(impl_scopes: ImplScopes) {\n-        debug!{\"Dump of impl scopes:\"};\n-\n-        let mut i = 0u;\n-        let mut impl_scopes = impl_scopes;\n-        loop {\n-            match *impl_scopes {\n-                cons(impl_scope, rest_impl_scopes) => {\n-                    debug!{\"Impl scope %u:\", i};\n-\n-                    for (*impl_scope).each |implementation| {\n-                        debug!{\"Impl: %s\", *implementation.ident};\n-                    }\n-\n-                    i += 1u;\n-                    impl_scopes = rest_impl_scopes;\n-                }\n-                nil => {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n }\n \n /// Entry point to crate resolution.\n fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n               -> { def_map: DefMap,\n                    exp_map: ExportMap,\n                    exp_map2: ExportMap2,\n-                   impl_map: ImplMap,\n                    trait_map: TraitMap } {\n \n     let resolver = @Resolver(session, lang_items, crate);\n@@ -4895,7 +4732,6 @@ fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n         def_map: resolver.def_map,\n         exp_map: resolver.export_map,\n         exp_map2: resolver.export_map2,\n-        impl_map: resolver.impl_map,\n         trait_map: resolver.trait_map\n     };\n }"}, {"sha": "d4eb0ff806b551911dd425c8d0eb15f29c95a4ad", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aaf08ff4238b9117440f8717ab33a45ee45d4e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=26aaf08ff4238b9117440f8717ab33a45ee45d4e", "patch": "@@ -5645,7 +5645,6 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         reachable: cx.reachable,\n         reexports: reexports(cx),\n         reexports2: cx.exp_map2,\n-        impl_map: |a| impl_map(cx, a),\n         item_symbols: cx.item_symbols,\n         discrim_symbols: cx.discrim_symbols,\n         link_meta: cx.link_meta,\n@@ -5669,15 +5668,6 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         }\n         return reexports;\n     }\n-\n-    fn impl_map(cx: @crate_ctxt,\n-                id: ast::node_id) -> ~[(ast::ident, ast::def_id)] {\n-        let mut result = ~[];\n-        for list::each(cx.maps.impl_map.get(id)) |impls| {\n-            vec::push_all(result, (*impls).map(|i| (i.ident, i.did)));\n-        }\n-        return result;\n-    }\n }\n \n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {"}]}