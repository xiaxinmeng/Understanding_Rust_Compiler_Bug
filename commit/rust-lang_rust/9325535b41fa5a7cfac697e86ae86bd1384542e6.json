{"sha": "9325535b41fa5a7cfac697e86ae86bd1384542e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMjU1MzViNDFmYTVhN2NmYWM2OTdlODZhZTg2YmQxMzg0NTQyZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T05:31:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T05:31:22Z"}, "message": "auto merge of #7978 : sstewartgallus/rust/rename_arc, r=bblum\n\nTo be more specific:\r\n\r\n`UPPERCASETYPE` was changed to `UppercaseType`\r\n`type_new` was changed to `Type::new`\r\n`type_function(value)` was changed to `value.method()`", "tree": {"sha": "f28193aa80d78d16efd25cf319fbd8b604125173", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f28193aa80d78d16efd25cf319fbd8b604125173"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9325535b41fa5a7cfac697e86ae86bd1384542e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9325535b41fa5a7cfac697e86ae86bd1384542e6", "html_url": "https://github.com/rust-lang/rust/commit/9325535b41fa5a7cfac697e86ae86bd1384542e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9325535b41fa5a7cfac697e86ae86bd1384542e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3078e83c3f1a643ddbdefa78095e4fbda3cecc02", "url": "https://api.github.com/repos/rust-lang/rust/commits/3078e83c3f1a643ddbdefa78095e4fbda3cecc02", "html_url": "https://github.com/rust-lang/rust/commit/3078e83c3f1a643ddbdefa78095e4fbda3cecc02"}, {"sha": "39b3a0561f06b1ea01a12d8fc3372334116a7833", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b3a0561f06b1ea01a12d8fc3372334116a7833", "html_url": "https://github.com/rust-lang/rust/commit/39b3a0561f06b1ea01a12d8fc3372334116a7833"}], "stats": {"total": 851, "additions": 427, "deletions": 424}, "files": [{"sha": "1315dbf65b2cdf90e2405bbe2a1d7331f2a31215", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -135,7 +135,7 @@ msgstr \"\"\n #. type: Bullet: '* '\n #: doc/tutorial-tasks.md:56\n msgid \"\"\n-\"[`extra::arc`] - The ARC (atomically reference counted) type, for safely \"\n+\"[`extra::arc`] - The Arc (atomically reference counted) type, for safely \"\n \"sharing immutable data,\"\n msgstr \"\"\n \n@@ -597,7 +597,7 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-tasks.md:338\n-msgid \"## Sharing immutable data without copy: ARC\"\n+msgid \"## Sharing immutable data without copy: Arc\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -613,18 +613,18 @@ msgstr \"\"\n #: doc/tutorial-tasks.md:347\n msgid \"\"\n \"To tackle this issue, one can use an Atomically Reference Counted wrapper \"\n-\"(`ARC`) as implemented in the `extra` library of Rust. With an ARC, the data \"\n-\"will no longer be copied for each task. The ARC acts as a reference to the \"\n+\"(`Arc`) as implemented in the `extra` library of Rust. With an Arc, the data \"\n+\"will no longer be copied for each task. The Arc acts as a reference to the \"\n \"shared data and only this reference is shared and cloned.\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-tasks.md:355\n msgid \"\"\n-\"Here is a small example showing how to use ARCs. We wish to run concurrently \"\n+\"Here is a small example showing how to use Arcs. We wish to run concurrently \"\n \"several computations on a single large vector of floats. Each task needs the \"\n \"full vector to perform its duty.  ~~~ # use std::vec; # use std::uint; # use \"\n-\"std::rand; use extra::arc::ARC;\"\n+\"std::rand; use extra::arc::Arc;\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -648,7 +648,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial-tasks.md:365\n #, no-wrap\n-msgid \"    let numbers_arc = ARC(numbers);\\n\"\n+msgid \"    let numbers_arc = Arc::new(numbers);\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -665,7 +665,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"        do spawn {\\n\"\n-\"            let local_arc : ARC<~[float]> = port.recv();\\n\"\n+\"            let local_arc : Arc<~[float]> = port.recv();\\n\"\n \"            let task_numbers = local_arc.get();\\n\"\n \"            println(fmt!(\\\"%u-norm = %?\\\", num, pnorm(task_numbers, num)));\\n\"\n \"        }\\n\"\n@@ -679,31 +679,31 @@ msgstr \"\"\n msgid \"\"\n \"The function `pnorm` performs a simple computation on the vector (it \"\n \"computes the sum of its items at the power given as argument and takes the \"\n-\"inverse power of this value). The ARC on the vector is created by the line \"\n-\"~~~ # use extra::arc::ARC; # use std::vec; # use std::rand; # let numbers = \"\n+\"inverse power of this value). The Arc on the vector is created by the line \"\n+\"~~~ # use extra::arc::Arc; # use std::vec; # use std::rand; # let numbers = \"\n \"vec::from_fn(1000000, |_| rand::random::<float>()); let \"\n-\"numbers_arc=ARC(numbers); ~~~ and a clone of it is sent to each task ~~~ # \"\n-\"use extra::arc::ARC; # use std::vec; # use std::rand; # let numbers=vec::\"\n+\"numbers_arc=Arc::new(numbers); ~~~ and a clone of it is sent to each task ~~~ # \"\n+\"use extra::arc::Arc; # use std::vec; # use std::rand; # let numbers=vec::\"\n \"from_fn(1000000, |_| rand::random::<float>()); # let numbers_arc = \"\n-\"ARC(numbers); # let (port, chan)  = stream(); chan.send(numbers_arc.\"\n+\"Arc::new(numbers); # let (port, chan)  = stream(); chan.send(numbers_arc.\"\n \"clone()); ~~~ copying only the wrapper and not its contents.\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-tasks.md:414\n msgid \"\"\n-\"Each task recovers the underlying data by ~~~ # use extra::arc::ARC; # use \"\n+\"Each task recovers the underlying data by ~~~ # use extra::arc::Arc; # use \"\n \"std::vec; # use std::rand; # let numbers=vec::from_fn(1000000, |_| rand::\"\n-\"random::<float>()); # let numbers_arc=ARC(numbers); # let (port, chan)  = \"\n-\"stream(); # chan.send(numbers_arc.clone()); # let local_arc : ARC<~[float]> \"\n+\"random::<float>()); # let numbers_arc=Arc::new(numbers); # let (port, chan)  = \"\n+\"stream(); # chan.send(numbers_arc.clone()); # let local_arc : Arc<~[float]> \"\n \"= port.recv(); let task_numbers = local_arc.get(); ~~~ and can use it as if \"\n \"it were local.\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-tasks.md:416\n msgid \"\"\n-\"The `arc` module also implements ARCs around mutable data that are not \"\n+\"The `arc` module also implements Arcs around mutable data that are not \"\n \"covered here.\"\n msgstr \"\"\n "}, {"sha": "2b48bd63fff3ab4748bd3ac3eb6896a6a239764c", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -50,7 +50,7 @@ concurrency at this writing:\n * [`std::pipes`] - The underlying messaging infrastructure,\n * [`extra::comm`] - Additional messaging types based on `std::pipes`,\n * [`extra::sync`] - More exotic synchronization tools, including locks,\n-* [`extra::arc`] - The ARC (atomically reference counted) type,\n+* [`extra::arc`] - The Arc (atomically reference counted) type,\n   for safely sharing immutable data,\n * [`extra::future`] - A type representing values that may be computed concurrently and retrieved at a later time.\n \n@@ -334,24 +334,24 @@ fn main() {\n }\n ~~~\n \n-## Sharing immutable data without copy: ARC\n+## Sharing immutable data without copy: Arc\n \n To share immutable data between tasks, a first approach would be to only use pipes as we have seen\n previously. A copy of the data to share would then be made for each task. In some cases, this would\n add up to a significant amount of wasted memory and would require copying the same data more than\n necessary.\n \n-To tackle this issue, one can use an Atomically Reference Counted wrapper (`ARC`) as implemented in\n-the `extra` library of Rust. With an ARC, the data will no longer be copied for each task. The ARC\n+To tackle this issue, one can use an Atomically Reference Counted wrapper (`Arc`) as implemented in\n+the `extra` library of Rust. With an Arc, the data will no longer be copied for each task. The Arc\n acts as a reference to the shared data and only this reference is shared and cloned.\n \n-Here is a small example showing how to use ARCs. We wish to run concurrently several computations on\n+Here is a small example showing how to use Arcs. We wish to run concurrently several computations on\n a single large vector of floats. Each task needs the full vector to perform its duty.\n ~~~\n # use std::vec;\n # use std::uint;\n # use std::rand;\n-use extra::arc::ARC;\n+use extra::arc::Arc;\n \n fn pnorm(nums: &~[float], p: uint) -> float {\n     nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as float)) ).pow(&(1f / (p as float)))\n@@ -361,14 +361,14 @@ fn main() {\n     let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n     println(fmt!(\"Inf-norm = %?\",  *numbers.iter().max().unwrap()));\n \n-    let numbers_arc = ARC(numbers);\n+    let numbers_arc = Arc::new(numbers);\n \n     for uint::range(1,10) |num| {\n         let (port, chan)  = stream();\n         chan.send(numbers_arc.clone());\n \n         do spawn {\n-            let local_arc : ARC<~[float]> = port.recv();\n+            let local_arc : Arc<~[float]> = port.recv();\n             let task_numbers = local_arc.get();\n             println(fmt!(\"%u-norm = %?\", num, pnorm(task_numbers, num)));\n         }\n@@ -377,42 +377,42 @@ fn main() {\n ~~~\n \n The function `pnorm` performs a simple computation on the vector (it computes the sum of its items\n-at the power given as argument and takes the inverse power of this value). The ARC on the vector is\n+at the power given as argument and takes the inverse power of this value). The Arc on the vector is\n created by the line\n ~~~\n-# use extra::arc::ARC;\n+# use extra::arc::Arc;\n # use std::vec;\n # use std::rand;\n # let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\n-let numbers_arc=ARC(numbers);\n+let numbers_arc=Arc::new(numbers);\n ~~~\n and a clone of it is sent to each task\n ~~~\n-# use extra::arc::ARC;\n+# use extra::arc::Arc;\n # use std::vec;\n # use std::rand;\n # let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n-# let numbers_arc = ARC(numbers);\n+# let numbers_arc = Arc::new(numbers);\n # let (port, chan)  = stream();\n chan.send(numbers_arc.clone());\n ~~~\n copying only the wrapper and not its contents.\n \n Each task recovers the underlying data by\n ~~~\n-# use extra::arc::ARC;\n+# use extra::arc::Arc;\n # use std::vec;\n # use std::rand;\n # let numbers=vec::from_fn(1000000, |_| rand::random::<float>());\n-# let numbers_arc=ARC(numbers);\n+# let numbers_arc=Arc::new(numbers);\n # let (port, chan)  = stream();\n # chan.send(numbers_arc.clone());\n-# let local_arc : ARC<~[float]> = port.recv();\n+# let local_arc : Arc<~[float]> = port.recv();\n let task_numbers = local_arc.get();\n ~~~\n and can use it as if it were local.\n \n-The `arc` module also implements ARCs around mutable data that are not covered here.\n+The `arc` module also implements Arcs around mutable data that are not covered here.\n \n # Handling task failure\n "}, {"sha": "9479e47ed8c9db45719ed725bba0cb2dd6c78797", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 111, "deletions": 110, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -15,13 +15,13 @@\n  * # Example\n  *\n  * In this example, a large vector of floats is shared between several tasks.\n- * With simple pipes, without ARC, a copy would have to be made for each task.\n+ * With simple pipes, without Arc, a copy would have to be made for each task.\n  *\n  * ~~~ {.rust}\n  * extern mod std;\n  * use extra::arc;\n  * let numbers=vec::from_fn(100, |ind| (ind as float)*rand::random());\n- * let shared_numbers=arc::ARC(numbers);\n+ * let shared_numbers=arc::Arc::new(numbers);\n  *\n  *   for 10.times {\n  *       let (port, chan)  = stream();\n@@ -41,7 +41,7 @@\n \n \n use sync;\n-use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n+use sync::{Mutex, RWLock};\n \n use std::cast;\n use std::unstable::sync::UnsafeAtomicRcBox;\n@@ -56,12 +56,12 @@ pub struct Condvar<'self> {\n }\n \n impl<'self> Condvar<'self> {\n-    /// Atomically exit the associated ARC and block until a signal is sent.\n+    /// Atomically exit the associated Arc and block until a signal is sent.\n     #[inline]\n     pub fn wait(&self) { self.wait_on(0) }\n \n     /**\n-     * Atomically exit the associated ARC and block on a specified condvar\n+     * Atomically exit the associated Arc and block on a specified condvar\n      * until a signal is sent on that same condvar (as sync::cond.wait_on).\n      *\n      * wait() is equivalent to wait_on(0).\n@@ -104,37 +104,38 @@ impl<'self> Condvar<'self> {\n }\n \n /****************************************************************************\n- * Immutable ARC\n+ * Immutable Arc\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-pub struct ARC<T> { priv x: UnsafeAtomicRcBox<T> }\n+pub struct Arc<T> { priv x: UnsafeAtomicRcBox<T> }\n \n-/// Create an atomically reference counted wrapper.\n-pub fn ARC<T:Freeze + Send>(data: T) -> ARC<T> {\n-    ARC { x: UnsafeAtomicRcBox::new(data) }\n-}\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-impl<T:Freeze+Send> ARC<T> {\n+impl<T:Freeze+Send> Arc<T> {\n+    /// Create an atomically reference counted wrapper.\n+    pub fn new(data: T) -> Arc<T> {\n+        Arc { x: UnsafeAtomicRcBox::new(data) }\n+    }\n+\n     pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n \n     /**\n-     * Retrieve the data back out of the ARC. This function blocks until the\n+     * Retrieve the data back out of the Arc. This function blocks until the\n      * reference given to it is the last existing one, and then unwrap the data\n      * instead of destroying it.\n      *\n      * If multiple tasks call unwrap, all but the first will fail. Do not call\n-     * unwrap from a task that holds another reference to the same ARC; it is\n+     * unwrap from a task that holds another reference to the same Arc; it is\n      * guaranteed to deadlock.\n      */\n     pub fn unwrap(self) -> T {\n-        let ARC { x: x } = self;\n+        let Arc { x: x } = self;\n         unsafe { x.unwrap() }\n     }\n }\n@@ -146,47 +147,48 @@ impl<T:Freeze+Send> ARC<T> {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-impl<T:Freeze + Send> Clone for ARC<T> {\n-    fn clone(&self) -> ARC<T> {\n-        ARC { x: self.x.clone() }\n+impl<T:Freeze + Send> Clone for Arc<T> {\n+    fn clone(&self) -> Arc<T> {\n+        Arc { x: self.x.clone() }\n     }\n }\n \n /****************************************************************************\n- * Mutex protected ARC (unsafe)\n+ * Mutex protected Arc (unsafe)\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct MutexARCInner<T> { priv lock: Mutex, priv failed: bool, priv data: T }\n-/// An ARC with mutable data protected by a blocking mutex.\n-struct MutexARC<T> { priv x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n+struct MutexArcInner<T> { priv lock: Mutex, priv failed: bool, priv data: T }\n+/// An Arc with mutable data protected by a blocking mutex.\n+struct MutexArc<T> { priv x: UnsafeAtomicRcBox<MutexArcInner<T>> }\n \n-/// Create a mutex-protected ARC with the supplied data.\n-pub fn MutexARC<T:Send>(user_data: T) -> MutexARC<T> {\n-    mutex_arc_with_condvars(user_data, 1)\n-}\n-/**\n- * Create a mutex-protected ARC with the supplied data and a specified number\n- * of condvars (as sync::mutex_with_condvars).\n- */\n-pub fn mutex_arc_with_condvars<T:Send>(user_data: T,\n-                                    num_condvars: uint) -> MutexARC<T> {\n-    let data =\n-        MutexARCInner { lock: mutex_with_condvars(num_condvars),\n-                          failed: false, data: user_data };\n-    MutexARC { x: UnsafeAtomicRcBox::new(data) }\n-}\n \n-impl<T:Send> Clone for MutexARC<T> {\n-    /// Duplicate a mutex-protected ARC, as arc::clone.\n-    fn clone(&self) -> MutexARC<T> {\n+impl<T:Send> Clone for MutexArc<T> {\n+    /// Duplicate a mutex-protected Arc, as arc::clone.\n+    fn clone(&self) -> MutexArc<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n         // count would be exactly the same as the shared state's.\n-        MutexARC { x: self.x.clone() }\n+        MutexArc { x: self.x.clone() }\n     }\n }\n \n-impl<T:Send> MutexARC<T> {\n+impl<T:Send> MutexArc<T> {\n+    /// Create a mutex-protected Arc with the supplied data.\n+    pub fn new(user_data: T) -> MutexArc<T> {\n+        MutexArc::new_with_condvars(user_data, 1)\n+    }\n+\n+    /**\n+     * Create a mutex-protected Arc with the supplied data and a specified number\n+     * of condvars (as sync::Mutex::new_with_condvars).\n+     */\n+    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> MutexArc<T> {\n+        let data = MutexArcInner {\n+            lock: Mutex::new_with_condvars(num_condvars),\n+            failed: false, data: user_data\n+        };\n+        MutexArc { x: UnsafeAtomicRcBox::new(data) }\n+    }\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -195,19 +197,19 @@ impl<T:Send> MutexARC<T> {\n      * finishes running.\n      *\n      * The reason this function is 'unsafe' is because it is possible to\n-     * construct a circular reference among multiple ARCs by mutating the\n+     * construct a circular reference among multiple Arcs by mutating the\n      * underlying data. This creates potential for deadlock, but worse, this\n-     * will guarantee a memory leak of all involved ARCs. Using mutex ARCs\n-     * inside of other ARCs is safe in absence of circular references.\n+     * will guarantee a memory leak of all involved Arcs. Using mutex Arcs\n+     * inside of other Arcs is safe in absence of circular references.\n      *\n      * If you wish to nest mutex_arcs, one strategy for ensuring safety at\n      * runtime is to add a \"nesting level counter\" inside the stored data, and\n      * when traversing the arcs, assert that they monotonically decrease.\n      *\n      * # Failure\n      *\n-     * Failing while inside the ARC will unlock the ARC while unwinding, so\n-     * that other tasks won't block forever. It will also poison the ARC:\n+     * Failing while inside the Arc will unlock the Arc while unwinding, so\n+     * that other tasks won't block forever. It will also poison the Arc:\n      * any tasks that subsequently try to access it (including those already\n      * blocked on the mutex) will also fail immediately.\n      */\n@@ -247,11 +249,11 @@ impl<T:Send> MutexARC<T> {\n      * Will additionally fail if another task has failed while accessing the arc.\n      */\n     pub fn unwrap(self) -> T {\n-        let MutexARC { x: x } = self;\n+        let MutexArc { x: x } = self;\n         let inner = unsafe { x.unwrap() };\n-        let MutexARCInner { failed: failed, data: data, _ } = inner;\n+        let MutexArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail!(~\"Can't unwrap poisoned MutexARC - another task failed inside!\");\n+            fail!(~\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n         }\n         data\n     }\n@@ -263,7 +265,7 @@ impl<T:Send> MutexARC<T> {\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n-            fail!(\"Poisoned MutexARC - another task failed inside!\");\n+            fail!(\"Poisoned MutexArc - another task failed inside!\");\n         } else {\n             fail!(\"Poisoned rw_arc - another task failed inside!\");\n         }\n@@ -294,60 +296,59 @@ fn PoisonOnFail<'r>(failed: &'r mut bool) -> PoisonOnFail {\n }\n \n /****************************************************************************\n- * R/W lock protected ARC\n+ * R/W lock protected Arc\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct RWARCInner<T> { priv lock: RWlock, priv failed: bool, priv data: T }\n+struct RWArcInner<T> { priv lock: RWLock, priv failed: bool, priv data: T }\n /**\n- * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n+ * A dual-mode Arc protected by a reader-writer lock. The data can be accessed\n  * mutably or immutably, and immutably-accessing tasks may run concurrently.\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n #[no_freeze]\n-struct RWARC<T> {\n-    priv x: UnsafeAtomicRcBox<RWARCInner<T>>,\n+struct RWArc<T> {\n+    priv x: UnsafeAtomicRcBox<RWArcInner<T>>,\n }\n \n-/// Create a reader/writer ARC with the supplied data.\n-pub fn RWARC<T:Freeze + Send>(user_data: T) -> RWARC<T> {\n-    rw_arc_with_condvars(user_data, 1)\n-}\n-/**\n- * Create a reader/writer ARC with the supplied data and a specified number\n- * of condvars (as sync::rwlock_with_condvars).\n- */\n-pub fn rw_arc_with_condvars<T:Freeze + Send>(\n-    user_data: T,\n-    num_condvars: uint) -> RWARC<T>\n-{\n-    let data =\n-        RWARCInner { lock: rwlock_with_condvars(num_condvars),\n-                     failed: false, data: user_data };\n-    RWARC { x: UnsafeAtomicRcBox::new(data), }\n-}\n-\n-impl<T:Freeze + Send> RWARC<T> {\n-    /// Duplicate a rwlock-protected ARC, as arc::clone.\n-    pub fn clone(&self) -> RWARC<T> {\n-        RWARC {\n+impl<T:Freeze + Send> RWArc<T> {\n+    /// Duplicate a rwlock-protected Arc, as arc::clone.\n+    pub fn clone(&self) -> RWArc<T> {\n+        RWArc {\n             x: self.x.clone(),\n         }\n     }\n \n }\n \n-impl<T:Freeze + Send> RWARC<T> {\n+impl<T:Freeze + Send> RWArc<T> {\n+    /// Create a reader/writer Arc with the supplied data.\n+    pub fn new(user_data: T) -> RWArc<T> {\n+        RWArc::new_with_condvars(user_data, 1)\n+    }\n+\n+    /**\n+     * Create a reader/writer Arc with the supplied data and a specified number\n+     * of condvars (as sync::RWLock::new_with_condvars).\n+     */\n+    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWArc<T> {\n+        let data = RWArcInner {\n+            lock: RWLock::new_with_condvars(num_condvars),\n+            failed: false, data: user_data\n+        };\n+        RWArc { x: UnsafeAtomicRcBox::new(data), }\n+    }\n+\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n      *\n      * # Failure\n      *\n-     * Failing while inside the ARC will unlock the ARC while unwinding, so\n-     * that other tasks won't block forever. As MutexARC.access, it will also\n-     * poison the ARC, so subsequent readers and writers will both also fail.\n+     * Failing while inside the Arc will unlock the Arc while unwinding, so\n+     * that other tasks won't block forever. As MutexArc.access, it will also\n+     * poison the Arc, so subsequent readers and writers will both also fail.\n      */\n     #[inline]\n     pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n@@ -385,8 +386,8 @@ impl<T:Freeze + Send> RWARC<T> {\n      *\n      * # Failure\n      *\n-     * Failing will unlock the ARC while unwinding. However, unlike all other\n-     * access modes, this will not poison the ARC.\n+     * Failing will unlock the Arc while unwinding. However, unlike all other\n+     * access modes, this will not poison the Arc.\n      */\n     pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         unsafe {\n@@ -467,11 +468,11 @@ impl<T:Freeze + Send> RWARC<T> {\n      * in write mode.\n      */\n     pub fn unwrap(self) -> T {\n-        let RWARC { x: x, _ } = self;\n+        let RWArc { x: x, _ } = self;\n         let inner = unsafe { x.unwrap() };\n-        let RWARCInner { failed: failed, data: data, _ } = inner;\n+        let RWArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail!(~\"Can't unwrap poisoned RWARC - another task failed inside!\")\n+            fail!(~\"Can't unwrap poisoned RWArc - another task failed inside!\")\n         }\n         data\n     }\n@@ -481,25 +482,25 @@ impl<T:Freeze + Send> RWARC<T> {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T:Freeze + Send>(state: *mut RWARCInner<T>) -> *RWlock {\n+fn borrow_rwlock<T:Freeze + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n     unsafe { cast::transmute(&(*state).lock) }\n }\n \n-/// The \"write permission\" token used for RWARC.write_downgrade().\n+/// The \"write permission\" token used for RWArc.write_downgrade().\n pub struct RWWriteMode<'self, T> {\n     data: &'self mut T,\n-    token: sync::RWlockWriteMode<'self>,\n+    token: sync::RWLockWriteMode<'self>,\n     poison: PoisonOnFail,\n }\n \n-/// The \"read permission\" token used for RWARC.write_downgrade().\n+/// The \"read permission\" token used for RWArc.write_downgrade().\n pub struct RWReadMode<'self, T> {\n     data: &'self T,\n-    token: sync::RWlockReadMode<'self>,\n+    token: sync::RWLockReadMode<'self>,\n }\n \n impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n-    /// Access the pre-downgrade RWARC in write mode.\n+    /// Access the pre-downgrade RWArc in write mode.\n     pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n             RWWriteMode {\n@@ -514,7 +515,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n         }\n     }\n \n-    /// Access the pre-downgrade RWARC in write mode with a condvar.\n+    /// Access the pre-downgrade RWArc in write mode with a condvar.\n     pub fn write_cond<'x, 'c, U>(&mut self,\n                                  blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                                  -> U {\n@@ -570,15 +571,15 @@ mod tests {\n     #[test]\n     fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = ARC(v);\n+        let arc_v = Arc::new(v);\n \n         let (p, c) = comm::stream();\n \n         do task::spawn() || {\n             let p = comm::PortSet::new();\n             c.send(p.chan());\n \n-            let arc_v : ARC<~[int]> = p.recv();\n+            let arc_v : Arc<~[int]> = p.recv();\n \n             let v = (*arc_v.get()).clone();\n             assert_eq!(v[3], 4);\n@@ -596,7 +597,7 @@ mod tests {\n     #[test]\n     fn test_mutex_arc_condvar() {\n         unsafe {\n-            let arc = ~MutexARC(false);\n+            let arc = ~MutexArc::new(false);\n             let arc2 = ~arc.clone();\n             let (p,c) = comm::oneshot();\n             let (c,p) = (Cell::new(c), Cell::new(p));\n@@ -620,7 +621,7 @@ mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_arc_condvar_poison() {\n         unsafe {\n-            let arc = ~MutexARC(1);\n+            let arc = ~MutexArc::new(1);\n             let arc2 = ~arc.clone();\n             let (p, c) = comm::stream();\n \n@@ -644,7 +645,7 @@ mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_mutex_arc_poison() {\n         unsafe {\n-            let arc = ~MutexARC(1);\n+            let arc = ~MutexArc::new(1);\n             let arc2 = ~arc.clone();\n             do task::try || {\n                 do arc2.access |one| {\n@@ -658,7 +659,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_mutex_arc_unwrap_poison() {\n-        let arc = MutexARC(1);\n+        let arc = MutexArc::new(1);\n         let arc2 = ~(&arc).clone();\n         let (p, c) = comm::stream();\n         do task::spawn {\n@@ -675,7 +676,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_wr() {\n-        let arc = ~RWARC(1);\n+        let arc = ~RWArc::new(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write |one| {\n@@ -688,7 +689,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_ww() {\n-        let arc = ~RWARC(1);\n+        let arc = ~RWArc::new(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write |one| {\n@@ -701,7 +702,7 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_dw() {\n-        let arc = ~RWARC(1);\n+        let arc = ~RWArc::new(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write_downgrade |mut write_mode| {\n@@ -716,7 +717,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = ~RWARC(1);\n+        let arc = ~RWArc::new(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.read |one| {\n@@ -729,7 +730,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = ~RWARC(1);\n+        let arc = ~RWArc::new(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.read |one| {\n@@ -742,7 +743,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_dr() {\n-        let arc = ~RWARC(1);\n+        let arc = ~RWArc::new(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n             do arc2.write_downgrade |write_mode| {\n@@ -758,7 +759,7 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc() {\n-        let arc = ~RWARC(0);\n+        let arc = ~RWArc::new(0);\n         let arc2 = (*arc).clone();\n         let (p,c) = comm::stream();\n \n@@ -806,7 +807,7 @@ mod tests {\n         // (4) tells writer and all other readers to contend as it downgrades.\n         // (5) Writer attempts to set state back to 42, while downgraded task\n         //     and all reader tasks assert that it's 31337.\n-        let arc = ~RWARC(0);\n+        let arc = ~RWArc::new(0);\n \n         // Reader tasks\n         let mut reader_convos = ~[];\n@@ -884,10 +885,10 @@ mod tests {\n         // the sync module rather than this one, but it's here because an\n         // rwarc gives us extra shared state to help check for the race.\n         // If you want to see this test fail, go to sync.rs and replace the\n-        // line in RWlock::write_cond() that looks like:\n+        // line in RWLock::write_cond() that looks like:\n         //     \"blk(&Condvar { order: opt_lock, ..*cond })\"\n         // with just \"blk(cond)\".\n-        let x = ~RWARC(true);\n+        let x = ~RWArc::new(true);\n         let (wp, wc) = comm::stream();\n \n         // writer task"}, {"sha": "743c4347a4b4a36571b907d5cbfdc5e9756aec33", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 168, "deletions": 166, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -19,7 +19,7 @@\n use std::borrow;\n use std::comm;\n use std::task;\n-use std::unstable::sync::{Exclusive, exclusive, UnsafeAtomicRcBox};\n+use std::unstable::sync::{Exclusive, UnsafeAtomicRcBox};\n use std::unstable::atomics;\n use std::util;\n \n@@ -34,48 +34,47 @@ type WaitEnd = comm::PortOne<()>;\n type SignalEnd = comm::ChanOne<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct Waitqueue { head: comm::Port<SignalEnd>,\n+struct WaitQueue { head: comm::Port<SignalEnd>,\n                    tail: comm::Chan<SignalEnd> }\n \n-#[doc(hidden)]\n-fn new_waitqueue() -> Waitqueue {\n-    let (block_head, block_tail) = comm::stream();\n-    Waitqueue { head: block_head, tail: block_tail }\n-}\n+impl WaitQueue {\n+    fn new() -> WaitQueue {\n+        let (block_head, block_tail) = comm::stream();\n+        WaitQueue { head: block_head, tail: block_tail }\n+    }\n \n-// Signals one live task from the queue.\n-#[doc(hidden)]\n-fn signal_waitqueue(q: &Waitqueue) -> bool {\n-    // The peek is mandatory to make sure recv doesn't block.\n-    if q.head.peek() {\n-        // Pop and send a wakeup signal. If the waiter was killed, its port\n-        // will have closed. Keep trying until we get a live task.\n-        if comm::try_send_one(q.head.recv(), ()) {\n-            true\n+    // Signals one live task from the queue.\n+    fn signal(&self) -> bool {\n+        // The peek is mandatory to make sure recv doesn't block.\n+        if self.head.peek() {\n+            // Pop and send a wakeup signal. If the waiter was killed, its port\n+            // will have closed. Keep trying until we get a live task.\n+            if comm::try_send_one(self.head.recv(), ()) {\n+                true\n+            } else {\n+                self.signal()\n+            }\n         } else {\n-            signal_waitqueue(q)\n+            false\n         }\n-    } else {\n-        false\n     }\n-}\n \n-#[doc(hidden)]\n-fn broadcast_waitqueue(q: &Waitqueue) -> uint {\n-    let mut count = 0;\n-    while q.head.peek() {\n-        if comm::try_send_one(q.head.recv(), ()) {\n-            count += 1;\n+    fn broadcast(&self) -> uint {\n+        let mut count = 0;\n+        while self.head.peek() {\n+            if comm::try_send_one(self.head.recv(), ()) {\n+                count += 1;\n+            }\n         }\n+        count\n     }\n-    count\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n #[doc(hidden)]\n struct SemInner<Q> {\n     count: int,\n-    waiters:   Waitqueue,\n+    waiters:   WaitQueue,\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n     blocked:   Q\n@@ -84,23 +83,14 @@ struct SemInner<Q> {\n #[doc(hidden)]\n struct Sem<Q>(Exclusive<SemInner<Q>>);\n \n-#[doc(hidden)]\n-fn new_sem<Q:Send>(count: int, q: Q) -> Sem<Q> {\n-    Sem(exclusive(SemInner {\n-        count: count, waiters: new_waitqueue(), blocked: q }))\n-}\n-#[doc(hidden)]\n-fn new_sem_and_signal(count: int, num_condvars: uint)\n-        -> Sem<~[Waitqueue]> {\n-    let mut queues = ~[];\n-    for num_condvars.times {\n-        queues.push(new_waitqueue());\n-    }\n-    new_sem(count, queues)\n-}\n \n #[doc(hidden)]\n impl<Q:Send> Sem<Q> {\n+    fn new(count: int, q: Q) -> Sem<Q> {\n+        Sem(Exclusive::new(SemInner {\n+            count: count, waiters: WaitQueue::new(), blocked: q }))\n+    }\n+\n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n@@ -129,7 +119,7 @@ impl<Q:Send> Sem<Q> {\n             do (**self).with |state| {\n                 state.count += 1;\n                 if state.count <= 0 {\n-                    signal_waitqueue(&state.waiters);\n+                    state.waiters.signal();\n                 }\n             }\n         }\n@@ -151,7 +141,16 @@ impl Sem<()> {\n }\n \n #[doc(hidden)]\n-impl Sem<~[Waitqueue]> {\n+impl Sem<~[WaitQueue]> {\n+    fn new_and_signal(count: int, num_condvars: uint)\n+        -> Sem<~[WaitQueue]> {\n+        let mut queues = ~[];\n+        for num_condvars.times {\n+            queues.push(WaitQueue::new());\n+        }\n+        Sem::new(count, queues)\n+    }\n+\n     pub fn access_waitqueue<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n@@ -168,7 +167,7 @@ impl Sem<~[Waitqueue]> {\n #[doc(hidden)]\n type SemRelease<'self> = SemReleaseGeneric<'self, ()>;\n #[doc(hidden)]\n-type SemAndSignalRelease<'self> = SemReleaseGeneric<'self, ~[Waitqueue]>;\n+type SemAndSignalRelease<'self> = SemReleaseGeneric<'self, ~[WaitQueue]>;\n #[doc(hidden)]\n struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n \n@@ -188,7 +187,7 @@ fn SemRelease<'r>(sem: &'r Sem<()>) -> SemRelease<'r> {\n }\n \n #[doc(hidden)]\n-fn SemAndSignalRelease<'r>(sem: &'r Sem<~[Waitqueue]>)\n+fn SemAndSignalRelease<'r>(sem: &'r Sem<~[WaitQueue]>)\n                         -> SemAndSignalRelease<'r> {\n     SemReleaseGeneric {\n         sem: sem\n@@ -207,7 +206,7 @@ enum ReacquireOrderLock<'self> {\n pub struct Condvar<'self> {\n     // The 'Sem' object associated with this condvar. This is the one that's\n     // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n-    priv sem: &'self Sem<~[Waitqueue]>,\n+    priv sem: &'self Sem<~[WaitQueue]>,\n     // This is (can be) an extra semaphore which is held around the reacquire\n     // operation on the first one. This is only used in cvars associated with\n     // rwlocks, and is needed to ensure that, when a downgrader is trying to\n@@ -257,7 +256,7 @@ impl<'self> Condvar<'self> {\n                         // Drop the lock.\n                         state.count += 1;\n                         if state.count <= 0 {\n-                            signal_waitqueue(&state.waiters);\n+                            state.waiters.signal();\n                         }\n                         // Enqueue ourself to be woken up by a signaller.\n                         let SignalEnd = SignalEnd.take_unwrap();\n@@ -288,7 +287,7 @@ impl<'self> Condvar<'self> {\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct CondvarReacquire<'self> {\n-            sem: &'self Sem<~[Waitqueue]>,\n+            sem: &'self Sem<~[WaitQueue]>,\n             order: ReacquireOrderLock<'self>,\n         }\n \n@@ -322,7 +321,7 @@ impl<'self> Condvar<'self> {\n             let mut result = false;\n             do (**self.sem).with |state| {\n                 if condvar_id < state.blocked.len() {\n-                    result = signal_waitqueue(&state.blocked[condvar_id]);\n+                    result = state.blocked[condvar_id].signal();\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n@@ -347,14 +346,14 @@ impl<'self> Condvar<'self> {\n                     // swap it out with the old one, and broadcast on the\n                     // old one outside of the little-lock.\n                     queue = Some(util::replace(&mut state.blocked[condvar_id],\n-                                               new_waitqueue()));\n+                                               WaitQueue::new()));\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n             }\n             do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n                 let queue = queue.take_unwrap();\n-                broadcast_waitqueue(&queue)\n+                queue.broadcast()\n             }\n         }\n     }\n@@ -376,7 +375,7 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-impl Sem<~[Waitqueue]> {\n+impl Sem<~[WaitQueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n@@ -393,10 +392,6 @@ impl Sem<~[Waitqueue]> {\n /// A counting, blocking, bounded-waiting semaphore.\n struct Semaphore { priv sem: Sem<()> }\n \n-/// Create a new semaphore with the specified count.\n-pub fn semaphore(count: int) -> Semaphore {\n-    Semaphore { sem: new_sem(count, ()) }\n-}\n \n impl Clone for Semaphore {\n     /// Create a new handle to the semaphore.\n@@ -406,6 +401,11 @@ impl Clone for Semaphore {\n }\n \n impl Semaphore {\n+    /// Create a new semaphore with the specified count.\n+    pub fn new(count: int) -> Semaphore {\n+        Semaphore { sem: Sem::new(count, ()) }\n+    }\n+\n     /**\n      * Acquire a resource represented by the semaphore. Blocks if necessary\n      * until resource(s) become available.\n@@ -434,26 +434,28 @@ impl Semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-pub struct Mutex { priv sem: Sem<~[Waitqueue]> }\n-\n-/// Create a new mutex, with one associated condvar.\n-pub fn Mutex() -> Mutex { mutex_with_condvars(1) }\n-/**\n- * Create a new mutex, with a specified number of associated condvars. This\n- * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n- * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n- * any operations on the condvar will fail.)\n- */\n-pub fn mutex_with_condvars(num_condvars: uint) -> Mutex {\n-    Mutex { sem: new_sem_and_signal(1, num_condvars) }\n-}\n+pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n \n impl Clone for Mutex {\n     /// Create a new handle to the mutex.\n     fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n }\n \n impl Mutex {\n+    /// Create a new mutex, with one associated condvar.\n+    pub fn new() -> Mutex { Mutex::new_with_condvars(1) }\n+\n+    /**\n+    * Create a new mutex, with a specified number of associated condvars. This\n+    * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n+    * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n+    * any operations on the condvar will fail.)\n+    */\n+    pub fn new_with_condvars(num_condvars: uint) -> Mutex {\n+        Mutex { sem: Sem::new_and_signal(1, num_condvars) }\n+    }\n+\n+\n     /// Run a function with ownership of the mutex.\n     pub fn lock<U>(&self, blk: &fn() -> U) -> U {\n         (&self.sem).access_waitqueue(blk)\n@@ -472,7 +474,7 @@ impl Mutex {\n // NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n \n #[doc(hidden)]\n-struct RWlockInner {\n+struct RWLockInner {\n     // You might ask, \"Why don't you need to use an atomic for the mode flag?\"\n     // This flag affects the behaviour of readers (for plain readers, they\n     // assert on it; for downgraders, they use it to decide which mode to\n@@ -499,33 +501,33 @@ struct RWlockInner {\n  * A task which fails while holding an rwlock will unlock the rwlock as it\n  * unwinds.\n  */\n-pub struct RWlock {\n+pub struct RWLock {\n     priv order_lock:  Semaphore,\n-    priv access_lock: Sem<~[Waitqueue]>,\n-    priv state:       UnsafeAtomicRcBox<RWlockInner>,\n+    priv access_lock: Sem<~[WaitQueue]>,\n+    priv state:       UnsafeAtomicRcBox<RWLockInner>,\n }\n \n-/// Create a new rwlock, with one associated condvar.\n-pub fn RWlock() -> RWlock { rwlock_with_condvars(1) }\n+impl RWLock {\n+    /// Create a new rwlock, with one associated condvar.\n+    pub fn new() -> RWLock { RWLock::new_with_condvars(1) }\n \n-/**\n- * Create a new rwlock, with a specified number of associated condvars.\n- * Similar to mutex_with_condvars.\n- */\n-pub fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n-    let state = UnsafeAtomicRcBox::new(RWlockInner {\n-        read_mode:  false,\n-        read_count: atomics::AtomicUint::new(0),\n-    });\n-    RWlock { order_lock:  semaphore(1),\n-             access_lock: new_sem_and_signal(1, num_condvars),\n-             state:       state, }\n-}\n+    /**\n+    * Create a new rwlock, with a specified number of associated condvars.\n+    * Similar to mutex_with_condvars.\n+    */\n+    pub fn new_with_condvars(num_condvars: uint) -> RWLock {\n+        let state = UnsafeAtomicRcBox::new(RWLockInner {\n+            read_mode:  false,\n+            read_count: atomics::AtomicUint::new(0),\n+        });\n+        RWLock { order_lock:  Semaphore::new(1),\n+                access_lock: Sem::new_and_signal(1, num_condvars),\n+                state:       state, }\n+    }\n \n-impl RWlock {\n     /// Create a new handle to the rwlock.\n-    pub fn clone(&self) -> RWlock {\n-        RWlock { order_lock:  (&(self.order_lock)).clone(),\n+    pub fn clone(&self) -> RWLock {\n+        RWLock { order_lock:  (&(self.order_lock)).clone(),\n                  access_lock: Sem((*self.access_lock).clone()),\n                  state:       self.state.clone() }\n     }\n@@ -546,7 +548,7 @@ impl RWlock {\n                         state.read_mode = true;\n                     }\n                 }\n-                release = Some(RWlockReleaseRead(self));\n+                release = Some(RWLockReleaseRead(self));\n             }\n         }\n         blk()\n@@ -638,7 +640,7 @@ impl RWlock {\n      * }\n      * ~~~\n      */\n-    pub fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: &fn(v: RWLockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -648,14 +650,14 @@ impl RWlock {\n                 (&self.access_lock).acquire();\n                 (&self.order_lock).release();\n             }\n-            _release = Some(RWlockReleaseDowngrade(self));\n+            _release = Some(RWLockReleaseDowngrade(self));\n         }\n-        blk(RWlockWriteMode { lock: self })\n+        blk(RWLockWriteMode { lock: self })\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    pub fn downgrade<'a>(&self, token: RWlockWriteMode<'a>)\n-                         -> RWlockReadMode<'a> {\n+    pub fn downgrade<'a>(&self, token: RWLockWriteMode<'a>)\n+                         -> RWLockReadMode<'a> {\n         if !borrow::ref_eq(self, token.lock) {\n             fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n@@ -679,19 +681,19 @@ impl RWlock {\n                 }\n             }\n         }\n-        RWlockReadMode { lock: token.lock }\n+        RWLockReadMode { lock: token.lock }\n     }\n }\n \n // FIXME(#3588) should go inside of read()\n #[doc(hidden)]\n-struct RWlockReleaseRead<'self> {\n-    lock: &'self RWlock,\n+struct RWLockReleaseRead<'self> {\n+    lock: &'self RWLock,\n }\n \n #[doc(hidden)]\n #[unsafe_destructor]\n-impl<'self> Drop for RWlockReleaseRead<'self> {\n+impl<'self> Drop for RWLockReleaseRead<'self> {\n     fn drop(&self) {\n         unsafe {\n             do task::unkillable {\n@@ -713,22 +715,22 @@ impl<'self> Drop for RWlockReleaseRead<'self> {\n }\n \n #[doc(hidden)]\n-fn RWlockReleaseRead<'r>(lock: &'r RWlock) -> RWlockReleaseRead<'r> {\n-    RWlockReleaseRead {\n+fn RWLockReleaseRead<'r>(lock: &'r RWLock) -> RWLockReleaseRead<'r> {\n+    RWLockReleaseRead {\n         lock: lock\n     }\n }\n \n // FIXME(#3588) should go inside of downgrade()\n #[doc(hidden)]\n #[unsafe_destructor]\n-struct RWlockReleaseDowngrade<'self> {\n-    lock: &'self RWlock,\n+struct RWLockReleaseDowngrade<'self> {\n+    lock: &'self RWLock,\n }\n \n #[doc(hidden)]\n #[unsafe_destructor]\n-impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n+impl<'self> Drop for RWLockReleaseDowngrade<'self> {\n     fn drop(&self) {\n         unsafe {\n             do task::unkillable {\n@@ -762,36 +764,36 @@ impl<'self> Drop for RWlockReleaseDowngrade<'self> {\n }\n \n #[doc(hidden)]\n-fn RWlockReleaseDowngrade<'r>(lock: &'r RWlock)\n-                           -> RWlockReleaseDowngrade<'r> {\n-    RWlockReleaseDowngrade {\n+fn RWLockReleaseDowngrade<'r>(lock: &'r RWLock)\n+                           -> RWLockReleaseDowngrade<'r> {\n+    RWLockReleaseDowngrade {\n         lock: lock\n     }\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockWriteMode<'self> { priv lock: &'self RWlock }\n+pub struct RWLockWriteMode<'self> { priv lock: &'self RWLock }\n #[unsafe_destructor]\n-impl<'self> Drop for RWlockWriteMode<'self> { fn drop(&self) {} }\n+impl<'self> Drop for RWLockWriteMode<'self> { fn drop(&self) {} }\n \n /// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWlockReadMode<'self> { priv lock: &'self RWlock }\n+pub struct RWLockReadMode<'self> { priv lock: &'self RWLock }\n #[unsafe_destructor]\n-impl<'self> Drop for RWlockReadMode<'self> { fn drop(&self) {} }\n+impl<'self> Drop for RWLockReadMode<'self> { fn drop(&self) {} }\n \n-impl<'self> RWlockWriteMode<'self> {\n+impl<'self> RWLockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n     pub fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n     pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         // Need to make the condvar use the order lock when reacquiring the\n-        // access lock. See comment in RWlock::write_cond for why.\n+        // access lock. See comment in RWLock::write_cond for why.\n         blk(&Condvar { sem:        &self.lock.access_lock,\n                        order: Just(&self.lock.order_lock), })\n     }\n }\n \n-impl<'self> RWlockReadMode<'self> {\n+impl<'self> RWLockReadMode<'self> {\n     /// Access the post-downgrade rwlock in read mode.\n     pub fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n }\n@@ -816,19 +818,19 @@ mod tests {\n      ************************************************************************/\n     #[test]\n     fn test_sem_acquire_release() {\n-        let s = ~semaphore(1);\n+        let s = ~Semaphore::new(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n     #[test]\n     fn test_sem_basic() {\n-        let s = ~semaphore(1);\n+        let s = ~Semaphore::new(1);\n         do s.access { }\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n-        let s = ~semaphore(1);\n+        let s = ~Semaphore::new(1);\n         let s2 = ~s.clone();\n         do task::spawn || {\n             do s2.access {\n@@ -843,7 +845,7 @@ mod tests {\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (p,c) = comm::stream();\n-        let s = ~semaphore(0);\n+        let s = ~Semaphore::new(0);\n         let s2 = ~s.clone();\n         do task::spawn || {\n             s2.acquire();\n@@ -855,7 +857,7 @@ mod tests {\n \n         /* Parent waits and child signals */\n         let (p,c) = comm::stream();\n-        let s = ~semaphore(0);\n+        let s = ~Semaphore::new(0);\n         let s2 = ~s.clone();\n         do task::spawn || {\n             for 5.times { task::yield(); }\n@@ -869,7 +871,7 @@ mod tests {\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n-        let s = ~semaphore(2);\n+        let s = ~Semaphore::new(2);\n         let s2 = ~s.clone();\n         let (p1,c1) = comm::stream();\n         let (p2,c2) = comm::stream();\n@@ -889,7 +891,7 @@ mod tests {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::ManualThreads(1)) {\n-            let s = ~semaphore(1);\n+            let s = ~Semaphore::new(1);\n             let s2 = ~s.clone();\n             let (p,c) = comm::stream();\n             let child_data = Cell::new((s2, c));\n@@ -914,7 +916,7 @@ mod tests {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n         let (p,c) = comm::stream();\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n         {\n@@ -946,7 +948,7 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n \n         // Child wakes up parent\n         do m.lock_cond |cond| {\n@@ -978,7 +980,7 @@ mod tests {\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         let mut ports = ~[];\n \n         for num_waiters.times {\n@@ -1013,7 +1015,7 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         let m2 = ~m.clone();\n         do task::try || {\n             do m.lock_cond |_x| { }\n@@ -1025,7 +1027,7 @@ mod tests {\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         let m2 = ~m.clone();\n \n         let result: result::Result<(),()> = do task::try || {\n@@ -1041,7 +1043,7 @@ mod tests {\n     fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         let m2 = ~m.clone();\n \n         let result: result::Result<(),()> = do task::try || {\n@@ -1065,7 +1067,7 @@ mod tests {\n     }\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_broadcast() {\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         let m2 = ~m.clone();\n         let (p,c) = comm::stream();\n \n@@ -1120,7 +1122,7 @@ mod tests {\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n-        let m = ~Mutex();\n+        let m = ~Mutex::new();\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n             do task::spawn || {\n@@ -1134,7 +1136,7 @@ mod tests {\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_different_conds() {\n         let result = do task::try {\n-            let m = ~mutex_with_condvars(2);\n+            let m = ~Mutex::new_with_condvars(2);\n             let m2 = ~m.clone();\n             let (p,c) = comm::stream();\n             do task::spawn || {\n@@ -1155,17 +1157,17 @@ mod tests {\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_no_condvars() {\n         let result = do task::try {\n-            let m = ~mutex_with_condvars(0);\n+            let m = ~Mutex::new_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n-            let m = ~mutex_with_condvars(0);\n+            let m = ~Mutex::new_with_condvars(0);\n             do m.lock_cond |cond| { cond.signal(); }\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n-            let m = ~mutex_with_condvars(0);\n+            let m = ~Mutex::new_with_condvars(0);\n             do m.lock_cond |cond| { cond.broadcast(); }\n         };\n         assert!(result.is_err());\n@@ -1174,9 +1176,9 @@ mod tests {\n      * Reader/writer lock tests\n      ************************************************************************/\n     #[cfg(test)]\n-    pub enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n+    pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n+    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: &fn()) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1192,9 +1194,9 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(x: ~RWlock,\n-                                 mode1: RWlockMode,\n-                                 mode2: RWlockMode) {\n+    fn test_rwlock_exclusion(x: ~RWLock,\n+                                 mode1: RWLockMode,\n+                                 mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n         let (p,c) = comm::stream();\n@@ -1216,7 +1218,7 @@ mod tests {\n             assert_eq!(*sharedstate, 20);\n         }\n \n-        fn access_shared(sharedstate: &mut int, x: &RWlock, mode: RWlockMode,\n+        fn access_shared(sharedstate: &mut int, x: &RWLock, mode: RWLockMode,\n                          n: uint) {\n             for n.times {\n                 do lock_rwlock_in_mode(x, mode) {\n@@ -1229,22 +1231,22 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(~RWlock(), Read, Write);\n-        test_rwlock_exclusion(~RWlock(), Write, Read);\n-        test_rwlock_exclusion(~RWlock(), Read, Downgrade);\n-        test_rwlock_exclusion(~RWlock(), Downgrade, Read);\n+        test_rwlock_exclusion(~RWLock::new(), Read, Write);\n+        test_rwlock_exclusion(~RWLock::new(), Write, Read);\n+        test_rwlock_exclusion(~RWLock::new(), Read, Downgrade);\n+        test_rwlock_exclusion(~RWLock::new(), Downgrade, Read);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(~RWlock(), Write, Write);\n-        test_rwlock_exclusion(~RWlock(), Write, Downgrade);\n-        test_rwlock_exclusion(~RWlock(), Downgrade, Write);\n-        test_rwlock_exclusion(~RWlock(), Downgrade, Downgrade);\n+        test_rwlock_exclusion(~RWLock::new(), Write, Write);\n+        test_rwlock_exclusion(~RWLock::new(), Write, Downgrade);\n+        test_rwlock_exclusion(~RWLock::new(), Downgrade, Write);\n+        test_rwlock_exclusion(~RWLock::new(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(x: ~RWlock,\n-                                 mode1: RWlockMode,\n-                                 mode2: RWlockMode,\n+    fn test_rwlock_handshake(x: ~RWLock,\n+                                 mode1: RWLockMode,\n+                                 mode2: RWLockMode,\n                                  make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = (*x).clone();\n@@ -1275,32 +1277,32 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(~RWlock(), Read, Read, false);\n+        test_rwlock_handshake(~RWLock::new(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(~RWlock(), DowngradeRead, Read, false);\n-        test_rwlock_handshake(~RWlock(), Read, DowngradeRead, true);\n+        test_rwlock_handshake(~RWLock::new(), DowngradeRead, Read, false);\n+        test_rwlock_handshake(~RWLock::new(), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n-        let x = ~RWlock();\n+        let x = ~RWLock::new();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n         test_rwlock_handshake(x, Read, Read, false);\n-        let y = ~RWlock();\n+        let y = ~RWLock::new();\n         do lock_rwlock_in_mode(y, DowngradeRead) { }\n         test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n-        let x = ~RWlock();\n+        let x = ~RWLock::new();\n         do x.read { do x.read { } }\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n-        let x = ~RWlock();\n+        let x = ~RWLock::new();\n \n         // Child wakes up parent\n         do x.write_cond |cond| {\n@@ -1337,7 +1339,7 @@ mod tests {\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWlock, downgrade: bool, blk: &fn(c: &Condvar)) {\n+        fn lock_cond(x: &RWLock, downgrade: bool, blk: &fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n                     do mode.write_cond |c| { blk(c) }\n@@ -1346,7 +1348,7 @@ mod tests {\n                 do x.write_cond |c| { blk(c) }\n             }\n         }\n-        let x = ~RWlock();\n+        let x = ~RWLock::new();\n         let mut ports = ~[];\n \n         for num_waiters.times {\n@@ -1383,9 +1385,9 @@ mod tests {\n         test_rwlock_cond_broadcast_helper(12, false, false);\n     }\n     #[cfg(test)] #[ignore(cfg(windows))]\n-    fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n+    fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let x = ~RWlock();\n+        let x = ~RWLock::new();\n         let x2 = (*x).clone();\n \n         let result: result::Result<(),()> = do task::try || {\n@@ -1431,8 +1433,8 @@ mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token.\n-        let x = ~RWlock();\n-        let y = ~RWlock();\n+        let x = ~RWLock::new();\n+        let y = ~RWLock::new();\n         do x.write_downgrade |xwrite| {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {"}, {"sha": "125f3a5cd4a986261996c423c0b4d852738377ef", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -15,7 +15,7 @@ use digest::DigestUtil;\n use json;\n use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n-use arc::{ARC,RWARC};\n+use arc::{Arc,RWArc};\n use treemap::TreeMap;\n \n use std::cell::Cell;\n@@ -176,10 +176,10 @@ impl Logger {\n \n #[deriving(Clone)]\n struct Context {\n-    db: RWARC<Database>,\n-    logger: RWARC<Logger>,\n-    cfg: ARC<json::Object>,\n-    freshness: ARC<TreeMap<~str,extern fn(&str,&str)->bool>>\n+    db: RWArc<Database>,\n+    logger: RWArc<Logger>,\n+    cfg: Arc<json::Object>,\n+    freshness: Arc<TreeMap<~str,extern fn(&str,&str)->bool>>\n }\n \n struct Prep<'self> {\n@@ -229,14 +229,14 @@ fn digest_file(path: &Path) -> ~str {\n \n impl Context {\n \n-    pub fn new(db: RWARC<Database>,\n-               lg: RWARC<Logger>,\n-               cfg: ARC<json::Object>) -> Context {\n+    pub fn new(db: RWArc<Database>,\n+               lg: RWArc<Logger>,\n+               cfg: Arc<json::Object>) -> Context {\n         Context {\n             db: db,\n             logger: lg,\n             cfg: cfg,\n-            freshness: ARC(TreeMap::new())\n+            freshness: Arc::new(TreeMap::new())\n         }\n     }\n \n@@ -383,9 +383,9 @@ fn test() {\n         r.get_ref().write_str(\"int main() { return 0; }\");\n     }\n \n-    let cx = Context::new(RWARC(Database::new(Path(\"db.json\"))),\n-                          RWARC(Logger::new()),\n-                          ARC(TreeMap::new()));\n+    let cx = Context::new(RWArc::new(Database::new(Path(\"db.json\"))),\n+                          RWArc::new(Logger::new()),\n+                          Arc::new(TreeMap::new()));\n \n     let s = do cx.with_prep(\"test1\") |prep| {\n "}, {"sha": "9fe6aa57958523a31e91e07cabab530bce4b453b", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -22,7 +22,7 @@ use option::{Option, Some, None};\n use uint;\n use vec::OwnedVector;\n use util::replace;\n-use unstable::sync::{Exclusive, exclusive};\n+use unstable::sync::Exclusive;\n use rtcomm = rt::comm;\n use rt;\n \n@@ -228,7 +228,7 @@ impl<T: Send> SharedChan<T> {\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n         let Chan { inner } = c;\n         let c = match inner {\n-            Left(c) => Left(exclusive(c)),\n+            Left(c) => Left(Exclusive::new(c)),\n             Right(c) => Right(rtcomm::SharedChan::new(c))\n         };\n         SharedChan { inner: c }"}, {"sha": "2bf4543df5017df274203f65ff9c82e65939171a", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -57,7 +57,7 @@ struct KillHandleInner {\n \n     // Shared state between task and children for exit code propagation. These\n     // are here so we can re-use the kill handle to implement watched children\n-    // tasks. Using a separate ARClike would introduce extra atomic adds/subs\n+    // tasks. Using a separate Arc-like would introduce extra atomic adds/subs\n     // into common spawn paths, so this is just for speed.\n \n     // Locklessly accessed; protected by the enclosing refcount's barriers.\n@@ -217,7 +217,7 @@ impl KillHandle {\n             // Exit code propagation fields\n             any_child_failed: false,\n             child_tombstones: None,\n-            graveyard_lock:   LittleLock(),\n+            graveyard_lock:   LittleLock::new(),\n         }));\n         (handle, flag_clone)\n     }"}, {"sha": "8518ddaeae15f08a0a8076b898c43c0356e1106b", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -16,7 +16,7 @@ use kinds::Send;\n use vec::OwnedVector;\n use cell::Cell;\n use option::*;\n-use unstable::sync::{Exclusive, exclusive};\n+use unstable::sync::Exclusive;\n use clone::Clone;\n \n pub struct MessageQueue<T> {\n@@ -27,7 +27,7 @@ pub struct MessageQueue<T> {\n impl<T: Send> MessageQueue<T> {\n     pub fn new() -> MessageQueue<T> {\n         MessageQueue {\n-            queue: ~exclusive(~[])\n+            queue: ~Exclusive::new(~[])\n         }\n     }\n "}, {"sha": "d327023de978adb8bf33946ed10ffee9df61392d", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -15,7 +15,7 @@ use container::Container;\n use vec::OwnedVector;\n use option::{Option, Some, None};\n use cell::Cell;\n-use unstable::sync::{Exclusive, exclusive};\n+use unstable::sync::Exclusive;\n use rt::sched::SchedHandle;\n use clone::Clone;\n \n@@ -26,7 +26,7 @@ pub struct SleeperList {\n impl SleeperList {\n     pub fn new() -> SleeperList {\n         SleeperList {\n-            stack: ~exclusive(~[])\n+            stack: ~Exclusive::new(~[])\n         }\n     }\n "}, {"sha": "5397b5f2c5cf6603610ea5e3fc21c32b065ab4b7", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -28,7 +28,7 @@ use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n use rt::local::Local;\n use str::StrSlice;\n-use unstable::sync::{Exclusive, exclusive};\n+use unstable::sync::Exclusive;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n@@ -158,7 +158,7 @@ pub struct UvRemoteCallback {\n \n impl UvRemoteCallback {\n     pub fn new(loop_: &mut Loop, f: ~fn()) -> UvRemoteCallback {\n-        let exit_flag = exclusive(false);\n+        let exit_flag = Exclusive::new(false);\n         let exit_flag_clone = exit_flag.clone();\n         let async = do AsyncWatcher::new(loop_) |watcher, status| {\n             assert!(status.is_none());"}, {"sha": "24792f3904e51645f2e23cea49bea8a3a7d9bfa5", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -11,7 +11,7 @@\n use container::Container;\n use option::*;\n use vec::OwnedVector;\n-use unstable::sync::{Exclusive, exclusive};\n+use unstable::sync::Exclusive;\n use cell::Cell;\n use kinds::Send;\n use clone::Clone;\n@@ -24,7 +24,7 @@ pub struct WorkQueue<T> {\n impl<T: Send> WorkQueue<T> {\n     pub fn new() -> WorkQueue<T> {\n         WorkQueue {\n-            queue: ~exclusive(~[])\n+            queue: ~Exclusive::new(~[])\n         }\n     }\n "}, {"sha": "df927cb6a7aef4beda47b182664cf9ee75c30e3f", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -677,7 +677,7 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n \n /**\n  * A stronger version of unkillable that also inhibits scheduling operations.\n- * For use with exclusive ARCs, which use pthread mutexes directly.\n+ * For use with exclusive Arcs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;"}, {"sha": "61dcc33c629268ca53f93bdc7446d0faf01d6339", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -91,7 +91,7 @@ use task::unkillable;\n use to_bytes::IterBytes;\n use uint;\n use util;\n-use unstable::sync::{Exclusive, exclusive};\n+use unstable::sync::Exclusive;\n use rt::{OldTaskContext, TaskContext, SchedulerContext, GlobalContext, context};\n use rt::local::Local;\n use rt::task::Task;\n@@ -545,7 +545,7 @@ impl RuntimeGlue {\n                             // Main task, doing first spawn ever. Lazily initialise here.\n                             let mut members = TaskSet::new();\n                             members.insert(OldTask(me));\n-                            let tasks = exclusive(Some(TaskGroupData {\n+                            let tasks = Exclusive::new(Some(TaskGroupData {\n                                 members: members,\n                                 descendants: TaskSet::new(),\n                             }));\n@@ -569,7 +569,7 @@ impl RuntimeGlue {\n                         let mut members = TaskSet::new();\n                         let my_handle = (*me).death.kill_handle.get_ref().clone();\n                         members.insert(NewTask(my_handle));\n-                        let tasks = exclusive(Some(TaskGroupData {\n+                        let tasks = Exclusive::new(Some(TaskGroupData {\n                             members: members,\n                             descendants: TaskSet::new(),\n                         }));\n@@ -596,7 +596,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             (spawner_group.tasks.clone(), ancestors, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n-            let g = exclusive(Some(TaskGroupData {\n+            let g = Exclusive::new(Some(TaskGroupData {\n                 members:     TaskSet::new(),\n                 descendants: TaskSet::new(),\n             }));\n@@ -605,7 +605,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 assert!(new_generation < uint::max_value);\n                 // Child's ancestors start with the spawner.\n                 // Build a new node in the ancestor list.\n-                AncestorList(Some(exclusive(AncestorNode {\n+                AncestorList(Some(Exclusive::new(AncestorNode {\n                     generation: new_generation,\n                     parent_group: spawner_group.tasks.clone(),\n                     ancestors: ancestors,"}, {"sha": "b6fc5b1f66257d91b43d2a7840e6a6f079e886db", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -85,7 +85,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     }\n \n     /// Wait until all other handles are dropped, then retrieve the enclosed\n-    /// data. See extra::arc::ARC for specific semantics documentation.\n+    /// data. See extra::arc::Arc for specific semantics documentation.\n     /// If called when the task is already unkillable, unwrap will unkillably\n     /// block; otherwise, an unwrapping task can be killed by linked failure.\n     pub unsafe fn unwrap(self) -> T {\n@@ -146,7 +146,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n                 // If 'put' returns the server end back to us, we were rejected;\n                 // someone else was trying to unwrap. Avoid guaranteed deadlock.\n                 cast::forget(data);\n-                fail!(\"Another task is already unwrapping this ARC!\");\n+                fail!(\"Another task is already unwrapping this Arc!\");\n             }\n         }\n     }\n@@ -251,15 +251,15 @@ impl Drop for LittleLock {\n     }\n }\n \n-pub fn LittleLock() -> LittleLock {\n-    unsafe {\n-        LittleLock {\n-            l: rust_create_little_lock()\n+impl LittleLock {\n+    pub fn new() -> LittleLock {\n+        unsafe {\n+            LittleLock {\n+                l: rust_create_little_lock()\n+            }\n         }\n     }\n-}\n \n-impl LittleLock {\n     #[inline]\n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         do atomically {\n@@ -285,45 +285,45 @@ struct ExData<T> {\n  * # Safety note\n  *\n  * This uses a pthread mutex, not one that's aware of the userspace scheduler.\n- * The user of an exclusive must be careful not to invoke any functions that may\n+ * The user of an Exclusive must be careful not to invoke any functions that may\n  * reschedule the task while holding the lock, or deadlock may result. If you\n- * need to block or yield while accessing shared state, use extra::sync::RWARC.\n+ * need to block or yield while accessing shared state, use extra::sync::RWArc.\n  */\n pub struct Exclusive<T> {\n     x: UnsafeAtomicRcBox<ExData<T>>\n }\n \n-pub fn exclusive<T:Send>(user_data: T) -> Exclusive<T> {\n-    let data = ExData {\n-        lock: LittleLock(),\n-        failed: false,\n-        data: user_data\n-    };\n-    Exclusive {\n-        x: UnsafeAtomicRcBox::new(data)\n-    }\n-}\n-\n impl<T:Send> Clone for Exclusive<T> {\n-    // Duplicate an exclusive ARC, as std::arc::clone.\n+    // Duplicate an Exclusive Arc, as std::arc::clone.\n     fn clone(&self) -> Exclusive<T> {\n         Exclusive { x: self.x.clone() }\n     }\n }\n \n impl<T:Send> Exclusive<T> {\n-    // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n+    pub fn new(user_data: T) -> Exclusive<T> {\n+        let data = ExData {\n+            lock: LittleLock::new(),\n+            failed: false,\n+            data: user_data\n+        };\n+        Exclusive {\n+            x: UnsafeAtomicRcBox::new(data)\n+        }\n+    }\n+\n+    // Exactly like std::arc::MutexArc,access(), but with the LittleLock\n     // instead of a proper mutex. Same reason for being unsafe.\n     //\n     // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n-    // the exclusive. Supporting that is a work in progress.\n+    // the Exclusive. Supporting that is a work in progress.\n     #[inline]\n     pub unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n-                fail!(\"Poisoned exclusive - another task failed inside!\");\n+                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n             }\n             (*rec).failed = true;\n             let result = f(&mut (*rec).data);\n@@ -341,7 +341,7 @@ impl<T:Send> Exclusive<T> {\n \n     pub fn unwrap(self) -> T {\n         let Exclusive { x: x } = self;\n-        // Someday we might need to unkillably unwrap an exclusive, but not today.\n+        // Someday we might need to unkillably unwrap an Exclusive, but not today.\n         let inner = unsafe { x.unwrap() };\n         let ExData { data: user_data, _ } = inner; // will destroy the LittleLock\n         user_data\n@@ -360,20 +360,20 @@ mod tests {\n     use cell::Cell;\n     use comm;\n     use option::*;\n-    use super::{exclusive, UnsafeAtomicRcBox};\n+    use super::{Exclusive, UnsafeAtomicRcBox};\n     use task;\n     use uint;\n     use util;\n \n     #[test]\n-    fn exclusive_arc() {\n+    fn exclusive_new_arc() {\n         unsafe {\n             let mut futures = ~[];\n \n             let num_tasks = 10;\n             let count = 10;\n \n-            let total = exclusive(~0);\n+            let total = Exclusive::new(~0);\n \n             for uint::range(0, num_tasks) |_i| {\n                 let total = total.clone();\n@@ -399,11 +399,11 @@ mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_poison() {\n+    fn exclusive_new_poison() {\n         unsafe {\n-            // Tests that if one task fails inside of an exclusive, subsequent\n+            // Tests that if one task fails inside of an Exclusive::new, subsequent\n             // accesses will also fail.\n-            let x = exclusive(1);\n+            let x = Exclusive::new(1);\n             let x2 = x.clone();\n             do task::try || {\n                 do x2.with |one| {\n@@ -466,15 +466,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn exclusive_unwrap_basic() {\n+    fn exclusive_new_unwrap_basic() {\n         // Unlike the above, also tests no double-freeing of the LittleLock.\n-        let x = exclusive(~~\"hello\");\n+        let x = Exclusive::new(~~\"hello\");\n         assert!(x.unwrap() == ~~\"hello\");\n     }\n \n     #[test]\n-    fn exclusive_unwrap_contended() {\n-        let x = exclusive(~~\"hello\");\n+    fn exclusive_new_unwrap_contended() {\n+        let x = Exclusive::new(~~\"hello\");\n         let x2 = Cell::new(x.clone());\n         do task::spawn {\n             let x2 = x2.take();\n@@ -484,7 +484,7 @@ mod tests {\n         assert!(x.unwrap() == ~~\"hello\");\n \n         // Now try the same thing, but with the child task blocking.\n-        let x = exclusive(~~\"hello\");\n+        let x = Exclusive::new(~~\"hello\");\n         let x2 = Cell::new(x.clone());\n         let mut res = None;\n         let mut builder = task::task();\n@@ -499,8 +499,8 @@ mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_unwrap_conflict() {\n-        let x = exclusive(~~\"hello\");\n+    fn exclusive_new_unwrap_conflict() {\n+        let x = Exclusive::new(~~\"hello\");\n         let x2 = Cell::new(x.clone());\n         let mut res = None;\n         let mut builder = task::task();\n@@ -515,14 +515,14 @@ mod tests {\n     }\n \n     #[test] #[ignore(cfg(windows))]\n-    fn exclusive_unwrap_deadlock() {\n+    fn exclusive_new_unwrap_deadlock() {\n         // This is not guaranteed to get to the deadlock before being killed,\n         // but it will show up sometimes, and if the deadlock were not there,\n         // the test would nondeterministically fail.\n         let result = do task::try {\n-            // a task that has two references to the same exclusive will\n+            // a task that has two references to the same Exclusive::new will\n             // deadlock when it unwraps. nothing to be done about that.\n-            let x = exclusive(~~\"hello\");\n+            let x = Exclusive::new(~~\"hello\");\n             let x2 = x.clone();\n             do task::spawn {\n                 for 10.times { task::yield(); } // try to let the unwrapper go"}, {"sha": "54057be5268072bd1035c7c1fdb53508c985ee7e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -2563,9 +2563,9 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = ~[::unstable::sync::exclusive(()),\n-                      ::unstable::sync::exclusive(()),\n-                      ::unstable::sync::exclusive(())];\n+        let mut v = ~[::unstable::sync::Exclusive::new(()),\n+                      ::unstable::sync::Exclusive::new(()),\n+                      ::unstable::sync::Exclusive::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);"}, {"sha": "00add20fb7dcd7dfa06cd361761900ebb066d111", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -230,7 +230,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n }\n \n /// A parallel version of the bfs function.\n-fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n+fn pbfs(graph: &arc::Arc<graph>, key: node_id) -> bfs_result {\n     // This works by doing functional updates of a color vector.\n \n     let graph_vec = graph.get(); // FIXME #3387 requires this temp\n@@ -263,7 +263,7 @@ fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n         i += 1;\n         let old_len = colors.len();\n \n-        let color = arc::ARC(colors);\n+        let color = arc::Arc::new(colors);\n \n         let color_vec = color.get(); // FIXME #3387 requires this temp\n         colors = do par::mapi(*color_vec) {\n@@ -444,7 +444,7 @@ fn main() {\n     let mut total_seq = 0.0;\n     let mut total_par = 0.0;\n \n-    let graph_arc = arc::ARC(graph.clone());\n+    let graph_arc = arc::Arc::new(graph.clone());\n \n     do gen_search_keys(graph, num_keys).map() |root| {\n         io::stdout().write_line(\"\");"}, {"sha": "c685057874a0c7444eda7fb329c6400ffb5d046b", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -11,9 +11,9 @@\n // This test creates a bunch of tasks that simultaneously send to each\n // other in a ring. The messages should all be basically\n // independent.\n-// This is like msgsend-ring-pipes but adapted to use ARCs.\n+// This is like msgsend-ring-pipes but adapted to use Arcs.\n \n-// This also serves as a pipes test, because ARCs are implemented with pipes.\n+// This also serves as a pipes test, because Arcs are implemented with pipes.\n \n extern mod extra;\n \n@@ -26,7 +26,7 @@ use std::os;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = arc::MutexARC<~[uint]>;\n+type pipe = arc::MutexArc<~[uint]>;\n \n fn send(p: &pipe, msg: uint) {\n     unsafe {\n@@ -48,7 +48,7 @@ fn recv(p: &pipe) -> uint {\n }\n \n fn init() -> (pipe,pipe) {\n-    let m = arc::MutexARC(~[]);\n+    let m = arc::MutexArc::new(~[]);\n     ((&m).clone(), m)\n }\n "}, {"sha": "e7def11b2663ee5f4a798719355f627f849da347", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -11,9 +11,9 @@\n // This test creates a bunch of tasks that simultaneously send to each\n // other in a ring. The messages should all be basically\n // independent.\n-// This is like msgsend-ring-pipes but adapted to use ARCs.\n+// This is like msgsend-ring-pipes but adapted to use Arcs.\n \n-// This also serves as a pipes test, because ARCs are implemented with pipes.\n+// This also serves as a pipes test, because Arcs are implemented with pipes.\n \n extern mod extra;\n \n@@ -26,7 +26,7 @@ use std::os;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = arc::RWARC<~[uint]>;\n+type pipe = arc::RWArc<~[uint]>;\n \n fn send(p: &pipe, msg: uint) {\n     do p.write_cond |state, cond| {\n@@ -44,7 +44,7 @@ fn recv(p: &pipe) -> uint {\n }\n \n fn init() -> (pipe,pipe) {\n-    let x = arc::RWARC(~[]);\n+    let x = arc::RWArc::new(~[]);\n     ((&x).clone(), x)\n }\n "}, {"sha": "f8a3c5c573a0d3e8dac740ef9b78eea23f332258", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::arc;\n fn main() {\n-    let x = ~arc::RWARC(1);\n+    let x = ~arc::RWArc::new(1);\n     let mut y = None;\n     do x.write_cond |_one, cond| {\n         y = Some(cond);"}, {"sha": "451616a074f118942ce116f8490e8979c545b6a5", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -11,7 +11,7 @@\n extern mod extra;\n use extra::arc;\n fn main() {\n-    let x = ~arc::RWARC(1);\n+    let x = ~arc::RWArc::new(1);\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(x.downgrade(write_mode));"}, {"sha": "44657dfd0efe61baa803cced381bd7778bd37926", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -11,7 +11,7 @@\n extern mod extra;\n use extra::arc;\n fn main() {\n-    let x = ~arc::RWARC(1);\n+    let x = ~arc::RWArc::new(1);\n     let mut y = None; //~ ERROR lifetime of variable does not enclose its declaration\n     do x.write |one| {\n         y = Some(one);"}, {"sha": "44ac0e722d38af9d4deb25c2bbc35a4674837b40", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::arc;\n fn main() {\n-    let x = ~arc::RWARC(1);\n+    let x = ~arc::RWArc::new(1);\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         do (&write_mode).write_cond |_one, cond| {"}, {"sha": "b6535b6189a0449cc77ab77bea55ec695ab54a2d", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::arc;\n fn main() {\n-    let x = ~arc::RWARC(1);\n+    let x = ~arc::RWArc::new(1);\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);"}, {"sha": "fd54b6638c65fece20d30d69ebb0e7006c4650df", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -17,7 +17,7 @@ use std::task;\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    let arc_v = arc::ARC(v);\n+    let arc_v = arc::Arc::new(v);\n \n     do task::spawn() {\n         let v = arc_v.get();"}, {"sha": "a17196ae298e7022fc40faded5978a7d5d959f65", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -15,7 +15,7 @@ use std::task;\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    let arc_v = arc::ARC(v);\n+    let arc_v = arc::Arc::new(v);\n \n     do task::spawn() {\n         let v = arc_v.get();"}, {"sha": "dddd9a1868c938263994a19d54773bdc54c021a2", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -21,7 +21,7 @@ fn foo(blk: ~once fn()) {\n }\n \n fn main() {\n-    let x = arc::ARC(true);\n+    let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());\n         util::ignore(x);"}, {"sha": "45110bd4bc68a09dabbdbd9add3b570477bd323b", "filename": "src/test/compile-fail/once-cant-call-twice-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -22,7 +22,7 @@ fn foo(blk: &once fn()) {\n }\n \n fn main() {\n-    let x = arc::ARC(true);\n+    let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());\n         util::ignore(x);"}, {"sha": "cc40fb6b8d88eea28edd8b844dde366cdb9bd7c0", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-heap.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -21,7 +21,7 @@ fn foo(blk: ~fn()) {\n }\n \n fn main() {\n-    let x = arc::ARC(true);\n+    let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());\n         util::ignore(x); //~ ERROR cannot move out of captured outer variable"}, {"sha": "aedeb92df787c35bbb2b205a9ada425e669c854a", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -21,7 +21,7 @@ fn foo(blk: &fn()) {\n }\n \n fn main() {\n-    let x = arc::ARC(true);\n+    let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());\n         util::ignore(x); //~ ERROR cannot move out of captured outer variable"}, {"sha": "928953de39088f8fb4eee4c0112bc228d44d4674", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -13,7 +13,7 @@ extern mod extra;\n use extra::sync;\n \n fn main() {\n-    let m = ~sync::Mutex();\n+    let m = ~sync::Mutex::new();\n     let mut cond = None;\n     do m.lock_cond |c| {\n         cond = Some(c);"}, {"sha": "03779b3ffe3d1e90bae38b2201f34e4c8dc2a40c", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::sync;\n fn main() {\n-    let x = ~sync::RWlock();\n+    let x = ~sync::RWLock::new();\n     let mut y = None;\n     do x.write_cond |cond| {\n         y = Some(cond);"}, {"sha": "6ce3869bab224ad00ea3d2d3ffcfb8b94a3c833a", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::sync;\n fn main() {\n-    let x = ~sync::RWlock();\n+    let x = ~sync::RWLock::new();\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(x.downgrade(write_mode));"}, {"sha": "fab16894a655a9ffd3f9ada73ef694c7d6f457a6", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::sync;\n fn main() {\n-    let x = ~sync::RWlock();\n+    let x = ~sync::RWLock::new();\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         do (&write_mode).write_cond |cond| {"}, {"sha": "7210fbf37b424a582cd2f06ebbc70d13d18d89fa", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@\n extern mod extra;\n use extra::sync;\n fn main() {\n-    let x = ~sync::RWlock();\n+    let x = ~sync::RWLock::new();\n     let mut y = None;\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);"}, {"sha": "5e7c7cf519b05f2ce09fca6cb8ad5ee2e811b8f2", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -13,7 +13,7 @@\n extern mod extra;\n use extra::arc;\n \n-enum e<T> { e(arc::ARC<T>) }\n+enum e<T> { e(arc::Arc<T>) }\n \n fn foo() -> e<int> {fail!();}\n "}, {"sha": "9d808d19af2e9d9bcd3c45e751032a59c4d58fc1", "filename": "src/test/run-pass/bind-by-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-by-move.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -11,10 +11,10 @@\n // xfail-fast\n extern mod extra;\n use extra::arc;\n-fn dispose(_x: arc::ARC<bool>) { unsafe { } }\n+fn dispose(_x: arc::Arc<bool>) { unsafe { } }\n \n pub fn main() {\n-    let p = arc::ARC(true);\n+    let p = arc::Arc::new(true);\n     let x = Some(p);\n     match x {\n         Some(z) => { dispose(z); },"}, {"sha": "e1d2f0e1c4847365aecd9bbdefb05188bde7fe3f", "filename": "src/test/run-pass/match-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-ref-binding-in-guard-3256.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -12,7 +12,7 @@ use std::unstable;\n \n pub fn main() {\n     unsafe {\n-        let x = Some(unstable::sync::exclusive(true));\n+        let x = Some(unstable::sync::Exclusive::new(true));\n         match x {\n             Some(ref z) if z.with(|b| *b) => {\n                 do z.with |b| { assert!(*b); }"}, {"sha": "744cd1066cf7c0af3b9b0f026c77f09bbc477eca", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -21,7 +21,7 @@ fn foo(blk: ~once fn()) {\n }\n \n fn main() {\n-    let x = arc::ARC(true);\n+    let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());\n         util::ignore(x);"}, {"sha": "002503a5566bdb9119824d569276dca94bfe75be", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -22,7 +22,7 @@ fn foo(blk: &once fn()) {\n }\n \n fn main() {\n-    let x = arc::ARC(true);\n+    let x = arc::Arc::new(true);\n     do foo {\n         assert!(*x.get());\n         util::ignore(x);"}, {"sha": "0677b63b5aa4f971d879064ab954837242b75926", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that a heterogeneous list of existential types can be put inside an ARC\n+// Tests that a heterogeneous list of existential types can be put inside an Arc\n // and shared between tasks as long as all types fulfill Freeze+Send.\n \n // xfail-fast\n@@ -64,7 +64,7 @@ fn main() {\n     let dogge1 = Dogge { bark_decibels: 100, tricks_known: 42, name: ~\"alan_turing\" };\n     let dogge2 = Dogge { bark_decibels: 55,  tricks_known: 11, name: ~\"albert_einstein\" };\n     let fishe = Goldfyshe { swim_speed: 998, name: ~\"alec_guinness\" };\n-    let arc = arc::ARC(~[~catte  as ~Pet:Freeze+Send,\n+    let arc = arc::Arc::new(~[~catte  as ~Pet:Freeze+Send,\n                          ~dogge1 as ~Pet:Freeze+Send,\n                          ~fishe  as ~Pet:Freeze+Send,\n                          ~dogge2 as ~Pet:Freeze+Send]);\n@@ -82,21 +82,21 @@ fn main() {\n     p3.recv();\n }\n \n-fn check_legs(arc: arc::ARC<~[~Pet:Freeze+Send]>) {\n+fn check_legs(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n     let mut legs = 0;\n     for arc.get().iter().advance |pet| {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n-fn check_names(arc: arc::ARC<~[~Pet:Freeze+Send]>) {\n+fn check_names(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n     for arc.get().iter().advance |pet| {\n         do pet.name |name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         }\n     }\n }\n-fn check_pedigree(arc: arc::ARC<~[~Pet:Freeze+Send]>) {\n+fn check_pedigree(arc: arc::Arc<~[~Pet:Freeze+Send]>) {\n     for arc.get().iter().advance |pet| {\n         assert!(pet.of_good_pedigree());\n     }"}, {"sha": "2db954d27c10b292d56d06f9210480c991e0415a", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9325535b41fa5a7cfac697e86ae86bd1384542e6/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=9325535b41fa5a7cfac697e86ae86bd1384542e6", "patch": "@@ -17,7 +17,7 @@ fn f(p: &mut Point) { p.z = 13; }\n \n pub fn main() {\n     unsafe {\n-        let x = Some(unstable::sync::exclusive(true));\n+        let x = Some(unstable::sync::Exclusive::new(true));\n         match x {\n             Some(ref z) if z.with(|b| *b) => {\n                 do z.with |b| { assert!(*b); }"}]}