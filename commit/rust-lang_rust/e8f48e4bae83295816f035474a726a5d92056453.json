{"sha": "e8f48e4bae83295816f035474a726a5d92056453", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZjQ4ZTRiYWU4MzI5NTgxNmYwMzU0NzRhNzI2YTVkOTIwNTY0NTM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-29T21:15:15Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-29T21:15:15Z"}, "message": "[WIP] Implement PassMode::Cast", "tree": {"sha": "68371dcb3f615211bc169fc004c89f5ad867e603", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68371dcb3f615211bc169fc004c89f5ad867e603"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8f48e4bae83295816f035474a726a5d92056453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f48e4bae83295816f035474a726a5d92056453", "html_url": "https://github.com/rust-lang/rust/commit/e8f48e4bae83295816f035474a726a5d92056453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8f48e4bae83295816f035474a726a5d92056453/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268d7bc459d436d28171e37050edec287f950bfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/268d7bc459d436d28171e37050edec287f950bfe", "html_url": "https://github.com/rust-lang/rust/commit/268d7bc459d436d28171e37050edec287f950bfe"}], "stats": {"total": 225, "additions": 191, "deletions": 34}, "files": [{"sha": "c227bdd534f34d15f2eab92d994d40ad2cc7697a", "filename": "src/abi/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e8f48e4bae83295816f035474a726a5d92056453/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f48e4bae83295816f035474a726a5d92056453/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=e8f48e4bae83295816f035474a726a5d92056453", "patch": "@@ -191,12 +191,24 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     start_block: Block,\n ) {\n+    fx.bcx.append_block_params_for_function_params(start_block);\n+\n+    fx.bcx.switch_to_block(start_block);\n+    fx.bcx.ins().nop();\n+\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, start_block);\n+    let mut block_params_iter = fx\n+        .bcx\n+        .func\n+        .dfg\n+        .block_params(start_block)\n+        .to_vec()\n+        .into_iter();\n+    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n \n     // None means pass_mode == NoPass\n@@ -229,14 +241,14 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 let mut params = Vec::new();\n                 for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n                     let arg_abi = arg_abis_iter.next().unwrap();\n-                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_abi);\n+                    let param = cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n                 let arg_abi = arg_abis_iter.next().unwrap();\n-                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_abi);\n+                let param = cvalue_for_param(fx, Some(local), None, arg_abi, &mut block_params_iter);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n@@ -246,14 +258,13 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     if fx.instance.def.requires_caller_location(fx.tcx) {\n         // Store caller location for `#[track_caller]`.\n         let arg_abi = arg_abis_iter.next().unwrap();\n-        fx.caller_location = Some(cvalue_for_param(fx, start_block, None, None, arg_abi).unwrap());\n+        fx.caller_location =\n+            Some(cvalue_for_param(fx, None, None, arg_abi, &mut block_params_iter).unwrap());\n     }\n \n     assert!(arg_abis_iter.next().is_none(), \"ArgAbi left behind\");\n     fx.fn_abi = Some(fn_abi);\n-\n-    fx.bcx.switch_to_block(start_block);\n-    fx.bcx.ins().nop();\n+    assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n     #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);"}, {"sha": "6f27fa52d882cb1060a0f7b08cf6946d69569552", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 146, "deletions": 16, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e8f48e4bae83295816f035474a726a5d92056453/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f48e4bae83295816f035474a726a5d92056453/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=e8f48e4bae83295816f035474a726a5d92056453", "patch": "@@ -4,14 +4,86 @@ use crate::prelude::*;\n use crate::value_and_place::assert_assignable;\n \n use cranelift_codegen::ir::ArgumentPurpose;\n-use rustc_target::abi::call::{ArgAbi, PassMode};\n+use rustc_target::abi::call::{ArgAbi, CastTarget, PassMode, Reg, RegKind};\n use smallvec::{smallvec, SmallVec};\n \n pub(super) trait ArgAbiExt<'tcx> {\n     fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]>;\n     fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>);\n }\n \n+fn reg_to_abi_param(reg: Reg) -> AbiParam {\n+    let clif_ty = match (reg.kind, reg.size.bytes()) {\n+        (RegKind::Integer, 1) => types::I8,\n+        (RegKind::Integer, 2) => types::I16,\n+        (RegKind::Integer, 4) => types::I32,\n+        (RegKind::Integer, 8) => types::I64,\n+        (RegKind::Integer, 16) => types::I128,\n+        (RegKind::Float, 4) => types::F32,\n+        (RegKind::Float, 8) => types::F64,\n+        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        _ => unreachable!(\"{:?}\", reg),\n+    };\n+    AbiParam::new(clif_ty)\n+}\n+\n+fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+    let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n+        (0, 0)\n+    } else {\n+        (\n+            cast.rest.total.bytes() / cast.rest.unit.size.bytes(),\n+            cast.rest.total.bytes() % cast.rest.unit.size.bytes(),\n+        )\n+    };\n+\n+    if cast.prefix.iter().all(|x| x.is_none()) {\n+        // Simplify to a single unit when there is no prefix and size <= unit size\n+        if cast.rest.total <= cast.rest.unit.size {\n+            let clif_ty = match (cast.rest.unit.kind, cast.rest.unit.size.bytes()) {\n+                (RegKind::Integer, 1) => types::I8,\n+                (RegKind::Integer, 2) => types::I16,\n+                (RegKind::Integer, 3..=4) => types::I32,\n+                (RegKind::Integer, 5..=8) => types::I64,\n+                (RegKind::Integer, 9..=16) => types::I128,\n+                (RegKind::Float, 4) => types::F32,\n+                (RegKind::Float, 8) => types::F64,\n+                (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+                _ => unreachable!(\"{:?}\", cast.rest.unit),\n+            };\n+            return smallvec![AbiParam::new(clif_ty)];\n+        }\n+    }\n+\n+    // Create list of fields in the main structure\n+    let mut args = cast\n+        .prefix\n+        .iter()\n+        .flatten()\n+        .map(|&kind| {\n+            reg_to_abi_param(Reg {\n+                kind,\n+                size: cast.prefix_chunk_size,\n+            })\n+        })\n+        .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n+        .collect::<SmallVec<_>>();\n+\n+    // Append final integer\n+    if rem_bytes != 0 {\n+        // Only integers can be really split further.\n+        assert_eq!(cast.rest.unit.kind, RegKind::Integer);\n+        args.push(reg_to_abi_param(Reg {\n+            kind: RegKind::Integer,\n+            size: Size::from_bytes(rem_bytes),\n+        }));\n+    }\n+\n+    args\n+}\n+\n+// FIXME respect argument extension mode\n+\n impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]> {\n         match self.mode {\n@@ -34,7 +106,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(_) => smallvec![AbiParam::new(pointer_ty(tcx))],\n+            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n             PassMode::Indirect {\n                 attrs: _,\n                 extra_attrs: None,\n@@ -87,13 +159,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(_) => (\n-                Some(AbiParam::special(\n-                    pointer_ty(tcx),\n-                    ArgumentPurpose::StructReturn,\n-                )),\n-                vec![],\n-            ),\n+            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n             PassMode::Indirect {\n                 attrs: _,\n                 extra_attrs: None,\n@@ -117,6 +183,60 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     }\n }\n \n+pub(super) fn to_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    arg: CValue<'tcx>,\n+    cast: CastTarget,\n+) -> SmallVec<[Value; 2]> {\n+    let (ptr, meta) = arg.force_stack(fx);\n+    assert!(meta.is_none());\n+    let mut offset = 0;\n+    cast_target_to_abi_params(cast)\n+        .into_iter()\n+        .map(|param| {\n+            let val = ptr\n+                .offset_i64(fx, offset)\n+                .load(fx, param.value_type, MemFlags::new());\n+            offset += i64::from(param.value_type.bytes());\n+            val\n+        })\n+        .collect()\n+}\n+\n+pub(super) fn from_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    block_params: &[Value],\n+    layout: TyAndLayout<'tcx>,\n+    cast: CastTarget,\n+) -> CValue<'tcx> {\n+    let abi_params = cast_target_to_abi_params(cast);\n+    let size = abi_params\n+        .iter()\n+        .map(|param| param.value_type.bytes())\n+        .sum();\n+    // Stack slot size may be bigger for for example `[u8; 3]` which is packed into an `i32`.\n+    assert!(u64::from(size) >= layout.size.bytes());\n+    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        size,\n+        offset: None,\n+    });\n+    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let mut offset = 0;\n+    let mut block_params_iter = block_params.into_iter().copied();\n+    for param in abi_params {\n+        let val = ptr.offset_i64(fx, offset).store(\n+            fx,\n+            block_params_iter.next().unwrap(),\n+            MemFlags::new(),\n+        );\n+        offset += i64::from(param.value_type.bytes());\n+        val\n+    }\n+    assert_eq!(block_params_iter.next(), None, \"Leftover block param\");\n+    CValue::by_ref(ptr, layout)\n+}\n+\n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n@@ -131,7 +251,8 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(_) | PassMode::Indirect { .. } => match arg.force_stack(fx) {\n+        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Indirect { .. } => match arg.force_stack(fx) {\n             (ptr, None) => smallvec![ptr.get_addr(fx)],\n             (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n         },\n@@ -142,15 +263,22 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n-    let clif_types = arg_abi.get_abi_param(fx.tcx);\n-    let block_params = clif_types\n+    let block_params = arg_abi\n+        .get_abi_param(fx.tcx)\n         .into_iter()\n-        .map(|abi_param| fx.bcx.append_block_param(start_block, abi_param.value_type))\n+        .map(|abi_param| {\n+            let block_param = block_params_iter.next().unwrap();\n+            assert_eq!(\n+                fx.bcx.func.dfg.value_type(block_param),\n+                abi_param.value_type\n+            );\n+            block_param\n+        })\n         .collect::<SmallVec<[_; 2]>>();\n \n     #[cfg(debug_assertions)]\n@@ -178,8 +306,10 @@ pub(super) fn cvalue_for_param<'tcx>(\n                 arg_abi.layout,\n             ))\n         }\n-        PassMode::Cast(_)\n-        | PassMode::Indirect {\n+        PassMode::Cast(cast) => {\n+            Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n+        }\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,"}, {"sha": "a382963bf1ed743b0963690b2fb3800c3da3ef40", "filename": "src/abi/returning.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e8f48e4bae83295816f035474a726a5d92056453/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f48e4bae83295816f035474a726a5d92056453/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=e8f48e4bae83295816f035474a726a5d92056453", "patch": "@@ -60,14 +60,14 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n pub(super) fn codegen_return_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n-    start_block: Block,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n         PassMode::Ignore => (\n             CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n             smallvec![],\n         ),\n-        PassMode::Direct(_) | PassMode::Pair(_, _) => {\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -79,13 +79,13 @@ pub(super) fn codegen_return_param<'tcx>(\n                 smallvec![],\n             )\n         }\n-        PassMode::Cast(_)\n-        | PassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n         } => {\n-            let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n+            let ret_param = block_params_iter.next().unwrap();\n+            assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n                 CPlace::for_ptr(\n                     Pointer::new(ret_param),\n@@ -128,8 +128,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n ) -> (Inst, T) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n-        PassMode::Cast(_)\n-        | PassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n@@ -142,7 +141,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n             extra_attrs: Some(_),\n             on_stack: _,\n         } => unreachable!(\"unsized return value\"),\n-        PassMode::Direct(_) | PassMode::Pair(_, _) => None,\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n     let (call_inst, meta) = f(fx, return_ptr);\n@@ -165,8 +164,20 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n                 );\n             }\n         }\n-        PassMode::Cast(_)\n-        | PassMode::Indirect {\n+        PassMode::Cast(cast) => {\n+            if let Some(ret_place) = ret_place {\n+                let results = fx\n+                    .bcx\n+                    .inst_results(call_inst)\n+                    .into_iter()\n+                    .copied()\n+                    .collect::<SmallVec<[Value; 2]>>();\n+                let result =\n+                    super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n+                ret_place.write_cvalue(fx, result);\n+            }\n+        }\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n@@ -185,7 +196,6 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n     match fx.fn_abi.as_ref().unwrap().ret.mode {\n         PassMode::Ignore\n-        | PassMode::Cast(_)\n         | PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n@@ -208,5 +218,11 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n+        PassMode::Cast(cast) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx);\n+            let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);\n+            fx.bcx.ins().return_(&ret_vals);\n+        }\n     }\n }"}]}