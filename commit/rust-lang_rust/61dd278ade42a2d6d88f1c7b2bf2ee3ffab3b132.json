{"sha": "61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "node_id": "C_kwDOAAsO6NoAKDYxZGQyNzhhZGU0MmEyZDZkODhmMWM3YjJiZjJlZTNmZmFiM2IxMzI", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-05-03T04:38:25Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-05-25T22:32:31Z"}, "message": "Move `download` functions from `native` to builder.rs\n\nThis has no logic changes, just a move.", "tree": {"sha": "7937cb0de22b6596ed45f8fb613218e6eb9af270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7937cb0de22b6596ed45f8fb613218e6eb9af270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "html_url": "https://github.com/rust-lang/rust/commit/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b5e1215efa47cf4d78a945c7be1c04cda4f57d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5e1215efa47cf4d78a945c7be1c04cda4f57d4", "html_url": "https://github.com/rust-lang/rust/commit/1b5e1215efa47cf4d78a945c7be1c04cda4f57d4"}], "stats": {"total": 444, "additions": 222, "deletions": 222}, "files": [{"sha": "a0ce200883d3c570a39c8b41cd8a45739a94132f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 207, "deletions": 4, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "patch": "@@ -2,13 +2,14 @@ use std::any::{type_name, Any};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::env;\n-use std::ffi::OsStr;\n+use std::ffi::{OsStr, OsString};\n use std::fmt::{Debug, Write};\n-use std::fs;\n+use std::fs::{self, File};\n use std::hash::Hash;\n+use std::io::{BufRead, BufReader, ErrorKind};\n use std::ops::Deref;\n use std::path::{Component, Path, PathBuf};\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n use std::time::{Duration, Instant};\n \n use crate::cache::{Cache, Interned, INTERNER};\n@@ -29,7 +30,8 @@ use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n // FIXME: replace with std::lazy after it gets stabilized and reaches beta\n-use once_cell::sync::Lazy;\n+use once_cell::sync::{Lazy, OnceCell};\n+use xz2::bufread::XzDecoder;\n \n pub struct Builder<'a> {\n     pub build: &'a Build,\n@@ -758,6 +760,207 @@ impl<'a> Builder<'a> {\n         StepDescription::run(v, self, paths);\n     }\n \n+    /// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+    /// or the RPATH section, to fix the dynamic library search path\n+    ///\n+    /// This is only required on NixOS and uses the PatchELF utility to\n+    /// change the interpreter/RPATH of ELF executables.\n+    ///\n+    /// Please see https://nixos.org/patchelf.html for more information\n+    pub(crate) fn fix_bin_or_dylib(&self, fname: &Path) {\n+        // FIXME: cache NixOS detection?\n+        match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n+            Err(_) => return,\n+            Ok(output) if !output.status.success() => return,\n+            Ok(output) => {\n+                let mut s = output.stdout;\n+                if s.last() == Some(&b'\\n') {\n+                    s.pop();\n+                }\n+                if s != b\"Linux\" {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // If the user has asked binaries to be patched for Nix, then\n+        // don't check for NixOS or `/lib`, just continue to the patching.\n+        // FIXME: shouldn't this take precedence over the `uname` check above?\n+        if !self.config.patch_binaries_for_nix {\n+            // Use `/etc/os-release` instead of `/etc/NIXOS`.\n+            // The latter one does not exist on NixOS when using tmpfs as root.\n+            const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n+            let os_release = match File::open(\"/etc/os-release\") {\n+                Err(e) if e.kind() == ErrorKind::NotFound => return,\n+                Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n+                Ok(f) => f,\n+            };\n+            if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n+                return;\n+            }\n+            if Path::new(\"/lib\").exists() {\n+                return;\n+            }\n+        }\n+\n+        // At this point we're pretty sure the user is running NixOS or using Nix\n+        println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n+\n+        // Only build `.nix-deps` once.\n+        static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n+        let mut nix_build_succeeded = true;\n+        let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n+            // Run `nix-build` to \"build\" each dependency (which will likely reuse\n+            // the existing `/nix/store` copy, or at most download a pre-built copy).\n+            //\n+            // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n+            // directory, but still reference the actual `/nix/store` path in the rpath\n+            // as it makes it significantly more robust against changes to the location of\n+            // the `.nix-deps` location.\n+            //\n+            // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+            // zlib: Needed as a system dependency of `libLLVM-*.so`.\n+            // patchelf: Needed for patching ELF binaries (see doc comment above).\n+            let nix_deps_dir = self.out.join(\".nix-deps\");\n+            const NIX_EXPR: &str = \"\n+            with (import <nixpkgs> {});\n+            symlinkJoin {\n+                name = \\\"rust-stage0-dependencies\\\";\n+                paths = [\n+                    zlib\n+                    patchelf\n+                    stdenv.cc.bintools\n+                ];\n+            }\n+            \";\n+            nix_build_succeeded = self.try_run(Command::new(\"nix-build\").args(&[\n+                Path::new(\"-E\"),\n+                Path::new(NIX_EXPR),\n+                Path::new(\"-o\"),\n+                &nix_deps_dir,\n+            ]));\n+            nix_deps_dir\n+        });\n+        if !nix_build_succeeded {\n+            return;\n+        }\n+\n+        let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n+        let rpath_entries = {\n+            // ORIGIN is a relative default, all binary and dynamic libraries we ship\n+            // appear to have this (even when `../lib` is redundant).\n+            // NOTE: there are only two paths here, delimited by a `:`\n+            let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n+            entries.push(t!(fs::canonicalize(nix_deps_dir)));\n+            entries.push(\"/lib\");\n+            entries\n+        };\n+        patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n+        if !fname.extension().map_or(false, |ext| ext == \"so\") {\n+            // Finally, set the corret .interp for binaries\n+            let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n+            // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n+            let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n+            patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n+        }\n+\n+        self.try_run(patchelf.arg(fname));\n+    }\n+\n+    pub(crate) fn download_component(&self, base: &str, url: &str, dest_path: &Path) {\n+        // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n+        let tempfile = self.tempdir().join(dest_path.file_name().unwrap());\n+        // FIXME: support `do_verify` (only really needed for nightly rustfmt)\n+        // FIXME: support non-utf8 paths?\n+        self.download_with_retries(tempfile.to_str().unwrap(), &format!(\"{}/{}\", base, url));\n+        t!(std::fs::rename(&tempfile, dest_path));\n+    }\n+\n+    fn download_with_retries(&self, tempfile: &str, url: &str) {\n+        println!(\"downloading {}\", url);\n+        // Try curl. If that fails and we are on windows, fallback to PowerShell.\n+        if !self.check_run(Command::new(\"curl\").args(&[\n+            \"-#\",\n+            \"-y\",\n+            \"30\",\n+            \"-Y\",\n+            \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n+            \"--connect-timeout\",\n+            \"30\", // timeout if cannot connect within 30 seconds\n+            \"--retry\",\n+            \"3\",\n+            \"-Sf\",\n+            \"-o\",\n+            tempfile,\n+            url,\n+        ])) {\n+            if self.build.build.contains(\"windows-msvc\") {\n+                println!(\"Fallback to PowerShell\");\n+                for _ in 0..3 {\n+                    if self.try_run(Command::new(\"PowerShell.exe\").args(&[\n+                        \"/nologo\",\n+                        \"-Command\",\n+                        \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n+                        &format!(\n+                            \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n+                            url, tempfile\n+                        ),\n+                    ])) {\n+                        return;\n+                    }\n+                    println!(\"\\nspurious failure, trying again\");\n+                }\n+            }\n+            std::process::exit(1);\n+        }\n+    }\n+\n+    pub(crate) fn unpack(&self, tarball: &Path, dst: &Path) {\n+        println!(\"extracting {} to {}\", tarball.display(), dst.display());\n+        if !dst.exists() {\n+            t!(fs::create_dir_all(dst));\n+        }\n+\n+        // FIXME: will need to be a parameter once `download-rustc` is moved to rustbuild\n+        const MATCH: &str = \"rust-dev\";\n+\n+        // `tarball` ends with `.tar.xz`; strip that suffix\n+        // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n+        let uncompressed_filename =\n+            Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n+        let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n+\n+        // decompress the file\n+        let data = t!(File::open(tarball));\n+        let decompressor = XzDecoder::new(BufReader::new(data));\n+\n+        let mut tar = tar::Archive::new(decompressor);\n+        for member in t!(tar.entries()) {\n+            let mut member = t!(member);\n+            let original_path = t!(member.path()).into_owned();\n+            // skip the top-level directory\n+            if original_path == directory_prefix {\n+                continue;\n+            }\n+            let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n+            if !short_path.starts_with(MATCH) {\n+                continue;\n+            }\n+            short_path = t!(short_path.strip_prefix(MATCH));\n+            let dst_path = dst.join(short_path);\n+            self.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n+            if !t!(member.unpack_in(dst)) {\n+                panic!(\"path traversal attack ??\");\n+            }\n+            let src_path = dst.join(original_path);\n+            if src_path.is_dir() && dst_path.exists() {\n+                continue;\n+            }\n+            t!(fs::rename(src_path, dst_path));\n+        }\n+        t!(fs::remove_dir_all(dst.join(directory_prefix)));\n+    }\n+\n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid"}, {"sha": "5bb94f297c81410f2bc4e5200611ac7dca2cbe74", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 7, "deletions": 218, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "patch": "@@ -12,16 +12,13 @@ use std::env;\n use std::env::consts::EXE_EXTENSION;\n use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n-use std::io::{self, BufRead, BufReader, ErrorKind};\n+use std::io;\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio};\n-\n-use once_cell::sync::OnceCell;\n-use xz2::bufread::XzDecoder;\n+use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n-use crate::util::{self, exe, output, t, up_to_date};\n+use crate::util::{self, exe, output, program_out_of_date, t, up_to_date};\n use crate::{CLang, GitRepo};\n \n pub struct Meta {\n@@ -151,13 +148,13 @@ pub(crate) fn maybe_download_ci_llvm(builder: &Builder<'_>) {\n     if program_out_of_date(&llvm_stamp, &key) && !config.dry_run {\n         download_ci_llvm(builder, &llvm_sha);\n         for binary in [\"llvm-config\", \"FileCheck\"] {\n-            fix_bin_or_dylib(builder, &llvm_root.join(\"bin\").join(binary));\n+            builder.fix_bin_or_dylib(&llvm_root.join(\"bin\").join(binary));\n         }\n         let llvm_lib = llvm_root.join(\"lib\");\n         for entry in t!(fs::read_dir(&llvm_lib)) {\n             let lib = t!(entry).path();\n             if lib.extension().map_or(false, |ext| ext == \"so\") {\n-                fix_bin_or_dylib(builder, &lib);\n+                builder.fix_bin_or_dylib(&lib);\n             }\n         }\n         t!(fs::write(llvm_stamp, key));\n@@ -182,218 +179,10 @@ fn download_ci_llvm(builder: &Builder<'_>, llvm_sha: &str) {\n     let filename = format!(\"rust-dev-nightly-{}.tar.xz\", builder.build.build.triple);\n     let tarball = rustc_cache.join(&filename);\n     if !tarball.exists() {\n-        download_component(builder, base, &format!(\"{}/{}\", url, filename), &tarball);\n+        builder.download_component(base, &format!(\"{}/{}\", url, filename), &tarball);\n     }\n     let llvm_root = builder.config.ci_llvm_root();\n-    unpack(builder, &tarball, &llvm_root);\n-}\n-\n-/// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n-/// or the RPATH section, to fix the dynamic library search path\n-///\n-/// This is only required on NixOS and uses the PatchELF utility to\n-/// change the interpreter/RPATH of ELF executables.\n-///\n-/// Please see https://nixos.org/patchelf.html for more information\n-fn fix_bin_or_dylib(builder: &Builder<'_>, fname: &Path) {\n-    // FIXME: cache NixOS detection?\n-    match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n-        Err(_) => return,\n-        Ok(output) if !output.status.success() => return,\n-        Ok(output) => {\n-            let mut s = output.stdout;\n-            if s.last() == Some(&b'\\n') {\n-                s.pop();\n-            }\n-            if s != b\"Linux\" {\n-                return;\n-            }\n-        }\n-    }\n-\n-    // If the user has asked binaries to be patched for Nix, then\n-    // don't check for NixOS or `/lib`, just continue to the patching.\n-    // FIXME: shouldn't this take precedence over the `uname` check above?\n-    if !builder.config.patch_binaries_for_nix {\n-        // Use `/etc/os-release` instead of `/etc/NIXOS`.\n-        // The latter one does not exist on NixOS when using tmpfs as root.\n-        const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n-        let os_release = match File::open(\"/etc/os-release\") {\n-            Err(e) if e.kind() == ErrorKind::NotFound => return,\n-            Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n-            Ok(f) => f,\n-        };\n-        if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n-            return;\n-        }\n-        if Path::new(\"/lib\").exists() {\n-            return;\n-        }\n-    }\n-\n-    // At this point we're pretty sure the user is running NixOS or using Nix\n-    println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n-\n-    // Only build `.nix-deps` once.\n-    static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n-    let mut nix_build_succeeded = true;\n-    let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n-        // Run `nix-build` to \"build\" each dependency (which will likely reuse\n-        // the existing `/nix/store` copy, or at most download a pre-built copy).\n-        //\n-        // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n-        // directory, but still reference the actual `/nix/store` path in the rpath\n-        // as it makes it significantly more robust against changes to the location of\n-        // the `.nix-deps` location.\n-        //\n-        // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n-        // zlib: Needed as a system dependency of `libLLVM-*.so`.\n-        // patchelf: Needed for patching ELF binaries (see doc comment above).\n-        let nix_deps_dir = builder.out.join(\".nix-deps\");\n-        const NIX_EXPR: &str = \"\n-        with (import <nixpkgs> {});\n-        symlinkJoin {\n-            name = \\\"rust-stage0-dependencies\\\";\n-            paths = [\n-                zlib\n-                patchelf\n-                stdenv.cc.bintools\n-            ];\n-        }\n-        \";\n-        nix_build_succeeded = builder.try_run(Command::new(\"nix-build\").args(&[\n-            Path::new(\"-E\"),\n-            Path::new(NIX_EXPR),\n-            Path::new(\"-o\"),\n-            &nix_deps_dir,\n-        ]));\n-        nix_deps_dir\n-    });\n-    if !nix_build_succeeded {\n-        return;\n-    }\n-\n-    let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n-    let rpath_entries = {\n-        // ORIGIN is a relative default, all binary and dynamic libraries we ship\n-        // appear to have this (even when `../lib` is redundant).\n-        // NOTE: there are only two paths here, delimited by a `:`\n-        let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n-        entries.push(t!(fs::canonicalize(nix_deps_dir)));\n-        entries.push(\"/lib\");\n-        entries\n-    };\n-    patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n-    if !fname.extension().map_or(false, |ext| ext == \"so\") {\n-        // Finally, set the corret .interp for binaries\n-        let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n-        // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n-        let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n-        patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n-    }\n-\n-    builder.try_run(patchelf.arg(fname));\n-}\n-\n-fn download_component(builder: &Builder<'_>, base: &str, url: &str, dest_path: &Path) {\n-    // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n-    let tempfile = builder.tempdir().join(dest_path.file_name().unwrap());\n-    // FIXME: support `do_verify` (only really needed for nightly rustfmt)\n-    // FIXME: support non-utf8 paths?\n-    download_with_retries(builder, tempfile.to_str().unwrap(), &format!(\"{}/{}\", base, url));\n-    t!(std::fs::rename(&tempfile, dest_path));\n-}\n-\n-fn download_with_retries(builder: &Builder<'_>, tempfile: &str, url: &str) {\n-    println!(\"downloading {}\", url);\n-    // Try curl. If that fails and we are on windows, fallback to PowerShell.\n-    if !builder.check_run(Command::new(\"curl\").args(&[\n-        \"-#\",\n-        \"-y\",\n-        \"30\",\n-        \"-Y\",\n-        \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n-        \"--connect-timeout\",\n-        \"30\", // timeout if cannot connect within 30 seconds\n-        \"--retry\",\n-        \"3\",\n-        \"-Sf\",\n-        \"-o\",\n-        tempfile,\n-        url,\n-    ])) {\n-        if builder.build.build.contains(\"windows-msvc\") {\n-            println!(\"Fallback to PowerShell\");\n-            for _ in 0..3 {\n-                if builder.try_run(Command::new(\"PowerShell.exe\").args(&[\n-                    \"/nologo\",\n-                    \"-Command\",\n-                    \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n-                    &format!(\n-                        \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n-                        url, tempfile\n-                    ),\n-                ])) {\n-                    return;\n-                }\n-                println!(\"\\nspurious failure, trying again\");\n-            }\n-        }\n-        std::process::exit(1);\n-    }\n-}\n-\n-fn unpack(builder: &Builder<'_>, tarball: &Path, dst: &Path) {\n-    println!(\"extracting {} to {}\", tarball.display(), dst.display());\n-    if !dst.exists() {\n-        t!(fs::create_dir_all(dst));\n-    }\n-\n-    // FIXME: will need to be a parameter once `download-rustc` is moved to rustbuild\n-    const MATCH: &str = \"rust-dev\";\n-\n-    // `tarball` ends with `.tar.xz`; strip that suffix\n-    // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n-    let uncompressed_filename =\n-        Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n-    let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n-\n-    // decompress the file\n-    let data = t!(File::open(tarball));\n-    let decompressor = XzDecoder::new(BufReader::new(data));\n-\n-    let mut tar = tar::Archive::new(decompressor);\n-    for member in t!(tar.entries()) {\n-        let mut member = t!(member);\n-        let original_path = t!(member.path()).into_owned();\n-        // skip the top-level directory\n-        if original_path == directory_prefix {\n-            continue;\n-        }\n-        let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n-        if !short_path.starts_with(MATCH) {\n-            continue;\n-        }\n-        short_path = t!(short_path.strip_prefix(MATCH));\n-        let dst_path = dst.join(short_path);\n-        builder.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n-        if !t!(member.unpack_in(dst)) {\n-            panic!(\"path traversal attack ??\");\n-        }\n-        let src_path = dst.join(original_path);\n-        if src_path.is_dir() && dst_path.exists() {\n-            continue;\n-        }\n-        t!(fs::rename(src_path, dst_path));\n-    }\n-    t!(fs::remove_dir_all(dst.join(directory_prefix)));\n-}\n-\n-fn program_out_of_date(stamp: &Path, key: &str) -> bool {\n-    if !stamp.exists() {\n-        return true;\n-    }\n-    t!(fs::read_to_string(stamp)) != key\n+    builder.unpack(&tarball, &llvm_root);\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]"}, {"sha": "b4691840618debb39a2533ff04aa8761979fb83f", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=61dd278ade42a2d6d88f1c7b2bf2ee3ffab3b132", "patch": "@@ -115,6 +115,14 @@ impl Drop for TimeIt {\n     }\n }\n \n+/// Used for download caching\n+pub(crate) fn program_out_of_date(stamp: &Path, key: &str) -> bool {\n+    if !stamp.exists() {\n+        return true;\n+    }\n+    t!(fs::read_to_string(stamp)) != key\n+}\n+\n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {"}]}