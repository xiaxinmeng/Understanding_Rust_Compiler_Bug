{"sha": "358a603f110b0489d22f3929d3f232e684fd9ffb", "node_id": "C_kwDOAAsO6NoAKDM1OGE2MDNmMTEwYjA0ODlkMjJmMzkyOWQzZjIzMmU2ODRmZDlmZmI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-10T02:40:56Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-15T22:41:28Z"}, "message": "Use `token::Lit` in `ast::ExprKind::Lit`.\n\nInstead of `ast::Lit`.\n\nLiteral lowering now happens at two different times. Expression literals\nare lowered when HIR is crated. Attribute literals are lowered during\nparsing.\n\nThis commit changes the language very slightly. Some programs that used\nto not compile now will compile. This is because some invalid literals\nthat are removed by `cfg` or attribute macros will no longer trigger\nerrors. See this comment for more details:\nhttps://github.com/rust-lang/rust/pull/102944#issuecomment-1277476773", "tree": {"sha": "e409967cbf3698809be84c84dbf25285dc154bdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e409967cbf3698809be84c84dbf25285dc154bdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/358a603f110b0489d22f3929d3f232e684fd9ffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/358a603f110b0489d22f3929d3f232e684fd9ffb", "html_url": "https://github.com/rust-lang/rust/commit/358a603f110b0489d22f3929d3f232e684fd9ffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/358a603f110b0489d22f3929d3f232e684fd9ffb/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01760265cbdc985af50e7046e7635d124b24e335", "url": "https://api.github.com/repos/rust-lang/rust/commits/01760265cbdc985af50e7046e7635d124b24e335", "html_url": "https://github.com/rust-lang/rust/commit/01760265cbdc985af50e7046e7635d124b24e335"}], "stats": {"total": 1266, "additions": 693, "deletions": 573}, "files": [{"sha": "5d9d0a5fecaccd133f2c69813eba5967278575ca", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1332,7 +1332,7 @@ pub enum ExprKind {\n     /// A unary operation (e.g., `!x`, `*x`).\n     Unary(UnOp, P<Expr>),\n     /// A literal (e.g., `1`, `\"foo\"`).\n-    Lit(Lit),\n+    Lit(token::Lit),\n     /// A cast (e.g., `foo as f64`).\n     Cast(P<Expr>, P<Ty>),\n     /// A type ascription (e.g., `42: usize`).\n@@ -1698,16 +1698,12 @@ pub struct StrLit {\n }\n \n impl StrLit {\n-    pub fn as_lit(&self) -> Lit {\n+    pub fn as_token_lit(&self) -> token::Lit {\n         let token_kind = match self.style {\n             StrStyle::Cooked => token::Str,\n             StrStyle::Raw(n) => token::StrRaw(n),\n         };\n-        Lit {\n-            token_lit: token::Lit::new(token_kind, self.symbol, self.suffix),\n-            span: self.span,\n-            kind: LitKind::Str(self.symbol_unescaped, self.style),\n-        }\n+        token::Lit::new(token_kind, self.symbol, self.suffix)\n     }\n }\n \n@@ -1733,9 +1729,10 @@ pub enum LitFloatType {\n     Unsuffixed,\n }\n \n-/// Literal kind.\n-///\n-/// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n+/// Note that the entire literal (including the suffix) is considered when\n+/// deciding the `LitKind`. This means that float literals like `1f32` are\n+/// classified by this type as `Float`. This is different to `token::LitKind`\n+/// which does *not* consider the suffix.\n #[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`). The symbol is unescaped, and so may differ\n@@ -1749,10 +1746,11 @@ pub enum LitKind {\n     Char(char),\n     /// An integer literal (`1`).\n     Int(u128, LitIntType),\n-    /// A float literal (`1f64` or `1E10f64`). Stored as a symbol rather than\n-    /// `f64` so that `LitKind` can impl `Eq` and `Hash`.\n+    /// A float literal (`1.0`, `1f64` or `1E10f64`). The pre-suffix part is\n+    /// stored as a symbol rather than `f64` so that `LitKind` can impl `Eq`\n+    /// and `Hash`.\n     Float(Symbol, LitFloatType),\n-    /// A boolean literal.\n+    /// A boolean literal (`true`, `false`).\n     Bool(bool),\n     /// Placeholder for a literal that wasn't well-formed in some way.\n     Err,"}, {"sha": "07f982b7e864bb3181f2917077b77a478ce7e662", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -533,7 +533,7 @@ impl MetaItemKind {\n             MetaItemKind::NameValue(lit) => {\n                 let expr = P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n-                    kind: ast::ExprKind::Lit(lit.clone()),\n+                    kind: ast::ExprKind::Lit(lit.token_lit.clone()),\n                     span: lit.span,\n                     attrs: ast::AttrVec::new(),\n                     tokens: None,\n@@ -605,7 +605,7 @@ impl MetaItemKind {\n                 MetaItemKind::name_value_from_tokens(&mut inner_tokens.into_trees())\n             }\n             Some(TokenTree::Token(token, _)) => {\n-                Lit::from_token(&token).ok().map(MetaItemKind::NameValue)\n+                Lit::from_token(&token).map(MetaItemKind::NameValue)\n             }\n             _ => None,\n         }\n@@ -618,8 +618,10 @@ impl MetaItemKind {\n                 MetaItemKind::list_from_tokens(tokens.clone())\n             }\n             MacArgs::Delimited(..) => None,\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => match &expr.kind {\n-                ast::ExprKind::Lit(lit) => Some(MetaItemKind::NameValue(lit.clone())),\n+            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => match expr.kind {\n+                ast::ExprKind::Lit(token_lit) => Some(MetaItemKind::NameValue(\n+                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_mac_args\"),\n+                )),\n                 _ => None,\n             },\n             MacArgs::Eq(_, MacArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n@@ -668,7 +670,7 @@ impl NestedMetaItem {\n     {\n         match tokens.peek() {\n             Some(TokenTree::Token(token, _))\n-                if let Ok(lit) = Lit::from_token(token) =>\n+                if let Some(lit) = Lit::from_token(token) =>\n             {\n                 tokens.next();\n                 return Some(NestedMetaItem::Literal(lit));"}, {"sha": "e0ff690e7667851ebd5c751101b2b2194b0f556f", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -59,13 +59,17 @@ pub enum Delimiter {\n     Invisible,\n }\n \n+// Note that the suffix is *not* considered when deciding the `LitKind` in this\n+// type. This means that float literals like `1f32` are classified by this type\n+// as `Int`. Only upon conversion to `ast::LitKind` will such a literal be\n+// given the `Float` kind.\n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`\n     Byte,\n     Char,\n-    Integer,\n-    Float,\n+    Integer, // e.g. `1`, `1u8`, `1f32`\n+    Float,   // e.g. `1.`, `1.0`, `1e3f32`\n     Str,\n     StrRaw(u8), // raw string delimited by `n` hash symbols\n     ByteStr,\n@@ -81,6 +85,42 @@ pub struct Lit {\n     pub suffix: Option<Symbol>,\n }\n \n+impl Lit {\n+    pub fn new(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Lit {\n+        Lit { kind, symbol, suffix }\n+    }\n+\n+    /// Returns `true` if this is semantically a float literal. This includes\n+    /// ones like `1f32` that have an `Integer` kind but a float suffix.\n+    pub fn is_semantic_float(&self) -> bool {\n+        match self.kind {\n+            LitKind::Float => true,\n+            LitKind::Integer => match self.suffix {\n+                Some(sym) => sym == sym::f32 || sym == sym::f64,\n+                None => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    /// Keep this in sync with `Token::can_begin_literal_or_bool` excluding unary negation.\n+    pub fn from_token(token: &Token) -> Option<Lit> {\n+        match token.uninterpolate().kind {\n+            Ident(name, false) if name.is_bool_lit() => {\n+                Some(Lit::new(Bool, name, None))\n+            }\n+            Literal(token_lit) => Some(token_lit),\n+            Interpolated(ref nt)\n+                if let NtExpr(expr) | NtLiteral(expr) = &**nt\n+                && let ast::ExprKind::Lit(token_lit) = expr.kind =>\n+            {\n+                Some(token_lit.clone())\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl fmt::Display for Lit {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Lit { kind, symbol, suffix } = *self;\n@@ -139,12 +179,6 @@ impl LitKind {\n     }\n }\n \n-impl Lit {\n-    pub fn new(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Lit {\n-        Lit { kind, symbol, suffix }\n-    }\n-}\n-\n pub fn ident_can_begin_expr(name: Symbol, span: Span, is_raw: bool) -> bool {\n     let ident_token = Token::new(Ident(name, is_raw), span);\n "}, {"sha": "db2ac9626afd58e357f284103db6f07f893b42a8", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -8,8 +8,8 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use std::ascii;\n \n+#[derive(Debug)]\n pub enum LitError {\n-    NotLiteral,\n     LexerError,\n     InvalidSuffix,\n     InvalidIntSuffix,\n@@ -202,27 +202,10 @@ impl Lit {\n         Ok(Lit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n     }\n \n-    /// Converts arbitrary token into an AST literal.\n-    ///\n-    /// Keep this in sync with `Token::can_begin_literal_or_bool` excluding unary negation.\n-    pub fn from_token(token: &Token) -> Result<Lit, LitError> {\n-        let lit = match token.uninterpolate().kind {\n-            token::Ident(name, false) if name.is_bool_lit() => {\n-                token::Lit::new(token::Bool, name, None)\n-            }\n-            token::Literal(lit) => lit,\n-            token::Interpolated(ref nt) => {\n-                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt\n-                    && let ast::ExprKind::Lit(lit) = &expr.kind\n-                {\n-                    return Ok(lit.clone());\n-                }\n-                return Err(LitError::NotLiteral);\n-            }\n-            _ => return Err(LitError::NotLiteral),\n-        };\n-\n-        Lit::from_token_lit(lit, token.span)\n+    /// Converts an arbitrary token into an AST literal.\n+    pub fn from_token(token: &Token) -> Option<Lit> {\n+        token::Lit::from_token(token)\n+            .and_then(|token_lit| Lit::from_token_lit(token_lit, token.span).ok())\n     }\n \n     /// Attempts to recover an AST literal from semantic literal."}, {"sha": "b4a8283c4a02d233c311cf4ee6faa1485310683a", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -14,6 +14,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n+use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n@@ -84,8 +85,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::Unary(op, ohs)\n                 }\n-                ExprKind::Lit(ref l) => {\n-                    hir::ExprKind::Lit(respan(self.lower_span(l.span), l.kind.clone()))\n+                ExprKind::Lit(token_lit) => {\n+                    let lit_kind = match LitKind::from_token_lit(token_lit) {\n+                        Ok(lit_kind) => lit_kind,\n+                        Err(err) => {\n+                            report_lit_error(&self.tcx.sess.parse_sess, err, token_lit, e.span);\n+                            LitKind::Err\n+                        }\n+                    };\n+                    hir::ExprKind::Lit(respan(self.lower_span(e.span), lit_kind))\n                 }\n                 ExprKind::IncludedBytes(ref bytes) => hir::ExprKind::Lit(respan(\n                     self.lower_span(e.span),"}, {"sha": "cc93774d846b3e81eb9cc3cb225cea45670585b7", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -959,8 +959,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             MacArgs::Eq(eq_span, MacArgsEq::Ast(ref expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n-                let lit = if let ExprKind::Lit(lit) = &expr.kind {\n-                    lit.clone()\n+                let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n+                    match Lit::from_token_lit(token_lit, expr.span) {\n+                        Ok(lit) => lit,\n+                        Err(_err) => Lit {\n+                            token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n+                            kind: LitKind::Err,\n+                            span: DUMMY_SP,\n+                        },\n+                    }\n                 } else {\n                     Lit {\n                         token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),"}, {"sha": "5f01f555b302b4839e41309471a5a0dc312dc59d", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -373,8 +373,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn print_literal(&mut self, lit: &ast::Lit) {\n-        self.maybe_print_comment(lit.span.lo());\n-        self.word(lit.token_lit.to_string())\n+        self.print_token_literal(lit.token_lit, lit.span)\n+    }\n+\n+    fn print_token_literal(&mut self, token_lit: token::Lit, span: Span) {\n+        self.maybe_print_comment(span.lo());\n+        self.word(token_lit.to_string())\n     }\n \n     fn print_string(&mut self, st: &str, style: ast::StrStyle) {\n@@ -1735,7 +1739,7 @@ impl<'a> State<'a> {\n             }\n             ast::Extern::Explicit(abi, _) => {\n                 self.word_nbsp(\"extern\");\n-                self.print_literal(&abi.as_lit());\n+                self.print_token_literal(abi.as_token_lit(), abi.span);\n                 self.nbsp();\n             }\n         }"}, {"sha": "86f1d6bfecd64931ba0a0382347246f5ea2ba021", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -319,8 +319,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::AddrOf(k, m, ref expr) => {\n                 self.print_expr_addr_of(k, m, expr);\n             }\n-            ast::ExprKind::Lit(ref lit) => {\n-                self.print_literal(lit);\n+            ast::ExprKind::Lit(token_lit) => {\n+                self.print_token_literal(token_lit, expr.span);\n             }\n             ast::ExprKind::IncludedBytes(ref bytes) => {\n                 let lit = ast::Lit::from_included_bytes(bytes, expr.span);"}, {"sha": "9c4425701e0391b955bfded3ae50f19c9d7f7a83", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -207,7 +207,7 @@ impl<'a> State<'a> {\n                     s.word(\"extern\");\n                 }));\n                 if let Some(abi) = nmod.abi {\n-                    self.print_literal(&abi.as_lit());\n+                    self.print_token_literal(abi.as_token_lit(), abi.span);\n                     self.nbsp();\n                 }\n                 self.bopen();"}, {"sha": "a34c17a4258fec5c36d26bcb96b9eb6b52a59de9", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -172,7 +172,11 @@ pub fn parse_asm_args<'a>(\n             // If it can't possibly expand to a string, provide diagnostics here to include other\n             // things it could have been.\n             match template.kind {\n-                ast::ExprKind::Lit(ast::Lit { kind: ast::LitKind::Str(..), .. }) => {}\n+                ast::ExprKind::Lit(token_lit)\n+                    if matches!(\n+                        token_lit.kind,\n+                        token::LitKind::Str | token::LitKind::StrRaw(_)\n+                    ) => {}\n                 ast::ExprKind::MacCall(..) => {}\n                 _ => {\n                     let errstr = if is_global_asm {"}, {"sha": "d579616ad1b84b25cb77fa516f312fd7ae35ce7b", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast as ast;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_expand::base::{self, DummyResult};\n+use rustc_session::errors::report_lit_error;\n use rustc_span::symbol::Symbol;\n \n use std::string::String;\n@@ -18,28 +19,28 @@ pub fn expand_concat(\n     let mut has_errors = false;\n     for e in es {\n         match e.kind {\n-            ast::ExprKind::Lit(ref lit) => match lit.kind {\n-                ast::LitKind::Str(ref s, _) | ast::LitKind::Float(ref s, _) => {\n+            ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+                Ok(ast::LitKind::Str(ref s, _) | ast::LitKind::Float(ref s, _)) => {\n                     accumulator.push_str(s.as_str());\n                 }\n-                ast::LitKind::Char(c) => {\n+                Ok(ast::LitKind::Char(c)) => {\n                     accumulator.push(c);\n                 }\n-                ast::LitKind::Int(\n-                    i,\n-                    ast::LitIntType::Unsigned(_)\n-                    | ast::LitIntType::Signed(_)\n-                    | ast::LitIntType::Unsuffixed,\n-                ) => {\n+                Ok(ast::LitKind::Int(i, _)) => {\n                     accumulator.push_str(&i.to_string());\n                 }\n-                ast::LitKind::Bool(b) => {\n+                Ok(ast::LitKind::Bool(b)) => {\n                     accumulator.push_str(&b.to_string());\n                 }\n-                ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..) => {\n+                Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n                     cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n+                    has_errors = true;\n+                }\n+                Ok(ast::LitKind::Err) => {\n+                    has_errors = true;\n                 }\n-                ast::LitKind::Err => {\n+                Err(err) => {\n+                    report_lit_error(&cx.sess.parse_sess, err, token_lit, e.span);\n                     has_errors = true;\n                 }\n             },"}, {"sha": "87658e60e9d4eb2971874c7664c4c08daf19481d", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -2,32 +2,35 @@ use rustc_ast as ast;\n use rustc_ast::{ptr::P, tokenstream::TokenStream};\n use rustc_errors::Applicability;\n use rustc_expand::base::{self, DummyResult};\n+use rustc_span::Span;\n \n /// Emits errors for literal expressions that are invalid inside and outside of an array.\n-fn invalid_type_err(cx: &mut base::ExtCtxt<'_>, expr: &P<rustc_ast::Expr>, is_nested: bool) {\n-    let ast::ExprKind::Lit(lit) = &expr.kind else {\n-        unreachable!();\n-    };\n-    match lit.kind {\n-        ast::LitKind::Char(_) => {\n-            let mut err = cx.struct_span_err(expr.span, \"cannot concatenate character literals\");\n-            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(expr.span) {\n+fn invalid_type_err(\n+    cx: &mut base::ExtCtxt<'_>,\n+    token_lit: ast::token::Lit,\n+    span: Span,\n+    is_nested: bool,\n+) {\n+    match ast::LitKind::from_token_lit(token_lit) {\n+        Ok(ast::LitKind::Char(_)) => {\n+            let mut err = cx.struct_span_err(span, \"cannot concatenate character literals\");\n+            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n                 err.span_suggestion(\n-                    expr.span,\n+                    span,\n                     \"try using a byte character\",\n                     format!(\"b{}\", snippet),\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n             }\n         }\n-        ast::LitKind::Str(_, _) => {\n-            let mut err = cx.struct_span_err(expr.span, \"cannot concatenate string literals\");\n+        Ok(ast::LitKind::Str(_, _)) => {\n+            let mut err = cx.struct_span_err(span, \"cannot concatenate string literals\");\n             // suggestion would be invalid if we are nested\n             if !is_nested {\n-                if let Ok(snippet) = cx.sess.source_map().span_to_snippet(expr.span) {\n+                if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n                     err.span_suggestion(\n-                        expr.span,\n+                        span,\n                         \"try using a byte string\",\n                         format!(\"b{}\", snippet),\n                         Applicability::MachineApplicable,\n@@ -36,34 +39,34 @@ fn invalid_type_err(cx: &mut base::ExtCtxt<'_>, expr: &P<rustc_ast::Expr>, is_ne\n             }\n             err.emit();\n         }\n-        ast::LitKind::Float(_, _) => {\n-            cx.span_err(expr.span, \"cannot concatenate float literals\");\n+        Ok(ast::LitKind::Float(_, _)) => {\n+            cx.span_err(span, \"cannot concatenate float literals\");\n         }\n-        ast::LitKind::Bool(_) => {\n-            cx.span_err(expr.span, \"cannot concatenate boolean literals\");\n+        Ok(ast::LitKind::Bool(_)) => {\n+            cx.span_err(span, \"cannot concatenate boolean literals\");\n         }\n-        ast::LitKind::Err => {}\n-        ast::LitKind::Int(_, _) if !is_nested => {\n-            let mut err = cx.struct_span_err(expr.span, \"cannot concatenate numeric literals\");\n-            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(expr.span) {\n+        Ok(ast::LitKind::Err) => {}\n+        Ok(ast::LitKind::Int(_, _)) if !is_nested => {\n+            let mut err = cx.struct_span_err(span, \"cannot concatenate numeric literals\");\n+            if let Ok(snippet) = cx.sess.source_map().span_to_snippet(span) {\n                 err.span_suggestion(\n-                    expr.span,\n+                    span,\n                     \"try wrapping the number in an array\",\n                     format!(\"[{}]\", snippet),\n                     Applicability::MachineApplicable,\n                 );\n             }\n             err.emit();\n         }\n-        ast::LitKind::Int(\n+        Ok(ast::LitKind::Int(\n             val,\n             ast::LitIntType::Unsuffixed | ast::LitIntType::Unsigned(ast::UintTy::U8),\n-        ) => {\n+        )) => {\n             assert!(val > u8::MAX.into()); // must be an error\n-            cx.span_err(expr.span, \"numeric literal is out of bounds\");\n+            cx.span_err(span, \"numeric literal is out of bounds\");\n         }\n-        ast::LitKind::Int(_, _) => {\n-            cx.span_err(expr.span, \"numeric literal is not a `u8`\");\n+        Ok(ast::LitKind::Int(_, _)) => {\n+            cx.span_err(span, \"numeric literal is not a `u8`\");\n         }\n         _ => unreachable!(),\n     }\n@@ -83,14 +86,14 @@ fn handle_array_element(\n             *has_errors = true;\n             None\n         }\n-        ast::ExprKind::Lit(ref lit) => match lit.kind {\n-            ast::LitKind::Int(\n+        ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+            Ok(ast::LitKind::Int(\n                 val,\n                 ast::LitIntType::Unsuffixed | ast::LitIntType::Unsigned(ast::UintTy::U8),\n-            ) if val <= u8::MAX.into() => Some(val as u8),\n+            )) if val <= u8::MAX.into() => Some(val as u8),\n \n-            ast::LitKind::Byte(val) => Some(val),\n-            ast::LitKind::ByteStr(_) => {\n+            Ok(ast::LitKind::Byte(val)) => Some(val),\n+            Ok(ast::LitKind::ByteStr(_)) => {\n                 if !*has_errors {\n                     cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n                         .note(\"byte strings are treated as arrays of bytes\")\n@@ -102,7 +105,7 @@ fn handle_array_element(\n             }\n             _ => {\n                 if !*has_errors {\n-                    invalid_type_err(cx, expr, true);\n+                    invalid_type_err(cx, token_lit, expr.span, true);\n                 }\n                 *has_errors = true;\n                 None\n@@ -148,9 +151,9 @@ pub fn expand_concat_bytes(\n                 }\n             }\n             ast::ExprKind::Repeat(ref expr, ref count) => {\n-                if let ast::ExprKind::Lit(ast::Lit {\n-                    kind: ast::LitKind::Int(count_val, _), ..\n-                }) = count.value.kind\n+                if let ast::ExprKind::Lit(token_lit) = count.value.kind\n+                && let Ok(ast::LitKind::Int(count_val, _)) =\n+                    ast::LitKind::from_token_lit(token_lit)\n                 {\n                     if let Some(elem) =\n                         handle_array_element(cx, &mut has_errors, &mut missing_literals, expr)\n@@ -163,16 +166,16 @@ pub fn expand_concat_bytes(\n                     cx.span_err(count.value.span, \"repeat count is not a positive number\");\n                 }\n             }\n-            ast::ExprKind::Lit(ref lit) => match lit.kind {\n-                ast::LitKind::Byte(val) => {\n+            ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+                Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n-                ast::LitKind::ByteStr(ref bytes) => {\n+                Ok(ast::LitKind::ByteStr(ref bytes)) => {\n                     accumulator.extend_from_slice(&bytes);\n                 }\n                 _ => {\n                     if !has_errors {\n-                        invalid_type_err(cx, &e, false);\n+                        invalid_type_err(cx, token_lit, e.span, false);\n                     }\n                     has_errors = true;\n                 }"}, {"sha": "95fff929d46fec32ff55fdb5666afe3884b9f6d7", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1226,10 +1226,10 @@ pub fn expr_to_spanned_string<'a>(\n     let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n \n     Err(match expr.kind {\n-        ast::ExprKind::Lit(ref l) => match l.kind {\n-            ast::LitKind::Str(s, style) => return Ok((s, style, expr.span)),\n-            ast::LitKind::ByteStr(_) => {\n-                let mut err = cx.struct_span_err(l.span, err_msg);\n+        ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+            Ok(ast::LitKind::Str(s, style)) => return Ok((s, style, expr.span)),\n+            Ok(ast::LitKind::ByteStr(_)) => {\n+                let mut err = cx.struct_span_err(expr.span, err_msg);\n                 let span = expr.span.shrink_to_lo();\n                 err.span_suggestion(\n                     span.with_hi(span.lo() + BytePos(1)),\n@@ -1239,8 +1239,9 @@ pub fn expr_to_spanned_string<'a>(\n                 );\n                 Some((err, true))\n             }\n-            ast::LitKind::Err => None,\n-            _ => Some((cx.struct_span_err(l.span, err_msg), false)),\n+            Ok(ast::LitKind::Err) => None,\n+            Err(_) => None,\n+            _ => Some((cx.struct_span_err(expr.span, err_msg), false)),\n         },\n         ast::ExprKind::Err => None,\n         _ => Some((cx.struct_span_err(expr.span, err_msg), false)),"}, {"sha": "8aa72e142f82c25193f58353f6ccb58da650a1dc", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -334,8 +334,8 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     fn expr_lit(&self, span: Span, lit_kind: ast::LitKind) -> P<ast::Expr> {\n-        let lit = ast::Lit::from_lit_kind(lit_kind, span);\n-        self.expr(span, ast::ExprKind::Lit(lit))\n+        let token_lit = lit_kind.to_token_lit();\n+        self.expr(span, ast::ExprKind::Lit(token_lit))\n     }\n \n     pub fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {"}, {"sha": "2e832deeecda0ed0645bbde1d4a5ec6da2ccf808", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -516,14 +516,14 @@ impl server::TokenStream for Rustc<'_, '_> {\n         // We don't use `TokenStream::from_ast` as the tokenstream currently cannot\n         // be recovered in the general case.\n         match &expr.kind {\n-            ast::ExprKind::Lit(l) if l.token_lit.kind == token::Bool => {\n+            ast::ExprKind::Lit(token_lit) if token_lit.kind == token::Bool => {\n                 Ok(tokenstream::TokenStream::token_alone(\n-                    token::Ident(l.token_lit.symbol, false),\n-                    l.span,\n+                    token::Ident(token_lit.symbol, false),\n+                    expr.span,\n                 ))\n             }\n-            ast::ExprKind::Lit(l) => {\n-                Ok(tokenstream::TokenStream::token_alone(token::Literal(l.token_lit), l.span))\n+            ast::ExprKind::Lit(token_lit) => {\n+                Ok(tokenstream::TokenStream::token_alone(token::Literal(*token_lit), expr.span))\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n                 let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n@@ -533,16 +533,13 @@ impl server::TokenStream for Rustc<'_, '_> {\n                 ))\n             }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n-                ast::ExprKind::Lit(l) => match l.token_lit {\n+                ast::ExprKind::Lit(token_lit) => match token_lit {\n                     token::Lit { kind: token::Integer | token::Float, .. } => {\n                         Ok(Self::TokenStream::from_iter([\n                             // FIXME: The span of the `-` token is lost when\n                             // parsing, so we cannot faithfully recover it here.\n                             tokenstream::TokenTree::token_alone(token::BinOp(token::Minus), e.span),\n-                            tokenstream::TokenTree::token_alone(\n-                                token::Literal(l.token_lit),\n-                                l.span,\n-                            ),\n+                            tokenstream::TokenTree::token_alone(token::Literal(*token_lit), e.span),\n                         ]))\n                     }\n                     _ => Err(()),"}, {"sha": "3fbabbc6344a7f3518b10e11b1869bb78d9fd948", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -167,11 +167,15 @@ pub enum DocStyle {\n     Inner,\n }\n \n+// Note that the suffix is *not* considered when deciding the `LiteralKind` in\n+// this type. This means that float literals like `1f32` are classified by this\n+// type as `Int`. (Compare against `rustc_ast::token::LitKind` and\n+// `rustc_ast::ast::LitKind.)\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum LiteralKind {\n-    /// \"12_u8\", \"0o100\", \"0b120i99\"\n+    /// \"12_u8\", \"0o100\", \"0b120i99\", \"1f32\".\n     Int { base: Base, empty_int: bool },\n-    /// \"12.34f32\", \"0b100.100\"\n+    /// \"12.34f32\", \"1e3\", but not \"1f32`.\n     Float { base: Base, empty_exponent: bool },\n     /// \"'a'\", \"'\\\\'\", \"'''\", \"';\"\n     Char { terminated: bool },"}, {"sha": "253ff1f793c558814f269c3400fce9b54cd0fa87", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -98,9 +98,10 @@ fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n impl EarlyLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::While(cond, _, label) = &e.kind\n-            && let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind\n-            && let ast::LitKind::Bool(true) = lit.kind\n-            && !lit.span.from_expansion()\n+            && let cond = pierce_parens(cond)\n+            && let ast::ExprKind::Lit(token_lit) = cond.kind\n+            && let token::Lit { kind: token::Bool, symbol: kw::True, .. } = token_lit\n+            && !cond.span.from_expansion()\n         {\n             let condition_span = e.span.with_hi(cond.span.hi());\n             cx.struct_span_lint("}, {"sha": "7106e75dba290ebcac26a9deac25964eff0afaec", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -123,23 +123,22 @@ impl EarlyLintPass for HiddenUnicodeCodepoints {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         // byte strings are already handled well enough by `EscapeError::NonAsciiCharInByteString`\n-        let (text, span, padding) = match &expr.kind {\n-            ast::ExprKind::Lit(ast::Lit { token_lit, kind, span }) => {\n+        match &expr.kind {\n+            ast::ExprKind::Lit(token_lit) => {\n                 let text = token_lit.symbol;\n                 if !contains_text_flow_control_chars(text.as_str()) {\n                     return;\n                 }\n-                let padding = match kind {\n+                let padding = match token_lit.kind {\n                     // account for `\"` or `'`\n-                    ast::LitKind::Str(_, ast::StrStyle::Cooked) | ast::LitKind::Char(_) => 1,\n+                    ast::token::LitKind::Str | ast::token::LitKind::Char => 1,\n                     // account for `r###\"`\n-                    ast::LitKind::Str(_, ast::StrStyle::Raw(val)) => *val as u32 + 2,\n+                    ast::token::LitKind::StrRaw(n) => n as u32 + 2,\n                     _ => return,\n                 };\n-                (text, span, padding)\n+                self.lint_text_direction_codepoint(cx, text, expr.span, padding, true, \"literal\");\n             }\n-            _ => return,\n+            _ => {}\n         };\n-        self.lint_text_direction_codepoint(cx, text, *span, padding, true, \"literal\");\n     }\n }"}, {"sha": "724d92254a4554dd2a888b2effb91b31e92f80de", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -304,61 +304,6 @@ pub(crate) struct FloatLiteralRequiresIntegerPart {\n     pub correct: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(parser_invalid_int_literal_width)]\n-#[help]\n-pub(crate) struct InvalidIntLiteralWidth {\n-    #[primary_span]\n-    pub span: Span,\n-    pub width: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_invalid_num_literal_base_prefix)]\n-#[note]\n-pub(crate) struct InvalidNumLiteralBasePrefix {\n-    #[primary_span]\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n-    pub span: Span,\n-    pub fixed: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_invalid_num_literal_suffix)]\n-#[help]\n-pub(crate) struct InvalidNumLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_invalid_float_literal_width)]\n-#[help]\n-pub(crate) struct InvalidFloatLiteralWidth {\n-    #[primary_span]\n-    pub span: Span,\n-    pub width: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_invalid_float_literal_suffix)]\n-#[help]\n-pub(crate) struct InvalidFloatLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_int_literal_too_large)]\n-pub(crate) struct IntLiteralTooLarge {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(parser_missing_semicolon_before_array)]\n pub(crate) struct MissingSemicolonBeforeArray {\n@@ -740,41 +685,6 @@ pub(crate) struct InvalidInterpolatedExpression {\n     pub span: Span,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(parser_hexadecimal_float_literal_not_supported)]\n-pub(crate) struct HexadecimalFloatLiteralNotSupported {\n-    #[primary_span]\n-    #[label(parser_not_supported)]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_octal_float_literal_not_supported)]\n-pub(crate) struct OctalFloatLiteralNotSupported {\n-    #[primary_span]\n-    #[label(parser_not_supported)]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_binary_float_literal_not_supported)]\n-pub(crate) struct BinaryFloatLiteralNotSupported {\n-    #[primary_span]\n-    #[label(parser_not_supported)]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser_invalid_literal_suffix)]\n-pub(crate) struct InvalidLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    // FIXME(#100717)\n-    pub kind: String,\n-    pub suffix: Symbol,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(parser_invalid_literal_suffix_on_tuple_index)]\n pub(crate) struct InvalidLiteralSuffixOnTupleIndex {"}, {"sha": "f027843e6b43d469ab5483494543ee9d89b42d98", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -661,6 +661,7 @@ impl<'a> StringReader<'a> {\n         prefix_len: u32,\n         postfix_len: u32,\n     ) -> (token::LitKind, Symbol) {\n+        let mut has_fatal_err = false;\n         let content_start = start + BytePos(prefix_len);\n         let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n@@ -672,6 +673,9 @@ impl<'a> StringReader<'a> {\n                 let lo = content_start + BytePos(start);\n                 let hi = lo + BytePos(end - start);\n                 let span = self.mk_sp(lo, hi);\n+                if err.is_fatal() {\n+                    has_fatal_err = true;\n+                }\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit_content,\n@@ -683,7 +687,14 @@ impl<'a> StringReader<'a> {\n                 );\n             }\n         });\n-        (kind, Symbol::intern(lit_content))\n+\n+        // We normally exclude the quotes for the symbol, but for errors we\n+        // include it because it results in clearer error messages.\n+        if !has_fatal_err {\n+            (kind, Symbol::intern(lit_content))\n+        } else {\n+            (token::Err, self.symbol_from_to(start, end))\n+        }\n     }\n }\n "}, {"sha": "612accf3e3b7713fcef1fdad4c5658723ce1d560", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -316,8 +316,8 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(crate) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n-        let lit = self.parse_lit()?;\n-        debug!(\"checking if {:?} is unusuffixed\", lit);\n+        let lit = self.parse_ast_lit()?;\n+        debug!(\"checking if {:?} is unsuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n             self.sess.emit_err(SuffixedLiteralInAttribute { span: lit.span });"}, {"sha": "c9629ea49e0bf7247e7caaf84cf7457bec65d1d3", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 97, "deletions": 145, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -7,35 +7,30 @@ use super::{\n };\n use crate::errors::{\n     ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncMoveOrderIncorrect,\n-    BinaryFloatLiteralNotSupported, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n-    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n-    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n-    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n-    FoundExprWouldBeStmt, HexadecimalFloatLiteralNotSupported, IfExpressionMissingCondition,\n-    IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, IntLiteralTooLarge,\n+    BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct, ComparisonInterpretedAsGeneric,\n+    ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n+    ExpectedElseBlock, ExpectedEqForLetExpr, ExpectedExpressionFoundLet,\n+    FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n+    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n     InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n-    InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth, InvalidIntLiteralWidth,\n-    InvalidInterpolatedExpression, InvalidLiteralSuffix, InvalidLiteralSuffixOnTupleIndex,\n-    InvalidLogicalOperator, InvalidLogicalOperatorSub, InvalidNumLiteralBasePrefix,\n-    InvalidNumLiteralSuffix, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n+    InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n+    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n     LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n     MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n     MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n     NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n-    OctalFloatLiteralNotSupported, OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n     RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n     StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n     UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n-\n use core::mem;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::Spacing;\n use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n-use rustc_ast::util::literal::LitError;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n use rustc_ast::visit::Visitor;\n use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, Lit, UnOp, DUMMY_NODE_ID};\n@@ -47,7 +42,7 @@ use rustc_errors::{\n     Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n     StashKey,\n };\n-use rustc_session::errors::ExprParenthesesNeeded;\n+use rustc_session::errors::{report_lit_error, ExprParenthesesNeeded};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::source_map::{self, Span, Spanned};\n@@ -1415,9 +1410,9 @@ impl<'a> Parser<'a> {\n \n     fn parse_lit_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n-        match self.parse_opt_lit() {\n-            Some(literal) => {\n-                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal));\n+        match self.parse_opt_token_lit() {\n+            Some((token_lit, _)) => {\n+                let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(token_lit));\n                 self.maybe_recover_from_bad_qpath(expr)\n             }\n             None => self.try_macro_suggestion(),\n@@ -1548,7 +1543,7 @@ impl<'a> Parser<'a> {\n                 })\n             });\n             consume_colon = false;\n-            Ok(self.mk_expr(lo, ExprKind::Lit(lit)))\n+            Ok(self.mk_expr(lo, ExprKind::Lit(lit.token_lit)))\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1625,9 +1620,9 @@ impl<'a> Parser<'a> {\n \n     /// Emit an error when a char is parsed as a lifetime because of a missing quote\n     pub(super) fn recover_unclosed_char(\n-        &mut self,\n+        &self,\n         lifetime: Ident,\n-        err: impl FnOnce(&mut Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n+        err: impl FnOnce(&Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n     ) -> ast::Lit {\n         if let Some(mut diag) =\n             self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n@@ -1649,9 +1644,10 @@ impl<'a> Parser<'a> {\n                 )\n                 .emit();\n         }\n+        let name = lifetime.without_first_quote().name;\n         ast::Lit {\n-            token_lit: token::Lit::new(token::LitKind::Char, lifetime.name, None),\n-            kind: ast::LitKind::Char(lifetime.name.as_str().chars().next().unwrap_or('_')),\n+            token_lit: token::Lit::new(token::LitKind::Char, name, None),\n+            kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n             span: lifetime.span,\n         }\n     }\n@@ -1765,7 +1761,7 @@ impl<'a> Parser<'a> {\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n     pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<Lit>> {\n-        match self.parse_opt_lit() {\n+        match self.parse_opt_ast_lit() {\n             Some(lit) => match lit.kind {\n                 ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n                     style,\n@@ -1780,41 +1776,47 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        self.parse_opt_lit().ok_or(()).or_else(|()| {\n-            if let token::Interpolated(inner) = &self.token.kind {\n-                let expr = match inner.as_ref() {\n-                    token::NtExpr(expr) => Some(expr),\n-                    token::NtLiteral(expr) => Some(expr),\n-                    _ => None,\n-                };\n-                if let Some(expr) = expr {\n-                    if matches!(expr.kind, ExprKind::Err) {\n-                        let mut err = InvalidInterpolatedExpression { span: self.token.span }\n-                            .into_diagnostic(&self.sess.span_diagnostic);\n-                        err.downgrade_to_delayed_bug();\n-                        return Err(err);\n-                    }\n-                }\n-            }\n-            let token = self.token.clone();\n-            let err = |self_: &mut Self| {\n-                let msg = format!(\"unexpected token: {}\", super::token_descr(&token));\n-                self_.struct_span_err(token.span, &msg)\n+    fn handle_missing_lit(&mut self) -> PResult<'a, Lit> {\n+        if let token::Interpolated(inner) = &self.token.kind {\n+            let expr = match inner.as_ref() {\n+                token::NtExpr(expr) => Some(expr),\n+                token::NtLiteral(expr) => Some(expr),\n+                _ => None,\n             };\n-            // On an error path, eagerly consider a lifetime to be an unclosed character lit\n-            if self.token.is_lifetime() {\n-                let lt = self.expect_lifetime();\n-                Ok(self.recover_unclosed_char(lt.ident, err))\n-            } else {\n-                Err(err(self))\n+            if let Some(expr) = expr {\n+                if matches!(expr.kind, ExprKind::Err) {\n+                    let mut err = InvalidInterpolatedExpression { span: self.token.span }\n+                        .into_diagnostic(&self.sess.span_diagnostic);\n+                    err.downgrade_to_delayed_bug();\n+                    return Err(err);\n+                }\n             }\n-        })\n+        }\n+        let token = self.token.clone();\n+        let err = |self_: &Self| {\n+            let msg = format!(\"unexpected token: {}\", super::token_descr(&token));\n+            self_.struct_span_err(token.span, &msg)\n+        };\n+        // On an error path, eagerly consider a lifetime to be an unclosed character lit\n+        if self.token.is_lifetime() {\n+            let lt = self.expect_lifetime();\n+            Ok(self.recover_unclosed_char(lt.ident, err))\n+        } else {\n+            Err(err(self))\n+        }\n     }\n \n-    /// Matches `lit = true | false | token_lit`.\n-    /// Returns `None` if the next token is not a literal.\n-    pub(super) fn parse_opt_lit(&mut self) -> Option<Lit> {\n+    pub(super) fn parse_token_lit(&mut self) -> PResult<'a, (token::Lit, Span)> {\n+        self.parse_opt_token_lit()\n+            .ok_or(())\n+            .or_else(|()| self.handle_missing_lit().map(|lit| (lit.token_lit, lit.span)))\n+    }\n+\n+    pub(super) fn parse_ast_lit(&mut self) -> PResult<'a, Lit> {\n+        self.parse_opt_ast_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n+    }\n+\n+    fn recover_after_dot(&mut self) -> Option<Token> {\n         let mut recovered = None;\n         if self.token == token::Dot {\n             // Attempt to recover `.4` as `0.4`. We don't currently have any syntax where\n@@ -1840,100 +1842,50 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let token = recovered.as_ref().unwrap_or(&self.token);\n-        match Lit::from_token(token) {\n-            Ok(lit) => {\n-                self.bump();\n-                Some(lit)\n-            }\n-            Err(LitError::NotLiteral) => None,\n-            Err(err) => {\n-                let span = token.span;\n-                let token::Literal(lit) = token.kind else {\n-                    unreachable!();\n-                };\n-                self.bump();\n-                self.report_lit_error(err, lit, span);\n-                // Pack possible quotes and prefixes from the original literal into\n-                // the error literal's symbol so they can be pretty-printed faithfully.\n-                let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n-                let symbol = Symbol::intern(&suffixless_lit.to_string());\n-                let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                Some(Lit::from_token_lit(lit, span).unwrap_or_else(|_| unreachable!()))\n-            }\n-        }\n+        recovered\n     }\n \n-    fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n-        // Checks if `s` looks like i32 or u1234 etc.\n-        fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n-            s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n-        }\n-\n-        // Try to lowercase the prefix if it's a valid base prefix.\n-        fn fix_base_capitalisation(s: &str) -> Option<String> {\n-            if let Some(stripped) = s.strip_prefix('B') {\n-                Some(format!(\"0b{stripped}\"))\n-            } else if let Some(stripped) = s.strip_prefix('O') {\n-                Some(format!(\"0o{stripped}\"))\n-            } else if let Some(stripped) = s.strip_prefix('X') {\n-                Some(format!(\"0x{stripped}\"))\n-            } else {\n-                None\n-            }\n-        }\n+    /// Matches `lit = true | false | token_lit`.\n+    /// Returns `None` if the next token is not a literal.\n+    pub(super) fn parse_opt_token_lit(&mut self) -> Option<(token::Lit, Span)> {\n+        let recovered = self.recover_after_dot();\n+        let token = recovered.as_ref().unwrap_or(&self.token);\n+        let span = token.span;\n+        token::Lit::from_token(token).map(|token_lit| {\n+            self.bump();\n+            (token_lit, span)\n+        })\n+    }\n \n-        let token::Lit { kind, suffix, .. } = lit;\n-        match err {\n-            // `NotLiteral` is not an error by itself, so we don't report\n-            // it and give the parser opportunity to try something else.\n-            LitError::NotLiteral => {}\n-            // `LexerError` *is* an error, but it was already reported\n-            // by lexer, so here we don't report it the second time.\n-            LitError::LexerError => {}\n-            LitError::InvalidSuffix => {\n-                if let Some(suffix) = suffix {\n-                    self.sess.emit_err(InvalidLiteralSuffix {\n-                        span,\n-                        kind: format!(\"{}\", kind.descr()),\n-                        suffix,\n-                    });\n-                }\n-            }\n-            LitError::InvalidIntSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\");\n-                let suf = suf.as_str();\n-                if looks_like_width_suffix(&['i', 'u'], &suf) {\n-                    // If it looks like a width, try to be helpful.\n-                    self.sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n-                } else if let Some(fixed) = fix_base_capitalisation(suf) {\n-                    self.sess.emit_err(InvalidNumLiteralBasePrefix { span, fixed });\n-                } else {\n-                    self.sess.emit_err(InvalidNumLiteralSuffix { span, suffix: suf.to_string() });\n-                }\n-            }\n-            LitError::InvalidFloatSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\");\n-                let suf = suf.as_str();\n-                if looks_like_width_suffix(&['f'], suf) {\n-                    // If it looks like a width, try to be helpful.\n-                    self.sess\n-                        .emit_err(InvalidFloatLiteralWidth { span, width: suf[1..].to_string() });\n-                } else {\n-                    self.sess.emit_err(InvalidFloatLiteralSuffix { span, suffix: suf.to_string() });\n+    /// Matches `lit = true | false | token_lit`.\n+    /// Returns `None` if the next token is not a literal.\n+    pub(super) fn parse_opt_ast_lit(&mut self) -> Option<Lit> {\n+        let recovered = self.recover_after_dot();\n+        let token = recovered.as_ref().unwrap_or(&self.token);\n+        match token::Lit::from_token(token) {\n+            Some(token_lit) => {\n+                match Lit::from_token_lit(token_lit, token.span) {\n+                    Ok(lit) => {\n+                        self.bump();\n+                        Some(lit)\n+                    }\n+                    Err(err) => {\n+                        let span = token.span;\n+                        let token::Literal(lit) = token.kind else {\n+                            unreachable!();\n+                        };\n+                        self.bump();\n+                        report_lit_error(&self.sess, err, lit, span);\n+                        // Pack possible quotes and prefixes from the original literal into\n+                        // the error literal's symbol so they can be pretty-printed faithfully.\n+                        let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n+                        let symbol = Symbol::intern(&suffixless_lit.to_string());\n+                        let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n+                        Some(Lit::from_token_lit(lit, span).unwrap_or_else(|_| unreachable!()))\n+                    }\n                 }\n             }\n-            LitError::NonDecimalFloat(base) => {\n-                match base {\n-                    16 => self.sess.emit_err(HexadecimalFloatLiteralNotSupported { span }),\n-                    8 => self.sess.emit_err(OctalFloatLiteralNotSupported { span }),\n-                    2 => self.sess.emit_err(BinaryFloatLiteralNotSupported { span }),\n-                    _ => unreachable!(),\n-                };\n-            }\n-            LitError::IntTooLarge => {\n-                self.sess.emit_err(IntLiteralTooLarge { span });\n-            }\n+            None => None,\n         }\n     }\n \n@@ -1958,8 +1910,8 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n-        let lit = self.parse_lit()?;\n-        let expr = self.mk_expr(lit.span, ExprKind::Lit(lit));\n+        let (token_lit, span) = self.parse_token_lit()?;\n+        let expr = self.mk_expr(span, ExprKind::Lit(token_lit));\n \n         if minus_present {\n             Ok(self.mk_expr(lo.to(self.prev_token.span), self.mk_unary(UnOp::Neg, expr)))"}, {"sha": "b3af37a5f7029241d538fe34d1a31abdb179b340", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -420,7 +420,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(self_.token.span, format!(\"expected {}\", expected));\n                 err\n             });\n-            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit)))\n+            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit.token_lit)))\n         } else {\n             // Try to parse everything else as literal with optional minus\n             match self.parse_literal_maybe_minus() {"}, {"sha": "7820bbc178948c4f986f31055927e19f33112370", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -359,7 +359,7 @@ impl<'a> Parser<'a> {\n     /// report error for `let 1x = 123`\n     pub fn report_invalid_identifier_error(&mut self) -> PResult<'a, ()> {\n         if let token::Literal(lit) = self.token.uninterpolate().kind &&\n-            let Err(_) = rustc_ast::Lit::from_token(&self.token) &&\n+            rustc_ast::Lit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n                 return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));"}, {"sha": "8e7f8bfe0f540ecb897b75b513d4975eeb67bf91", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -49,10 +49,12 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n                 MetaItemKind::List(nmis)\n             }\n             MacArgs::Eq(_, MacArgsEq::Ast(expr)) => {\n-                if let ast::ExprKind::Lit(lit) = &expr.kind {\n-                    if !lit.kind.is_unsuffixed() {\n+                if let ast::ExprKind::Lit(token_lit) = expr.kind\n+                    && let Ok(lit) = ast::Lit::from_token_lit(token_lit, expr.span)\n+                {\n+                    if token_lit.suffix.is_some() {\n                         let mut err = sess.span_diagnostic.struct_span_err(\n-                            lit.span,\n+                            expr.span,\n                             \"suffixed literals are not allowed in attributes\",\n                         );\n                         err.help(\n@@ -61,7 +63,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n                         );\n                         return Err(err);\n                     } else {\n-                        MetaItemKind::NameValue(lit.clone())\n+                        MetaItemKind::NameValue(lit)\n                     }\n                 } else {\n                     // The non-error case can happen with e.g. `#[foo = 1+1]`. The error case can"}, {"sha": "4bfa583fc72bbd441fabac9bf57627e3ca4ad06c", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,6 +1,9 @@\n use std::num::NonZeroU32;\n \n use crate::cgu_reuse_tracker::CguReuse;\n+use crate::parse::ParseSess;\n+use rustc_ast::token;\n+use rustc_ast::util::literal::LitError;\n use rustc_errors::MultiSpan;\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n@@ -191,3 +194,162 @@ pub enum UnleashedFeatureHelp {\n         span: Span,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_invalid_literal_suffix)]\n+pub(crate) struct InvalidLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    // FIXME(#100717)\n+    pub kind: String,\n+    pub suffix: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_invalid_int_literal_width)]\n+#[help]\n+pub(crate) struct InvalidIntLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_invalid_num_literal_base_prefix)]\n+#[note]\n+pub(crate) struct InvalidNumLiteralBasePrefix {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n+    pub span: Span,\n+    pub fixed: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_invalid_num_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidNumLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_invalid_float_literal_width)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_invalid_float_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_int_literal_too_large)]\n+pub(crate) struct IntLiteralTooLarge {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_hexadecimal_float_literal_not_supported)]\n+pub(crate) struct HexadecimalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser_not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_octal_float_literal_not_supported)]\n+pub(crate) struct OctalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser_not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser_binary_float_literal_not_supported)]\n+pub(crate) struct BinaryFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser_not_supported)]\n+    pub span: Span,\n+}\n+\n+pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span: Span) {\n+    // Checks if `s` looks like i32 or u1234 etc.\n+    fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n+        s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n+    }\n+\n+    // Try to lowercase the prefix if it's a valid base prefix.\n+    fn fix_base_capitalisation(s: &str) -> Option<String> {\n+        if let Some(stripped) = s.strip_prefix('B') {\n+            Some(format!(\"0b{stripped}\"))\n+        } else if let Some(stripped) = s.strip_prefix('O') {\n+            Some(format!(\"0o{stripped}\"))\n+        } else if let Some(stripped) = s.strip_prefix('X') {\n+            Some(format!(\"0x{stripped}\"))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    let token::Lit { kind, suffix, .. } = lit;\n+    match err {\n+        // `LexerError` is an error, but it was already reported\n+        // by lexer, so here we don't report it the second time.\n+        LitError::LexerError => {}\n+        LitError::InvalidSuffix => {\n+            if let Some(suffix) = suffix {\n+                sess.emit_err(InvalidLiteralSuffix {\n+                    span,\n+                    kind: format!(\"{}\", kind.descr()),\n+                    suffix,\n+                });\n+            }\n+        }\n+        LitError::InvalidIntSuffix => {\n+            let suf = suffix.expect(\"suffix error with no suffix\");\n+            let suf = suf.as_str();\n+            if looks_like_width_suffix(&['i', 'u'], &suf) {\n+                // If it looks like a width, try to be helpful.\n+                sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n+            } else if let Some(fixed) = fix_base_capitalisation(suf) {\n+                sess.emit_err(InvalidNumLiteralBasePrefix { span, fixed });\n+            } else {\n+                sess.emit_err(InvalidNumLiteralSuffix { span, suffix: suf.to_string() });\n+            }\n+        }\n+        LitError::InvalidFloatSuffix => {\n+            let suf = suffix.expect(\"suffix error with no suffix\");\n+            let suf = suf.as_str();\n+            if looks_like_width_suffix(&['f'], suf) {\n+                // If it looks like a width, try to be helpful.\n+                sess.emit_err(InvalidFloatLiteralWidth { span, width: suf[1..].to_string() });\n+            } else {\n+                sess.emit_err(InvalidFloatLiteralSuffix { span, suffix: suf.to_string() });\n+            }\n+        }\n+        LitError::NonDecimalFloat(base) => {\n+            match base {\n+                16 => sess.emit_err(HexadecimalFloatLiteralNotSupported { span }),\n+                8 => sess.emit_err(OctalFloatLiteralNotSupported { span }),\n+                2 => sess.emit_err(BinaryFloatLiteralNotSupported { span }),\n+                _ => unreachable!(),\n+            };\n+        }\n+        LitError::IntTooLarge => {\n+            sess.emit_err(IntLiteralTooLarge { span });\n+        }\n+    }\n+}"}, {"sha": "19aae1d3c9511f4fd9011621558401107f99f0bc", "filename": "src/test/ui/codemap_tests/unicode_2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode_2.stderr?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,3 +1,9 @@\n+error[E0425]: cannot find value `a\u0310\u00e9` in this scope\n+  --> $DIR/unicode_2.rs:4:13\n+   |\n+LL |     let _ = a\u0310e\u0301;\n+   |             ^^ not found in this scope\n+\n error: invalid width `7` for integer literal\n   --> $DIR/unicode_2.rs:2:25\n    |\n@@ -14,12 +20,6 @@ LL |     let _ = (\"\uc544\u3042\", 1i42);\n    |\n    = help: valid widths are 8, 16, 32, 64 and 128\n \n-error[E0425]: cannot find value `a\u0310\u00e9` in this scope\n-  --> $DIR/unicode_2.rs:4:13\n-   |\n-LL |     let _ = a\u0310e\u0301;\n-   |             ^^ not found in this scope\n-\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "c8d88f745a1f0e22e328ff235afd1b3cc7d5b398", "filename": "src/test/ui/lexer/error-stage.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Flexer%2Ferror-stage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Flexer%2Ferror-stage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexer%2Ferror-stage.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,31 +1,80 @@\n+// This test is about the treatment of invalid literals. In particular, some\n+// literals are only considered invalid if they survive to HIR lowering.\n+//\n+// Literals with bad suffixes\n+// --------------------------\n+// Literals consist of a primary part and an optional suffix.\n+// https://doc.rust-lang.org/reference/tokens.html#suffixes says:\n+//\n+//   Any kind of literal (string, integer, etc) with any suffix is valid as a\n+//   token, and can be passed to a macro without producing an error. The macro\n+//   itself will decide how to interpret such a token and whether to produce an\n+//   error or not.\n+//\n+//   ```\n+//   macro_rules! blackhole { ($tt:tt) => () }\n+//   blackhole!(\"string\"suffix); // OK\n+//   ```\n+//\n+//   However, suffixes on literal tokens parsed as Rust code are restricted.\n+//   Any suffixes are rejected on non-numeric literal tokens, and numeric\n+//   literal tokens are accepted only with suffixes from the list below.\n+//\n+//   Integer: u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, usize, isize\n+//   Floating-point: f32, f64\n+//\n+// This means that something like `\"string\"any_suffix` is a token accepted by\n+// the lexer, but rejected later for being an invalid combination of primary\n+// part and suffix.\n+//\n+// `0b10f32` is a similar case. `0b10` is a valid primary part that is a valid\n+// *integer* literal when no suffix is present. It only causes an error later\n+// when combined with the `f32` float suffix.\n+//\n+// However, `0b10.0f32` is different. It is rejected by the lexer because\n+// `0b10.0` is not a valid token even on its own.\n+//\n+// This difference is unfortunate, but it's baked into the language now.\n+//\n+// Too-large integer literals\n+// --------------------------\n+// https://doc.rust-lang.org/reference/tokens.html#integer-literals says that\n+// literals like `128_i8` and `256_u8` \"are too big for their type, but are\n+// still valid tokens\".\n+\n macro_rules! sink {\n     ($($x:tt;)*) => {()}\n }\n \n-// The invalid literals are ignored because the macro consumes them.\n+// The invalid literals are ignored because the macro consumes them. Except for\n+// `0b10.0f32` because it's a lexer error.\n const _: () = sink! {\n     \"string\"any_suffix; // OK\n     10u123; // OK\n     10.0f123; // OK\n     0b10f32; // OK\n+    0b10.0f32; //~ ERROR binary float literal is not supported\n     999340282366920938463463374607431768211455999; // OK\n };\n \n-// The invalid literals cause errors.\n+// The invalid literals used to cause errors, but this was changed by #102944.\n+// Except for `0b010.0f32`, because it's a lexer error.\n #[cfg(FALSE)]\n fn configured_out() {\n-    \"string\"any_suffix; //~ ERROR suffixes on string literals are invalid\n-    10u123; //~ ERROR invalid width `123` for integer literal\n-    10.0f123; //~ ERROR invalid width `123` for float literal\n-    0b10f32; //~ ERROR binary float literal is not supported\n-    999340282366920938463463374607431768211455999; //~ ERROR integer literal is too large\n+    \"string\"any_suffix; // OK\n+    10u123; // OK\n+    10.0f123; // OK\n+    0b10f32; // OK\n+    0b10.0f32; //~ ERROR binary float literal is not supported\n+    999340282366920938463463374607431768211455999; // OK\n }\n \n-// The invalid literals cause errors.\n+// All the invalid literals cause errors.\n fn main() {\n     \"string\"any_suffix; //~ ERROR suffixes on string literals are invalid\n     10u123; //~ ERROR invalid width `123` for integer literal\n     10.0f123; //~ ERROR invalid width `123` for float literal\n     0b10f32; //~ ERROR binary float literal is not supported\n+    0b10.0f32; //~ ERROR binary float literal is not supported\n     999340282366920938463463374607431768211455999; //~ ERROR integer literal is too large\n }"}, {"sha": "697a7c28da16d5743bcd23728fd040ad5383b9a2", "filename": "src/test/ui/lexer/error-stage.stderr", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Flexer%2Ferror-stage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Flexer%2Ferror-stage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexer%2Ferror-stage.stderr?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,70 +1,54 @@\n-error: suffixes on string literals are invalid\n-  --> $DIR/error-stage.rs:17:5\n-   |\n-LL |     \"string\"any_suffix;\n-   |     ^^^^^^^^^^^^^^^^^^ invalid suffix `any_suffix`\n-\n-error: invalid width `123` for integer literal\n-  --> $DIR/error-stage.rs:18:5\n+error: binary float literal is not supported\n+  --> $DIR/error-stage.rs:56:5\n    |\n-LL |     10u123;\n+LL |     0b10.0f32;\n    |     ^^^^^^\n-   |\n-   = help: valid widths are 8, 16, 32, 64 and 128\n-\n-error: invalid width `123` for float literal\n-  --> $DIR/error-stage.rs:19:5\n-   |\n-LL |     10.0f123;\n-   |     ^^^^^^^^\n-   |\n-   = help: valid widths are 32 and 64\n \n error: binary float literal is not supported\n-  --> $DIR/error-stage.rs:20:5\n+  --> $DIR/error-stage.rs:68:5\n    |\n-LL |     0b10f32;\n-   |     ^^^^^^^ not supported\n+LL |     0b10.0f32;\n+   |     ^^^^^^\n \n-error: integer literal is too large\n-  --> $DIR/error-stage.rs:21:5\n+error: binary float literal is not supported\n+  --> $DIR/error-stage.rs:78:5\n    |\n-LL |     999340282366920938463463374607431768211455999;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     0b10.0f32;\n+   |     ^^^^^^\n \n error: suffixes on string literals are invalid\n-  --> $DIR/error-stage.rs:26:5\n+  --> $DIR/error-stage.rs:74:5\n    |\n LL |     \"string\"any_suffix;\n    |     ^^^^^^^^^^^^^^^^^^ invalid suffix `any_suffix`\n \n error: invalid width `123` for integer literal\n-  --> $DIR/error-stage.rs:27:5\n+  --> $DIR/error-stage.rs:75:5\n    |\n LL |     10u123;\n    |     ^^^^^^\n    |\n    = help: valid widths are 8, 16, 32, 64 and 128\n \n error: invalid width `123` for float literal\n-  --> $DIR/error-stage.rs:28:5\n+  --> $DIR/error-stage.rs:76:5\n    |\n LL |     10.0f123;\n    |     ^^^^^^^^\n    |\n    = help: valid widths are 32 and 64\n \n error: binary float literal is not supported\n-  --> $DIR/error-stage.rs:29:5\n+  --> $DIR/error-stage.rs:77:5\n    |\n LL |     0b10f32;\n    |     ^^^^^^^ not supported\n \n error: integer literal is too large\n-  --> $DIR/error-stage.rs:30:5\n+  --> $DIR/error-stage.rs:79:5\n    |\n LL |     999340282366920938463463374607431768211455999;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "8cb9ef7e0c9219d88785bac368c2317252d699cc", "filename": "src/test/ui/parser/bad-lit-suffixes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -28,12 +28,11 @@ fn main() {\n }\n \n #[rustc_dummy = \"string\"suffix]\n-//~^ ERROR suffixes on string literals are invalid\n+//~^ ERROR unexpected expression: `\"string\"suffix`\n fn f() {}\n \n #[must_use = \"string\"suffix]\n-//~^ ERROR suffixes on string literals are invalid\n-//~^^ ERROR malformed `must_use` attribute input\n+//~^ ERROR unexpected expression: `\"string\"suffix`\n fn g() {}\n \n #[link(name = \"string\"suffix)]"}, {"sha": "756f99ab12c82cf971545bb701ad8401860254f7", "filename": "src/test/ui/parser/bad-lit-suffixes.stderr", "status": "modified", "additions": 27, "deletions": 40, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -10,6 +10,32 @@ error: suffixes on string literals are invalid\n LL |     \"C\"suffix\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n+error: unexpected expression: `\"string\"suffix`\n+  --> $DIR/bad-lit-suffixes.rs:30:17\n+   |\n+LL | #[rustc_dummy = \"string\"suffix]\n+   |                 ^^^^^^^^^^^^^^\n+\n+error: unexpected expression: `\"string\"suffix`\n+  --> $DIR/bad-lit-suffixes.rs:34:14\n+   |\n+LL | #[must_use = \"string\"suffix]\n+   |              ^^^^^^^^^^^^^^\n+\n+error: suffixes on string literals are invalid\n+  --> $DIR/bad-lit-suffixes.rs:38:15\n+   |\n+LL | #[link(name = \"string\"suffix)]\n+   |               ^^^^^^^^^^^^^^ invalid suffix `suffix`\n+\n+error: invalid suffix `suffix` for number literal\n+  --> $DIR/bad-lit-suffixes.rs:42:41\n+   |\n+LL | #[rustc_layout_scalar_valid_range_start(0suffix)]\n+   |                                         ^^^^^^^ invalid suffix `suffix`\n+   |\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n error: suffixes on string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:12:5\n    |\n@@ -110,44 +136,5 @@ LL |     1.0e10suffix;\n    |\n    = help: valid suffixes are `f32` and `f64`\n \n-error: suffixes on string literals are invalid\n-  --> $DIR/bad-lit-suffixes.rs:30:17\n-   |\n-LL | #[rustc_dummy = \"string\"suffix]\n-   |                 ^^^^^^^^^^^^^^ invalid suffix `suffix`\n-\n-error: suffixes on string literals are invalid\n-  --> $DIR/bad-lit-suffixes.rs:34:14\n-   |\n-LL | #[must_use = \"string\"suffix]\n-   |              ^^^^^^^^^^^^^^ invalid suffix `suffix`\n-\n-error: malformed `must_use` attribute input\n-  --> $DIR/bad-lit-suffixes.rs:34:1\n-   |\n-LL | #[must_use = \"string\"suffix]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: the following are the possible correct uses\n-   |\n-LL | #[must_use = \"reason\"]\n-   |\n-LL | #[must_use]\n-   |\n-\n-error: suffixes on string literals are invalid\n-  --> $DIR/bad-lit-suffixes.rs:39:15\n-   |\n-LL | #[link(name = \"string\"suffix)]\n-   |               ^^^^^^^^^^^^^^ invalid suffix `suffix`\n-\n-error: invalid suffix `suffix` for number literal\n-  --> $DIR/bad-lit-suffixes.rs:43:41\n-   |\n-LL | #[rustc_layout_scalar_valid_range_start(0suffix)]\n-   |                                         ^^^^^^^ invalid suffix `suffix`\n-   |\n-   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n-\n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "df92579a85df280a7846addaad0aa94045ed4fc1", "filename": "src/tools/clippy/clippy_lints/src/almost_complete_letter_range.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Falmost_complete_letter_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Falmost_complete_letter_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Falmost_complete_letter_range.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -73,12 +73,21 @@ impl EarlyLintPass for AlmostCompleteLetterRange {\n }\n \n fn check_range(cx: &EarlyContext<'_>, span: Span, start: &Expr, end: &Expr, sugg: Option<(Span, &str)>) {\n-    if let ExprKind::Lit(start_lit) = &start.peel_parens().kind\n-        && let ExprKind::Lit(end_lit) = &end.peel_parens().kind\n+    if let ExprKind::Lit(start_token_lit) = start.peel_parens().kind\n+        && let ExprKind::Lit(end_token_lit) = end.peel_parens().kind\n         && matches!(\n-            (&start_lit.kind, &end_lit.kind),\n-            (LitKind::Byte(b'a') | LitKind::Char('a'), LitKind::Byte(b'z') | LitKind::Char('z'))\n-            | (LitKind::Byte(b'A') | LitKind::Char('A'), LitKind::Byte(b'Z') | LitKind::Char('Z'))\n+            (\n+                LitKind::from_token_lit(start_token_lit),\n+                LitKind::from_token_lit(end_token_lit),\n+            ),\n+            (\n+                Ok(LitKind::Byte(b'a') | LitKind::Char('a')),\n+                Ok(LitKind::Byte(b'z') | LitKind::Char('z'))\n+            )\n+            | (\n+                Ok(LitKind::Byte(b'A') | LitKind::Char('A')),\n+                Ok(LitKind::Byte(b'Z') | LitKind::Char('Z')),\n+            )\n         )\n         && !in_external_macro(cx.sess(), span)\n     {"}, {"sha": "f793abdfda34a83d0ac69893ee450a2cfafee12b", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -2,7 +2,8 @@\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast::{BinOpKind, Expr, ExprKind, Lit, LitKind};\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, LitKind};\n+use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -52,8 +53,8 @@ enum Side {\n \n impl IntPlusOne {\n     #[expect(clippy::cast_sign_loss)]\n-    fn check_lit(lit: &Lit, target_value: i128) -> bool {\n-        if let LitKind::Int(value, ..) = lit.kind {\n+    fn check_lit(token_lit: token::Lit, target_value: i128) -> bool {\n+        if let Ok(LitKind::Int(value, ..)) = LitKind::from_token_lit(token_lit) {\n             return value == (target_value as u128);\n         }\n         false\n@@ -65,11 +66,11 @@ impl IntPlusOne {\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, &ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n@@ -81,10 +82,10 @@ impl IntPlusOne {\n             {\n                 match (&rhslhs.kind, &rhsrhs.kind) {\n                     // `y + 1` and `1 + y`\n-                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                    (&ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n-                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (_, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,\n@@ -96,10 +97,10 @@ impl IntPlusOne {\n             {\n                 match (&lhslhs.kind, &lhsrhs.kind) {\n                     // `1 + x` and `x + 1`\n-                    (&ExprKind::Lit(ref lit), _) if Self::check_lit(lit, 1) => {\n+                    (&ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n-                    (_, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (_, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n@@ -109,11 +110,11 @@ impl IntPlusOne {\n             (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, &ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,"}, {"sha": "3a7b7835c990f6adbe021b9e079b49b0c0217ce5", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -5,11 +5,13 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::numeric_literal::{NumericLiteral, Radix};\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n+use rustc_ast::ast::{Expr, ExprKind, LitKind};\n+use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n use std::iter;\n \n declare_clippy_lint! {\n@@ -236,8 +238,8 @@ impl EarlyLintPass for LiteralDigitGrouping {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit);\n+        if let ExprKind::Lit(lit) = expr.kind {\n+            self.check_lit(cx, lit, expr.span);\n         }\n     }\n }\n@@ -252,12 +254,13 @@ impl LiteralDigitGrouping {\n         }\n     }\n \n-    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: token::Lit, span: Span) {\n         if_chain! {\n-            if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, lit);\n+            if let Some(src) = snippet_opt(cx, span);\n+            if let Ok(lit_kind) = LitKind::from_token_lit(lit);\n+            if let Some(mut num_lit) = NumericLiteral::from_lit_kind(&src, &lit_kind);\n             then {\n-                if !Self::check_for_mistyped_suffix(cx, lit.span, &mut num_lit) {\n+                if !Self::check_for_mistyped_suffix(cx, span, &mut num_lit) {\n                     return;\n                 }\n \n@@ -293,14 +296,14 @@ impl LiteralDigitGrouping {\n                         | WarningType::InconsistentDigitGrouping\n                         | WarningType::UnusualByteGroupings\n                         | WarningType::LargeDigitGroups => {\n-                            !lit.span.from_expansion()\n+                            !span.from_expansion()\n                         }\n                         WarningType::DecimalRepresentation | WarningType::MistypedLiteralSuffix => {\n                             true\n                         }\n                     };\n                     if should_warn {\n-                        warning_type.display(num_lit.format(), cx, lit.span);\n+                        warning_type.display(num_lit.format(), cx, span);\n                     }\n                 }\n             }\n@@ -458,8 +461,8 @@ impl EarlyLintPass for DecimalLiteralRepresentation {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit);\n+        if let ExprKind::Lit(lit) = expr.kind {\n+            self.check_lit(cx, lit, expr.span);\n         }\n     }\n }\n@@ -469,19 +472,20 @@ impl DecimalLiteralRepresentation {\n     pub fn new(threshold: u64) -> Self {\n         Self { threshold }\n     }\n-    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: token::Lit, span: Span) {\n         // Lint integral literals.\n         if_chain! {\n-            if let LitKind::Int(val, _) = lit.kind;\n-            if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(num_lit) = NumericLiteral::from_lit(&src, lit);\n+            if let Ok(lit_kind) = LitKind::from_token_lit(lit);\n+            if let LitKind::Int(val, _) = lit_kind;\n+            if let Some(src) = snippet_opt(cx, span);\n+            if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit_kind);\n             if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {\n                 let hex = format!(\"{val:#X}\");\n                 let num_lit = NumericLiteral::new(&hex, num_lit.suffix, false);\n                 let _ = Self::do_lint(num_lit.integer).map_err(|warning_type| {\n-                    warning_type.display(num_lit.format(), cx, lit.span);\n+                    warning_type.display(num_lit.format(), cx, span);\n                 });\n             }\n         }"}, {"sha": "eda4376f200ee713c34fcfb93891aab4923e84eb", "filename": "src/tools/clippy/clippy_lints/src/misc_early/literal_suffix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_ast::ast::Lit;\n use rustc_errors::Applicability;\n use rustc_lint::EarlyContext;\n+use rustc_span::Span;\n \n use super::{SEPARATED_LITERAL_SUFFIX, UNSEPARATED_LITERAL_SUFFIX};\n \n-pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &str, sugg_type: &str) {\n+pub(super) fn check(cx: &EarlyContext<'_>, lit_span: Span, lit_snip: &str, suffix: &str, sugg_type: &str) {\n     let Some(maybe_last_sep_idx) = lit_snip.len().checked_sub(suffix.len() + 1) else {\n         return; // It's useless so shouldn't lint.\n     };\n@@ -15,7 +15,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &s\n             span_lint_and_sugg(\n                 cx,\n                 SEPARATED_LITERAL_SUFFIX,\n-                lit.span,\n+                lit_span,\n                 &format!(\"{sugg_type} type suffix should not be separated by an underscore\"),\n                 \"remove the underscore\",\n                 format!(\"{}{suffix}\", &lit_snip[..maybe_last_sep_idx]),\n@@ -25,7 +25,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &s\n             span_lint_and_sugg(\n                 cx,\n                 UNSEPARATED_LITERAL_SUFFIX,\n-                lit.span,\n+                lit_span,\n                 &format!(\"{sugg_type} type suffix should be separated by an underscore\"),\n                 \"add an underscore\",\n                 format!(\"{}_{suffix}\", &lit_snip[..=maybe_last_sep_idx]),"}, {"sha": "ddb8b9173a537d15e4462efdfd7d9c5d0579bbcc", "filename": "src/tools/clippy/clippy_lints/src/misc_early/mixed_case_hex_literals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast::Lit;\n use rustc_lint::EarlyContext;\n+use rustc_span::Span;\n \n use super::MIXED_CASE_HEX_LITERALS;\n \n-pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &str) {\n+pub(super) fn check(cx: &EarlyContext<'_>, lit_span: Span, suffix: &str, lit_snip: &str) {\n     let Some(maybe_last_sep_idx) = lit_snip.len().checked_sub(suffix.len() + 1) else {\n         return; // It's useless so shouldn't lint.\n     };\n@@ -23,7 +23,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &s\n             span_lint(\n                 cx,\n                 MIXED_CASE_HEX_LITERALS,\n-                lit.span,\n+                lit_span,\n                 \"inconsistent casing in hexadecimal literal\",\n             );\n             break;"}, {"sha": "78be6b9e23fa2f99c67dd0265d21f7a1fdd0741d", "filename": "src/tools/clippy/clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -9,7 +9,8 @@ mod zero_prefixed_literal;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast::{Expr, ExprKind, Generics, Lit, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n+use rustc_ast::ast::{Expr, ExprKind, Generics, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n+use rustc_ast::token;\n use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n@@ -374,42 +375,43 @@ impl EarlyLintPass for MiscEarlyLints {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.kind {\n-            MiscEarlyLints::check_lit(cx, lit);\n+        if let ExprKind::Lit(lit) = expr.kind {\n+            MiscEarlyLints::check_lit(cx, lit, expr.span);\n         }\n         double_neg::check(cx, expr);\n     }\n }\n \n impl MiscEarlyLints {\n-    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(cx: &EarlyContext<'_>, lit: token::Lit, span: Span) {\n         // We test if first character in snippet is a number, because the snippet could be an expansion\n         // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n         // Note that this check also covers special case that `line!()` is eagerly expanded by compiler.\n         // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n         // FIXME: Find a better way to detect those cases.\n-        let lit_snip = match snippet_opt(cx, lit.span) {\n+        let lit_snip = match snippet_opt(cx, span) {\n             Some(snip) if snip.chars().next().map_or(false, |c| c.is_ascii_digit()) => snip,\n             _ => return,\n         };\n \n-        if let LitKind::Int(value, lit_int_type) = lit.kind {\n+        let lit_kind = LitKind::from_token_lit(lit);\n+        if let Ok(LitKind::Int(value, lit_int_type)) = lit_kind {\n             let suffix = match lit_int_type {\n                 LitIntType::Signed(ty) => ty.name_str(),\n                 LitIntType::Unsigned(ty) => ty.name_str(),\n                 LitIntType::Unsuffixed => \"\",\n             };\n-            literal_suffix::check(cx, lit, &lit_snip, suffix, \"integer\");\n+            literal_suffix::check(cx, span, &lit_snip, suffix, \"integer\");\n             if lit_snip.starts_with(\"0x\") {\n-                mixed_case_hex_literals::check(cx, lit, suffix, &lit_snip);\n+                mixed_case_hex_literals::check(cx, span, suffix, &lit_snip);\n             } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n                 // nothing to do\n             } else if value != 0 && lit_snip.starts_with('0') {\n-                zero_prefixed_literal::check(cx, lit, &lit_snip);\n+                zero_prefixed_literal::check(cx, span, &lit_snip);\n             }\n-        } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n+        } else if let Ok(LitKind::Float(_, LitFloatType::Suffixed(float_ty))) = lit_kind {\n             let suffix = float_ty.name_str();\n-            literal_suffix::check(cx, lit, &lit_snip, suffix, \"float\");\n+            literal_suffix::check(cx, span, &lit_snip, suffix, \"float\");\n         }\n     }\n }"}, {"sha": "4f9578d1b25763f1f124a572e55be6ff733618e0", "filename": "src/tools/clippy/clippy_lints/src/misc_early/zero_prefixed_literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,28 +1,28 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use rustc_ast::ast::Lit;\n use rustc_errors::Applicability;\n use rustc_lint::EarlyContext;\n+use rustc_span::Span;\n \n use super::ZERO_PREFIXED_LITERAL;\n \n-pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str) {\n+pub(super) fn check(cx: &EarlyContext<'_>, lit_span: Span, lit_snip: &str) {\n     let trimmed_lit_snip = lit_snip.trim_start_matches(|c| c == '_' || c == '0');\n     span_lint_and_then(\n         cx,\n         ZERO_PREFIXED_LITERAL,\n-        lit.span,\n+        lit_span,\n         \"this is a decimal constant\",\n         |diag| {\n             diag.span_suggestion(\n-                lit.span,\n+                lit_span,\n                 \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n                 trimmed_lit_snip.to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n             // do not advise to use octal form if the literal cannot be expressed in base 8.\n             if !lit_snip.contains(|c| c == '8' || c == '9') {\n                 diag.span_suggestion(\n-                    lit.span,\n+                    lit_span,\n                     \"if you mean to use an octal constant, use `0o`\",\n                     format!(\"0o{trimmed_lit_snip}\"),\n                     Applicability::MaybeIncorrect,"}, {"sha": "2a7159764e4637007bd8be353ca33a7d0a2343b7", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -56,11 +56,11 @@ impl EarlyLintPass for OctalEscapes {\n             return;\n         }\n \n-        if let ExprKind::Lit(lit) = &expr.kind {\n-            if matches!(lit.token_lit.kind, LitKind::Str) {\n-                check_lit(cx, &lit.token_lit, lit.span, true);\n-            } else if matches!(lit.token_lit.kind, LitKind::ByteStr) {\n-                check_lit(cx, &lit.token_lit, lit.span, false);\n+        if let ExprKind::Lit(token_lit) = &expr.kind {\n+            if matches!(token_lit.kind, LitKind::Str) {\n+                check_lit(cx, &token_lit, expr.span, true);\n+            } else if matches!(token_lit.kind, LitKind::ByteStr) {\n+                check_lit(cx, &token_lit, expr.span, false);\n             }\n         }\n     }"}, {"sha": "bee4a33fb4a019b7dcb9d91fb48c38243431cc40", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,7 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use if_chain::if_chain;\n-use rustc_ast::ast::{BinOpKind, Expr, ExprKind, LitKind, UnOp};\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -120,7 +121,7 @@ impl EarlyLintPass for Precedence {\n             if_chain! {\n                 if !all_odd;\n                 if let ExprKind::Lit(lit) = &arg.kind;\n-                if let LitKind::Int(..) | LitKind::Float(..) = &lit.kind;\n+                if let token::LitKind::Integer | token::LitKind::Float = &lit.kind;\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n                     span_lint_and_sugg("}, {"sha": "3c1998d0237d989cf9180e4ec8a345468737a3c6", "filename": "src/tools/clippy/clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_ast::ast::{Expr, ExprKind, LitFloatType, LitKind};\n+use rustc_ast::ast::{Expr, ExprKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -33,14 +33,14 @@ fn is_useless_rounding(expr: &Expr) -> Option<(&str, String)> {\n     if let ExprKind::MethodCall(name_ident, receiver, _, _) = &expr.kind\n         && let method_name = name_ident.ident.name.as_str()\n         && (method_name == \"ceil\" || method_name == \"round\" || method_name == \"floor\")\n-        && let ExprKind::Lit(spanned) = &receiver.kind\n-        && let LitKind::Float(symbol, ty) = spanned.kind {\n-            let f = symbol.as_str().parse::<f64>().unwrap();\n-            let f_str = symbol.to_string() + if let LitFloatType::Suffixed(ty) = ty {\n-                ty.name_str()\n-            } else {\n-                \"\"\n-            };\n+        && let ExprKind::Lit(token_lit) = &receiver.kind\n+        && token_lit.is_semantic_float() {\n+            let f = token_lit.symbol.as_str().parse::<f64>().unwrap();\n+            let mut f_str = token_lit.symbol.to_string();\n+            match token_lit.suffix {\n+                Some(suffix) => f_str.push_str(suffix.as_str()),\n+                None => {}\n+            }\n             if f.fract() == 0.0 {\n                 Some((method_name, f_str))\n             } else {"}, {"sha": "73d1ba727c82108a95d7db8e375b653b774c3b17", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -152,7 +152,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         },\n         (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n-        (Lit(l), Lit(r)) => l.kind == r.kind,\n+        (Lit(l), Lit(r)) => l == r,\n         (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n         (Let(lp, le, _), Let(rp, re, _)) => eq_pat(lp, rp) && eq_expr(le, re),\n         (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),"}, {"sha": "42bdfd4827f107ef1c2bea8b229af638cfe9f0c0", "filename": "src/tools/clippy/clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast::{Lit, LitFloatType, LitIntType, LitKind};\n+use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n use std::iter;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -46,10 +46,6 @@ pub struct NumericLiteral<'a> {\n }\n \n impl<'a> NumericLiteral<'a> {\n-    pub fn from_lit(src: &'a str, lit: &Lit) -> Option<NumericLiteral<'a>> {\n-        NumericLiteral::from_lit_kind(src, &lit.kind)\n-    }\n-\n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         let unsigned_src = src.strip_prefix('-').map_or(src, |s| s);\n         if lit_kind.is_numeric()"}, {"sha": "ccc2fd0d5f5899881167285d76554aabdffb2f65", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -260,7 +260,9 @@ impl Rewrite for ast::NestedMetaItem {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n-            ast::NestedMetaItem::Literal(ref l) => rewrite_literal(context, l, shape),\n+            ast::NestedMetaItem::Literal(ref l) => {\n+                rewrite_literal(context, l.token_lit, l.span, shape)\n+            }\n         }\n     }\n }\n@@ -318,7 +320,7 @@ impl Rewrite for ast::MetaItem {\n                 // we might be better off ignoring the fact that the attribute\n                 // is longer than the max width and continue on formatting.\n                 // See #2479 for example.\n-                let value = rewrite_literal(context, literal, lit_shape)\n+                let value = rewrite_literal(context, literal.token_lit, literal.span, lit_shape)\n                     .unwrap_or_else(|| context.snippet(literal.span).to_owned());\n                 format!(\"{} = {}\", path, value)\n             }"}, {"sha": "b4f1a178dbf44d4a03d0ba82cf00007733ccad6f", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a603f110b0489d22f3929d3f232e684fd9ffb/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=358a603f110b0489d22f3929d3f232e684fd9ffb", "patch": "@@ -3,7 +3,7 @@ use std::cmp::min;\n \n use itertools::Itertools;\n use rustc_ast::token::{Delimiter, LitKind};\n-use rustc_ast::{ast, ptr};\n+use rustc_ast::{ast, ptr, token};\n use rustc_span::{BytePos, Span};\n \n use crate::chains::rewrite_chain;\n@@ -75,12 +75,12 @@ pub(crate) fn format_expr(\n             choose_separator_tactic(context, expr.span),\n             None,\n         ),\n-        ast::ExprKind::Lit(ref l) => {\n-            if let Some(expr_rw) = rewrite_literal(context, l, shape) {\n+        ast::ExprKind::Lit(token_lit) => {\n+            if let Some(expr_rw) = rewrite_literal(context, token_lit, expr.span, shape) {\n                 Some(expr_rw)\n             } else {\n-                if let LitKind::StrRaw(_) = l.token_lit.kind {\n-                    Some(context.snippet(l.span).trim().into())\n+                if let LitKind::StrRaw(_) = token_lit.kind {\n+                    Some(context.snippet(expr.span).trim().into())\n                 } else {\n                     None\n                 }\n@@ -274,9 +274,9 @@ pub(crate) fn format_expr(\n \n             fn needs_space_before_range(context: &RewriteContext<'_>, lhs: &ast::Expr) -> bool {\n                 match lhs.kind {\n-                    ast::ExprKind::Lit(ref lit) => match lit.kind {\n-                        ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n-                            context.snippet(lit.span).ends_with('.')\n+                    ast::ExprKind::Lit(token_lit) => match token_lit.kind {\n+                        token::LitKind::Float if token_lit.suffix.is_none() => {\n+                            context.snippet(lhs.span).ends_with('.')\n                         }\n                         _ => false,\n                     },\n@@ -1185,14 +1185,15 @@ pub(crate) fn is_unsafe_block(block: &ast::Block) -> bool {\n \n pub(crate) fn rewrite_literal(\n     context: &RewriteContext<'_>,\n-    l: &ast::Lit,\n+    token_lit: token::Lit,\n+    span: Span,\n     shape: Shape,\n ) -> Option<String> {\n-    match l.kind {\n-        ast::LitKind::Str(_, ast::StrStyle::Cooked) => rewrite_string_lit(context, l.span, shape),\n-        ast::LitKind::Int(..) => rewrite_int_lit(context, l, shape),\n+    match token_lit.kind {\n+        token::LitKind::Str => rewrite_string_lit(context, span, shape),\n+        token::LitKind::Integer => rewrite_int_lit(context, token_lit, span, shape),\n         _ => wrap_str(\n-            context.snippet(l.span).to_owned(),\n+            context.snippet(span).to_owned(),\n             context.config.max_width(),\n             shape,\n         ),\n@@ -1225,9 +1226,13 @@ fn rewrite_string_lit(context: &RewriteContext<'_>, span: Span, shape: Shape) ->\n     )\n }\n \n-fn rewrite_int_lit(context: &RewriteContext<'_>, lit: &ast::Lit, shape: Shape) -> Option<String> {\n-    let span = lit.span;\n-    let symbol = lit.token_lit.symbol.as_str();\n+fn rewrite_int_lit(\n+    context: &RewriteContext<'_>,\n+    token_lit: token::Lit,\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n+    let symbol = token_lit.symbol.as_str();\n \n     if let Some(symbol_stripped) = symbol.strip_prefix(\"0x\") {\n         let hex_lit = match context.config.hex_literal_case() {\n@@ -1240,9 +1245,7 @@ fn rewrite_int_lit(context: &RewriteContext<'_>, lit: &ast::Lit, shape: Shape) -\n                 format!(\n                     \"0x{}{}\",\n                     hex_lit,\n-                    lit.token_lit\n-                        .suffix\n-                        .map_or(String::new(), |s| s.to_string())\n+                    token_lit.suffix.map_or(String::new(), |s| s.to_string())\n                 ),\n                 context.config.max_width(),\n                 shape,"}]}