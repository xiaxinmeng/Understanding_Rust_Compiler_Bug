{"sha": "f2c7917402ebd858f5b517a3406bec8ef187bfb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYzc5MTc0MDJlYmQ4NThmNWI1MTdhMzQwNmJlYzhlZjE4N2JmYjE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-13T23:08:21Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:08Z"}, "message": "translate drop glue using MIR\n\nDrop of arrays is now translated in trans::block in an ugly way that I\nshould clean up in a later PR, and does not handle panics in the middle\nof an array drop, but this commit & PR are growing too big.", "tree": {"sha": "a6b24f0954ea0ba84082ddf605f1268173efaa53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6b24f0954ea0ba84082ddf605f1268173efaa53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2c7917402ebd858f5b517a3406bec8ef187bfb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c7917402ebd858f5b517a3406bec8ef187bfb1", "html_url": "https://github.com/rust-lang/rust/commit/f2c7917402ebd858f5b517a3406bec8ef187bfb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2c7917402ebd858f5b517a3406bec8ef187bfb1/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26df816f520d00fe5ddf332a0a08ad6e26a5698d", "url": "https://api.github.com/repos/rust-lang/rust/commits/26df816f520d00fe5ddf332a0a08ad6e26a5698d", "html_url": "https://github.com/rust-lang/rust/commit/26df816f520d00fe5ddf332a0a08ad6e26a5698d"}], "stats": {"total": 1862, "additions": 721, "deletions": 1141}, "files": [{"sha": "e74e13d1a6b055d460bef6341d96a9897d077cb1", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -46,8 +46,13 @@\n             issue = \"0\")]\n #![allow(missing_docs)]\n \n-extern \"rust-intrinsic\" {\n+#[cfg(not(stage0))]\n+#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n+#[rustc_deprecated(reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n+                   since = \"1.18.0\")]\n+pub use ptr::drop_in_place;\n \n+extern \"rust-intrinsic\" {\n     // NB: These intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n@@ -622,6 +627,7 @@ extern \"rust-intrinsic\" {\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n \n+    #[cfg(stage0)]\n     /// Executes the destructor (if any) of the pointed-to value.\n     ///\n     /// This has two use cases:"}, {"sha": "c4409d3cb559039930b6db9701ce5e9e516eeef0", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -37,9 +37,38 @@ pub use intrinsics::copy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::write_bytes;\n \n+#[cfg(stage0)]\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n pub use intrinsics::drop_in_place;\n \n+#[cfg(not(stage0))]\n+/// Executes the destructor (if any) of the pointed-to value.\n+///\n+/// This has two use cases:\n+///\n+/// * It is *required* to use `drop_in_place` to drop unsized types like\n+///   trait objects, because they can't be read out onto the stack and\n+///   dropped normally.\n+///\n+/// * It is friendlier to the optimizer to do this over `ptr::read` when\n+///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n+///   as the compiler doesn't need to prove that it's sound to elide the\n+///   copy.\n+///\n+/// # Undefined Behavior\n+///\n+/// This has all the same safety problems as `ptr::read` with respect to\n+/// invalid pointers, types, and double drops.\n+#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n+#[lang=\"drop_in_place\"]\n+#[inline]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n /// Creates a null raw pointer.\n ///\n /// # Examples"}, {"sha": "81a415a2f530964427287920165122471f528701", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -335,7 +335,7 @@ language_item_table! {\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n     BoxFreeFnLangItem,               \"box_free\",                box_free_fn;\n-    StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n+    DropInPlaceFnLangItem,             \"drop_in_place\",           drop_in_place_fn;\n \n     StartFnLangItem,                 \"start\",                   start_fn;\n \n@@ -355,8 +355,6 @@ language_item_table! {\n     ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n \n-    NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n-\n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;"}, {"sha": "33df648f172d625c248406fed56c259461af1171", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccesso\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n-use ty::subst::Substs;\n+use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n@@ -982,6 +982,22 @@ impl<'tcx> Debug for Operand<'tcx> {\n     }\n }\n \n+impl<'tcx> Operand<'tcx> {\n+    pub fn item<'a>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                    def_id: DefId,\n+                    substs: &'tcx Substs<'tcx>,\n+                    span: Span)\n+                    -> Self\n+    {\n+        Operand::Constant(Constant {\n+            span: span,\n+            ty: tcx.item_type(def_id).subst(tcx, substs),\n+            literal: Literal::Item { def_id, substs }\n+        })\n+    }\n+\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n "}, {"sha": "67287f1b4ff72bf0ae9618f4c0deb014e1a26b05", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -35,6 +35,8 @@ pub enum InstanceDef<'tcx> {\n     Virtual(DefId, usize),\n     // <[mut closure] as FnOnce>::call_once\n     ClosureOnceShim { call_once: DefId },\n+    // drop_in_place::<T>; None for empty drop glue.\n+    DropGlue(DefId, Option<Ty<'tcx>>),\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -46,7 +48,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             InstanceDef::Virtual(def_id, _) |\n             InstanceDef::Intrinsic(def_id, ) |\n             InstanceDef::ClosureOnceShim { call_once: def_id }\n-                => def_id\n+                => def_id,\n+            InstanceDef::DropGlue(def_id, _) => def_id\n         }\n     }\n \n@@ -65,6 +68,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         // real on-demand.\n         let ty = match self {\n             &InstanceDef::FnPtrShim(_, ty) => Some(ty),\n+            &InstanceDef::DropGlue(_, ty) => ty,\n             _ => None\n         }.into_iter();\n \n@@ -97,6 +101,9 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::ClosureOnceShim { .. } => {\n                 write!(f, \" - shim\")\n             }\n+            InstanceDef::DropGlue(_, ty) => {\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n         }\n     }\n }"}, {"sha": "81037fe40d9dab07ecdfd904a5a492c5a72b15a1", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -437,7 +437,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             Rvalue::Ref(..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Len(..) => {}\n+            Rvalue::Len(..) |\n             Rvalue::Box(..) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always"}, {"sha": "26d5b7fd38ab080b09552e520bb5764ea154d7f1", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 130, "deletions": 2, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::region::ROOT_CODE_EXTENT;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{Kind, Subst};\n use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -25,10 +25,13 @@ use syntax::ast;\n use syntax_pos::Span;\n \n use std::cell::RefCell;\n+use std::fmt;\n use std::iter;\n use std::mem;\n \n use transform::{add_call_guards, no_landing_pads, simplify};\n+use util::elaborate_drops::{self, DropElaborator, DropStyle, DropFlagMode};\n+use util::patch::MirPatch;\n \n pub fn provide(providers: &mut Providers) {\n     providers.mir_shims = make_shim;\n@@ -101,6 +104,9 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 None\n             )\n         }\n+        ty::InstanceDef::DropGlue(def_id, ty) => {\n+            build_drop_shim(tcx, &param_env, def_id, ty)\n+        }\n         ty::InstanceDef::Intrinsic(_) => {\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n         }\n@@ -143,6 +149,129 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n         .collect()\n }\n \n+fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             def_id: DefId,\n+                             ty: Option<Ty<'tcx>>)\n+                             -> Mir<'tcx>\n+{\n+    debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n+\n+    let substs = if let Some(ty) = ty {\n+        tcx.mk_substs(iter::once(Kind::from(ty)))\n+    } else {\n+        param_env.free_substs\n+    };\n+    let fn_ty = tcx.item_type(def_id).subst(tcx, substs);\n+    let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n+    let span = tcx.def_span(def_id);\n+\n+    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+\n+    let return_block = BasicBlock::new(1);\n+    let mut blocks = IndexVec::new();\n+    let block = |blocks: &mut IndexVec<_, _>, kind| {\n+        blocks.push(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator { source_info, kind }),\n+            is_cleanup: false\n+        })\n+    };\n+    block(&mut blocks, TerminatorKind::Goto { target: return_block });\n+    block(&mut blocks, TerminatorKind::Return);\n+\n+    let mut mir = Mir::new(\n+        blocks,\n+        IndexVec::from_elem_n(\n+            VisibilityScopeData { span: span, parent_scope: None }, 1\n+        ),\n+        IndexVec::new(),\n+        sig.output(),\n+        local_decls_for_sig(&sig),\n+        sig.inputs().len(),\n+        vec![],\n+        span\n+    );\n+\n+    if let Some(..) = ty {\n+        let patch = {\n+            let mut elaborator = DropShimElaborator {\n+                mir: &mir,\n+                patch: MirPatch::new(&mir),\n+                tcx, param_env\n+            };\n+            let dropee = Lvalue::Projection(\n+                box Projection {\n+                    base: Lvalue::Local(Local::new(1+0)),\n+                    elem: ProjectionElem::Deref\n+                }\n+                );\n+            let resume_block = elaborator.patch.resume_block();\n+            elaborate_drops::elaborate_drop(\n+                &mut elaborator,\n+                source_info,\n+                false,\n+                &dropee,\n+                (),\n+                return_block,\n+                Some(resume_block),\n+                START_BLOCK\n+            );\n+            elaborator.patch\n+        };\n+        patch.apply(&mut mir);\n+    }\n+\n+    mir\n+}\n+\n+pub struct DropShimElaborator<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    patch: MirPatch<'tcx>,\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+}\n+\n+impl<'a, 'tcx> fmt::Debug for DropShimElaborator<'a, 'tcx> {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n+    type Path = ();\n+\n+    fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n+    fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n+    fn tcx(&self) -> ty::TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn param_env(&self) -> &'a ty::ParameterEnvironment<'tcx> { self.param_env }\n+\n+    fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n+        if let DropFlagMode::Shallow = mode {\n+            DropStyle::Static\n+        } else {\n+            DropStyle::Open\n+        }\n+    }\n+\n+    fn get_drop_flag(&mut self, _path: Self::Path) -> Option<Operand<'tcx>> {\n+        None\n+    }\n+\n+    fn clear_drop_flag(&mut self, _location: Location, _path: Self::Path, _mode: DropFlagMode) {\n+    }\n+\n+    fn field_subpath(&self, _path: Self::Path, _field: Field) -> Option<Self::Path> {\n+        None\n+    }\n+    fn deref_subpath(&self, _path: Self::Path) -> Option<Self::Path> {\n+        None\n+    }\n+    fn downcast_subpath(&self, _path: Self::Path, _variant: usize) -> Option<Self::Path> {\n+        Some(())\n+    }\n+}\n+\n /// Build a \"call\" shim for `def_id`. The shim calls the\n /// function specified by `call_kind`, first adjusting its first\n /// argument according to `rcvr_adjustment`.\n@@ -162,7 +291,6 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n     let fn_ty = tcx.item_type(def_id).subst(tcx, param_env.free_substs);\n-    // Not normalizing here without a param env.\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n     let span = tcx.def_span(def_id);\n "}, {"sha": "d0f142ad7d7a87b7a81fb7fc905cc957426bee77", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 218, "deletions": 83, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n use std::fmt;\n+use rustc::hir;\n use rustc::mir::*;\n+use rustc::middle::const_val::ConstInt;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n use util::patch::MirPatch;\n@@ -92,6 +94,7 @@ pub fn elaborate_drop<'b, 'tcx, D>(\n     bb: BasicBlock)\n     where D: DropElaborator<'b, 'tcx>\n {\n+    assert_eq!(unwind.is_none(), is_cleanup);\n     DropCtxt {\n         elaborator, source_info, is_cleanup, lvalue, path, succ, unwind\n     }.elaborate_drop(bb)\n@@ -146,7 +149,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 });\n             }\n             DropStyle::Conditional => {\n-                let drop_bb = self.complete_drop(Some(DropFlagMode::Deep));\n+                let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+                let succ = self.succ;\n+                let drop_bb = self.complete_drop(\n+                    is_cleanup, Some(DropFlagMode::Deep), succ);\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n                     target: drop_bb\n                 });\n@@ -208,7 +214,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 // Using `self.path` here to condition the drop on\n                 // our own drop flag.\n                 path: self.path\n-            }.complete_drop(None)\n+            }.complete_drop(is_cleanup, None, succ)\n         }\n     }\n \n@@ -220,7 +226,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// (the first field is never reached). If it is `None`, all\n     /// unwind targets are left blank.\n     fn drop_halfladder<'a>(&mut self,\n-                           unwind_ladder: Option<Vec<BasicBlock>>,\n+                           unwind_ladder: Option<&[BasicBlock]>,\n                            succ: BasicBlock,\n                            fields: &[(Lvalue<'tcx>, Option<D::Path>)],\n                            is_cleanup: bool)\n@@ -262,10 +268,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// .c1:\n     ///     ELAB(drop location.1 [target=.c2])\n     /// .c2:\n-    ///     ELAB(drop location.2 [target=`self.unwind])\n+    ///     ELAB(drop location.2 [target=`self.unwind`])\n     fn drop_ladder<'a>(&mut self,\n                        fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>)\n-                       -> BasicBlock\n+                       -> (BasicBlock, Option<BasicBlock>)\n     {\n         debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n \n@@ -286,8 +292,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let succ = self.succ; // FIXME(#6393)\n         let is_cleanup = self.is_cleanup;\n-        self.drop_halfladder(unwind_ladder, succ, &fields, is_cleanup)\n-            .last().cloned().unwrap_or(succ)\n+        let normal_ladder =\n+            self.drop_halfladder(unwind_ladder.as_ref().map(|x| &**x),\n+                                 succ, &fields, is_cleanup);\n+\n+        (normal_ladder.last().cloned().unwrap_or(succ),\n+         unwind_ladder.and_then(|l| l.last().cloned()).or(self.unwind))\n     }\n \n     fn open_drop_for_tuple<'a>(&mut self, tys: &[Ty<'tcx>])\n@@ -300,7 +310,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n-        self.drop_ladder(fields)\n+        self.drop_ladder(fields).0\n     }\n \n     fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n@@ -323,7 +333,33 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn open_drop_for_adt<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n                              -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", self, adt, substs);\n+        if adt.variants.len() == 0 {\n+            return self.elaborator.patch().new_block(BasicBlockData {\n+                statements: vec![],\n+                terminator: Some(Terminator {\n+                    source_info: self.source_info,\n+                    kind: TerminatorKind::Unreachable\n+                }),\n+                is_cleanup: self.is_cleanup\n+            });\n+        }\n+\n+        let contents_drop = if adt.is_union() {\n+            (self.succ, self.unwind)\n+        } else {\n+            self.open_drop_for_adt_contents(adt, substs)\n+        };\n \n+        if adt.has_dtor(self.tcx()) {\n+            self.destructor_call_block(contents_drop)\n+        } else {\n+            contents_drop.0\n+        }\n+    }\n+\n+    fn open_drop_for_adt_contents<'a>(&mut self, adt: &'tcx ty::AdtDef,\n+                                      substs: &'tcx Substs<'tcx>)\n+                                      -> (BasicBlock, Option<BasicBlock>) {\n         match adt.variants.len() {\n             1 => {\n                 let fields = self.move_paths_for_fields(\n@@ -335,9 +371,19 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.drop_ladder(fields)\n             }\n             _ => {\n+                let is_cleanup = self.is_cleanup;\n+                let succ = self.succ;\n+                let unwind = self.unwind; // FIXME(#6393)\n+\n                 let mut values = Vec::with_capacity(adt.variants.len());\n-                let mut blocks = Vec::with_capacity(adt.variants.len());\n+                let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n+                let mut unwind_blocks = if is_cleanup {\n+                    None\n+                } else {\n+                    Some(Vec::with_capacity(adt.variants.len()))\n+                };\n                 let mut otherwise = None;\n+                let mut unwind_otherwise = None;\n                 for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n                     let subpath = self.elaborator.downcast_subpath(\n                         self.path, variant_index);\n@@ -351,53 +397,146 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                             &adt.variants[variant_index],\n                             substs);\n                         values.push(discr);\n-                        blocks.push(self.drop_ladder(fields));\n+                        if let Some(ref mut unwind_blocks) = unwind_blocks {\n+                            // We can't use the half-ladder from the original\n+                            // drop ladder, because this breaks the\n+                            // \"funclet can't have 2 successor funclets\"\n+                            // requirement from MSVC:\n+                            //\n+                            //           switch       unwind-switch\n+                            //          /      \\         /        \\\n+                            //         v1.0    v2.0  v2.0-unwind  v1.0-unwind\n+                            //         |        |      /             |\n+                            //    v1.1-unwind  v2.1-unwind           |\n+                            //      ^                                |\n+                            //       \\-------------------------------/\n+                            //\n+                            // Create a duplicate half-ladder to avoid that. We\n+                            // could technically only do this on MSVC, but I\n+                            // I want to minimize the divergence between MSVC\n+                            // and non-MSVC.\n+\n+                            let unwind = unwind.unwrap();\n+                            let halfladder = self.drop_halfladder(\n+                                None, unwind, &fields, true);\n+                            unwind_blocks.push(\n+                                halfladder.last().cloned().unwrap_or(unwind)\n+                            );\n+                        }\n+                        let (normal, _) = self.drop_ladder(fields);\n+                        normal_blocks.push(normal);\n                     } else {\n                         // variant not found - drop the entire enum\n                         if let None = otherwise {\n-                            otherwise =\n-                                Some(self.complete_drop(Some(DropFlagMode::Shallow)));\n+                            otherwise = Some(self.complete_drop(\n+                                is_cleanup,\n+                                Some(DropFlagMode::Shallow),\n+                                succ));\n+                            unwind_otherwise = unwind.map(|unwind| self.complete_drop(\n+                                true,\n+                                Some(DropFlagMode::Shallow),\n+                                unwind\n+                            ));\n                         }\n                     }\n                 }\n                 if let Some(block) = otherwise {\n-                    blocks.push(block);\n+                    normal_blocks.push(block);\n+                    if let Some(ref mut unwind_blocks) = unwind_blocks {\n+                        unwind_blocks.push(unwind_otherwise.unwrap());\n+                    }\n                 } else {\n                     values.pop();\n                 }\n-                // If there are multiple variants, then if something\n-                // is present within the enum the discriminant, tracked\n-                // by the rest path, must be initialized.\n-                //\n-                // Additionally, we do not want to switch on the\n-                // discriminant after it is free-ed, because that\n-                // way lies only trouble.\n-                let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n-                let discr = Lvalue::Local(self.new_temp(discr_ty));\n-                let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n-                let switch_block = self.elaborator.patch().new_block(BasicBlockData {\n-                    statements: vec![\n-                        Statement {\n-                            source_info: self.source_info,\n-                            kind: StatementKind::Assign(discr.clone(), discr_rv),\n-                        }\n-                    ],\n-                    terminator: Some(Terminator {\n-                        source_info: self.source_info,\n-                        kind: TerminatorKind::SwitchInt {\n-                            discr: Operand::Consume(discr),\n-                            switch_ty: discr_ty,\n-                            values: From::from(values),\n-                            targets: blocks,\n-                        }\n-                    }),\n-                    is_cleanup: self.is_cleanup,\n-                });\n-                self.drop_flag_test_block(switch_block)\n+\n+                (self.adt_switch_block(is_cleanup, adt, normal_blocks, &values, succ),\n+                 unwind_blocks.map(|unwind_blocks| {\n+                     self.adt_switch_block(\n+                         is_cleanup, adt, unwind_blocks, &values, unwind.unwrap()\n+                     )\n+                 }))\n             }\n         }\n     }\n \n+    fn adt_switch_block(&mut self,\n+                        is_cleanup: bool,\n+                        adt: &'tcx ty::AdtDef,\n+                        blocks: Vec<BasicBlock>,\n+                        values: &[ConstInt],\n+                        succ: BasicBlock)\n+                        -> BasicBlock {\n+        // If there are multiple variants, then if something\n+        // is present within the enum the discriminant, tracked\n+        // by the rest path, must be initialized.\n+        //\n+        // Additionally, we do not want to switch on the\n+        // discriminant after it is free-ed, because that\n+        // way lies only trouble.\n+        let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n+        let discr = Lvalue::Local(self.new_temp(discr_ty));\n+        let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n+        let switch_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![\n+                Statement {\n+                    source_info: self.source_info,\n+                    kind: StatementKind::Assign(discr.clone(), discr_rv),\n+                }\n+                ],\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::SwitchInt {\n+                    discr: Operand::Consume(discr),\n+                    switch_ty: discr_ty,\n+                    values: From::from(values.to_owned()),\n+                    targets: blocks,\n+                }\n+            }),\n+            is_cleanup: is_cleanup,\n+        });\n+        self.drop_flag_test_block(is_cleanup, switch_block, succ)\n+    }\n+\n+    fn destructor_call_block<'a>(&mut self, (succ, unwind): (BasicBlock, Option<BasicBlock>))\n+                                 -> BasicBlock\n+    {\n+        debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n+        let tcx = self.tcx();\n+        let drop_trait = tcx.lang_items.drop_trait().unwrap();\n+        let drop_fn = tcx.associated_items(drop_trait).next().unwrap();\n+        let ty = self.lvalue_ty(self.lvalue);\n+        let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n+\n+        let re_erased = tcx.mk_region(ty::ReErased);\n+        let ref_ty = tcx.mk_ref(re_erased, ty::TypeAndMut {\n+            ty: ty,\n+            mutbl: hir::Mutability::MutMutable\n+        });\n+        let ref_lvalue = self.new_temp(ref_ty);\n+        let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n+\n+        self.elaborator.patch().new_block(BasicBlockData {\n+            statements: vec![Statement {\n+                source_info: self.source_info,\n+                kind: StatementKind::Assign(\n+                    Lvalue::Local(ref_lvalue),\n+                    Rvalue::Ref(re_erased, BorrowKind::Mut, self.lvalue.clone())\n+                )\n+            }],\n+            terminator: Some(Terminator {\n+                kind: TerminatorKind::Call {\n+                    func: Operand::item(tcx, drop_fn.def_id, substs,\n+                                        self.source_info.span),\n+                    args: vec![Operand::Consume(Lvalue::Local(ref_lvalue))],\n+                    destination: Some((unit_temp, succ)),\n+                    cleanup: unwind,\n+                },\n+                source_info: self.source_info\n+            }),\n+            is_cleanup: self.is_cleanup,\n+        })\n+    }\n+\n     /// The slow-path - create an \"open\", elaborated drop for a type\n     /// which is moved-out-of only partially, and patch `bb` to a jump\n     /// to it. This must not be called on ADTs with a destructor,\n@@ -408,6 +547,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.lvalue_ty(self.lvalue);\n+        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        let succ = self.succ;\n         match ty.sty {\n             ty::TyClosure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n@@ -422,6 +563,14 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty::TyAdt(def, substs) => {\n                 self.open_drop_for_adt(def, substs)\n             }\n+            ty::TyDynamic(..) => {\n+                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+            }\n+            ty::TyArray(..) | ty::TySlice(..) => {\n+                // FIXME(#34708): handle partially-dropped\n+                // array/slice elements.\n+                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+            }\n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n         }\n     }\n@@ -433,22 +582,27 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// if FLAG(self.path)\n     ///     if let Some(mode) = mode: FLAG(self.path)[mode] = false\n     ///     drop(self.lv)\n-    fn complete_drop<'a>(&mut self, drop_mode: Option<DropFlagMode>) -> BasicBlock\n+    fn complete_drop<'a>(&mut self,\n+                         is_cleanup: bool,\n+                         drop_mode: Option<DropFlagMode>,\n+                         succ: BasicBlock) -> BasicBlock\n     {\n         debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n \n-        let drop_block = self.drop_block();\n+        let drop_block = self.drop_block(is_cleanup, succ);\n         if let Some(mode) = drop_mode {\n             let block_start = Location { block: drop_block, statement_index: 0 };\n             self.elaborator.clear_drop_flag(block_start, self.path, mode);\n         }\n \n-        self.drop_flag_test_block(drop_block)\n+        self.drop_flag_test_block(is_cleanup, drop_block, succ)\n     }\n \n     fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {\n         debug!(\"elaborated_drop_block({:?})\", self);\n-        let blk = self.drop_block();\n+        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        let succ = self.succ;\n+        let blk = self.drop_block(is_cleanup, succ);\n         self.elaborate_drop(blk);\n         blk\n     }\n@@ -460,7 +614,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         is_cleanup: bool\n     ) -> BasicBlock {\n         let block = self.unelaborated_free_block(ty, target, is_cleanup);\n-        self.drop_flag_test_block_with_succ(is_cleanup, block, target)\n+        self.drop_flag_test_block(is_cleanup, block, target)\n     }\n \n     fn unelaborated_free_block<'a>(\n@@ -473,53 +627,34 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n-        let fty = tcx.item_type(free_func).subst(tcx, substs);\n \n-        let free_block = self.elaborator.patch().new_block(BasicBlockData {\n-            statements: vec![],\n-            terminator: Some(Terminator {\n-                source_info: self.source_info, kind: TerminatorKind::Call {\n-                    func: Operand::Constant(Constant {\n-                        span: self.source_info.span,\n-                        ty: fty,\n-                        literal: Literal::Item {\n-                            def_id: free_func,\n-                            substs: substs\n-                        }\n-                    }),\n-                    args: vec![Operand::Consume(self.lvalue.clone())],\n-                    destination: Some((unit_temp, target)),\n-                    cleanup: None\n-                }\n-            }),\n-            is_cleanup: is_cleanup\n-        });\n+        let call = TerminatorKind::Call {\n+            func: Operand::item(tcx, free_func, substs, self.source_info.span),\n+            args: vec![Operand::Consume(self.lvalue.clone())],\n+            destination: Some((unit_temp, target)),\n+            cleanup: None\n+        }; // FIXME(#6393)\n+        let free_block = self.new_block(is_cleanup, call);\n+\n         let block_start = Location { block: free_block, statement_index: 0 };\n         self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n         free_block\n     }\n \n-    fn drop_block<'a>(&mut self) -> BasicBlock {\n+    fn drop_block<'a>(&mut self, is_cleanup: bool, succ: BasicBlock) -> BasicBlock {\n         let block = TerminatorKind::Drop {\n             location: self.lvalue.clone(),\n-            target: self.succ,\n-            unwind: self.unwind\n+            target: succ,\n+            unwind: if is_cleanup { None } else { self.unwind }\n         };\n-        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n         self.new_block(is_cleanup, block)\n     }\n \n-    fn drop_flag_test_block<'a>(&mut self, on_set: BasicBlock) -> BasicBlock {\n-        let is_cleanup = self.is_cleanup;\n-        let succ = self.succ; // FIXME(#6393)\n-        self.drop_flag_test_block_with_succ(is_cleanup, on_set, succ)\n-    }\n-\n-    fn drop_flag_test_block_with_succ<'a>(&mut self,\n-                                          is_cleanup: bool,\n-                                          on_set: BasicBlock,\n-                                          on_unset: BasicBlock)\n-                                          -> BasicBlock\n+    fn drop_flag_test_block(&mut self,\n+                            is_cleanup: bool,\n+                            on_set: BasicBlock,\n+                            on_unset: BasicBlock)\n+                            -> BasicBlock\n     {\n         let style = self.elaborator.drop_style(self.path, DropFlagMode::Shallow);\n         debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\","}, {"sha": "27a19d211c2908ef4f5910aa1f4915859d28cede", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{self, type_is_fat_ptr, C_uint};\n+use common::{type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -59,6 +59,7 @@ enum ArgKind {\n pub use self::attr_impl::ArgAttribute;\n \n #[allow(non_upper_case_globals)]\n+#[allow(unused)]\n mod attr_impl {\n     // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n     bitflags! {\n@@ -223,16 +224,6 @@ impl ArgType {\n         self.kind == ArgKind::Ignore\n     }\n \n-    /// Get the LLVM type for an lvalue of the original Rust type of\n-    /// this argument/return, i.e. the result of `type_of::type_of`.\n-    pub fn memory_ty(&self, ccx: &CrateContext) -> Type {\n-        if self.original_ty == Type::i1(ccx) {\n-            Type::i8(ccx)\n-        } else {\n-            self.original_ty\n-        }\n-    }\n-\n     /// Store a direct/indirect value described by this ArgType into a\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n@@ -344,17 +335,6 @@ impl FnType {\n         fn_ty\n     }\n \n-    pub fn from_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                   instance: &ty::Instance<'tcx>,\n-                                   extra_args: &[Ty<'tcx>]) -> FnType\n-    {\n-        let ity = common::instance_ty(ccx.shared(), instance);\n-        let sig = common::ty_fn_sig(ccx, ity);\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-\n-        Self::new(ccx, sig, extra_args)\n-    }\n-\n     fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             sig: ty::FnSig<'tcx>,\n                             extra_args: &[Ty<'tcx>]) -> FnType {"}, {"sha": "058f37f62dd82b70f87814f6ce567b2236d05c99", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -363,28 +363,6 @@ fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n     }\n }\n \n-/// Yield information about how to dispatch a case of the\n-/// discriminant-like value returned by `trans_switch`.\n-///\n-/// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n-    let l = bcx.ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum { discr, .. }\n-        | layout::General { discr, .. }=> {\n-            C_integral(Type::from_integer(bcx.ccx, discr), value.0, true)\n-        }\n-        layout::RawNullablePointer { .. } |\n-        layout::StructWrappedNullablePointer { .. } => {\n-            assert!(value == Disr(0) || value == Disr(1));\n-            C_bool(bcx.ccx, value != Disr(0))\n-        }\n-        _ => {\n-            bug!(\"{} does not have a discriminant. Represented as {:#?}\", t, l);\n-        }\n-    }\n-}\n-\n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {"}, {"sha": "6bef31ccf64a423999d4f9bf664837eca1670da6", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -17,6 +17,7 @@ pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use context::CrateContext;\n \n+\n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n pub fn inline(val: ValueRef, inline: InlineAttr) {"}, {"sha": "6593b8e68d425fbd21a818bd87cb58b5c0348ce8", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -403,7 +403,9 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef,\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False, alignment.to_align())\n-    } else if (t.is_region_ptr() || t.is_box()) && !common::type_is_fat_ptr(ccx, t) {\n+    } else if (t.is_region_ptr() || t.is_box() || t.is_fn())\n+        && !common::type_is_fat_ptr(ccx, t)\n+    {\n         b.load_nonnull(ptr, alignment.to_align())\n     } else {\n         b.load(ptr, alignment.to_align())"}, {"sha": "aefee51191ac4e3804efe66880ab7d32ee1ce5ac", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -96,6 +96,9 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n+        if common::is_inline_instance(tcx, &instance) {\n+            attributes::inline(llfn, attributes::InlineAttr::Hint);\n+        }\n         let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n "}, {"sha": "2b2e5e85ea50d3d604ba05512cbc5ad5b2d46a7f", "filename": "src/librustc_trans/cleanup.rs", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/26df816f520d00fe5ddf332a0a08ad6e26a5698d/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26df816f520d00fe5ddf332a0a08ad6e26a5698d/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=26df816f520d00fe5ddf332a0a08ad6e26a5698d", "patch": "@@ -1,144 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! ## The Cleanup module\n-//!\n-//! The cleanup module tracks what values need to be cleaned up as scopes\n-//! are exited, either via panic or just normal control flow.\n-//!\n-//! Cleanup items can be scheduled into any of the scopes on the stack.\n-//! Typically, when a scope is finished, we generate the cleanup code. This\n-//! corresponds to a normal exit from a block (for example, an expression\n-//! completing evaluation successfully without panic).\n-\n-use llvm::BasicBlockRef;\n-use base;\n-use mir::lvalue::LvalueRef;\n-use rustc::mir::tcx::LvalueTy;\n-use builder::Builder;\n-use common::Funclet;\n-use glue;\n-use type_::Type;\n-\n-pub struct CleanupScope<'tcx> {\n-    // Cleanup to run upon scope exit.\n-    cleanup: Option<DropValue<'tcx>>,\n-\n-    // Computed on creation if compiling with landing pads (!sess.no_landing_pads)\n-    pub landing_pad: Option<BasicBlockRef>,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct DropValue<'tcx> {\n-    val: LvalueRef<'tcx>,\n-    skip_dtor: bool,\n-}\n-\n-impl<'tcx> DropValue<'tcx> {\n-    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &Builder<'a, 'tcx>) {\n-        glue::call_drop_glue(bcx, self.val, self.skip_dtor, funclet)\n-    }\n-\n-    /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n-    /// for an unwind and then `resume` to continue error propagation:\n-    ///\n-    ///     landing_pad -> ... cleanups ... -> [resume]\n-    ///\n-    /// This should only be called once per function, as it creates an alloca for the landingpad.\n-    fn get_landing_pad<'a>(&self, bcx: &Builder<'a, 'tcx>) -> BasicBlockRef {\n-        debug!(\"get_landing_pad\");\n-        let bcx = bcx.build_sibling_block(\"cleanup_unwind\");\n-        let llpersonality = bcx.ccx.eh_personality();\n-        bcx.set_personality_fn(llpersonality);\n-\n-        if base::wants_msvc_seh(bcx.sess()) {\n-            let pad = bcx.cleanup_pad(None, &[]);\n-            let funclet = Some(Funclet::new(pad));\n-            self.trans(funclet.as_ref(), &bcx);\n-\n-            bcx.cleanup_ret(pad, None);\n-        } else {\n-            // The landing pad return type (the type being propagated). Not sure\n-            // what this represents but it's determined by the personality\n-            // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(bcx.ccx, &[Type::i8p(bcx.ccx), Type::i32(bcx.ccx)], false);\n-\n-            // The only landing pad clause will be 'cleanup'\n-            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.llfn());\n-\n-            // The landing pad block is a cleanup\n-            bcx.set_cleanup(llretval);\n-\n-            // Insert cleanup instructions into the cleanup block\n-            self.trans(None, &bcx);\n-\n-            if !bcx.sess().target.target.options.custom_unwind_resume {\n-                bcx.resume(llretval);\n-            } else {\n-                let exc_ptr = bcx.extract_value(llretval, 0);\n-                bcx.call(bcx.ccx.eh_unwind_resume(), &[exc_ptr], None);\n-                bcx.unreachable();\n-            }\n-        }\n-\n-        bcx.llbb()\n-    }\n-}\n-\n-impl<'a, 'tcx> CleanupScope<'tcx> {\n-    /// Issue #23611: Schedules a (deep) drop of the contents of\n-    /// `val`, which is a pointer to an instance of struct/enum type\n-    /// `ty`. The scheduled code handles extracting the discriminant\n-    /// and dropping the contents associated with that variant\n-    /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(\n-        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n-    ) -> CleanupScope<'tcx> {\n-        if let LvalueTy::Downcast { .. } = val.ty {\n-            bug!(\"Cannot drop downcast ty yet\");\n-        }\n-        // `if` below could be \"!contents_needs_drop\"; skipping drop\n-        // is just an optimization, so sound to be conservative.\n-        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n-            return CleanupScope::noop();\n-        }\n-\n-        let drop = DropValue {\n-            val: val,\n-            skip_dtor: true,\n-        };\n-\n-        CleanupScope::new(bcx, drop)\n-    }\n-\n-    fn new(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n-        CleanupScope {\n-            cleanup: Some(drop_val),\n-            landing_pad: if !bcx.sess().no_landing_pads() {\n-                Some(drop_val.get_landing_pad(bcx))\n-            } else {\n-                None\n-            },\n-        }\n-    }\n-\n-    pub fn noop() -> CleanupScope<'tcx> {\n-        CleanupScope {\n-            cleanup: None,\n-            landing_pad: None,\n-        }\n-    }\n-\n-    pub fn trans(self, bcx: &'a Builder<'a, 'tcx>) {\n-        if let Some(cleanup) = self.cleanup {\n-            cleanup.trans(None, &bcx);\n-        }\n-    }\n-}"}, {"sha": "500802a4135d009894d5a6beec787122e910c211", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 73, "deletions": 187, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -193,25 +193,21 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::lang_items::{BoxFreeFnLangItem, ExchangeMallocFnLangItem};\n+use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n use rustc::traits;\n-use rustc::ty::subst::{Kind, Substs, Subst};\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n-use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n use context::SharedCrateContext;\n use common::{def_ty, instance_ty};\n-use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n-use std::iter;\n-\n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n@@ -327,10 +323,6 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        TransItem::DropGlue(t) => {\n-            find_drop_glue_neighbors(scx, t, &mut neighbors);\n-            recursion_depth_reset = None;\n-        }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().hir.local_def_id(node_id);\n             let instance = Instance::mono(scx.tcx(), def_id);\n@@ -339,8 +331,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             debug_assert!(should_trans_locally(scx.tcx(), &instance));\n \n             let ty = instance_ty(scx, &instance);\n-            let ty = glue::get_drop_glue_type(scx, ty);\n-            neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+            visit_drop_use(scx, ty, true, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n@@ -396,6 +387,14 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n \n+    let recursion_depth = if Some(def_id) == tcx.lang_items.drop_in_place_fn() {\n+        // HACK: drop_in_place creates tight monomorphization loops. Give\n+        // it more margin.\n+        recursion_depth / 4\n+    } else {\n+        recursion_depth\n+    };\n+\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n@@ -521,27 +520,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &mir::Lvalue<'tcx>,\n-                    context: mir_visit::LvalueContext<'tcx>,\n-                    location: Location) {\n-        debug!(\"visiting lvalue {:?}\", *lvalue);\n-\n-        if let mir_visit::LvalueContext::Drop = context {\n-            let ty = lvalue.ty(self.mir, self.scx.tcx())\n-                           .to_ty(self.scx.tcx());\n-\n-            let ty = monomorphize::apply_param_substs(self.scx,\n-                                                      self.param_substs,\n-                                                      &ty);\n-            assert!(ty.is_normalized_for_trans());\n-            let ty = glue::get_drop_glue_type(self.scx, ty);\n-            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n-        }\n-\n-        self.super_lvalue(lvalue, context, location);\n-    }\n-\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: Location) {\n         debug!(\"visiting constant {:?} @ {:?}\", *constant, location);\n \n@@ -568,54 +546,90 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                              kind: &mir::TerminatorKind<'tcx>,\n                              location: Location) {\n         let tcx = self.scx.tcx();\n-        if let mir::TerminatorKind::Call {\n-            ref func,\n-            ..\n-        } = *kind {\n-            let callee_ty = func.ty(self.mir, tcx);\n-            let callee_ty = monomorphize::apply_param_substs(\n-                self.scx, self.param_substs, &callee_ty);\n-            visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+        match *kind {\n+            mir::TerminatorKind::Call { ref func, .. } => {\n+                let callee_ty = func.ty(self.mir, tcx);\n+                let callee_ty = monomorphize::apply_param_substs(\n+                    self.scx, self.param_substs, &callee_ty);\n+                visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n+            }\n+            mir::TerminatorKind::Drop { ref location, .. } |\n+            mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n+                let ty = location.ty(self.mir, self.scx.tcx())\n+                    .to_ty(self.scx.tcx());\n+                let ty = monomorphize::apply_param_substs(self.scx,\n+                                                          self.param_substs,\n+                                                          &ty);\n+                visit_drop_use(self.scx, ty, true, self.output);\n+            }\n+            mir::TerminatorKind::Goto { .. } |\n+            mir::TerminatorKind::SwitchInt { .. } |\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Unreachable |\n+            mir::TerminatorKind::Assert { .. } => {}\n         }\n \n         self.super_terminator_kind(block, kind, location);\n     }\n }\n \n+fn visit_drop_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                            ty: ty::Ty<'tcx>,\n+                            is_direct_call: bool,\n+                            output: &mut Vec<TransItem<'tcx>>)\n+{\n+    let instance = monomorphize::resolve_drop_in_place(scx, ty);\n+    visit_instance_use(scx, instance, is_direct_call, output);\n+}\n+\n fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                           ty: ty::Ty<'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<TransItem<'tcx>>)\n {\n-    debug!(\"visit_fn_use({:?}, is_direct_call={:?})\", ty, is_direct_call);\n-    let (def_id, substs) = match ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => (def_id, substs),\n-        _ => return\n-    };\n+    if let ty::TyFnDef(def_id, substs, _) = ty.sty {\n+        let instance = monomorphize::resolve(scx, def_id, substs);\n+        visit_instance_use(scx, instance, is_direct_call, output);\n+    }\n+}\n \n-    let instance = monomorphize::resolve(scx, def_id, substs);\n+fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                instance: ty::Instance<'tcx>,\n+                                is_direct_call: bool,\n+                                output: &mut Vec<TransItem<'tcx>>)\n+{\n+    debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_trans_locally(scx.tcx(), &instance) {\n         return\n     }\n \n     match instance.def {\n-        ty::InstanceDef::Intrinsic(..) => {\n+        ty::InstanceDef::Intrinsic(def_id) => {\n             if !is_direct_call {\n-                bug!(\"intrinsic {:?} being reified\", ty);\n-            }\n-            if scx.tcx().item_name(def_id) == \"drop_in_place\" {\n-                // drop_in_place is a call to drop glue, need to instantiate\n-                // that.\n-                let ty = glue::get_drop_glue_type(scx, substs.type_at(0));\n-                output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+                bug!(\"intrinsic {:?} being reified\", def_id);\n             }\n         }\n-        ty::InstanceDef::Virtual(..) => {\n+        ty::InstanceDef::Virtual(..) |\n+        ty::InstanceDef::DropGlue(_, None) => {\n             // don't need to emit shim if we are calling directly.\n             if !is_direct_call {\n                 output.push(create_fn_trans_item(instance));\n             }\n         }\n+        ty::InstanceDef::DropGlue(_, Some(ty)) => {\n+            match ty.sty {\n+                ty::TyArray(ety, _) |\n+                ty::TySlice(ety)\n+                    if is_direct_call =>\n+                {\n+                    // drop of arrays/slices is translated in-line.\n+                    visit_drop_use(scx, ety, false, output);\n+                }\n+                _ => {}\n+            };\n+            output.push(create_fn_trans_item(instance));\n+        }\n         ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Item(..) |\n         ty::InstanceDef::FnPtrShim(..) => {\n@@ -634,6 +648,7 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n         ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Virtual(..) |\n         ty::InstanceDef::FnPtrShim(..) |\n+        ty::InstanceDef::DropGlue(..) |\n         ty::InstanceDef::Intrinsic(_) => return true\n     };\n     match tcx.hir.get_if_local(def_id) {\n@@ -658,124 +673,6 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n     }\n }\n \n-fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                      dg: DropGlueKind<'tcx>,\n-                                      output: &mut Vec<TransItem<'tcx>>) {\n-    let ty = match dg {\n-        DropGlueKind::Ty(ty) => ty,\n-        DropGlueKind::TyContents(_) => {\n-            // We already collected the neighbors of this item via the\n-            // DropGlueKind::Ty variant.\n-            return\n-        }\n-    };\n-\n-    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(scx.tcx(), ty));\n-\n-    // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n-    if ty.is_box() {\n-        let tcx = scx.tcx();\n-        let def_id = tcx.require_lang_item(BoxFreeFnLangItem);\n-        let box_free_instance = Instance::new(\n-            def_id,\n-            tcx.mk_substs(iter::once(Kind::from(ty.boxed_ty())))\n-        );\n-        if should_trans_locally(tcx, &box_free_instance) {\n-            output.push(create_fn_trans_item(box_free_instance));\n-        }\n-    }\n-\n-    // If the type implements Drop, also add a translation item for the\n-    // monomorphized Drop::drop() implementation.\n-    let has_dtor = match ty.sty {\n-        ty::TyAdt(def, _) => def.has_dtor(scx.tcx()),\n-        _ => false\n-    };\n-\n-    if has_dtor && !ty.is_box() {\n-        let drop_trait_def_id = scx.tcx()\n-                                   .lang_items\n-                                   .drop_trait()\n-                                   .unwrap();\n-        let drop_method = scx.tcx().associated_items(drop_trait_def_id)\n-            .find(|it| it.kind == ty::AssociatedKind::Method)\n-            .unwrap().def_id;\n-        let substs = scx.tcx().mk_substs_trait(ty, &[]);\n-        let instance = monomorphize::resolve(scx, drop_method, substs);\n-        if should_trans_locally(scx.tcx(), &instance) {\n-            output.push(create_fn_trans_item(instance));\n-        }\n-\n-        // This type has a Drop implementation, we'll need the contents-only\n-        // version of the glue too.\n-        output.push(TransItem::DropGlue(DropGlueKind::TyContents(ty)));\n-    }\n-\n-    // Finally add the types of nested values\n-    match ty.sty {\n-        ty::TyBool      |\n-        ty::TyChar      |\n-        ty::TyInt(_)    |\n-        ty::TyUint(_)   |\n-        ty::TyStr       |\n-        ty::TyFloat(_)  |\n-        ty::TyRawPtr(_) |\n-        ty::TyRef(..)   |\n-        ty::TyFnDef(..) |\n-        ty::TyFnPtr(_)  |\n-        ty::TyNever     |\n-        ty::TyDynamic(..)  => {\n-            /* nothing to do */\n-        }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            let inner_type = glue::get_drop_glue_type(scx, ty.boxed_ty());\n-            if scx.type_needs_drop(inner_type) {\n-                output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n-            }\n-        }\n-        ty::TyAdt(def, substs) => {\n-            for field in def.all_fields() {\n-                let field_type = def_ty(scx, field.did, substs);\n-                let field_type = glue::get_drop_glue_type(scx, field_type);\n-\n-                if scx.type_needs_drop(field_type) {\n-                    output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n-                }\n-            }\n-        }\n-        ty::TyClosure(def_id, substs) => {\n-            for upvar_ty in substs.upvar_tys(def_id, scx.tcx()) {\n-                let upvar_ty = glue::get_drop_glue_type(scx, upvar_ty);\n-                if scx.type_needs_drop(upvar_ty) {\n-                    output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n-                }\n-            }\n-        }\n-        ty::TySlice(inner_type)    |\n-        ty::TyArray(inner_type, _) => {\n-            let inner_type = glue::get_drop_glue_type(scx, inner_type);\n-            if scx.type_needs_drop(inner_type) {\n-                output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n-            }\n-        }\n-        ty::TyTuple(args, _) => {\n-            for arg in args {\n-                let arg = glue::get_drop_glue_type(scx, arg);\n-                if scx.type_needs_drop(arg) {\n-                    output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n-                }\n-            }\n-        }\n-        ty::TyProjection(_) |\n-        ty::TyParam(_)      |\n-        ty::TyInfer(_)      |\n-        ty::TyAnon(..)      |\n-        ty::TyError         => {\n-            bug!(\"encountered unexpected type\");\n-        }\n-    }\n-}\n-\n /// For given pair of source and target type that occur in an unsizing coercion,\n /// this function finds the pair of types that determines the vtable linking\n /// them.\n@@ -894,8 +791,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n             output.extend(methods);\n         }\n         // Also add the destructor\n-        let dg_type = glue::get_drop_glue_type(scx, impl_ty);\n-        output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n+        visit_drop_use(scx, impl_ty, false, output);\n     }\n }\n \n@@ -940,8 +836,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                                def_id_to_string(self.scx.tcx(), def_id));\n \n                         let ty = def_ty(self.scx, def_id, Substs::empty());\n-                        let ty = glue::get_drop_glue_type(self.scx, ty);\n-                        self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+                        visit_drop_use(self.scx, ty, true, self.output);\n                     }\n                 }\n             }\n@@ -1093,12 +988,3 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     printer.push_def_path(def_id, &mut output);\n     output\n }\n-\n-fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n-    let mut output = String::new();\n-    let printer = DefPathBasedNames::new(tcx, false, false);\n-    printer.push_type_name(ty, &mut output);\n-    output\n-}"}, {"sha": "a0906bb02f5a32893db8c4fff5f754e6ec3b33c3", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -535,16 +535,27 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn requests_inline<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: &ty::Instance<'tcx>\n+) -> bool {\n+    if is_inline_instance(tcx, instance) {\n+        return true\n+    }\n+    attr::requests_inline(&instance.def.attrs(tcx)[..])\n+}\n+\n+pub fn is_inline_instance<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: &ty::Instance<'tcx>\n ) -> bool {\n     let def_id = match instance.def {\n         ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n         _ => return true\n     };\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::StructCtor |\n         DefPathData::EnumVariant(..) |\n         DefPathData::ClosureExpr => true,\n-        _ => attr::requests_inline(&tcx.get_attrs(def_id)[..]),\n+        _ => false\n     }\n }\n "}, {"sha": "1c1395f1b7762604309616c59b07979824036bf8", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -21,7 +21,6 @@ use debuginfo;\n use callee;\n use base;\n use declare;\n-use glue::DropGlueKind;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n@@ -46,7 +45,7 @@ use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n-use abi::{Abi, FnType};\n+use abi::Abi;\n \n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n@@ -94,8 +93,6 @@ pub struct LocalCrateContext<'tcx> {\n     previous_work_product: Option<WorkProduct>,\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n-    fn_pointer_shims: RefCell<FxHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n@@ -587,8 +584,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n-                fn_pointer_shims: RefCell::new(FxHashMap()),\n-                drop_glues: RefCell::new(FxHashMap()),\n                 instances: RefCell::new(FxHashMap()),\n                 vtables: RefCell::new(FxHashMap()),\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n@@ -723,15 +718,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n \n-    pub fn fn_pointer_shims(&self) -> &RefCell<FxHashMap<Ty<'tcx>, ValueRef>> {\n-        &self.local().fn_pointer_shims\n-    }\n-\n-    pub fn drop_glues<'a>(&'a self)\n-                          -> &'a RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n-        &self.local().drop_glues\n-    }\n-\n     pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }"}, {"sha": "41a9ab2842dcd3e85694b6d25b73f43821fb8c58", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 14, "deletions": 389, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -13,69 +13,35 @@\n // Code relating to drop glue.\n \n use std;\n-use std::iter;\n \n use llvm;\n-use llvm::{ValueRef, get_param};\n-use middle::lang_items::BoxFreeFnLangItem;\n-use rustc::ty::subst::{Substs};\n+use llvm::{ValueRef};\n use rustc::traits;\n-use rustc::ty::{self, layout, AdtDef, AdtKind, Ty, TypeFoldable};\n-use rustc::ty::subst::Kind;\n-use rustc::mir::tcx::LvalueTy;\n-use mir::lvalue::LvalueRef;\n-use abi::FnType;\n-use adt;\n-use base::*;\n-use callee::get_fn;\n-use cleanup::CleanupScope;\n+use rustc::ty::{self, Ty, TypeFoldable};\n use common::*;\n use machine::*;\n+use meth;\n use monomorphize;\n-use trans_item::TransItem;\n-use tvec;\n-use type_of::{type_of, sizing_type_of, align_of};\n-use type_::Type;\n+use type_of::{sizing_type_of, align_of};\n use value::Value;\n-use Disr;\n use builder::Builder;\n \n-use mir::lvalue::Alignment;\n-\n-pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n-    let content_ty = ptr.ty.to_ty(bcx.tcx());\n-    let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n-    let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n-    let instance = monomorphize::resolve(bcx.ccx.shared(), def_id, substs);\n-\n-    let fn_ty = FnType::from_instance(bcx.ccx, &instance, &[]);\n-    let llret = bcx.call(get_fn(bcx.ccx, instance),\n-        &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize], None);\n-    fn_ty.apply_attrs_callsite(llret);\n-}\n-\n-pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn needs_drop_glue<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>) -> bool {\n     assert!(t.is_normalized_for_trans());\n \n     let t = scx.tcx().erase_regions(&t);\n \n-    // Even if there is no dtor for t, there might be one deeper down and we\n-    // might need to pass in the vtable ptr.\n-    if !scx.type_is_sized(t) {\n-        return t;\n-    }\n-\n     // FIXME (#22815): note that type_needs_drop conservatively\n     // approximates in some cases and may say a type expression\n     // requires drop glue when it actually does not.\n     //\n     // (In this case it is not clear whether any harm is done, i.e.\n-    // erroneously returning `t` in some cases where we could have\n-    // returned `tcx.types.i8` does not appear unsound. The impact on\n+    // erroneously returning `true` in some cases where we could have\n+    // returned `false` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n     if !scx.type_needs_drop(t) {\n-        return scx.tcx().types.i8;\n+        return false;\n     }\n     match t.sty {\n         ty::TyAdt(def, _) if def.is_box() => {\n@@ -85,210 +51,19 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n                     let layout = t.layout(&infcx).unwrap();\n                     if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n                         // `Box<ZeroSizeType>` does not allocate.\n-                        scx.tcx().types.i8\n+                        false\n                     } else {\n-                        t\n+                        true\n                     }\n                 })\n             } else {\n-                t\n+                true\n             }\n         }\n-        _ => t\n-    }\n-}\n-\n-fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: LvalueRef<'tcx>) {\n-    call_drop_glue(bcx, args, false, None)\n-}\n-\n-pub fn call_drop_glue<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    mut args: LvalueRef<'tcx>,\n-    skip_dtor: bool,\n-    funclet: Option<&'a Funclet>,\n-) {\n-    let t = args.ty.to_ty(bcx.tcx());\n-    // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n-    if bcx.ccx.shared().type_needs_drop(t) {\n-        let ccx = bcx.ccx;\n-        let g = if skip_dtor {\n-            DropGlueKind::TyContents(t)\n-        } else {\n-            DropGlueKind::Ty(t)\n-        };\n-        let glue = get_drop_glue_core(ccx, g);\n-        let glue_type = get_drop_glue_type(ccx.shared(), t);\n-        if glue_type != t {\n-            args.llval = bcx.pointercast(args.llval, type_of(ccx, glue_type).ptr_to());\n-        }\n-\n-        // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[args.llval, args.llextra][..1 + args.has_extra() as usize],\n-            funclet.map(|b| b.bundle()));\n+        _ => true\n     }\n }\n \n-pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n-    get_drop_glue_core(ccx, DropGlueKind::Ty(t))\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum DropGlueKind<'tcx> {\n-    /// The normal path; runs the dtor, and then recurs on the contents\n-    Ty(Ty<'tcx>),\n-    /// Skips the dtor, if any, for ty; drops the contents directly.\n-    /// Note that the dtor is only skipped at the most *shallow*\n-    /// level, namely, an `impl Drop for Ty` itself. So, for example,\n-    /// if Ty is Newtype(S) then only the Drop impl for Newtype itself\n-    /// will be skipped, while the Drop impl for S, if any, will be\n-    /// invoked.\n-    TyContents(Ty<'tcx>),\n-}\n-\n-impl<'tcx> DropGlueKind<'tcx> {\n-    pub fn ty(&self) -> Ty<'tcx> {\n-        match *self { DropGlueKind::Ty(t) | DropGlueKind::TyContents(t) => t }\n-    }\n-\n-    pub fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n-    {\n-        match *self {\n-            DropGlueKind::Ty(t) => DropGlueKind::Ty(f(t)),\n-            DropGlueKind::TyContents(t) => DropGlueKind::TyContents(f(t)),\n-        }\n-    }\n-}\n-\n-fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) -> ValueRef {\n-    let g = g.map_ty(|t| get_drop_glue_type(ccx.shared(), t));\n-    match ccx.drop_glues().borrow().get(&g) {\n-        Some(&(glue, _)) => glue,\n-        None => {\n-            bug!(\"Could not find drop glue for {:?} -- {} -- {}.\",\n-                    g,\n-                    TransItem::DropGlue(g).to_raw_string(),\n-                    ccx.codegen_unit().name());\n-        }\n-    }\n-}\n-\n-pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKind<'tcx>) {\n-    assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n-    let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n-\n-    let mut bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-\n-    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n-    // All glue functions take values passed *by alias*; this is a\n-    // requirement since in many contexts glue is invoked indirectly and\n-    // the caller has no idea if it's dealing with something that can be\n-    // passed by value.\n-    //\n-    // llfn is expected be declared to take a parameter of the appropriate\n-    // type, so we don't need to explicitly cast the function parameter.\n-\n-    // NB: v0 is an *alias* of type t here, not a direct value.\n-    // Only drop the value when it ... well, we used to check for\n-    // non-null, (and maybe we need to continue doing so), but we now\n-    // must definitely check for special bit-patterns corresponding to\n-    // the special dtor markings.\n-    let t = g.ty();\n-\n-    let value = get_param(llfn, 0);\n-    let ptr = if ccx.shared().type_is_sized(t) {\n-        LvalueRef::new_sized_ty(value, t, Alignment::AbiAligned)\n-    } else {\n-        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t, Alignment::AbiAligned)\n-    };\n-\n-    let skip_dtor = match g {\n-        DropGlueKind::Ty(_) => false,\n-        DropGlueKind::TyContents(_) => true\n-    };\n-\n-    let bcx = match t.sty {\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            // Support for Box is built-in as yet and its drop glue is special\n-            // despite having a dummy Drop impl in the library.\n-            assert!(!skip_dtor);\n-            let content_ty = t.boxed_ty();\n-            let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval), None);\n-                let info = bcx.load(get_meta(&bcx, ptr.llval), None);\n-                LvalueRef::new_unsized_ty(llbox, info, content_ty, Alignment::AbiAligned)\n-            } else {\n-                LvalueRef::new_sized_ty(\n-                    bcx.load(ptr.llval, None),\n-                    content_ty, Alignment::AbiAligned)\n-            };\n-            drop_ty(&bcx, ptr);\n-            trans_exchange_free_ty(&bcx, ptr);\n-            bcx\n-        }\n-        ty::TyDynamic(..) => {\n-            // No support in vtable for distinguishing destroying with\n-            // versus without calling Drop::drop. Assert caller is\n-            // okay with always calling the Drop impl, if any.\n-            assert!(!skip_dtor);\n-            let dtor = bcx.load(ptr.llextra, None);\n-            bcx.call(dtor, &[ptr.llval], None);\n-            bcx\n-        }\n-        ty::TyAdt(def, ..) if def.has_dtor(bcx.tcx()) && !skip_dtor => {\n-            let shallow_drop = def.is_union();\n-            let tcx = bcx.tcx();\n-\n-            // Be sure to put the contents into a scope so we can use an invoke\n-            // instruction to call the user destructor but still call the field\n-            // destructors if the user destructor panics.\n-            //\n-            // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n-            // might well consider changing below to more direct code.\n-            // Issue #23611: schedule cleanup of contents, re-inspecting the\n-            // discriminant (if any) in case of variant swap in drop code.\n-            let contents_scope = if !shallow_drop {\n-                CleanupScope::schedule_drop_adt_contents(&bcx, ptr)\n-            } else {\n-                CleanupScope::noop()\n-            };\n-            let drop_trait_def_id = tcx.lang_items.drop_trait().unwrap();\n-            let drop_method = tcx.associated_items(drop_trait_def_id)\n-                .find(|it| it.kind == ty::AssociatedKind::Method)\n-                .unwrap().def_id;\n-            let self_type_substs = tcx.mk_substs_trait(t, &[]);\n-            let drop_instance = monomorphize::resolve(\n-                bcx.ccx.shared(), drop_method, self_type_substs);\n-            let fn_ty = FnType::from_instance(bcx.ccx, &drop_instance, &[]);\n-            let llfn = get_fn(bcx.ccx, drop_instance);\n-            let llret;\n-            let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n-            if let Some(landing_pad) = contents_scope.landing_pad {\n-                let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n-                llret = bcx.invoke(llfn, args, normal_bcx.llbb(), landing_pad, None);\n-                bcx = normal_bcx;\n-            } else {\n-                llret = bcx.call(llfn, args, None);\n-            }\n-            fn_ty.apply_attrs_callsite(llret);\n-            contents_scope.trans(&bcx);\n-            bcx\n-        }\n-        ty::TyAdt(def, ..) if def.is_union() => {\n-            bcx\n-        }\n-        _ => {\n-            if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, ptr)\n-            } else {\n-                bcx\n-            }\n-        }\n-    };\n-    bcx.ret_void();\n-}\n-\n pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n@@ -375,20 +150,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             (size, align)\n         }\n         ty::TyDynamic(..) => {\n-            // info points to the vtable and the second entry in the vtable is the\n-            // dynamic size of the object.\n-            let info = bcx.pointercast(info, Type::int(bcx.ccx).ptr_to());\n-            let size_ptr = bcx.gepi(info, &[1]);\n-            let align_ptr = bcx.gepi(info, &[2]);\n-\n-            let size = bcx.load(size_ptr, None);\n-            let align = bcx.load(align_ptr, None);\n-\n-            // Vtable loads are invariant\n-            bcx.set_invariant_load(size);\n-            bcx.set_invariant_load(align);\n-\n-            (size, align)\n+            // load size/align from vtable\n+            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n@@ -403,141 +166,3 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }\n-\n-// Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'a, 'tcx>(\n-    cx: Builder<'a, 'tcx>,\n-    mut ptr: LvalueRef<'tcx>\n-) -> Builder<'a, 'tcx> {\n-    fn iter_variant_fields<'a, 'tcx>(\n-        cx: &'a Builder<'a, 'tcx>,\n-        av: LvalueRef<'tcx>,\n-        adt_def: &'tcx AdtDef,\n-        variant_index: usize,\n-        substs: &'tcx Substs<'tcx>\n-    ) {\n-        let variant = &adt_def.variants[variant_index];\n-        let tcx = cx.tcx();\n-        for (i, field) in variant.fields.iter().enumerate() {\n-            let arg = monomorphize::field_ty(tcx, substs, field);\n-            let (field_ptr, align) = av.trans_field_ptr(&cx, i);\n-            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg, align));\n-        }\n-    }\n-\n-    let mut cx = cx;\n-    let t = ptr.ty.to_ty(cx.tcx());\n-    match t.sty {\n-        ty::TyClosure(def_id, substs) => {\n-            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let (llupvar, align) = ptr.trans_field_ptr(&cx, i);\n-                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty, align));\n-            }\n-        }\n-        ty::TyArray(_, n) => {\n-            let base = get_dataptr(&cx, ptr.llval);\n-            let len = C_uint(cx.ccx, n);\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty, ptr.alignment)));\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n-                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty, ptr.alignment)));\n-        }\n-        ty::TyTuple(ref args, _) => {\n-            for (i, arg) in args.iter().enumerate() {\n-                let (llfld_a, align) = ptr.trans_field_ptr(&cx, i);\n-                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg, align));\n-            }\n-        }\n-        ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-            AdtKind::Struct => {\n-                for (i, field) in adt.variants[0].fields.iter().enumerate() {\n-                    let field_ty = monomorphize::field_ty(cx.tcx(), substs, field);\n-                    let (llval, align) = ptr.trans_field_ptr(&cx, i);\n-                    let field_ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n-                        LvalueRef::new_sized_ty(llval, field_ty, align)\n-                    } else {\n-                        LvalueRef::new_unsized_ty(llval, ptr.llextra, field_ty, align)\n-                    };\n-                    drop_ty(&cx, field_ptr);\n-                }\n-            }\n-            AdtKind::Union => {\n-                bug!(\"Union in `glue::drop_structural_ty`\");\n-            }\n-            AdtKind::Enum => {\n-                let n_variants = adt.variants.len();\n-\n-                // NB: we must hit the discriminant first so that structural\n-                // comparison know not to proceed when the discriminants differ.\n-\n-                // Obtain a representation of the discriminant sufficient to translate\n-                // destructuring; this may or may not involve the actual discriminant.\n-                let l = cx.ccx.layout_of(t);\n-                match *l {\n-                    layout::Univariant { .. } |\n-                    layout::UntaggedUnion { .. } => {\n-                        if n_variants != 0 {\n-                            assert!(n_variants == 1);\n-                            ptr.ty = LvalueTy::Downcast {\n-                                adt_def: adt,\n-                                substs: substs,\n-                                variant_index: 0,\n-                            };\n-                            iter_variant_fields(&cx, ptr, &adt, 0, substs);\n-                        }\n-                    }\n-                    layout::CEnum { .. } |\n-                    layout::General { .. } |\n-                    layout::RawNullablePointer { .. } |\n-                    layout::StructWrappedNullablePointer { .. } => {\n-                        let lldiscrim_a = adt::trans_get_discr(\n-                            &cx, t, ptr.llval, ptr.alignment, None, false);\n-\n-                        // Create a fall-through basic block for the \"else\" case of\n-                        // the switch instruction we're about to generate. Note that\n-                        // we do **not** use an Unreachable instruction here, even\n-                        // though most of the time this basic block will never be hit.\n-                        //\n-                        // When an enum is dropped it's contents are currently\n-                        // overwritten to DTOR_DONE, which means the discriminant\n-                        // could have changed value to something not within the actual\n-                        // range of the discriminant. Currently this function is only\n-                        // used for drop glue so in this case we just return quickly\n-                        // from the outer function, and any other use case will only\n-                        // call this for an already-valid enum in which case the `ret\n-                        // void` will never be hit.\n-                        let ret_void_cx = cx.build_sibling_block(\"enum-iter-ret-void\");\n-                        ret_void_cx.ret_void();\n-                        let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = cx.build_sibling_block(\"enum-iter-next\");\n-\n-                        for (i, discr) in adt.discriminants(cx.tcx()).enumerate() {\n-                            let variant_cx_name = format!(\"enum-iter-variant-{}\", i);\n-                            let variant_cx = cx.build_sibling_block(&variant_cx_name);\n-                            let case_val = adt::trans_case(&cx, t, Disr::from(discr));\n-                            variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            ptr.ty = LvalueTy::Downcast {\n-                                adt_def: adt,\n-                                substs: substs,\n-                                variant_index: i,\n-                            };\n-                            iter_variant_fields(&variant_cx, ptr, &adt, i, substs);\n-                            variant_cx.br(next_cx.llbb());\n-                        }\n-                        cx = next_cx;\n-                    }\n-                    _ => bug!(\"{} is not an enum.\", t),\n-                }\n-            }\n-        },\n-\n-        _ => {\n-            cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n-        }\n-    }\n-    return cx;\n-}"}, {"sha": "f3e30ed4839ae488fe1aeb86cce9d89bfa3e58c0", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -113,7 +113,6 @@ mod cabi_x86;\n mod cabi_x86_64;\n mod cabi_x86_win64;\n mod callee;\n-mod cleanup;\n mod collector;\n mod common;\n mod consts;"}, {"sha": "75ab407614050eab3e187c868b020627569245cf", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -14,28 +14,45 @@ use callee;\n use common::*;\n use builder::Builder;\n use consts;\n-use glue;\n use machine;\n+use monomorphize;\n use type_::Type;\n use type_of::*;\n use value::Value;\n use rustc::ty;\n \n-// drop_glue pointer, size, align.\n-const VTABLE_OFFSET: usize = 3;\n-\n-/// Extracts a method from a trait object's vtable, at the specified index.\n-pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                    llvtable: ValueRef,\n-                                    vtable_index: usize) -> ValueRef {\n-    // Load the data pointer from the object.\n-    debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n-           vtable_index, Value(llvtable));\n-\n-    let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[vtable_index + VTABLE_OFFSET]), None);\n-    // Vtable loads are invariant\n-    bcx.set_invariant_load(ptr);\n-    ptr\n+#[derive(Copy, Clone, Debug)]\n+pub struct VirtualIndex(usize);\n+\n+pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n+pub const SIZE: VirtualIndex = VirtualIndex(1);\n+pub const ALIGN: VirtualIndex = VirtualIndex(2);\n+\n+impl<'a, 'tcx> VirtualIndex {\n+    pub fn from_index(index: usize) -> Self {\n+        VirtualIndex(index + 3)\n+    }\n+\n+    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+        // Load the data pointer from the object.\n+        debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n+\n+        let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[self.0]), None);\n+        // Vtable loads are invariant\n+        bcx.set_invariant_load(ptr);\n+        ptr\n+    }\n+\n+    pub fn get_usize(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+        // Load the data pointer from the object.\n+        debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n+\n+        let llvtable = bcx.pointercast(llvtable, Type::int(bcx.ccx).ptr_to());\n+        let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n+        // Vtable loads are invariant\n+        bcx.set_invariant_load(ptr);\n+        ptr\n+    }\n }\n \n /// Creates a dynamic vtable for the given type and vtable origin.\n@@ -68,8 +85,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let align = align_of(ccx, ty);\n \n     let mut components: Vec<_> = [\n-        // Generate a destructor for the vtable.\n-        glue::get_drop_glue(ccx, ty),\n+        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n     ].iter().cloned().collect();"}, {"sha": "226d40948c4dc41096e482f3571954aec8319f0a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -19,13 +19,13 @@ use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n use common::{self, Funclet};\n-use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n+use common::{C_bool, C_str_slice, C_struct, C_u32, C_uint, C_undef};\n use consts;\n use machine::llalign_of_min;\n use meth;\n use monomorphize;\n+use tvec;\n use type_of::{self, align_of};\n-use glue;\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -209,21 +209,49 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.shared(), ty);\n \n-                // Double check for necessity to drop\n-                if !bcx.ccx.shared().type_needs_drop(ty) {\n+                if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+                    // we don't actually need to drop anything.\n                     funclet_br(self, bcx, target);\n-                    return;\n+                    return\n                 }\n \n-                let mut lvalue = self.trans_lvalue(&bcx, location);\n-                let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n-                let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n-                if bcx.ccx.shared().type_is_sized(ty) && drop_ty != ty {\n-                    lvalue.llval = bcx.pointercast(\n-                        lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to());\n-                }\n-                let args = &[lvalue.llval, lvalue.llextra][..1 + lvalue.has_extra() as usize];\n+                let lvalue = self.trans_lvalue(&bcx, location);\n+                let (drop_fn, need_extra) = match ty.sty {\n+                    ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n+                                          false),\n+                    ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+                        // FIXME: handle panics\n+                        let drop_fn = monomorphize::resolve_drop_in_place(\n+                            bcx.ccx.shared(), ety);\n+                        let drop_fn = callee::get_fn(bcx.ccx, drop_fn);\n+                        let bcx = tvec::slice_for_each(\n+                            &bcx,\n+                            lvalue.project_index(&bcx, C_uint(bcx.ccx, 0u64)),\n+                            ety,\n+                            lvalue.len(bcx.ccx),\n+                            |bcx, llval, loop_bb| {\n+                                self.set_debug_loc(&bcx, terminator.source_info);\n+                                if let Some(unwind) = unwind {\n+                                    bcx.invoke(\n+                                        drop_fn,\n+                                        &[llval],\n+                                        loop_bb,\n+                                        llblock(self, unwind),\n+                                        cleanup_bundle\n+                                    );\n+                                } else {\n+                                    bcx.call(drop_fn, &[llval], cleanup_bundle);\n+                                    bcx.br(loop_bb);\n+                                }\n+                            });\n+                        funclet_br(self, bcx, target);\n+                        return\n+                    }\n+                    _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n+                };\n+                let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(\n                         drop_fn,\n@@ -417,23 +445,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     Some(ty::InstanceDef::Virtual(..)) => {\n                         FnType::new_vtable(bcx.ccx, sig, &extra_args)\n                     }\n-                    _ => FnType::new(bcx.ccx, sig, &extra_args)\n-                };\n-\n-                if intrinsic == Some(\"drop_in_place\") {\n-                    let &(_, target) = destination.as_ref().unwrap();\n-                    let ty = instance.unwrap().substs.type_at(0);\n-\n-                    // Double check for necessity to drop\n-                    if !bcx.ccx.shared().type_needs_drop(ty) {\n+                    Some(ty::InstanceDef::DropGlue(_, None)) => {\n+                        // empty drop glue - a nop.\n+                        let &(_, target) = destination.as_ref().unwrap();\n                         funclet_br(self, bcx, target);\n                         return;\n                     }\n-\n-                    let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n-                    let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                    llfn = Some(bcx.pointercast(drop_fn, llty));\n-                }\n+                    _ => FnType::new(bcx.ccx, sig, &extra_args)\n+                };\n \n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n@@ -588,7 +607,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (ptr, meta) = (a, b);\n                 if *next_idx == 0 {\n                     if let Some(ty::InstanceDef::Virtual(_, idx)) = *def {\n-                        let llmeth = meth::get_virtual_method(bcx, meta, idx);\n+                        let llmeth = meth::VirtualIndex::from_index(idx).get_fn(bcx, meta);\n                         let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n                         *llfn = Some(bcx.pointercast(llmeth, llty));\n                     }\n@@ -756,14 +775,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return block;\n         }\n \n+        let block = self.blocks[target_bb];\n+        let landing_pad = self.landing_pad_uncached(block);\n+        self.landing_pads[target_bb] = Some(landing_pad);\n+        landing_pad\n+    }\n+\n+    fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n         if base::wants_msvc_seh(self.ccx.sess()) {\n-            return self.blocks[target_bb];\n+            return target_bb;\n         }\n \n-        let target = self.get_builder(target_bb);\n-\n         let bcx = self.new_block(\"cleanup\");\n-        self.landing_pads[target_bb] = Some(bcx.llbb());\n \n         let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n@@ -772,7 +795,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot, None);\n-        bcx.br(target.llbb());\n+        bcx.br(target_bb);\n         bcx.llbb()\n     }\n "}, {"sha": "dd8c1d0e1f0310d5b49d15b2593c03f0b454aacd", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 16, "deletions": 42, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -27,7 +27,6 @@ use std::ptr;\n use std::ops;\n \n use super::{MirContext, LocalRef};\n-use super::operand::OperandValue;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Alignment {\n@@ -95,16 +94,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(ty), alignment)\n     }\n \n-    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>, alignment: Alignment)\n-                          -> LvalueRef<'tcx> {\n-        LvalueRef {\n-            llval: llval,\n-            llextra: llextra,\n-            ty: LvalueTy::from_ty(ty),\n-            alignment: alignment,\n-        }\n-    }\n-\n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n         let tmp = bcx.alloca(type_of::type_of(bcx.ccx, ty), name);\n@@ -279,6 +268,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n         }\n     }\n+\n+    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n+        if let ty::TySlice(_) = self.ty.to_ty(bcx.tcx()).sty {\n+            // Slices already point to the array element type.\n+            bcx.inbounds_gep(self.llval, &[llindex])\n+        } else {\n+            let zero = common::C_uint(bcx.ccx, 0u64);\n+            bcx.inbounds_gep(self.llval, &[zero, llindex])\n+        }\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n@@ -314,39 +313,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                let ptr = self.trans_consume(bcx, base);\n-                let projected_ty = LvalueTy::from_ty(ptr.ty)\n-                    .projection_ty(tcx, &mir::ProjectionElem::Deref);\n-                let projected_ty = self.monomorphize(&projected_ty);\n-                let (llptr, llextra) = match ptr.val {\n-                    OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n-                    OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n-                    OperandValue::Ref(..) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n-                };\n-                LvalueRef {\n-                    llval: llptr,\n-                    llextra: llextra,\n-                    ty: projected_ty,\n-                    alignment: Alignment::AbiAligned,\n-                }\n+                self.trans_consume(bcx, base).deref()\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n                 let projected_ty = self.monomorphize(&projected_ty);\n                 let align = tr_base.alignment;\n \n-                let project_index = |llindex| {\n-                    let element = if let ty::TySlice(_) = tr_base.ty.to_ty(tcx).sty {\n-                        // Slices already point to the array element type.\n-                        bcx.inbounds_gep(tr_base.llval, &[llindex])\n-                    } else {\n-                        let zero = common::C_uint(bcx.ccx, 0u64);\n-                        bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n-                    };\n-                    (element, align)\n-                };\n-\n                 let ((llprojected, align), llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n@@ -359,25 +333,25 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n-                        (project_index(self.prepare_index(bcx, index.immediate())), ptr::null_mut())\n+                        let llindex = self.prepare_index(bcx, index.immediate());\n+                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx, offset);\n-                        (project_index(lloffset), ptr::null_mut())\n+                        ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx, offset);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        (project_index(llindex), ptr::null_mut())\n+                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llindex = C_uint(bcx.ccx, from);\n-                        let (llbase, align) = project_index(llindex);\n+                        let llbase = tr_base.project_index(bcx, C_uint(bcx.ccx, from));\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {"}, {"sha": "da24c03fdc2a01bebb03ba1f35b10afe7ca23c23", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -9,9 +9,10 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::layout::Layout;\n use rustc::mir;\n+use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n@@ -22,9 +23,10 @@ use type_of;\n use type_::Type;\n \n use std::fmt;\n+use std::ptr;\n \n use super::{MirContext, LocalRef};\n-use super::lvalue::Alignment;\n+use super::lvalue::{Alignment, LvalueRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -86,6 +88,22 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n+    pub fn deref(self) -> LvalueRef<'tcx> {\n+        let projected_ty = self.ty.builtin_deref(true, ty::NoPreference)\n+            .unwrap().ty;\n+        let (llptr, llextra) = match self.val {\n+            OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n+            OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n+            OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n+        };\n+        LvalueRef {\n+            llval: llptr,\n+            llextra: llextra,\n+            ty: LvalueTy::from_ty(projected_ty),\n+            alignment: Alignment::AbiAligned,\n+        }\n+    }\n+\n     /// If this operand is a Pair, we return an\n     /// Immediate aggregate with the two values.\n     pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n@@ -236,7 +254,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let val = self.trans_constant(bcx, constant);\n+                let val = self.trans_constant(&bcx, constant);\n                 let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it."}, {"sha": "d487aa6cd5be6f7d5e00dab89cc4683b80b2df9b", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -98,8 +98,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n-                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n+                tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot, loop_bb| {\n                     self.store_operand(bcx, llslot, dest.alignment.to_align(), tr_elem);\n+                    bcx.br(loop_bb);\n                 })\n             }\n \n@@ -459,7 +460,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 (bcx, operand)\n             }\n-\n             mir::Rvalue::Use(ref operand) => {\n                 let operand = self.trans_operand(&bcx, operand);\n                 (bcx, operand)\n@@ -662,7 +662,7 @@ pub fn rvalue_creates_operand(rvalue: &mir::Rvalue) -> bool {\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Discriminant(..) |\n         mir::Rvalue::Box(..) |\n-        mir::Rvalue::Use(..) =>\n+        mir::Rvalue::Use(..) => // (*)\n             true,\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) =>"}, {"sha": "fcf6937d4b6d58670681f042e9bc6deedc71076b", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -10,9 +10,11 @@\n \n use abi::Abi;\n use common::*;\n+use glue;\n \n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::fold::{TypeFolder, TypeFoldable};\n@@ -242,8 +244,19 @@ pub fn resolve<'a, 'tcx>(\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n             _ => {\n-                debug!(\" => free item\");\n-                ty::InstanceDef::Item(def_id)\n+                if Some(def_id) == scx.tcx().lang_items.drop_in_place_fn() {\n+                    let ty = substs.type_at(0);\n+                    if glue::needs_drop_glue(scx, ty) {\n+                        debug!(\" => nontrivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n+                    } else {\n+                        debug!(\" => trivial drop glue\");\n+                        ty::InstanceDef::DropGlue(def_id, None)\n+                    }\n+                } else {\n+                    debug!(\" => free item\");\n+                    ty::InstanceDef::Item(def_id)\n+                }\n             }\n         };\n         Instance { def, substs }\n@@ -253,6 +266,16 @@ pub fn resolve<'a, 'tcx>(\n     result\n }\n \n+pub fn resolve_drop_in_place<'a, 'tcx>(\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    ty: Ty<'tcx>)\n+    -> ty::Instance<'tcx>\n+{\n+    let def_id = scx.tcx().require_lang_item(DropInPlaceFnLangItem);\n+    let substs = scx.tcx().intern_substs(&[Kind::from(ty)]);\n+    resolve(scx, def_id, substs)\n+}\n+\n pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n                                              source_ty: Ty<'tcx>,\n                                              target_ty: Ty<'tcx>)"}, {"sha": "90ce40cfbcf8fa3f27f3f33cbeb781baca05ab39", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -194,7 +194,6 @@ impl<'tcx> CodegenUnit<'tcx> {\n                TransItem::Static(node_id) => {\n                     exported_symbols.contains(&node_id)\n                }\n-               TransItem::DropGlue(..) => false,\n             };\n             exported.hash(&mut state);\n         }\n@@ -245,7 +244,6 @@ impl<'tcx> CodegenUnit<'tcx> {\n                     tcx.hir.as_local_node_id(instance.def_id())\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n-                TransItem::DropGlue(_) => None,\n             }\n         }\n     }\n@@ -341,7 +339,6 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                     match trans_item {\n                         TransItem::Fn(..) |\n                         TransItem::Static(..) => llvm::ExternalLinkage,\n-                        TransItem::DropGlue(..) => unreachable!(),\n                     }\n                 }\n             };\n@@ -461,6 +458,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n                 ty::InstanceDef::FnPtrShim(..) |\n                 ty::InstanceDef::ClosureOnceShim { .. } |\n                 ty::InstanceDef::Intrinsic(..) |\n+                ty::InstanceDef::DropGlue(..) |\n                 ty::InstanceDef::Virtual(..) => return None\n             };\n \n@@ -485,7 +483,6 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n \n             Some(def_id)\n         }\n-        TransItem::DropGlue(dg) => characteristic_def_id_of_type(dg.ty()),\n         TransItem::Static(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }"}, {"sha": "1b48e131b720a2c5e5a3b01c5e7597cbd524c235", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -100,7 +100,6 @@ impl<'tcx> SymbolMap<'tcx> {\n                     tcx.hir.as_local_node_id(def.def_id())\n                 }\n                 TransItem::Static(node_id) => Some(node_id),\n-                TransItem::DropGlue(_) => None,\n             }.map(|node_id| {\n                 tcx.hir.span(node_id)\n             })"}, {"sha": "410e3f30be731eb0622e0a659030f04215094612", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 78, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -20,28 +20,23 @@ use consts;\n use context::{CrateContext, SharedCrateContext};\n use common;\n use declare;\n-use glue::DropGlueKind;\n use llvm;\n use monomorphize::Instance;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::definitions::DefPathData;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use type_of;\n-use glue;\n-use abi::{Abi, FnType};\n use back::symbol_names;\n use std::fmt::Write;\n use std::iter;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n-    DropGlue(DropGlueKind<'tcx>),\n     Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n@@ -100,9 +95,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n                 base::trans_instance(&ccx, instance);\n             }\n-            TransItem::DropGlue(dg) => {\n-                glue::implement_drop_glue(&ccx, dg);\n-            }\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n@@ -131,9 +123,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(instance) => {\n                 TransItem::predefine_fn(ccx, instance, linkage, &symbol_name);\n             }\n-            TransItem::DropGlue(dg) => {\n-                TransItem::predefine_drop_glue(ccx, dg, linkage, &symbol_name);\n-            }\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n@@ -180,52 +169,14 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n \n         debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-        match ccx.tcx().def_key(instance.def_id()).disambiguated_data.data {\n-            DefPathData::StructCtor |\n-            DefPathData::EnumVariant(..) |\n-            DefPathData::ClosureExpr => {\n-                attributes::inline(lldecl, attributes::InlineAttr::Hint);\n-            }\n-            _ => {}\n+        if common::is_inline_instance(ccx.tcx(), &instance) {\n+            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n         }\n-\n         attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,\n-                           dg: glue::DropGlueKind<'tcx>,\n-                           linkage: llvm::Linkage,\n-                           symbol_name: &str) {\n-        let tcx = ccx.tcx();\n-        assert_eq!(dg.ty(), glue::get_drop_glue_type(ccx.shared(), dg.ty()));\n-        let t = dg.ty();\n-\n-        let sig = tcx.mk_fn_sig(\n-            iter::once(tcx.mk_mut_ptr(t)),\n-            tcx.mk_nil(),\n-            false,\n-            hir::Unsafety::Normal,\n-            Abi::Rust\n-        );\n-\n-        debug!(\"predefine_drop_glue: sig={}\", sig);\n-\n-        let fn_ty = FnType::new(ccx, sig, &[]);\n-        let llfnty = fn_ty.llvm_type(ccx);\n-\n-        assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n-        let llfn = declare::declare_cfn(ccx, symbol_name, llfnty);\n-        unsafe { llvm::LLVMRustSetLinkage(llfn, linkage) };\n-        if linkage == llvm::Linkage::LinkOnceODRLinkage ||\n-           linkage == llvm::Linkage::WeakODRLinkage {\n-            llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-        }\n-        attributes::set_frame_pointer_elimination(ccx, llfn);\n-        ccx.drop_glues().borrow_mut().insert(dg, (llfn, fn_ty));\n-    }\n-\n     pub fn compute_symbol_name(&self,\n                                scx: &SharedCrateContext<'a, 'tcx>) -> String {\n         match *self {\n@@ -234,13 +185,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 let def_id = scx.tcx().hir.local_def_id(node_id);\n                 symbol_names::symbol_name(Instance::mono(scx.tcx(), def_id), scx)\n             }\n-            TransItem::DropGlue(dg) => {\n-                let prefix = match dg {\n-                    DropGlueKind::Ty(_) => \"drop\",\n-                    DropGlueKind::TyContents(_) => \"drop_contents\",\n-                };\n-                symbol_names::exported_name_from_type_and_prefix(scx, dg.ty(), prefix)\n-            }\n         }\n     }\n \n@@ -257,7 +201,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                     InstantiationMode::GloballyShared\n                 }\n             }\n-            TransItem::DropGlue(..) => InstantiationMode::LocalCopy,\n             TransItem::Static(..) => InstantiationMode::GloballyShared,\n         }\n     }\n@@ -267,7 +210,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(ref instance) => {\n                 instance.substs.types().next().is_some()\n             }\n-            TransItem::DropGlue(..) |\n             TransItem::Static(..)   => false,\n         }\n     }\n@@ -276,7 +218,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def_id(),\n             TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n         };\n \n         let attributes = tcx.get_attrs(def_id);\n@@ -300,16 +241,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         let hir_map = &tcx.hir;\n \n         return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                let printer = DefPathBasedNames::new(tcx, false, false);\n-                printer.push_type_name(dg.ty(), &mut s);\n-                s\n-            }\n             TransItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n@@ -334,13 +265,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn to_raw_string(&self) -> String {\n         match *self {\n-            TransItem::DropGlue(dg) => {\n-                let prefix = match dg {\n-                    DropGlueKind::Ty(_) => \"Ty\",\n-                    DropGlueKind::TyContents(_) => \"TyContents\",\n-                };\n-                format!(\"DropGlue({}: {})\", prefix, dg.ty() as *const _ as usize)\n-            }\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,"}, {"sha": "4216a73a8dd85b1ea2deae5865ec160a2235c279", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use builder::Builder;\n-use llvm::ValueRef;\n+use llvm::{BasicBlockRef, ValueRef};\n use common::*;\n use rustc::ty::Ty;\n \n@@ -20,7 +20,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     unit_ty: Ty<'tcx>,\n     len: ValueRef,\n     f: F\n-) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef) {\n+) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef, BasicBlockRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n     let zst = type_is_zero_size(bcx.ccx, unit_ty);\n     let add = |bcx: &Builder, a, b| if zst {\n@@ -46,9 +46,8 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-    f(&body_bcx, if zst { data_ptr } else { current });\n     let next = add(&body_bcx, current, C_uint(bcx.ccx, 1usize));\n+    f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n     header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n-    body_bcx.br(header_bcx.llbb());\n     next_bcx\n }"}, {"sha": "eb4f9e8e28e2d6a0a4c4e10224d2c29b3f298f5f", "filename": "src/test/codegen-units/item-collection/cross-crate-generic-functions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-generic-functions.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -30,5 +30,3 @@ fn main()\n     // This should not introduce a codegen item\n     let _ = cgu_generic_function::exported_but_not_generic(3);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "d8e6028b799fbbf18be03e11ad791e98eb20befb", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -11,8 +11,7 @@\n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n \n-//~ TRANS_ITEM drop-glue drop_in_place_intrinsic::StructWithDtor[0]\n-//~ TRANS_ITEM drop-glue-contents drop_in_place_intrinsic::StructWithDtor[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n struct StructWithDtor(u32);\n \n impl Drop for StructWithDtor {\n@@ -23,7 +22,7 @@ impl Drop for StructWithDtor {\n //~ TRANS_ITEM fn drop_in_place_intrinsic::main[0]\n fn main() {\n \n-    //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]; 2]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n     let x = [StructWithDtor(0), StructWithDtor(1)];\n \n     drop_slice_in_place(&x);\n@@ -35,7 +34,7 @@ fn drop_slice_in_place(x: &[StructWithDtor]) {\n         // This is the interesting thing in this test case: Normally we would\n         // not have drop-glue for the unsized [StructWithDtor]. This has to be\n         // generated though when the drop_in_place() intrinsic is used.\n-        //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic.cgu-0[Internal]\n         ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n     }\n }"}, {"sha": "c4aed7465bcb080e699fba3180ad7692486a33dd", "filename": "src/test/codegen-units/item-collection/function-as-argument.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ffunction-as-argument.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -44,5 +44,3 @@ fn main() {\n     //~ TRANS_ITEM fn function_as_argument::function[0]<f32, i64>\n     take_fn_pointer(function, 0f32, 0i64);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "06e02b100152e3bce98a2944f4b275a6e950ed3b", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -45,8 +45,7 @@ enum EnumNoDrop<T1, T2> {\n struct NonGenericNoDrop(i32);\n \n struct NonGenericWithDrop(i32);\n-//~ TRANS_ITEM drop-glue generic_drop_glue::NonGenericWithDrop[0]\n-//~ TRANS_ITEM drop-glue-contents generic_drop_glue::NonGenericWithDrop[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue.cgu-0[Internal]\n \n impl Drop for NonGenericWithDrop {\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n@@ -55,13 +54,11 @@ impl Drop for NonGenericWithDrop {\n \n //~ TRANS_ITEM fn generic_drop_glue::main[0]\n fn main() {\n-    //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<i8, char>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::StructWithDrop[0]<i8, char>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n-    //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n@@ -70,19 +67,17 @@ fn main() {\n \n     // This is supposed to generate drop-glue because it contains a field that\n     // needs to be dropped.\n-    //~ TRANS_ITEM drop-glue generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue.cgu-0[Internal]\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n-    //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<i32, i64>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::EnumWithDrop[0]<i32, i64>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n-    //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<f64, f32>\n-    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::EnumWithDrop[0]<f64, f32>\n+    //~TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,\n@@ -99,5 +94,3 @@ fn main() {\n         EnumNoDrop::B(x) => x as f64\n     };\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "9c6bdb6624eaecf63c5208969f8a0a0cb007cf86", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -31,12 +31,13 @@ impl<T> Trait for Struct<T> {\n fn main() {\n     let s1 = Struct { _a: 0u32 };\n \n-    //~ TRANS_ITEM drop-glue i8\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable.cgu-0[Internal]\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;\n \n     let s1 = Struct { _a: 0u64 };\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable.cgu-0[Internal]\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n     //~ TRANS_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n     let _ = &s1 as &Trait;"}, {"sha": "75d842d3c0bfce21cd432b49e79e83457a1558a1", "filename": "src/test/codegen-units/item-collection/items-within-generic-items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fitems-within-generic-items.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -40,5 +40,3 @@ fn main() {\n     //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<i8>\n     let _ = generic_fn(0i8);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "5f70ff396ddd5f78e76220a227c81dca7d873b59", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -13,8 +13,7 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM drop-glue non_generic_drop_glue::StructWithDrop[0]\n-//~ TRANS_ITEM drop-glue-contents non_generic_drop_glue::StructWithDrop[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue.cgu-0[Internal]\n struct StructWithDrop {\n     x: i32\n }\n@@ -28,8 +27,7 @@ struct StructNoDrop {\n     x: i32\n }\n \n-//~ TRANS_ITEM drop-glue non_generic_drop_glue::EnumWithDrop[0]\n-//~ TRANS_ITEM drop-glue-contents non_generic_drop_glue::EnumWithDrop[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue.cgu-0[Internal]\n enum EnumWithDrop {\n     A(i32)\n }\n@@ -54,5 +52,3 @@ fn main() {\n         EnumNoDrop::A(x) => x\n     };\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "26f9eb11876cbe07a2d1757bbec58026a16c48c4", "filename": "src/test/codegen-units/item-collection/non-generic-functions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-functions.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -77,5 +77,3 @@ fn main() {\n     let x = Struct { _x: 0 };\n     x.bar();\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "05848a727e95101c160840d9e37c7adf3c01a548", "filename": "src/test/codegen-units/item-collection/overloaded-operators.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -68,5 +68,3 @@ impl Deref for Equatable {\n         &self.0\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "3c9dcf32e0c7806e07058b912de9950f8d1c897d", "filename": "src/test/codegen-units/item-collection/static-init.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -20,4 +20,3 @@ pub fn foo<T>() { }\n fn main() { }\n \n //~ TRANS_ITEM fn static_init::main[0]\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "89bc620b7c552933226c9ad28a060329aaa23fed", "filename": "src/test/codegen-units/item-collection/statics-and-consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatics-and-consts.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -60,5 +60,3 @@ fn main() {\n //~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[2]\n \n //~ TRANS_ITEM fn statics_and_consts::main[0]\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "e8a7d8f25b22ca9b89113f23242177102bebbacb", "filename": "src/test/codegen-units/item-collection/trait-implementations.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-implementations.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -78,5 +78,3 @@ fn main() {\n    //~ TRANS_ITEM fn trait_implementations::{{impl}}[3]::bar[0]<&str, &str>\n    0f32.bar(\"&str\", \"&str\");\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "f095b637a84e47df7a727fe67f64267920c4e079", "filename": "src/test/codegen-units/item-collection/trait-method-as-argument.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-as-argument.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -64,5 +64,3 @@ fn main() {\n     //~ TRANS_ITEM fn core::ops[0]::FnMut[0]::call_mut[0]<fn(u32) -> u32, (u32)>\n     take_foo_mut(Trait::foo, 'c');\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "5b24a219f354bb140d62777f80143d726deedbfb", "filename": "src/test/codegen-units/item-collection/trait-method-default-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -66,5 +66,3 @@ fn main() {\n     //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i16, ()>\n     0u32.bar(0i16, ());\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "e41cb34eec6abfd8dcfaff686d2c0474bfa094db", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -13,12 +13,11 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue.cgu-0[Internal]\n struct Root(Intermediate);\n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Intermediate[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue.cgu-0[Internal]\n struct Intermediate(Leaf);\n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Leaf[0]\n-//~ TRANS_ITEM drop-glue-contents transitive_drop_glue::Leaf[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue.cgu-0[Internal]\n struct Leaf;\n \n impl Drop for Leaf {\n@@ -39,17 +38,15 @@ fn main() {\n \n     let _ = Root(Intermediate(Leaf));\n \n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<u32>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<u32>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<u32>\n-    //~ TRANS_ITEM drop-glue-contents transitive_drop_glue::LeafGen[0]<u32>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<i16>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<i16>\n-    //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<i16>\n-    //~ TRANS_ITEM drop-glue-contents transitive_drop_glue::LeafGen[0]<i16>\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue.cgu-0[Internal]\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n }"}, {"sha": "39043cf87cbecd7bd838ba8e71df4e0e785f8acf", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -13,8 +13,7 @@\n \n #![deny(dead_code)]\n \n-//~ TRANS_ITEM drop-glue tuple_drop_glue::Dropped[0]\n-//~ TRANS_ITEM drop-glue-contents tuple_drop_glue::Dropped[0]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue.cgu-0[Internal]\n struct Dropped;\n \n impl Drop for Dropped {\n@@ -24,10 +23,10 @@ impl Drop for Dropped {\n \n //~ TRANS_ITEM fn tuple_drop_glue::main[0]\n fn main() {\n-    //~ TRANS_ITEM drop-glue (u32, tuple_drop_glue::Dropped[0])\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue.cgu-0[Internal]\n     let x = (0u32, Dropped);\n \n-    //~ TRANS_ITEM drop-glue (i16, (tuple_drop_glue::Dropped[0], bool))\n-    //~ TRANS_ITEM drop-glue (tuple_drop_glue::Dropped[0], bool)\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue.cgu-0[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue.cgu-0[Internal]\n     let x = (0i16, (Dropped, true));\n }"}, {"sha": "de7613741b27bfd2610dbe87184d29195f47d3f4", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -57,11 +57,13 @@ fn main()\n {\n     // simple case\n     let bool_sized = &true;\n-    //~ TRANS_ITEM drop-glue i8\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n \n-    let char_sized = &true;\n+    let char_sized = &'a';\n+\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[1]::foo[0]\n     let _char_unsized = char_sized as &Trait;\n \n@@ -71,11 +73,13 @@ fn main()\n         _b: 2,\n         _c: 3.0f64\n     };\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[2]::foo[0]\n     let _struct_unsized = struct_sized as &Struct<Trait>;\n \n     // custom coercion\n     let wrapper_sized = Wrapper(&0u32);\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing.cgu-0[Internal]\n     //~ TRANS_ITEM fn unsizing::{{impl}}[3]::foo[0]\n     let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n }"}, {"sha": "ce85c4fc13ce2a753b38961b6a2dd22eedc9e430", "filename": "src/test/codegen-units/item-collection/unused-traits-and-generics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funused-traits-and-generics.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -86,4 +86,3 @@ impl NonGeneric {\n \n // Only the non-generic methods should be instantiated:\n //~ TRANS_ITEM fn unused_traits_and_generics::{{impl}}[3]::foo[0]\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "f28c4872111c990c3e89684c599b8d5d46f4ec09", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -20,15 +20,14 @@\n // aux-build:cgu_extern_drop_glue.rs\n extern crate cgu_extern_drop_glue;\n \n-//~ TRANS_ITEM drop-glue cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n-//~ TRANS_ITEM drop-glue-contents cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<cgu_extern_drop_glue::Struct[0]> @@ extern_drop_glue[Internal] extern_drop_glue-mod1[Internal]\n \n struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n //~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[External]\n fn user()\n {\n-    //~ TRANS_ITEM drop-glue extern_drop_glue::LocalStruct[0] @@ extern_drop_glue[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::LocalStruct[0]> @@ extern_drop_glue[Internal]\n     let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n }\n \n@@ -40,7 +39,7 @@ mod mod1 {\n     //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[External]\n     fn user()\n     {\n-        //~ TRANS_ITEM drop-glue extern_drop_glue::mod1[0]::LocalStruct[0] @@ extern_drop_glue-mod1[Internal]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<extern_drop_glue::mod1[0]::LocalStruct[0]> @@ extern_drop_glue-mod1[Internal]\n         let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n     }\n }"}, {"sha": "e32c946f8554f4ca5c6ac5c9d1b86235fd027267", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -60,5 +60,3 @@ mod mod3 {\n // once for the current crate\n //~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n //~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "64f4f854c2d7ffe00db0d576dd9495c6b8e2191e", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -16,8 +16,7 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM drop-glue local_drop_glue::Struct[0] @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n-//~ TRANS_ITEM drop-glue-contents local_drop_glue::Struct[0] @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Struct[0]> @@ local_drop_glue[Internal] local_drop_glue-mod1[Internal]\n struct Struct {\n     _a: u32\n }\n@@ -27,7 +26,7 @@ impl Drop for Struct {\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM drop-glue local_drop_glue::Outer[0] @@ local_drop_glue[Internal]\n+//~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::Outer[0]> @@ local_drop_glue[Internal]\n struct Outer {\n     _a: Struct\n }\n@@ -46,10 +45,10 @@ mod mod1\n {\n     use super::Struct;\n \n-    //~ TRANS_ITEM drop-glue local_drop_glue::mod1[0]::Struct2[0] @@ local_drop_glue-mod1[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<local_drop_glue::mod1[0]::Struct2[0]> @@ local_drop_glue-mod1[Internal]\n     struct Struct2 {\n         _a: Struct,\n-        //~ TRANS_ITEM drop-glue (u32, local_drop_glue::Struct[0]) @@ local_drop_glue-mod1[Internal]\n+        //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, local_drop_glue::Struct[0])> @@ local_drop_glue-mod1[Internal]\n         _b: (u32, Struct),\n     }\n "}, {"sha": "07c341203f9e206a0ef17098be4cd0abffcdbcde", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -80,5 +80,3 @@ mod mod2 {\n         static BAZ: u64 = 0;\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "d06b3ac407a7f4d2898d2d97cc006f0ced6bcb61", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -46,5 +46,3 @@ mod mod1 {\n         static BAR: u32 = 0;\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "c4594bb547ef54ba303b4777e85c1b80a4a0f430", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2c7917402ebd858f5b517a3406bec8ef187bfb1/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=f2c7917402ebd858f5b517a3406bec8ef187bfb1", "patch": "@@ -69,7 +69,7 @@ mod mod1 {\n \n //~ TRANS_ITEM fn vtable_through_const::main[0] @@ vtable_through_const[External]\n fn main() {\n-    //~ TRANS_ITEM drop-glue i8 @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ vtable_through_const[Internal]\n \n     // Since Trait1::do_something() is instantiated via its default implementation,\n     // it is considered a generic and is instantiated here only because it is"}]}