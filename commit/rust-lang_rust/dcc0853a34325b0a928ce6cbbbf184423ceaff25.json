{"sha": "dcc0853a34325b0a928ce6cbbbf184423ceaff25", "node_id": "C_kwDOAAsO6NoAKGRjYzA4NTNhMzQzMjViMGE5MjhjZTZjYmJiZjE4NDQyM2NlYWZmMjU", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-02-27T18:46:57Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-02-28T03:23:03Z"}, "message": "Add support for on_stack parameters", "tree": {"sha": "cafc1aa7cf622b015fff469afb23f571228ea281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cafc1aa7cf622b015fff469afb23f571228ea281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcc0853a34325b0a928ce6cbbbf184423ceaff25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc0853a34325b0a928ce6cbbbf184423ceaff25", "html_url": "https://github.com/rust-lang/rust/commit/dcc0853a34325b0a928ce6cbbbf184423ceaff25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcc0853a34325b0a928ce6cbbbf184423ceaff25/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a9ae8d4736ad5534b3daf7d56a18f6b51966cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9ae8d4736ad5534b3daf7d56a18f6b51966cd5", "html_url": "https://github.com/rust-lang/rust/commit/1a9ae8d4736ad5534b3daf7d56a18f6b51966cd5"}], "stats": {"total": 89, "additions": 61, "deletions": 28}, "files": [{"sha": "a1d9f2f5e3822a813641c02e93d869e4e028aa19", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcc0853a34325b0a928ce6cbbbf184423ceaff25/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dcc0853a34325b0a928ce6cbbbf184423ceaff25/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dcc0853a34325b0a928ce6cbbbf184423ceaff25", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#b9f188d2ce2c7b12211e90903f1b2cf309785b85\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#b9f188d2ce2c7b12211e90903f1b2cf309785b85\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "2c796d0f69e593f92efba98ff69cfd0299c1a698", "filename": "src/abi.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=dcc0853a34325b0a928ce6cbbbf184423ceaff25", "patch": "@@ -1,5 +1,6 @@\n-use gccjit::{ToRValue, Type};\n+use gccjit::{ToLValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{AbiBuilderMethods, BaseTypeMethods};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::bug;\n use rustc_middle::ty::Ty;\n use rustc_target::abi::call::{CastTarget, FnAbi, PassMode, Reg, RegKind};\n@@ -15,9 +16,21 @@ impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn get_param(&mut self, index: usize) -> Self::Value {\n-        self.cx.current_func.borrow().expect(\"current func\")\n-            .get_param(index as i32)\n-            .to_rvalue()\n+        let func = self.current_func();\n+        let param = func.get_param(index as i32);\n+        let on_stack =\n+            if let Some(on_stack_param_indices) = self.on_stack_function_params.borrow().get(&func) {\n+                on_stack_param_indices.contains(&index)\n+            }\n+            else {\n+                false\n+            };\n+        if on_stack {\n+            param.to_lvalue().get_address(None)\n+        }\n+        else {\n+            param.to_rvalue()\n+        }\n     }\n }\n \n@@ -87,12 +100,13 @@ impl GccType for Reg {\n \n pub trait FnAbiGccExt<'gcc, 'tcx> {\n     // TODO(antoyo): return a function pointer type instead?\n-    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool);\n+    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>);\n     fn ptr_to_gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n }\n \n impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n-    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool) {\n+    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>) {\n+        let mut on_stack_param_indices = FxHashSet::default();\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() {\n                 1\n@@ -144,17 +158,22 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     unimplemented!();\n                 }\n                 PassMode::Cast(cast) => cast.gcc_type(cx),\n-                PassMode::Indirect { extra_attrs: None, .. } => cx.type_ptr_to(arg.memory_ty(cx)),\n+                PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n+                    on_stack_param_indices.insert(argument_tys.len());\n+                    arg.memory_ty(cx)\n+                },\n+                PassMode::Indirect { extra_attrs: None, on_stack: false, .. } => cx.type_ptr_to(arg.memory_ty(cx)),\n             };\n             argument_tys.push(arg_ty);\n         }\n \n-        (return_ty, argument_tys, self.c_variadic)\n+        (return_ty, argument_tys, self.c_variadic, on_stack_param_indices)\n     }\n \n     fn ptr_to_gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        let (return_type, params, variadic) = self.gcc_type(cx);\n+        let (return_type, params, variadic, on_stack_param_indices) = self.gcc_type(cx);\n         let pointer_type = cx.context.new_function_pointer_type(None, return_type, &params, variadic);\n+        cx.on_stack_params.borrow_mut().insert(pointer_type.dyncast_function_ptr_type().expect(\"function ptr type\"), on_stack_param_indices);\n         pointer_type\n     }\n }"}, {"sha": "4aa9b5341fe66bce78f76987e1a39f9262a09100", "filename": "src/builder.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=dcc0853a34325b0a928ce6cbbbf184423ceaff25", "patch": "@@ -30,6 +30,7 @@ use rustc_codegen_ssa::traits::{\n     OverflowOp,\n     StaticBuilderMethods,\n };\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -207,6 +208,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             param_types.push(param);\n         }\n \n+        let mut on_stack_param_indices = FxHashSet::default();\n+        if let Some(indices) = self.on_stack_params.borrow().get(&gcc_func) {\n+            on_stack_param_indices = indices.clone();\n+        }\n+\n         if all_args_match {\n             return Cow::Borrowed(args);\n         }\n@@ -215,10 +221,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             .into_iter()\n             .zip(args.iter())\n             .enumerate()\n-            .map(|(_i, (expected_ty, &actual_val))| {\n+            .map(|(index, (expected_ty, &actual_val))| {\n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    self.bitcast(actual_val, expected_ty)\n+                    if on_stack_param_indices.contains(&index) {\n+                        actual_val.dereference(None).to_rvalue()\n+                    }\n+                    else {\n+                        self.bitcast(actual_val, expected_ty)\n+                    }\n                 }\n                 else {\n                     actual_val\n@@ -946,14 +957,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     /* Miscellaneous instructions */\n-    fn memcpy(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n-        if flags.contains(MemFlags::NONTEMPORAL) {\n-            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-            let val = self.load(src.get_type(), src, src_align);\n-            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n-            self.store_with_flags(val, ptr, dst_align, flags);\n-            return;\n-        }\n+    fn memcpy(&mut self, dst: RValue<'gcc>, _dst_align: Align, src: RValue<'gcc>, _src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n+        assert!(!flags.contains(MemFlags::NONTEMPORAL), \"non-temporal memcpy not supported\");\n         let size = self.intcast(size, self.type_size_t(), false);\n         let _is_volatile = flags.contains(MemFlags::VOLATILE);\n         let dst = self.pointercast(dst, self.type_i8p());"}, {"sha": "d411ccdb82122bcd76539c2e2ab2b61915634ef9", "filename": "src/context.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=dcc0853a34325b0a928ce6cbbbf184423ceaff25", "patch": "@@ -1,6 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n@@ -81,6 +81,12 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n+    // TODO(antoyo): improve the SSA API to not require those.\n+    // Mapping from function pointer type to indexes of on stack parameters.\n+    pub on_stack_params: RefCell<FxHashMap<FunctionPtrType<'gcc>, FxHashSet<usize>>>,\n+    // Mapping from function to indexes of on stack parameters.\n+    pub on_stack_function_params: RefCell<FxHashMap<Function<'gcc>, FxHashSet<usize>>>,\n+\n     /// Cache of emitted const globals (value -> global)\n     pub const_globals: RefCell<FxHashMap<RValue<'gcc>, RValue<'gcc>>>,\n     /// Map from the address of a global variable (rvalue) to the global variable itself (lvalue).\n@@ -208,6 +214,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             linkage: Cell::new(FunctionType::Internal),\n             instances: Default::default(),\n             function_instances: Default::default(),\n+            on_stack_params: Default::default(),\n+            on_stack_function_params: Default::default(),\n             vtables: Default::default(),\n             const_globals: Default::default(),\n             global_lvalues: Default::default(),"}, {"sha": "43017376916dca5e7f48aa94b4fd5c14f3f4a2d9", "filename": "src/declare.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=dcc0853a34325b0a928ce6cbbbf184423ceaff25", "patch": "@@ -80,8 +80,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n \n     pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n-        let (return_type, params, variadic) = fn_abi.gcc_type(self);\n+        let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n+        self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n         // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n         unsafe { std::mem::transmute(func) }\n     }"}, {"sha": "d4b1dd5ca16f88282795745420ad112ed01c88d5", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc0853a34325b0a928ce6cbbbf184423ceaff25/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=dcc0853a34325b0a928ce6cbbbf184423ceaff25", "patch": "@@ -464,17 +464,17 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             val.to_rvalue()\n         };\n         match self.mode {\n-            PassMode::Ignore => {}\n+            PassMode::Ignore => {},\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n-            }\n+            },\n             PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n-            }\n+            },\n             PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n                 let next_arg = next();\n-                self.store(bx, next_arg.to_rvalue(), dst);\n-            }\n+                self.store(bx, next_arg, dst);\n+            },\n         }\n     }\n }"}]}