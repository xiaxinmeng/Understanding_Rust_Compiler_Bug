{"sha": "f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxY2UyOTQ4ZGJhOWIzMTRiM2YwMjA1YTZlOWIxMjViZGYxODZiOGU=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-04T13:24:13Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-17T12:55:05Z"}, "message": "clippy: support `QPath::LangItem`\n\nThis commit updates clippy with the introduction of `QPath::LangItem` so\nthat it still compiles.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "fe2143aa15635f00e1fdc921c410a451da01a56b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2143aa15635f00e1fdc921c410a451da01a56b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl86fikACgkQJZLnbIc4\nH9nccBAApz/3ighSXP+Gcy2b8YT8ZJm02aX26Put4vws50LoNvdufj07OtfksPQ2\n3ls1U2j1RGXWxs7L70D+1etfi9YZY+NfJBCNvRF+lyYWb/WMIplhywkZeaU07/Kw\n7JFchqUo3dlJvx8tlm/3XJYIsOspDVFB/xd7n5Qzo7fJ6jGwa6udFODv25CcghBI\neMt2UpgBZ6JgyCgVR8BIMRB1H+DB1NBoJcJ8JaQgFc/Kqys8PrkksAA06VKmTXde\nJAhNE8Uy18E/KbGBwZFiSHJ099V0O3KYHb0OZykr+UgKqcOpbcPJmkgLMeaulVPa\nCMslc9hwnpH2oGGM+K0edFiSxpUs2HHTKOpHbswL55/Xf4kCS85RunZYK5MmBsV9\ndPUnGaWx7sSDbrq6/DbbKosUM0/kogqzG+CCHbc7I7NPoVzi1M4AmjV3YlCTlg0H\nOfR/pnbxJJw3mbf3p/u6q0ABuJab3QHF7EeTYuks1v7NZHVqnxjYyS1UIBxjgmoR\nkcDoD3HrPLmPrkzpFR28OEOajAoZG9Jyymz6TLOHYXDTQtoc9VJVTLvendkDXG0A\nk4wPCJu//LQhboCAskzWIHdwnUFoO62ATE1fNgXfUtfMLmNFFy1Bp+IQPbqjlq61\n6CKLpv2E+qTCj7WBa++E+PxW4rSwgaKqgbJX9LRLsCY+MGS2FWE=\n=tCC7\n-----END PGP SIGNATURE-----", "payload": "tree fe2143aa15635f00e1fdc921c410a451da01a56b\nparent dde93c9ba61e441bcafab84a1e42cddb32aa0178\nauthor David Wood <david@davidtw.co> 1596547453 +0100\ncommitter David Wood <david@davidtw.co> 1597668905 +0100\n\nclippy: support `QPath::LangItem`\n\nThis commit updates clippy with the introduction of `QPath::LangItem` so\nthat it still compiles.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "html_url": "https://github.com/rust-lang/rust/commit/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde93c9ba61e441bcafab84a1e42cddb32aa0178", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde93c9ba61e441bcafab84a1e42cddb32aa0178", "html_url": "https://github.com/rust-lang/rust/commit/dde93c9ba61e441bcafab84a1e42cddb32aa0178"}], "stats": {"total": 247, "additions": 117, "deletions": 130}, "files": [{"sha": "067ea903bdd96bf77f06820625449835d287f01d", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n                             );\n                          }\n                     },\n-                    QPath::TypeRelative(..) => {},\n+                    QPath::TypeRelative(..) | QPath::LangItem(..) => {},\n                 }\n             }\n         }"}, {"sha": "90b1a529be79dc310e7cd3a35f1129a944e5168e", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array);\n-            if let Some(range) = higher::range(cx, index) {\n+            if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {"}, {"sha": "129abd7d89749342e89da0f41d695ed2732fecbf", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -171,7 +171,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 Finite\n             }\n         },\n-        ExprKind::Struct(..) => higher::range(cx, expr).map_or(false, |r| r.end.is_none()).into(),\n+        ExprKind::Struct(..) => higher::range(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n }"}, {"sha": "e5daa30f8ca15745759706c41534552cb355d8d8", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -262,7 +262,7 @@ fn check_len(\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Special case ranges until `range_is_empty` is stabilized. See issue 3807.\n     fn should_skip_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-        higher::range(cx, expr).map_or(false, |_| {\n+        higher::range(expr).map_or(false, |_| {\n             !cx.tcx\n                 .features()\n                 .declared_lib_features"}, {"sha": "8ffcd417d1df1848e59a035a3480a28b907e38b6", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -1003,7 +1003,7 @@ fn detect_manual_memcpy<'tcx>(\n         start: Some(start),\n         end: Some(end),\n         limits,\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n@@ -1177,7 +1177,7 @@ fn check_for_loop_range<'tcx>(\n         start: Some(start),\n         ref end,\n         limits,\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n@@ -1679,7 +1679,7 @@ fn check_for_mut_range_bound(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'\n         start: Some(start),\n         end: Some(end),\n         ..\n-    }) = higher::range(cx, arg)\n+    }) = higher::range(arg)\n     {\n         let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {"}, {"sha": "faa20687ef61f3c938e7853f9783ced3c97552af", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -1,7 +1,8 @@\n-use crate::utils::{self, is_type_diagnostic_item, match_type, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{is_type_diagnostic_item, is_type_lang_item, snippet, span_lint_and_sugg};\n+use crate::utils::walk_ptrs_ty;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -96,5 +97,5 @@ fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n     let ty = walk_ptrs_ty(ty);\n-    match_type(cx, ty, &utils::paths::RANGE_FULL)\n+    is_type_lang_item(cx, ty, LangItem::RangeFull)\n }"}, {"sha": "2265a1888556af0ed9150af0ecb3e97c9a7f2f1b", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -2271,7 +2271,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         if_chain! {\n             if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n-                = higher::range(cx, index_expr);\n+                = higher::range(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {"}, {"sha": "482a563572db270fa63a436879cb4348a3a3f79f", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -433,6 +433,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             return;\n         }\n         let binding = match expr.kind {\n+            ExprKind::Path(hir::QPath::LangItem(..)) => None,\n             ExprKind::Path(ref qpath) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&"}, {"sha": "7a75fc125d0ad0eb42f3c4b8f5f154466eabf41d", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -147,7 +147,7 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n                     if let ExprKind::MethodCall(ref iter_path, _, ref iter_args , _) = *iter;\n                     if iter_path.ident.name == sym!(iter);\n                     // range expression in `.zip()` call: `0..x.len()`\n-                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n+                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n                     if is_integer_const(cx, start, 0);\n                     // `.len()` call\n                     if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n@@ -180,7 +180,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             start,\n             end: Some(end),\n             limits: RangeLimits::HalfOpen\n-        }) = higher::range(cx, expr);\n+        }) = higher::range(expr);\n         if let Some(y) = y_plus_one(cx, end);\n         then {\n             let span = if expr.span.from_expansion() {\n@@ -225,7 +225,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n // inclusive range minus one: `x..=(y-1)`\n fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n+        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr);\n         if let Some(y) = y_minus_one(cx, end);\n         then {\n             span_lint_and_then(\n@@ -279,7 +279,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n \n     if_chain! {\n-        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(cx, expr);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind;\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);"}, {"sha": "a74104e92820a3ca7288b008edebbd46848ab3ad", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{\n-    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet, snippet_with_macro_callsite,\n-    span_lint_and_sugg,\n+    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet,\n+    snippet_with_macro_callsite, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind, QPath, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let ExprKind::Match(ref match_arg, _, MatchSource::TryDesugar) = expr.kind;\n             if let ExprKind::Call(ref match_fun, ref try_args) = match_arg.kind;\n             if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n-            if match_qpath(match_fun_path, &paths::TRY_INTO_RESULT);\n+            if matches!(match_fun_path, QPath::LangItem(LangItem::TryIntoResult, _));\n             if let Some(ref try_arg) = try_args.get(0);\n             if let ExprKind::Call(ref err_fun, ref err_args) = try_arg.kind;\n             if let Some(ref err_arg) = err_args.get(0);"}, {"sha": "d1a7886a47effab9afb8831f6cd3c3c5e63e2b6d", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -475,6 +475,7 @@ impl Types {\n                             }\n                         }\n                     },\n+                    QPath::LangItem(..) => {},\n                 }\n             },\n             TyKind::Rptr(ref lt, ref mut_ty) => self.check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),"}, {"sha": "43166d26787a71258ab4c615e4d641f5b4ed50f1", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_try, match_qpath, match_trait_method, paths, span_lint};\n+use crate::utils::{is_try, match_trait_method, paths, span_lint};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -42,10 +42,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n         match expr.kind {\n             hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n                 if let hir::ExprKind::Call(ref func, ref args) = res.kind {\n-                    if let hir::ExprKind::Path(ref path) = func.kind {\n-                        if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n-                            check_method_call(cx, &args[0], expr);\n-                        }\n+                    if matches!(\n+                        func.kind,\n+                        hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::TryIntoResult, _))\n+                    ) {\n+                        check_method_call(cx, &args[0], expr);\n                     }\n                 } else {\n                     check_method_call(cx, res, expr);"}, {"sha": "9b7a268c6287c1fffd8b2fab131bb2d53bbeb175", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -175,9 +175,19 @@ impl PrintVisitor {\n     }\n \n     fn print_qpath(&mut self, path: &QPath<'_>) {\n-        print!(\"    if match_qpath({}, &[\", self.current);\n-        print_path(path, &mut true);\n-        println!(\"]);\");\n+        match  *path {\n+            QPath::LangItem(lang_item, _) => {\n+                println!(\n+                    \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n+                   self.current, lang_item,\n+                );\n+            },\n+            _ => {\n+                print!(\"    if match_qpath({}, &[\", self.current);\n+                print_path(path, &mut true);\n+                println!(\"]);\");\n+            },\n+        }\n     }\n }\n \n@@ -760,5 +770,6 @@ fn print_path(path: &QPath<'_>, first: &mut bool) {\n             },\n             ref other => print!(\"/* unimplemented: {:?}*/\", other),\n         },\n+        QPath::LangItem(..) => panic!(\"print_path: called for lang item qpath\"),\n     }\n }"}, {"sha": "ba15456014d35e730a7876b0077600ec59d13867", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 23, "deletions": 75, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -3,12 +3,11 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, match_qpath, paths};\n+use crate::utils::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -47,7 +46,7 @@ pub struct Range<'a> {\n }\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n+pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n     fn get_field<'c>(name: &str, fields: &'c [hir::Field<'_>]) -> Option<&'c hir::Expr<'c>> {\n@@ -56,94 +55,43 @@ pub fn range<'a, 'tcx>(cx: &LateContext<'tcx>, expr: &'a hir::Expr<'_>) -> Optio\n         Some(expr)\n     }\n \n-    let def_path = match cx.typeck_results().expr_ty(expr).kind {\n-        ty::Adt(def, _) => cx.tcx.def_path(def.did),\n-        _ => return None,\n-    };\n-\n-    // sanity checks for std::ops::RangeXXXX\n-    if def_path.data.len() != 3 {\n-        return None;\n-    }\n-    if def_path.data.get(0)?.data.as_symbol() != sym!(ops) {\n-        return None;\n-    }\n-    if def_path.data.get(1)?.data.as_symbol() != sym!(range) {\n-        return None;\n-    }\n-    let type_name = def_path.data.get(2)?.data.as_symbol();\n-    let range_types = [\n-        \"RangeFrom\",\n-        \"RangeFull\",\n-        \"RangeInclusive\",\n-        \"Range\",\n-        \"RangeTo\",\n-        \"RangeToInclusive\",\n-    ];\n-    if !range_types.contains(&&*type_name.as_str()) {\n-        return None;\n-    }\n-\n-    // The range syntax is expanded to literal paths starting with `core` or `std`\n-    // depending on\n-    // `#[no_std]`. Testing both instead of resolving the paths.\n-\n     match expr.kind {\n-        hir::ExprKind::Path(ref path) => {\n-            if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n-                Some(Range {\n+        hir::ExprKind::Call(ref path, ref args) if matches!(\n+            path.kind,\n+            hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+        ) => Some(Range {\n+            start: Some(&args[0]),\n+            end: Some(&args[1]),\n+            limits: ast::RangeLimits::Closed,\n+        }),\n+        hir::ExprKind::Struct(ref path, ref fields, None) => {\n+            match path {\n+                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n                     start: None,\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n-        },\n-        hir::ExprKind::Call(ref path, ref args) => {\n-            if let hir::ExprKind::Path(ref path) = path.kind {\n-                if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW)\n-                {\n-                    Some(Range {\n-                        start: Some(&args[0]),\n-                        end: Some(&args[1]),\n-                        limits: ast::RangeLimits::Closed,\n-                    })\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            }\n-        },\n-        hir::ExprKind::Struct(ref path, ref fields, None) => {\n-            if match_qpath(path, &paths::RANGE_FROM_STD) || match_qpath(path, &paths::RANGE_FROM) {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n                     start: Some(get_field(\"start\", fields)?),\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n                     start: Some(get_field(\"start\", fields)?),\n                     end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_TO_INCLUSIVE)\n-            {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n                     start: None,\n                     end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::Closed,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n-                Some(Range {\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n                     start: None,\n                     end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n+                }),\n+                _ => None,\n             }\n         },\n         _ => None,"}, {"sha": "2eefd4a38a67a5056981c2622deaebedc78cc348", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -3,9 +3,9 @@ use crate::utils::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FnRetTy, GenericArg,\n-    GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path, PathSegment, QPath,\n-    Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat,\n+    FnRetTy, GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName,\n+    Pat, PatKind, Path, PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n@@ -185,10 +185,20 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n+    pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n+        match (&left, &right) {\n+            (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) =>\n+                li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp),\n+        }\n+    }\n+\n     /// Checks whether two patterns are the same.\n     pub fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n+            (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n+                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_fieldpat(l, r))\n+            },\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n@@ -223,6 +233,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n                 self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n             },\n+            (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) =>\n+                llang_item == rlang_item,\n             _ => false,\n         }\n     }\n@@ -601,6 +613,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             QPath::TypeRelative(_, ref path) => {\n                 self.hash_name(path.ident.name);\n             },\n+            QPath::LangItem(lang_item, ..) => {\n+                lang_item.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            }\n         }\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n@@ -710,6 +725,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_ty(ty);\n                     segment.ident.name.hash(&mut self.s);\n                 },\n+                QPath::LangItem(lang_item, ..) => {\n+                    lang_item.hash(&mut self.s);\n+                }\n             },\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);"}, {"sha": "4701a3f26e6f7dbc58a18c436745b77e4acf2336", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -266,6 +266,9 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n+        hir::ExprKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n+            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n+        },\n         hir::ExprKind::AddrOf(kind, ref muta, ref e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"kind: {:?}\", kind);\n@@ -488,6 +491,9 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n+        hir::PatKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n+            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n+        },\n         hir::PatKind::Tuple(pats, opt_dots_position) => {\n             println!(\"{}Tuple\", ind);\n             if let Some(dot_position) = opt_dots_position {"}, {"sha": "a56b8203513e6d2c8945a5b520cb9093d4483b40", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -142,6 +142,14 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n     }\n }\n \n+/// Checks if the type is equal to a lang item\n+pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n+    match ty.kind {\n+        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n+        _ => false,\n+    }\n+}\n+\n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n@@ -163,13 +171,15 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n         QPath::TypeRelative(_, ref seg) => seg,\n+        QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n     }\n }\n \n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments.get(0),\n         QPath::TypeRelative(_, ref seg) => Some(seg),\n+        QPath::LangItem(..) => None,\n     }\n }\n \n@@ -196,6 +206,7 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n             },\n             _ => false,\n         },\n+        QPath::LangItem(..) => false,\n     }\n }\n \n@@ -277,7 +288,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n     match qpath {\n         hir::QPath::Resolved(_, path) => path.res,\n-        hir::QPath::TypeRelative(..) => {\n+        hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n             if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n                 cx.tcx.typeck(id.owner.to_def_id().expect_local()).qpath_res(qpath, id)\n             } else {"}, {"sha": "9c28d63d414c525b2ae5e3013be44ab07fef0255", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -84,19 +84,7 @@ pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n-pub const RANGE: [&str; 3] = [\"core\", \"ops\", \"Range\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n-pub const RANGE_FROM: [&str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FROM_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL: [&str; 4] = [\"core\", \"ops\", \"range\", \"RangeFull\"];\n-pub const RANGE_FULL_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n-pub const RANGE_INCLUSIVE_NEW: [&str; 4] = [\"core\", \"ops\", \"RangeInclusive\", \"new\"];\n-pub const RANGE_INCLUSIVE_STD_NEW: [&str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"new\"];\n-pub const RANGE_STD: [&str; 3] = [\"std\", \"ops\", \"Range\"];\n-pub const RANGE_TO: [&str; 3] = [\"core\", \"ops\", \"RangeTo\"];\n-pub const RANGE_TO_INCLUSIVE: [&str; 3] = [\"core\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO_INCLUSIVE_STD: [&str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n-pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n@@ -130,7 +118,6 @@ pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n-pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const TRY_INTO_TRAIT: [&str; 3] = [\"core\", \"convert\", \"TryInto\"];\n pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];"}, {"sha": "2955f8d8e591984dc4004595aeda7bff29d40a7d", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -42,7 +42,7 @@ impl<'a> Sugg<'a> {\n     pub fn hir_opt(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n-            Self::hir_from_snippet(cx, expr, snippet)\n+            Self::hir_from_snippet(expr, snippet)\n         })\n     }\n \n@@ -80,13 +80,13 @@ impl<'a> Sugg<'a> {\n     pub fn hir_with_macro_callsite(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n         let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n \n-        Self::hir_from_snippet(cx, expr, snippet)\n+        Self::hir_from_snippet(expr, snippet)\n     }\n \n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n-    fn hir_from_snippet(cx: &LateContext<'_>, expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n-        if let Some(range) = higher::range(cx, expr) {\n+    fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n+        if let Some(range) = higher::range(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,"}, {"sha": "3bf7607c62f0b27011f8a1cea0603089a6440f7c", "filename": "src/tools/clippy/tests/ui/author/for_loop.stdout", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f1ce2948dba9b314b3f0205a6e9b125bdf186b8e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=f1ce2948dba9b314b3f0205a6e9b125bdf186b8e", "patch": "@@ -3,10 +3,10 @@ if_chain! {\n     if let ExprKind::Match(ref expr1, ref arms, MatchSource::ForLoopDesugar) = expr.kind;\n     if let ExprKind::Call(ref func, ref args) = expr1.kind;\n     if let ExprKind::Path(ref path) = func.kind;\n-    if match_qpath(path, &[\"{{root}}\", \"std\", \"iter\", \"IntoIterator\", \"into_iter\"]);\n+    if matches!(path, QPath::LangItem(LangItem::IntoIterIntoIter, _));\n     if args.len() == 1;\n     if let ExprKind::Struct(ref path1, ref fields, None) = args[0].kind;\n-    if match_qpath(path1, &[\"{{root}}\", \"std\", \"ops\", \"Range\"]);\n+    if matches!(path1, QPath::LangItem(LangItem::Range, _));\n     if fields.len() == 2;\n     // unimplemented: field checks\n     if arms.len() == 1;\n@@ -20,7 +20,7 @@ if_chain! {\n     if let ExprKind::Match(ref expr2, ref arms1, MatchSource::ForLoopDesugar) = e.kind;\n     if let ExprKind::Call(ref func1, ref args1) = expr2.kind;\n     if let ExprKind::Path(ref path2) = func1.kind;\n-    if match_qpath(path2, &[\"{{root}}\", \"std\", \"iter\", \"Iterator\", \"next\"]);\n+    if matches!(path2, QPath::LangItem(LangItem::IteratorNext, _));\n     if args1.len() == 1;\n     if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, ref inner) = args1[0].kind;\n     if let ExprKind::Path(ref path3) = inner.kind;\n@@ -31,13 +31,15 @@ if_chain! {\n     if match_qpath(path4, &[\"__next\"]);\n     if let ExprKind::Path(ref path5) = value.kind;\n     if match_qpath(path5, &[\"val\"]);\n-    if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pat.kind;\n-    if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n+    if let PatKind::Struct(ref path6, ref fields1, false) = arms1[0].pat.kind;\n+    if matches!(path6, QPath::LangItem(LangItem::OptionSome, _));\n     if fields1.len() == 1;\n     // unimplemented: field checks\n     if let ExprKind::Break(ref destination, None) = arms1[1].body.kind;\n-    if let PatKind::Path(ref path7) = arms1[1].pat.kind;\n-    if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n+    if let PatKind::Struct(ref path7, ref fields2, false) = arms1[1].pat.kind;\n+    if matches!(path7, QPath::LangItem(LangItem::OptionNone, _));\n+    if fields2.len() == 0;\n+    // unimplemented: field checks\n     if let StmtKind::Local(ref local1) = body.stmts[2].kind;\n     if let Some(ref init) = local1.init;\n     if let ExprKind::Path(ref path8) = init.kind;"}]}