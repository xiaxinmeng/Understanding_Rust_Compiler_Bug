{"sha": "49f851c2c9e57465317938a0486495ef02ef5d81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Zjg1MWMyYzllNTc0NjUzMTc5MzhhMDQ4NjQ5NWVmMDJlZjVkODE=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-10-26T19:12:53Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-10-29T16:09:20Z"}, "message": "Fix type_of for enums to not lose data in some cases when immediate.\n\nThe previous implementation, when combined with small discriminants and\nimmediate types, caused problems for types like `Either<u8, i16>` which\nare now small enough to be immediate and can have fields intersecting\nthe highest-alignment variant's alignment padding (which LLVM doesn't\npreserve).  So let's not do that.", "tree": {"sha": "8aaf291b19ecf80fab4e0d769c5affd6882cb628", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aaf291b19ecf80fab4e0d769c5affd6882cb628"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49f851c2c9e57465317938a0486495ef02ef5d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49f851c2c9e57465317938a0486495ef02ef5d81", "html_url": "https://github.com/rust-lang/rust/commit/49f851c2c9e57465317938a0486495ef02ef5d81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49f851c2c9e57465317938a0486495ef02ef5d81/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac4644d7de7ec1528061dd4bb9639308c6018ee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4644d7de7ec1528061dd4bb9639308c6018ee6", "html_url": "https://github.com/rust-lang/rust/commit/ac4644d7de7ec1528061dd4bb9639308c6018ee6"}], "stats": {"total": 56, "additions": 32, "deletions": 24}, "files": [{"sha": "997bcbca9ce0b33b245b81d70f00589ae8c331a8", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/49f851c2c9e57465317938a0486495ef02ef5d81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f851c2c9e57465317938a0486495ef02ef5d81/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=49f851c2c9e57465317938a0486495ef02ef5d81", "patch": "@@ -382,30 +382,38 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n         CEnum(ity, _, _) => ~[ll_inttype(cx, ity)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n         NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n-        General(_ity, ref sts) => {\n-            // To get \"the\" type of a general enum, we pick the case\n-            // with the largest alignment (so it will always align\n-            // correctly in containing structures) and pad it out.\n-            assert!(sts.len() >= 1);\n-            let mut most_aligned = None;\n-            let mut largest_align = 0;\n-            let mut largest_size = 0;\n-            for st in sts.iter() {\n-                if largest_size < st.size {\n-                    largest_size = st.size;\n-                }\n-                if largest_align < st.align {\n-                    // Clang breaks ties by size; it is unclear if\n-                    // that accomplishes anything important.\n-                    largest_align = st.align;\n-                    most_aligned = Some(st);\n-                }\n-            }\n-            let most_aligned = most_aligned.unwrap();\n-            let padding = largest_size - most_aligned.size;\n-\n-            struct_llfields(cx, most_aligned, sizing)\n-                + &[Type::array(&Type::i8(), padding)]\n+        General(ity, ref sts) => {\n+            // We need a representation that has:\n+            // * The alignment of the most-aligned field\n+            // * The size of the largest variant (rounded up to that alignment)\n+            // * No alignment padding anywhere any variant has actual data\n+            //   (currently matters only for enums small enough to be immediate)\n+            // * The discriminant in an obvious place.\n+            //\n+            // So we start with the discriminant, pad it up to the alignment with\n+            // more of its own type, then use alignment-sized ints to get the rest\n+            // of the size.\n+            //\n+            // Note: if/when we start exposing SIMD vector types (or f80, on some\n+            // platforms that have it), this will need some adjustment.\n+            let size = sts.iter().map(|st| st.size).max().unwrap();\n+            let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n+            let align = most_aligned.align;\n+            let discr_ty = ll_inttype(cx, ity);\n+            let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n+            let pad_ty = match align {\n+                1 => Type::i8(),\n+                2 => Type::i16(),\n+                4 => Type::i32(),\n+                8 if machine::llalign_of_min(cx, Type::i64()) == 8 => Type::i64(),\n+                _ => fail!(\"Unsupported enum alignment: {:?}\", align)\n+            };\n+            assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n+            let align_units = (size + align - 1) / align;\n+            assert_eq!(align % discr_size, 0);\n+            ~[discr_ty,\n+              Type::array(&discr_ty, align / discr_size - 1),\n+              Type::array(&pad_ty, align_units - 1)]\n         }\n     }\n }"}]}