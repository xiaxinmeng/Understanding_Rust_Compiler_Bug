{"sha": "86d05655b48af5aa2bea7c0e191d0cbe22810e29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZDA1NjU1YjQ4YWY1YWEyYmVhN2MwZTE5MWQwY2JlMjI4MTBlMjk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-21T18:35:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T18:35:04Z"}, "message": "rustc: Merge in type serialization and deserialization\n\nSigned-off-by: Patrick Walton <pcwalton@mimiga.net>", "tree": {"sha": "1ac36ef007cb8fff509f84c1a73f53c069b59f91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ac36ef007cb8fff509f84c1a73f53c069b59f91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86d05655b48af5aa2bea7c0e191d0cbe22810e29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86d05655b48af5aa2bea7c0e191d0cbe22810e29", "html_url": "https://github.com/rust-lang/rust/commit/86d05655b48af5aa2bea7c0e191d0cbe22810e29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86d05655b48af5aa2bea7c0e191d0cbe22810e29/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a", "html_url": "https://github.com/rust-lang/rust/commit/0366f5ae23fa1268e95ffeff787c4eeb19d02a2a"}], "stats": {"total": 277, "additions": 277, "deletions": 0}, "files": [{"sha": "89a19fc237b2c9453b1e6a4c61f49adc8a06692f", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/86d05655b48af5aa2bea7c0e191d0cbe22810e29/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d05655b48af5aa2bea7c0e191d0cbe22810e29/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=86d05655b48af5aa2bea7c0e191d0cbe22810e29", "patch": "@@ -6,11 +6,14 @@ import lib.llvm.llvmext;\n import lib.llvm.mk_object_file;\n import lib.llvm.mk_section_iter;\n import middle.fold;\n+import middle.ty;\n import util.common;\n import util.common.span;\n \n import std._str;\n+import std._vec;\n import std.fs;\n+import std.option;\n import std.os;\n import std.map.hashmap;\n \n@@ -20,6 +23,174 @@ type env = @rec(\n     vec[str] library_search_paths\n );\n \n+// Type decoding\n+\n+// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// (The second has to be authed pure.) Extra parameters are for converting\n+// to/from def_ids in the string rep. Whatever format you choose should not\n+// contain pipe characters.\n+\n+// Callback to translate defs to strs or back.\n+type str_def = fn(str) -> ast.def_id;\n+\n+type pstate = rec(str rep, mutable uint pos, uint len);\n+\n+fn peek(@pstate st) -> char {\n+    if (st.pos < st.len) {ret st.rep.(st.pos) as char;}\n+    else {ret ' ';}\n+}\n+impure fn next(@pstate st) -> char { // ?? somehow not recognized as impure\n+    if (st.pos >= st.len) {fail;}\n+    auto ch = st.rep.(st.pos);\n+    st.pos = st.pos + 1u;\n+    ret ch as char;\n+}\n+\n+fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n+    auto len = _str.byte_len(rep);\n+    auto st = @rec(rep=rep, mutable pos=0u, len=len);\n+    auto result = parse_ty(st, sd);\n+    check(st.pos == len);\n+    ret result;\n+}\n+\n+impure fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n+    ret @rec(struct=parse_sty(st, sd),\n+             cname=option.none[str]);\n+}\n+\n+impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n+    alt (next(st)) {\n+        case ('n') {ret ty.ty_nil;}\n+        case ('b') {ret ty.ty_bool;}\n+        case ('i') {ret ty.ty_int;}\n+        case ('u') {ret ty.ty_uint;}\n+        case ('M') {\n+            alt (next(st)) {\n+                case ('b') {ret ty.ty_machine(common.ty_u8);}\n+                case ('w') {ret ty.ty_machine(common.ty_u16);}\n+                case ('l') {ret ty.ty_machine(common.ty_u32);}\n+                case ('d') {ret ty.ty_machine(common.ty_u64);}\n+                case ('B') {ret ty.ty_machine(common.ty_i8);}\n+                case ('W') {ret ty.ty_machine(common.ty_i16);}\n+                case ('L') {ret ty.ty_machine(common.ty_i32);}\n+                case ('D') {ret ty.ty_machine(common.ty_i64);}\n+                case ('f') {ret ty.ty_machine(common.ty_f32);}\n+                case ('F') {ret ty.ty_machine(common.ty_f64);}\n+            }\n+        }\n+        case ('c') {ret ty.ty_char;}\n+        case ('s') {ret ty.ty_str;}\n+        case ('t') {\n+            check(next(st) == '[');\n+            auto def = \"\";\n+            while (peek(st) != '|') {def += _str.from_char(next(st));}\n+            st.pos = st.pos + 1u;\n+            let vec[@ty.t] params = vec();\n+            while (peek(st) != ']') {\n+                params = _vec.push[@ty.t](params, parse_ty(st, sd));\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty.ty_tag(sd(def), params);\n+        }      \n+        case ('@') {ret ty.ty_box(parse_ty(st, sd));}\n+        case ('V') {ret ty.ty_vec(parse_ty(st, sd));}\n+        case ('P') {ret ty.ty_port(parse_ty(st, sd));}\n+        case ('C') {ret ty.ty_chan(parse_ty(st, sd));}\n+        case ('T') {\n+            check(next(st) == '[');\n+            let vec[@ty.t] params = vec();\n+            while (peek(st) != ']') {\n+                params = _vec.push[@ty.t](params, parse_ty(st, sd));\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty.ty_tup(params);\n+        }\n+        case ('R') {\n+            check(next(st) == '[');\n+            let vec[ty.field] fields = vec();\n+            while (peek(st) != ']') {\n+                auto name = \"\";\n+                while (peek(st) != '=') {name += _str.from_char(next(st));}\n+                st.pos = st.pos + 1u;\n+                fields = _vec.push[ty.field]\n+                    (fields, rec(ident=name, ty=parse_ty(st, sd)));\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty.ty_rec(fields);\n+        }\n+        case ('F') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty.ty_fn(ast.proto_fn, func._0, func._1);\n+        }\n+        case ('W') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty.ty_fn(ast.proto_iter, func._0, func._1);\n+        }\n+        case ('N') {\n+            auto abi;\n+            alt (next(st)) {\n+                case ('r') {abi = ast.native_abi_rust;}\n+                case ('c') {abi = ast.native_abi_cdecl;}\n+            }\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty.ty_native_fn(abi,func._0,func._1);\n+        }\n+        case ('O') {\n+            check(next(st) == '[');\n+            let vec[ty.method] methods = vec();\n+            while (peek(st) != ']') {\n+                auto proto;\n+                alt (next(st)) {\n+                    case ('W') {proto = ast.proto_iter;}\n+                    case ('F') {proto = ast.proto_fn;}\n+                }\n+                auto name = \"\";\n+                while (peek(st) != '[') {name += _str.from_char(next(st));}\n+                auto func = parse_ty_fn(st, sd);\n+                methods = _vec.push[ty.method]\n+                    (methods, rec(proto=proto,\n+                                  ident=name,\n+                                  inputs=func._0,\n+                                  output=func._1));\n+            }\n+            ret ty.ty_obj(methods);\n+        }\n+        case ('X') {ret ty.ty_var(parse_int(st));}\n+        case ('E') {ret ty.ty_native;}\n+    }\n+}\n+\n+impure fn parse_int(@pstate st) -> int {\n+    auto n = 0;\n+    while (true) {\n+        auto cur = peek(st);\n+        if (cur < '0' || cur > '9') {break;}\n+        st.pos = st.pos + 1u;\n+        n *= 10;\n+        n += (cur as int) - ('0' as int);\n+    }\n+    ret n;\n+}\n+\n+impure fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n+    check(next(st) == '[');\n+    let vec[ty.arg] inputs = vec();\n+    while (peek(st) != ']') {\n+        auto mode = ast.val;\n+        if (peek(st) == '&') {\n+            mode = ast.alias;\n+            st.pos = st.pos + 1u;\n+        }\n+        inputs = _vec.push[ty.arg]\n+            (inputs, rec(mode=mode, ty=parse_ty(st, sd)));\n+    }\n+    st.pos = st.pos + 1u;\n+    ret tup(inputs, parse_ty(st, sd));\n+}\n+\n+\n+\n // TODO: return something\n fn load_crate(ast.ident ident, vec[str] library_search_paths) -> @() {\n     for (str library_search_path in library_search_paths) {"}, {"sha": "bff0ac94e19c7c1ae1f2c8eff21859ddd2dec9bb", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/86d05655b48af5aa2bea7c0e191d0cbe22810e29/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d05655b48af5aa2bea7c0e191d0cbe22810e29/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=86d05655b48af5aa2bea7c0e191d0cbe22810e29", "patch": "@@ -1,12 +1,118 @@\n import std._str;\n+import std._vec;\n+import std.option;\n+\n import front.ast;\n import middle.trans;\n+import middle.ty;\n import back.x86;\n+import util.common;\n \n import lib.llvm.llvm;\n import lib.llvm.llvm.ValueRef;\n import lib.llvm.False;\n \n+// Type encoding\n+\n+// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// (The second has to be authed pure.) Extra parameters are for converting\n+// to/from def_ids in the string rep. Whatever format you choose should not\n+// contain pipe characters.\n+\n+// Callback to translate defs to strs or back.\n+type def_str = fn(ast.def_id) -> str;\n+\n+fn ty_str(@ty.t t, def_str ds) -> str {\n+    ret sty_str(t.struct, ds);\n+}\n+\n+fn sty_str(ty.sty st, def_str ds) -> str {\n+    alt (st) {\n+        case (ty.ty_nil) {ret \"n\";}\n+        case (ty.ty_bool) {ret \"b\";}\n+        case (ty.ty_int) {ret \"i\";}\n+        case (ty.ty_uint) {ret \"u\";}\n+        case (ty.ty_machine(?mach)) {\n+            alt (mach) {\n+                case (common.ty_u8) {ret \"Mb\";}\n+                case (common.ty_u16) {ret \"Mw\";}\n+                case (common.ty_u32) {ret \"Ml\";}\n+                case (common.ty_u64) {ret \"Md\";}\n+                case (common.ty_i8) {ret \"MB\";}\n+                case (common.ty_i16) {ret \"MW\";}\n+                case (common.ty_i32) {ret \"ML\";}\n+                case (common.ty_i64) {ret \"MD\";}\n+                case (common.ty_f32) {ret \"Mf\";}\n+                case (common.ty_f64) {ret \"MF\";}\n+            }\n+        }\n+        case (ty.ty_char) {ret \"c\";}\n+        case (ty.ty_str) {ret \"s\";}\n+        case (ty.ty_tag(?def,?tys)) { // TODO restore def_id\n+            auto acc = \"t[\" + ds(def) + \"|\";\n+            for (@ty.t t in tys) {acc += ty_str(t, ds);}\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_box(?t)) {ret \"@\" + ty_str(t, ds);}\n+        case (ty.ty_vec(?t)) {ret \"V\" + ty_str(t, ds);}\n+        case (ty.ty_port(?t)) {ret \"P\" + ty_str(t, ds);}\n+        case (ty.ty_chan(?t)) {ret \"C\" + ty_str(t, ds);}\n+        case (ty.ty_tup(?tys)) {\n+            auto acc = \"T[\";\n+            for (@ty.t t in tys) {acc += ty_str(t, ds);}\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_rec(?fields)) {\n+            auto acc = \"R[\";\n+            for (ty.field field in fields) {\n+                acc += field.ident + \"=\";\n+                acc += ty_str(field.ty, ds);\n+            }\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_fn(?proto,?args,?out)) {\n+            ret proto_str(proto) + ty_fn_str(args, out, ds);\n+        }\n+        case (ty.ty_native_fn(?abi,?args,?out)) {\n+            auto abistr;\n+            alt (abi) {\n+                case (ast.native_abi_rust) {abistr = \"r\";}\n+                case (ast.native_abi_cdecl) {abistr = \"c\";}\n+            }\n+            ret \"N\" + abistr + ty_fn_str(args, out, ds);\n+        }\n+        case (ty.ty_obj(?methods)) {\n+            auto acc = \"O[\";\n+            for (ty.method m in methods) {\n+                acc += proto_str(m.proto);\n+                acc += m.ident;\n+                acc += ty_fn_str(m.inputs, m.output, ds);\n+            }\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_var(?id)) {ret \"X\" + common.istr(id);}\n+        case (ty.ty_native) {ret \"E\";}\n+        // TODO (maybe?)   ty_param(ast.def_id), ty_type;\n+    }\n+}\n+\n+fn proto_str(ast.proto proto) -> str {\n+    alt (proto) {\n+        case (ast.proto_iter) {ret \"W\";}\n+        case (ast.proto_fn) {ret \"F\";}\n+    }\n+}\n+\n+fn ty_fn_str(vec[ty.arg] args, @ty.t out, def_str ds) -> str {\n+    auto acc = \"[\";\n+    for (ty.arg arg in args) {\n+        if (arg.mode == ast.alias) {acc += \"&\";}\n+        acc += ty_str(arg.ty, ds);\n+    }\n+    ret acc + \"]\" + ty_str(out, ds);\n+}\n+\n+\n // Returns a Plain Old LLVM String.\n fn C_postr(str s) -> ValueRef {\n     ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);"}]}