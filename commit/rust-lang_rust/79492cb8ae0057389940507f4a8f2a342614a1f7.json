{"sha": "79492cb8ae0057389940507f4a8f2a342614a1f7", "node_id": "C_kwDOAAsO6NoAKDc5NDkyY2I4YWUwMDU3Mzg5OTQwNTA3ZjRhOGYyYTM0MjYxNGExZjc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-10T15:08:47Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-10T15:08:47Z"}, "message": "internal: Revert castable expectation and simplify", "tree": {"sha": "e7d8303c7b8863040d538275dd74a716e103cd93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d8303c7b8863040d538275dd74a716e103cd93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79492cb8ae0057389940507f4a8f2a342614a1f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79492cb8ae0057389940507f4a8f2a342614a1f7", "html_url": "https://github.com/rust-lang/rust/commit/79492cb8ae0057389940507f4a8f2a342614a1f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79492cb8ae0057389940507f4a8f2a342614a1f7/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f5deb4ff2e38896599866b1a33e1fffb0b7304a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5deb4ff2e38896599866b1a33e1fffb0b7304a", "html_url": "https://github.com/rust-lang/rust/commit/8f5deb4ff2e38896599866b1a33e1fffb0b7304a"}], "stats": {"total": 119, "additions": 88, "deletions": 31}, "files": [{"sha": "767afdf9eb4e835b29e09cc0ce888d6a8f4953ba", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=79492cb8ae0057389940507f4a8f2a342614a1f7", "patch": "@@ -219,6 +219,7 @@ struct InternedStandardTypes {\n     unknown: Ty,\n     bool_: Ty,\n     unit: Ty,\n+    never: Ty,\n }\n \n impl Default for InternedStandardTypes {\n@@ -227,6 +228,7 @@ impl Default for InternedStandardTypes {\n             unknown: TyKind::Error.intern(Interner),\n             bool_: TyKind::Scalar(Scalar::Bool).intern(Interner),\n             unit: TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner),\n+            never: TyKind::Never.intern(Interner),\n         }\n     }\n }\n@@ -1024,6 +1026,7 @@ impl<'a> InferenceContext<'a> {\n pub(crate) enum Expectation {\n     None,\n     HasType(Ty),\n+    #[allow(dead_code)]\n     Castable(Ty),\n     RValueLikeUnsized(Ty),\n }\n@@ -1102,6 +1105,10 @@ impl Expectation {\n         }\n     }\n \n+    fn coercion_target_type(&self, table: &mut unify::InferenceTable<'_>) -> Ty {\n+        self.only_has_type(table).unwrap_or_else(|| table.new_type_var())\n+    }\n+\n     /// Comment copied from rustc:\n     /// Disregard \"castable to\" expectations because they\n     /// can lead us astray. Consider for example `if cond"}, {"sha": "7aa2176d67421c21357a6c72195afd35bf6c6777", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=79492cb8ae0057389940507f4a8f2a342614a1f7", "patch": "@@ -51,7 +51,7 @@ impl InferenceContext<'_> {\n                 .map(to_chalk_trait_id)\n                 .collect();\n \n-        let self_ty = TyKind::Error.intern(Interner);\n+        let self_ty = self.result.standard_types.unknown.clone();\n         let bounds = dyn_ty.bounds.clone().substitute(Interner, &[self_ty.cast(Interner)]);\n         for bound in bounds.iter(Interner) {\n             // NOTE(skip_binders): the extracted types are rebound by the returned `FnPointer`"}, {"sha": "9f97261486be1d02b3d5e1f726bbd68c6bf4ce35", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=79492cb8ae0057389940507f4a8f2a342614a1f7", "patch": "@@ -87,16 +87,15 @@ impl<'a> InferenceContext<'a> {\n                 let expected = &expected.adjust_for_branches(&mut self.table);\n                 self.infer_expr(\n                     condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                    &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n \n-                let result_ty = self.table.new_type_var();\n                 let then_ty = self.infer_expr_inner(then_branch, expected);\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n-                let mut coerce = CoerceMany::new(result_ty);\n+                let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n                 coerce.coerce(self, Some(then_branch), &then_ty);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n@@ -113,7 +112,7 @@ impl<'a> InferenceContext<'a> {\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n                 self.infer_pat(pat, &input_ty, BindingMode::default());\n-                TyKind::Scalar(Scalar::Bool).intern(Interner)\n+                self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n                 let old_resolver = mem::replace(\n@@ -188,27 +187,29 @@ impl<'a> InferenceContext<'a> {\n                     .intern(Interner)\n             }\n             &Expr::Loop { body, label } => {\n+                // FIXME: should be:\n+                // let ty = expected.coercion_target_type(&mut self.table);\n                 let ty = self.table.new_type_var();\n                 let (breaks, ()) =\n                     self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n-                        this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                        this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                     });\n \n                 match breaks {\n                     Some(breaks) => {\n                         self.diverges = Diverges::Maybe;\n                         breaks\n                     }\n-                    None => TyKind::Never.intern(Interner),\n+                    None => self.result.standard_types.never.clone(),\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(\n                         condition,\n-                        &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                        &Expectation::HasType(this.result.standard_types.bool_.clone()),\n                     );\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -224,7 +225,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -382,12 +383,9 @@ impl<'a> InferenceContext<'a> {\n                 let expected = expected.adjust_for_branches(&mut self.table);\n \n                 let result_ty = if arms.is_empty() {\n-                    TyKind::Never.intern(Interner)\n+                    self.result.standard_types.never.clone()\n                 } else {\n-                    match &expected {\n-                        Expectation::HasType(ty) => ty.clone(),\n-                        _ => self.table.new_type_var(),\n-                    }\n+                    expected.coercion_target_type(&mut self.table)\n                 };\n                 let mut coerce = CoerceMany::new(result_ty);\n \n@@ -400,7 +398,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                            &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                         );\n                     }\n \n@@ -425,7 +423,7 @@ impl<'a> InferenceContext<'a> {\n                         is_break: false,\n                     });\n                 };\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n@@ -439,7 +437,7 @@ impl<'a> InferenceContext<'a> {\n                         // avoiding the borrowck\n                         let mut coerce = mem::replace(\n                             &mut ctxt.coerce,\n-                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                            CoerceMany::new(expected.coercion_target_type(&mut self.table)),\n                         );\n \n                         // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n@@ -457,7 +455,7 @@ impl<'a> InferenceContext<'a> {\n                         });\n                     }\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -466,7 +464,7 @@ impl<'a> InferenceContext<'a> {\n                     let unit = TyBuilder::unit();\n                     let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n@@ -479,14 +477,14 @@ impl<'a> InferenceContext<'a> {\n                     resume_ty\n                 } else {\n                     // FIXME: report error (yield expr in non-generator)\n-                    TyKind::Error.intern(Interner)\n+                    self.result.standard_types.unknown.clone()\n                 }\n             }\n             Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n                     self.infer_expr_inner(expr, &Expectation::None);\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n@@ -611,8 +609,8 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n-                let _inner_ty =\n-                    self.infer_expr_inner(*expr, &Expectation::Castable(cast_ty.clone()));\n+                // FIXME: propagate the \"castable to\" expectation\n+                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::None);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n@@ -829,7 +827,7 @@ impl<'a> InferenceContext<'a> {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n                         self.infer_expr(\n                             repeat,\n-                            &Expectation::has_type(\n+                            &Expectation::HasType(\n                                 TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n                             ),\n                         );\n@@ -852,7 +850,7 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Array(coerce.complete(), len).intern(Interner)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n+                Literal::Bool(..) => self.result.standard_types.bool_.clone(),\n                 Literal::String(..) => {\n                     TyKind::Ref(Mutability::Not, static_lifetime(), TyKind::Str.intern(Interner))\n                         .intern(Interner)\n@@ -1148,7 +1146,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(expr) = else_branch {\n                         self.infer_expr_coerce(\n                             *expr,\n-                            &Expectation::has_type(Ty::new(Interner, TyKind::Never)),\n+                            &Expectation::HasType(self.result.standard_types.never.clone()),\n                         );\n                     }\n "}, {"sha": "0a8527afbd0430bf0baa9c4431594cf9b9f20d07", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=79492cb8ae0057389940507f4a8f2a342614a1f7", "patch": "@@ -112,7 +112,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n-                    ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n+                    ParamKind::Type => self.result.standard_types.unknown.clone().cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })"}, {"sha": "2e5787b701cae3e29023c779dc02e33868fd3ef3", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79492cb8ae0057389940507f4a8f2a342614a1f7/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=79492cb8ae0057389940507f4a8f2a342614a1f7", "patch": "@@ -3200,6 +3200,8 @@ fn func() {\n     \"#,\n     );\n }\n+\n+// FIXME\n #[test]\n fn castable_to() {\n     check_infer(\n@@ -3224,10 +3226,60 @@ fn func() {\n             120..122 '{}': ()\n             138..184 '{     ...0]>; }': ()\n             148..149 'x': Box<[i32; 0]>\n-            152..160 'Box::new': fn new<[i32; 0]>([i32; 0]) -> Box<[i32; 0]>\n-            152..164 'Box::new([])': Box<[i32; 0]>\n+            152..160 'Box::new': fn new<[{unknown}; 0]>([{unknown}; 0]) -> Box<[{unknown}; 0]>\n+            152..164 'Box::new([])': Box<[{unknown}; 0]>\n             152..181 'Box::n...2; 0]>': Box<[i32; 0]>\n-            161..163 '[]': [i32; 0]\n+            161..163 '[]': [{unknown}; 0]\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn castable_to1() {\n+    check_infer(\n+        r#\"\n+struct Ark<T>(T);\n+impl<T> Ark<T> {\n+    fn foo(&self) -> *const T {\n+        &self.0\n+    }\n+}\n+fn f<T>(t: Ark<T>) {\n+    Ark::foo(&t) as *const ();\n+}\n+\"#,\n+        expect![[r#\"\n+            47..51 'self': &Ark<T>\n+            65..88 '{     ...     }': *const T\n+            75..82 '&self.0': &T\n+            76..80 'self': &Ark<T>\n+            76..82 'self.0': T\n+            99..100 't': Ark<T>\n+            110..144 '{     ... (); }': ()\n+            116..124 'Ark::foo': fn foo<T>(&Ark<T>) -> *const T\n+            116..128 'Ark::foo(&t)': *const T\n+            116..141 'Ark::f...nst ()': *const ()\n+            125..127 '&t': &Ark<T>\n+            126..127 't': Ark<T>\n+        \"#]],\n+    );\n+}\n+\n+// FIXME\n+#[test]\n+fn castable_to2() {\n+    check_infer(\n+        r#\"\n+fn func() {\n+    let x = &0u32 as *const _;\n+}\n+\"#,\n+        expect![[r#\"\n+            10..44 '{     ...t _; }': ()\n+            20..21 'x': *const {unknown}\n+            24..29 '&0u32': &u32\n+            24..41 '&0u32 ...onst _': *const {unknown}\n+            25..29 '0u32': u32\n         \"#]],\n     );\n }"}]}