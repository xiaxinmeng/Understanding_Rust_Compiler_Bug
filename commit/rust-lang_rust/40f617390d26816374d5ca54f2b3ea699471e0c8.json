{"sha": "40f617390d26816374d5ca54f2b3ea699471e0c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZjYxNzM5MGQyNjgxNjM3NGQ1Y2E1NGYyYjNlYTY5OTQ3MWUwYzg=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-07-14T04:34:45Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-07-14T04:34:45Z"}, "message": "Main part of the type system rewrite:\nChange the type of all objects to be { {}*, {}* }.", "tree": {"sha": "7c2f7bdd797fa3a3c89ed655f89758afc6056530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c2f7bdd797fa3a3c89ed655f89758afc6056530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40f617390d26816374d5ca54f2b3ea699471e0c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40f617390d26816374d5ca54f2b3ea699471e0c8", "html_url": "https://github.com/rust-lang/rust/commit/40f617390d26816374d5ca54f2b3ea699471e0c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40f617390d26816374d5ca54f2b3ea699471e0c8/comments", "author": null, "committer": null, "parents": [{"sha": "8c94d8fd54ba864e6a603ba6d90d41ccfaa62f53", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c94d8fd54ba864e6a603ba6d90d41ccfaa62f53", "html_url": "https://github.com/rust-lang/rust/commit/8c94d8fd54ba864e6a603ba6d90d41ccfaa62f53"}], "stats": {"total": 162, "additions": 87, "deletions": 75}, "files": [{"sha": "e5ec3e7ed0c71b7cb7807453deadc5ed9fa63791", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 87, "deletions": 75, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/40f617390d26816374d5ca54f2b3ea699471e0c8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f617390d26816374d5ca54f2b3ea699471e0c8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=40f617390d26816374d5ca54f2b3ea699471e0c8", "patch": "@@ -159,7 +159,6 @@ type local_ctxt =\n \n // Types used for llself.\n type val_self_pair = rec(ValueRef v, ty::t t);\n-type ty_self_pair = tup(TypeRef, ty::t);\n \n \n // Function context.  Every LLVM function we create will have one of these.\n@@ -477,6 +476,13 @@ fn T_struct(&TypeRef[] elts) -> TypeRef {\n \n fn T_opaque() -> TypeRef { ret llvm::LLVMOpaqueType(); }\n \n+fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n+\n+fn T_rust_object() -> TypeRef {\n+   auto e = T_ptr(T_empty_struct());\n+   ret T_struct(~[e, e]);\n+}\n+\n fn T_task() -> TypeRef {\n     auto t =\n         T_struct(~[T_int(), // Refcount\n@@ -511,8 +517,8 @@ fn T_glue_fn(&crate_ctxt cx) -> TypeRef {\n     ret t;\n }\n \n-fn T_dtor(&@crate_ctxt ccx, &span sp, TypeRef llself_ty) -> TypeRef {\n-    ret type_of_fn_full(ccx, sp, ast::proto_fn, some[TypeRef](llself_ty),\n+fn T_dtor(&@crate_ctxt ccx, &span sp) -> TypeRef {\n+    ret type_of_fn_full(ccx, sp, ast::proto_fn, true,\n                         ~[], ty::mk_nil(ccx.tcx), 0u);\n }\n \n@@ -751,7 +757,7 @@ fn type_of_explicit_args(&@crate_ctxt cx, &span sp, &ty::arg[] inputs)\n //  - new_fn_ctxt\n //  - trans_args\n fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n-                   &option::t[TypeRef] obj_self, &ty::arg[] inputs,\n+                   bool is_method, &ty::arg[] inputs,\n                    &ty::t output, uint ty_param_count) -> TypeRef {\n     let TypeRef[] atys = ~[];\n \n@@ -766,13 +772,14 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n     atys += ~[T_taskptr(*cx)];\n \n     // Arg 2: Env (closure-bindings / self-obj)\n-    alt (obj_self) {\n-        case (some(?t)) { assert (t as int != 0); atys += ~[t]; }\n-        case (_) { atys += ~[T_opaque_closure_ptr(*cx)]; }\n+    if (is_method) {\n+        atys += ~[T_rust_object()];\n+    } else {\n+        atys += ~[T_opaque_closure_ptr(*cx)];\n     }\n \n     // Args >3: ty params, if not acquired via capture...\n-    if (obj_self == none[TypeRef]) {\n+    if (!is_method) {\n         auto i = 0u;\n         while (i < ty_param_count) {\n             atys += ~[T_ptr(cx.tydesc_type)];\n@@ -785,7 +792,7 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n         // argument.\n         atys +=\n             ~[T_fn_pair(*cx,\n-                        type_of_fn_full(cx, sp, ast::proto_fn, none[TypeRef],\n+                        type_of_fn_full(cx, sp, ast::proto_fn, false,\n                                         ~[rec(mode=ty::mo_alias(false),\n                                              ty=output)], ty::mk_nil(cx.tcx),\n                                         0u))];\n@@ -799,7 +806,7 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n fn type_of_fn(&@crate_ctxt cx, &span sp, ast::proto proto,\n               &ty::arg[] inputs, &ty::t output, uint ty_param_count) ->\n    TypeRef {\n-    ret type_of_fn_full(cx, sp, proto, none[TypeRef], inputs, output,\n+    ret type_of_fn_full(cx, sp, proto, false, inputs, output,\n                         ty_param_count);\n }\n \n@@ -894,22 +901,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = T_fn_pair(*cx, nft);\n         }\n         case (ty::ty_obj(?meths)) {\n-            auto th = mk_type_handle();\n-            auto self_ty = llvm::LLVMResolveTypeHandle(th.llth);\n-            let TypeRef[] mtys = ~[T_ptr(T_i8())];\n-            for (ty::method m in meths) {\n-                let TypeRef mty =\n-                    type_of_fn_full(cx, sp, m.proto, some[TypeRef](self_ty),\n-                                    m.inputs, m.output, 0u);\n-                mtys += ~[T_ptr(mty)];\n-            }\n-            let TypeRef vtbl = T_struct(mtys);\n-            let TypeRef pair =\n-                T_struct(~[T_ptr(vtbl), T_opaque_obj_ptr(*cx)]);\n-            auto abs_pair = llvm::LLVMResolveTypeHandle(th.llth);\n-            llvm::LLVMRefineType(abs_pair, pair);\n-            abs_pair = llvm::LLVMResolveTypeHandle(th.llth);\n-            llty = abs_pair;\n+            llty = T_rust_object();\n         }\n         case (ty::ty_res(_, ?sub, ?tps)) {\n             auto sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n@@ -2071,6 +2063,11 @@ fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             auto box_cell =\n                 cx.build.GEP(v0, ~[C_int(0), C_int(abi::obj_field_box)]);\n             auto b = cx.build.Load(box_cell);\n+\n+            auto ccx = cx.fcx.lcx.ccx;\n+            auto llbox_ty = T_opaque_obj_ptr(*ccx);\n+            b = cx.build.PointerCast(b, llbox_ty);\n+\n             auto body =\n                 cx.build.GEP(b, ~[C_int(0), C_int(abi::box_rc_field_body)]);\n             auto tydescptr =\n@@ -2245,11 +2242,14 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n \n fn decr_refcnt_maybe_free(&@block_ctxt cx, ValueRef box_ptr_alias,\n                           ValueRef full_alias, &ty::t t) -> result {\n+    auto ccx = cx.fcx.lcx.ccx;\n     auto load_rc_cx = new_sub_block_ctxt(cx, \"load rc\");\n     auto rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n     auto free_cx = new_sub_block_ctxt(cx, \"free\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     auto box_ptr = cx.build.Load(box_ptr_alias);\n+    auto llbox_ty = T_opaque_obj_ptr(*ccx);\n+    box_ptr = cx.build.PointerCast(box_ptr, llbox_ty);\n     auto null_test = cx.build.IsNull(box_ptr);\n     cx.build.CondBr(null_test, next_cx.llbb, load_rc_cx.llbb);\n     auto rc_ptr =\n@@ -3102,12 +3102,14 @@ fn call_tydesc_glue(&@block_ctxt cx, ValueRef v, &ty::t t, int field) ->\n fn maybe_call_dtor(&@block_ctxt cx, ValueRef v) -> @block_ctxt {\n     auto vtbl = cx.build.GEP(v, ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n     vtbl = cx.build.Load(vtbl);\n+    auto vtbl_type = T_ptr(T_array(T_ptr(T_nil()), 1u));\n+    vtbl = cx.build.PointerCast(vtbl, vtbl_type);\n+\n     auto dtor_ptr = cx.build.GEP(vtbl, ~[C_int(0), C_int(0)]);\n     dtor_ptr = cx.build.Load(dtor_ptr);\n-    auto self_t = llvm::LLVMGetElementType(val_ty(v));\n     dtor_ptr =\n         cx.build.BitCast(dtor_ptr,\n-                         T_ptr(T_dtor(cx.fcx.lcx.ccx, cx.sp, self_t)));\n+                         T_ptr(T_dtor(cx.fcx.lcx.ccx, cx.sp)));\n     auto dtor_cx = new_sub_block_ctxt(cx, \"dtor\");\n     auto after_cx = new_sub_block_ctxt(cx, \"after_dtor\");\n     auto test =\n@@ -4660,7 +4662,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n     auto iter_body_llty =\n-        type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn, none[TypeRef],\n+        type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn, false,\n                         ~[rec(mode=ty::mo_alias(false), ty=decl_ty)],\n                         ty::mk_nil(lcx.ccx.tcx), 0u);\n     let ValueRef lliterbody =\n@@ -4932,12 +4934,23 @@ fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n                                 ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n             vtbl = r.bcx.build.Load(vtbl);\n \n+            auto vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 2u));\n+            vtbl = cx.build.PointerCast(vtbl, vtbl_type);\n+\n             // +1 because slot #0 contains the destructor\n             auto v = r.bcx.build.GEP(vtbl,\n                                      ~[C_int(0), C_int(ix + 1u as int)]);\n-            auto lvo = lval_mem(r.bcx, v);\n             let ty::t fn_ty =\n                 ty::method_ty_to_fn_ty(cx.fcx.lcx.ccx.tcx, methods.(ix));\n+            auto tcx = cx.fcx.lcx.ccx.tcx;\n+            auto ll_fn_ty = type_of_fn_full(cx.fcx.lcx.ccx, sp,\n+                                            ty::ty_fn_proto(tcx, fn_ty),\n+                                            true,\n+                                            ty::ty_fn_args(tcx, fn_ty),\n+                                            ty::ty_fn_ret(tcx, fn_ty),\n+                                            0u);\n+            v = r.bcx.build.PointerCast(v, T_ptr(T_ptr(ll_fn_ty)));\n+            auto lvo = lval_mem(r.bcx, v);\n             ret rec(llobj=some[ValueRef](r.val), method_ty=some[ty::t](fn_ty)\n                     with lvo);\n         }\n@@ -6046,7 +6059,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             let TypeRef llfnty =\n                 alt (ty::struct(ccx.tcx, node_id_type(ccx, e.id))) {\n                     case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n-                        type_of_fn_full(ccx, e.span, proto, none, inputs,\n+                        type_of_fn_full(ccx, e.span, proto, false, inputs,\n                                         output, 0u)\n                     }\n                 };\n@@ -6892,7 +6905,6 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // Get the type of the eventual entire anonymous object, possibly with\n     // extensions.  NB: This type includes both inner and outer methods.\n     auto outer_obj_ty = ty::node_id_to_type(ccx.tcx, id);\n-    auto llouter_obj_ty = type_of(ccx, sp, outer_obj_ty);\n \n     // Create a vtable for the anonymous object.\n \n@@ -6925,7 +6937,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // create_vtbl() with no \"additional methods\".  What's happening\n             // is that, since *all* of the methods are \"additional\", we can\n             // get away with acting like none of them are.\n-            vtbl = create_vtbl(bcx.fcx.lcx, sp, llouter_obj_ty, outer_obj_ty,\n+            vtbl = create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty,\n                                wrapper_obj, ty_params, none,\n                                additional_field_tys);\n         }\n@@ -6943,19 +6955,15 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // one with a matching name and type being added, we'll need to\n             // create a forwarding slot.  And, of course, we need to create a\n             // normal vtable entry for every method being added.\n-            vtbl = create_vtbl(bcx.fcx.lcx, sp, llouter_obj_ty, outer_obj_ty,\n+            vtbl = create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty,\n                                wrapper_obj, ty_params,\n                                some(with_obj_ty),\n                                additional_field_tys);\n         }\n     }\n \n-    // Allocate the object that we're going to return.  It's a two-word pair\n-    // containing a vtable pointer and a body pointer.\n-    auto pair =\n-        alloca(bcx,\n-               T_struct(~[val_ty(vtbl),\n-                          T_obj_ptr(*ccx, std::ivec::len(ty_params))]));\n+    // Allocate the object that we're going to return.\n+    auto pair = alloca(bcx, T_rust_object());\n \n     // Take care of cleanups.\n     auto t = node_id_type(ccx, id);\n@@ -6969,12 +6977,13 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     auto pair_box =\n         bcx.build.GEP(pair, ~[C_int(0), C_int(abi::obj_field_box)]);\n \n+    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n     bcx.build.Store(vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, fields, and a pointer to our with_obj.\n-    let TypeRef llbox_ty = T_opaque_obj_ptr(*ccx);\n+    let TypeRef llbox_ty = T_ptr(T_empty_struct());\n \n     if (std::ivec::len[ast::ty_param](ty_params) == 0u &&\n         std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n@@ -7115,7 +7124,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     }\n \n     // Cast the final object to how we want its type to appear.\n-    pair = bcx.build.PointerCast(pair, T_ptr(llouter_obj_ty));\n+    pair = bcx.build.PointerCast(pair, T_ptr(T_rust_object()));\n \n     // Return the object we built.\n     ret rslt(bcx, pair);\n@@ -7493,7 +7502,7 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp, ValueRef llfndecl) -> @fn_ctxt {\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(&@fn_ctxt cx, ast::proto proto,\n-                             option::t[ty_self_pair] ty_self, ty::t ret_ty,\n+                             option::t[ty::t] ty_self, ty::t ret_ty,\n                              &ast::arg[] args,\n                              &ast::ty_param[] ty_params) {\n     // Skip the implicit arguments 0, 1, and 2.  TODO: Pull out 3u and define\n@@ -7503,7 +7512,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx, ast::proto proto,\n     auto arg_n = 3u;\n     alt (ty_self) {\n         case (some(?tt)) {\n-            cx.llself = some[val_self_pair](rec(v=cx.llenv, t=tt._1));\n+            cx.llself = some[val_self_pair](rec(v=cx.llenv, t=tt));\n         }\n         case (none) {\n             auto i = 0u;\n@@ -7541,17 +7550,13 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx, ast::proto proto,\n // Recommended LLVM style, strange though this is, is to copy from args to\n // allocas immediately upon entry; this permits us to GEP into structures we\n // were passed and whatnot. Apparently mem2reg will mop up.\n-fn copy_any_self_to_alloca(@fn_ctxt fcx, option::t[ty_self_pair] ty_self) {\n+fn copy_any_self_to_alloca(@fn_ctxt fcx) {\n     auto bcx = llstaticallocas_block_ctxt(fcx);\n     alt ({ fcx.llself }) {\n         case (some(?pair)) {\n-            alt (ty_self) {\n-                case (some[ty_self_pair](?tt)) {\n-                    auto a = alloca(bcx, tt._0);\n-                    bcx.build.Store(pair.v, a);\n-                    fcx.llself = some[val_self_pair](rec(v=a, t=pair.t));\n-                }\n-            }\n+            auto a = alloca(bcx, T_rust_object());\n+            bcx.build.Store(pair.v, a);\n+            fcx.llself = some[val_self_pair](rec(v=a, t=pair.t));\n         }\n         case (_) { }\n     }\n@@ -7673,7 +7678,7 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n-            option::t[ty_self_pair] ty_self, &ast::ty_param[] ty_params,\n+            option::t[ty::t] ty_self, &ast::ty_param[] ty_params,\n             ast::node_id id) {\n     set_uwtable(llfndecl);\n \n@@ -7682,7 +7687,7 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n     create_llargs_for_fn_args(fcx, f.proto, ty_self,\n                               ty::ret_ty_of_fn(cx.ccx.tcx, id),\n                               f.decl.inputs, ty_params);\n-    copy_any_self_to_alloca(fcx, ty_self);\n+    copy_any_self_to_alloca(fcx);\n     alt ({ fcx.llself }) {\n         case (some(?llself)) { populate_fn_ctxt_from_llself(fcx, llself); }\n         case (_) { }\n@@ -7720,7 +7725,7 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n // vtable slot for method calls that \"fall through\" to an inner object.  A\n // helper function for create_vtbl.\n fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n-                       TypeRef llself_ty, ty::t self_ty,\n+                       ty::t self_ty,\n                        &ast::ty_param[] ty_params,\n                        ty::t with_obj_ty,\n                        &ty::t[] additional_field_tys) -> ValueRef {\n@@ -7751,7 +7756,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n     let TypeRef llforwarding_fn_ty =\n         type_of_fn_full(\n             cx.ccx, sp, m.proto,\n-            some[TypeRef](llself_ty), m.inputs, m.output,\n+            true, m.inputs, m.output,\n             std::ivec::len[ast::ty_param](ty_params));\n     let ValueRef llforwarding_fn =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n@@ -7764,7 +7769,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n \n     // The outer object will arrive in the forwarding function via the llenv\n     // argument.  Put it in an alloca so that we can GEP into it later.\n-    auto llself_obj_ptr = alloca(bcx, llself_ty);\n+    auto llself_obj_ptr = alloca(bcx, T_rust_object());\n     bcx.build.Store(fcx.llenv, llself_obj_ptr);\n \n     // Grab hold of the outer object so we can pass it into the inner object,\n@@ -7791,6 +7796,10 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n                                         C_int(abi::obj_field_box)]);\n     llself_obj_box = bcx.build.Load(llself_obj_box);\n \n+    auto ccx = bcx.fcx.lcx.ccx;\n+    auto llbox_ty = T_opaque_obj_ptr(*ccx);\n+    llself_obj_box = bcx.build.PointerCast(llself_obj_box, llbox_ty);\n+\n     // Now, reach into the box and grab the body.\n     auto llself_obj_body =\n         bcx.build.GEP(llself_obj_box, ~[C_int(0),\n@@ -7859,6 +7868,9 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n \n     // Pick out the original method from the vtable.  The +1 is because slot\n     // #0 contains the destructor.\n+    auto vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 2u));\n+    llwith_obj_vtbl = bcx.build.PointerCast(llwith_obj_vtbl, vtbl_type);\n+\n     auto llorig_mthd = bcx.build.GEP(llwith_obj_vtbl,\n                                      ~[C_int(0), C_int(ix + 1u as int)]);\n \n@@ -7867,7 +7879,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n     auto llorig_mthd_ty =\n         type_of_fn_full(bcx.fcx.lcx.ccx, sp,\n                         ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx, orig_mthd_ty),\n-                        some[TypeRef](llself_ty),\n+                        true,\n                         m.inputs,\n                         m.output,\n                         std::ivec::len[ast::ty_param](ty_params));\n@@ -7903,7 +7915,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n \n // process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n // function for create_vtbl.\n-fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n+fn process_normal_mthd(@local_ctxt cx, @ast::method m,\n                        ty::t self_ty, &ast::ty_param[] ty_params)\n     -> ValueRef {\n \n@@ -7913,7 +7925,7 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n             llfnty =\n                 type_of_fn_full(\n                     cx.ccx, m.span, proto,\n-                    some[TypeRef](llself_ty), inputs, output,\n+                    true, inputs, output,\n                     std::ivec::len[ast::ty_param](ty_params));\n         }\n     }\n@@ -7929,15 +7941,15 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n     cx.ccx.item_ids.insert(m.node.id, llfn);\n     cx.ccx.item_symbols.insert(m.node.id, s);\n     trans_fn(mcx, m.span, m.node.meth, llfn,\n-             some[ty_self_pair](tup(llself_ty, self_ty)),\n+             some(self_ty),\n              ty_params, m.node.id);\n \n     ret llfn;\n }\n \n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n-fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n+fn create_vtbl(@local_ctxt cx, &span sp, ty::t self_ty,\n                &ast::_obj ob, &ast::ty_param[] ty_params,\n                option::t[ty::t] with_obj_ty,\n                &ty::t[] additional_field_tys) -> ValueRef {\n@@ -7954,7 +7966,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n     auto dtor = C_null(T_ptr(T_i8()));\n     alt (ob.dtor) {\n         case (some(?d)) {\n-            auto dtor_1 = trans_dtor(cx, llself_ty, self_ty, ty_params, d);\n+            auto dtor_1 = trans_dtor(cx, self_ty, ty_params, d);\n             dtor = llvm::LLVMConstBitCast(dtor_1, val_ty(dtor));\n         }\n         case (none) { }\n@@ -8076,7 +8088,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n     for (vtbl_mthd m in meths) {\n         alt (m) {\n             case (normal_mthd(?nm)) {\n-                llmethods += ~[process_normal_mthd(cx, nm, llself_ty, self_ty,\n+                llmethods += ~[process_normal_mthd(cx, nm, self_ty,\n                                                    ty_params)];\n             }\n             // If we have to process a forwarding method, then we need to know\n@@ -8093,7 +8105,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n                     }\n                     case (some(?t)) {\n                         llmethods += ~[process_fwding_mthd(\n-                                cx, sp, fm, llself_ty,\n+                                cx, sp, fm,\n                                 self_ty, ty_params,\n                                 t,\n                                 additional_field_tys)];\n@@ -8115,15 +8127,15 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n     ret gvar;\n }\n \n-fn trans_dtor(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n+fn trans_dtor(@local_ctxt cx, ty::t self_ty,\n               &ast::ty_param[] ty_params, &@ast::method dtor) -> ValueRef {\n-    auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n+    auto llfnty = T_dtor(cx.ccx, dtor.span);\n     let str s = mangle_internal_name_by_path(cx.ccx, cx.path + ~[\"drop\"]);\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n     trans_fn(cx, dtor.span, dtor.node.meth, llfn,\n-             some[ty_self_pair](tup(llself_ty, self_ty)), ty_params,\n+             some(self_ty), ty_params,\n              dtor.node.id);\n     ret llfn;\n }\n@@ -8157,7 +8169,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n     // Both regular arguments and type parameters are handled here.\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id),\n                               fn_args, ty_params);\n     let ty::arg[] arg_tys = arg_tys_of_fn(ccx, ctor_id);\n@@ -8171,7 +8183,6 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building.\n     auto self_ty = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n-    auto llself_ty = type_of(ccx, sp, self_ty);\n \n     // Set up the two-word pair that we're going to return from the object\n     // constructor we're building.  The two elements of this pair will be a\n@@ -8192,8 +8203,9 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n-    auto vtbl = create_vtbl(cx, sp, llself_ty, self_ty, ob, ty_params, none,\n+    auto vtbl = create_vtbl(cx, sp, self_ty, ob, ty_params, none,\n                             ~[]);\n+    vtbl = bcx.build.PointerCast(vtbl, T_ptr(T_empty_struct()));\n \n     bcx.build.Store(vtbl, pair_vtbl);\n \n@@ -8204,7 +8216,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // FIXME: What about with_obj?  Do we have to think about it here?\n     // (Pertains to issues #538/#539/#540/#543.)\n \n-    let TypeRef llbox_ty = T_opaque_obj_ptr(*ccx);\n+    let TypeRef llbox_ty = T_ptr(T_empty_struct());\n \n     // FIXME: we should probably also allocate a box for empty objs that have\n     // a dtor, since otherwise they are never dropped, and the dtor never\n@@ -8345,7 +8357,7 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n     }\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     auto ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n                               ret_t, dtor.decl.inputs, ty_params);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -8404,7 +8416,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n         }\n     }\n     auto fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n-    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n+    create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n                               ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n                               fn_args, ty_params);\n     let ty::t[] ty_param_substs = ~[];\n@@ -8501,7 +8513,7 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n             alt (cx.ccx.item_ids.find(item.id)) {\n                 case (some(?llfndecl)) {\n                     trans_fn(sub_cx, item.span, f, llfndecl,\n-                             none[ty_self_pair], tps, item.id);\n+                             none, tps, item.id);\n                 }\n                 case (_) {\n                     cx.ccx.sess.span_fatal(item.span,"}]}