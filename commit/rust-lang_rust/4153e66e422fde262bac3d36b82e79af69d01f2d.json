{"sha": "4153e66e422fde262bac3d36b82e79af69d01f2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNTNlNjZlNDIyZmRlMjYyYmFjM2QzNmI4MmU3OWFmNjlkMDFmMmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T00:45:41Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T00:45:41Z"}, "message": "Move non-public API from lib.rs to its own module", "tree": {"sha": "b71adaba0df38b1a7c88f3da878fbad4dc2df007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b71adaba0df38b1a7c88f3da878fbad4dc2df007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4153e66e422fde262bac3d36b82e79af69d01f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4153e66e422fde262bac3d36b82e79af69d01f2d", "html_url": "https://github.com/rust-lang/rust/commit/4153e66e422fde262bac3d36b82e79af69d01f2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4153e66e422fde262bac3d36b82e79af69d01f2d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "070ae8ab5c275b6e8d59661b4f9f78f8baa880e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/070ae8ab5c275b6e8d59661b4f9f78f8baa880e4", "html_url": "https://github.com/rust-lang/rust/commit/070ae8ab5c275b6e8d59661b4f9f78f8baa880e4"}], "stats": {"total": 1244, "additions": 631, "deletions": 613}, "files": [{"sha": "201403210328b31a87e4ced4cdc059001520fb24", "filename": "src/filemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=4153e66e422fde262bac3d36b82e79af69d01f2d", "patch": "@@ -16,7 +16,7 @@ use config::{Config, EmitMode, FileName, Verbosity};\n use rustfmt_diff::{make_diff, output_modified, print_diff};\n \n #[cfg(test)]\n-use FileRecord;\n+use formatting::FileRecord;\n \n // Append a newline to the end of each file.\n pub fn append_newline(s: &mut String) {"}, {"sha": "95e2b08e3fed6f8e89c9dedad64cfd02a64299bc", "filename": "src/formatting.rs", "status": "added", "additions": 593, "deletions": 0, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=4153e66e422fde262bac3d36b82e79af69d01f2d", "patch": "@@ -0,0 +1,593 @@\n+// High level formatting functions.\n+\n+use std::collections::HashMap;\n+use std::io::{self, Write};\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::rc::Rc;\n+use std::time::Duration;\n+\n+use syntax::ast;\n+use syntax::codemap::{CodeMap, FilePathMapping, Span};\n+use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n+use syntax::errors::{DiagnosticBuilder, Handler};\n+use syntax::parse::{self, ParseSess};\n+\n+use comment::{CharClasses, FullCodeCharKind};\n+use issues::BadIssueSeeker;\n+use visitor::{FmtVisitor, SnippetProvider};\n+use {filemap, modules, ErrorKind, FormatReport, Input};\n+\n+use config::summary::Summary;\n+use config::{Config, FileName, NewlineStyle, Verbosity};\n+\n+// A map of the files of a crate, with their new content\n+pub(crate) type FileMap = Vec<FileRecord>;\n+\n+pub(crate) type FileRecord = (FileName, String);\n+\n+pub(crate) struct FormattingError {\n+    pub(crate) line: usize,\n+    pub(crate) kind: ErrorKind,\n+    is_comment: bool,\n+    is_string: bool,\n+    pub(crate) line_buffer: String,\n+}\n+\n+impl FormattingError {\n+    pub(crate) fn from_span(span: &Span, codemap: &CodeMap, kind: ErrorKind) -> FormattingError {\n+        FormattingError {\n+            line: codemap.lookup_char_pos(span.lo()).line,\n+            is_comment: kind.is_comment(),\n+            kind,\n+            is_string: false,\n+            line_buffer: codemap\n+                .span_to_lines(*span)\n+                .ok()\n+                .and_then(|fl| {\n+                    fl.file\n+                        .get_line(fl.lines[0].line_index)\n+                        .map(|l| l.into_owned())\n+                })\n+                .unwrap_or_else(|| String::new()),\n+        }\n+    }\n+\n+    pub(crate) fn msg_prefix(&self) -> &str {\n+        match self.kind {\n+            ErrorKind::LineOverflow(..)\n+            | ErrorKind::TrailingWhitespace\n+            | ErrorKind::IoError(_)\n+            | ErrorKind::ParseError\n+            | ErrorKind::LostComment => \"internal error:\",\n+            ErrorKind::LicenseCheck | ErrorKind::BadAttr | ErrorKind::VersionMismatch => \"error:\",\n+            ErrorKind::BadIssue(_) | ErrorKind::DeprecatedAttr => \"warning:\",\n+        }\n+    }\n+\n+    pub(crate) fn msg_suffix(&self) -> &str {\n+        if self.is_comment || self.is_string {\n+            \"set `error_on_unformatted = false` to suppress \\\n+             the warning against comments or string literals\\n\"\n+        } else {\n+            \"\"\n+        }\n+    }\n+\n+    // (space, target)\n+    pub(crate) fn format_len(&self) -> (usize, usize) {\n+        match self.kind {\n+            ErrorKind::LineOverflow(found, max) => (max, found - max),\n+            ErrorKind::TrailingWhitespace\n+            | ErrorKind::DeprecatedAttr\n+            | ErrorKind::BadAttr\n+            | ErrorKind::LostComment => {\n+                let trailing_ws_start = self\n+                    .line_buffer\n+                    .rfind(|c: char| !c.is_whitespace())\n+                    .map(|pos| pos + 1)\n+                    .unwrap_or(0);\n+                (\n+                    trailing_ws_start,\n+                    self.line_buffer.len() - trailing_ws_start,\n+                )\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+pub(crate) type FormatErrorMap = HashMap<FileName, Vec<FormattingError>>;\n+\n+#[derive(Default, Debug)]\n+pub(crate) struct ReportedErrors {\n+    pub(crate) has_operational_errors: bool,\n+    pub(crate) has_check_errors: bool,\n+}\n+\n+fn should_emit_verbose<F>(path: &FileName, config: &Config, f: F)\n+where\n+    F: Fn(),\n+{\n+    if config.verbose() == Verbosity::Verbose && path != &FileName::Stdin {\n+        f();\n+    }\n+}\n+\n+// Formatting which depends on the AST.\n+fn format_ast<F>(\n+    krate: &ast::Crate,\n+    parse_session: &mut ParseSess,\n+    main_file: &FileName,\n+    config: &Config,\n+    report: FormatReport,\n+    mut after_file: F,\n+) -> Result<(FileMap, bool, bool), io::Error>\n+where\n+    F: FnMut(&FileName, &mut String, &[(usize, usize)], &FormatReport) -> Result<bool, io::Error>,\n+{\n+    let mut result = FileMap::new();\n+    // diff mode: check if any files are differing\n+    let mut has_diff = false;\n+    let mut has_macro_rewrite_failure = false;\n+\n+    let skip_children = config.skip_children();\n+    for (path, module) in modules::list_files(krate, parse_session.codemap())? {\n+        if (skip_children && path != *main_file) || config.ignore().skip_file(&path) {\n+            continue;\n+        }\n+        should_emit_verbose(&path, config, || println!(\"Formatting {}\", path));\n+        let filemap = parse_session\n+            .codemap()\n+            .lookup_char_pos(module.inner.lo())\n+            .file;\n+        let big_snippet = filemap.src.as_ref().unwrap();\n+        let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n+        let mut visitor =\n+            FmtVisitor::from_codemap(parse_session, config, &snippet_provider, report.clone());\n+        // Format inner attributes if available.\n+        if !krate.attrs.is_empty() && path == *main_file {\n+            visitor.skip_empty_lines(filemap.end_pos);\n+            if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n+                visitor.push_rewrite(module.inner, None);\n+            } else {\n+                visitor.format_separate_mod(module, &*filemap);\n+            }\n+        } else {\n+            visitor.last_pos = filemap.start_pos;\n+            visitor.skip_empty_lines(filemap.end_pos);\n+            visitor.format_separate_mod(module, &*filemap);\n+        };\n+\n+        debug_assert_eq!(\n+            visitor.line_number,\n+            ::utils::count_newlines(&visitor.buffer)\n+        );\n+\n+        has_diff |= match after_file(&path, &mut visitor.buffer, &visitor.skipped_range, &report) {\n+            Ok(result) => result,\n+            Err(e) => {\n+                // Create a new error with path_str to help users see which files failed\n+                let err_msg = format!(\"{}: {}\", path, e);\n+                return Err(io::Error::new(e.kind(), err_msg));\n+            }\n+        };\n+\n+        has_macro_rewrite_failure |= visitor.macro_rewrite_failure;\n+\n+        result.push((path.clone(), visitor.buffer));\n+    }\n+\n+    Ok((result, has_diff, has_macro_rewrite_failure))\n+}\n+\n+/// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n+fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n+    skipped_range\n+        .iter()\n+        .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n+}\n+\n+fn should_report_error(\n+    config: &Config,\n+    char_kind: FullCodeCharKind,\n+    is_string: bool,\n+    error_kind: &ErrorKind,\n+) -> bool {\n+    let allow_error_report = if char_kind.is_comment() || is_string || error_kind.is_comment() {\n+        config.error_on_unformatted()\n+    } else {\n+        true\n+    };\n+\n+    match error_kind {\n+        ErrorKind::LineOverflow(..) => config.error_on_line_overflow() && allow_error_report,\n+        ErrorKind::TrailingWhitespace | ErrorKind::LostComment => allow_error_report,\n+        _ => true,\n+    }\n+}\n+\n+// Formatting done on a char by char or line by line basis.\n+// FIXME(#20) other stuff for parity with make tidy\n+fn format_lines(\n+    text: &mut String,\n+    name: &FileName,\n+    skipped_range: &[(usize, usize)],\n+    config: &Config,\n+    report: &FormatReport,\n+) {\n+    let mut last_was_space = false;\n+    let mut line_len = 0;\n+    let mut cur_line = 1;\n+    let mut newline_count = 0;\n+    let mut errors = vec![];\n+    let mut issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n+    let mut line_buffer = String::with_capacity(config.max_width() * 2);\n+    let mut is_string = false; // true if the current line contains a string literal.\n+    let mut format_line = config.file_lines().contains_line(name, cur_line);\n+    let allow_issue_seek = !issue_seeker.is_disabled();\n+\n+    // Check license.\n+    if let Some(ref license_template) = config.license_template {\n+        if !license_template.is_match(text) {\n+            errors.push(FormattingError {\n+                line: cur_line,\n+                kind: ErrorKind::LicenseCheck,\n+                is_comment: false,\n+                is_string: false,\n+                line_buffer: String::new(),\n+            });\n+        }\n+    }\n+\n+    // Iterate over the chars in the file map.\n+    for (kind, c) in CharClasses::new(text.chars()) {\n+        if c == '\\r' {\n+            continue;\n+        }\n+\n+        if allow_issue_seek && format_line {\n+            // Add warnings for bad todos/ fixmes\n+            if let Some(issue) = issue_seeker.inspect(c) {\n+                errors.push(FormattingError {\n+                    line: cur_line,\n+                    kind: ErrorKind::BadIssue(issue),\n+                    is_comment: false,\n+                    is_string: false,\n+                    line_buffer: String::new(),\n+                });\n+            }\n+        }\n+\n+        if c == '\\n' {\n+            if format_line {\n+                // Check for (and record) trailing whitespace.\n+                if last_was_space {\n+                    if should_report_error(config, kind, is_string, &ErrorKind::TrailingWhitespace)\n+                        && !is_skipped_line(cur_line, skipped_range)\n+                    {\n+                        errors.push(FormattingError {\n+                            line: cur_line,\n+                            kind: ErrorKind::TrailingWhitespace,\n+                            is_comment: kind.is_comment(),\n+                            is_string: kind.is_string(),\n+                            line_buffer: line_buffer.clone(),\n+                        });\n+                    }\n+                    line_len -= 1;\n+                }\n+\n+                // Check for any line width errors we couldn't correct.\n+                let error_kind = ErrorKind::LineOverflow(line_len, config.max_width());\n+                if line_len > config.max_width()\n+                    && !is_skipped_line(cur_line, skipped_range)\n+                    && should_report_error(config, kind, is_string, &error_kind)\n+                {\n+                    errors.push(FormattingError {\n+                        line: cur_line,\n+                        kind: error_kind,\n+                        is_comment: kind.is_comment(),\n+                        is_string,\n+                        line_buffer: line_buffer.clone(),\n+                    });\n+                }\n+            }\n+\n+            line_len = 0;\n+            cur_line += 1;\n+            format_line = config.file_lines().contains_line(name, cur_line);\n+            newline_count += 1;\n+            last_was_space = false;\n+            line_buffer.clear();\n+            is_string = false;\n+        } else {\n+            newline_count = 0;\n+            line_len += if c == '\\t' { config.tab_spaces() } else { 1 };\n+            last_was_space = c.is_whitespace();\n+            line_buffer.push(c);\n+            if kind.is_string() {\n+                is_string = true;\n+            }\n+        }\n+    }\n+\n+    if newline_count > 1 {\n+        debug!(\"track truncate: {} {}\", text.len(), newline_count);\n+        let line = text.len() - newline_count + 1;\n+        text.truncate(line);\n+    }\n+\n+    report.append(name.clone(), errors);\n+}\n+\n+fn parse_input<'sess>(\n+    input: Input,\n+    parse_session: &'sess ParseSess,\n+    config: &Config,\n+) -> Result<ast::Crate, ParseError<'sess>> {\n+    let mut parser = match input {\n+        Input::File(file) => parse::new_parser_from_file(parse_session, &file),\n+        Input::Text(text) => parse::new_parser_from_source_str(\n+            parse_session,\n+            syntax::codemap::FileName::Custom(\"stdin\".to_owned()),\n+            text,\n+        ),\n+    };\n+\n+    parser.cfg_mods = false;\n+    if config.skip_children() {\n+        parser.recurse_into_file_modules = false;\n+    }\n+\n+    let mut parser = AssertUnwindSafe(parser);\n+    let result = catch_unwind(move || parser.0.parse_crate_mod());\n+\n+    match result {\n+        Ok(Ok(c)) => {\n+            if parse_session.span_diagnostic.has_errors() {\n+                // Bail out if the parser recovered from an error.\n+                Err(ParseError::Recovered)\n+            } else {\n+                Ok(c)\n+            }\n+        }\n+        Ok(Err(e)) => Err(ParseError::Error(e)),\n+        Err(_) => Err(ParseError::Panic),\n+    }\n+}\n+\n+/// All the ways that parsing can fail.\n+enum ParseError<'sess> {\n+    /// There was an error, but the parser recovered.\n+    Recovered,\n+    /// There was an error (supplied) and parsing failed.\n+    Error(DiagnosticBuilder<'sess>),\n+    /// The parser panicked.\n+    Panic,\n+}\n+\n+pub(crate) fn format_input_inner<T: Write>(\n+    input: Input,\n+    config: &Config,\n+    mut out: Option<&mut T>,\n+) -> Result<(Summary, FileMap, FormatReport), (ErrorKind, Summary)> {\n+    syntax_pos::hygiene::set_default_edition(config.edition().to_libsyntax_pos_edition());\n+    let mut summary = Summary::default();\n+    if config.disable_all_formatting() {\n+        // When the input is from stdin, echo back the input.\n+        if let Input::Text(ref buf) = input {\n+            if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n+                return Err((From::from(e), summary));\n+            }\n+        }\n+        return Ok((summary, FileMap::new(), FormatReport::new()));\n+    }\n+    let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+\n+    let tty_handler = if config.hide_parse_errors() {\n+        let silent_emitter = Box::new(EmitterWriter::new(\n+            Box::new(Vec::new()),\n+            Some(codemap.clone()),\n+            false,\n+            false,\n+        ));\n+        Handler::with_emitter(true, false, silent_emitter)\n+    } else {\n+        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+        let color_cfg = if supports_color {\n+            ColorConfig::Auto\n+        } else {\n+            ColorConfig::Never\n+        };\n+        Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n+    };\n+    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+\n+    let main_file = match input {\n+        Input::File(ref file) => FileName::Real(file.clone()),\n+        Input::Text(..) => FileName::Stdin,\n+    };\n+\n+    let krate = match parse_input(input, &parse_session, config) {\n+        Ok(krate) => krate,\n+        Err(err) => {\n+            match err {\n+                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n+                ParseError::Panic => {\n+                    // Note that if you see this message and want more information,\n+                    // then go to `parse_input` and run the parse function without\n+                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n+                    should_emit_verbose(&main_file, config, || {\n+                        println!(\"The Rust parser panicked\")\n+                    });\n+                }\n+                ParseError::Recovered => {}\n+            }\n+            summary.add_parsing_error();\n+            return Err((ErrorKind::ParseError, summary));\n+        }\n+    };\n+\n+    summary.mark_parse_time();\n+\n+    // Suppress error output after parsing.\n+    let silent_emitter = Box::new(EmitterWriter::new(\n+        Box::new(Vec::new()),\n+        Some(codemap.clone()),\n+        false,\n+        false,\n+    ));\n+    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n+\n+    let report = FormatReport::new();\n+\n+    let format_result = format_ast(\n+        &krate,\n+        &mut parse_session,\n+        &main_file,\n+        config,\n+        report.clone(),\n+        |file_name, file, skipped_range, report| {\n+            // For some reason, the codemap does not include terminating\n+            // newlines so we must add one on for each file. This is sad.\n+            filemap::append_newline(file);\n+\n+            format_lines(file, file_name, skipped_range, config, report);\n+            replace_with_system_newlines(file, config);\n+\n+            if let Some(ref mut out) = out {\n+                return filemap::write_file(file, file_name, out, config);\n+            }\n+            Ok(false)\n+        },\n+    );\n+\n+    summary.mark_format_time();\n+\n+    should_emit_verbose(&main_file, config, || {\n+        fn duration_to_f32(d: Duration) -> f32 {\n+            d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+        }\n+\n+        println!(\n+            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+            duration_to_f32(summary.get_parse_time().unwrap()),\n+            duration_to_f32(summary.get_format_time().unwrap()),\n+        )\n+    });\n+\n+    {\n+        let report_errs = &report.internal.borrow().1;\n+        if report_errs.has_check_errors {\n+            summary.add_check_error();\n+        }\n+        if report_errs.has_operational_errors {\n+            summary.add_operational_error();\n+        }\n+    }\n+\n+    match format_result {\n+        Ok((file_map, has_diff, has_macro_rewrite_failure)) => {\n+            if report.has_warnings() {\n+                summary.add_formatting_error();\n+            }\n+\n+            if has_diff {\n+                summary.add_diff();\n+            }\n+\n+            if has_macro_rewrite_failure {\n+                summary.add_macro_foramt_failure();\n+            }\n+\n+            Ok((summary, file_map, report))\n+        }\n+        Err(e) => Err((From::from(e), summary)),\n+    }\n+}\n+\n+fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    } else {\n+        config.newline_style()\n+    };\n+\n+    match style {\n+        NewlineStyle::Unix => return,\n+        NewlineStyle::Windows => {\n+            let mut transformed = String::with_capacity(text.capacity());\n+            for c in text.chars() {\n+                match c {\n+                    '\\n' => transformed.push_str(\"\\r\\n\"),\n+                    '\\r' => continue,\n+                    c => transformed.push(c),\n+                }\n+            }\n+            *text = transformed;\n+        }\n+        NewlineStyle::Native => unreachable!(),\n+    }\n+}\n+\n+/// A single span of changed lines, with 0 or more removed lines\n+/// and a vector of 0 or more inserted lines.\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ModifiedChunk {\n+    /// The first to be removed from the original text\n+    pub line_number_orig: u32,\n+    /// The number of lines which have been replaced\n+    pub lines_removed: u32,\n+    /// The new lines\n+    pub lines: Vec<String>,\n+}\n+\n+/// Set of changed sections of a file.\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ModifiedLines {\n+    /// The set of changed chunks.\n+    pub chunks: Vec<ModifiedChunk>,\n+}\n+\n+/// Format a file and return a `ModifiedLines` data structure describing\n+/// the changed ranges of lines.\n+#[cfg(test)]\n+pub(crate) fn get_modified_lines(\n+    input: Input,\n+    config: &Config,\n+) -> Result<ModifiedLines, (ErrorKind, Summary)> {\n+    use std::io::BufRead;\n+\n+    let mut data = Vec::new();\n+\n+    let mut config = config.clone();\n+    config.set().emit_mode(::config::EmitMode::ModifiedLines);\n+    ::format_input(input, &config, Some(&mut data))?;\n+\n+    let mut lines = data.lines();\n+    let mut chunks = Vec::new();\n+    while let Some(Ok(header)) = lines.next() {\n+        // Parse the header line\n+        let values: Vec<_> = header\n+            .split(' ')\n+            .map(|s| s.parse::<u32>().unwrap())\n+            .collect();\n+        assert_eq!(values.len(), 3);\n+        let line_number_orig = values[0];\n+        let lines_removed = values[1];\n+        let num_added = values[2];\n+        let mut added_lines = Vec::new();\n+        for _ in 0..num_added {\n+            added_lines.push(lines.next().unwrap().unwrap());\n+        }\n+        chunks.push(ModifiedChunk {\n+            line_number_orig,\n+            lines_removed,\n+            lines: added_lines,\n+        });\n+    }\n+    Ok(ModifiedLines { chunks })\n+}"}, {"sha": "2c1ef49f35445aaa3bb78f05b3ebff9c20f3f211", "filename": "src/lib.rs", "status": "modified", "additions": 31, "deletions": 608, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4153e66e422fde262bac3d36b82e79af69d01f2d", "patch": "@@ -41,22 +41,15 @@ use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n use std::io::{self, Write};\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::time::Duration;\n-\n use syntax::ast;\n-use syntax::codemap::{CodeMap, FilePathMapping, Span};\n-use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n-use syntax::errors::{DiagnosticBuilder, Handler};\n-use syntax::parse::{self, ParseSess};\n \n-use comment::{CharClasses, FullCodeCharKind, LineClasses};\n+use comment::LineClasses;\n use failure::Fail;\n-use issues::{BadIssueSeeker, Issue};\n+use formatting::{format_input_inner, FormatErrorMap, FormattingError, ReportedErrors};\n+use issues::Issue;\n use shape::Indent;\n-use visitor::{FmtVisitor, SnippetProvider};\n \n pub use checkstyle::{footer as checkstyle_footer, header as checkstyle_header};\n pub use config::summary::Summary;\n@@ -77,6 +70,7 @@ mod comment;\n pub(crate) mod config;\n mod expr;\n pub(crate) mod filemap;\n+pub(crate) mod formatting;\n mod imports;\n mod issues;\n mod items;\n@@ -100,11 +94,6 @@ mod types;\n mod vertical;\n pub(crate) mod visitor;\n \n-// A map of the files of a crate, with their new content\n-pub(crate) type FileMap = Vec<FileRecord>;\n-\n-pub(crate) type FileRecord = (FileName, String);\n-\n /// The various errors that can occur during formatting. Note that not all of\n /// these can currently be propagated to clients.\n #[derive(Fail, Debug)]\n@@ -162,76 +151,6 @@ impl From<io::Error> for ErrorKind {\n     }\n }\n \n-struct FormattingError {\n-    line: usize,\n-    kind: ErrorKind,\n-    is_comment: bool,\n-    is_string: bool,\n-    line_buffer: String,\n-}\n-\n-impl FormattingError {\n-    fn from_span(span: &Span, codemap: &CodeMap, kind: ErrorKind) -> FormattingError {\n-        FormattingError {\n-            line: codemap.lookup_char_pos(span.lo()).line,\n-            is_comment: kind.is_comment(),\n-            kind,\n-            is_string: false,\n-            line_buffer: codemap\n-                .span_to_lines(*span)\n-                .ok()\n-                .and_then(|fl| {\n-                    fl.file\n-                        .get_line(fl.lines[0].line_index)\n-                        .map(|l| l.into_owned())\n-                })\n-                .unwrap_or_else(|| String::new()),\n-        }\n-    }\n-    fn msg_prefix(&self) -> &str {\n-        match self.kind {\n-            ErrorKind::LineOverflow(..)\n-            | ErrorKind::TrailingWhitespace\n-            | ErrorKind::IoError(_)\n-            | ErrorKind::ParseError\n-            | ErrorKind::LostComment => \"internal error:\",\n-            ErrorKind::LicenseCheck | ErrorKind::BadAttr | ErrorKind::VersionMismatch => \"error:\",\n-            ErrorKind::BadIssue(_) | ErrorKind::DeprecatedAttr => \"warning:\",\n-        }\n-    }\n-\n-    fn msg_suffix(&self) -> &str {\n-        if self.is_comment || self.is_string {\n-            \"set `error_on_unformatted = false` to suppress \\\n-             the warning against comments or string literals\\n\"\n-        } else {\n-            \"\"\n-        }\n-    }\n-\n-    // (space, target)\n-    fn format_len(&self) -> (usize, usize) {\n-        match self.kind {\n-            ErrorKind::LineOverflow(found, max) => (max, found - max),\n-            ErrorKind::TrailingWhitespace\n-            | ErrorKind::DeprecatedAttr\n-            | ErrorKind::BadAttr\n-            | ErrorKind::LostComment => {\n-                let trailing_ws_start = self\n-                    .line_buffer\n-                    .rfind(|c: char| !c.is_whitespace())\n-                    .map(|pos| pos + 1)\n-                    .unwrap_or(0);\n-                (\n-                    trailing_ws_start,\n-                    self.line_buffer.len() - trailing_ws_start,\n-                )\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n /// Reports on any issues that occurred during a run of Rustfmt.\n ///\n /// Can be reported to the user via its `Display` implementation of `print_fancy`.\n@@ -241,14 +160,6 @@ pub struct FormatReport {\n     internal: Rc<RefCell<(FormatErrorMap, ReportedErrors)>>,\n }\n \n-type FormatErrorMap = HashMap<FileName, Vec<FormattingError>>;\n-\n-#[derive(Default, Debug)]\n-struct ReportedErrors {\n-    has_operational_errors: bool,\n-    has_check_errors: bool,\n-}\n-\n impl FormatReport {\n     fn new() -> FormatReport {\n         FormatReport {\n@@ -336,7 +247,7 @@ impl FormatReport {\n                     t.attr(term::Attr::Bold)?;\n                     write!(t, \"{}| \", prefix_spaces)?;\n                     t.fg(term::color::RED)?;\n-                    writeln!(t, \"{}\", target_str(space_len, target_len))?;\n+                    writeln!(t, \"{}\", FormatReport::target_str(space_len, target_len))?;\n                     t.reset()?;\n                 }\n \n@@ -367,12 +278,12 @@ impl FormatReport {\n \n         Ok(())\n     }\n-}\n \n-fn target_str(space_len: usize, target_len: usize) -> String {\n-    let empty_line = \" \".repeat(space_len);\n-    let overflowed = \"^\".repeat(target_len);\n-    empty_line + &overflowed\n+    fn target_str(space_len: usize, target_len: usize) -> String {\n+        let empty_line = \" \".repeat(space_len);\n+        let overflowed = \"^\".repeat(target_len);\n+        empty_line + &overflowed\n+    }\n }\n \n impl fmt::Display for FormatReport {\n@@ -393,7 +304,7 @@ impl fmt::Display for FormatReport {\n                         error.line,\n                         error.line_buffer,\n                         prefix_spaces,\n-                        target_str(space_len, target_len)\n+                        FormatReport::target_str(space_len, target_len)\n                     )\n                 };\n \n@@ -428,267 +339,6 @@ impl fmt::Display for FormatReport {\n     }\n }\n \n-fn should_emit_verbose<F>(path: &FileName, config: &Config, f: F)\n-where\n-    F: Fn(),\n-{\n-    if config.verbose() == Verbosity::Verbose && path != &FileName::Stdin {\n-        f();\n-    }\n-}\n-\n-// Formatting which depends on the AST.\n-fn format_ast<F>(\n-    krate: &ast::Crate,\n-    parse_session: &mut ParseSess,\n-    main_file: &FileName,\n-    config: &Config,\n-    report: FormatReport,\n-    mut after_file: F,\n-) -> Result<(FileMap, bool, bool), io::Error>\n-where\n-    F: FnMut(&FileName, &mut String, &[(usize, usize)], &FormatReport) -> Result<bool, io::Error>,\n-{\n-    let mut result = FileMap::new();\n-    // diff mode: check if any files are differing\n-    let mut has_diff = false;\n-    let mut has_macro_rewrite_failure = false;\n-\n-    let skip_children = config.skip_children();\n-    for (path, module) in modules::list_files(krate, parse_session.codemap())? {\n-        if (skip_children && path != *main_file) || config.ignore().skip_file(&path) {\n-            continue;\n-        }\n-        should_emit_verbose(&path, config, || println!(\"Formatting {}\", path));\n-        let filemap = parse_session\n-            .codemap()\n-            .lookup_char_pos(module.inner.lo())\n-            .file;\n-        let big_snippet = filemap.src.as_ref().unwrap();\n-        let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n-        let mut visitor =\n-            FmtVisitor::from_codemap(parse_session, config, &snippet_provider, report.clone());\n-        // Format inner attributes if available.\n-        if !krate.attrs.is_empty() && path == *main_file {\n-            visitor.skip_empty_lines(filemap.end_pos);\n-            if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n-                visitor.push_rewrite(module.inner, None);\n-            } else {\n-                visitor.format_separate_mod(module, &*filemap);\n-            }\n-        } else {\n-            visitor.last_pos = filemap.start_pos;\n-            visitor.skip_empty_lines(filemap.end_pos);\n-            visitor.format_separate_mod(module, &*filemap);\n-        };\n-\n-        debug_assert_eq!(\n-            visitor.line_number,\n-            ::utils::count_newlines(&visitor.buffer)\n-        );\n-\n-        has_diff |= match after_file(&path, &mut visitor.buffer, &visitor.skipped_range, &report) {\n-            Ok(result) => result,\n-            Err(e) => {\n-                // Create a new error with path_str to help users see which files failed\n-                let err_msg = format!(\"{}: {}\", path, e);\n-                return Err(io::Error::new(e.kind(), err_msg));\n-            }\n-        };\n-\n-        has_macro_rewrite_failure |= visitor.macro_rewrite_failure;\n-\n-        result.push((path.clone(), visitor.buffer));\n-    }\n-\n-    Ok((result, has_diff, has_macro_rewrite_failure))\n-}\n-\n-/// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n-fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n-    skipped_range\n-        .iter()\n-        .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n-}\n-\n-fn should_report_error(\n-    config: &Config,\n-    char_kind: FullCodeCharKind,\n-    is_string: bool,\n-    error_kind: &ErrorKind,\n-) -> bool {\n-    let allow_error_report = if char_kind.is_comment() || is_string || error_kind.is_comment() {\n-        config.error_on_unformatted()\n-    } else {\n-        true\n-    };\n-\n-    match error_kind {\n-        ErrorKind::LineOverflow(..) => config.error_on_line_overflow() && allow_error_report,\n-        ErrorKind::TrailingWhitespace | ErrorKind::LostComment => allow_error_report,\n-        _ => true,\n-    }\n-}\n-\n-// Formatting done on a char by char or line by line basis.\n-// FIXME(#20) other stuff for parity with make tidy\n-fn format_lines(\n-    text: &mut String,\n-    name: &FileName,\n-    skipped_range: &[(usize, usize)],\n-    config: &Config,\n-    report: &FormatReport,\n-) {\n-    let mut last_was_space = false;\n-    let mut line_len = 0;\n-    let mut cur_line = 1;\n-    let mut newline_count = 0;\n-    let mut errors = vec![];\n-    let mut issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n-    let mut line_buffer = String::with_capacity(config.max_width() * 2);\n-    let mut is_string = false; // true if the current line contains a string literal.\n-    let mut format_line = config.file_lines().contains_line(name, cur_line);\n-    let allow_issue_seek = !issue_seeker.is_disabled();\n-\n-    // Check license.\n-    if let Some(ref license_template) = config.license_template {\n-        if !license_template.is_match(text) {\n-            errors.push(FormattingError {\n-                line: cur_line,\n-                kind: ErrorKind::LicenseCheck,\n-                is_comment: false,\n-                is_string: false,\n-                line_buffer: String::new(),\n-            });\n-        }\n-    }\n-\n-    // Iterate over the chars in the file map.\n-    for (kind, c) in CharClasses::new(text.chars()) {\n-        if c == '\\r' {\n-            continue;\n-        }\n-\n-        if allow_issue_seek && format_line {\n-            // Add warnings for bad todos/ fixmes\n-            if let Some(issue) = issue_seeker.inspect(c) {\n-                errors.push(FormattingError {\n-                    line: cur_line,\n-                    kind: ErrorKind::BadIssue(issue),\n-                    is_comment: false,\n-                    is_string: false,\n-                    line_buffer: String::new(),\n-                });\n-            }\n-        }\n-\n-        if c == '\\n' {\n-            if format_line {\n-                // Check for (and record) trailing whitespace.\n-                if last_was_space {\n-                    if should_report_error(config, kind, is_string, &ErrorKind::TrailingWhitespace)\n-                        && !is_skipped_line(cur_line, skipped_range)\n-                    {\n-                        errors.push(FormattingError {\n-                            line: cur_line,\n-                            kind: ErrorKind::TrailingWhitespace,\n-                            is_comment: kind.is_comment(),\n-                            is_string: kind.is_string(),\n-                            line_buffer: line_buffer.clone(),\n-                        });\n-                    }\n-                    line_len -= 1;\n-                }\n-\n-                // Check for any line width errors we couldn't correct.\n-                let error_kind = ErrorKind::LineOverflow(line_len, config.max_width());\n-                if line_len > config.max_width()\n-                    && !is_skipped_line(cur_line, skipped_range)\n-                    && should_report_error(config, kind, is_string, &error_kind)\n-                {\n-                    errors.push(FormattingError {\n-                        line: cur_line,\n-                        kind: error_kind,\n-                        is_comment: kind.is_comment(),\n-                        is_string,\n-                        line_buffer: line_buffer.clone(),\n-                    });\n-                }\n-            }\n-\n-            line_len = 0;\n-            cur_line += 1;\n-            format_line = config.file_lines().contains_line(name, cur_line);\n-            newline_count += 1;\n-            last_was_space = false;\n-            line_buffer.clear();\n-            is_string = false;\n-        } else {\n-            newline_count = 0;\n-            line_len += if c == '\\t' { config.tab_spaces() } else { 1 };\n-            last_was_space = c.is_whitespace();\n-            line_buffer.push(c);\n-            if kind.is_string() {\n-                is_string = true;\n-            }\n-        }\n-    }\n-\n-    if newline_count > 1 {\n-        debug!(\"track truncate: {} {}\", text.len(), newline_count);\n-        let line = text.len() - newline_count + 1;\n-        text.truncate(line);\n-    }\n-\n-    report.append(name.clone(), errors);\n-}\n-\n-fn parse_input<'sess>(\n-    input: Input,\n-    parse_session: &'sess ParseSess,\n-    config: &Config,\n-) -> Result<ast::Crate, ParseError<'sess>> {\n-    let mut parser = match input {\n-        Input::File(file) => parse::new_parser_from_file(parse_session, &file),\n-        Input::Text(text) => parse::new_parser_from_source_str(\n-            parse_session,\n-            syntax::codemap::FileName::Custom(\"stdin\".to_owned()),\n-            text,\n-        ),\n-    };\n-\n-    parser.cfg_mods = false;\n-    if config.skip_children() {\n-        parser.recurse_into_file_modules = false;\n-    }\n-\n-    let mut parser = AssertUnwindSafe(parser);\n-    let result = catch_unwind(move || parser.0.parse_crate_mod());\n-\n-    match result {\n-        Ok(Ok(c)) => {\n-            if parse_session.span_diagnostic.has_errors() {\n-                // Bail out if the parser recovered from an error.\n-                Err(ParseError::Recovered)\n-            } else {\n-                Ok(c)\n-            }\n-        }\n-        Ok(Err(e)) => Err(ParseError::Error(e)),\n-        Err(_) => Err(ParseError::Panic),\n-    }\n-}\n-\n-/// All the ways that parsing can fail.\n-enum ParseError<'sess> {\n-    /// There was an error, but the parser recovered.\n-    Recovered,\n-    /// There was an error (supplied) and parsing failed.\n-    Error(DiagnosticBuilder<'sess>),\n-    /// The parser panicked.\n-    Panic,\n-}\n-\n /// Format the given snippet. The snippet is expected to be *complete* code.\n /// When we cannot parse the given snippet, this function returns `None`.\n fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n@@ -707,30 +357,30 @@ fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n     }\n }\n \n-const FN_MAIN_PREFIX: &str = \"fn main() {\\n\";\n-\n-fn enclose_in_main_block(s: &str, config: &Config) -> String {\n-    let indent = Indent::from_width(config, config.tab_spaces());\n-    let mut result = String::with_capacity(s.len() * 2);\n-    result.push_str(FN_MAIN_PREFIX);\n-    let mut need_indent = true;\n-    for (kind, line) in LineClasses::new(s) {\n-        if need_indent {\n-            result.push_str(&indent.to_string(config));\n-        }\n-        result.push_str(&line);\n-        result.push('\\n');\n-        need_indent = !kind.is_string() || line.ends_with('\\\\');\n-    }\n-    result.push('}');\n-    result\n-}\n-\n /// Format the given code block. Mainly targeted for code block in comment.\n /// The code block may be incomplete (i.e. parser may be unable to parse it).\n /// To avoid panic in parser, we wrap the code block with a dummy function.\n /// The returned code block does *not* end with newline.\n fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n+    const FN_MAIN_PREFIX: &str = \"fn main() {\\n\";\n+\n+    fn enclose_in_main_block(s: &str, config: &Config) -> String {\n+        let indent = Indent::from_width(config, config.tab_spaces());\n+        let mut result = String::with_capacity(s.len() * 2);\n+        result.push_str(FN_MAIN_PREFIX);\n+        let mut need_indent = true;\n+        for (kind, line) in LineClasses::new(s) {\n+            if need_indent {\n+                result.push_str(&indent.to_string(config));\n+            }\n+            result.push_str(&line);\n+            result.push('\\n');\n+            need_indent = !kind.is_string() || line.ends_with('\\\\');\n+        }\n+        result.push('}');\n+        result\n+    }\n+\n     // Wrap the given code block with `fn main()` if it does not have one.\n     let snippet = enclose_in_main_block(code_snippet, config);\n     let mut result = String::with_capacity(snippet.len());\n@@ -806,236 +456,9 @@ pub fn format_input<T: Write>(\n     syntax::with_globals(|| format_input_inner(input, config, out)).map(|tup| (tup.0, tup.2))\n }\n \n-fn format_input_inner<T: Write>(\n-    input: Input,\n-    config: &Config,\n-    mut out: Option<&mut T>,\n-) -> Result<(Summary, FileMap, FormatReport), (ErrorKind, Summary)> {\n-    syntax_pos::hygiene::set_default_edition(config.edition().to_libsyntax_pos_edition());\n-    let mut summary = Summary::default();\n-    if config.disable_all_formatting() {\n-        // When the input is from stdin, echo back the input.\n-        if let Input::Text(ref buf) = input {\n-            if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n-                return Err((From::from(e), summary));\n-            }\n-        }\n-        return Ok((summary, FileMap::new(), FormatReport::new()));\n-    }\n-    let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n-\n-    let tty_handler = if config.hide_parse_errors() {\n-        let silent_emitter = Box::new(EmitterWriter::new(\n-            Box::new(Vec::new()),\n-            Some(codemap.clone()),\n-            false,\n-            false,\n-        ));\n-        Handler::with_emitter(true, false, silent_emitter)\n-    } else {\n-        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-        let color_cfg = if supports_color {\n-            ColorConfig::Auto\n-        } else {\n-            ColorConfig::Never\n-        };\n-        Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n-    };\n-    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n-\n-    let main_file = match input {\n-        Input::File(ref file) => FileName::Real(file.clone()),\n-        Input::Text(..) => FileName::Stdin,\n-    };\n-\n-    let krate = match parse_input(input, &parse_session, config) {\n-        Ok(krate) => krate,\n-        Err(err) => {\n-            match err {\n-                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n-                ParseError::Panic => {\n-                    // Note that if you see this message and want more information,\n-                    // then go to `parse_input` and run the parse function without\n-                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                    should_emit_verbose(&main_file, config, || {\n-                        println!(\"The Rust parser panicked\")\n-                    });\n-                }\n-                ParseError::Recovered => {}\n-            }\n-            summary.add_parsing_error();\n-            return Err((ErrorKind::ParseError, summary));\n-        }\n-    };\n-\n-    summary.mark_parse_time();\n-\n-    // Suppress error output after parsing.\n-    let silent_emitter = Box::new(EmitterWriter::new(\n-        Box::new(Vec::new()),\n-        Some(codemap.clone()),\n-        false,\n-        false,\n-    ));\n-    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n-\n-    let report = FormatReport::new();\n-\n-    let format_result = format_ast(\n-        &krate,\n-        &mut parse_session,\n-        &main_file,\n-        config,\n-        report.clone(),\n-        |file_name, file, skipped_range, report| {\n-            // For some reason, the codemap does not include terminating\n-            // newlines so we must add one on for each file. This is sad.\n-            filemap::append_newline(file);\n-\n-            format_lines(file, file_name, skipped_range, config, report);\n-            replace_with_system_newlines(file, config);\n-\n-            if let Some(ref mut out) = out {\n-                return filemap::write_file(file, file_name, out, config);\n-            }\n-            Ok(false)\n-        },\n-    );\n-\n-    summary.mark_format_time();\n-\n-    should_emit_verbose(&main_file, config, || {\n-        fn duration_to_f32(d: Duration) -> f32 {\n-            d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n-        }\n-\n-        println!(\n-            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-            duration_to_f32(summary.get_parse_time().unwrap()),\n-            duration_to_f32(summary.get_format_time().unwrap()),\n-        )\n-    });\n-\n-    {\n-        let report_errs = &report.internal.borrow().1;\n-        if report_errs.has_check_errors {\n-            summary.add_check_error();\n-        }\n-        if report_errs.has_operational_errors {\n-            summary.add_operational_error();\n-        }\n-    }\n-\n-    match format_result {\n-        Ok((file_map, has_diff, has_macro_rewrite_failure)) => {\n-            if report.has_warnings() {\n-                summary.add_formatting_error();\n-            }\n-\n-            if has_diff {\n-                summary.add_diff();\n-            }\n-\n-            if has_macro_rewrite_failure {\n-                summary.add_macro_foramt_failure();\n-            }\n-\n-            Ok((summary, file_map, report))\n-        }\n-        Err(e) => Err((From::from(e), summary)),\n-    }\n-}\n-\n-fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n-\n-    match style {\n-        NewlineStyle::Unix => return,\n-        NewlineStyle::Windows => {\n-            let mut transformed = String::with_capacity(text.capacity());\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => transformed.push_str(\"\\r\\n\"),\n-                    '\\r' => continue,\n-                    c => transformed.push(c),\n-                }\n-            }\n-            *text = transformed;\n-        }\n-        NewlineStyle::Native => unreachable!(),\n-    }\n-}\n-\n-/// A single span of changed lines, with 0 or more removed lines\n-/// and a vector of 0 or more inserted lines.\n-#[derive(Debug, PartialEq, Eq)]\n-struct ModifiedChunk {\n-    /// The first to be removed from the original text\n-    pub line_number_orig: u32,\n-    /// The number of lines which have been replaced\n-    pub lines_removed: u32,\n-    /// The new lines\n-    pub lines: Vec<String>,\n-}\n-\n-/// Set of changed sections of a file.\n-#[derive(Debug, PartialEq, Eq)]\n-struct ModifiedLines {\n-    /// The set of changed chunks.\n-    pub chunks: Vec<ModifiedChunk>,\n-}\n-\n-/// Format a file and return a `ModifiedLines` data structure describing\n-/// the changed ranges of lines.\n-#[cfg(test)]\n-fn get_modified_lines(\n-    input: Input,\n-    config: &Config,\n-) -> Result<ModifiedLines, (ErrorKind, Summary)> {\n-    use std::io::BufRead;\n-\n-    let mut data = Vec::new();\n-\n-    let mut config = config.clone();\n-    config.set().emit_mode(config::EmitMode::ModifiedLines);\n-    format_input(input, &config, Some(&mut data))?;\n-\n-    let mut lines = data.lines();\n-    let mut chunks = Vec::new();\n-    while let Some(Ok(header)) = lines.next() {\n-        // Parse the header line\n-        let values: Vec<_> = header\n-            .split(' ')\n-            .map(|s| s.parse::<u32>().unwrap())\n-            .collect();\n-        assert_eq!(values.len(), 3);\n-        let line_number_orig = values[0];\n-        let lines_removed = values[1];\n-        let num_added = values[2];\n-        let mut added_lines = Vec::new();\n-        for _ in 0..num_added {\n-            added_lines.push(lines.next().unwrap().unwrap());\n-        }\n-        chunks.push(ModifiedChunk {\n-            line_number_orig,\n-            lines_removed,\n-            lines: added_lines,\n-        });\n-    }\n-    Ok(ModifiedLines { chunks })\n-}\n-\n #[cfg(test)]\n mod unit_tests {\n-    use super::{format_code_block, format_snippet, Config};\n+    use super::*;\n \n     #[test]\n     fn test_no_panic_on_format_snippet_and_format_code_block() {"}, {"sha": "b2eead3183dfe49be1872a527461421ec1a5bdea", "filename": "src/test/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4153e66e422fde262bac3d36b82e79af69d01f2d/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=4153e66e422fde262bac3d36b82e79af69d01f2d", "patch": "@@ -15,15 +15,17 @@ use syntax;\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs;\n-use std::io::{self, BufRead, BufReader, Read};\n+use std::io::{self, BufRead, BufReader, Read, Write};\n use std::iter::{Enumerate, Peekable};\n use std::path::{Path, PathBuf};\n use std::str::Chars;\n \n use config::summary::Summary;\n-use config::{Color, Config, ReportTactic};\n-use rustfmt_diff::*;\n-use *;\n+use config::{Color, Config, EmitMode, FileName, ReportTactic};\n+use filemap;\n+use formatting::{format_input_inner, get_modified_lines, FileMap, ModifiedChunk, ModifiedLines};\n+use rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, OutputWriter};\n+use {format_input, FormatReport, Input};\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";"}]}