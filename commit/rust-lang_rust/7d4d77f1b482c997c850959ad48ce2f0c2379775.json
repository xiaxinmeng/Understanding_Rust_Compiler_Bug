{"sha": "7d4d77f1b482c997c850959ad48ce2f0c2379775", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNGQ3N2YxYjQ4MmM5OTdjODUwOTU5YWQ0OGNlMmYwYzIzNzk3NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-20T08:08:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-20T08:08:48Z"}, "message": "Auto merge of #26305 - Nashenas88:field-method-message-2392, r=eddyb\n\nThis fixes #2392\r\n\r\nI'd like to thank @eddyb for helping me on this one! I wouldn't have gotten the complicated FnOnce check done without his help.", "tree": {"sha": "2c51fcca5abc9878298d7d4bc05e496dc75eef71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c51fcca5abc9878298d7d4bc05e496dc75eef71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d4d77f1b482c997c850959ad48ce2f0c2379775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4d77f1b482c997c850959ad48ce2f0c2379775", "html_url": "https://github.com/rust-lang/rust/commit/7d4d77f1b482c997c850959ad48ce2f0c2379775", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d4d77f1b482c997c850959ad48ce2f0c2379775/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd2151c701e64fa00e539957dabf40df820ee380", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2151c701e64fa00e539957dabf40df820ee380", "html_url": "https://github.com/rust-lang/rust/commit/dd2151c701e64fa00e539957dabf40df820ee380"}, {"sha": "bae1df65aaabf6129636364d86d918c76ed52b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bae1df65aaabf6129636364d86d918c76ed52b6b", "html_url": "https://github.com/rust-lang/rust/commit/bae1df65aaabf6129636364d86d918c76ed52b6b"}], "stats": {"total": 131, "additions": 124, "deletions": 7}, "files": [{"sha": "4fbe42455ae8685d1f13b92d2403fc2506747fe7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7d4d77f1b482c997c850959ad48ce2f0c2379775/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4d77f1b482c997c850959ad48ce2f0c2379775/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7d4d77f1b482c997c850959ad48ce2f0c2379775", "patch": "@@ -15,8 +15,11 @@ use CrateCtxt;\n \n use astconv::AstConv;\n use check::{self, FnCtxt};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, ToPolyTraitRef, AsPredicate};\n use middle::def;\n+use middle::lang_items::FnOnceTraitLangItem;\n+use middle::subst::Substs;\n+use middle::traits::{Obligation, SelectionContext};\n use metadata::{csearch, cstore, decoder};\n \n use syntax::{ast, ast_util};\n@@ -59,12 +62,58 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None);\n \n             // If the item has the name of a field, give a help note\n-            if let (&ty::TyStruct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n+            if let (&ty::TyStruct(did, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n                 let fields = ty::lookup_struct_fields(cx, did);\n-                if fields.iter().any(|f| f.name == item_name) {\n-                    cx.sess.span_note(span,\n-                        &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                                 function stored in the `{0}` field\", item_name));\n+\n+                if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n+                    let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n+                        Ok(expr_string) => expr_string,\n+                        _ => \"s\".into() // Default to a generic placeholder for the\n+                                        // expression when we can't generate a string\n+                                        // snippet\n+                    };\n+\n+                    let span_stored_function = || {\n+                        cx.sess.span_note(span,\n+                                          &format!(\"use `({0}.{1})(...)` if you meant to call \\\n+                                                    the function stored in the `{1}` field\",\n+                                                   expr_string, item_name));\n+                    };\n+\n+                    let span_did_you_mean = || {\n+                        cx.sess.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n+                                                         expr_string, item_name));\n+                    };\n+\n+                    // Determine if the field can be used as a function in some way\n+                    let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n+                    if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n+                        let infcx = fcx.infcx();\n+                        infcx.probe(|_| {\n+                            let fn_once_substs = Substs::new_trait(vec![infcx.next_ty_var()],\n+                                                                   Vec::new(),\n+                                                                   field_ty);\n+                            let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n+                                                              cx.mk_substs(fn_once_substs));\n+                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                            let obligation = Obligation::misc(span,\n+                                                              fcx.body_id,\n+                                                              poly_trait_ref.as_predicate());\n+                            let mut selcx = SelectionContext::new(infcx, fcx);\n+\n+                            if selcx.evaluate_obligation(&obligation) {\n+                                span_stored_function();\n+                            } else {\n+                                span_did_you_mean();\n+                            }\n+                        });\n+                    } else {\n+                        match field_ty.sty {\n+                            // fallback to matching a closure or function pointer\n+                            ty::TyClosure(..) | ty::TyBareFn(..) => span_stored_function(),\n+                            _ => span_did_you_mean(),\n+                        }\n+                    }\n                 }\n             }\n "}, {"sha": "4601db9dba0fc11fdc741eb0d9ce3702de4abf65", "filename": "src/test/compile-fail/issue-18343.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d4d77f1b482c997c850959ad48ce2f0c2379775/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4d77f1b482c997c850959ad48ce2f0c2379775/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs?ref=7d4d77f1b482c997c850959ad48ce2f0c2379775", "patch": "@@ -15,5 +15,5 @@ struct Obj<F> where F: FnMut() -> u32 {\n fn main() {\n     let o = Obj { closure: || 42 };\n     o.closure(); //~ ERROR no method named `closure` found\n-    //~^ NOTE use `(s.closure)(...)` if you meant to call the function stored in the `closure` field\n+    //~^ NOTE use `(o.closure)(...)` if you meant to call the function stored in the `closure` field\n }"}, {"sha": "c5598e8785cbd1766c2da85a0b2c8cc34e783af2", "filename": "src/test/compile-fail/issue-2392.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7d4d77f1b482c997c850959ad48ce2f0c2379775/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4d77f1b482c997c850959ad48ce2f0c2379775/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs?ref=7d4d77f1b482c997c850959ad48ce2f0c2379775", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+use std::boxed::FnBox;\n+\n+struct Obj<F> where F: FnOnce() -> u32 {\n+    closure: F,\n+    not_closure: usize,\n+}\n+\n+struct BoxedObj {\n+    boxed_closure: Box<FnBox() -> u32>,\n+}\n+\n+struct Wrapper<F> where F: FnMut() -> u32 {\n+    wrap: Obj<F>,\n+}\n+\n+fn func() -> u32 {\n+    0\n+}\n+\n+fn check_expression() -> Obj<Box<FnBox() -> u32>> {\n+    Obj { closure: Box::new(|| 42_u32) as Box<FnBox() -> u32>, not_closure: 42 }\n+}\n+\n+fn main() {\n+    // test variations of function\n+\n+    let o_closure = Obj { closure: || 42, not_closure: 42 };\n+    o_closure.closure(); //~ ERROR no method named `closure` found\n+    //~^ NOTE use `(o_closure.closure)(...)` if you meant to call the function stored\n+\n+    o_closure.not_closure(); //~ ERROR no method named `not_closure` found\n+    //~^ NOTE did you mean to write `o_closure.not_closure`?\n+\n+    let o_func = Obj { closure: func, not_closure: 5 };\n+    o_func.closure(); //~ ERROR no method named `closure` found\n+    //~^ NOTE use `(o_func.closure)(...)` if you meant to call the function stored\n+\n+    let boxed_fn = BoxedObj { boxed_closure: Box::new(func) };\n+    boxed_fn.boxed_closure();//~ ERROR no method named `boxed_closure` found\n+    //~^ NOTE use `(boxed_fn.boxed_closure)(...)` if you meant to call the function stored\n+\n+    let boxed_closure = BoxedObj { boxed_closure: Box::new(|| 42_u32) as Box<FnBox() -> u32> };\n+    boxed_closure.boxed_closure();//~ ERROR no method named `boxed_closure` found\n+    //~^ NOTE use `(boxed_closure.boxed_closure)(...)` if you meant to call the function stored\n+\n+    // test expression writing in the notes\n+\n+    let w = Wrapper { wrap: o_func };\n+    w.wrap.closure();//~ ERROR no method named `closure` found\n+    //~^ NOTE use `(w.wrap.closure)(...)` if you meant to call the function stored\n+\n+    w.wrap.not_closure();//~ ERROR no method named `not_closure` found\n+    //~^ NOTE did you mean to write `w.wrap.not_closure`?\n+\n+    check_expression().closure();//~ ERROR no method named `closure` found\n+    //~^ NOTE use `(check_expression().closure)(...)` if you meant to call the function stored\n+}"}]}