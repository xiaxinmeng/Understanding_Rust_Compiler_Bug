{"sha": "b3321e286013f14e20241706ef738d868fe7e91d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMzIxZTI4NjAxM2YxNGUyMDI0MTcwNmVmNzM4ZDg2OGZlN2U5MWQ=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-03-25T01:43:18Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-03-25T01:43:18Z"}, "message": "Add docs for Vec::from functions\n\nPart of #51430", "tree": {"sha": "c89f30c8daeb45c4d17eaf52e61abbfbf9df7bb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c89f30c8daeb45c4d17eaf52e61abbfbf9df7bb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3321e286013f14e20241706ef738d868fe7e91d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3321e286013f14e20241706ef738d868fe7e91d", "html_url": "https://github.com/rust-lang/rust/commit/b3321e286013f14e20241706ef738d868fe7e91d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3321e286013f14e20241706ef738d868fe7e91d/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07e0e2ec268c140e607e1ac7f49f145612d0f597", "url": "https://api.github.com/repos/rust-lang/rust/commits/07e0e2ec268c140e607e1ac7f49f145612d0f597", "html_url": "https://github.com/rust-lang/rust/commit/07e0e2ec268c140e607e1ac7f49f145612d0f597"}], "stats": {"total": 61, "additions": 61, "deletions": 0}, "files": [{"sha": "69df60a7c3e184f6d7a9e42a4189d5d7d1b593be", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b3321e286013f14e20241706ef738d868fe7e91d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3321e286013f14e20241706ef738d868fe7e91d/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=b3321e286013f14e20241706ef738d868fe7e91d", "patch": "@@ -2712,6 +2712,13 @@ impl<T, A: Allocator> AsMut<[T]> for Vec<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> From<&[T]> for Vec<T> {\n+    /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Vec::from(&[1, 2, 3][..]), vec![1, 2, 3]);\n+    /// ```\n     #[cfg(not(test))]\n     fn from(s: &[T]) -> Vec<T> {\n         s.to_vec()\n@@ -2724,6 +2731,13 @@ impl<T: Clone> From<&[T]> for Vec<T> {\n \n #[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\n impl<T: Clone> From<&mut [T]> for Vec<T> {\n+    /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Vec::from(&mut [1, 2, 3][..]), vec![1, 2, 3]);\n+    /// ```\n     #[cfg(not(test))]\n     fn from(s: &mut [T]) -> Vec<T> {\n         s.to_vec()\n@@ -2740,6 +2754,13 @@ impl<T, const N: usize> From<[T; N]> for Vec<T> {\n     fn from(s: [T; N]) -> Vec<T> {\n         <[T]>::into_vec(box s)\n     }\n+    /// Allocate a `Vec<T>` and move `s`'s items into it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Vec::from([1, 2, 3]), vec![1, 2, 3]);\n+    /// ```\n     #[cfg(test)]\n     fn from(s: [T; N]) -> Vec<T> {\n         crate::slice::into_vec(box s)\n@@ -2751,6 +2772,20 @@ impl<'a, T> From<Cow<'a, [T]>> for Vec<T>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n+    /// Convert a clone-on-write slice into a vector.\n+    ///\n+    /// If `s` already owns a `Vec<T>`, it will be returned directly.\n+    /// If `s` is borrowing a slice, a new `Vec<T>` will be allocated and\n+    /// filled by cloning `s`'s items into it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # use std::borrow::Cow;\n+    /// let o: Cow<[i32]> = Cow::Owned(vec![1, 2, 3]);\n+    /// let b: Cow<[i32]> = Cow::Borrowed(&[1, 2, 3]);\n+    /// assert_eq!(Vec::from(o), Vec::from(b));\n+    /// ```\n     fn from(s: Cow<'a, [T]>) -> Vec<T> {\n         s.into_owned()\n     }\n@@ -2760,6 +2795,15 @@ where\n #[cfg(not(test))]\n #[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\n impl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n+    /// Convert a boxed slice into a vector.\n+    /// No heap allocation is performed, and the items are not copied.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let b: Box<[i32]> = vec![1, 2, 3].into_boxed_slice();\n+    /// assert_eq!(Vec::from(b), vec![1, 2, 3]);\n+    /// ```\n     fn from(s: Box<[T], A>) -> Self {\n         let len = s.len();\n         Self { buf: RawVec::from_box(s), len }\n@@ -2770,13 +2814,30 @@ impl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n #[cfg(not(test))]\n #[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\n impl<T, A: Allocator> From<Vec<T, A>> for Box<[T], A> {\n+    /// Convert a vector into a boxed slice.\n+    ///\n+    /// If `v` has excess capacity, its items will be moved into a\n+    /// newly-allocated buffer with exactly the right capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Box::from(vec![1, 2, 3]), vec![1, 2, 3].into_boxed_slice());\n+    /// ```\n     fn from(v: Vec<T, A>) -> Self {\n         v.into_boxed_slice()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<&str> for Vec<u8> {\n+    /// Allocate a `Vec<u8>` and fill it with a UTF-8 string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(Vec::from(\"123\"), vec![b'1', b'2', b'3']);\n+    /// ```\n     fn from(s: &str) -> Vec<u8> {\n         From::from(s.as_bytes())\n     }"}]}