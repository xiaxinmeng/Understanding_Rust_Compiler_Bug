{"sha": "3fe4023370a50d89227c4d2f645f868ac753656f", "node_id": "C_kwDOAAsO6NoAKDNmZTQwMjMzNzBhNTBkODkyMjdjNGQyZjY0NWY4NjhhYzc1MzY1NmY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-27T17:48:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-27T17:48:48Z"}, "message": "Rollup merge of #107110 - strega-nil:mbtwc-wctmb, r=ChrisDenton\n\n[stdio][windows] Use MBTWC and WCTMB\n\n`MultiByteToWideChar` and `WideCharToMultiByte` are extremely well optimized, and therefore should probably be used when we know we can (specifically in the Windows stdio stuff).\n\nFixes #107092", "tree": {"sha": "de10db6cc4159ff3525b2761432f1b70f7bd70bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de10db6cc4159ff3525b2761432f1b70f7bd70bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fe4023370a50d89227c4d2f645f868ac753656f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj/O0ACRBK7hj4Ov3rIwAANiIIAKU/porcPlQsWZ9VgzoXJ8F8\nMvW2481e7ChGYgJqi94l/8xuGbYVrSBUw7U97nkUsr21C5H/jpPIRfbBFm2+IMhc\nbmrxutj5pQdWNAGi3QWsSy5R+PFG8SCDIyZSyTw1O+xGLdXqz8B5YdFBFoFAX/ou\nw5Oavv00y2eNZJbEsRhltmvDXOdLuUngcYEv/kbYwjoy4QU6GG+cu4pA7ZqAXIjl\nQhvesx17s1zf8RJ49flri03E8ouIQ/pDCVkTc4mYXTpk8vpz1Fh8dS7Tb7mUNfNH\nASauwwvaBle56NjhdLu6TiyDO5AZ4JVU4xPRWNIm8kIYAWiNjdAp9L3eDT6jcJM=\n=oGVv\n-----END PGP SIGNATURE-----\n", "payload": "tree de10db6cc4159ff3525b2761432f1b70f7bd70bb\nparent cf04603dca6c37366fb010a36dd05047f7b70b1e\nparent 7f25580512a3466e1cb90253cb3806acb50063a5\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677520128 +0100\ncommitter GitHub <noreply@github.com> 1677520128 +0100\n\nRollup merge of #107110 - strega-nil:mbtwc-wctmb, r=ChrisDenton\n\n[stdio][windows] Use MBTWC and WCTMB\n\n`MultiByteToWideChar` and `WideCharToMultiByte` are extremely well optimized, and therefore should probably be used when we know we can (specifically in the Windows stdio stuff).\n\nFixes #107092\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe4023370a50d89227c4d2f645f868ac753656f", "html_url": "https://github.com/rust-lang/rust/commit/3fe4023370a50d89227c4d2f645f868ac753656f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fe4023370a50d89227c4d2f645f868ac753656f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf04603dca6c37366fb010a36dd05047f7b70b1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf04603dca6c37366fb010a36dd05047f7b70b1e", "html_url": "https://github.com/rust-lang/rust/commit/cf04603dca6c37366fb010a36dd05047f7b70b1e"}, {"sha": "7f25580512a3466e1cb90253cb3806acb50063a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f25580512a3466e1cb90253cb3806acb50063a5", "html_url": "https://github.com/rust-lang/rust/commit/7f25580512a3466e1cb90253cb3806acb50063a5"}], "stats": {"total": 107, "additions": 78, "deletions": 29}, "files": [{"sha": "b62f3ad29d3713f1c8190a20fdb3e6f47c1297c6", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fe4023370a50d89227c4d2f645f868ac753656f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe4023370a50d89227c4d2f645f868ac753656f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3fe4023370a50d89227c4d2f645f868ac753656f", "patch": "@@ -232,6 +232,7 @@\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n+#![cfg_attr(windows, feature(round_char_boundary))]\n //\n // Language features:\n #![feature(alloc_error_handler)]"}, {"sha": "5d150eca00ed8361d594b932dee55e2606b3b13e", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fe4023370a50d89227c4d2f645f868ac753656f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe4023370a50d89227c4d2f645f868ac753656f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=3fe4023370a50d89227c4d2f645f868ac753656f", "patch": "@@ -6,13 +6,15 @@\n \n use crate::ffi::CStr;\n use crate::mem;\n-use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n+use crate::os::raw::{c_char, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::os::windows::io::{BorrowedHandle, HandleOrInvalid, HandleOrNull};\n use crate::ptr;\n use core::ffi::NonZero_c_ulong;\n \n use libc::{c_void, size_t, wchar_t};\n \n+pub use crate::os::raw::c_int;\n+\n #[path = \"c/errors.rs\"] // c.rs is included from two places so we need to specify this\n mod errors;\n pub use errors::*;\n@@ -47,16 +49,19 @@ pub type ACCESS_MASK = DWORD;\n \n pub type LPBOOL = *mut BOOL;\n pub type LPBYTE = *mut BYTE;\n+pub type LPCCH = *const CHAR;\n pub type LPCSTR = *const CHAR;\n+pub type LPCWCH = *const WCHAR;\n pub type LPCWSTR = *const WCHAR;\n+pub type LPCVOID = *const c_void;\n pub type LPDWORD = *mut DWORD;\n pub type LPHANDLE = *mut HANDLE;\n pub type LPOVERLAPPED = *mut OVERLAPPED;\n pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n pub type LPSTARTUPINFO = *mut STARTUPINFO;\n+pub type LPSTR = *mut CHAR;\n pub type LPVOID = *mut c_void;\n-pub type LPCVOID = *const c_void;\n pub type LPWCH = *mut WCHAR;\n pub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\n pub type LPWSADATA = *mut WSADATA;\n@@ -132,6 +137,10 @@ pub const MAX_PATH: usize = 260;\n \n pub const FILE_TYPE_PIPE: u32 = 3;\n \n+pub const CP_UTF8: DWORD = 65001;\n+pub const MB_ERR_INVALID_CHARS: DWORD = 0x08;\n+pub const WC_ERR_INVALID_CHARS: DWORD = 0x80;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {\n@@ -1147,6 +1156,25 @@ extern \"system\" {\n         lpFilePart: *mut LPWSTR,\n     ) -> DWORD;\n     pub fn GetFileAttributesW(lpFileName: LPCWSTR) -> DWORD;\n+\n+    pub fn MultiByteToWideChar(\n+        CodePage: UINT,\n+        dwFlags: DWORD,\n+        lpMultiByteStr: LPCCH,\n+        cbMultiByte: c_int,\n+        lpWideCharStr: LPWSTR,\n+        cchWideChar: c_int,\n+    ) -> c_int;\n+    pub fn WideCharToMultiByte(\n+        CodePage: UINT,\n+        dwFlags: DWORD,\n+        lpWideCharStr: LPCWCH,\n+        cchWideChar: c_int,\n+        lpMultiByteStr: LPSTR,\n+        cbMultiByte: c_int,\n+        lpDefaultChar: LPCCH,\n+        lpUsedDefaultChar: LPBOOL,\n+    ) -> c_int;\n }\n \n #[link(name = \"ws2_32\")]"}, {"sha": "32c6ccffb7a7324f8d760a16c4284afc5032d142", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3fe4023370a50d89227c4d2f645f868ac753656f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe4023370a50d89227c4d2f645f868ac753656f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=3fe4023370a50d89227c4d2f645f868ac753656f", "patch": "@@ -169,14 +169,27 @@ fn write(\n }\n \n fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usize> {\n+    debug_assert!(!utf8.is_empty());\n+\n     let mut utf16 = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];\n-    let mut len_utf16 = 0;\n-    for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n-        *dest = MaybeUninit::new(chr);\n-        len_utf16 += 1;\n-    }\n-    // Safety: We've initialized `len_utf16` values.\n-    let utf16: &[u16] = unsafe { MaybeUninit::slice_assume_init_ref(&utf16[..len_utf16]) };\n+    let utf8 = &utf8[..utf8.floor_char_boundary(utf16.len())];\n+\n+    let utf16: &[u16] = unsafe {\n+        // Note that this theoretically checks validity twice in the (most common) case\n+        // where the underlying byte sequence is valid utf-8 (given the check in `write()`).\n+        let result = c::MultiByteToWideChar(\n+            c::CP_UTF8,                      // CodePage\n+            c::MB_ERR_INVALID_CHARS,         // dwFlags\n+            utf8.as_ptr() as c::LPCCH,       // lpMultiByteStr\n+            utf8.len() as c::c_int,          // cbMultiByte\n+            utf16.as_mut_ptr() as c::LPWSTR, // lpWideCharStr\n+            utf16.len() as c::c_int,         // cchWideChar\n+        );\n+        assert!(result != 0, \"Unexpected error in MultiByteToWideChar\");\n+\n+        // Safety: MultiByteToWideChar initializes `result` values.\n+        MaybeUninit::slice_assume_init_ref(&utf16[..result as usize])\n+    };\n \n     let mut written = write_u16s(handle, &utf16)?;\n \n@@ -189,8 +202,8 @@ fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usiz\n         // a missing surrogate can be produced (and also because of the UTF-8 validation above),\n         // write the missing surrogate out now.\n         // Buffering it would mean we have to lie about the number of bytes written.\n-        let first_char_remaining = utf16[written];\n-        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF {\n+        let first_code_unit_remaining = utf16[written];\n+        if first_code_unit_remaining >= 0xDCEE && first_code_unit_remaining <= 0xDFFF {\n             // low surrogate\n             // We just hope this works, and give up otherwise\n             let _ = write_u16s(handle, &utf16[written..written + 1]);\n@@ -212,6 +225,7 @@ fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usiz\n }\n \n fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n+    debug_assert!(data.len() < u32::MAX as usize);\n     let mut written = 0;\n     cvt(unsafe {\n         c::WriteConsoleW(\n@@ -365,26 +379,32 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usiz\n     Ok(amount as usize)\n }\n \n-#[allow(unused)]\n fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n-    let mut written = 0;\n-    for chr in char::decode_utf16(utf16.iter().cloned()) {\n-        match chr {\n-            Ok(chr) => {\n-                chr.encode_utf8(&mut utf8[written..]);\n-                written += chr.len_utf8();\n-            }\n-            Err(_) => {\n-                // We can't really do any better than forget all data and return an error.\n-                return Err(io::const_io_error!(\n-                    io::ErrorKind::InvalidData,\n-                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n-                     encountered unpaired surrogate\",\n-                ));\n-            }\n-        }\n+    debug_assert!(utf16.len() <= c::c_int::MAX as usize);\n+    debug_assert!(utf8.len() <= c::c_int::MAX as usize);\n+\n+    let result = unsafe {\n+        c::WideCharToMultiByte(\n+            c::CP_UTF8,                    // CodePage\n+            c::WC_ERR_INVALID_CHARS,       // dwFlags\n+            utf16.as_ptr(),                // lpWideCharStr\n+            utf16.len() as c::c_int,       // cchWideChar\n+            utf8.as_mut_ptr() as c::LPSTR, // lpMultiByteStr\n+            utf8.len() as c::c_int,        // cbMultiByte\n+            ptr::null(),                   // lpDefaultChar\n+            ptr::null_mut(),               // lpUsedDefaultChar\n+        )\n+    };\n+    if result == 0 {\n+        // We can't really do any better than forget all data and return an error.\n+        Err(io::const_io_error!(\n+            io::ErrorKind::InvalidData,\n+            \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+            encountered unpaired surrogate\",\n+        ))\n+    } else {\n+        Ok(result as usize)\n     }\n-    Ok(written)\n }\n \n impl IncompleteUtf8 {"}]}