{"sha": "21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "node_id": "C_kwDOAAsO6NoAKDIxZWUwM2UwNjIxYzcwYjg5NGUxYmZkZDhjODJiYTVhZWFhYmM4MTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-13T22:05:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-13T22:05:28Z"}, "message": "Auto merge of #105667 - matthiaskrgr:rollup-fexlc0b, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #105147 (Allow unsafe through inline const)\n - #105438 (Move some codegen-y methods from `rustc_hir_analysis::collect` -> `rustc_codegen_ssa`)\n - #105464 (Support #[track_caller] on async closures)\n - #105476 (Change pattern borrowing suggestions to be verbose and remove invalid suggestion)\n - #105500 (Make some diagnostics not depend on the source of what they reference being available)\n - #105628 (Small doc fixes)\n - #105659 (Don't require owned data in `MaybeStorageLive`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5f852d4bd1f946791f801be0b25b69aa051c9148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f852d4bd1f946791f801be0b25b69aa051c9148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "html_url": "https://github.com/rust-lang/rust/commit/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f529f0f49f4dd404b78e605398531c96f220fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f529f0f49f4dd404b78e605398531c96f220fc5", "html_url": "https://github.com/rust-lang/rust/commit/0f529f0f49f4dd404b78e605398531c96f220fc5"}, {"sha": "e0e9f3a7b79663154e33aa2853c5bd555eb7b129", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e9f3a7b79663154e33aa2853c5bd555eb7b129", "html_url": "https://github.com/rust-lang/rust/commit/e0e9f3a7b79663154e33aa2853c5bd555eb7b129"}], "stats": {"total": 6795, "additions": 3398, "deletions": 3397}, "files": [{"sha": "e86e807279d6f10157264705e42e49c8b8c872d0", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -31,6 +31,44 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n+            match &e.kind {\n+                // Paranthesis expression does not have a HirId and is handled specially.\n+                ExprKind::Paren(ex) => {\n+                    let mut ex = self.lower_expr_mut(ex);\n+                    // Include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = self.lower_span(e.span);\n+                    }\n+                    // Merge attributes into the inner expression.\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs =\n+                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id.local_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n+                    return ex;\n+                }\n+                // Desugar `ExprForLoop`\n+                // from: `[opt_ident]: for <pat> in <head> <body>`\n+                //\n+                // This also needs special handling because the HirId of the returned `hir::Expr` will not\n+                // correspond to the `e.id`, so `lower_expr_for` handles attribute lowering itself.\n+                ExprKind::ForLoop(pat, head, body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n+                }\n+                _ => (),\n+            }\n+\n+            let hir_id = self.lower_node_id(e.id);\n+            self.lower_attrs(hir_id, &e.attrs);\n+\n             let kind = match &e.kind {\n                 ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n                 ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n@@ -48,7 +86,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n                         if let [inner] = &args[..] && e.attrs.len() == 1 {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n-                            let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n                             self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n@@ -147,7 +184,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ),\n                 ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n                     *capture_clause,\n-                    None,\n+                    hir_id,\n                     *closure_node_id,\n                     None,\n                     e.span,\n@@ -184,6 +221,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             binder,\n                             *capture_clause,\n                             e.id,\n+                            hir_id,\n                             *closure_id,\n                             fn_decl,\n                             body,\n@@ -279,39 +317,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n                 ExprKind::Err => hir::ExprKind::Err,\n                 ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-                ExprKind::Paren(ex) => {\n-                    let mut ex = self.lower_expr_mut(ex);\n-                    // Include parens in span, but only if it is a super-span.\n-                    if e.span.contains(ex.span) {\n-                        ex.span = self.lower_span(e.span);\n-                    }\n-                    // Merge attributes into the inner expression.\n-                    if !e.attrs.is_empty() {\n-                        let old_attrs =\n-                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n-                        self.attrs.insert(\n-                            ex.hir_id.local_id,\n-                            &*self.arena.alloc_from_iter(\n-                                e.attrs\n-                                    .iter()\n-                                    .map(|a| self.lower_attr(a))\n-                                    .chain(old_attrs.iter().cloned()),\n-                            ),\n-                        );\n-                    }\n-                    return ex;\n-                }\n \n-                // Desugar `ExprForLoop`\n-                // from: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprKind::ForLoop(pat, head, body, opt_label) => {\n-                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n-                }\n+                ExprKind::Paren(_) | ExprKind::ForLoop(..) => unreachable!(\"already handled\"),\n+\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n \n-            let hir_id = self.lower_node_id(e.id);\n-            self.lower_attrs(hir_id, &e.attrs);\n             hir::Expr { hir_id, kind, span: self.lower_span(e.span) }\n         })\n     }\n@@ -576,7 +587,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n-        outer_hir_id: Option<hir::HirId>,\n+        outer_hir_id: hir::HirId,\n         closure_node_id: NodeId,\n         ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n@@ -669,8 +680,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::ExprKind::Closure(c)\n         };\n \n-        let track_caller = outer_hir_id\n-            .and_then(|id| self.attrs.get(&id.local_id))\n+        let track_caller = self\n+            .attrs\n+            .get(&outer_hir_id.local_id)\n             .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n \n         let hir_id = self.lower_node_id(closure_node_id);\n@@ -985,6 +997,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         binder: &ClosureBinder,\n         capture_clause: CaptureBy,\n         closure_id: NodeId,\n+        closure_hir_id: hir::HirId,\n         inner_closure_id: NodeId,\n         decl: &FnDecl,\n         body: &Expr,\n@@ -1018,9 +1031,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 let async_body = this.make_async_expr(\n                     capture_clause,\n-                    // FIXME(nbdd0121): This should also use a proper HIR id so `#[track_caller]`\n-                    // can be applied on async closures as well.\n-                    None,\n+                    closure_hir_id,\n                     inner_closure_id,\n                     async_ret_ty,\n                     body.span,"}, {"sha": "73065ab516350fe33c50fae50de39a228278340f", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1139,7 +1139,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n-                Some(fn_id),\n+                fn_id,\n                 closure_id,\n                 None,\n                 body.span,"}, {"sha": "cbd590052008c14a46f3ab0b099ea517ef6f7ce9", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1059,17 +1059,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                     if self.fn_self_span_reported.insert(fn_span) {\n                         err.span_note(\n-                            // Check whether the source is accessible\n-                            if self.infcx.tcx.sess.source_map().is_span_accessible(self_arg.span) {\n-                                self_arg.span\n-                            } else {\n-                                fn_call_span\n-                            },\n+                            self_arg.span,\n                             \"calling this operator moves the left-hand side\",\n                         );\n                     }\n                 }\n-                CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n+                CallKind::Normal { self_arg, desugaring, method_did } => {\n                     let self_arg = self_arg.unwrap();\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n@@ -1139,14 +1134,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ),\n                         );\n                     }\n+                    let tcx = self.infcx.tcx;\n                     // Avoid pointing to the same function in multiple different\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n+                        let func = tcx.def_path_str(method_did);\n                         err.span_note(\n                             self_arg.span,\n-                            &format!(\"this function takes ownership of the receiver `self`, which moves {}\", place_name)\n+                            &format!(\"`{func}` takes ownership of the receiver `self`, which moves {place_name}\")\n                         );\n                     }\n+                    let parent_did = tcx.parent(method_did);\n+                    let parent_self_ty = (tcx.def_kind(parent_did)\n+                        == rustc_hir::def::DefKind::Impl)\n+                        .then_some(parent_did)\n+                        .and_then(|did| match tcx.type_of(did).kind() {\n+                            ty::Adt(def, ..) => Some(def.did()),\n+                            _ => None,\n+                        });\n+                    let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+                        matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n+                    });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {\n                         err.span_label(\n                             var_span,"}, {"sha": "6db3c858ae7149b9a138dbd77c7813c3eeea298e", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::ty;\n use rustc_mir_dataflow::move_paths::{\n     IllegalMoveOrigin, IllegalMoveOriginKind, LookupResult, MoveError, MovePathIndex,\n };\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span};\n \n use crate::diagnostics::{DescribePlaceOpt, UseSpans};\n use crate::prefixes::PrefixSet;\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         match_span: Span,\n         statement_span: Span,\n     ) {\n-        debug!(\"append_binding_error(match_place={:?}, match_span={:?})\", match_place, match_span);\n+        debug!(?match_place, ?match_span, \"append_binding_error\");\n \n         let from_simple_let = match_place.is_none();\n         let match_place = match_place.unwrap_or(move_from);\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let GroupedMoveError::MovesFromPlace { span, binds_to, .. } = ge\n                         && match_span == *span\n                     {\n-                        debug!(\"appending local({:?}) to list\", bind_to);\n+                        debug!(\"appending local({bind_to:?}) to list\");\n                         if !binds_to.is_empty() {\n                             binds_to.push(bind_to);\n                         }\n@@ -198,7 +198,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     } = ge\n                     {\n                         if match_span == *span && mpi == *other_mpi {\n-                            debug!(\"appending local({:?}) to list\", bind_to);\n+                            debug!(\"appending local({bind_to:?}) to list\");\n                             binds_to.push(bind_to);\n                             return;\n                         }\n@@ -410,15 +410,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn add_move_hints(&self, error: GroupedMoveError<'tcx>, err: &mut Diagnostic, span: Span) {\n         match error {\n             GroupedMoveError::MovesFromPlace { mut binds_to, move_from, .. } => {\n-                if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider borrowing here\",\n-                        format!(\"&{snippet}\"),\n-                        Applicability::Unspecified,\n-                    );\n-                }\n-\n+                self.add_borrow_suggestions(err, span);\n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n@@ -461,39 +453,75 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn add_borrow_suggestions(&self, err: &mut Diagnostic, span: Span) {\n+        match self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+            Ok(snippet) if snippet.starts_with('*') => {\n+                err.span_suggestion_verbose(\n+                    span.with_hi(span.lo() + BytePos(1)),\n+                    \"consider removing the dereference here\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            _ => {\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_lo(),\n+                    \"consider borrowing here\",\n+                    \"&\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+\n     fn add_move_error_suggestions(&self, err: &mut Diagnostic, binds_to: &[Local]) {\n-        let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n+        let mut suggestions: Vec<(Span, String, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n             if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                 VarBindingForm { pat_span, .. },\n             )))) = bind_to.local_info\n             {\n-                if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n+                let Ok(pat_snippet) =\n+                    self.infcx.tcx.sess.source_map().span_to_snippet(pat_span) else { continue; };\n+                let Some(stripped) = pat_snippet.strip_prefix('&') else {\n+                    suggestions.push((\n+                        bind_to.source_info.span.shrink_to_lo(),\n+                        \"consider borrowing the pattern binding\".to_string(),\n+                        \"ref \".to_string(),\n+                    ));\n+                    continue;\n+                };\n+                let inner_pat_snippet = stripped.trim_start();\n+                let (pat_span, suggestion, to_remove) = if inner_pat_snippet.starts_with(\"mut\")\n+                    && inner_pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                 {\n-                    if let Some(stripped) = pat_snippet.strip_prefix('&') {\n-                        let pat_snippet = stripped.trim_start();\n-                        let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n-                            && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n-                        {\n-                            (pat_snippet[\"mut\".len()..].trim_start(), \"&mut\")\n-                        } else {\n-                            (pat_snippet, \"&\")\n-                        };\n-                        suggestions.push((pat_span, to_remove, suggestion.to_owned()));\n-                    }\n-                }\n+                    let inner_pat_snippet = inner_pat_snippet[\"mut\".len()..].trim_start();\n+                    let pat_span = pat_span.with_hi(\n+                        pat_span.lo()\n+                            + BytePos((pat_snippet.len() - inner_pat_snippet.len()) as u32),\n+                    );\n+                    (pat_span, String::new(), \"mutable borrow\")\n+                } else {\n+                    let pat_span = pat_span.with_hi(\n+                        pat_span.lo()\n+                            + BytePos(\n+                                (pat_snippet.len() - inner_pat_snippet.trim_start().len()) as u32,\n+                            ),\n+                    );\n+                    (pat_span, String::new(), \"borrow\")\n+                };\n+                suggestions.push((\n+                    pat_span,\n+                    format!(\"consider removing the {to_remove}\"),\n+                    suggestion.to_string(),\n+                ));\n             }\n         }\n         suggestions.sort_unstable_by_key(|&(span, _, _)| span);\n         suggestions.dedup_by_key(|&mut (span, _, _)| span);\n-        for (span, to_remove, suggestion) in suggestions {\n-            err.span_suggestion(\n-                span,\n-                &format!(\"consider removing the `{to_remove}`\"),\n-                suggestion,\n-                Applicability::MachineApplicable,\n-            );\n+        for (span, msg, suggestion) in suggestions {\n+            err.span_suggestion_verbose(span, &msg, suggestion, Applicability::MachineApplicable);\n         }\n     }\n \n@@ -521,8 +549,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         if binds_to.len() > 1 {\n             err.note(\n-                \"move occurs because these variables have types that \\\n-                      don't implement the `Copy` trait\",\n+                \"move occurs because these variables have types that don't implement the `Copy` \\\n+                 trait\",\n             );\n         }\n     }"}, {"sha": "c7f2e1966c1edfb271c9ce884ebcca932c3c0827", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,688 @@\n+use rustc_ast::{ast, MetaItemKind, NestedMetaItem};\n+use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::{lang_items, weak_lang_items::WEAK_LANG_ITEMS, LangItem};\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::mir::mono::Linkage;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self as ty, DefIdTree, TyCtxt};\n+use rustc_session::{lint, parse::feature_err};\n+use rustc_span::{sym, Span};\n+use rustc_target::spec::{abi, SanitizerSet};\n+\n+use crate::target_features::from_target_feature;\n+use crate::{errors::ExpectedUsedSymbol, target_features::check_target_feature_trait_unsafe};\n+\n+fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n+    use rustc_middle::mir::mono::Linkage::*;\n+\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but allow them anyway and trust that the\n+    // user knows what they're doing. Who knows, unanticipated use cases may pop\n+    // up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Appending,\n+        \"available_externally\" => AvailableExternally,\n+        \"common\" => Common,\n+        \"extern_weak\" => ExternalWeak,\n+        \"external\" => External,\n+        \"internal\" => Internal,\n+        \"linkonce\" => LinkOnceAny,\n+        \"linkonce_odr\" => LinkOnceODR,\n+        \"private\" => Private,\n+        \"weak\" => WeakAny,\n+        \"weak_odr\" => WeakODR,\n+        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n+    }\n+}\n+\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n+    if cfg!(debug_assertions) {\n+        let def_kind = tcx.def_kind(did);\n+        assert!(\n+            def_kind.has_codegen_attrs(),\n+            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n+        );\n+    }\n+\n+    let did = did.expect_local();\n+    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n+    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n+    if tcx.should_inherit_track_caller(did) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+    }\n+\n+    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n+\n+    let mut inline_span = None;\n+    let mut link_ordinal_span = None;\n+    let mut no_sanitize_span = None;\n+    for attr in attrs.iter() {\n+        if attr.has_name(sym::cold) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n+        } else if attr.has_name(sym::rustc_allocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n+        } else if attr.has_name(sym::ffi_returns_twice) {\n+            if tcx.is_foreign_item(did) {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n+            } else {\n+                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0724,\n+                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::ffi_pure) {\n+            if tcx.is_foreign_item(did) {\n+                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n+                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0757,\n+                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n+                    )\n+                    .emit();\n+                } else {\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n+                }\n+            } else {\n+                // `#[ffi_pure]` is only allowed on foreign functions\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0755,\n+                    \"`#[ffi_pure]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::ffi_const) {\n+            if tcx.is_foreign_item(did) {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n+            } else {\n+                // `#[ffi_const]` is only allowed on foreign functions\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0756,\n+                    \"`#[ffi_const]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::rustc_nounwind) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        } else if attr.has_name(sym::rustc_reallocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n+        } else if attr.has_name(sym::rustc_deallocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n+        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n+        } else if attr.has_name(sym::naked) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n+        } else if attr.has_name(sym::no_mangle) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+        } else if attr.has_name(sym::no_coverage) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+        } else if attr.has_name(sym::used) {\n+            let inner = attr.meta_item_list();\n+            match inner.as_deref() {\n+                Some([item]) if item.has_name(sym::linker) => {\n+                    if !tcx.features().used_with_arg {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::used_with_arg,\n+                            attr.span,\n+                            \"`#[used(linker)]` is currently unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n+                }\n+                Some([item]) if item.has_name(sym::compiler) => {\n+                    if !tcx.features().used_with_arg {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::used_with_arg,\n+                            attr.span,\n+                            \"`#[used(compiler)]` is currently unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n+                }\n+                Some(_) => {\n+                    tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n+                }\n+                None => {\n+                    // Unfortunately, unconditionally using `llvm.used` causes\n+                    // issues in handling `.init_array` with the gold linker,\n+                    // but using `llvm.compiler.used` caused a nontrival amount\n+                    // of unintentional ecosystem breakage -- particularly on\n+                    // Mach-O targets.\n+                    //\n+                    // As a result, we emit `llvm.compiler.used` only on ELF\n+                    // targets. This is somewhat ad-hoc, but actually follows\n+                    // our pre-LLVM 13 behavior (prior to the ecosystem\n+                    // breakage), and seems to match `clang`'s behavior as well\n+                    // (both before and after LLVM 13), possibly because they\n+                    // have similar compatibility concerns to us. See\n+                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n+                    // and following comments for some discussion of this, as\n+                    // well as the comments in `rustc_codegen_llvm` where these\n+                    // flags are handled.\n+                    //\n+                    // Anyway, to be clear: this is still up in the air\n+                    // somewhat, and is subject to change in the future (which\n+                    // is a good thing, because this would ideally be a bit\n+                    // more firmed up).\n+                    let is_like_elf = !(tcx.sess.target.is_like_osx\n+                        || tcx.sess.target.is_like_windows\n+                        || tcx.sess.target.is_like_wasm);\n+                    codegen_fn_attrs.flags |= if is_like_elf {\n+                        CodegenFnAttrFlags::USED\n+                    } else {\n+                        CodegenFnAttrFlags::USED_LINKER\n+                    };\n+                }\n+            }\n+        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n+            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0776,\n+                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n+                )\n+                .emit();\n+            }\n+            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n+                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n+                    .emit();\n+            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n+        } else if attr.has_name(sym::thread_local) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n+        } else if attr.has_name(sym::track_caller) {\n+            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n+                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n+                    .emit();\n+            }\n+            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    sym::closure_track_caller,\n+                    attr.span,\n+                    \"`#[track_caller]` on closures is currently unstable\",\n+                )\n+                .emit();\n+            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+        } else if attr.has_name(sym::export_name) {\n+            if let Some(s) = attr.value_str() {\n+                if s.as_str().contains('\\0') {\n+                    // `#[export_name = ...]` will be converted to a null-terminated string,\n+                    // so it may not contain any null characters.\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0648,\n+                        \"`export_name` may not contain null characters\"\n+                    )\n+                    .emit();\n+                }\n+                codegen_fn_attrs.export_name = Some(s);\n+            }\n+        } else if attr.has_name(sym::target_feature) {\n+            if !tcx.is_closure(did.to_def_id())\n+                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n+            {\n+                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n+                    // The `#[target_feature]` attribute is allowed on\n+                    // WebAssembly targets on all functions, including safe\n+                    // ones. Other targets require that `#[target_feature]` is\n+                    // only applied to unsafe functions (pending the\n+                    // `target_feature_11` feature) because on most targets\n+                    // execution of instructions that are not supported is\n+                    // considered undefined behavior. For WebAssembly which is a\n+                    // 100% safe target at execution time it's not possible to\n+                    // execute undefined instructions, and even if a future\n+                    // feature was added in some form for this it would be a\n+                    // deterministic trap. There is no undefined behavior when\n+                    // executing WebAssembly so `#[target_feature]` is allowed\n+                    // on safe functions (but again, only for WebAssembly)\n+                    //\n+                    // Note that this is also allowed if `actually_rustdoc` so\n+                    // if a target is documenting some wasm-specific code then\n+                    // it's not spuriously denied.\n+                } else if !tcx.features().target_feature_11 {\n+                    let mut err = feature_err(\n+                        &tcx.sess.parse_sess,\n+                        sym::target_feature_11,\n+                        attr.span,\n+                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n+                    );\n+                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n+                    err.emit();\n+                } else {\n+                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                }\n+            }\n+            from_target_feature(\n+                tcx,\n+                attr,\n+                supported_target_features,\n+                &mut codegen_fn_attrs.target_features,\n+            );\n+        } else if attr.has_name(sym::linkage) {\n+            if let Some(val) = attr.value_str() {\n+                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                if tcx.is_foreign_item(did) {\n+                    codegen_fn_attrs.import_linkage = linkage;\n+                } else {\n+                    codegen_fn_attrs.linkage = linkage;\n+                }\n+            }\n+        } else if attr.has_name(sym::link_section) {\n+            if let Some(val) = attr.value_str() {\n+                if val.as_str().bytes().any(|b| b == 0) {\n+                    let msg = format!(\n+                        \"illegal null byte in link_section \\\n+                         value: `{}`\",\n+                        &val\n+                    );\n+                    tcx.sess.span_err(attr.span, &msg);\n+                } else {\n+                    codegen_fn_attrs.link_section = Some(val);\n+                }\n+            }\n+        } else if attr.has_name(sym::link_name) {\n+            codegen_fn_attrs.link_name = attr.value_str();\n+        } else if attr.has_name(sym::link_ordinal) {\n+            link_ordinal_span = Some(attr.span);\n+            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n+                codegen_fn_attrs.link_ordinal = ordinal;\n+            }\n+        } else if attr.has_name(sym::no_sanitize) {\n+            no_sanitize_span = Some(attr.span);\n+            if let Some(list) = attr.meta_item_list() {\n+                for item in list.iter() {\n+                    if item.has_name(sym::address) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n+                    } else if item.has_name(sym::cfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                    } else if item.has_name(sym::kcfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n+                    } else if item.has_name(sym::memory) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n+                    } else if item.has_name(sym::memtag) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n+                    } else if item.has_name(sym::shadow_call_stack) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n+                    } else if item.has_name(sym::thread) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n+                    } else if item.has_name(sym::hwaddress) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+                    } else {\n+                        tcx.sess\n+                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                            .emit();\n+                    }\n+                }\n+            }\n+        } else if attr.has_name(sym::instruction_set) {\n+            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n+                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n+                    [NestedMetaItem::MetaItem(set)] => {\n+                        let segments =\n+                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                        match segments.as_slice() {\n+                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                                if !tcx.sess.target.has_thumb_interworking {\n+                                    struct_span_err!(\n+                                        tcx.sess.diagnostic(),\n+                                        attr.span,\n+                                        E0779,\n+                                        \"target does not support `#[instruction_set]`\"\n+                                    )\n+                                    .emit();\n+                                    None\n+                                } else if segments[1] == sym::a32 {\n+                                    Some(InstructionSetAttr::ArmA32)\n+                                } else if segments[1] == sym::t32 {\n+                                    Some(InstructionSetAttr::ArmT32)\n+                                } else {\n+                                    unreachable!()\n+                                }\n+                            }\n+                            _ => {\n+                                struct_span_err!(\n+                                    tcx.sess.diagnostic(),\n+                                    attr.span,\n+                                    E0779,\n+                                    \"invalid instruction set specified\",\n+                                )\n+                                .emit();\n+                                None\n+                            }\n+                        }\n+                    }\n+                    [] => {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0778,\n+                            \"`#[instruction_set]` requires an argument\"\n+                        )\n+                        .emit();\n+                        None\n+                    }\n+                    _ => {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0779,\n+                            \"cannot specify more than one instruction set\"\n+                        )\n+                        .emit();\n+                        None\n+                    }\n+                },\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0778,\n+                        \"must specify an instruction set\"\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            };\n+        } else if attr.has_name(sym::repr) {\n+            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n+                Some(items) => match items.as_slice() {\n+                    [item] => match item.name_value_literal() {\n+                        Some((sym::align, literal)) => {\n+                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n+\n+                            match alignment {\n+                                Ok(align) => Some(align),\n+                                Err(msg) => {\n+                                    struct_span_err!(\n+                                        tcx.sess.diagnostic(),\n+                                        attr.span,\n+                                        E0589,\n+                                        \"invalid `repr(align)` attribute: {}\",\n+                                        msg\n+                                    )\n+                                    .emit();\n+\n+                                    None\n+                                }\n+                            }\n+                        }\n+                        _ => None,\n+                    },\n+                    [] => None,\n+                    _ => None,\n+                },\n+                None => None,\n+            };\n+        }\n+    }\n+\n+    codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+        if !attr.has_name(sym::inline) {\n+            return ia;\n+        }\n+        match attr.meta_kind() {\n+            Some(MetaItemKind::Word) => InlineAttr::Hint,\n+            Some(MetaItemKind::List(ref items)) => {\n+                inline_span = Some(attr.span);\n+                if items.len() != 1 {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0534,\n+                        \"expected one argument\"\n+                    )\n+                    .emit();\n+                    InlineAttr::None\n+                } else if list_contains_name(&items, sym::always) {\n+                    InlineAttr::Always\n+                } else if list_contains_name(&items, sym::never) {\n+                    InlineAttr::Never\n+                } else {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        items[0].span(),\n+                        E0535,\n+                        \"invalid argument\"\n+                    )\n+                    .help(\"valid inline arguments are `always` and `never`\")\n+                    .emit();\n+\n+                    InlineAttr::None\n+                }\n+            }\n+            Some(MetaItemKind::NameValue(_)) => ia,\n+            None => ia,\n+        }\n+    });\n+\n+    codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n+        if !attr.has_name(sym::optimize) {\n+            return ia;\n+        }\n+        let err = |sp, s| struct_span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s).emit();\n+        match attr.meta_kind() {\n+            Some(MetaItemKind::Word) => {\n+                err(attr.span, \"expected one argument\");\n+                ia\n+            }\n+            Some(MetaItemKind::List(ref items)) => {\n+                inline_span = Some(attr.span);\n+                if items.len() != 1 {\n+                    err(attr.span, \"expected one argument\");\n+                    OptimizeAttr::None\n+                } else if list_contains_name(&items, sym::size) {\n+                    OptimizeAttr::Size\n+                } else if list_contains_name(&items, sym::speed) {\n+                    OptimizeAttr::Speed\n+                } else {\n+                    err(items[0].span(), \"invalid argument\");\n+                    OptimizeAttr::None\n+                }\n+            }\n+            Some(MetaItemKind::NameValue(_)) => ia,\n+            None => ia,\n+        }\n+    });\n+\n+    // #73631: closures inherit `#[target_feature]` annotations\n+    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n+        let owner_id = tcx.parent(did.to_def_id());\n+        if tcx.def_kind(owner_id).has_codegen_attrs() {\n+            codegen_fn_attrs\n+                .target_features\n+                .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied());\n+        }\n+    }\n+\n+    // If a function uses #[target_feature] it can't be inlined into general\n+    // purpose functions as they wouldn't have the right target features\n+    // enabled. For that reason we also forbid #[inline(always)] as it can't be\n+    // respected.\n+    if !codegen_fn_attrs.target_features.is_empty() {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let Some(span) = inline_span {\n+                tcx.sess.span_err(\n+                    span,\n+                    \"cannot use `#[inline(always)]` with \\\n+                     `#[target_feature]`\",\n+                );\n+            }\n+        }\n+    }\n+\n+    if !codegen_fn_attrs.no_sanitize.is_empty() {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n+                tcx.struct_span_lint_hir(\n+                    lint::builtin::INLINE_NO_SANITIZE,\n+                    hir_id,\n+                    no_sanitize_span,\n+                    \"`no_sanitize` will have no effect after inlining\",\n+                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n+                )\n+            }\n+        }\n+    }\n+\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        codegen_fn_attrs.inline = InlineAttr::Never;\n+    }\n+\n+    // Weak lang items have the same semantics as \"std internal\" symbols in the\n+    // sense that they're preserved through all our LTO passes and only\n+    // strippable by the linker.\n+    //\n+    // Additionally weak lang items have predetermined symbol names.\n+    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+    }\n+    if let Some((name, _)) = lang_items::extract(attrs)\n+        && let Some(lang_item) = LangItem::from_name(name)\n+        && let Some(link_name) = lang_item.link_name()\n+    {\n+        codegen_fn_attrs.export_name = Some(link_name);\n+        codegen_fn_attrs.link_name = Some(link_name);\n+    }\n+    check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n+\n+    // Internal symbols to the standard library all have no_mangle semantics in\n+    // that they have defined symbol names present in the function name. This\n+    // also applies to weak symbols where they all have known symbol names.\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+    }\n+\n+    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n+    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n+    // intrinsic functions.\n+    if let Some(name) = &codegen_fn_attrs.link_name {\n+        if name.as_str().starts_with(\"llvm.\") {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        }\n+    }\n+\n+    codegen_fn_attrs\n+}\n+\n+/// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n+/// applied to the method prototype.\n+fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n+        && let ty::AssocItemContainer::ImplContainer = impl_item.container\n+        && let Some(trait_item) = impl_item.trait_item_def_id\n+    {\n+        return tcx\n+            .codegen_fn_attrs(trait_item)\n+            .flags\n+            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n+    }\n+\n+    false\n+}\n+\n+fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n+    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n+        feature_err(\n+            &tcx.sess.parse_sess,\n+            sym::raw_dylib,\n+            attr.span,\n+            \"`#[link_ordinal]` is unstable on x86\",\n+        )\n+        .emit();\n+    }\n+    let meta_item_list = attr.meta_item_list();\n+    let meta_item_list = meta_item_list.as_deref();\n+    let sole_meta_list = match meta_item_list {\n+        Some([item]) => item.lit(),\n+        Some(_) => {\n+            tcx.sess\n+                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n+                .note(\"the attribute requires exactly one argument\")\n+                .emit();\n+            return None;\n+        }\n+        _ => None,\n+    };\n+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n+        sole_meta_list\n+    {\n+        // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n+        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n+        // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n+        // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n+        //\n+        // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n+        // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n+        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n+        // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n+        // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n+        // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment\n+        // about LINK.EXE failing.)\n+        if *ordinal <= u16::MAX as u128 {\n+            Some(*ordinal as u16)\n+        } else {\n+            let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n+            tcx.sess\n+                .struct_span_err(attr.span, &msg)\n+                .note(\"the value may not exceed `u16::MAX`\")\n+                .emit();\n+            None\n+        }\n+    } else {\n+        tcx.sess\n+            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n+            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n+            .emit();\n+        None\n+    }\n+}\n+\n+fn check_link_name_xor_ordinal(\n+    tcx: TyCtxt<'_>,\n+    codegen_fn_attrs: &CodegenFnAttrs,\n+    inline_span: Option<Span>,\n+) {\n+    if codegen_fn_attrs.link_name.is_none() || codegen_fn_attrs.link_ordinal.is_none() {\n+        return;\n+    }\n+    let msg = \"cannot use `#[link_name]` with `#[link_ordinal]`\";\n+    if let Some(span) = inline_span {\n+        tcx.sess.span_err(span, msg);\n+    } else {\n+        tcx.sess.err(msg);\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers { codegen_fn_attrs, should_inherit_track_caller, ..*providers };\n+}"}, {"sha": "0620000201f0254f81ff6dd4200876324b02fd0a", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -548,3 +548,10 @@ pub struct ArchiveBuildFailure {\n pub struct UnknownArchiveKind<'a> {\n     pub kind: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_expected_used_symbol)]\n+pub struct ExpectedUsedSymbol {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "0e6596d4ba781bfd7a859a0329105f26a7a2ef60", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -42,6 +42,7 @@ use std::path::{Path, PathBuf};\n \n pub mod back;\n pub mod base;\n+pub mod codegen_attrs;\n pub mod common;\n pub mod coverageinfo;\n pub mod debuginfo;\n@@ -180,6 +181,7 @@ pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide(providers);\n     crate::target_features::provide(providers);\n+    crate::codegen_attrs::provide(providers);\n }\n \n pub fn provide_extern(providers: &mut ExternProviders) {"}, {"sha": "0dabe96b60277e032ad0214d2260277915f6a02d", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 154, "deletions": 10, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,8 +1,19 @@\n+use rustc_ast::ast;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n \n /// Features that control behaviour of rustc, rather than the codegen.\n pub const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n@@ -322,15 +333,148 @@ pub fn tied_target_features(sess: &Session) -> &'static [&'static [&'static str]\n     }\n }\n \n-pub(crate) fn provide(providers: &mut Providers) {\n-    providers.supported_target_features = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        if tcx.sess.opts.actually_rustdoc {\n-            // rustdoc needs to be able to document functions that use all the features, so\n-            // whitelist them all\n-            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n-        } else {\n-            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n-        }\n+pub fn from_target_feature(\n+    tcx: TyCtxt<'_>,\n+    attr: &ast::Attribute,\n+    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n+    target_features: &mut Vec<Symbol>,\n+) {\n+    let Some(list) = attr.meta_item_list() else { return };\n+    let bad_item = |span| {\n+        let msg = \"malformed `target_feature` attribute input\";\n+        let code = \"enable = \\\"..\\\"\";\n+        tcx.sess\n+            .struct_span_err(span, msg)\n+            .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n+            .emit();\n     };\n+    let rust_features = tcx.features();\n+    for item in list {\n+        // Only `enable = ...` is accepted in the meta-item list.\n+        if !item.has_name(sym::enable) {\n+            bad_item(item.span());\n+            continue;\n+        }\n+\n+        // Must be of the form `enable = \"...\"` (a string).\n+        let Some(value) = item.value_str() else {\n+            bad_item(item.span());\n+            continue;\n+        };\n+\n+        // We allow comma separation to enable multiple features.\n+        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n+            let Some(feature_gate) = supported_target_features.get(feature) else {\n+                let msg =\n+                    format!(\"the feature named `{}` is not valid for this target\", feature);\n+                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n+                err.span_label(\n+                    item.span(),\n+                    format!(\"`{}` is not valid for this target\", feature),\n+                );\n+                if let Some(stripped) = feature.strip_prefix('+') {\n+                    let valid = supported_target_features.contains_key(stripped);\n+                    if valid {\n+                        err.help(\"consider removing the leading `+` in the feature name\");\n+                    }\n+                }\n+                err.emit();\n+                return None;\n+            };\n+\n+            // Only allow features whose feature gates have been enabled.\n+            let allowed = match feature_gate.as_ref().copied() {\n+                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n+                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n+                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n+                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n+                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n+                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n+                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n+                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n+                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n+                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n+                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n+                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n+                Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n+                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n+                Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,\n+                Some(name) => bug!(\"unknown target feature gate {}\", name),\n+                None => true,\n+            };\n+            if !allowed {\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    feature_gate.unwrap(),\n+                    item.span(),\n+                    &format!(\"the target feature `{}` is currently unstable\", feature),\n+                )\n+                .emit();\n+            }\n+            Some(Symbol::intern(feature))\n+        }));\n+    }\n+}\n+\n+/// Computes the set of target features used in a function for the purposes of\n+/// inline assembly.\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n+    let mut target_features = tcx.sess.unstable_target_features.clone();\n+    if tcx.def_kind(did).has_codegen_attrs() {\n+        let attrs = tcx.codegen_fn_attrs(did);\n+        target_features.extend(&attrs.target_features);\n+        match attrs.instruction_set {\n+            None => {}\n+            Some(InstructionSetAttr::ArmA32) => {\n+                target_features.remove(&sym::thumb_mode);\n+            }\n+            Some(InstructionSetAttr::ArmT32) => {\n+                target_features.insert(sym::thumb_mode);\n+            }\n+        }\n+    }\n+\n+    tcx.arena.alloc(target_features)\n+}\n+\n+/// Checks the function annotated with `#[target_feature]` is not a safe\n+/// trait method implementation, reporting an error if it is.\n+pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n+    let node = tcx.hir().get(hir_id);\n+    if let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n+        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n+        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n+            tcx.sess\n+                .struct_span_err(\n+                    attr_span,\n+                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n+                )\n+                .span_label(attr_span, \"cannot be applied to safe trait method\")\n+                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n+                .emit();\n+        }\n+    }\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        supported_target_features: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            if tcx.sess.opts.actually_rustdoc {\n+                // rustdoc needs to be able to document functions that use all the features, so\n+                // whitelist them all\n+                all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+            } else {\n+                supported_target_features(tcx.sess)\n+                    .iter()\n+                    .map(|&(a, b)| (a.to_string(), b))\n+                    .collect()\n+            }\n+        },\n+        asm_target_features,\n+        ..*providers\n+    }\n }"}, {"sha": "1b932d0e7084f74442f2a3019002acb291787781", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> MirPass<'tcx> for Validator {\n         };\n \n         let always_live_locals = always_storage_live_locals(body);\n-        let storage_liveness = MaybeStorageLive::new(always_live_locals)\n+        let storage_liveness = MaybeStorageLive::new(std::borrow::Cow::Owned(always_live_locals))\n             .into_engine(tcx, body)\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n@@ -79,7 +79,7 @@ struct TypeChecker<'a, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     mir_phase: MirPhase,\n     reachable_blocks: BitSet<BasicBlock>,\n-    storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n+    storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive<'static>>,\n     place_cache: Vec<PlaceRef<'tcx>>,\n     value_cache: Vec<u128>,\n }"}, {"sha": "38d9b044981cd723687c8962d06345fc226aa39a", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -5,7 +5,7 @@\n use rustc_hir::def_id::DefId;\n use rustc_hir::{lang_items, LangItem};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{AssocItemContainer, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, DesugaringKind, Span};\n \n@@ -39,9 +39,7 @@ pub enum CallKind<'tcx> {\n     Normal {\n         self_arg: Option<Ident>,\n         desugaring: Option<(CallDesugaringKind, Ty<'tcx>)>,\n-        /// Whether the self type of the method call has an `.as_ref()` method.\n-        /// Used for better diagnostics.\n-        is_option_or_result: bool,\n+        method_did: DefId,\n     },\n     /// A call to `Fn(..)::call(..)`, desugared from `my_closure(a, b, c)`\n     FnCall { fn_trait_id: DefId, self_ty: Ty<'tcx> },\n@@ -133,16 +131,6 @@ pub fn call_kind<'tcx>(\n         } else {\n             None\n         };\n-        let parent_did = tcx.parent(method_did);\n-        let parent_self_ty = (tcx.def_kind(parent_did) == rustc_hir::def::DefKind::Impl)\n-            .then_some(parent_did)\n-            .and_then(|did| match tcx.type_of(did).kind() {\n-                ty::Adt(def, ..) => Some(def.did()),\n-                _ => None,\n-            });\n-        let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-            matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n-        });\n-        CallKind::Normal { self_arg, desugaring, is_option_or_result }\n+        CallKind::Normal { self_arg, desugaring, method_did }\n     })\n }"}, {"sha": "db4c82b35c77822d718d16039112205dada7972c", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -192,3 +192,5 @@ codegen_ssa_archive_build_failure =\n \n codegen_ssa_unknown_archive_kind =\n     Don't know how to build archive of type: {$kind}\n+\n+codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`"}, {"sha": "e33323a7795369bf6ccf2b77c0299b0e9b7600d2", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -101,8 +101,6 @@ hir_analysis_extern_crate_not_idiomatic =\n     `extern crate` is not idiomatic in the new edition\n     .suggestion = convert it to a `{$msg_code}`\n \n-hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n-\n hir_analysis_const_impl_for_non_const_trait =\n     const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n     .suggestion = mark `{$trait_name}` as const"}, {"sha": "c62e358e804cade724910bb8f95020b3853dfc84", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1408,49 +1408,58 @@ impl EmitterWriter {\n             if !sm.ensure_source_file_source_present(annotated_file.file.clone()) {\n                 if !self.short_message {\n                     // We'll just print an unannotated message.\n-                    for (annotation_id, line) in annotated_file.lines.into_iter().enumerate() {\n+                    for (annotation_id, line) in annotated_file.lines.iter().enumerate() {\n                         let mut annotations = line.annotations.clone();\n                         annotations.sort_by_key(|a| Reverse(a.start_col));\n                         let mut line_idx = buffer.num_lines();\n-                        buffer.append(\n-                            line_idx,\n-                            &format!(\n-                                \"{}:{}:{}\",\n-                                sm.filename_for_diagnostics(&annotated_file.file.name),\n-                                sm.doctest_offset_line(&annotated_file.file.name, line.line_index),\n-                                annotations[0].start_col + 1,\n-                            ),\n-                            Style::LineAndColumn,\n-                        );\n-                        if annotation_id == 0 {\n-                            buffer.prepend(line_idx, \"--> \", Style::LineNumber);\n+\n+                        let labels: Vec<_> = annotations\n+                            .iter()\n+                            .filter_map(|a| Some((a.label.as_ref()?, a.is_primary)))\n+                            .filter(|(l, _)| !l.is_empty())\n+                            .collect();\n+\n+                        if annotation_id == 0 || !labels.is_empty() {\n+                            buffer.append(\n+                                line_idx,\n+                                &format!(\n+                                    \"{}:{}:{}\",\n+                                    sm.filename_for_diagnostics(&annotated_file.file.name),\n+                                    sm.doctest_offset_line(\n+                                        &annotated_file.file.name,\n+                                        line.line_index\n+                                    ),\n+                                    annotations[0].start_col + 1,\n+                                ),\n+                                Style::LineAndColumn,\n+                            );\n+                            if annotation_id == 0 {\n+                                buffer.prepend(line_idx, \"--> \", Style::LineNumber);\n+                            } else {\n+                                buffer.prepend(line_idx, \"::: \", Style::LineNumber);\n+                            }\n                             for _ in 0..max_line_num_len {\n                                 buffer.prepend(line_idx, \" \", Style::NoStyle);\n                             }\n                             line_idx += 1;\n-                        };\n-                        for (i, annotation) in annotations.into_iter().enumerate() {\n-                            if let Some(label) = &annotation.label {\n-                                let style = if annotation.is_primary {\n-                                    Style::LabelPrimary\n-                                } else {\n-                                    Style::LabelSecondary\n-                                };\n-                                if annotation_id == 0 {\n-                                    buffer.prepend(line_idx, \" |\", Style::LineNumber);\n-                                    for _ in 0..max_line_num_len {\n-                                        buffer.prepend(line_idx, \" \", Style::NoStyle);\n-                                    }\n-                                    line_idx += 1;\n-                                    buffer.append(line_idx + i, \" = note: \", style);\n-                                    for _ in 0..max_line_num_len {\n-                                        buffer.prepend(line_idx, \" \", Style::NoStyle);\n-                                    }\n-                                } else {\n-                                    buffer.append(line_idx + i, \": \", style);\n-                                }\n-                                buffer.append(line_idx + i, label, style);\n+                        }\n+                        for (label, is_primary) in labels.into_iter() {\n+                            let style = if is_primary {\n+                                Style::LabelPrimary\n+                            } else {\n+                                Style::LabelSecondary\n+                            };\n+                            buffer.prepend(line_idx, \" |\", Style::LineNumber);\n+                            for _ in 0..max_line_num_len {\n+                                buffer.prepend(line_idx, \" \", Style::NoStyle);\n+                            }\n+                            line_idx += 1;\n+                            buffer.append(line_idx, \" = note: \", style);\n+                            for _ in 0..max_line_num_len {\n+                                buffer.prepend(line_idx, \" \", Style::NoStyle);\n                             }\n+                            buffer.append(line_idx, label, style);\n+                            line_idx += 1;\n                         }\n                     }\n                 }"}, {"sha": "1eeaaf55e63af0f43a8e84884140294fe0e3f846", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 4, "deletions": 809, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -17,28 +17,20 @@\n use crate::astconv::AstConv;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::errors;\n-use rustc_ast as ast;\n-use rustc_ast::{MetaItemKind, NestedMetaItem};\n-use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n-use rustc_hir::{lang_items, GenericParamKind, LangItem, Node};\n+use rustc_hir::{GenericParamKind, Node};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, ToPredicate, Ty, TyCtxt};\n-use rustc_session::lint;\n-use rustc_session::parse::feature_err;\n+use rustc_middle::ty::{self, AdtKind, Const, IsSuggestable, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_target::spec::{abi, SanitizerSet};\n+use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n use std::iter;\n \n@@ -78,10 +70,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_polarity,\n         is_foreign_item,\n         generator_kind,\n-        codegen_fn_attrs,\n-        asm_target_features,\n         collect_mod_item_types,\n-        should_inherit_track_caller,\n         ..*providers\n     };\n }\n@@ -1455,797 +1444,3 @@ fn generator_kind(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::GeneratorKind>\n         _ => bug!(\"generator_kind applied to non-local def-id {:?}\", def_id),\n     }\n }\n-\n-fn from_target_feature(\n-    tcx: TyCtxt<'_>,\n-    attr: &ast::Attribute,\n-    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n-    target_features: &mut Vec<Symbol>,\n-) {\n-    let Some(list) = attr.meta_item_list() else { return };\n-    let bad_item = |span| {\n-        let msg = \"malformed `target_feature` attribute input\";\n-        let code = \"enable = \\\"..\\\"\";\n-        tcx.sess\n-            .struct_span_err(span, msg)\n-            .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n-            .emit();\n-    };\n-    let rust_features = tcx.features();\n-    for item in list {\n-        // Only `enable = ...` is accepted in the meta-item list.\n-        if !item.has_name(sym::enable) {\n-            bad_item(item.span());\n-            continue;\n-        }\n-\n-        // Must be of the form `enable = \"...\"` (a string).\n-        let Some(value) = item.value_str() else {\n-            bad_item(item.span());\n-            continue;\n-        };\n-\n-        // We allow comma separation to enable multiple features.\n-        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            let Some(feature_gate) = supported_target_features.get(feature) else {\n-                let msg =\n-                    format!(\"the feature named `{}` is not valid for this target\", feature);\n-                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n-                err.span_label(\n-                    item.span(),\n-                    format!(\"`{}` is not valid for this target\", feature),\n-                );\n-                if let Some(stripped) = feature.strip_prefix('+') {\n-                    let valid = supported_target_features.contains_key(stripped);\n-                    if valid {\n-                        err.help(\"consider removing the leading `+` in the feature name\");\n-                    }\n-                }\n-                err.emit();\n-                return None;\n-            };\n-\n-            // Only allow features whose feature gates have been enabled.\n-            let allowed = match feature_gate.as_ref().copied() {\n-                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n-                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n-                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n-                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n-                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n-                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n-                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n-                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n-                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n-                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n-                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n-                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n-                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n-                Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n-                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n-                Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,\n-                Some(name) => bug!(\"unknown target feature gate {}\", name),\n-                None => true,\n-            };\n-            if !allowed {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    feature_gate.unwrap(),\n-                    item.span(),\n-                    &format!(\"the target feature `{}` is currently unstable\", feature),\n-                )\n-                .emit();\n-            }\n-            Some(Symbol::intern(feature))\n-        }));\n-    }\n-}\n-\n-fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n-    use rustc_middle::mir::mono::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but allow them anyway and trust that the\n-    // user knows what they're doing. Who knows, unanticipated use cases may pop\n-    // up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Appending,\n-        \"available_externally\" => AvailableExternally,\n-        \"common\" => Common,\n-        \"extern_weak\" => ExternalWeak,\n-        \"external\" => External,\n-        \"internal\" => Internal,\n-        \"linkonce\" => LinkOnceAny,\n-        \"linkonce_odr\" => LinkOnceODR,\n-        \"private\" => Private,\n-        \"weak\" => WeakAny,\n-        \"weak_odr\" => WeakODR,\n-        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n-    }\n-}\n-\n-fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n-    if cfg!(debug_assertions) {\n-        let def_kind = tcx.def_kind(did);\n-        assert!(\n-            def_kind.has_codegen_attrs(),\n-            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n-        );\n-    }\n-\n-    let did = did.expect_local();\n-    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n-    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n-    if tcx.should_inherit_track_caller(did) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-    }\n-\n-    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n-\n-    let mut inline_span = None;\n-    let mut link_ordinal_span = None;\n-    let mut no_sanitize_span = None;\n-    for attr in attrs.iter() {\n-        if attr.has_name(sym::cold) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.has_name(sym::rustc_allocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.has_name(sym::ffi_returns_twice) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-            } else {\n-                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0724,\n-                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::ffi_pure) {\n-            if tcx.is_foreign_item(did) {\n-                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n-                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0757,\n-                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n-                    )\n-                    .emit();\n-                } else {\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-                }\n-            } else {\n-                // `#[ffi_pure]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0755,\n-                    \"`#[ffi_pure]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::ffi_const) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-            } else {\n-                // `#[ffi_const]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0756,\n-                    \"`#[ffi_const]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::rustc_nounwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        } else if attr.has_name(sym::rustc_reallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n-        } else if attr.has_name(sym::rustc_deallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n-        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n-        } else if attr.has_name(sym::naked) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.has_name(sym::no_mangle) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.has_name(sym::no_coverage) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.has_name(sym::used) {\n-            let inner = attr.meta_item_list();\n-            match inner.as_deref() {\n-                Some([item]) if item.has_name(sym::linker) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(linker)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n-                }\n-                Some([item]) if item.has_name(sym::compiler) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(compiler)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-                }\n-                Some(_) => {\n-                    tcx.sess.emit_err(errors::ExpectedUsedSymbol { span: attr.span });\n-                }\n-                None => {\n-                    // Unfortunately, unconditionally using `llvm.used` causes\n-                    // issues in handling `.init_array` with the gold linker,\n-                    // but using `llvm.compiler.used` caused a nontrival amount\n-                    // of unintentional ecosystem breakage -- particularly on\n-                    // Mach-O targets.\n-                    //\n-                    // As a result, we emit `llvm.compiler.used` only on ELF\n-                    // targets. This is somewhat ad-hoc, but actually follows\n-                    // our pre-LLVM 13 behavior (prior to the ecosystem\n-                    // breakage), and seems to match `clang`'s behavior as well\n-                    // (both before and after LLVM 13), possibly because they\n-                    // have similar compatibility concerns to us. See\n-                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n-                    // and following comments for some discussion of this, as\n-                    // well as the comments in `rustc_codegen_llvm` where these\n-                    // flags are handled.\n-                    //\n-                    // Anyway, to be clear: this is still up in the air\n-                    // somewhat, and is subject to change in the future (which\n-                    // is a good thing, because this would ideally be a bit\n-                    // more firmed up).\n-                    let is_like_elf = !(tcx.sess.target.is_like_osx\n-                        || tcx.sess.target.is_like_windows\n-                        || tcx.sess.target.is_like_wasm);\n-                    codegen_fn_attrs.flags |= if is_like_elf {\n-                        CodegenFnAttrFlags::USED\n-                    } else {\n-                        CodegenFnAttrFlags::USED_LINKER\n-                    };\n-                }\n-            }\n-        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0776,\n-                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n-                )\n-                .emit();\n-            }\n-            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n-                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n-                    .emit();\n-            }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-        } else if attr.has_name(sym::thread_local) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n-                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n-                    .emit();\n-            }\n-            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    sym::closure_track_caller,\n-                    attr.span,\n-                    \"`#[track_caller]` on closures is currently unstable\",\n-                )\n-                .emit();\n-            }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.has_name(sym::export_name) {\n-            if let Some(s) = attr.value_str() {\n-                if s.as_str().contains('\\0') {\n-                    // `#[export_name = ...]` will be converted to a null-terminated string,\n-                    // so it may not contain any null characters.\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0648,\n-                        \"`export_name` may not contain null characters\"\n-                    )\n-                    .emit();\n-                }\n-                codegen_fn_attrs.export_name = Some(s);\n-            }\n-        } else if attr.has_name(sym::target_feature) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n-            {\n-                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n-                    // The `#[target_feature]` attribute is allowed on\n-                    // WebAssembly targets on all functions, including safe\n-                    // ones. Other targets require that `#[target_feature]` is\n-                    // only applied to unsafe functions (pending the\n-                    // `target_feature_11` feature) because on most targets\n-                    // execution of instructions that are not supported is\n-                    // considered undefined behavior. For WebAssembly which is a\n-                    // 100% safe target at execution time it's not possible to\n-                    // execute undefined instructions, and even if a future\n-                    // feature was added in some form for this it would be a\n-                    // deterministic trap. There is no undefined behavior when\n-                    // executing WebAssembly so `#[target_feature]` is allowed\n-                    // on safe functions (but again, only for WebAssembly)\n-                    //\n-                    // Note that this is also allowed if `actually_rustdoc` so\n-                    // if a target is documenting some wasm-specific code then\n-                    // it's not spuriously denied.\n-                } else if !tcx.features().target_feature_11 {\n-                    let mut err = feature_err(\n-                        &tcx.sess.parse_sess,\n-                        sym::target_feature_11,\n-                        attr.span,\n-                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n-                    );\n-                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n-                    err.emit();\n-                } else {\n-                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n-                }\n-            }\n-            from_target_feature(\n-                tcx,\n-                attr,\n-                supported_target_features,\n-                &mut codegen_fn_attrs.target_features,\n-            );\n-        } else if attr.has_name(sym::linkage) {\n-            if let Some(val) = attr.value_str() {\n-                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n-                if tcx.is_foreign_item(did) {\n-                    codegen_fn_attrs.import_linkage = linkage;\n-                } else {\n-                    codegen_fn_attrs.linkage = linkage;\n-                }\n-            }\n-        } else if attr.has_name(sym::link_section) {\n-            if let Some(val) = attr.value_str() {\n-                if val.as_str().bytes().any(|b| b == 0) {\n-                    let msg = format!(\n-                        \"illegal null byte in link_section \\\n-                         value: `{}`\",\n-                        &val\n-                    );\n-                    tcx.sess.span_err(attr.span, &msg);\n-                } else {\n-                    codegen_fn_attrs.link_section = Some(val);\n-                }\n-            }\n-        } else if attr.has_name(sym::link_name) {\n-            codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.has_name(sym::link_ordinal) {\n-            link_ordinal_span = Some(attr.span);\n-            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n-                codegen_fn_attrs.link_ordinal = ordinal;\n-            }\n-        } else if attr.has_name(sym::no_sanitize) {\n-            no_sanitize_span = Some(attr.span);\n-            if let Some(list) = attr.meta_item_list() {\n-                for item in list.iter() {\n-                    if item.has_name(sym::address) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n-                    } else if item.has_name(sym::cfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n-                    } else if item.has_name(sym::kcfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n-                    } else if item.has_name(sym::memory) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.has_name(sym::memtag) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n-                    } else if item.has_name(sym::shadow_call_stack) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n-                    } else if item.has_name(sym::thread) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n-                    } else if item.has_name(sym::hwaddress) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n-                    } else {\n-                        tcx.sess\n-                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                            .emit();\n-                    }\n-                }\n-            }\n-        } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n-                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n-                    [NestedMetaItem::MetaItem(set)] => {\n-                        let segments =\n-                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                        match segments.as_slice() {\n-                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                                if !tcx.sess.target.has_thumb_interworking {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0779,\n-                                        \"target does not support `#[instruction_set]`\"\n-                                    )\n-                                    .emit();\n-                                    None\n-                                } else if segments[1] == sym::a32 {\n-                                    Some(InstructionSetAttr::ArmA32)\n-                                } else if segments[1] == sym::t32 {\n-                                    Some(InstructionSetAttr::ArmT32)\n-                                } else {\n-                                    unreachable!()\n-                                }\n-                            }\n-                            _ => {\n-                                struct_span_err!(\n-                                    tcx.sess.diagnostic(),\n-                                    attr.span,\n-                                    E0779,\n-                                    \"invalid instruction set specified\",\n-                                )\n-                                .emit();\n-                                None\n-                            }\n-                        }\n-                    }\n-                    [] => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0778,\n-                            \"`#[instruction_set]` requires an argument\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                    _ => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0779,\n-                            \"cannot specify more than one instruction set\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                },\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0778,\n-                        \"must specify an instruction set\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            };\n-        } else if attr.has_name(sym::repr) {\n-            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n-                Some(items) => match items.as_slice() {\n-                    [item] => match item.name_value_literal() {\n-                        Some((sym::align, literal)) => {\n-                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n-\n-                            match alignment {\n-                                Ok(align) => Some(align),\n-                                Err(msg) => {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0589,\n-                                        \"invalid `repr(align)` attribute: {}\",\n-                                        msg\n-                                    )\n-                                    .emit();\n-\n-                                    None\n-                                }\n-                            }\n-                        }\n-                        _ => None,\n-                    },\n-                    [] => None,\n-                    _ => None,\n-                },\n-                None => None,\n-            };\n-        }\n-    }\n-\n-    codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if !attr.has_name(sym::inline) {\n-            return ia;\n-        }\n-        match attr.meta_kind() {\n-            Some(MetaItemKind::Word) => InlineAttr::Hint,\n-            Some(MetaItemKind::List(ref items)) => {\n-                inline_span = Some(attr.span);\n-                if items.len() != 1 {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0534,\n-                        \"expected one argument\"\n-                    )\n-                    .emit();\n-                    InlineAttr::None\n-                } else if list_contains_name(&items, sym::always) {\n-                    InlineAttr::Always\n-                } else if list_contains_name(&items, sym::never) {\n-                    InlineAttr::Never\n-                } else {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        items[0].span(),\n-                        E0535,\n-                        \"invalid argument\"\n-                    )\n-                    .help(\"valid inline arguments are `always` and `never`\")\n-                    .emit();\n-\n-                    InlineAttr::None\n-                }\n-            }\n-            Some(MetaItemKind::NameValue(_)) => ia,\n-            None => ia,\n-        }\n-    });\n-\n-    codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if !attr.has_name(sym::optimize) {\n-            return ia;\n-        }\n-        let err = |sp, s| struct_span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s).emit();\n-        match attr.meta_kind() {\n-            Some(MetaItemKind::Word) => {\n-                err(attr.span, \"expected one argument\");\n-                ia\n-            }\n-            Some(MetaItemKind::List(ref items)) => {\n-                inline_span = Some(attr.span);\n-                if items.len() != 1 {\n-                    err(attr.span, \"expected one argument\");\n-                    OptimizeAttr::None\n-                } else if list_contains_name(&items, sym::size) {\n-                    OptimizeAttr::Size\n-                } else if list_contains_name(&items, sym::speed) {\n-                    OptimizeAttr::Speed\n-                } else {\n-                    err(items[0].span(), \"invalid argument\");\n-                    OptimizeAttr::None\n-                }\n-            }\n-            Some(MetaItemKind::NameValue(_)) => ia,\n-            None => ia,\n-        }\n-    });\n-\n-    // #73631: closures inherit `#[target_feature]` annotations\n-    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n-        let owner_id = tcx.parent(did.to_def_id());\n-        if tcx.def_kind(owner_id).has_codegen_attrs() {\n-            codegen_fn_attrs\n-                .target_features\n-                .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied());\n-        }\n-    }\n-\n-    // If a function uses #[target_feature] it can't be inlined into general\n-    // purpose functions as they wouldn't have the right target features\n-    // enabled. For that reason we also forbid #[inline(always)] as it can't be\n-    // respected.\n-    if !codegen_fn_attrs.target_features.is_empty() {\n-        if codegen_fn_attrs.inline == InlineAttr::Always {\n-            if let Some(span) = inline_span {\n-                tcx.sess.span_err(\n-                    span,\n-                    \"cannot use `#[inline(always)]` with \\\n-                     `#[target_feature]`\",\n-                );\n-            }\n-        }\n-    }\n-\n-    if !codegen_fn_attrs.no_sanitize.is_empty() {\n-        if codegen_fn_attrs.inline == InlineAttr::Always {\n-            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n-                tcx.struct_span_lint_hir(\n-                    lint::builtin::INLINE_NO_SANITIZE,\n-                    hir_id,\n-                    no_sanitize_span,\n-                    \"`no_sanitize` will have no effect after inlining\",\n-                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n-                )\n-            }\n-        }\n-    }\n-\n-    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        codegen_fn_attrs.inline = InlineAttr::Never;\n-    }\n-\n-    // Weak lang items have the same semantics as \"std internal\" symbols in the\n-    // sense that they're preserved through all our LTO passes and only\n-    // strippable by the linker.\n-    //\n-    // Additionally weak lang items have predetermined symbol names.\n-    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-    }\n-    if let Some((name, _)) = lang_items::extract(attrs)\n-        && let Some(lang_item) = LangItem::from_name(name)\n-        && let Some(link_name) = lang_item.link_name()\n-    {\n-        codegen_fn_attrs.export_name = Some(link_name);\n-        codegen_fn_attrs.link_name = Some(link_name);\n-    }\n-    check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n-\n-    // Internal symbols to the standard library all have no_mangle semantics in\n-    // that they have defined symbol names present in the function name. This\n-    // also applies to weak symbols where they all have known symbol names.\n-    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-    }\n-\n-    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n-    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n-    // intrinsic functions.\n-    if let Some(name) = &codegen_fn_attrs.link_name {\n-        if name.as_str().starts_with(\"llvm.\") {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        }\n-    }\n-\n-    codegen_fn_attrs\n-}\n-\n-/// Computes the set of target features used in a function for the purposes of\n-/// inline assembly.\n-fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n-    let mut target_features = tcx.sess.unstable_target_features.clone();\n-    if tcx.def_kind(did).has_codegen_attrs() {\n-        let attrs = tcx.codegen_fn_attrs(did);\n-        target_features.extend(&attrs.target_features);\n-        match attrs.instruction_set {\n-            None => {}\n-            Some(InstructionSetAttr::ArmA32) => {\n-                target_features.remove(&sym::thumb_mode);\n-            }\n-            Some(InstructionSetAttr::ArmT32) => {\n-                target_features.insert(sym::thumb_mode);\n-            }\n-        }\n-    }\n-\n-    tcx.arena.alloc(target_features)\n-}\n-\n-/// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n-/// applied to the method prototype.\n-fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n-        && let ty::AssocItemContainer::ImplContainer = impl_item.container\n-        && let Some(trait_item) = impl_item.trait_item_def_id\n-    {\n-        return tcx\n-            .codegen_fn_attrs(trait_item)\n-            .flags\n-            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-    }\n-\n-    false\n-}\n-\n-fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n-    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n-    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n-        feature_err(\n-            &tcx.sess.parse_sess,\n-            sym::raw_dylib,\n-            attr.span,\n-            \"`#[link_ordinal]` is unstable on x86\",\n-        )\n-        .emit();\n-    }\n-    let meta_item_list = attr.meta_item_list();\n-    let meta_item_list = meta_item_list.as_deref();\n-    let sole_meta_list = match meta_item_list {\n-        Some([item]) => item.lit(),\n-        Some(_) => {\n-            tcx.sess\n-                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n-                .note(\"the attribute requires exactly one argument\")\n-                .emit();\n-            return None;\n-        }\n-        _ => None,\n-    };\n-    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n-        sole_meta_list\n-    {\n-        // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n-        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n-        // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n-        // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n-        //\n-        // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n-        // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n-        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n-        // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n-        // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n-        // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment\n-        // about LINK.EXE failing.)\n-        if *ordinal <= u16::MAX as u128 {\n-            Some(*ordinal as u16)\n-        } else {\n-            let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n-            tcx.sess\n-                .struct_span_err(attr.span, &msg)\n-                .note(\"the value may not exceed `u16::MAX`\")\n-                .emit();\n-            None\n-        }\n-    } else {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n-            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n-            .emit();\n-        None\n-    }\n-}\n-\n-fn check_link_name_xor_ordinal(\n-    tcx: TyCtxt<'_>,\n-    codegen_fn_attrs: &CodegenFnAttrs,\n-    inline_span: Option<Span>,\n-) {\n-    if codegen_fn_attrs.link_name.is_none() || codegen_fn_attrs.link_ordinal.is_none() {\n-        return;\n-    }\n-    let msg = \"cannot use `#[link_name]` with `#[link_ordinal]`\";\n-    if let Some(span) = inline_span {\n-        tcx.sess.span_err(span, msg);\n-    } else {\n-        tcx.sess.err(msg);\n-    }\n-}\n-\n-/// Checks the function annotated with `#[target_feature]` is not a safe\n-/// trait method implementation, reporting an error if it is.\n-fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-    let node = tcx.hir().get(hir_id);\n-    if let Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n-        let parent_id = tcx.hir().get_parent_item(hir_id);\n-        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr_span,\n-                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n-                )\n-                .span_label(attr_span, \"cannot be applied to safe trait method\")\n-                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n-                .emit();\n-        }\n-    }\n-}"}, {"sha": "19a1b5da41d775c91de2fea0e7e0af0cccdb0b8a", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -75,7 +75,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     const NO_GENERICS: &hir::Generics<'_> = hir::Generics::empty();\n \n-    // We use an `IndexSet` to preserves order of insertion.\n+    // We use an `IndexSet` to preserve order of insertion.\n     // Preserving the order of insertion is important here so as not to break UI tests.\n     let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n@@ -97,11 +97,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics) => *generics,\n \n-            ItemKind::Trait(_, _, ref generics, ..) => {\n-                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                *generics\n-            }\n-            ItemKind::TraitAlias(ref generics, _) => {\n+            ItemKind::Trait(_, _, ref generics, ..) | ItemKind::TraitAlias(ref generics, _) => {\n                 is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n                 *generics\n             }\n@@ -406,9 +402,10 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             // For a predicate from a where clause to become a bound on an\n             // associated type:\n             // * It must use the identity substs of the item.\n-            //     * Since any generic parameters on the item are not in scope,\n-            //       this means that the item is not a GAT, and its identity\n-            //       substs are the same as the trait's.\n+            //   * We're in the scope of the trait, so we can't name any\n+            //     parameters of the GAT. That means that all we need to\n+            //     check are that the substs of the projection are the\n+            //     identity substs of the trait.\n             // * It must be an associated type for this trait (*not* a\n             //   supertrait).\n             if let ty::Projection(projection) = ty.kind() {"}, {"sha": "d9697c63c56e1e8df9d2cfa2ceb5542b92a04ad8", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -253,13 +253,6 @@ pub struct ExternCrateNotIdiomatic {\n     pub suggestion_code: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis_expected_used_symbol)]\n-pub struct ExpectedUsedSymbol {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis_const_impl_for_non_const_trait)]\n pub struct ConstImplForNonConstTrait {"}, {"sha": "2d3b4663f06ce82f17f272d63bf4a0b86efe282e", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1853,7 +1853,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )],\n     ) {\n         let mut derives = Vec::<(String, Span, Symbol)>::new();\n-        let mut traits = Vec::<Span>::new();\n+        let mut traits = Vec::new();\n         for (pred, _, _) in unsatisfied_predicates {\n             let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n@@ -1892,10 +1892,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     derives.push((self_name, self_span, diagnostic_name));\n                 } else {\n-                    traits.push(self.tcx.def_span(trait_pred.def_id()));\n+                    traits.push(trait_pred.def_id());\n                 }\n             } else {\n-                traits.push(self.tcx.def_span(trait_pred.def_id()));\n+                traits.push(trait_pred.def_id());\n             }\n         }\n         traits.sort();\n@@ -1918,10 +1918,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let len = traits.len();\n         if len > 0 {\n-            let span: MultiSpan = traits.into();\n+            let span =\n+                MultiSpan::from_spans(traits.iter().map(|&did| self.tcx.def_span(did)).collect());\n+            let mut names = format!(\"`{}`\", self.tcx.def_path_str(traits[0]));\n+            for (i, &did) in traits.iter().enumerate().skip(1) {\n+                if len > 2 {\n+                    names.push_str(\", \");\n+                }\n+                if i == len - 1 {\n+                    names.push_str(\" and \");\n+                }\n+                names.push('`');\n+                names.push_str(&self.tcx.def_path_str(did));\n+                names.push('`');\n+            }\n             err.span_note(\n                 span,\n-                &format!(\"the following trait{} must be implemented\", pluralize!(len),),\n+                &format!(\"the trait{} {} must be implemented\", pluralize!(len), names),\n             );\n         }\n "}, {"sha": "4370d4bd758d21f3112c664cd7a96f1456585243", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1527,13 +1527,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 if let Some(virtual_dir) = &sess.opts.unstable_opts.simulate_remapped_rust_src_base\n                 {\n                     if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n-                        if let rustc_span::FileName::Real(ref mut old_name) = name {\n-                            if let rustc_span::RealFileName::LocalPath(local) = old_name {\n-                                if let Ok(rest) = local.strip_prefix(real_dir) {\n-                                    *old_name = rustc_span::RealFileName::Remapped {\n-                                        local_path: None,\n-                                        virtual_name: virtual_dir.join(rest),\n-                                    };\n+                        for subdir in [\"library\", \"compiler\"] {\n+                            if let rustc_span::FileName::Real(ref mut old_name) = name {\n+                                if let rustc_span::RealFileName::LocalPath(local) = old_name {\n+                                    if let Ok(rest) = local.strip_prefix(real_dir.join(subdir)) {\n+                                        *old_name = rustc_span::RealFileName::Remapped {\n+                                            local_path: None,\n+                                            virtual_name: virtual_dir.join(subdir).join(rest),\n+                                        };\n+                                    }\n                                 }\n                             }\n                         }"}, {"sha": "f8385c4701605bcc07841ef86b7bb6d6a36c8122", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -252,7 +252,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for GenericArg<'tcx> {\n     }\n }\n \n-/// A substitution mapping generic parameters to new values.\n+/// List of generic arguments that are gonna be used to substitute generic parameters.\n pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n \n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;"}, {"sha": "7b19acf70737f66a2451cd75634c54b9de26fb34", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                         remainder_span,\n                                         pattern,\n                                         None,\n-                                        Some((None, initializer_span)),\n+                                        Some((Some(&destination), initializer_span)),\n                                     );\n                                     this.visit_primary_bindings(\n                                         pattern,"}, {"sha": "1fd2e40c187e0487eb761156caa852a091d45b98", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -20,6 +20,7 @@\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::{\n     mir::*,\n@@ -33,6 +34,7 @@ mod parse;\n pub(super) fn build_custom_mir<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     did: DefId,\n+    hir_id: HirId,\n     thir: &Thir<'tcx>,\n     expr: ExprId,\n     params: &IndexVec<ParamId, Param<'tcx>>,\n@@ -67,7 +69,10 @@ pub(super) fn build_custom_mir<'tcx>(\n         parent_scope: None,\n         inlined: None,\n         inlined_parent_scope: None,\n-        local_data: ClearCrossCrate::Clear,\n+        local_data: ClearCrossCrate::Set(SourceScopeLocalData {\n+            lint_root: hir_id,\n+            safety: Safety::Safe,\n+        }),\n     });\n     body.injection_phase = Some(parse_attribute(attr));\n "}, {"sha": "7af89dd472f88e9be4ccf03111f2ad525d870d7c", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -487,6 +487,7 @@ fn construct_fn<'tcx>(\n         return custom::build_custom_mir(\n             tcx,\n             fn_def.did.to_def_id(),\n+            fn_id,\n             thir,\n             expr,\n             arguments,"}, {"sha": "3bb1f51650abd5c846acad632a7e649099f4559f", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -132,6 +132,18 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n     fn unsafe_op_in_unsafe_fn_allowed(&self) -> bool {\n         self.tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, self.hir_context).0 == Level::Allow\n     }\n+\n+    /// Handle closures/generators/inline-consts, which is unsafecked with their parent body.\n+    fn visit_inner_body(&mut self, def: ty::WithOptConstParam<LocalDefId>) {\n+        if let Ok((inner_thir, expr)) = self.tcx.thir_body(def) {\n+            let inner_thir = &inner_thir.borrow();\n+            let hir_context = self.tcx.hir().local_def_id_to_hir_id(def.did);\n+            let mut inner_visitor = UnsafetyVisitor { thir: inner_thir, hir_context, ..*self };\n+            inner_visitor.visit_expr(&inner_thir[expr]);\n+            // Unsafe blocks can be used in the inner body, make sure to take it into account\n+            self.safety_context = inner_visitor.safety_context;\n+        }\n+    }\n }\n \n // Searches for accesses to layout constrained fields.\n@@ -408,16 +420,11 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 } else {\n                     ty::WithOptConstParam::unknown(closure_id)\n                 };\n-                let (closure_thir, expr) = self.tcx.thir_body(closure_def).unwrap_or_else(|_| {\n-                    (self.tcx.alloc_steal_thir(Thir::new()), ExprId::from_u32(0))\n-                });\n-                let closure_thir = &closure_thir.borrow();\n-                let hir_context = self.tcx.hir().local_def_id_to_hir_id(closure_id);\n-                let mut closure_visitor =\n-                    UnsafetyVisitor { thir: closure_thir, hir_context, ..*self };\n-                closure_visitor.visit_expr(&closure_thir[expr]);\n-                // Unsafe blocks can be used in closures, make sure to take it into account\n-                self.safety_context = closure_visitor.safety_context;\n+                self.visit_inner_body(closure_def);\n+            }\n+            ExprKind::ConstBlock { did, substs: _ } => {\n+                let def_id = did.expect_local();\n+                self.visit_inner_body(ty::WithOptConstParam::unknown(def_id));\n             }\n             ExprKind::Field { lhs, .. } => {\n                 let lhs = &self.thir[lhs];\n@@ -612,11 +619,8 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n         return;\n     }\n \n-    // Closures are handled by their owner, if it has a body\n-    if tcx.is_closure(def.did.to_def_id()) {\n-        let hir = tcx.hir();\n-        let owner = hir.enclosing_body_owner(hir.local_def_id_to_hir_id(def.did));\n-        tcx.ensure().thir_check_unsafety(owner);\n+    // Closures and inline consts are handled by their owner, if it has a body\n+    if tcx.is_typeck_child(def.did.to_def_id()) {\n         return;\n     }\n "}, {"sha": "8d379b90a86db28194b2946df68bc564b8e84961", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,20 +3,21 @@ pub use super::*;\n use crate::{CallReturnPlaces, GenKill, Results, ResultsRefCursor};\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n+use std::borrow::Cow;\n use std::cell::RefCell;\n \n #[derive(Clone)]\n-pub struct MaybeStorageLive {\n-    always_live_locals: BitSet<Local>,\n+pub struct MaybeStorageLive<'a> {\n+    always_live_locals: Cow<'a, BitSet<Local>>,\n }\n \n-impl MaybeStorageLive {\n-    pub fn new(always_live_locals: BitSet<Local>) -> Self {\n+impl<'a> MaybeStorageLive<'a> {\n+    pub fn new(always_live_locals: Cow<'a, BitSet<Local>>) -> Self {\n         MaybeStorageLive { always_live_locals }\n     }\n }\n \n-impl<'tcx> crate::AnalysisDomain<'tcx> for MaybeStorageLive {\n+impl<'tcx, 'a> crate::AnalysisDomain<'tcx> for MaybeStorageLive<'a> {\n     type Domain = BitSet<Local>;\n \n     const NAME: &'static str = \"maybe_storage_live\";\n@@ -38,7 +39,7 @@ impl<'tcx> crate::AnalysisDomain<'tcx> for MaybeStorageLive {\n     }\n }\n \n-impl<'tcx> crate::GenKillAnalysis<'tcx> for MaybeStorageLive {\n+impl<'tcx, 'a> crate::GenKillAnalysis<'tcx> for MaybeStorageLive<'a> {\n     type Idx = Local;\n \n     fn statement_effect("}, {"sha": "782abd7804d5d0f66ed7175a141d42fe41bb6e2d", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,6 +1,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n@@ -134,6 +135,28 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n+    fn visit_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n+        if let Operand::Constant(constant) = op {\n+            let maybe_uneval = match constant.literal {\n+                ConstantKind::Val(..) | ConstantKind::Ty(_) => None,\n+                ConstantKind::Unevaluated(uv, _) => Some(uv),\n+            };\n+\n+            if let Some(uv) = maybe_uneval {\n+                if uv.promoted.is_none() {\n+                    let def_id = uv.def.def_id_for_type_of();\n+                    if self.tcx.def_kind(def_id) == DefKind::InlineConst {\n+                        let local_def_id = def_id.expect_local();\n+                        let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n+                            self.tcx.unsafety_check_result(local_def_id);\n+                        self.register_violations(violations, used_unsafe_blocks.iter().copied());\n+                    }\n+                }\n+            }\n+        }\n+        self.super_operand(op, location);\n+    }\n+\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         // On types with `scalar_valid_range`, prevent\n         // * `&mut x.field`\n@@ -410,6 +433,12 @@ impl<'tcx> intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'_, 'tcx> {\n         intravisit::walk_block(self, block);\n     }\n \n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        if matches!(self.tcx.def_kind(c.def_id), DefKind::InlineConst) {\n+            self.visit_body(self.tcx.hir().body(c.body))\n+        }\n+    }\n+\n     fn visit_fn(\n         &mut self,\n         fk: intravisit::FnKind<'tcx>,\n@@ -484,7 +513,7 @@ fn unsafety_check_result<'tcx>(\n     let mut checker = UnsafetyChecker::new(body, def.did, tcx, param_env);\n     checker.visit_body(&body);\n \n-    let unused_unsafes = (!tcx.is_closure(def.did.to_def_id()))\n+    let unused_unsafes = (!tcx.is_typeck_child(def.did.to_def_id()))\n         .then(|| check_unused_unsafe(tcx, def.did, &checker.used_unsafe_blocks));\n \n     tcx.arena.alloc(UnsafetyCheckResult {\n@@ -516,8 +545,8 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n-    // closures are handled by their parent fn.\n-    if tcx.is_closure(def_id.to_def_id()) {\n+    // closures and inline consts are handled by their parent fn.\n+    if tcx.is_typeck_child(def_id.to_def_id()) {\n         return;\n     }\n "}, {"sha": "c097af6161159a7fcec85b6b0bb69a3605fcb8e9", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -490,7 +490,7 @@ fn locals_live_across_suspend_points<'tcx>(\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n+    let mut storage_live = MaybeStorageLive::new(std::borrow::Cow::Borrowed(always_live_locals))\n         .into_engine(tcx, body_ref)\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);"}, {"sha": "2c89f4add2e708c7b637f0965e9cbc2aaadd8982", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1308,15 +1308,15 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             let is_local_static =\n                 if let DefKind::Static(_) = kind { def_id.is_local() } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n-                let sess = self.tcx.sess;\n-                let sm = sess.source_map();\n-                let name = match qpath {\n-                    hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => {\n-                        sm.span_to_snippet(qpath.span()).ok()\n+                let name = match *qpath {\n+                    hir::QPath::LangItem(it, ..) => {\n+                        self.tcx.lang_items().get(it).map(|did| self.tcx.def_path_str(did))\n                     }\n+                    hir::QPath::Resolved(_, path) => Some(self.tcx.def_path_str(path.res.def_id())),\n                     hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);\n+                let sess = self.tcx.sess;\n                 let _ = match name {\n                     Some(name) => {\n                         sess.emit_err(ItemIsPrivate { span, kind, descr: (&name).into() })"}, {"sha": "c1b7c61d09b15a0e4794642ae3ea46e27bf94243", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2186,15 +2186,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             format!(\"does not implement `{}`\", trait_pred.print_modifiers_and_trait_path())\n         };\n \n-        let mut explain_yield = |interior_span: Span,\n-                                 yield_span: Span,\n-                                 scope_span: Option<Span>| {\n-            let mut span = MultiSpan::from_span(yield_span);\n-            if let Ok(snippet) = source_map.span_to_snippet(interior_span) {\n-                // #70935: If snippet contains newlines, display \"the value\" instead\n-                // so that we do not emit complex diagnostics.\n-                let snippet = &format!(\"`{}`\", snippet);\n-                let snippet = if snippet.contains('\\n') { \"the value\" } else { snippet };\n+        let mut explain_yield =\n+            |interior_span: Span, yield_span: Span, scope_span: Option<Span>| {\n+                let mut span = MultiSpan::from_span(yield_span);\n+                let snippet = match source_map.span_to_snippet(interior_span) {\n+                    // #70935: If snippet contains newlines, display \"the value\" instead\n+                    // so that we do not emit complex diagnostics.\n+                    Ok(snippet) if !snippet.contains('\\n') => format!(\"`{}`\", snippet),\n+                    _ => \"the value\".to_string(),\n+                };\n                 // note: future is not `Send` as this value is used across an await\n                 //   --> $DIR/issue-70935-complex-spans.rs:13:9\n                 //    |\n@@ -2219,17 +2219,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     interior_span,\n                     format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n                 );\n-                // If available, use the scope span to annotate the drop location.\n-                let mut scope_note = None;\n                 if let Some(scope_span) = scope_span {\n                     let scope_span = source_map.end_point(scope_span);\n \n                     let msg = format!(\"{} is later dropped here\", snippet);\n-                    if source_map.is_multiline(yield_span.between(scope_span)) {\n-                        span.push_span_label(scope_span, msg);\n-                    } else {\n-                        scope_note = Some((scope_span, msg));\n-                    }\n+                    span.push_span_label(scope_span, msg);\n                 }\n                 err.span_note(\n                     span,\n@@ -2238,11 +2232,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         future_or_generator, trait_explanation, an_await_or_yield\n                     ),\n                 );\n-                if let Some((span, msg)) = scope_note {\n-                    err.span_note(span, &msg);\n-                }\n-            }\n-        };\n+            };\n         match interior_or_upvar_span {\n             GeneratorInteriorOrUpvar::Interior(interior_span, interior_extra_info) => {\n                 if let Some((scope_span, yield_span, expr, from_awaited_ty)) = interior_extra_info {"}, {"sha": "ada541e644a3130236366d1b562303afe9059f38", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -187,9 +187,9 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes, typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes, typeck, optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "88fd4d89b2827661b9d9f74dcaf4be3e5692d4d7", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -158,9 +158,9 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -210,9 +210,9 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "9b4d23757b871340e7418c03025e449d978ccf63", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -158,9 +158,9 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -212,9 +212,9 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,typeck,optimized_mir\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail6\")]\n pub fn change_continue_label() {\n     let mut _x = 0;"}, {"sha": "1b7ef4e4f19cfc193c26ee6aa643adbb99c720c5", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -660,10 +660,7 @@ LL | #[derive(Diagnostic)]\n    = help: normalized in stderr\n note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n   --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:LL:CC\n-   |\n-LL |         arg: impl IntoDiagnosticArg,\n-   |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n-   = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Diagnostic` which comes from the expansion of the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 83 previous errors\n "}, {"sha": "2673ee9f937fb1e87bee5d6ebf36c177d097622b", "filename": "src/test/ui/alloc-error/alloc-error-handler-bad-signature-2.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Falloc-error%2Falloc-error-handler-bad-signature-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -17,9 +17,6 @@ LL | |  }\n    = note: struct `core::alloc::Layout` and struct `Layout` have similar names, but are actually distinct types\n note: struct `core::alloc::Layout` is defined in crate `core`\n   --> $SRC_DIR/core/src/alloc/layout.rs:LL:COL\n-   |\n-LL | pub struct Layout {\n-   | ^^^^^^^^^^^^^^^^^\n note: struct `Layout` is defined in the current crate\n   --> $DIR/alloc-error-handler-bad-signature-2.rs:7:1\n    |"}, {"sha": "dc93c47dace2331381d8445925cde9e9befe1eea", "filename": "src/test/ui/associated-type-bounds/issue-99828.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-99828.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -15,9 +15,6 @@ LL | fn get_iter(vec: &[i32]) -> impl Iterator<Item = {}> + '_ {\n    |\n note: associated type defined here\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     type Item;\n-   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fc830b8d6768657f9ef06dc1a29b89088ac2d090", "filename": "src/test/ui/associated-types/defaults-wf.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |     type Ty = Vec<[u8]>;\n    = help: the trait `Sized` is not implemented for `[u8]`\n note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-   |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n-   |                ^ required by this bound in `Vec`\n \n error: aborting due to previous error\n "}, {"sha": "8e7cf86c4066f112e8125e443e759ebb606f0957", "filename": "src/test/ui/associated-types/trait-with-supertraits-needing-sized-self.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Ftrait-with-supertraits-needing-sized-self.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL | trait ArithmeticOps: Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self>\n    |\n note: required by a bound in `Add`\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Add<Rhs = Self> {\n-   |               ^^^^^^^^^^ required by this bound in `Add`\n help: consider further restricting `Self`\n    |\n LL | trait ArithmeticOps: Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + Div<Output=Self> + Sized {}"}, {"sha": "f0f5245a3b42ba5d395058ed9bad1037146056b0", "filename": "src/test/ui/async-await/async-await-let-else.drop-tracking.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.drop-tracking.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -68,14 +68,10 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-await-let-else.rs:33:28\n    |\n LL |         (Rc::new(()), bar().await);\n-   |          -----------       ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n-   |          |\n+   |          -----------       ^^^^^^ - `Rc::new(())` is later dropped here\n+   |          |                 |\n+   |          |                 await occurs here, with `Rc::new(())` maybe used later\n    |          has type `Rc<()>` which is not `Send`\n-note: `Rc::new(())` is later dropped here\n-  --> $DIR/async-await-let-else.rs:33:35\n-   |\n-LL |         (Rc::new(()), bar().await);\n-   |                                   ^\n note: required by a bound in `is_send`\n   --> $DIR/async-await-let-else.rs:19:15\n    |"}, {"sha": "d3c5e80a30df443ee5cf66c942c445ba95cec701", "filename": "src/test/ui/async-await/async-await-let-else.no-drop-tracking.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -53,14 +53,10 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/async-await-let-else.rs:33:28\n    |\n LL |         (Rc::new(()), bar().await);\n-   |          -----------       ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n-   |          |\n+   |          -----------       ^^^^^^ - `Rc::new(())` is later dropped here\n+   |          |                 |\n+   |          |                 await occurs here, with `Rc::new(())` maybe used later\n    |          has type `Rc<()>` which is not `Send`\n-note: `Rc::new(())` is later dropped here\n-  --> $DIR/async-await-let-else.rs:33:35\n-   |\n-LL |         (Rc::new(()), bar().await);\n-   |                                   ^\n note: required by a bound in `is_send`\n   --> $DIR/async-await-let-else.rs:19:15\n    |"}, {"sha": "963c6ba57adf89448eac3463e72257edc5a0cbd1", "filename": "src/test/ui/async-await/generator-desc.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerator-desc.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,9 +12,6 @@ LL |     fun(async {}, async {});\n               found `async` block `[async block@$DIR/generator-desc.rs:10:19: 10:27]`\n note: function defined here\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n-   |\n-LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n-   |              ^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/generator-desc.rs:12:16"}, {"sha": "8036d82daa4a33f51f3dff008efa3c58b55c50bb", "filename": "src/test/ui/async-await/issue-70935-complex-spans.no_drop_tracking.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.no_drop_tracking.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,14 +12,10 @@ LL |           baz(|| async{\n    |  _____________-\n LL | |             foo(tx.clone());\n LL | |         }).await;\n-   | |         - ^^^^^^ await occurs here, with the value maybe used later\n-   | |_________|\n+   | |         - ^^^^^^- the value is later dropped here\n+   | |         | |\n+   | |_________| await occurs here, with the value maybe used later\n    |           has type `[closure@$DIR/issue-70935-complex-spans.rs:17:13: 17:15]` which is not `Send`\n-note: the value is later dropped here\n-  --> $DIR/issue-70935-complex-spans.rs:19:17\n-   |\n-LL |         }).await;\n-   |                 ^\n \n error: aborting due to previous error\n "}, {"sha": "4a1705715caccbae37ea337820e2a12a5c57d4cf", "filename": "src/test/ui/async-await/issue-72442.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissue-72442.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissue-72442.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-72442.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,9 +8,6 @@ LL |             let mut f = File::open(path.to_str())?;\n    |\n note: required by a bound in `File::open`\n   --> $SRC_DIR/std/src/fs.rs:LL:COL\n-   |\n-LL |     pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {\n-   |                    ^^^^^^^^^^^ required by this bound in `File::open`\n \n error: aborting due to previous error\n "}, {"sha": "40c0e72b20391047a5ff92bb21ff2aafa86e4883", "filename": "src/test/ui/async-await/issues/issue-65159.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,11 +6,6 @@ LL | async fn copy() -> Result<()>\n    |                    |\n    |                    expected 2 generic arguments\n    |\n-note: enum defined here, with 2 generic parameters: `T`, `E`\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^ -  -\n help: add missing generic argument\n    |\n LL | async fn copy() -> Result<(), E>"}, {"sha": "1033fa6cc8b344c474a9c79b6d74fdaa9eb903e9", "filename": "src/test/ui/async-await/issues/issue-65436-raw-ptr-not-send.no_drop_tracking.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.no_drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.no_drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65436-raw-ptr-not-send.no_drop_tracking.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,14 +13,10 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/issue-65436-raw-ptr-not-send.rs:18:35\n    |\n LL |         bar(Foo(std::ptr::null())).await;\n-   |                 ----------------  ^^^^^^ await occurs here, with `std::ptr::null()` maybe used later\n-   |                 |\n+   |                 ----------------  ^^^^^^- `std::ptr::null()` is later dropped here\n+   |                 |                 |\n+   |                 |                 await occurs here, with `std::ptr::null()` maybe used later\n    |                 has type `*const u8` which is not `Send`\n-note: `std::ptr::null()` is later dropped here\n-  --> $DIR/issue-65436-raw-ptr-not-send.rs:18:41\n-   |\n-LL |         bar(Foo(std::ptr::null())).await;\n-   |                                         ^\n help: consider moving this into a `let` binding to create a shorter lived borrow\n   --> $DIR/issue-65436-raw-ptr-not-send.rs:18:13\n    |"}, {"sha": "2ce68a782918cf064c449afedab10f6815a2f3e2", "filename": "src/test/ui/async-await/issues/issue-67893.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-67893.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-67893.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-67893.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,14 +9,10 @@ note: future is not `Send` as this value is used across an await\n   --> $DIR/auxiliary/issue_67893.rs:9:26\n    |\n LL |     f(*x.lock().unwrap()).await;\n-   |        ----------------- ^^^^^^ await occurs here, with `x.lock().unwrap()` maybe used later\n-   |        |\n+   |        ----------------- ^^^^^^- `x.lock().unwrap()` is later dropped here\n+   |        |                 |\n+   |        |                 await occurs here, with `x.lock().unwrap()` maybe used later\n    |        has type `MutexGuard<'_, ()>` which is not `Send`\n-note: `x.lock().unwrap()` is later dropped here\n-  --> $DIR/auxiliary/issue_67893.rs:9:32\n-   |\n-LL |     f(*x.lock().unwrap()).await;\n-   |                                ^\n note: required by a bound in `g`\n   --> $DIR/issue-67893.rs:6:14\n    |"}, {"sha": "0a6f705e255ae4c89646860970e94e4cd53cbe93", "filename": "src/test/ui/async-await/pin-needed-to-poll-2.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -14,9 +14,6 @@ LL | struct Sleep(std::marker::PhantomPinned);\n    |        ^^^^^\n note: required by a bound in `Pin::<P>::new`\n   --> $SRC_DIR/core/src/pin.rs:LL:COL\n-   |\n-LL | impl<P: Deref<Target: Unpin>> Pin<P> {\n-   |                       ^^^^^ required by this bound in `Pin::<P>::new`\n \n error: aborting due to previous error\n "}, {"sha": "b1f4a73aafeabf317352e1ccf16cb163f9726e8c", "filename": "src/test/ui/async-await/pin-needed-to-poll.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,11 +6,9 @@ LL | struct Sleep;\n ...\n LL |         self.sleep.poll(cx)\n    |                    ^^^^ method not found in `Sleep`\n+  --> $SRC_DIR/core/src/future/future.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/future/future.rs:LL:COL\n-   |\n-LL |     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n-   |        ---- the method is available for `Pin<&mut Sleep>` here\n+   = note: the method is available for `Pin<&mut Sleep>` here\n    |\n help: consider wrapping the receiver expression with the appropriate type\n    |"}, {"sha": "8e81387c34bd056013659ffca95f4840e031f7d2", "filename": "src/test/ui/async-await/track-caller/async-block.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-block.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,9 @@\n+// edition:2021\n+\n+#![feature(closure_track_caller, stmt_expr_attributes)]\n+\n+fn main() {\n+    let _ = #[track_caller] async {\n+        //~^ ERROR attribute should be applied to a function definition [E0739]\n+    };\n+}"}, {"sha": "407439921c0d44dccec43274a576a60f4ed62ed5", "filename": "src/test/ui/async-await/track-caller/async-block.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-block.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,12 @@\n+error[E0739]: attribute should be applied to a function definition\n+  --> $DIR/async-block.rs:6:13\n+   |\n+LL |       let _ = #[track_caller] async {\n+   |  _____________^^^^^^^^^^^^^^^_-\n+LL | |\n+LL | |     };\n+   | |_____- not a function definition\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0739`."}, {"sha": "9593fdb1908e22213b5ea35303338e37379da8bf", "filename": "src/test/ui/async-await/track-caller/async-closure-gate.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,10 @@\n+// edition:2021\n+\n+#![feature(async_closure, stmt_expr_attributes)]\n+\n+fn main() {\n+    let _ = #[track_caller] async || {\n+        //~^ ERROR `#[track_caller]` on closures is currently unstable [E0658]\n+        //~| ERROR `#[track_caller]` on closures is currently unstable [E0658]\n+    };\n+}"}, {"sha": "be3d110eccdb002e68617843dfe505c456ecf91c", "filename": "src/test/ui/async-await/track-caller/async-closure-gate.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fasync-closure-gate.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,25 @@\n+error[E0658]: `#[track_caller]` on closures is currently unstable\n+  --> $DIR/async-closure-gate.rs:6:13\n+   |\n+LL |     let _ = #[track_caller] async || {\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #87417 <https://github.com/rust-lang/rust/issues/87417> for more information\n+   = help: add `#![feature(closure_track_caller)]` to the crate attributes to enable\n+\n+error[E0658]: `#[track_caller]` on closures is currently unstable\n+  --> $DIR/async-closure-gate.rs:6:38\n+   |\n+LL |       let _ = #[track_caller] async || {\n+   |  ______________________________________^\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: see issue #87417 <https://github.com/rust-lang/rust/issues/87417> for more information\n+   = help: add `#![feature(closure_track_caller)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "066cf97628fa5cd9d5852847bfddb5f799c7555a", "filename": "src/test/ui/async-await/track-caller/panic-track-caller.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n // edition:2021\n // needs-unwind\n-#![feature(closure_track_caller)]\n+#![feature(closure_track_caller, async_closure, stmt_expr_attributes)]\n \n use std::future::Future;\n use std::panic;\n@@ -67,6 +67,13 @@ async fn foo_assoc() {\n     Foo::bar_assoc().await\n }\n \n+async fn foo_closure() {\n+    let c = #[track_caller] async || {\n+        panic!();\n+    };\n+    c().await\n+}\n+\n fn panicked_at(f: impl FnOnce() + panic::UnwindSafe) -> u32 {\n     let loc = Arc::new(Mutex::new(None));\n \n@@ -87,4 +94,5 @@ fn main() {\n     assert_eq!(panicked_at(|| block_on(foo())), 41);\n     assert_eq!(panicked_at(|| block_on(foo_track_caller())), 54);\n     assert_eq!(panicked_at(|| block_on(foo_assoc())), 67);\n+    assert_eq!(panicked_at(|| block_on(foo_closure())), 74);\n }"}, {"sha": "6fbbb55437eb2f8b91a0d3dd17346411fbdcf7c4", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,9 +10,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn add(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn add<A: Add<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -46,9 +43,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn sub(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn sub<A: Sub<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -82,9 +76,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn mul(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn mul<A: Mul<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -118,9 +109,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn div(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn div<A: Div<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -154,9 +142,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn rem(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn rem<A: Rem<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -190,9 +175,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL |     fn bitand(self, rhs: Rhs) -> Self::Output;\n-   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitand<A: BitAnd<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -226,9 +208,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL |     fn bitor(self, rhs: Rhs) -> Self::Output;\n-   |              ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitor<A: BitOr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -262,9 +241,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL |     fn bitxor(self, rhs: Rhs) -> Self::Output;\n-   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitxor<A: BitXor<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -298,9 +274,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL |     fn shl(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shl<A: Shl<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -334,9 +307,6 @@ LL |     drop(lhs);\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL |     fn shr(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shr<A: Shr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {"}, {"sha": "dae267da05d1758bd31791fff00a437cc3066a8a", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,9 +13,6 @@ LL | |     x;\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn add(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn double_move<T: Add<Output=()> + Copy>(x: T) {\n@@ -78,9 +75,6 @@ LL | |     *n;\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn add(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n \n error[E0507]: cannot move out of `*n` which is behind a shared reference\n   --> $DIR/binop-move-semantics.rs:32:5"}, {"sha": "6e236ca5296a17eee6b9489dbcb05e4b3a4b32b6", "filename": "src/test/ui/binop/issue-28837.stderr", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fissue-28837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fissue-28837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-28837.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,11 +11,8 @@ note: an implementation of `Add<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Add<_>`\n-note: the following trait must be implemented\n+note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Add<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: cannot subtract `A` from `A`\n   --> $DIR/issue-28837.rs:8:7\n@@ -30,11 +27,8 @@ note: an implementation of `Sub<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Sub<_>`\n-note: the following trait must be implemented\n+note: the trait `Sub` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Sub<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: cannot multiply `A` by `A`\n   --> $DIR/issue-28837.rs:10:7\n@@ -49,11 +43,8 @@ note: an implementation of `Mul<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Mul<_>`\n-note: the following trait must be implemented\n+note: the trait `Mul` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Mul<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: cannot divide `A` by `A`\n   --> $DIR/issue-28837.rs:12:7\n@@ -68,11 +59,8 @@ note: an implementation of `Div<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Div<_>`\n-note: the following trait must be implemented\n+note: the trait `Div` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Div<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: cannot mod `A` by `A`\n   --> $DIR/issue-28837.rs:14:7\n@@ -87,11 +75,8 @@ note: an implementation of `Rem<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Rem<_>`\n-note: the following trait must be implemented\n+note: the trait `Rem` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Rem<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: no implementation for `A & A`\n   --> $DIR/issue-28837.rs:16:7\n@@ -106,11 +91,8 @@ note: an implementation of `BitAnd<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `BitAnd<_>`\n-note: the following trait must be implemented\n+note: the trait `BitAnd` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait BitAnd<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: no implementation for `A | A`\n   --> $DIR/issue-28837.rs:18:7\n@@ -125,11 +107,8 @@ note: an implementation of `BitOr<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `BitOr<_>`\n-note: the following trait must be implemented\n+note: the trait `BitOr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait BitOr<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: no implementation for `A << A`\n   --> $DIR/issue-28837.rs:20:7\n@@ -144,11 +123,8 @@ note: an implementation of `Shl<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Shl<_>`\n-note: the following trait must be implemented\n+note: the trait `Shl` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait Shl<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: no implementation for `A >> A`\n   --> $DIR/issue-28837.rs:22:7\n@@ -163,11 +139,8 @@ note: an implementation of `Shr<_>` might be missing for `A`\n    |\n LL | struct A;\n    | ^^^^^^^^ must implement `Shr<_>`\n-note: the following trait must be implemented\n+note: the trait `Shr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait Shr<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: binary operation `==` cannot be applied to type `A`\n   --> $DIR/issue-28837.rs:24:7"}, {"sha": "c313ed6037f3ab043aef865989ef6725449c7fb7", "filename": "src/test/ui/binop/issue-3820.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fissue-3820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbinop%2Fissue-3820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-3820.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,11 +11,8 @@ note: an implementation of `Mul<_>` might be missing for `Thing`\n    |\n LL | struct Thing {\n    | ^^^^^^^^^^^^ must implement `Mul<_>`\n-note: the following trait must be implemented\n+note: the trait `Mul` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Mul<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "abee72ba8cf97cb1ed9d5ca73462a894368d393b", "filename": "src/test/ui/borrowck/access-mode-in-closures.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Faccess-mode-in-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Faccess-mode-in-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Faccess-mode-in-closures.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,10 +3,15 @@ error[E0507]: cannot move out of `s` which is behind a shared reference\n    |\n LL |         match *s { S(v) => v }\n    |               ^^     -\n-   |               |      |\n-   |               |      data moved here\n-   |               |      move occurs because `v` has type `Vec<isize>`, which does not implement the `Copy` trait\n-   |               help: consider borrowing here: `&*s`\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `v` has type `Vec<isize>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -         match *s { S(v) => v }\n+LL +         match s { S(v) => v }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "f9ced03e0f038fd86afc5020f3c737349a99727b", "filename": "src/test/ui/borrowck/borrowck-for-loop-correct-cmt-for-pattern.stderr", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-correct-cmt-for-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-correct-cmt-for-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-correct-cmt-for-pattern.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,31 +2,46 @@ error[E0507]: cannot move out of a shared reference\n   --> $DIR/borrowck-for-loop-correct-cmt-for-pattern.rs:12:15\n    |\n LL |     for &a in x.iter() {\n-   |         --    ^^^^^^^^\n-   |         ||\n-   |         |data moved here\n-   |         |move occurs because `a` has type `&mut i32`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `a`\n+   |          -    ^^^^^^^^\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `&mut i32`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     for &a in x.iter() {\n+LL +     for a in x.iter() {\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/borrowck-for-loop-correct-cmt-for-pattern.rs:18:15\n    |\n LL |     for &a in &f.a {\n-   |         --    ^^^^\n-   |         ||\n-   |         |data moved here\n-   |         |move occurs because `a` has type `Box<isize>`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `a`\n+   |          -    ^^^^\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `Box<isize>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     for &a in &f.a {\n+LL +     for a in &f.a {\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/borrowck-for-loop-correct-cmt-for-pattern.rs:22:15\n    |\n LL |     for &a in x.iter() {\n-   |         --    ^^^^^^^^\n-   |         ||\n-   |         |data moved here\n-   |         |move occurs because `a` has type `Box<i32>`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `a`\n+   |          -    ^^^^^^^^\n+   |          |\n+   |          data moved here\n+   |          move occurs because `a` has type `Box<i32>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     for &a in x.iter() {\n+LL +     for a in x.iter() {\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "625e7c3cad590c668d6bfb80ebbbd4a9eb8b4c95", "filename": "src/test/ui/borrowck/borrowck-issue-2657-2.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+fn main() {\n+\n+    let x: Option<Box<_>> = Some(Box::new(1));\n+\n+    match x {\n+      Some(ref y) => {\n+        let _b = y; //~ ERROR cannot move out\n+      }\n+      _ => {}\n+    }\n+}"}, {"sha": "f79a846e70e7bcc9448267766c5050853ab43e20", "filename": "src/test/ui/borrowck/borrowck-issue-2657-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn main() {\n \n     let x: Option<Box<_>> = Some(Box::new(1));"}, {"sha": "850bb9ae3930c87c80ed595f8e22ae5789262c9f", "filename": "src/test/ui/borrowck/borrowck-issue-2657-2.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-2657-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,11 +1,14 @@\n error[E0507]: cannot move out of `*y` which is behind a shared reference\n-  --> $DIR/borrowck-issue-2657-2.rs:7:18\n+  --> $DIR/borrowck-issue-2657-2.rs:8:18\n    |\n LL |         let _b = *y;\n-   |                  ^^\n-   |                  |\n-   |                  move occurs because `*y` has type `Box<i32>`, which does not implement the `Copy` trait\n-   |                  help: consider borrowing here: `&*y`\n+   |                  ^^ move occurs because `*y` has type `Box<i32>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -         let _b = *y;\n+LL +         let _b = y;\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "cf6c382a692b263c089d6b6c42dcfb8e4518bc5f", "filename": "src/test/ui/borrowck/borrowck-move-error-with-note.fixed", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+#![allow(unused)]\n+enum Foo {\n+    Foo1(Box<u32>, Box<u32>),\n+    Foo2(Box<u32>),\n+    Foo3,\n+}\n+\n+\n+\n+fn blah() {\n+    let f = &Foo::Foo1(Box::new(1), Box::new(2));\n+    match f { //~ ERROR cannot move out of\n+        Foo::Foo1(num1,\n+                  num2) => (),\n+        Foo::Foo2(num) => (),\n+        Foo::Foo3 => ()\n+    }\n+}\n+\n+struct S {\n+    f: String,\n+    g: String\n+}\n+impl Drop for S {\n+    fn drop(&mut self) { println!(\"{}\", self.f); }\n+}\n+\n+fn move_in_match() {\n+    match (S {f: \"foo\".to_string(), g: \"bar\".to_string()}) {\n+        //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+        S {\n+            f: ref _s,\n+            g: ref _t\n+        } => {}\n+    }\n+}\n+\n+// from issue-8064\n+struct A {\n+    a: Box<isize>,\n+}\n+\n+fn free<T>(_: T) {}\n+\n+fn blah2() {\n+    let a = &A { a: Box::new(1) };\n+    match &a.a { //~ ERROR cannot move out of\n+        n => {\n+            free(n)\n+        }\n+    }\n+    free(a)\n+}\n+\n+fn main() {}"}, {"sha": "f336ac4f994fa6990d648c9a9fa5a8303a020102", "filename": "src/test/ui/borrowck/borrowck-move-error-with-note.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+#![allow(unused)]\n enum Foo {\n     Foo1(Box<u32>, Box<u32>),\n     Foo2(Box<u32>),"}, {"sha": "722c2c1443a7fd6d4a74d04f1920b44f1052c79c", "filename": "src/test/ui/borrowck/borrowck-move-error-with-note.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,8 +1,8 @@\n error[E0507]: cannot move out of `f` as enum variant `Foo1` which is behind a shared reference\n-  --> $DIR/borrowck-move-error-with-note.rs:11:11\n+  --> $DIR/borrowck-move-error-with-note.rs:13:11\n    |\n LL |     match *f {\n-   |           ^^ help: consider borrowing here: `&*f`\n+   |           ^^\n LL |         Foo::Foo1(num1,\n    |                   ---- data moved here\n LL |                   num2) => (),\n@@ -11,9 +11,14 @@ LL |         Foo::Foo2(num) => (),\n    |                   --- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the dereference here\n+   |\n+LL -     match *f {\n+LL +     match f {\n+   |\n \n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-error-with-note.rs:28:11\n+  --> $DIR/borrowck-move-error-with-note.rs:30:11\n    |\n LL |     match (S {f: \"foo\".to_string(), g: \"bar\".to_string()}) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n@@ -24,17 +29,30 @@ LL |             g: _t\n    |                -- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing the pattern binding\n+   |\n+LL |             f: ref _s,\n+   |                +++\n+help: consider borrowing the pattern binding\n+   |\n+LL |             g: ref _t\n+   |                +++\n \n error[E0507]: cannot move out of `a.a` which is behind a shared reference\n-  --> $DIR/borrowck-move-error-with-note.rs:46:11\n+  --> $DIR/borrowck-move-error-with-note.rs:48:11\n    |\n LL |     match a.a {\n-   |           ^^^ help: consider borrowing here: `&a.a`\n+   |           ^^^\n LL |         n => {\n    |         -\n    |         |\n    |         data moved here\n    |         move occurs because `n` has type `Box<isize>`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     match &a.a {\n+   |           +\n \n error: aborting due to 3 previous errors\n "}, {"sha": "43fc102bd6256c90ea6a650670e487b1e0c49b60", "filename": "src/test/ui/borrowck/borrowck-move-from-unsafe-ptr.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,13 @@ error[E0507]: cannot move out of `*x` which is behind a raw pointer\n   --> $DIR/borrowck-move-from-unsafe-ptr.rs:2:13\n    |\n LL |     let y = *x;\n-   |             ^^\n-   |             |\n-   |             move occurs because `*x` has type `Box<isize>`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*x`\n+   |             ^^ move occurs because `*x` has type `Box<isize>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let y = *x;\n+LL +     let y = x;\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "21bd073321b8374dff41d9e842a537a21ec33fbb", "filename": "src/test/ui/borrowck/borrowck-move-in-irrefut-pat.stderr", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-in-irrefut-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-in-irrefut-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-in-irrefut-pat.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,30 +3,45 @@ error[E0507]: cannot move out of a shared reference\n    |\n LL | fn arg_item(&_x: &String) {}\n    |             ^--\n-   |             ||\n-   |             |data moved here\n-   |             |move occurs because `_x` has type `String`, which does not implement the `Copy` trait\n-   |             help: consider removing the `&`: `_x`\n+   |              |\n+   |              data moved here\n+   |              move occurs because `_x` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL - fn arg_item(&_x: &String) {}\n+LL + fn arg_item(_x: &String) {}\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/borrowck-move-in-irrefut-pat.rs:7:11\n    |\n LL |     with(|&_x| ())\n    |           ^--\n-   |           ||\n-   |           |data moved here\n-   |           |move occurs because `_x` has type `String`, which does not implement the `Copy` trait\n-   |           help: consider removing the `&`: `_x`\n+   |            |\n+   |            data moved here\n+   |            move occurs because `_x` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     with(|&_x| ())\n+LL +     with(|_x| ())\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/borrowck-move-in-irrefut-pat.rs:12:15\n    |\n LL |     let &_x = &\"hi\".to_string();\n-   |         ---   ^^^^^^^^^^^^^^^^^\n-   |         ||\n-   |         |data moved here\n-   |         |move occurs because `_x` has type `String`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `_x`\n+   |          --   ^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          data moved here\n+   |          move occurs because `_x` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     let &_x = &\"hi\".to_string();\n+LL +     let _x = &\"hi\".to_string();\n+   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ecf5382e863e00336d9ec449722a272f8044d628", "filename": "src/test/ui/borrowck/borrowck-move-out-of-overloaded-auto-deref.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,11 +7,8 @@ LL |     let _x = Rc::new(vec![1, 2]).into_iter();\n    |              |                   value moved due to this method call\n    |              move occurs because value has type `Vec<i32>`, which does not implement the `Copy` trait\n    |\n-note: this function takes ownership of the receiver `self`, which moves value\n+note: `into_iter` takes ownership of the receiver `self`, which moves value\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "599fa1e88dfecdd4dfd882aa6a31f94091c48ed6", "filename": "src/test/ui/borrowck/borrowck-move-out-of-overloaded-deref.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-overloaded-deref.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,13 @@ error[E0507]: cannot move out of an `Rc`\n   --> $DIR/borrowck-move-out-of-overloaded-deref.rs:4:14\n    |\n LL |     let _x = *Rc::new(\"hi\".to_string());\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              move occurs because value has type `String`, which does not implement the `Copy` trait\n-   |              help: consider borrowing here: `&*Rc::new(\"hi\".to_string())`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let _x = *Rc::new(\"hi\".to_string());\n+LL +     let _x = Rc::new(\"hi\".to_string());\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "c463c6559386c45265021279337c4bc644e7104f", "filename": "src/test/ui/borrowck/borrowck-move-out-of-struct-with-dtor.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![allow(unused)]\n+struct S {f:String}\n+impl Drop for S {\n+    fn drop(&mut self) { println!(\"{}\", self.f); }\n+}\n+\n+fn move_in_match() {\n+    match (S {f:\"foo\".to_string()}) {\n+        //~^ ERROR [E0509]\n+        S {f:ref _s} => {}\n+    }\n+}\n+\n+fn move_in_let() {\n+    let S {f:ref _s} = S {f:\"foo\".to_string()};\n+    //~^ ERROR [E0509]\n+}\n+\n+fn move_in_fn_arg(S {f:ref _s}: S) {\n+    //~^ ERROR [E0509]\n+}\n+\n+fn main() {}"}, {"sha": "93183062d61b319ac075ee4249d6c8d291f47899", "filename": "src/test/ui/borrowck/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+#![allow(unused)]\n struct S {f:String}\n impl Drop for S {\n     fn drop(&mut self) { println!(\"{}\", self.f); }"}, {"sha": "58f706c65ff281fc78101fac28e4812d7a084877", "filename": "src/test/ui/borrowck/borrowck-move-out-of-struct-with-dtor.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,5 +1,5 @@\n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-out-of-struct-with-dtor.rs:7:11\n+  --> $DIR/borrowck-move-out-of-struct-with-dtor.rs:9:11\n    |\n LL |     match (S {f:\"foo\".to_string()}) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n@@ -9,25 +9,40 @@ LL |         S {f:_s} => {}\n    |              |\n    |              data moved here\n    |              move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         S {f:ref _s} => {}\n+   |              +++\n \n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-out-of-struct-with-dtor.rs:14:20\n+  --> $DIR/borrowck-move-out-of-struct-with-dtor.rs:16:20\n    |\n LL |     let S {f:_s} = S {f:\"foo\".to_string()};\n    |              --    ^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n    |              |\n    |              data moved here\n    |              move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let S {f:ref _s} = S {f:\"foo\".to_string()};\n+   |              +++\n \n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-out-of-struct-with-dtor.rs:18:19\n+  --> $DIR/borrowck-move-out-of-struct-with-dtor.rs:20:19\n    |\n LL | fn move_in_fn_arg(S {f:_s}: S) {\n    |                   ^^^^^--^\n    |                   |    |\n    |                   |    data moved here\n    |                   |    move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n    |                   cannot move out of here\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL | fn move_in_fn_arg(S {f:ref _s}: S) {\n+   |                        +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "bc2ddf85fb4a856d32352fc585c0ab54c45c88ff", "filename": "src/test/ui/borrowck/borrowck-move-out-of-tuple-struct-with-dtor.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![allow(unused)]\n+struct S(String);\n+impl Drop for S {\n+    fn drop(&mut self) { }\n+}\n+\n+fn move_in_match() {\n+    match S(\"foo\".to_string()) {\n+        //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+        S(ref _s) => {}\n+    }\n+}\n+\n+fn move_in_let() {\n+    let S(ref _s) = S(\"foo\".to_string());\n+    //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+}\n+\n+fn move_in_fn_arg(S(ref _s): S) {\n+    //~^ ERROR cannot move out of type `S`, which implements the `Drop` trait\n+}\n+\n+fn main() {}"}, {"sha": "f050bce87406799608f4e1db27e3c26f845ecc30", "filename": "src/test/ui/borrowck/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+#![allow(unused)]\n struct S(String);\n impl Drop for S {\n     fn drop(&mut self) { }"}, {"sha": "160a1f99f63f657c536ed8d63481af37d3246a42", "filename": "src/test/ui/borrowck/borrowck-move-out-of-tuple-struct-with-dtor.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-tuple-struct-with-dtor.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,5 +1,5 @@\n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-out-of-tuple-struct-with-dtor.rs:7:11\n+  --> $DIR/borrowck-move-out-of-tuple-struct-with-dtor.rs:9:11\n    |\n LL |     match S(\"foo\".to_string()) {\n    |           ^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n@@ -9,25 +9,40 @@ LL |         S(_s) => {}\n    |           |\n    |           data moved here\n    |           move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         S(ref _s) => {}\n+   |           +++\n \n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-out-of-tuple-struct-with-dtor.rs:14:17\n+  --> $DIR/borrowck-move-out-of-tuple-struct-with-dtor.rs:16:17\n    |\n LL |     let S(_s) = S(\"foo\".to_string());\n    |           --    ^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n    |           |\n    |           data moved here\n    |           move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let S(ref _s) = S(\"foo\".to_string());\n+   |           +++\n \n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-out-of-tuple-struct-with-dtor.rs:18:19\n+  --> $DIR/borrowck-move-out-of-tuple-struct-with-dtor.rs:20:19\n    |\n LL | fn move_in_fn_arg(S(_s): S) {\n    |                   ^^--^\n    |                   | |\n    |                   | data moved here\n    |                   | move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n    |                   cannot move out of here\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL | fn move_in_fn_arg(S(ref _s): S) {\n+   |                     +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9ff20a1f46a127ea3c5c6a970869eb53966d20f1", "filename": "src/test/ui/borrowck/borrowck-move-out-of-vec-tail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,10 +10,10 @@ LL |                   Foo { string: b }] => {\n    |                                 - ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n-help: consider removing the `&`\n+help: consider removing the borrow\n    |\n-LL ~                 [Foo { string: a },\n-LL ~                   Foo { string: b }] => {\n+LL -                 &[Foo { string: a },\n+LL +                 [Foo { string: a },\n    |\n \n error: aborting due to previous error"}, {"sha": "f5f4817e9bf3220f9a619064f3c8d75d5c766dc6", "filename": "src/test/ui/borrowck/borrowck-overloaded-index-move-from-vec.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-from-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-from-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-from-vec.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,12 @@ error[E0507]: cannot move out of index of `MyVec<Box<i32>>`\n   --> $DIR/borrowck-overloaded-index-move-from-vec.rs:20:15\n    |\n LL |     let bad = v[0];\n-   |               ^^^^\n-   |               |\n-   |               move occurs because value has type `Box<i32>`, which does not implement the `Copy` trait\n-   |               help: consider borrowing here: `&v[0]`\n+   |               ^^^^ move occurs because value has type `Box<i32>`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let bad = &v[0];\n+   |               +\n \n error: aborting due to previous error\n "}, {"sha": "0e9284a2cadd26cf48564328da88ebe070829077", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -37,7 +37,7 @@ fn c() {\n         &mut [_a,\n         //~^ NOTE data moved here\n         //~| NOTE move occurs because `_a` has type\n-        //~| HELP consider removing the `&mut`\n+        //~| HELP consider removing the mutable borrow\n             ..\n         ] => {\n         }\n@@ -56,7 +56,7 @@ fn d() {\n         //~^ ERROR cannot move out\n         //~| NOTE cannot move out\n         &mut [\n-        //~^ HELP consider removing the `&mut`\n+        //~^ HELP consider removing the mutable borrow\n          _b] => {}\n         //~^ NOTE data moved here\n         //~| NOTE move occurs because `_b` has type\n@@ -79,7 +79,7 @@ fn e() {\n         //~^ NOTE data moved here\n         //~| NOTE and here\n         //~| NOTE and here\n-        //~| HELP consider removing the `&mut`\n+        //~| HELP consider removing the mutable borrow\n         _ => {}\n     }\n     let a = vec[0]; //~ ERROR cannot move out"}, {"sha": "0dc5e64e4ff3022ee92075d07b49bd3c2134729e", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.stderr", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -34,14 +34,10 @@ LL |         &mut [_a,\n    |               data moved here\n    |               move occurs because `_a` has type `Box<isize>`, which does not implement the `Copy` trait\n    |\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n    |\n-LL ~         [_a,\n-LL +\n-LL +\n-LL +\n-LL +             ..\n-LL ~         ] => {\n+LL -         &mut [_a,\n+LL +         [_a,\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n@@ -52,7 +48,11 @@ LL |     let a = vec[0];\n    |             |\n    |             cannot move out of here\n    |             move occurs because `vec[_]` has type `Box<isize>`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&vec[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let a = &vec[0];\n+   |             +\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:55:11\n@@ -66,11 +66,10 @@ LL |          _b] => {}\n    |          data moved here\n    |          move occurs because `_b` has type `Box<isize>`, which does not implement the `Copy` trait\n    |\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n    |\n-LL ~         [\n-LL +\n-LL ~          _b] => {}\n+LL -         &mut [\n+LL +         [\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n@@ -81,7 +80,11 @@ LL |     let a = vec[0];\n    |             |\n    |             cannot move out of here\n    |             move occurs because `vec[_]` has type `Box<isize>`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&vec[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let a = &vec[0];\n+   |             +\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:74:11\n@@ -90,14 +93,17 @@ LL |     match vec {\n    |           ^^^ cannot move out of here\n ...\n LL |         &mut [_a, _b, _c] => {}\n-   |         -----------------\n-   |         |     |   |   |\n-   |         |     |   |   ...and here\n-   |         |     |   ...and here\n-   |         |     data moved here\n-   |         help: consider removing the `&mut`: `[_a, _b, _c]`\n+   |               --  --  -- ...and here\n+   |               |   |\n+   |               |   ...and here\n+   |               data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut [_a, _b, _c] => {}\n+LL +         [_a, _b, _c] => {}\n+   |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:85:13\n@@ -107,7 +113,11 @@ LL |     let a = vec[0];\n    |             |\n    |             cannot move out of here\n    |             move occurs because `vec[_]` has type `Box<isize>`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&vec[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let a = &vec[0];\n+   |             +\n \n error: aborting due to 8 previous errors\n "}, {"sha": "65aea5b1834b0dc750be678ea46c8216b05773f7", "filename": "src/test/ui/borrowck/issue-17718-static-move.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-17718-static-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-17718-static-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-17718-static-move.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,12 @@ error[E0507]: cannot move out of static item `FOO`\n   --> $DIR/issue-17718-static-move.rs:6:14\n    |\n LL |     let _a = FOO;\n-   |              ^^^\n-   |              |\n-   |              move occurs because `FOO` has type `Foo`, which does not implement the `Copy` trait\n-   |              help: consider borrowing here: `&FOO`\n+   |              ^^^ move occurs because `FOO` has type `Foo`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let _a = &FOO;\n+   |              +\n \n error: aborting due to previous error\n "}, {"sha": "215bf0100636949a6eda04a58eec81bdaab2dd8f", "filename": "src/test/ui/borrowck/issue-20801.stderr", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-20801.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-20801.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-20801.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,37 +2,49 @@ error[E0507]: cannot move out of a mutable reference\n   --> $DIR/issue-20801.rs:26:22\n    |\n LL |     let a = unsafe { *mut_ref() };\n-   |                      ^^^^^^^^^^\n-   |                      |\n-   |                      move occurs because value has type `T`, which does not implement the `Copy` trait\n-   |                      help: consider borrowing here: `&*mut_ref()`\n+   |                      ^^^^^^^^^^ move occurs because value has type `T`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let a = unsafe { *mut_ref() };\n+LL +     let a = unsafe { mut_ref() };\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/issue-20801.rs:29:22\n    |\n LL |     let b = unsafe { *imm_ref() };\n-   |                      ^^^^^^^^^^\n-   |                      |\n-   |                      move occurs because value has type `T`, which does not implement the `Copy` trait\n-   |                      help: consider borrowing here: `&*imm_ref()`\n+   |                      ^^^^^^^^^^ move occurs because value has type `T`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let b = unsafe { *imm_ref() };\n+LL +     let b = unsafe { imm_ref() };\n+   |\n \n error[E0507]: cannot move out of a raw pointer\n   --> $DIR/issue-20801.rs:32:22\n    |\n LL |     let c = unsafe { *mut_ptr() };\n-   |                      ^^^^^^^^^^\n-   |                      |\n-   |                      move occurs because value has type `T`, which does not implement the `Copy` trait\n-   |                      help: consider borrowing here: `&*mut_ptr()`\n+   |                      ^^^^^^^^^^ move occurs because value has type `T`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let c = unsafe { *mut_ptr() };\n+LL +     let c = unsafe { mut_ptr() };\n+   |\n \n error[E0507]: cannot move out of a raw pointer\n   --> $DIR/issue-20801.rs:35:22\n    |\n LL |     let d = unsafe { *const_ptr() };\n-   |                      ^^^^^^^^^^^^\n-   |                      |\n-   |                      move occurs because value has type `T`, which does not implement the `Copy` trait\n-   |                      help: consider borrowing here: `&*const_ptr()`\n+   |                      ^^^^^^^^^^^^ move occurs because value has type `T`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let d = unsafe { *const_ptr() };\n+LL +     let d = unsafe { const_ptr() };\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "8d4918867f75ec1d9bf0d1675fe904225b39aa4f", "filename": "src/test/ui/borrowck/issue-47215-ice-from-drop-elab.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-47215-ice-from-drop-elab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-47215-ice-from-drop-elab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-47215-ice-from-drop-elab.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,12 @@ error[E0507]: cannot move out of static item `X`\n   --> $DIR/issue-47215-ice-from-drop-elab.rs:17:21\n    |\n LL |         let mut x = X;\n-   |                     ^\n-   |                     |\n-   |                     move occurs because `X` has type `AtomicUsize`, which does not implement the `Copy` trait\n-   |                     help: consider borrowing here: `&X`\n+   |                     ^ move occurs because `X` has type `AtomicUsize`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         let mut x = &X;\n+   |                     +\n \n error: aborting due to previous error\n "}, {"sha": "6ec920cb81f3904120aefc21178b4bc5bfe79a52", "filename": "src/test/ui/borrowck/issue-51301.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51301.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51301.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51301.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,6 +6,11 @@ LL |             .find(|(&event_type, _)| event == event_type)\n    |                      |\n    |                      data moved here\n    |                      move occurs because `event_type` has type `EventType`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |             .find(|(&ref event_type, _)| event == event_type)\n+   |                      +++\n \n error: aborting due to previous error\n "}, {"sha": "92943f6c9ecb2b1e9e69b0c38a2392a85048d9d5", "filename": "src/test/ui/borrowck/issue-51415.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+// Regression test for #51415: match default bindings were failing to\n+// see the \"move out\" implied by `&s` below.\n+\n+fn main() {\n+    let a = vec![String::from(\"a\")];\n+    let opt = a.iter().enumerate().find(|(_, &ref s)| {\n+        //~^ ERROR cannot move out\n+        *s == String::from(\"d\")\n+    }).map(|(i, _)| i);\n+    println!(\"{:?}\", opt);\n+}"}, {"sha": "56ed57a61a0feeb252c3acc6d6bc38491fc78c18", "filename": "src/test/ui/borrowck/issue-51415.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n // Regression test for #51415: match default bindings were failing to\n // see the \"move out\" implied by `&s` below.\n "}, {"sha": "0d486b45592b5d7f792dd3f9779c1afb78cc7c03", "filename": "src/test/ui/borrowck/issue-51415.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,11 +1,16 @@\n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/issue-51415.rs:6:42\n+  --> $DIR/issue-51415.rs:7:42\n    |\n LL |     let opt = a.iter().enumerate().find(|(_, &s)| {\n    |                                          ^^^^^-^\n    |                                               |\n    |                                               data moved here\n    |                                               move occurs because `s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let opt = a.iter().enumerate().find(|(_, &ref s)| {\n+   |                                               +++\n \n error: aborting due to previous error\n "}, {"sha": "99c63e4db50d3edbeff290d2a2a503b9b3f80cae", "filename": "src/test/ui/borrowck/issue-54597-reject-move-out-of-borrow-via-pat.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,13 @@ error[E0507]: cannot move out of `*array` which is behind a shared reference\n   --> $DIR/issue-54597-reject-move-out-of-borrow-via-pat.rs:14:13\n    |\n LL |             *array\n-   |             ^^^^^^\n-   |             |\n-   |             move occurs because `*array` has type `Vec<Value>`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*array`\n+   |             ^^^^^^ move occurs because `*array` has type `Vec<Value>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -             *array\n+LL +             array\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "a585bff0c654395b8c208ca5c29ca9f5f7a70d2b", "filename": "src/test/ui/borrowck/issue-83760.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-83760.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -27,11 +27,8 @@ LL |         foo = Some(Struct);\n LL |     let _y = foo;\n    |              ^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `foo`\n+note: `Option::<T>::unwrap` takes ownership of the receiver `self`, which moves `foo`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     pub const fn unwrap(self) -> T {\n-   |                         ^^^^\n \n error[E0382]: use of moved value: `foo`\n   --> $DIR/issue-83760.rs:37:14\n@@ -55,11 +52,8 @@ LL |         foo = Some(Struct);\n LL |     } else if true {\n LL |         foo = Some(Struct);\n    |         ^^^^^^^^^^^^^^^^^^\n-note: this function takes ownership of the receiver `self`, which moves `foo`\n+note: `Option::<T>::unwrap` takes ownership of the receiver `self`, which moves `foo`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     pub const fn unwrap(self) -> T {\n-   |                         ^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "afd141125ac7c9b3204ab714eab1e35244ef84bc", "filename": "src/test/ui/borrowck/issue-87456-point-to-closure.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-87456-point-to-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fissue-87456-point-to-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-87456-point-to-closure.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,10 +8,12 @@ LL |     take_mut(|| {\n    |              -- captured by this `FnMut` closure\n LL |\n LL |         let _foo: String = val;\n-   |                            ^^^\n-   |                            |\n-   |                            move occurs because `val` has type `String`, which does not implement the `Copy` trait\n-   |                            help: consider borrowing here: `&val`\n+   |                            ^^^ move occurs because `val` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         let _foo: String = &val;\n+   |                            +\n \n error: aborting due to previous error\n "}, {"sha": "8ac711e9e59db806a8d128dd54bb999c60be2fe1", "filename": "src/test/ui/borrowck/move-error-snippets.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,17 +2,18 @@ error[E0507]: cannot move out of static item `D`\n   --> $DIR/move-error-snippets-ext.rs:5:17\n    |\n LL |         let a = $c;\n-   |                 ^^\n-   |                 |\n-   |                 move occurs because `D` has type `A`, which does not implement the `Copy` trait\n-   |                 help: consider borrowing here: `&$c`\n+   |                 ^^ move occurs because `D` has type `A`, which does not implement the `Copy` trait\n    |\n   ::: $DIR/move-error-snippets.rs:21:1\n    |\n LL | sss!();\n    | ------ in this macro invocation\n    |\n    = note: this error originates in the macro `aaa` which comes from the expansion of the macro `sss` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider borrowing here\n+   |\n+LL |         let a = &$c;\n+   |                 +\n \n error: aborting due to previous error\n "}, {"sha": "ecd916a59fcbd725da4a3d607e951a71377ff885", "filename": "src/test/ui/borrowck/reborrow-sugg-move-then-borrow.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Freborrow-sugg-move-then-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Freborrow-sugg-move-then-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freborrow-sugg-move-then-borrow.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,11 +9,8 @@ LL |\n LL |     fill_segment(state);\n    |                  ^^^^^ value borrowed here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `state`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `state`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider creating a fresh reborrow of `state` here\n    |\n LL |     for _ in &mut *state {}"}, {"sha": "4621d8793514ac8dd2cf858dd6e1d424cd6c9eb8", "filename": "src/test/ui/borrowck/suggest-as-ref-on-mut-closure.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,11 +8,8 @@ LL |     cb.map(|cb| cb());\n    |     help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n    |     move occurs because `*cb` has type `Option<&mut dyn FnMut()>`, which does not implement the `Copy` trait\n    |\n-note: this function takes ownership of the receiver `self`, which moves `*cb`\n+note: `Option::<T>::map` takes ownership of the receiver `self`, which moves `*cb`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     pub const fn map<U, F>(self, f: F) -> Option<U>\n-   |                            ^^^^\n \n error[E0596]: cannot borrow `*cb` as mutable, as it is behind a `&` reference\n   --> $DIR/suggest-as-ref-on-mut-closure.rs:12:26"}, {"sha": "b1367c652188bd8f4bafd95c2addf26ea843e94b", "filename": "src/test/ui/borrowck/unboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,11 +10,8 @@ LL |         y.into_iter();\n    |         |\n    |         move occurs because `y` has type `Vec<String>`, which does not implement the `Copy` trait\n    |\n-note: this function takes ownership of the receiver `self`, which moves `y`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `y`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f102f666dc2769daf19207fafb13ed30af11cb3a", "filename": "src/test/ui/box/into-boxed-slice-fail.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbox%2Finto-boxed-slice-fail.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     let _ = Box::into_boxed_slice(boxed_slice);\n    = help: the trait `Sized` is not implemented for `[u8]`\n note: required by a bound in `Box::<T, A>::into_boxed_slice`\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | impl<T, A: Allocator> Box<T, A> {\n-   |      ^ required by this bound in `Box::<T, A>::into_boxed_slice`\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> $DIR/into-boxed-slice-fail.rs:7:13\n@@ -33,9 +30,6 @@ LL |     let _ = Box::into_boxed_slice(boxed_trait);\n    = help: the trait `Sized` is not implemented for `dyn Debug`\n note: required by a bound in `Box::<T, A>::into_boxed_slice`\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | impl<T, A: Allocator> Box<T, A> {\n-   |      ^ required by this bound in `Box::<T, A>::into_boxed_slice`\n \n error[E0277]: the size for values of type `dyn Debug` cannot be known at compilation time\n   --> $DIR/into-boxed-slice-fail.rs:11:13"}, {"sha": "f68d181291dd7f49456e8ae28eeaf9cbf445035b", "filename": "src/test/ui/by-move-pattern-binding.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fby-move-pattern-binding.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -19,4 +19,11 @@ fn main() {\n         &E::Foo => {}\n         &E::Bar(ref identifier) => println!(\"{}\", *identifier)\n     };\n+    if let &E::Bar(identifier) = &s.x { //~ ERROR cannot move\n+        f(identifier.clone());\n+    };\n+    let &E::Bar(identifier) = &s.x else { //~ ERROR cannot move\n+        return;\n+    };\n+    f(identifier.clone());\n }"}, {"sha": "203e37dc387c1526798c544ae1dec9e3c36b4963", "filename": "src/test/ui/by-move-pattern-binding.stderr", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fby-move-pattern-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fby-move-pattern-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fby-move-pattern-binding.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -5,12 +5,47 @@ LL |     match &s.x {\n    |           ^^^^\n LL |         &E::Foo => {}\n LL |         &E::Bar(identifier) => f(identifier.clone())\n-   |         -------------------\n-   |         |       |\n-   |         |       data moved here\n-   |         |       move occurs because `identifier` has type `String`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `E::Bar(identifier)`\n+   |                 ----------\n+   |                 |\n+   |                 data moved here\n+   |                 move occurs because `identifier` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &E::Bar(identifier) => f(identifier.clone())\n+LL +         E::Bar(identifier) => f(identifier.clone())\n+   |\n+\n+error[E0507]: cannot move out of a shared reference\n+  --> $DIR/by-move-pattern-binding.rs:22:34\n+   |\n+LL |     if let &E::Bar(identifier) = &s.x {\n+   |                    ----------    ^^^^\n+   |                    |\n+   |                    data moved here\n+   |                    move occurs because `identifier` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     if let &E::Bar(identifier) = &s.x {\n+LL +     if let E::Bar(identifier) = &s.x {\n+   |\n+\n+error[E0507]: cannot move out of a shared reference\n+  --> $DIR/by-move-pattern-binding.rs:25:31\n+   |\n+LL |     let &E::Bar(identifier) = &s.x else {\n+   |                 ----------    ^^^^\n+   |                 |\n+   |                 data moved here\n+   |                 move occurs because `identifier` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     let &E::Bar(identifier) = &s.x else {\n+LL +     let E::Bar(identifier) = &s.x else {\n+   |\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0507`."}, {"sha": "d1f13d52362da8bf6f8e89045d4a432e497a42f5", "filename": "src/test/ui/c-variadic/issue-86053-1.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fc-variadic%2Fissue-86053-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fc-variadic%2Fissue-86053-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fissue-86053-1.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -63,11 +63,9 @@ error[E0412]: cannot find type `F` in this scope\n    |\n LL |     self , ... ,   self ,   self , ... ) where F : FnOnce ( & 'a & 'b usize ) {\n    |                                                ^\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n    |\n help: a trait with a similar name exists\n    |"}, {"sha": "eda867f4159ff7d5f82f5a8f8050f904137cf01b", "filename": "src/test/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -14,9 +14,6 @@ LL | | }\n    = note: [async fn body@$DIR/async.rs:7:29: 9:2] must be a future or must implement `IntoFuture` to be awaited\n note: required by a bound in `identity_future`\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n-   |\n-LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n-   |                                      ^^^^^^^^^^^^^^^^^^ required by this bound in `identity_future`\n \n error[E0277]: the size for values of type `<[async fn body@$DIR/async.rs:7:29: 9:2] as Future>::Output` cannot be known at compilation time\n   --> $DIR/async.rs:7:29\n@@ -30,9 +27,6 @@ LL | | }\n    = help: the trait `Sized` is not implemented for `<[async fn body@$DIR/async.rs:7:29: 9:2] as Future>::Output`\n note: required by a bound in `identity_future`\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n-   |\n-LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n-   |                              ^ required by this bound in `identity_future`\n \n error[E0277]: `[async fn body@$DIR/async.rs:7:29: 9:2]` is not a future\n   --> $DIR/async.rs:7:25"}, {"sha": "b13700a4ea5ba9fedaee2a266d22dc47b392e564", "filename": "src/test/ui/check-static-values-constraints.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -58,10 +58,12 @@ error[E0507]: cannot move out of static item `x`\n   --> $DIR/check-static-values-constraints.rs:110:45\n    |\n LL |     let y = { static x: Box<isize> = box 3; x };\n-   |                                             ^\n-   |                                             |\n-   |                                             move occurs because `x` has type `Box<isize>`, which does not implement the `Copy` trait\n-   |                                             help: consider borrowing here: `&x`\n+   |                                             ^ move occurs because `x` has type `Box<isize>`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let y = { static x: Box<isize> = box 3; &x };\n+   |                                             +\n \n error[E0010]: allocations are not allowed in statics\n   --> $DIR/check-static-values-constraints.rs:110:38"}, {"sha": "87a5d67a420c498c2a7926dfbaf6f4300eb83d5f", "filename": "src/test/ui/closures/closure-expected.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,9 +10,6 @@ LL |     let y = x.or_else(4);\n    = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `Option::<T>::or_else`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |         F: ~const FnOnce() -> Option<T>,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::or_else`\n \n error: aborting due to previous error\n "}, {"sha": "64e3b51ea713bf25e60f05b4ab0a9befcba53042", "filename": "src/test/ui/closures/closure-move-sync.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fclosure-move-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fclosure-move-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-move-sync.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -19,9 +19,6 @@ LL |     let t = thread::spawn(|| {\n    |                           ^^\n note: required by a bound in `spawn`\n   --> $SRC_DIR/std/src/thread/mod.rs:LL:COL\n-   |\n-LL |     F: Send + 'static,\n-   |        ^^^^ required by this bound in `spawn`\n \n error[E0277]: `Sender<()>` cannot be shared between threads safely\n   --> $DIR/closure-move-sync.rs:18:19\n@@ -40,9 +37,6 @@ LL |     thread::spawn(|| tx.send(()).unwrap());\n    |                   ^^\n note: required by a bound in `spawn`\n   --> $SRC_DIR/std/src/thread/mod.rs:LL:COL\n-   |\n-LL |     F: Send + 'static,\n-   |        ^^^^ required by this bound in `spawn`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "449cd0b317757bfef4d48f71d1fd4e9d1a84fa6c", "filename": "src/test/ui/closures/coerce-unsafe-to-closure.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fcoerce-unsafe-to-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fcoerce-unsafe-to-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fcoerce-unsafe-to-closure.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,9 +10,6 @@ LL |     let x: Option<&[u8]> = Some(\"foo\").map(std::mem::transmute);\n    = note: unsafe function cannot be called generically without an unsafe block\n note: required by a bound in `Option::<T>::map`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |         F: ~const FnOnce(T) -> U,\n-   |            ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n \n error: aborting due to previous error\n "}, {"sha": "1e860d32b2a06ea523cfc0ec086cf25cf61c35d1", "filename": "src/test/ui/closures/issue-78720.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fissue-78720.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fissue-78720.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-78720.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,11 +9,9 @@ error[E0412]: cannot find type `F` in this scope\n    |\n LL |     _func: F,\n    |            ^\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n    |\n help: a trait with a similar name exists\n    |"}, {"sha": "72337892734e6af3a29009053ff42133f6f92f51", "filename": "src/test/ui/closures/issue-87461.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fissue-87461.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fissue-87461.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-87461.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,9 +8,6 @@ LL |     Ok(())\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-87461.rs:17:8\n@@ -22,9 +19,6 @@ LL |     Ok(())\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-87461.rs:26:12\n@@ -36,9 +30,6 @@ LL |         Ok(())\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "4a578b4d7f536204cfc6ae09a79ab5338f82c55e", "filename": "src/test/ui/closures/issue-90871.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-90871.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error[E0412]: cannot find type `n` in this scope\n    |\n LL |     type_ascribe!(2, n([u8; || 1]))\n    |                      ^ help: a trait with a similar name exists: `Fn`\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n \n error[E0308]: mismatched types\n   --> $DIR/issue-90871.rs:4:29"}, {"sha": "e0e369124a4be83557473cfd87160a5837647408", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,11 +9,8 @@ LL |     {\n LL |         println!(\"{:?}\", some_vec);\n    |                          ^^^^^^^^ value borrowed here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `some_vec`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `some_vec`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider cloning the value if the performance cost is acceptable\n    |"}, {"sha": "293ca6232b14e02cf2686de4a201c2352ffc0c4d", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |     let y = Mask::<_, _>::splat(false);\n    = note: cannot satisfy `_: MaskElement`\n note: required by a bound in `Mask::<T, LANES>::splat`\n   --> $SRC_DIR/core/src/../../portable-simd/crates/core_simd/src/masks.rs:LL:COL\n-   |\n-LL |     T: MaskElement,\n-   |        ^^^^^^^^^^^ required by this bound in `Mask::<T, LANES>::splat`\n help: consider giving `y` an explicit type, where the type for type parameter `T` is specified\n    |\n LL |     let y: Mask<_, LANES> = Mask::<_, _>::splat(false);"}, {"sha": "a08c9912527c732eb8de4b647310e3c2628d019d", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-80742.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ size_of called on unsized type `dyn Debug`\n+   = note: size_of called on unsized type `dyn Debug`\n    |\n note: inside `std::mem::size_of::<dyn Debug>`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `Inline::<dyn Debug>::{constant#0}`\n   --> $DIR/issue-80742.rs:22:10\n    |\n@@ -23,26 +19,20 @@ LL | struct Inline<T>\n ...\n LL |     let dst = Inline::<dyn Debug>::new(0);\n    |                                    ^^^ function or associated item cannot be called on `Inline<dyn Debug>` due to unsatisfied trait bounds\n+  --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-   |\n-LL | pub trait Debug {\n-   | --------------- doesn't satisfy `dyn Debug: Sized`\n+   = note: doesn't satisfy `dyn Debug: Sized`\n    |\n    = note: the following trait bounds were not satisfied:\n            `dyn Debug: Sized`\n \n error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ size_of called on unsized type `dyn Debug`\n+   = note: size_of called on unsized type `dyn Debug`\n    |\n note: inside `std::mem::size_of::<dyn Debug>`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `Inline::<dyn Debug>::{constant#0}`\n   --> $DIR/issue-80742.rs:14:10\n    |"}, {"sha": "8c76ca6902962df686e03c185f2bd4c3f4ba9a6f", "filename": "src/test/ui/const-generics/invalid-const-arg-for-type-param.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-const-arg-for-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-const-arg-for-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-const-arg-for-type-param.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -4,11 +4,6 @@ error[E0107]: this associated function takes 0 generic arguments but 1 generic a\n LL |     let _: u32 = 5i32.try_into::<32>().unwrap();\n    |                       ^^^^^^^^ expected 0 generic arguments\n    |\n-note: associated function defined here, with 0 generic parameters\n-  --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-   |\n-LL |     fn try_into(self) -> Result<T, Self::Error>;\n-   |        ^^^^^^^^\n help: consider moving this generic argument to the `TryInto` trait, which takes up to 1 argument\n    |\n LL |     let _: u32 = TryInto::<32>::try_into(5i32).unwrap();"}, {"sha": "993b63518e44cbb8b40f3c6c7138405475b6ab47", "filename": "src/test/ui/const-generics/invalid-constant-in-args.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvalid-constant-in-args.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -5,12 +5,6 @@ LL |     let _: Cell<&str, \"a\"> = Cell::new(\"\");\n    |            ^^^^       --- help: remove this generic argument\n    |            |\n    |            expected 1 generic argument\n-   |\n-note: struct defined here, with 1 generic parameter: `T`\n-  --> $SRC_DIR/core/src/cell.rs:LL:COL\n-   |\n-LL | pub struct Cell<T: ?Sized> {\n-   |            ^^^^ -\n \n error: aborting due to previous error\n "}, {"sha": "3a58a7cd7ef05b5670b01b8514e158b0e3dd528f", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 10, "deletions": 68, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S0`\n   --> $DIR/forbidden_slices.rs:18:34\n    |\n@@ -18,14 +14,10 @@ LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `std::slice::from_raw_parts::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S1`\n   --> $DIR/forbidden_slices.rs:19:33\n    |\n@@ -35,14 +27,10 @@ LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S2`\n   --> $DIR/forbidden_slices.rs:22:34\n    |\n@@ -97,14 +85,10 @@ LL | pub static S7: &[u16] = unsafe {\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u64>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S8`\n   --> $DIR/forbidden_slices.rs:43:5\n    |\n@@ -114,19 +98,12 @@ LL |     from_raw_parts(ptr, 1)\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R0`\n   --> $DIR/forbidden_slices.rs:46:34\n    |\n@@ -136,19 +113,12 @@ LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) }\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   = note: the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R1`\n   --> $DIR/forbidden_slices.rs:47:33\n    |\n@@ -159,19 +129,12 @@ LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u32>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R2`\n   --> $DIR/forbidden_slices.rs:50:25\n    |\n@@ -226,19 +189,12 @@ LL | pub static R7: &[u16] = unsafe {\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u64>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u64>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R8`\n   --> $DIR/forbidden_slices.rs:74:25\n    |\n@@ -248,19 +204,12 @@ LL |     from_ptr_range(ptr..ptr.add(1))\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n+   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R9`\n   --> $DIR/forbidden_slices.rs:79:34\n    |\n@@ -270,19 +219,12 @@ LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).ad\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n+   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R10`\n   --> $DIR/forbidden_slices.rs:80:35\n    |"}, {"sha": "4e929e3525c20dc78aec81d9af1ac7a5e5efbd86", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 10, "deletions": 68, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S0`\n   --> $DIR/forbidden_slices.rs:18:34\n    |\n@@ -18,14 +14,10 @@ LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   = note: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `std::slice::from_raw_parts::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S1`\n   --> $DIR/forbidden_slices.rs:19:33\n    |\n@@ -35,14 +27,10 @@ LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S2`\n   --> $DIR/forbidden_slices.rs:22:34\n    |\n@@ -97,14 +85,10 @@ LL | pub static S7: &[u16] = unsafe {\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `std::slice::from_raw_parts::<'_, u64>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `S8`\n   --> $DIR/forbidden_slices.rs:43:5\n    |\n@@ -114,19 +98,12 @@ LL |     from_raw_parts(ptr, 1)\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R0`\n   --> $DIR/forbidden_slices.rs:46:34\n    |\n@@ -136,19 +113,12 @@ LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) }\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   = note: the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, ()>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R1`\n   --> $DIR/forbidden_slices.rs:47:33\n    |\n@@ -159,19 +129,12 @@ LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u32>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R2`\n   --> $DIR/forbidden_slices.rs:50:25\n    |\n@@ -226,19 +189,12 @@ LL | pub static R7: &[u16] = unsafe {\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u64>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u64>::add`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R8`\n   --> $DIR/forbidden_slices.rs:74:25\n    |\n@@ -248,19 +204,12 @@ LL |     from_ptr_range(ptr..ptr.add(1))\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n+   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R9`\n   --> $DIR/forbidden_slices.rs:79:34\n    |\n@@ -270,19 +219,12 @@ LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).ad\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n+   = note: `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `from_ptr_range::<'_, u32>`\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n-   |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `R10`\n   --> $DIR/forbidden_slices.rs:80:35\n    |"}, {"sha": "3e7b09a5982d9597c17e44f7db08f5be6840dab9", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `_READ`\n   --> $DIR/out_of_bounds_read.rs:12:33\n    |\n@@ -18,19 +14,12 @@ LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { read(self) }\n-   |                  ^^^^^^^^^^\n note: inside `_CONST_READ`\n   --> $DIR/out_of_bounds_read.rs:13:39\n    |\n@@ -40,19 +29,12 @@ LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::mut_ptr::<impl *mut u32>::read`\n   --> $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { read(self) }\n-   |                  ^^^^^^^^^^\n note: inside `_MUT_READ`\n   --> $DIR/out_of_bounds_read.rs:14:37\n    |"}, {"sha": "7ad02252094203a3f8b6865b53a6f7382bfe88e6", "filename": "src/test/ui/consts/const-float-bits-reject-conv.stderr", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,19 +1,12 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n    |\n-LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   = note: the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n    |\n note: inside `core::f32::<impl f32>::to_bits::ct_f32_to_u32`\n   --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n-   |\n-LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `core::f32::<impl f32>::to_bits`\n   --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `f32::MASKED_NAN1`\n   --> $DIR/const-float-bits-reject-conv.rs:28:30\n    |\n@@ -24,19 +17,12 @@ LL |     const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n    |\n-LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n+   = note: the evaluated program panicked at 'const-eval error: cannot use f32::to_bits on a NaN', $SRC_DIR/core/src/num/f32.rs:LL:COL\n    |\n note: inside `core::f32::<impl f32>::to_bits::ct_f32_to_u32`\n   --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n-   |\n-LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `core::f32::<impl f32>::to_bits`\n   --> $SRC_DIR/core/src/num/f32.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `f32::MASKED_NAN2`\n   --> $DIR/const-float-bits-reject-conv.rs:30:30\n    |\n@@ -71,19 +57,12 @@ LL |     const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n-LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   = note: the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n note: inside `core::f64::<impl f64>::to_bits::ct_f64_to_u64`\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n-   |\n-LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `core::f64::<impl f64>::to_bits`\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `f64::MASKED_NAN1`\n   --> $DIR/const-float-bits-reject-conv.rs:50:30\n    |\n@@ -94,19 +73,12 @@ LL |     const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n-LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n+   = note: the evaluated program panicked at 'const-eval error: cannot use f64::to_bits on a NaN', $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n note: inside `core::f64::<impl f64>::to_bits::ct_f64_to_u64`\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n-   |\n-LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a NaN\")\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `core::f64::<impl f64>::to_bits`\n   --> $SRC_DIR/core/src/num/f64.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `f64::MASKED_NAN2`\n   --> $DIR/const-float-bits-reject-conv.rs:52:30\n    |"}, {"sha": "f6b532fb6586590a33aa1ce6e96d563c3ffe370c", "filename": "src/test/ui/consts/const-fn-error.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -21,9 +21,6 @@ LL |     for i in 0..x {\n    |\n note: impl defined here, but it is not `const`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL | impl<I: Iterator> const IntoIterator for I {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error[E0658]: mutable references are not allowed in constant functions"}, {"sha": "294ea627d8544e9fbf91135146432570b0adbf5a", "filename": "src/test/ui/consts/const-for.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL |     for _ in 0..5 {}\n    |\n note: impl defined here, but it is not `const`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL | impl<I: Iterator> const IntoIterator for I {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error[E0015]: cannot call non-const fn `<std::ops::Range<i32> as Iterator>::next` in constants"}, {"sha": "593a51bfe8fea6f7282a4b8d6804bff8c891e2a8", "filename": "src/test/ui/consts/const_unsafe_unreachable_ub.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/hint.rs:LL:COL\n    |\n-LL |         intrinsics::unreachable()\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ entering unreachable code\n+   = note: entering unreachable code\n    |\n note: inside `unreachable_unchecked`\n   --> $SRC_DIR/core/src/hint.rs:LL:COL\n-   |\n-LL |         intrinsics::unreachable()\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `foo`\n   --> $DIR/const_unsafe_unreachable_ub.rs:6:18\n    |"}, {"sha": "51eec78336565ac9b518ff1b1c875507f74be822", "filename": "src/test/ui/consts/extra-const-ub/detect-extra-ub.with_flag.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -31,19 +31,12 @@ LL |     let _x: &u32 = transmute(&[0u8; 4]);\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ accessing memory with alignment 1, but alignment 4 is required\n+   = note: accessing memory with alignment 1, but alignment 4 is required\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { read(self) }\n-   |                  ^^^^^^^^^^\n note: inside `INNER`\n   --> $DIR/detect-extra-ub.rs:38:9\n    |"}, {"sha": "61865b1dad764240adeb9cfaead4efedb5cc9806", "filename": "src/test/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,21 +1,14 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to copy parts of a pointer from memory at ALLOC\n+   = note: unable to copy parts of a pointer from memory at ALLOC\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n note: inside `std::ptr::read::<u8>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ptr::const_ptr::<impl *const u8>::read`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { read(self) }\n-   |                  ^^^^^^^^^^\n note: inside `C`\n   --> $DIR/issue-miri-1910.rs:8:5\n    |"}, {"sha": "e1da43c3aea4134f15025cd694071cbca338dbc2", "filename": "src/test/ui/consts/miri_unleashed/assoc_const.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,19 +1,12 @@\n error[E0080]: evaluation of `<std::string::String as Bar<std::vec::Vec<u32>, std::string::String>>::F` failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ calling non-const function `<Vec<u32> as Drop>::drop`\n+   = note: calling non-const function `<Vec<u32> as Drop>::drop`\n    |\n note: inside `std::ptr::drop_in_place::<Vec<u32>> - shim(Some(Vec<u32>))`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `std::ptr::drop_in_place::<(Vec<u32>, u32)> - shim(Some((Vec<u32>, u32)))`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `<String as Bar<Vec<u32>, String>>::F`\n   --> $DIR/assoc_const.rs:12:31\n    |"}, {"sha": "4f60b8820691ba0fb23de283c30845d8442ca100", "filename": "src/test/ui/consts/miri_unleashed/drop.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ calling non-const function `<Vec<i32> as Drop>::drop`\n+   = note: calling non-const function `<Vec<i32> as Drop>::drop`\n    |\n note: inside `std::ptr::drop_in_place::<Vec<i32>> - shim(Some(Vec<i32>))`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `TEST_BAD`\n   --> $DIR/drop.rs:17:1\n    |"}, {"sha": "dd2b81c5af2bc93171c26e86d80175aae019bc60", "filename": "src/test/ui/consts/missing_span_in_backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fmissing_span_in_backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fmissing_span_in_backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmissing_span_in_backtrace.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Z simulate-remapped-rust-src-base=/rustc/FAKE_PREFIX -Z translate-remapped-path-to-local-path=no -Z ui-testing=no\n+// compile-flags: -Z ui-testing=no\n // normalize-stderr-test \"alloc[0-9]+\" -> \"ALLOC_ID\"\n \n #![feature(const_swap)]"}, {"sha": "fff4729689f54058a1969380dfa67407af7a274c", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,14 +7,10 @@ LL |     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called on pointers into different allocations\n+   = note: `ptr_offset_from` called on pointers into different allocations\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `NOT_PTR`\n   --> $DIR/offset_from_ub.rs:24:14\n    |\n@@ -90,14 +86,10 @@ LL |     unsafe { ptr_offset_from_unsigned(ptr2, ptr1) }\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `OFFSET_VERY_FAR1`\n   --> $DIR/offset_from_ub.rs:115:14\n    |\n@@ -107,14 +99,10 @@ LL |     unsafe { ptr2.offset_from(ptr1) }\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `OFFSET_VERY_FAR2`\n   --> $DIR/offset_from_ub.rs:121:14\n    |"}, {"sha": "c0c851df5076e078bb5529b11f9b612d9740010a", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "modified", "additions": 12, "deletions": 60, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflowing in-bounds pointer arithmetic\n+   = note: overflowing in-bounds pointer arithmetic\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `BEFORE_START`\n   --> $DIR/offset_ub.rs:7:46\n    |\n@@ -18,14 +14,10 @@ LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1)\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: allocN has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `AFTER_END`\n   --> $DIR/offset_ub.rs:8:43\n    |\n@@ -35,14 +27,10 @@ LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: allocN has size 100, so pointer to 101 bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 100, so pointer to 101 bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `AFTER_ARRAY`\n   --> $DIR/offset_ub.rs:9:45\n    |\n@@ -52,14 +40,10 @@ LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101)\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflowing in-bounds pointer arithmetic\n+   = note: overflowing in-bounds pointer arithmetic\n    |\n note: inside `ptr::const_ptr::<impl *const u16>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `OVERFLOW`\n   --> $DIR/offset_ub.rs:11:43\n    |\n@@ -69,14 +53,10 @@ LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflowing in-bounds pointer arithmetic\n+   = note: overflowing in-bounds pointer arithmetic\n    |\n note: inside `ptr::const_ptr::<impl *const u16>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `UNDERFLOW`\n   --> $DIR/offset_ub.rs:12:44\n    |\n@@ -86,14 +66,10 @@ LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize:\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflowing in-bounds pointer arithmetic\n+   = note: overflowing in-bounds pointer arithmetic\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `OVERFLOW_ADDRESS_SPACE`\n   --> $DIR/offset_ub.rs:13:56\n    |\n@@ -103,14 +79,10 @@ LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *cons\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflowing in-bounds pointer arithmetic\n+   = note: overflowing in-bounds pointer arithmetic\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `UNDERFLOW_ADDRESS_SPACE`\n   --> $DIR/offset_ub.rs:14:57\n    |\n@@ -120,14 +92,10 @@ LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).of\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: allocN has size 1, so pointer to 2 bytes starting at offset -4 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 1, so pointer to 2 bytes starting at offset -4 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `NEGATIVE_OFFSET`\n   --> $DIR/offset_ub.rs:15:49\n    |\n@@ -137,14 +105,10 @@ LL | pub const NEGATIVE_OFFSET: *const u8 = unsafe { [0u8; 1].as_ptr().wrapping_\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: allocN has size 0, so pointer to 1 byte starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: allocN has size 0, so pointer to 1 byte starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `ZERO_SIZED_ALLOC`\n   --> $DIR/offset_ub.rs:17:50\n    |\n@@ -154,14 +118,10 @@ LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) as *mut T }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: 0x1[noalloc] is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds pointer arithmetic: 0x1[noalloc] is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::mut_ptr::<impl *mut u8>::offset`\n   --> $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) as *mut T }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `DANGLING`\n   --> $DIR/offset_ub.rs:18:42\n    |\n@@ -171,14 +131,10 @@ LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds pointer arithmetic: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `NULL_OFFSET_ZERO`\n   --> $DIR/offset_ub.rs:21:50\n    |\n@@ -188,14 +144,10 @@ LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: 0x7f..f[noalloc] is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds pointer arithmetic: 0x7f..f[noalloc] is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `UNDERFLOW_ABS`\n   --> $DIR/offset_ub.rs:24:47\n    |"}, {"sha": "fea924d12e54ee60a79799be0f8845a707b3cf4a", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,10 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: alloc3 has size $WORD, so pointer to $TWO_WORDS bytes starting at offset 0 is out-of-bounds\n+   = note: out-of-bounds pointer arithmetic: alloc3 has size $WORD, so pointer to $TWO_WORDS bytes starting at offset 0 is out-of-bounds\n    |\n note: inside `ptr::const_ptr::<impl *const usize>::offset`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |\n-LL |         unsafe { intrinsics::offset(self, count) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `_`\n   --> $DIR/ptr_comparisons.rs:50:34\n    |"}, {"sha": "2be69a30b1c122222de25596e628ff372f5f9504", "filename": "src/test/ui/derives/derives-span-Eq-enum-struct-variant.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum-struct-variant.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |      x: Error\n    |\n note: required by a bound in `AssertParamIsEq`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsEq<T: Eq + ?Sized> {\n-   |                               ^^ required by this bound in `AssertParamIsEq`\n    = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(Eq)]`\n    |"}, {"sha": "4f4f821cca3e7c735302daf8c1c8b3103a67d80b", "filename": "src/test/ui/derives/derives-span-Eq-enum.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |      Error\n    |\n note: required by a bound in `AssertParamIsEq`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsEq<T: Eq + ?Sized> {\n-   |                               ^^ required by this bound in `AssertParamIsEq`\n    = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(Eq)]`\n    |"}, {"sha": "f15659c3e166c9807c66cc7cef251465884b933e", "filename": "src/test/ui/derives/derives-span-Eq-struct.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-struct.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     x: Error\n    |\n note: required by a bound in `AssertParamIsEq`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsEq<T: Eq + ?Sized> {\n-   |                               ^^ required by this bound in `AssertParamIsEq`\n    = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(Eq)]`\n    |"}, {"sha": "4e5659b35f47a5434459c7681e33d7ccb1391a83", "filename": "src/test/ui/derives/derives-span-Eq-tuple-struct.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-tuple-struct.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     Error\n    |\n note: required by a bound in `AssertParamIsEq`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsEq<T: Eq + ?Sized> {\n-   |                               ^^ required by this bound in `AssertParamIsEq`\n    = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(Eq)]`\n    |"}, {"sha": "053d34f68251a44082558ca4678c750b593aaf9d", "filename": "src/test/ui/derives/deriving-meta-unknown-trait.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,22 +3,18 @@ error: cannot find derive macro `Eqr` in this scope\n    |\n LL | #[derive(Eqr)]\n    |          ^^^ help: a derive macro with a similar name exists: `Eq`\n+  --> $SRC_DIR/core/src/cmp.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub macro Eq($item:item) {\n-   | ------------ similarly named derive macro `Eq` defined here\n+   = note: similarly named derive macro `Eq` defined here\n \n error: cannot find derive macro `Eqr` in this scope\n   --> $DIR/deriving-meta-unknown-trait.rs:1:10\n    |\n LL | #[derive(Eqr)]\n    |          ^^^ help: a derive macro with a similar name exists: `Eq`\n+  --> $SRC_DIR/core/src/cmp.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub macro Eq($item:item) {\n-   | ------------ similarly named derive macro `Eq` defined here\n+   = note: similarly named derive macro `Eq` defined here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b18e1e5098b34ba08ed6cfd5f7a39d06aa060d23", "filename": "src/test/ui/deriving/issue-103157.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderiving%2Fissue-103157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fderiving%2Fissue-103157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fissue-103157.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -20,9 +20,6 @@ LL |     Float(Option<f64>),\n    = note: required for `Option<f64>` to implement `Eq`\n note: required by a bound in `AssertParamIsEq`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub struct AssertParamIsEq<T: Eq + ?Sized> {\n-   |                               ^^ required by this bound in `AssertParamIsEq`\n    = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "8a88332b73e105f8b06c85c634f8cdeefba70f7e", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -49,11 +49,8 @@ note: an implementation of `AddAssign<_>` might be missing for `S`\n    |\n LL | struct S { x: u8, y: u8 }\n    | ^^^^^^^^ must implement `AddAssign<_>`\n-note: the following trait must be implemented\n+note: the trait `AddAssign` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait AddAssign<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0067]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:17:22"}, {"sha": "ae0a84eea4d9a56c62667fa55cc44798c59eed6e", "filename": "src/test/ui/disallowed-deconstructing/disallowed-deconstructing-destructing-struct-let.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+struct X {\n+    x: String,\n+}\n+\n+impl Drop for X {\n+    fn drop(&mut self) {\n+        println!(\"value: {}\", self.x);\n+    }\n+}\n+\n+fn unwrap(x: X) -> String {\n+    let X { x: ref y } = x; //~ ERROR cannot move out of type\n+    y.to_string()\n+}\n+\n+fn main() {\n+    let x = X { x: \"hello\".to_string() };\n+    let y = unwrap(x);\n+    println!(\"contents: {}\", y);\n+}"}, {"sha": "c8db78610681336c8f03c060a6f6f3a353d69027", "filename": "src/test/ui/disallowed-deconstructing/disallowed-deconstructing-destructing-struct-let.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n struct X {\n     x: String,\n }\n@@ -10,7 +11,7 @@ impl Drop for X {\n \n fn unwrap(x: X) -> String {\n     let X { x: y } = x; //~ ERROR cannot move out of type\n-    y\n+    y.to_string()\n }\n \n fn main() {"}, {"sha": "596ad4bf784bb531187d7b9c159925926fd2ef97", "filename": "src/test/ui/disallowed-deconstructing/disallowed-deconstructing-destructing-struct-let.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-let.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,11 +1,16 @@\n error[E0509]: cannot move out of type `X`, which implements the `Drop` trait\n-  --> $DIR/disallowed-deconstructing-destructing-struct-let.rs:12:22\n+  --> $DIR/disallowed-deconstructing-destructing-struct-let.rs:13:22\n    |\n LL |     let X { x: y } = x;\n    |                -     ^ cannot move out of here\n    |                |\n    |                data moved here\n    |                move occurs because `y` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let X { x: ref y } = x;\n+   |                +++\n \n error: aborting due to previous error\n "}, {"sha": "c8a451efeb28ecdc7775cdc640e8924e209eabf0", "filename": "src/test/ui/disallowed-deconstructing/disallowed-deconstructing-destructing-struct-match.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+struct X {\n+    x: String,\n+}\n+\n+impl Drop for X {\n+    fn drop(&mut self) {\n+        println!(\"value: {}\", self.x);\n+    }\n+}\n+\n+fn main() {\n+    let x = X { x: \"hello\".to_string() };\n+\n+    match x {\n+    //~^ ERROR cannot move out of type `X`, which implements the `Drop` trait\n+        X { x: ref y } => println!(\"contents: {}\", y)\n+    }\n+}"}, {"sha": "815567ffec358cd95fa0a405ce5a224db73a4000", "filename": "src/test/ui/disallowed-deconstructing/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n struct X {\n     x: String,\n }"}, {"sha": "e32a4dd44114963a94d804bc19bb6f20937675d7", "filename": "src/test/ui/disallowed-deconstructing/disallowed-deconstructing-destructing-struct-match.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdisallowed-deconstructing%2Fdisallowed-deconstructing-destructing-struct-match.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,5 +1,5 @@\n error[E0509]: cannot move out of type `X`, which implements the `Drop` trait\n-  --> $DIR/disallowed-deconstructing-destructing-struct-match.rs:14:11\n+  --> $DIR/disallowed-deconstructing-destructing-struct-match.rs:15:11\n    |\n LL |     match x {\n    |           ^ cannot move out of here\n@@ -9,6 +9,11 @@ LL |         X { x: y } => println!(\"contents: {}\", y)\n    |                |\n    |                data moved here\n    |                move occurs because `y` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         X { x: ref y } => println!(\"contents: {}\", y)\n+   |                +++\n \n error: aborting due to previous error\n "}, {"sha": "8d0a82b707ddaa07ffcebd0df4cc2b9bd60b1227", "filename": "src/test/ui/dst/dst-rvalue.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdst%2Fdst-rvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fdst%2Fdst-rvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-rvalue.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     let _x: Box<str> = Box::new(*\"hello world\");\n    = help: the trait `Sized` is not implemented for `str`\n note: required by a bound in `Box::<T>::new`\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | impl<T> Box<T> {\n-   |      ^ required by this bound in `Box::<T>::new`\n \n error[E0277]: the size for values of type `[isize]` cannot be known at compilation time\n   --> $DIR/dst-rvalue.rs:8:37\n@@ -24,9 +21,6 @@ LL |     let _x: Box<[isize]> = Box::new(*array);\n    = help: the trait `Sized` is not implemented for `[isize]`\n note: required by a bound in `Box::<T>::new`\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | impl<T> Box<T> {\n-   |      ^ required by this bound in `Box::<T>::new`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e829bac196f7962b27bb1ef0554b7717356d0879", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,15 +6,12 @@ LL |     match x { }\n    |\n note: `Option<i32>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     None,\n-   |     ^^^^ not covered\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^ not covered\n+   = note: not covered\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |"}, {"sha": "0f179259356d50430ed09f38bf96f01e2762ed25", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,12 +8,9 @@ LL |     let Some(y) = x;\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Option<i32>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     None,\n-   |     ^^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "4f6abb22ab2f03f9ef63d1e81d1cb8669c4f49fb", "filename": "src/test/ui/error-codes/E0059.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0059.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0059.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0059.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL | fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }\n    |\n note: required by a bound in `Fn`\n   --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   |                    ^^^^^ required by this bound in `Fn`\n \n error: aborting due to previous error\n "}, {"sha": "903422f3b9b8a59ba9b02f526ce33cd634bde089", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,12 +6,9 @@ LL |     for Some(x) in xs {}\n    |\n note: `Option<i32>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     None,\n-   |     ^^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n \n error: aborting due to previous error"}, {"sha": "03630f38987e23cc95304050b8b4b7105373c89a", "filename": "src/test/ui/error-codes/E0507.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0507.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0507.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0507.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,7 +7,7 @@ LL |     x.borrow().nothing_is_true();\n    |     |          value moved due to this method call\n    |     move occurs because value has type `TheDarkKnight`, which does not implement the `Copy` trait\n    |\n-note: this function takes ownership of the receiver `self`, which moves value\n+note: `TheDarkKnight::nothing_is_true` takes ownership of the receiver `self`, which moves value\n   --> $DIR/E0507.rs:6:24\n    |\n LL |     fn nothing_is_true(self) {}"}, {"sha": "208ba30729f8b31b97c9b2860196801ff6f2c646", "filename": "src/test/ui/error-codes/E0508-fail.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0508-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0508-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0508-fail.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,7 +6,11 @@ LL |     let _value = array[0];\n    |                  |\n    |                  cannot move out of here\n    |                  move occurs because `array[_]` has type `NonCopy`, which does not implement the `Copy` trait\n-   |                  help: consider borrowing here: `&array[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let _value = &array[0];\n+   |                  +\n \n error: aborting due to previous error\n "}, {"sha": "df2d3b0d311c93652b67f3c9b67418fddc672971", "filename": "src/test/ui/error-codes/E0508.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0508.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0508.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0508.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,7 +6,11 @@ LL |     let _value = array[0];\n    |                  |\n    |                  cannot move out of here\n    |                  move occurs because `array[_]` has type `NonCopy`, which does not implement the `Copy` trait\n-   |                  help: consider borrowing here: `&array[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let _value = &array[0];\n+   |                  +\n \n error: aborting due to previous error\n "}, {"sha": "c00d9142e750559552589fb6881319869969c50c", "filename": "src/test/ui/error-codes/E0509.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0509.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-codes%2FE0509.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0509.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,7 +6,11 @@ LL |     let fancy_field = drop_struct.fancy;\n    |                       |\n    |                       cannot move out of here\n    |                       move occurs because `drop_struct.fancy` has type `FancyNum`, which does not implement the `Copy` trait\n-   |                       help: consider borrowing here: `&drop_struct.fancy`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let fancy_field = &drop_struct.fancy;\n+   |                       +\n \n error: aborting due to previous error\n "}, {"sha": "fe9956b70bdd75f3e9cb374adbb589cde91d2e50", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -41,11 +41,8 @@ note: an implementation of `Not` might be missing for `Question`\n    |\n LL | enum Question {\n    | ^^^^^^^^^^^^^ must implement `Not`\n-note: the following trait must be implemented\n+note: the trait `Not` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait Not {\n-   | ^^^^^^^^^^^^^\n \n error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/error-festival.rs:25:5"}, {"sha": "2f9d10d70a2fea087ef955ca6a2ad9e22dcb4108", "filename": "src/test/ui/expr/malformed_closure/ruby_style_closure.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -22,9 +22,6 @@ LL | |     });\n    = help: the trait `FnOnce<({integer},)>` is not implemented for `Option<_>`\n note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |         F: ~const FnOnce(T) -> Option<U>,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::and_then`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e253e4791e8bd095b8941ffc4ce6f5a3f47e20fa", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,12 +8,9 @@ LL |     let Ok(_x) = foo();\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Result<u32, !>` defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n+  ::: $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-LL | pub enum Result<T, E> {\n-   | ---------------------\n-...\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     ^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Result<u32, !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "a8a2a47fe46e1f6ed7a478b9f99d3e9d1167dddf", "filename": "src/test/ui/fmt/ifmt-bad-arg.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -309,9 +309,6 @@ LL |     println!(\"{} {:.*} {}\", 1, 3.2, 4);\n               found reference `&{float}`\n note: associated function defined here\n   --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-   |\n-LL |     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-   |            ^^^^^^^^^^\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n@@ -327,9 +324,6 @@ LL |     println!(\"{} {:07$.*} {}\", 1, 3.2, 4);\n               found reference `&{float}`\n note: associated function defined here\n   --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-   |\n-LL |     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-   |            ^^^^^^^^^^\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 38 previous errors"}, {"sha": "be321c3c5c08f1279e539132933ba9d391027627", "filename": "src/test/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -17,9 +17,6 @@ LL |     format!(\"{:X}\", \"3\");\n    = note: required for `&str` to implement `UpperHex`\n note: required by a bound in `ArgumentV1::<'a>::new_upper_hex`\n   --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-   |\n-LL |     arg_new!(new_upper_hex, UpperHex);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ArgumentV1::<'a>::new_upper_hex`\n    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `arg_new` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "afb39c9e594d17887c8890ca793d7dcad17a3df0", "filename": "src/test/ui/generator/issue-102645.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fgenerator%2Fissue-102645.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fgenerator%2Fissue-102645.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-102645.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL |     Pin::new(&mut b).resume();\n    |\n note: associated function defined here\n   --> $SRC_DIR/core/src/ops/generator.rs:LL:COL\n-   |\n-LL |     fn resume(self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return>;\n-   |        ^^^^^^\n help: provide the argument\n    |\n LL |     Pin::new(&mut b).resume(());"}, {"sha": "fb34540d969dae4e9401c2281f0363d93e797038", "filename": "src/test/ui/generator/sized-yield.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -20,9 +20,6 @@ LL |    Pin::new(&mut gen).resume(());\n    = help: the trait `Sized` is not implemented for `str`\n note: required by a bound in `GeneratorState`\n   --> $SRC_DIR/core/src/ops/generator.rs:LL:COL\n-   |\n-LL | pub enum GeneratorState<Y, R> {\n-   |                         ^ required by this bound in `GeneratorState`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b48966a1a1ed0c66f351b39ab7e7b8c5de8ddd8e", "filename": "src/test/ui/generics/wrong-number-of-args.stderr", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -889,11 +889,6 @@ error[E0107]: missing generics for struct `HashMap`\n LL |         type A = HashMap;\n    |                  ^^^^^^^ expected at least 2 generic arguments\n    |\n-note: struct defined here, with at least 2 generic parameters: `K`, `V`\n-  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL | pub struct HashMap<K, V, S = RandomState> {\n-   |            ^^^^^^^ -  -\n help: add missing generic arguments\n    |\n LL |         type A = HashMap<K, V>;\n@@ -907,11 +902,6 @@ LL |         type B = HashMap<String>;\n    |                  |\n    |                  expected at least 2 generic arguments\n    |\n-note: struct defined here, with at least 2 generic parameters: `K`, `V`\n-  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL | pub struct HashMap<K, V, S = RandomState> {\n-   |            ^^^^^^^ -  -\n help: add missing generic argument\n    |\n LL |         type B = HashMap<String, V>;\n@@ -924,24 +914,13 @@ LL |         type C = HashMap<'static>;\n    |                  ^^^^^^^--------- help: remove these generics\n    |                  |\n    |                  expected 0 lifetime arguments\n-   |\n-note: struct defined here, with 0 lifetime parameters\n-  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL | pub struct HashMap<K, V, S = RandomState> {\n-   |            ^^^^^^^\n \n error[E0107]: this struct takes at least 2 generic arguments but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:318:18\n    |\n LL |         type C = HashMap<'static>;\n    |                  ^^^^^^^ expected at least 2 generic arguments\n    |\n-note: struct defined here, with at least 2 generic parameters: `K`, `V`\n-  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL | pub struct HashMap<K, V, S = RandomState> {\n-   |            ^^^^^^^ -  -\n help: add missing generic arguments\n    |\n LL |         type C = HashMap<'static, K, V>;\n@@ -954,24 +933,13 @@ LL |         type D = HashMap<usize, String, char, f64>;\n    |                  ^^^^^^^                      --- help: remove this generic argument\n    |                  |\n    |                  expected at most 3 generic arguments\n-   |\n-note: struct defined here, with at most 3 generic parameters: `K`, `V`, `S`\n-  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL | pub struct HashMap<K, V, S = RandomState> {\n-   |            ^^^^^^^ -  -  ---------------\n \n error[E0107]: this struct takes at least 2 generic arguments but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:328:18\n    |\n LL |         type E = HashMap<>;\n    |                  ^^^^^^^ expected at least 2 generic arguments\n    |\n-note: struct defined here, with at least 2 generic parameters: `K`, `V`\n-  --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL | pub struct HashMap<K, V, S = RandomState> {\n-   |            ^^^^^^^ -  -\n help: add missing generic arguments\n    |\n LL |         type E = HashMap<K, V>;\n@@ -983,11 +951,6 @@ error[E0107]: missing generics for enum `Result`\n LL |         type A = Result;\n    |                  ^^^^^^ expected 2 generic arguments\n    |\n-note: enum defined here, with 2 generic parameters: `T`, `E`\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^ -  -\n help: add missing generic arguments\n    |\n LL |         type A = Result<T, E>;\n@@ -1001,11 +964,6 @@ LL |         type B = Result<String>;\n    |                  |\n    |                  expected 2 generic arguments\n    |\n-note: enum defined here, with 2 generic parameters: `T`, `E`\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^ -  -\n help: add missing generic argument\n    |\n LL |         type B = Result<String, E>;\n@@ -1018,24 +976,13 @@ LL |         type C = Result<'static>;\n    |                  ^^^^^^--------- help: remove these generics\n    |                  |\n    |                  expected 0 lifetime arguments\n-   |\n-note: enum defined here, with 0 lifetime parameters\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^\n \n error[E0107]: this enum takes 2 generic arguments but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:342:18\n    |\n LL |         type C = Result<'static>;\n    |                  ^^^^^^ expected 2 generic arguments\n    |\n-note: enum defined here, with 2 generic parameters: `T`, `E`\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^ -  -\n help: add missing generic arguments\n    |\n LL |         type C = Result<'static, T, E>;\n@@ -1048,24 +995,13 @@ LL |         type D = Result<usize, String, char>;\n    |                  ^^^^^^                ---- help: remove this generic argument\n    |                  |\n    |                  expected 2 generic arguments\n-   |\n-note: enum defined here, with 2 generic parameters: `T`, `E`\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^ -  -\n \n error[E0107]: this enum takes 2 generic arguments but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:352:18\n    |\n LL |         type E = Result<>;\n    |                  ^^^^^^ expected 2 generic arguments\n    |\n-note: enum defined here, with 2 generic parameters: `T`, `E`\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   |          ^^^^^^ -  -\n help: add missing generic arguments\n    |\n LL |         type E = Result<T, E>;"}, {"sha": "973b65bfd625a6188cdf5c199dfa31284b5b4dbc", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -46,11 +46,9 @@ error[E0643]: method `hash` has incompatible signature for trait\n    |\n LL |     fn hash(&self, hasher: &mut impl Hasher) {}\n    |                                 ^^^^^^^^^^^ expected generic parameter, found `impl Trait`\n+  --> $SRC_DIR/core/src/hash/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/hash/mod.rs:LL:COL\n-   |\n-LL |     fn hash<H: Hasher>(&self, state: &mut H);\n-   |             - declaration in trait here\n+   = note: declaration in trait here\n \n error: aborting due to 4 previous errors\n "}, {"sha": "03cc4c2b93bed3948427b7ae028dd11a4da4e70a", "filename": "src/test/ui/impl-trait/in-trait/wf-bounds.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |     fn nya() -> impl Wf<Vec<[u8]>>;\n    = help: the trait `Sized` is not implemented for `[u8]`\n note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-   |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n-   |                ^ required by this bound in `Vec`\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> $DIR/wf-bounds.rs:12:23"}, {"sha": "bc342dc46893b80e02778235fc7437037bb9d406", "filename": "src/test/ui/impl-trait/issues/issue-62742.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -25,7 +25,7 @@ LL | pub struct SafeImpl<T: ?Sized, A: Raw<T>>(PhantomData<(A, T)>);\n    |\n    = note: the following trait bounds were not satisfied:\n            `RawImpl<()>: Raw<()>`\n-note: the following trait must be implemented\n+note: the trait `Raw` must be implemented\n   --> $DIR/issue-62742.rs:12:1\n    |\n LL | pub trait Raw<T: ?Sized> {"}, {"sha": "f09c14d3df1df216b7a01e75be34e8ab972b70ca", "filename": "src/test/ui/impl-trait/issues/issue-92305.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -4,11 +4,6 @@ error[E0107]: missing generics for struct `Vec`\n LL | fn f<T>(data: &[T]) -> impl Iterator<Item = Vec> {\n    |                                             ^^^ expected at least 1 generic argument\n    |\n-note: struct defined here, with at least 1 generic parameter: `T`\n-  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-   |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n-   |            ^^^ -\n help: add missing generic argument\n    |\n LL | fn f<T>(data: &[T]) -> impl Iterator<Item = Vec<T>> {"}, {"sha": "ade479ed1022128a4bef62cabae71c1bccd4d10d", "filename": "src/test/ui/imports/extern-prelude-extern-crate-restricted-shadowing.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -24,11 +24,8 @@ LL |         extern crate std as Vec;\n ...\n LL | define_vec!();\n    | ------------- in this macro invocation\n-note: `Vec` could also refer to the struct defined here\n+note: `Vec` could also refer to a struct from prelude\n   --> $SRC_DIR/std/src/prelude/mod.rs:LL:COL\n-   |\n-LL |     pub use super::v1::*;\n-   |             ^^^^^^^^^^^^\n    = note: this error originates in the macro `define_vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "01b37f2acaa14444d7b043e2d1ab7c31572b7772", "filename": "src/test/ui/inference/issue-71732.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,9 +12,6 @@ LL |         .get(&\"key\".into())\n              where T: ?Sized;\n note: required by a bound in `HashMap::<K, V, S>::get`\n   --> $SRC_DIR/std/src/collections/hash/map.rs:LL:COL\n-   |\n-LL |         K: Borrow<Q>,\n-   |            ^^^^^^^^^ required by this bound in `HashMap::<K, V, S>::get`\n help: consider specifying the generic argument\n    |\n LL |         .get::<Q>(&\"key\".into())"}, {"sha": "1bec41e2efa01ec78f04cfc2d2ef9c7fe34452fd", "filename": "src/test/ui/inline-const/expr-unsafe-err.mir.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.mir.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/expr-unsafe-err.rs:8:9\n+   |\n+LL |         require_unsafe();\n+   |         ^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "adf05d352ea70c0f5f9602d965a5788e91601df1", "filename": "src/test/ui/inline-const/expr-unsafe-err.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,11 @@\n+// revisions: mir thir\n+// [thir]compile-flags: -Z thir-unsafeck\n+#![feature(inline_const)]\n+const unsafe fn require_unsafe() -> usize { 1 }\n+\n+fn main() {\n+    const {\n+        require_unsafe();\n+        //~^ ERROR [E0133]\n+    }\n+}"}, {"sha": "c971e8afb35770c56530afb66cf7379b3a885d9f", "filename": "src/test/ui/inline-const/expr-unsafe-err.thir.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe-err.thir.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: call to unsafe function `require_unsafe` is unsafe and requires unsafe function or block\n+  --> $DIR/expr-unsafe-err.rs:8:9\n+   |\n+LL |         require_unsafe();\n+   |         ^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "1ab6e42fba0a5b9a38ebe2c8d8547bfb4368163d", "filename": "src/test/ui/inline-const/expr-unsafe.mir.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.mir.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,14 @@\n+warning: unnecessary `unsafe` block\n+  --> $DIR/expr-unsafe.rs:12:13\n+   |\n+LL |             unsafe {}\n+   |             ^^^^^^ unnecessary `unsafe` block\n+   |\n+note: the lint level is defined here\n+  --> $DIR/expr-unsafe.rs:4:9\n+   |\n+LL | #![warn(unused_unsafe)]\n+   |         ^^^^^^^^^^^^^\n+\n+warning: 1 warning emitted\n+"}, {"sha": "d71efd33db16393faa706670b1d27ee07ba2732f", "filename": "src/test/ui/inline-const/expr-unsafe.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// revisions: mir thir\n+// [thir]compile-flags: -Z thir-unsafeck\n+#![warn(unused_unsafe)]\n+#![feature(inline_const)]\n+const unsafe fn require_unsafe() -> usize { 1 }\n+\n+fn main() {\n+    unsafe {\n+        const {\n+            require_unsafe();\n+            unsafe {}\n+            //~^ WARNING unnecessary `unsafe` block\n+        }\n+    }\n+}"}, {"sha": "4737444fb61c42ea44d01db76738ffc7072015c4", "filename": "src/test/ui/inline-const/expr-unsafe.thir.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fexpr-unsafe.thir.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,17 @@\n+warning: unnecessary `unsafe` block\n+  --> $DIR/expr-unsafe.rs:12:13\n+   |\n+LL |     unsafe {\n+   |     ------ because it's nested under this `unsafe` block\n+...\n+LL |             unsafe {}\n+   |             ^^^^^^ unnecessary `unsafe` block\n+   |\n+note: the lint level is defined here\n+  --> $DIR/expr-unsafe.rs:4:9\n+   |\n+LL | #![warn(unused_unsafe)]\n+   |         ^^^^^^^^^^^^^\n+\n+warning: 1 warning emitted\n+"}, {"sha": "e290b438c514093e59019355fdf299539974fff9", "filename": "src/test/ui/inline-const/pat-unsafe-err.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fpat-unsafe-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fpat-unsafe-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fpat-unsafe-err.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,17 @@\n+// ignore-test This is currently broken\n+// revisions: mir thir\n+// [thir]compile-flags: -Z thir-unsafeck\n+\n+#![allow(incomplete_features)]\n+#![feature(inline_const_pat)]\n+\n+const unsafe fn require_unsafe() -> usize { 1 }\n+\n+fn main() {\n+    match () {\n+        const {\n+            require_unsafe();\n+            //~^ ERROR [E0133]\n+        } => (),\n+    }\n+}"}, {"sha": "bcf7f6e01804e40bf3b6d1cc80b43e0c8820a453", "filename": "src/test/ui/inline-const/pat-unsafe.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fpat-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finline-const%2Fpat-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fpat-unsafe.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,22 @@\n+// ignore-test This is currently broken\n+// check-pass\n+// revisions: mir thir\n+// [thir]compile-flags: -Z thir-unsafeck\n+\n+#![allow(incomplete_features)]\n+#![warn(unused_unsafe)]\n+#![feature(inline_const_pat)]\n+\n+const unsafe fn require_unsafe() -> usize { 1 }\n+\n+fn main() {\n+    unsafe {\n+        match () {\n+            const {\n+                require_unsafe();\n+                unsafe {}\n+                //~^ WARNING unnecessary `unsafe` block\n+            } => (),\n+        }\n+    }\n+}"}, {"sha": "034d22591b38a582360f86a5367183167019c8c6", "filename": "src/test/ui/interior-mutability/interior-mutability.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finterior-mutability%2Finterior-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Finterior-mutability%2Finterior-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finterior-mutability%2Finterior-mutability.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -16,9 +16,6 @@ LL |     catch_unwind(|| { x.set(23); });\n    |                  ^^\n note: required by a bound in `catch_unwind`\n   --> $SRC_DIR/std/src/panic.rs:LL:COL\n-   |\n-LL | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n-   |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n \n error: aborting due to previous error\n "}, {"sha": "fd7d061b6b2e5627459e5ea11968c9539c345ff8", "filename": "src/test/ui/intrinsics/const-eval-select-bad.stderr", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -37,9 +37,6 @@ LL |     const_eval_select((), 42, 0xDEADBEEF);\n    = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |         F: FnOnce<ARG, Output = RET>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error: this argument must be a function item\n   --> $DIR/const-eval-select-bad.rs:10:31\n@@ -62,9 +59,6 @@ LL |     const_eval_select((), 42, 0xDEADBEEF);\n    = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |         G: FnOnce<ARG, Output = RET>,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error[E0271]: expected `fn(i32) -> bool {bar}` to be a fn item that returns `i32`, but it returns `bool`\n   --> $DIR/const-eval-select-bad.rs:32:34\n@@ -76,9 +70,6 @@ LL |     const_eval_select((1,), foo, bar);\n    |\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |         G: FnOnce<ARG, Output = RET>,\n-   |                        ^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error[E0631]: type mismatch in function arguments\n   --> $DIR/const-eval-select-bad.rs:37:32\n@@ -95,9 +86,6 @@ LL |     const_eval_select((true,), foo, baz);\n               found function signature `fn(i32) -> _`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |         F: FnOnce<ARG, Output = RET>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error: this argument must be a `const fn`\n   --> $DIR/const-eval-select-bad.rs:42:29"}, {"sha": "7fa06825f0f00c38bccf22c140a3752649cf5368", "filename": "src/test/ui/issues/issue-12567.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-12567.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-12567.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12567.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,6 +11,14 @@ LL |         (&[hd1, ..], &[hd2, ..])\n    |            --- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&[], &[ref hd, ..]) | (&[hd, ..], &[])\n+   |                 +++\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&[ref hd1, ..], &[hd2, ..])\n+   |            +++\n \n error[E0508]: cannot move out of type `[T]`, a non-copy slice\n   --> $DIR/issue-12567.rs:2:11\n@@ -25,6 +33,14 @@ LL |         (&[hd1, ..], &[hd2, ..])\n    |                        --- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&[], &[ref hd, ..]) | (&[hd, ..], &[])\n+   |                 +++\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&[hd1, ..], &[ref hd2, ..])\n+   |                        +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f8375d4ef9014ba6e7dcfe0ca100c93ee114a47d", "filename": "src/test/ui/issues/issue-14091-2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-14091-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-14091-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14091-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,11 +9,8 @@ note: an implementation of `Not` might be missing for `BytePos`\n    |\n LL | pub struct BytePos(pub u32);\n    | ^^^^^^^^^^^^^^^^^^ must implement `Not`\n-note: the following trait must be implemented\n+note: the trait `Not` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait Not {\n-   | ^^^^^^^^^^^^^\n    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "132e2b101a5ff1d4c207e69fa9e71951f41cb451", "filename": "src/test/ui/issues/issue-14092.stderr", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-14092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-14092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14092.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -4,13 +4,6 @@ error[E0107]: missing generics for struct `Box`\n LL | fn fn1(0: Box) {}\n    |           ^^^ expected at least 1 generic argument\n    |\n-note: struct defined here, with at least 1 generic parameter: `T`\n-  --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | pub struct Box<\n-   |            ^^^\n-LL |     T: ?Sized,\n-   |     -\n help: add missing generic argument\n    |\n LL | fn fn1(0: Box<T>) {}"}, {"sha": "60f5190dbd0d640f790cf33863fdf06bfd1dc9fa", "filename": "src/test/ui/issues/issue-16966.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -5,11 +5,6 @@ LL |     panic!(std::default::Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `M` declared on the function `begin_panic`\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider specifying the generic argument\n-  --> $SRC_DIR/std/src/panic.rs:LL:COL\n-   |\n-LL |         $crate::rt::begin_panic::<M>($msg)\n-   |                                +++++\n \n error: aborting due to previous error\n "}, {"sha": "81592320a2791b414f88788ba6c2e99c5ce21e5b", "filename": "src/test/ui/issues/issue-17546.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error[E0573]: expected type, found variant `NoResult`\n    |\n LL |     fn new() -> NoResult<MyEnum, String> {\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   | --------------------- similarly named enum `Result` defined here\n+   = note: similarly named enum `Result` defined here\n    |\n help: try using the variant's enum\n    |\n@@ -57,11 +55,9 @@ error[E0573]: expected type, found variant `NoResult`\n    |\n LL | fn newer() -> NoResult<foo::MyEnum, String> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   | --------------------- similarly named enum `Result` defined here\n+   = note: similarly named enum `Result` defined here\n    |\n help: try using the variant's enum\n    |"}, {"sha": "b37811e19559c3bdc82fe6c1036e2b3f8883040c", "filename": "src/test/ui/issues/issue-17651.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     (|| Box::new(*(&[0][..])))();\n    = help: the trait `Sized` is not implemented for `[{integer}]`\n note: required by a bound in `Box::<T>::new`\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | impl<T> Box<T> {\n-   |      ^ required by this bound in `Box::<T>::new`\n \n error: aborting due to previous error\n "}, {"sha": "bbf79366244a01d7381b2d9504b47742bbe86c25", "filename": "src/test/ui/issues/issue-18423.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-18423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-18423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18423.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -5,12 +5,6 @@ LL |     x: Box<'a, isize>\n    |        ^^^ -- help: remove this lifetime argument\n    |        |\n    |        expected 0 lifetime arguments\n-   |\n-note: struct defined here, with 0 lifetime parameters\n-  --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | pub struct Box<\n-   |            ^^^\n \n error: aborting due to previous error\n "}, {"sha": "1c5b76fbfc10b1e730ce7c738f264d4d5a05c998", "filename": "src/test/ui/issues/issue-20162.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20162.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL |     b.sort();\n    |\n note: required by a bound in `slice::<impl [T]>::sort`\n   --> $SRC_DIR/alloc/src/slice.rs:LL:COL\n-   |\n-LL |         T: Ord,\n-   |            ^^^ required by this bound in `slice::<impl [T]>::sort`\n help: consider annotating `X` with `#[derive(Ord)]`\n    |\n LL | #[derive(Ord)]"}, {"sha": "3ae952546a62dd0d652b032fa346917fca174a08", "filename": "src/test/ui/issues/issue-20433.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |     fn iceman(c: Vec<[i32]>) {}\n    = help: the trait `Sized` is not implemented for `[i32]`\n note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-   |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n-   |                ^ required by this bound in `Vec`\n \n error: aborting due to previous error\n "}, {"sha": "014eb2897b488871c5f0ea563ab1a30bea8119fd", "filename": "src/test/ui/issues/issue-23024.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,11 +13,6 @@ error[E0107]: missing generics for trait `Fn`\n LL |     println!(\"{:?}\",(vfnfer[0] as dyn Fn)(3));\n    |                                       ^^ expected 1 generic argument\n    |\n-note: trait defined here, with 1 generic parameter: `Args`\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   |           ^^ ----\n help: add missing generic argument\n    |\n LL |     println!(\"{:?}\",(vfnfer[0] as dyn Fn<Args>)(3));"}, {"sha": "8f934481d85db6be1d86ae91290db0ab1fc87930", "filename": "src/test/ui/issues/issue-23966.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-23966.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-23966.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23966.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     \"\".chars().fold(|_, _| (), ());\n    = help: the trait `FnMut<(_, char)>` is not implemented for `()`\n note: required by a bound in `fold`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(B, Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::fold`\n \n error: aborting due to previous error\n "}, {"sha": "7a0ca888d7471c3c87d81fa5ab6d5a418dedb47f", "filename": "src/test/ui/issues/issue-27033.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27033.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error[E0530]: match bindings cannot shadow unit variants\n    |\n LL |         None @ _ => {}\n    |         ^^^^ cannot be named the same as a unit variant\n+  --> $SRC_DIR/std/src/prelude/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/std/src/prelude/mod.rs:LL:COL\n-   |\n-LL |     pub use super::v1::*;\n-   |             ------------ the unit variant `None` is defined here\n+   = note: the unit variant `None` is defined here\n \n error[E0530]: match bindings cannot shadow constants\n   --> $DIR/issue-27033.rs:7:9"}, {"sha": "2b142f688ecb9dcc8b844d6840767393999bc579", "filename": "src/test/ui/issues/issue-3044.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-3044.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-3044.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3044.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL | |     });\n    |\n note: associated function defined here\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn fold<B, F>(mut self, init: B, mut f: F) -> B\n-   |        ^^^^\n help: provide the argument\n    |\n LL ~     needlesArr.iter().fold(|x, y| {"}, {"sha": "b667ae0a789375cf62cf29eb460968793be24459", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,25 +8,18 @@ LL |         .cloned()\n                    found type `u8`\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         Self: Sized + Iterator<Item = &'a T>,\n-   |                                ^^^^^^^^^^^^ required by this bound in `Iterator::cloned`\n \n error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>`, but its trait bounds were not satisfied\n   --> $DIR/issue-31173.rs:12:10\n    |\n LL |         .collect();\n    |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>` due to unsatisfied trait bounds\n+  --> $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n-   |\n-LL | pub struct TakeWhile<I, P> {\n-   | -------------------------- doesn't satisfy `<_ as Iterator>::Item = &_`\n-   |\n-  ::: $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n+   = note: doesn't satisfy `<_ as Iterator>::Item = &_`\n+  --> $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n    |\n-LL | pub struct Cloned<I> {\n-   | -------------------- doesn't satisfy `_: Iterator`\n+   = note: doesn't satisfy `_: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]> as Iterator>::Item = &_`"}, {"sha": "b8362499b2d0aae7aa06c2c96410d6a8e130450b", "filename": "src/test/ui/issues/issue-32655.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,11 +6,9 @@ LL |         #[derive_Clone]\n ...\n LL | foo!();\n    | ------ in this macro invocation\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |     pub macro derive_const($item:item) {\n-   |     ---------------------- similarly named attribute macro `derive_const` defined here\n+   = note: similarly named attribute macro `derive_const` defined here\n    |\n    = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n@@ -19,11 +17,9 @@ error: cannot find attribute `derive_Clone` in this scope\n    |\n LL |     #[derive_Clone]\n    |       ^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `derive_const`\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |     pub macro derive_const($item:item) {\n-   |     ---------------------- similarly named attribute macro `derive_const` defined here\n+   = note: similarly named attribute macro `derive_const` defined here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "49702c47658638bd28315df55d7b44ff327b5667", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,9 +8,6 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n                   found tuple `(&_, &_)`\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         Self: Sized + Iterator<Item = &'a T>,\n-   |                                ^^^^^^^^^^^^ required by this bound in `Iterator::cloned`\n \n error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14"}, {"sha": "9d2c315e4dbca92721686334dc03c64e4135aa47", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -32,9 +32,6 @@ LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_rece\n    |                                    `Iterator::Item` is `&(_, _, _)` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f2bf22227dbe47d787a16de1b781b7fd74927122", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,7 +13,7 @@ LL |         };\n LL |         x.zero()\n    |         ^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `x`\n+note: `Foo::zero` takes ownership of the receiver `self`, which moves `x`\n   --> $DIR/issue-34721.rs:4:13\n    |\n LL |     fn zero(self) -> Self;"}, {"sha": "4d505784b86548137db79c04bdb22298b3f03433", "filename": "src/test/ui/issues/issue-38857.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,9 +12,6 @@ LL |     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!()\n    |\n note: the module `sys` is defined here\n   --> $SRC_DIR/std/src/lib.rs:LL:COL\n-   |\n-LL | mod sys;\n-   | ^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e15eed6561234e91db2f6e3ab7133a630db45881", "filename": "src/test/ui/issues/issue-40402-ref-hints/issue-40402-1.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-40402-ref-hints%2Fissue-40402-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-40402-ref-hints%2Fissue-40402-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40402-ref-hints%2Fissue-40402-1.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,12 @@ error[E0507]: cannot move out of index of `Vec<String>`\n   --> $DIR/issue-40402-1.rs:9:13\n    |\n LL |     let e = f.v[0];\n-   |             ^^^^^^\n-   |             |\n-   |             move occurs because value has type `String`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&f.v[0]`\n+   |             ^^^^^^ move occurs because value has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let e = &f.v[0];\n+   |             +\n \n error: aborting due to previous error\n "}, {"sha": "1bc554efb5c3d5bfacf56e398ee2fc2a072a749d", "filename": "src/test/ui/issues/issue-40402-ref-hints/issue-40402-2.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-40402-ref-hints%2Fissue-40402-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-40402-ref-hints%2Fissue-40402-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40402-ref-hints%2Fissue-40402-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,12 +2,16 @@ error[E0507]: cannot move out of index of `Vec<(String, String)>`\n   --> $DIR/issue-40402-2.rs:5:18\n    |\n LL |     let (a, b) = x[0];\n-   |          -  -    ^^^^ help: consider borrowing here: `&x[0]`\n+   |          -  -    ^^^^\n    |          |  |\n    |          |  ...and here\n    |          data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing here\n+   |\n+LL |     let (a, b) = &x[0];\n+   |                  +\n \n error: aborting due to previous error\n "}, {"sha": "da3e62e35dc81b804a35254dfe8f9797e619606c", "filename": "src/test/ui/issues/issue-48364.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-48364.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-48364.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48364.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,9 +10,6 @@ LL |     b\"\".starts_with(stringify!(foo))\n               found reference `&'static str`\n note: associated function defined here\n   --> $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-   |\n-LL |     pub fn starts_with(&self, needle: &[T]) -> bool\n-   |            ^^^^^^^^^^^\n    = note: this error originates in the macro `stringify` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "d8a833a86f511a7c9636baa4fb6c20a2efd29eee", "filename": "src/test/ui/issues/issue-51154.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-51154.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-51154.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51154.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,9 +13,6 @@ LL |     let _: Box<F> = Box::new(|| ());\n    = help: every closure has a distinct type and so could not always match the caller-chosen type of parameter `F`\n note: associated function defined here\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL |     pub fn new(x: T) -> Self {\n-   |            ^^^\n \n error: aborting due to previous error\n "}, {"sha": "3aaf5fb3f3e3a56ad455db915356733b45482d61", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,11 +9,8 @@ LL |     for l in bad_letters {\n LL |     bad_letters.push('s');\n    |     ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `bad_letters`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `bad_letters`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider iterating over a slice of the `Vec<char>`'s content to avoid moving into the `for` loop\n    |\n LL |     for l in &bad_letters {"}, {"sha": "386ac794d7db32f77e643edb15d9e599a69d6cad", "filename": "src/test/ui/issues/issue-64559.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,11 +10,8 @@ LL |     let _closure = || orig;\n    |                    |\n    |                    value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `orig`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `orig`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider iterating over a slice of the `Vec<bool>`'s content to avoid moving into the `for` loop\n    |\n LL |     for _val in &orig {}"}, {"sha": "cec482a53baa91b3e962056d017c836247f8742a", "filename": "src/test/ui/issues/issue-66923-show-error-for-correct-call.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -15,9 +15,6 @@ LL |     let x2: Vec<f64> = x1.into_iter().collect();\n    |                           ^^^^^^^^^^^ `Iterator::Item` is `&f64` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error[E0277]: a value of type `Vec<f64>` cannot be built from an iterator over elements of type `&f64`\n   --> $DIR/issue-66923-show-error-for-correct-call.rs:12:29\n@@ -37,9 +34,6 @@ LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n    |                 ^^^^^^^^^^^ `Iterator::Item` is `&f64` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c983026995b20b8b91992006de95ee9071f7d770", "filename": "src/test/ui/issues/issue-7607-1.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-7607-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-7607-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7607-1.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error[E0412]: cannot find type `Fo` in this scope\n    |\n LL | impl Fo {\n    |      ^^ help: a trait with a similar name exists: `Fn`\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n \n error: aborting due to previous error\n "}, {"sha": "572414df2bf9d6af0b37498610f95f9529cf0060", "filename": "src/test/ui/issues/issue-83924.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-83924.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fissues%2Fissue-83924.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-83924.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,11 +10,8 @@ LL |     for n in v {\n LL |     for n in v {\n    |              ^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `v`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `v`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider creating a fresh reborrow of `v` here\n    |\n LL |     for n in &mut *v {"}, {"sha": "e38745cc10e1f3840e1081acc2e500700d827d15", "filename": "src/test/ui/iterators/collect-into-array.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |     let whatever: [u32; 10] = (0..10).collect();\n    = help: the trait `FromIterator<{integer}>` is not implemented for `[u32; 10]`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to previous error\n "}, {"sha": "29fff8c51c63be7ca4ee0b096c52f1ee5d522bb5", "filename": "src/test/ui/iterators/collect-into-slice.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -17,9 +17,6 @@ LL |     let some_generated_vec = (0..10).collect();\n    = help: the trait `Sized` is not implemented for `[i32]`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                ^ required by this bound in `Iterator::collect`\n \n error[E0277]: a slice of type `[i32]` cannot be built since `[i32]` has no definite size\n   --> $DIR/collect-into-slice.rs:6:38\n@@ -30,9 +27,6 @@ LL |     let some_generated_vec = (0..10).collect();\n    = help: the trait `FromIterator<{integer}>` is not implemented for `[i32]`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "84bac7833f67b029b56e09e1b5c54ac2d4eaf946", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -22,9 +22,6 @@ LL | |         });\n    | |__________^ `Iterator::Item` changed to `()` here\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         S: Sum<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n   --> $DIR/invalid-iterator-chain.rs:18:14\n@@ -57,9 +54,6 @@ LL |             .map(|x| { x; })\n    |              ^^^^^^^^^^^^^^^ `Iterator::Item` changed to `()` here\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         S: Sum<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `f64`\n   --> $DIR/invalid-iterator-chain.rs:28:14\n@@ -88,9 +82,6 @@ LL |             .map(|x| { x + 1.0 })\n    |              -------------------- `Iterator::Item` remains `f64` here\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         S: Sum<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `()`\n   --> $DIR/invalid-iterator-chain.rs:30:54\n@@ -112,9 +103,6 @@ LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n    |                    this expression has type `Vec<{integer}>`\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         S: Sum<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by summing an iterator over elements of type `&()`\n   --> $DIR/invalid-iterator-chain.rs:31:40\n@@ -135,9 +123,6 @@ LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n    |                    this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         S: Sum<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `Vec<i32>` cannot be built from an iterator over elements of type `()`\n   --> $DIR/invalid-iterator-chain.rs:40:25\n@@ -167,9 +152,6 @@ LL |       let f = e.filter(|_| false);\n    |                 ----------------- `Iterator::Item` remains `()` here\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a7d9c481a1a662cbceb90e4a820a47f2c96c9376", "filename": "src/test/ui/iterators/vec-on-unimplemented.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Fvec-on-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fiterators%2Fvec-on-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fvec-on-unimplemented.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error[E0599]: `Vec<bool>` is not an iterator\n    |\n LL |     vec![true, false].map(|v| !v).collect::<Vec<_>>();\n    |                       ^^^ `Vec<bool>` is not an iterator; try calling `.into_iter()` or `.iter()`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-   |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n-   | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<bool>: Iterator`\n+   = note: doesn't satisfy `Vec<bool>: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<bool>: Iterator`"}, {"sha": "0b206f31e7b6ebdd1f3c083c63eaa4bb9a947ce9", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |         std::iter::empty().collect()\n    = help: the trait `FromIterator<_>` is not implemented for `Bar`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to previous error\n "}, {"sha": "d8ac39a4f27a37869e5b72fab32d9d38730e42a3", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion4.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL |     x = std::iter::empty().collect();\n    = help: the trait `FromIterator<_>` is not implemented for `Foo`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error[E0277]: a value of type `impl Debug` cannot be built from an iterator over elements of type `_`\n   --> $DIR/recursion4.rs:19:28\n@@ -20,9 +17,6 @@ LL |     x = std::iter::empty().collect();\n    = help: the trait `FromIterator<_>` is not implemented for `impl Debug`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::collect`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f455dcb06f79dc97aa9e3072699154a3bb8121e5", "filename": "src/test/ui/limits/issue-55878.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flimits%2Fissue-55878.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flimits%2Fissue-55878.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flimits%2Fissue-55878.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,14 +1,8 @@\n error[E0080]: values of the type `[u8; SIZE]` are too big for the current architecture\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n note: inside `std::mem::size_of::<[u8; SIZE]>`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `main`\n   --> $DIR/issue-55878.rs:7:26\n    |"}, {"sha": "48fd4169da7c975aedc0bd24c0040d30c4d98f6c", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -604,9 +604,6 @@ LL |         let _val: Result<i32, i32> = mem::uninitialized();\n    |\n note: enums with multiple inhabited variants have to be initialized to a variant\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:152:34"}, {"sha": "747c38b800764a36a3f786d3fc76565fe3ffe0ac", "filename": "src/test/ui/lint/lint-const-item-mutation.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -108,9 +108,6 @@ LL |     VEC.push(0);\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: mutable reference created due to call to this method\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-   |\n-LL |     pub fn push(&mut self, value: T) {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: `const` item defined here\n   --> $DIR/lint-const-item-mutation.rs:31:1\n    |"}, {"sha": "e6a60d7bc4072378f2cf91a1e01e95f258d02a55", "filename": "src/test/ui/loops/issue-82916.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Floops%2Fissue-82916.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Floops%2Fissue-82916.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops%2Fissue-82916.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,11 +9,8 @@ LL |     for y in x {\n LL |     let z = x;\n    |             ^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `x`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `x`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider iterating over a slice of the `Vec<S>`'s content to avoid moving into the `for` loop\n    |\n LL |     for y in &x {"}, {"sha": "287cd7d67044eb824eba79c53b7c89130d356c27", "filename": "src/test/ui/macros/format-args-temporaries-in-write.stderr", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,11 +12,6 @@ LL |     };\n    |     |\n    |     `mutex` dropped here while still borrowed\n    |\n-help: consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped\n-  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |         $dst.write_fmt($crate::format_args!($($arg)*));\n-   |                                                       +\n \n error[E0597]: `mutex` does not live long enough\n   --> $DIR/format-args-temporaries-in-write.rs:47:29\n@@ -32,11 +27,6 @@ LL |     };\n    |     |\n    |     `mutex` dropped here while still borrowed\n    |\n-help: consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped\n-  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |         $dst.write_fmt($crate::format_args_nl!($($arg)*));\n-   |                                                          +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d7c8aaae22e1e1cf0e4ff3d74488ee324c58443a", "filename": "src/test/ui/macros/macro-name-typo.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error: cannot find macro `printlx` in this scope\n    |\n LL |     printlx!(\"oh noes!\");\n    |     ^^^^^^^ help: a macro with a similar name exists: `println`\n+  --> $SRC_DIR/std/src/macros.rs:LL:COL\n    |\n-  ::: $SRC_DIR/std/src/macros.rs:LL:COL\n-   |\n-LL | macro_rules! println {\n-   | -------------------- similarly named macro `println` defined here\n+   = note: similarly named macro `println` defined here\n \n error: aborting due to previous error\n "}, {"sha": "f1c3512bc9b8ee39fba96b9bf7b545e84d5ca1cc", "filename": "src/test/ui/macros/macro-path-prelude-fail-3.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error: cannot find macro `inline` in this scope\n    |\n LL |     inline!();\n    |     ^^^^^^ help: a macro with a similar name exists: `line`\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |     macro_rules! line {\n-   |     ----------------- similarly named macro `line` defined here\n+   = note: similarly named macro `line` defined here\n    |\n    = note: `inline` is in scope, but it is an attribute: `#[inline]`\n "}, {"sha": "22f54e04e54c3dc118db8bef42677a0309d58d2e", "filename": "src/test/ui/macros/unknown-builtin.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL | macro_rules! unknown { () => () }\n error[E0773]: attempted to define built-in macro more than once\n   --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-LL |     macro_rules! line {\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n note: previously defined here\n   --> $DIR/unknown-builtin.rs:9:1\n    |"}, {"sha": "6ff6fbabb4a5f3ac04ccdaae843f7b9a233310e2", "filename": "src/test/ui/malformed/malformed-derive-entry.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -24,9 +24,6 @@ LL | #[derive(Copy(Bad))]\n    |\n note: required by a bound in `Copy`\n   --> $SRC_DIR/core/src/marker.rs:LL:COL\n-   |\n-LL | pub trait Copy: Clone {\n-   |                 ^^^^^ required by this bound in `Copy`\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Test1` with `#[derive(Clone)]`\n    |\n@@ -41,9 +38,6 @@ LL | #[derive(Copy=\"bad\")]\n    |\n note: required by a bound in `Copy`\n   --> $SRC_DIR/core/src/marker.rs:LL:COL\n-   |\n-LL | pub trait Copy: Clone {\n-   |                 ^^^^^ required by this bound in `Copy`\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Test2` with `#[derive(Clone)]`\n    |"}, {"sha": "3f4e647491eb7390efc4ba288ba0a788b0bd2484", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -61,11 +61,8 @@ LL |      .take()\n    = note: the following trait bounds were not satisfied:\n            `Foo: Iterator`\n            which is required by `&mut Foo: Iterator`\n-note: the following trait must be implemented\n+note: the trait `Iterator` must be implemented\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL | pub trait Iterator {\n-   | ^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `take`, perhaps you need to implement it:\n            candidate #1: `Iterator`"}, {"sha": "25ad360b329aad8ecba8dbf4591f15c8a572f1e9", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,11 +11,9 @@ warning: cannot specify lifetime arguments explicitly if late bound lifetime par\n    |\n LL |     0.clone::<'a>();\n    |               ^^\n+  --> $SRC_DIR/core/src/clone.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |              - the late bound lifetime parameter is introduced here\n+   = note: the late bound lifetime parameter is introduced here\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>"}, {"sha": "2393791a9b2a81106ad423e13de7bb2f245282ff", "filename": "src/test/ui/mismatched_types/assignment-operator-unimplemented.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,11 +11,8 @@ note: an implementation of `AddAssign<_>` might be missing for `Foo`\n    |\n LL | struct Foo;\n    | ^^^^^^^^^^ must implement `AddAssign<_>`\n-note: the following trait must be implemented\n+note: the trait `AddAssign` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait AddAssign<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2ecab9f024a123a2de0b9d45eac0b9846ddfb9e8", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -128,9 +128,6 @@ LL | fn foo() {}\n    |\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n   --> $DIR/closure-arg-count.rs:27:57\n@@ -144,9 +141,6 @@ LL |     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n    |\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n   --> $DIR/closure-arg-count.rs:29:57\n@@ -161,9 +155,6 @@ LL | fn qux(x: usize, y: usize) {}\n    |\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n   --> $DIR/closure-arg-count.rs:32:45\n@@ -175,9 +166,6 @@ LL |     let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n    |\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error[E0593]: function is expected to take 0 arguments, but it takes 1 argument\n   --> $DIR/closure-arg-count.rs:35:10"}, {"sha": "fab9b7edc0cc5a38bb0c6ab566171b51fa5a4b62", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,9 +12,6 @@ LL |     a.iter().map(|_: (u32, u32)| 45);\n               found closure signature `fn((u32, u32)) -> _`\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error[E0631]: type mismatch in closure arguments\n   --> $DIR/closure-arg-type-mismatch.rs:4:14\n@@ -28,9 +25,6 @@ LL |     a.iter().map(|_: &(u16, u16)| 45);\n               found closure signature `for<'a> fn(&'a (u16, u16)) -> _`\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error[E0631]: type mismatch in closure arguments\n   --> $DIR/closure-arg-type-mismatch.rs:5:14\n@@ -44,9 +38,6 @@ LL |     a.iter().map(|_: (u16, u16)| 45);\n               found closure signature `fn((u16, u16)) -> _`\n note: required by a bound in `map`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         F: FnMut(Self::Item) -> B,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::map`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "680aff1726f9f905e056c800fad7a27206bfa5f5", "filename": "src/test/ui/mismatched_types/issue-35030.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-35030.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-35030.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-35030.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,9 +13,6 @@ LL |         Some(true)\n                         found type `bool` (`bool`)\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b91f75b97f84a0ce4b1483ccafafc26751fd7f45", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -12,9 +12,6 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n               found closure signature `for<'a> fn(&'a str) -> _`\n note: required by a bound in `filter`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         P: FnMut(&Self::Item) -> bool,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::filter`\n \n error[E0599]: the method `count` exists for struct `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:48]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-36053-2.rs:7:55\n@@ -24,11 +21,9 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n    |                                       |\n    |                                       doesn't satisfy `<_ as FnOnce<(&&str,)>>::Output = bool`\n    |                                       doesn't satisfy `_: FnMut<(&&str,)>`\n+  --> $SRC_DIR/core/src/iter/adapters/filter.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/iter/adapters/filter.rs:LL:COL\n-   |\n-LL | pub struct Filter<I, P> {\n-   | ----------------------- doesn't satisfy `_: Iterator`\n+   = note: doesn't satisfy `_: Iterator`\n    |\n    = note: the following trait bounds were not satisfied:\n            `<[closure@$DIR/issue-36053-2.rs:7:39: 7:48] as FnOnce<(&&str,)>>::Output = bool`"}, {"sha": "a5f38dd53666151a272d2893d6c2447b0895f5e8", "filename": "src/test/ui/mismatched_types/issue-47706-trait.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-47706-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-47706-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-47706-trait.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,9 +10,6 @@ LL |         None::<()>.map(Self::f);\n    |\n note: required by a bound in `Option::<T>::map`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |         F: ~const FnOnce(T) -> U,\n-   |            ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n \n error: aborting due to previous error\n "}, {"sha": "d9d408844d0a49140737ca05f8007dfa68541174", "filename": "src/test/ui/mismatched_types/issue-47706.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-47706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-47706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-47706.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,9 +11,6 @@ LL |         self.foo.map(Foo::new)\n    |\n note: required by a bound in `Option::<T>::map`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |         F: ~const FnOnce(T) -> U,\n-   |            ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n \n error[E0593]: function is expected to take 0 arguments, but it takes 1 argument\n   --> $DIR/issue-47706.rs:27:9"}, {"sha": "b75c7a99fdd334c98fc8d956c9310233a24fc7d0", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -14,11 +14,9 @@ error: `impl` item signature doesn't match `trait` item signature\n    |\n LL |     fn next(&mut self) -> Option<IteratorChunk<T, S>> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'1, T, S>>`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |     fn next(&mut self) -> Option<Self::Item>;\n-   |     ----------------------------------------- expected `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, T, S>>`\n+   = note: expected `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, T, S>>`\n    |\n    = note: expected `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'static, T, S>>`\n               found `fn(&'1 mut ChunkingIterator<T, S>) -> Option<IteratorChunk<'1, T, S>>`"}, {"sha": "d3b7525072ff4748addf112f24b185d8ac0e0238", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,9 +8,6 @@ LL |     a.unwrap();\n    = note: add `#[derive(Debug)]` to `Foo` or manually `impl Debug for Foo`\n note: required by a bound in `Result::<T, E>::unwrap`\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |         E: fmt::Debug,\n-   |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`\n help: consider annotating `Foo` with `#[derive(Debug)]`\n    |\n LL | #[derive(Debug)]"}, {"sha": "46a383325526db3371d9a1eb99bf66d534fa1f4e", "filename": "src/test/ui/mismatched_types/similar_paths.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsimilar_paths.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL |     Some(42_u8)\n    = note: enum `std::option::Option` and enum `Option` have similar names, but are actually distinct types\n note: enum `std::option::Option` is defined in crate `core`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL | pub enum Option<T> {\n-   | ^^^^^^^^^^^^^^^^^^\n note: enum `Option` is defined in the current crate\n   --> $DIR/similar_paths.rs:1:1\n    |"}, {"sha": "c5159471fe3e405bf9775d8ca1eb16f39433840f", "filename": "src/test/ui/moves/issue-99470-move-out-of-some.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-99470-move-out-of-some.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -5,11 +5,16 @@ LL |     match x {\n    |           ^\n LL |\n LL |         &Some(_y) => (),\n-   |         ---------\n-   |         |     |\n-   |         |     data moved here\n-   |         |     move occurs because `_y` has type `Box<i32>`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Some(_y)`\n+   |               --\n+   |               |\n+   |               data moved here\n+   |               move occurs because `_y` has type `Box<i32>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &Some(_y) => (),\n+LL +         Some(_y) => (),\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "b3f95ee192a565e85a6bc7647068168fd46e203f", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,11 +6,8 @@ LL |     val.0.into_iter().next();\n LL |     val.0;\n    |     ^^^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `val.0`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `val.0`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n    = note: move occurs because `val.0` has type `Vec<bool>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `foo`\n@@ -23,7 +20,7 @@ LL |     foo.use_self();\n LL |     foo;\n    |     ^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `foo`\n+note: `Foo::use_self` takes ownership of the receiver `self`, which moves `foo`\n   --> $DIR/move-fn-self-receiver.rs:13:17\n    |\n LL |     fn use_self(self) {}\n@@ -49,7 +46,7 @@ LL |     boxed_foo.use_box_self();\n LL |     boxed_foo;\n    |     ^^^^^^^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `boxed_foo`\n+note: `Foo::use_box_self` takes ownership of the receiver `self`, which moves `boxed_foo`\n   --> $DIR/move-fn-self-receiver.rs:14:21\n    |\n LL |     fn use_box_self(self: Box<Self>) {}\n@@ -65,7 +62,7 @@ LL |     pin_box_foo.use_pin_box_self();\n LL |     pin_box_foo;\n    |     ^^^^^^^^^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `pin_box_foo`\n+note: `Foo::use_pin_box_self` takes ownership of the receiver `self`, which moves `pin_box_foo`\n   --> $DIR/move-fn-self-receiver.rs:15:25\n    |\n LL |     fn use_pin_box_self(self: Pin<Box<Self>>) {}\n@@ -91,7 +88,7 @@ LL |     rc_foo.use_rc_self();\n LL |     rc_foo;\n    |     ^^^^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `rc_foo`\n+note: `Foo::use_rc_self` takes ownership of the receiver `self`, which moves `rc_foo`\n   --> $DIR/move-fn-self-receiver.rs:16:20\n    |\n LL |     fn use_rc_self(self: Rc<Self>) {}\n@@ -113,9 +110,6 @@ LL |     foo_add;\n    |\n note: calling this operator moves the left-hand side\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL |     fn add(self, rhs: Rhs) -> Self::Output;\n-   |            ^^^^\n \n error[E0382]: use of moved value: `implicit_into_iter`\n   --> $DIR/move-fn-self-receiver.rs:63:5\n@@ -157,7 +151,7 @@ LL |     for _val in container.custom_into_iter() {}\n LL |     container;\n    |     ^^^^^^^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `container`\n+note: `Container::custom_into_iter` takes ownership of the receiver `self`, which moves `container`\n   --> $DIR/move-fn-self-receiver.rs:23:25\n    |\n LL |     fn custom_into_iter(self) -> impl Iterator<Item = bool> {"}, {"sha": "26d4996d6cb1d7dc18b578eab8071f9fca446abf", "filename": "src/test/ui/moves/move-out-of-array-ref.stderr", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,45 +2,61 @@ error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n   --> $DIR/move-out-of-array-ref.rs:8:24\n    |\n LL |     let [_, e, _, _] = *a;\n-   |             -          ^^\n-   |             |          |\n-   |             |          cannot move out of here\n-   |             |          help: consider borrowing here: `&*a`\n+   |             -          ^^ cannot move out of here\n+   |             |\n    |             data moved here\n    |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let [_, e, _, _] = *a;\n+LL +     let [_, e, _, _] = a;\n+   |\n \n error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n   --> $DIR/move-out-of-array-ref.rs:13:27\n    |\n LL |     let [_, s @ .. , _] = *a;\n-   |             -             ^^\n-   |             |             |\n-   |             |             cannot move out of here\n-   |             |             help: consider borrowing here: `&*a`\n+   |             -             ^^ cannot move out of here\n+   |             |\n    |             data moved here\n    |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let [_, s @ .. , _] = *a;\n+LL +     let [_, s @ .. , _] = a;\n+   |\n \n error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n   --> $DIR/move-out-of-array-ref.rs:18:24\n    |\n LL |     let [_, e, _, _] = *a;\n-   |             -          ^^\n-   |             |          |\n-   |             |          cannot move out of here\n-   |             |          help: consider borrowing here: `&*a`\n+   |             -          ^^ cannot move out of here\n+   |             |\n    |             data moved here\n    |             move occurs because `e` has type `D`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let [_, e, _, _] = *a;\n+LL +     let [_, e, _, _] = a;\n+   |\n \n error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n   --> $DIR/move-out-of-array-ref.rs:23:27\n    |\n LL |     let [_, s @ .. , _] = *a;\n-   |             -             ^^\n-   |             |             |\n-   |             |             cannot move out of here\n-   |             |             help: consider borrowing here: `&*a`\n+   |             -             ^^ cannot move out of here\n+   |             |\n    |             data moved here\n    |             move occurs because `s` has type `[D; 2]`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let [_, s @ .. , _] = *a;\n+LL +     let [_, s @ .. , _] = a;\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "5a0357cf567da1e86140d5638d5ab64fb410b658", "filename": "src/test/ui/moves/move-out-of-slice-1.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-1.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,6 +8,11 @@ LL |         box [a] => {},\n    |              |\n    |              data moved here\n    |              move occurs because `a` has type `A`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         box [ref a] => {},\n+   |              +++\n \n error: aborting due to previous error\n "}, {"sha": "2f7394fbfd36ceba4c381151f17ab6e3460744a4", "filename": "src/test/ui/moves/move-out-of-slice-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,5 +1,6 @@\n #![feature(unsized_locals)]\n //~^ WARN the feature `unsized_locals` is incomplete\n+#![allow(unused)]\n \n struct A;\n #[derive(Clone, Copy)]"}, {"sha": "b46854cd6b4584390f90b0be37a6e752a602e575", "filename": "src/test/ui/moves/move-out-of-slice-2.stderr", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,7 +8,7 @@ LL | #![feature(unsized_locals)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0508]: cannot move out of type `[A]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:10:11\n+  --> $DIR/move-out-of-slice-2.rs:11:11\n    |\n LL |     match *a {\n    |           ^^ cannot move out of here\n@@ -18,9 +18,14 @@ LL |         [a @ ..] => {}\n    |          |\n    |          data moved here\n    |          move occurs because `a` has type `[A]`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         [ref a @ ..] => {}\n+   |          +++\n \n error[E0508]: cannot move out of type `[A]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:16:11\n+  --> $DIR/move-out-of-slice-2.rs:17:11\n    |\n LL |     match *b {\n    |           ^^ cannot move out of here\n@@ -30,9 +35,14 @@ LL |         [_, _, b @ .., _] => {}\n    |                |\n    |                data moved here\n    |                move occurs because `b` has type `[A]`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         [_, _, ref b @ .., _] => {}\n+   |                +++\n \n error[E0508]: cannot move out of type `[C]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:24:11\n+  --> $DIR/move-out-of-slice-2.rs:25:11\n    |\n LL |     match *c {\n    |           ^^ cannot move out of here\n@@ -42,9 +52,14 @@ LL |         [c @ ..] => {}\n    |          |\n    |          data moved here\n    |          move occurs because `c` has type `[C]`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         [ref c @ ..] => {}\n+   |          +++\n \n error[E0508]: cannot move out of type `[C]`, a non-copy slice\n-  --> $DIR/move-out-of-slice-2.rs:30:11\n+  --> $DIR/move-out-of-slice-2.rs:31:11\n    |\n LL |     match *d {\n    |           ^^ cannot move out of here\n@@ -54,6 +69,11 @@ LL |         [_, _, d @ .., _] => {}\n    |                |\n    |                data moved here\n    |                move occurs because `d` has type `[C]`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         [_, _, ref d @ .., _] => {}\n+   |                +++\n \n error: aborting due to 4 previous errors; 1 warning emitted\n "}, {"sha": "0b1a623a01345d75294e7bbe31faf28963421782", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,11 +8,8 @@ LL |     consume(x.into_iter().next().unwrap());\n LL |     touch(&x[0]);\n    |            ^ value borrowed here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `x`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `x`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider cloning the value if the performance cost is acceptable\n    |\n LL |     consume(x.clone().into_iter().next().unwrap());"}, {"sha": "df09ababa5a01f2718d12830aeaa82f944fab49d", "filename": "src/test/ui/moves/moves-based-on-type-block-bad.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-block-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-block-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-block-bad.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,13 +2,18 @@ error[E0507]: cannot move out of `hellothere.x` as enum variant `Bar` which is b\n   --> $DIR/moves-based-on-type-block-bad.rs:22:19\n    |\n LL |             match hellothere.x {\n-   |                   ^^^^^^^^^^^^ help: consider borrowing here: `&hellothere.x`\n+   |                   ^^^^^^^^^^^^\n LL |                 box E::Foo(_) => {}\n LL |                 box E::Bar(x) => println!(\"{}\", x.to_string()),\n    |                            -\n    |                            |\n    |                            data moved here\n    |                            move occurs because `x` has type `Box<isize>`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |             match &hellothere.x {\n+   |                   +\n \n error: aborting due to previous error\n "}, {"sha": "ae76889f104c89a80910e73028a8675818094e8d", "filename": "src/test/ui/moves/moves-based-on-type-exprs.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -160,11 +160,8 @@ LL |     let _y = x.into_iter().next().unwrap();\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `x`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `x`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider cloning the value if the performance cost is acceptable\n    |\n LL |     let _y = x.clone().into_iter().next().unwrap();\n@@ -180,11 +177,8 @@ LL |     let _y = [x.into_iter().next().unwrap(); 1];\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `x`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `x`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider cloning the value if the performance cost is acceptable\n    |\n LL |     let _y = [x.clone().into_iter().next().unwrap(); 1];"}, {"sha": "de5c9c5601635eedef6cc14e9900d98d61414691", "filename": "src/test/ui/never_type/issue-52443.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -46,9 +46,6 @@ LL |     [(); { for _ in 0usize.. {}; 0}];\n    |\n note: impl defined here, but it is not `const`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL | impl<I: Iterator> const IntoIterator for I {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error[E0658]: mutable references are not allowed in constants"}, {"sha": "e148b983e8e9da2836c479cc0bfd21ee3b872b8f", "filename": "src/test/ui/never_type/issue-96335.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnever_type%2Fissue-96335.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnever_type%2Fissue-96335.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-96335.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -26,9 +26,6 @@ LL |     0.....{loop{}1};\n             found struct `RangeTo<{integer}>`\n note: associated function defined here\n   --> $SRC_DIR/core/src/ops/range.rs:LL:COL\n-   |\n-LL |     pub const fn new(start: Idx, end: Idx) -> Self {\n-   |                  ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0dc5c08ea5f08d76ffe34d4b550e0075a836e91b", "filename": "src/test/ui/nll/cannot-move-block-spans.stderr", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnll%2Fcannot-move-block-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnll%2Fcannot-move-block-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcannot-move-block-spans.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,28 +2,37 @@ error[E0507]: cannot move out of `*r` which is behind a shared reference\n   --> $DIR/cannot-move-block-spans.rs:5:15\n    |\n LL |     let x = { *r };\n-   |               ^^\n-   |               |\n-   |               move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n-   |               help: consider borrowing here: `&*r`\n+   |               ^^ move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let x = { *r };\n+LL +     let x = { r };\n+   |\n \n error[E0507]: cannot move out of `*r` which is behind a shared reference\n   --> $DIR/cannot-move-block-spans.rs:6:22\n    |\n LL |     let y = unsafe { *r };\n-   |                      ^^\n-   |                      |\n-   |                      move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n-   |                      help: consider borrowing here: `&*r`\n+   |                      ^^ move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let y = unsafe { *r };\n+LL +     let y = unsafe { r };\n+   |\n \n error[E0507]: cannot move out of `*r` which is behind a shared reference\n   --> $DIR/cannot-move-block-spans.rs:7:26\n    |\n LL |     let z = loop { break *r; };\n-   |                          ^^\n-   |                          |\n-   |                          move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n-   |                          help: consider borrowing here: `&*r`\n+   |                          ^^ move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let z = loop { break *r; };\n+LL +     let z = loop { break r; };\n+   |\n \n error[E0508]: cannot move out of type `[String; 2]`, a non-copy array\n   --> $DIR/cannot-move-block-spans.rs:11:15\n@@ -33,7 +42,11 @@ LL |     let x = { arr[0] };\n    |               |\n    |               cannot move out of here\n    |               move occurs because `arr[_]` has type `String`, which does not implement the `Copy` trait\n-   |               help: consider borrowing here: `&arr[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let x = { &arr[0] };\n+   |               +\n \n error[E0508]: cannot move out of type `[String; 2]`, a non-copy array\n   --> $DIR/cannot-move-block-spans.rs:12:22\n@@ -43,7 +56,11 @@ LL |     let y = unsafe { arr[0] };\n    |                      |\n    |                      cannot move out of here\n    |                      move occurs because `arr[_]` has type `String`, which does not implement the `Copy` trait\n-   |                      help: consider borrowing here: `&arr[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let y = unsafe { &arr[0] };\n+   |                      +\n \n error[E0508]: cannot move out of type `[String; 2]`, a non-copy array\n   --> $DIR/cannot-move-block-spans.rs:13:26\n@@ -53,34 +70,47 @@ LL |     let z = loop { break arr[0]; };\n    |                          |\n    |                          cannot move out of here\n    |                          move occurs because `arr[_]` has type `String`, which does not implement the `Copy` trait\n-   |                          help: consider borrowing here: `&arr[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let z = loop { break &arr[0]; };\n+   |                          +\n \n error[E0507]: cannot move out of `*r` which is behind a shared reference\n   --> $DIR/cannot-move-block-spans.rs:17:38\n    |\n LL |     let x = { let mut u = 0; u += 1; *r };\n-   |                                      ^^\n-   |                                      |\n-   |                                      move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n-   |                                      help: consider borrowing here: `&*r`\n+   |                                      ^^ move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let x = { let mut u = 0; u += 1; *r };\n+LL +     let x = { let mut u = 0; u += 1; r };\n+   |\n \n error[E0507]: cannot move out of `*r` which is behind a shared reference\n   --> $DIR/cannot-move-block-spans.rs:18:45\n    |\n LL |     let y = unsafe { let mut u = 0; u += 1; *r };\n-   |                                             ^^\n-   |                                             |\n-   |                                             move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n-   |                                             help: consider borrowing here: `&*r`\n+   |                                             ^^ move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let y = unsafe { let mut u = 0; u += 1; *r };\n+LL +     let y = unsafe { let mut u = 0; u += 1; r };\n+   |\n \n error[E0507]: cannot move out of `*r` which is behind a shared reference\n   --> $DIR/cannot-move-block-spans.rs:19:49\n    |\n LL |     let z = loop { let mut u = 0; u += 1; break *r; u += 2; };\n-   |                                                 ^^\n-   |                                                 |\n-   |                                                 move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n-   |                                                 help: consider borrowing here: `&*r`\n+   |                                                 ^^ move occurs because `*r` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let z = loop { let mut u = 0; u += 1; break *r; u += 2; };\n+LL +     let z = loop { let mut u = 0; u += 1; break r; u += 2; };\n+   |\n \n error: aborting due to 9 previous errors\n "}, {"sha": "7f9cbc3c30a92a9ddabcc689bcbb159685ff5acc", "filename": "src/test/ui/nll/issue-52059-report-when-borrow-and-drop-conflict.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -36,7 +36,11 @@ LL |     let p = s.url; p\n    |             |\n    |             cannot move out of here\n    |             move occurs because `s.url` has type `&mut String`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&s.url`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let p = &s.url; p\n+   |             +\n \n error: aborting due to 4 previous errors\n "}, {"sha": "58b8aa31d4c2d26c5c140de80b8c1d6ca28fb192", "filename": "src/test/ui/nll/move-errors.stderr", "status": "modified", "additions": 78, "deletions": 20, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,10 +2,13 @@ error[E0507]: cannot move out of `*a` which is behind a shared reference\n   --> $DIR/move-errors.rs:6:13\n    |\n LL |     let b = *a;\n-   |             ^^\n-   |             |\n-   |             move occurs because `*a` has type `A`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*a`\n+   |             ^^ move occurs because `*a` has type `A`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let b = *a;\n+LL +     let b = a;\n+   |\n \n error[E0508]: cannot move out of type `[A; 1]`, a non-copy array\n   --> $DIR/move-errors.rs:12:13\n@@ -15,25 +18,35 @@ LL |     let b = a[0];\n    |             |\n    |             cannot move out of here\n    |             move occurs because `a[_]` has type `A`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&a[0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let b = &a[0];\n+   |             +\n \n error[E0507]: cannot move out of `**r` which is behind a shared reference\n   --> $DIR/move-errors.rs:19:13\n    |\n LL |     let s = **r;\n-   |             ^^^\n-   |             |\n-   |             move occurs because `**r` has type `A`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&**r`\n+   |             ^^^ move occurs because `**r` has type `A`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let s = **r;\n+LL +     let s = *r;\n+   |\n \n error[E0507]: cannot move out of an `Rc`\n   --> $DIR/move-errors.rs:27:13\n    |\n LL |     let s = *r;\n-   |             ^^\n-   |             |\n-   |             move occurs because value has type `A`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*r`\n+   |             ^^ move occurs because value has type `A`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let s = *r;\n+LL +     let s = r;\n+   |\n \n error[E0508]: cannot move out of type `[A; 1]`, a non-copy array\n   --> $DIR/move-errors.rs:32:13\n@@ -43,16 +56,26 @@ LL |     let a = [A(\"\".to_string())][0];\n    |             |\n    |             cannot move out of here\n    |             move occurs because value has type `A`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&[A(\"\".to_string())][0]`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let a = &[A(\"\".to_string())][0];\n+   |             +\n \n error[E0507]: cannot move out of `a` which is behind a shared reference\n   --> $DIR/move-errors.rs:38:16\n    |\n LL |     let A(s) = *a;\n-   |           -    ^^ help: consider borrowing here: `&*a`\n+   |           -    ^^\n    |           |\n    |           data moved here\n    |           move occurs because `s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let A(s) = *a;\n+LL +     let A(s) = a;\n+   |\n \n error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n   --> $DIR/move-errors.rs:44:19\n@@ -62,6 +85,11 @@ LL |     let C(D(s)) = c;\n    |             |\n    |             data moved here\n    |             move occurs because `s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let C(D(ref s)) = c;\n+   |             +++\n \n error[E0507]: cannot move out of `*a` which is behind a shared reference\n   --> $DIR/move-errors.rs:51:9\n@@ -73,17 +101,18 @@ error[E0508]: cannot move out of type `[B; 1]`, a non-copy array\n   --> $DIR/move-errors.rs:74:11\n    |\n LL |     match x[0] {\n-   |           ^^^^\n-   |           |\n-   |           cannot move out of here\n-   |           help: consider borrowing here: `&x[0]`\n+   |           ^^^^ cannot move out of here\n LL |\n LL |         B::U(d) => (),\n    |              - data moved here\n LL |         B::V(s) => (),\n    |              - ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing here\n+   |\n+LL |     match &x[0] {\n+   |           +\n \n error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n   --> $DIR/move-errors.rs:83:11\n@@ -96,6 +125,11 @@ LL |         B::U(D(s)) => (),\n    |                |\n    |                data moved here\n    |                move occurs because `s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         B::U(D(ref s)) => (),\n+   |                +++\n \n error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n   --> $DIR/move-errors.rs:92:11\n@@ -108,6 +142,11 @@ LL |         (D(s), &t) => (),\n    |            |\n    |            data moved here\n    |            move occurs because `s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (D(ref s), &t) => (),\n+   |            +++\n \n error[E0507]: cannot move out of `*x.1` which is behind a shared reference\n   --> $DIR/move-errors.rs:92:11\n@@ -120,6 +159,11 @@ LL |         (D(s), &t) => (),\n    |                 |\n    |                 data moved here\n    |                 move occurs because `t` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (D(s), &ref t) => (),\n+   |                 +++\n \n error[E0509]: cannot move out of type `F`, which implements the `Drop` trait\n   --> $DIR/move-errors.rs:102:11\n@@ -133,18 +177,32 @@ LL |         F(s, mut t) => (),\n    |           data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing the pattern binding\n+   |\n+LL |         F(ref s, mut t) => (),\n+   |           +++\n+help: consider borrowing the pattern binding\n+   |\n+LL |         F(s, ref mut t) => (),\n+   |              +++\n \n error[E0507]: cannot move out of `x` as enum variant `Err` which is behind a shared reference\n   --> $DIR/move-errors.rs:110:11\n    |\n LL |     match *x {\n-   |           ^^ help: consider borrowing here: `&*x`\n+   |           ^^\n LL |\n LL |         Ok(s) | Err(s) => (),\n    |            -\n    |            |\n    |            data moved here\n    |            move occurs because `s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     match *x {\n+LL +     match x {\n+   |\n \n error: aborting due to 14 previous errors\n "}, {"sha": "296e1fb3f26fe01319e36320608ee1c6365f6536", "filename": "src/test/ui/no-capture-arc.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fno-capture-arc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fno-capture-arc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-capture-arc.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,11 +13,6 @@ LL |     assert_eq!((*arc_v)[2], 3);\n    |                ^^^^^^^^ value borrowed here after move\n    |\n    = note: borrow occurs due to deref coercion to `Vec<i32>`\n-note: deref defined here\n-  --> $SRC_DIR/alloc/src/sync.rs:LL:COL\n-   |\n-LL |     type Target = T;\n-   |     ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "bcd481c33f361b374b7ee26aea00c8ce50a99a9e", "filename": "src/test/ui/no-reuse-move-arc.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-reuse-move-arc.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,11 +13,6 @@ LL |     assert_eq!((*arc_v)[2], 3);\n    |                ^^^^^^^^ value borrowed here after move\n    |\n    = note: borrow occurs due to deref coercion to `Vec<i32>`\n-note: deref defined here\n-  --> $SRC_DIR/alloc/src/sync.rs:LL:COL\n-   |\n-LL |     type Target = T;\n-   |     ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "75561f4119aa543d432b53da3df5bdf2957a5074", "filename": "src/test/ui/no-send-res-ports.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fno-send-res-ports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fno-send-res-ports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-send-res-ports.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -31,9 +31,6 @@ LL |     thread::spawn(move|| {\n    |                   ^^^^^^\n note: required by a bound in `spawn`\n   --> $SRC_DIR/std/src/thread/mod.rs:LL:COL\n-   |\n-LL |     F: Send + 'static,\n-   |        ^^^^ required by this bound in `spawn`\n \n error: aborting due to previous error\n "}, {"sha": "2a316dba778fe8f0163c50c5178e3ae22e287f7f", "filename": "src/test/ui/on-unimplemented/sum.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fsum.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -17,9 +17,6 @@ LL |     vec![(), ()].iter().sum::<i32>();\n    |     this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         S: Sum<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`\n \n error[E0277]: a value of type `i32` cannot be made by multiplying all elements of type `&()` from an iterator\n   --> $DIR/sum.rs:7:25\n@@ -40,9 +37,6 @@ LL |     vec![(), ()].iter().product::<i32>();\n    |     this expression has type `Vec<()>`\n note: required by a bound in `std::iter::Iterator::product`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         P: Product<Self::Item>,\n-   |            ^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::product`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "10d42b7e3c0b8de4892a98ee411bb38e709c8198", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -35,11 +35,8 @@ note: an implementation of `BitOr<_>` might be missing for `E`\n    |\n LL | enum E { A, B }\n    | ^^^^^^ must implement `BitOr<_>`\n-note: the following trait must be implemented\n+note: the trait `BitOr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-   |\n-LL | pub trait BitOr<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "2e16007825935a159bf5d213f332dd096b54d483", "filename": "src/test/ui/overloaded/overloaded-calls-nontuple.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Foverloaded%2Foverloaded-calls-nontuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Foverloaded%2Foverloaded-calls-nontuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foverloaded%2Foverloaded-calls-nontuple.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL | impl FnMut<isize> for S {\n    |\n note: required by a bound in `FnMut`\n   --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n-   |                       ^^^^^ required by this bound in `FnMut`\n \n error[E0059]: type parameter to bare `FnOnce` trait must be a tuple\n   --> $DIR/overloaded-calls-nontuple.rs:18:6\n@@ -18,9 +15,6 @@ LL | impl FnOnce<isize> for S {\n    |\n note: required by a bound in `FnOnce`\n   --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait FnOnce<Args: Tuple> {\n-   |                        ^^^^^ required by this bound in `FnOnce`\n \n error[E0277]: functions with the \"rust-call\" ABI must take a single non-self tuple argument\n   --> $DIR/overloaded-calls-nontuple.rs:12:5"}, {"sha": "07a203bf416eada152c3ca9da8e11d59d0c7ccd3", "filename": "src/test/ui/parser/issues/issue-62894.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62894.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62894.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-62894.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -42,11 +42,9 @@ LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n LL |\n LL | fn main() {}\n    | ^^ unexpected token\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |     ($left:expr, $right:expr $(,)?) => {\n-   |      ---------- while parsing argument for this `expr` macro fragment\n+   = note: while parsing argument for this `expr` macro fragment\n \n error: aborting due to 4 previous errors\n "}, {"sha": "79643660e8b0078c73e70de919e0fd285dc0f415", "filename": "src/test/ui/parser/kw-in-trait-bounds.stderr", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fkw-in-trait-bounds.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -91,44 +91,36 @@ error[E0405]: cannot find trait `r#fn` in this scope\n    |\n LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n    |          ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n \n error[E0405]: cannot find trait `r#fn` in this scope\n   --> $DIR/kw-in-trait-bounds.rs:17:4\n    |\n LL | G: fn(),\n    |    ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n \n error[E0405]: cannot find trait `r#fn` in this scope\n   --> $DIR/kw-in-trait-bounds.rs:3:27\n    |\n LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n    |                           ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n \n error[E0405]: cannot find trait `r#fn` in this scope\n   --> $DIR/kw-in-trait-bounds.rs:3:41\n    |\n LL | fn _f<F: fn(), G>(_: impl fn(), _: &dyn fn())\n    |                                         ^^ help: a trait with a similar name exists (notice the capitalization): `Fn`\n+  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL | pub trait Fn<Args: Tuple>: FnMut<Args> {\n-   | -------------------------------------- similarly named trait `Fn` defined here\n+   = note: similarly named trait `Fn` defined here\n \n error[E0405]: cannot find trait `r#struct` in this scope\n   --> $DIR/kw-in-trait-bounds.rs:24:10"}, {"sha": "5f04fc83d37abdebc9ba6a846b9f625a288b1d16", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes-fixable.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.fixed?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+fn main() {\n+    struct U;\n+\n+    // A tuple is a \"non-reference pattern\".\n+    // A `mut` binding pattern resets the binding mode to by-value.\n+\n+    let mut p = (U, U);\n+    let (a, ref mut b) = &mut p;\n+    //~^ ERROR cannot move out of a mutable reference\n+}"}, {"sha": "5dc1ae2feb5f06d714778f7a2f591ae1836da11b", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes-fixable.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+fn main() {\n+    struct U;\n+\n+    // A tuple is a \"non-reference pattern\".\n+    // A `mut` binding pattern resets the binding mode to by-value.\n+\n+    let mut p = (U, U);\n+    let (a, mut b) = &mut p;\n+    //~^ ERROR cannot move out of a mutable reference\n+}"}, {"sha": "d3ab533e35e4ab55f746e6a048f689c7b00c98c3", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes-fixable.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes-fixable.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -0,0 +1,17 @@\n+error[E0507]: cannot move out of a mutable reference\n+  --> $DIR/move-ref-patterns-default-binding-modes-fixable.rs:10:22\n+   |\n+LL |     let (a, mut b) = &mut p;\n+   |             -----    ^^^^^^\n+   |             |\n+   |             data moved here\n+   |             move occurs because `b` has type `U`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let (a, ref mut b) = &mut p;\n+   |             +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "6c913c245130d7307b7c8361731568bbc76385b1", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,8 +7,4 @@ fn main() {\n     let p = (U, U);\n     let (a, mut b) = &p;\n     //~^ ERROR cannot move out of a shared reference\n-\n-    let mut p = (U, U);\n-    let (a, mut b) = &mut p;\n-    //~^ ERROR cannot move out of a mutable reference\n }"}, {"sha": "65030b62250012729961a9f6938d6d012a4b1dd0", "filename": "src/test/ui/pattern/move-ref-patterns/move-ref-patterns-default-binding-modes.stderr", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fmove-ref-patterns-default-binding-modes.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,16 +6,12 @@ LL |     let (a, mut b) = &p;\n    |             |\n    |             data moved here\n    |             move occurs because `b` has type `U`, which does not implement the `Copy` trait\n-\n-error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/move-ref-patterns-default-binding-modes.rs:12:22\n    |\n-LL |     let (a, mut b) = &mut p;\n-   |             -----    ^^^^^^\n-   |             |\n-   |             data moved here\n-   |             move occurs because `b` has type `U`, which does not implement the `Copy` trait\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let (a, ref mut b) = &p;\n+   |             +++\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0507`."}, {"sha": "2a016048f2f7a03c38464de94af8c4ba0d0021a0", "filename": "src/test/ui/pattern/suggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,12 +6,9 @@ LL |     match Some(1) {\n    |\n note: `Option<i32>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     None,\n-   |     ^^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |"}, {"sha": "17e1a2304a13c0c8011481553170e1886fc11e5e", "filename": "src/test/ui/pattern/usefulness/doc-hidden-non-exhaustive.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fdoc-hidden-non-exhaustive.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -66,12 +66,9 @@ LL |     match None {\n    |\n note: `Option<HiddenEnum>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Option<HiddenEnum>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern, a match arm with multiple or-patterns as shown, or multiple match arms\n    |"}, {"sha": "12113957d6340dbc0862060d0b2072ed0ba124d4", "filename": "src/test/ui/pattern/usefulness/issue-35609.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -107,9 +107,6 @@ LL |     match Some(A) {\n    |\n note: `Option<Enum>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL | pub enum Option<T> {\n-   | ^^^^^^^^^^^^^^^^^^\n    = note: the matched value is of type `Option<Enum>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n    |"}, {"sha": "59d7bcd4b5e799d443b90374b7b18d6b2eef5d10", "filename": "src/test/ui/pattern/usefulness/issue-3601.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,12 +6,6 @@ LL |         box NodeKind::Element(ed) => match ed.kind {\n    |\n note: `Box<ElementKind>` defined here\n   --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-   |\n-LL | / pub struct Box<\n-LL | |     T: ?Sized,\n-LL | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-LL | | >(Unique<T>, A);\n-   | |_^\n    = note: the matched value is of type `Box<ElementKind>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |"}, {"sha": "e4dd35a59958ef37f2dc2ed58508168472bec0af", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -19,15 +19,11 @@ LL |     match Some(Some(North)) {\n    |\n note: `Option<Option<Direction>>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n-   |     |\n-   |     not covered\n-   |     not covered\n+   = note: not covered\n+   |\n+   = note: not covered\n    = note: the matched value is of type `Option<Option<Direction>>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |"}, {"sha": "86f75d15cfde7736c2294be1373bd6c9b605993b", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,12 +6,9 @@ LL |     match private::DATA {\n    |\n note: `Option<Private>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Option<Private>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |"}, {"sha": "e2260f50bfef2b462fa795ace1352d6a714f7916", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -36,12 +36,9 @@ LL |     match Some(10) {\n    |\n note: `Option<i32>` defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n+  ::: $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL | pub enum Option<T> {\n-   | ------------------\n-...\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n    |"}, {"sha": "c686a21772e0ed4e7ebfb3026779ff712d183222", "filename": "src/test/ui/privacy/associated-item-privacy-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -19,9 +19,9 @@ mod priv_trait {\n         Pub.method();\n         //~^ ERROR type `for<'a> fn(&'a Self) {<Self as PrivTr>::method}` is private\n         <Pub as PrivTr>::CONST;\n-        //~^ ERROR associated constant `<Pub as PrivTr>::CONST` is private\n+        //~^ ERROR associated constant `PrivTr::CONST` is private\n         let _: <Pub as PrivTr>::AssocTy;\n-        //~^ ERROR associated type `<Pub as PrivTr>::AssocTy` is private\n+        //~^ ERROR associated type `PrivTr::AssocTy` is private\n         pub type InSignatureTy = <Pub as PrivTr>::AssocTy;\n         //~^ ERROR trait `PrivTr` is private\n         pub trait InSignatureTr: PrivTr {}"}, {"sha": "eb905bf7ef85890d7783430b9db3e206c5eda39f", "filename": "src/test/ui/privacy/associated-item-privacy-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -31,7 +31,7 @@ LL |     priv_trait::mac!();\n    |\n    = note: this error originates in the macro `priv_trait::mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: associated constant `<Pub as PrivTr>::CONST` is private\n+error: associated constant `PrivTr::CONST` is private\n   --> $DIR/associated-item-privacy-trait.rs:21:9\n    |\n LL |         <Pub as PrivTr>::CONST;\n@@ -42,7 +42,7 @@ LL |     priv_trait::mac!();\n    |\n    = note: this error originates in the macro `priv_trait::mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: associated type `<Pub as PrivTr>::AssocTy` is private\n+error: associated type `PrivTr::AssocTy` is private\n   --> $DIR/associated-item-privacy-trait.rs:23:16\n    |\n LL |         let _: <Pub as PrivTr>::AssocTy;"}, {"sha": "cdbdcf60b2c540f78ffe6643c9b4745a38957ff1", "filename": "src/test/ui/privacy/private-inferred-type-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,7 +1,7 @@\n // aux-build:private-inferred-type.rs\n \n // error-pattern:type `fn() {ext::priv_fn}` is private\n-// error-pattern:static `PRIV_STATIC` is private\n+// error-pattern:static `ext::PRIV_STATIC` is private\n // error-pattern:type `ext::PrivEnum` is private\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n // error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct}` is private"}, {"sha": "42faeb4bf341dea982b44442d2cbec0061059d1a", "filename": "src/test/ui/privacy/private-inferred-type-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,7 +6,7 @@ LL |     ext::m!();\n    |\n    = note: this error originates in the macro `ext::m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: static `PRIV_STATIC` is private\n+error: static `ext::PRIV_STATIC` is private\n   --> $DIR/private-inferred-type-3.rs:16:5\n    |\n LL |     ext::m!();"}, {"sha": "14e5df21ef651a2e5d3c24e520770a77720b4105", "filename": "src/test/ui/proc-macro/issue-104884-trait-impl-sugg-err.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fissue-104884-trait-impl-sugg-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fissue-104884-trait-impl-sugg-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-104884-trait-impl-sugg-err.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,9 +7,6 @@ LL | #[derive(PartialOrd, AddImpl)]\n    = help: the trait `PartialEq` is not implemented for `PriorityQueue<T>`\n note: required by a bound in `PartialOrd`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n-   |                                           ^^^^^^^^^^^^^^ required by this bound in `PartialOrd`\n    = note: this error originates in the derive macro `PartialOrd` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `PriorityQueue<T>: Eq` is not satisfied\n@@ -20,9 +17,6 @@ LL | #[derive(PartialOrd, AddImpl)]\n    |\n note: required by a bound in `Ord`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub trait Ord: Eq + PartialOrd<Self> {\n-   |                ^^ required by this bound in `Ord`\n    = note: this error originates in the derive macro `AddImpl` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `T` with `T`\n@@ -38,9 +32,6 @@ LL | #[derive(PartialOrd, AddImpl)]\n    |          ^^^^^^^^^^\n note: required by a bound in `Ord`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub trait Ord: Eq + PartialOrd<Self> {\n-   |                     ^^^^^^^^^^^^^^^^ required by this bound in `Ord`\n    = note: this error originates in the derive macro `AddImpl` which comes from the expansion of the derive macro `PartialOrd` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors"}, {"sha": "a3b27fd7bcc1bd5997b83c9fb567a6a0b9973ca6", "filename": "src/test/ui/proc-macro/parent-source-spans.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fparent-source-spans.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -144,11 +144,9 @@ LL |     parent_source_spans!($($tokens)*);\n ...\n LL |     one!(\"hello\", \"world\");\n    |     ---------------------- in this macro invocation\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     -- similarly named tuple variant `Ok` defined here\n+   = note: similarly named tuple variant `Ok` defined here\n    |\n    = note: this error originates in the macro `parent_source_spans` which comes from the expansion of the macro `one` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n@@ -160,11 +158,9 @@ LL |     parent_source_spans!($($tokens)*);\n ...\n LL |     two!(\"yay\", \"rust\");\n    |     ------------------- in this macro invocation\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     -- similarly named tuple variant `Ok` defined here\n+   = note: similarly named tuple variant `Ok` defined here\n    |\n    = note: this error originates in the macro `parent_source_spans` which comes from the expansion of the macro `two` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n@@ -176,11 +172,9 @@ LL |     parent_source_spans!($($tokens)*);\n ...\n LL |     three!(\"hip\", \"hop\");\n    |     -------------------- in this macro invocation\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     -- similarly named tuple variant `Ok` defined here\n+   = note: similarly named tuple variant `Ok` defined here\n    |\n    = note: this error originates in the macro `parent_source_spans` which comes from the expansion of the macro `three` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "3c3f24d0ff22e319e72c930a6b0462aa69423db9", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -72,22 +72,18 @@ error: cannot find derive macro `Dlone` in this scope\n    |\n LL | #[derive(Dlone)]\n    |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n+  --> $SRC_DIR/core/src/clone.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL | pub macro Clone($item:item) {\n-   | --------------- similarly named derive macro `Clone` defined here\n+   = note: similarly named derive macro `Clone` defined here\n \n error: cannot find derive macro `Dlone` in this scope\n   --> $DIR/resolve-error.rs:35:10\n    |\n LL | #[derive(Dlone)]\n    |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n+  --> $SRC_DIR/core/src/clone.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL | pub macro Clone($item:item) {\n-   | --------------- similarly named derive macro `Clone` defined here\n+   = note: similarly named derive macro `Clone` defined here\n \n error: cannot find attribute `FooWithLongNan` in this scope\n   --> $DIR/resolve-error.rs:32:3"}, {"sha": "79f2001da005510f915eb3f696d550df0364f3c8", "filename": "src/test/ui/proc-macro/signature.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -14,9 +14,6 @@ LL | | }\n    = note: unsafe function cannot be called generically without an unsafe block\n note: required by a bound in `ProcMacro::custom_derive`\n   --> $SRC_DIR/proc_macro/src/bridge/client.rs:LL:COL\n-   |\n-LL |         expand: impl Fn(crate::TokenStream) -> crate::TokenStream + Copy,\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ProcMacro::custom_derive`\n \n error: aborting due to previous error\n "}, {"sha": "3f04ba866b7d6952addcbf0faf54f006c94b903c", "filename": "src/test/ui/proc-macro/span-api-tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fspan-api-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fproc-macro%2Fspan-api-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-api-tests.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,6 +2,7 @@\n // ignore-pretty\n // aux-build:span-api-tests.rs\n // aux-build:span-test-macros.rs\n+// compile-flags: -Ztranslate-remapped-path-to-local-path=yes\n \n #[macro_use]\n extern crate span_test_macros;"}, {"sha": "3956390368f7f132ab5b975d168a06516ba8ae4f", "filename": "src/test/ui/range/range-1.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-1.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -32,9 +32,6 @@ LL |     let range = *arr..;\n    = help: the trait `Sized` is not implemented for `[{integer}]`\n note: required by a bound in `RangeFrom`\n   --> $SRC_DIR/core/src/ops/range.rs:LL:COL\n-   |\n-LL | pub struct RangeFrom<Idx> {\n-   |                      ^^^ required by this bound in `RangeFrom`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "86ad6aa847c9fe5adfeb0947cd19d921ffe62b3d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,12 +8,9 @@ LL |     let Ok(x) = res;\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Result<u32, &R<'_>>` defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n+  ::: $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-LL | pub enum Result<T, E> {\n-   | ---------------------\n-...\n-LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n-   |     ^^^ not covered\n+   = note: not covered\n    = note: the matched value is of type `Result<u32, &R<'_>>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "cf478210132ede5fbc5eeaffb7f8168dd08c27ef", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -18,11 +18,9 @@ error[E0412]: cannot find type `Opiton` in this scope\n    |\n LL | type B = Opiton<u8>; // Misspelled type name from the prelude.\n    |          ^^^^^^ help: an enum with a similar name exists: `Option`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL | pub enum Option<T> {\n-   | ------------------ similarly named enum `Option` defined here\n+   = note: similarly named enum `Option` defined here\n \n error[E0412]: cannot find type `Baz` in this scope\n   --> $DIR/levenshtein.rs:16:14"}, {"sha": "964302e924c8ae7cdd987f2590bd4adfb52949e1", "filename": "src/test/ui/resolve/resolve-primitive-fallback.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fresolve%2Fresolve-primitive-fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fresolve%2Fresolve-primitive-fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-primitive-fallback.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -28,9 +28,6 @@ LL |     std::mem::size_of(u16);\n    |\n note: function defined here\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL | pub const fn size_of<T>() -> usize {\n-   |              ^^^^^^^\n help: remove the extra argument\n    |\n LL |     std::mem::size_of();"}, {"sha": "a19750cc73aa559b5d33ae614d3cf920134b95c0", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-test-wrong-type.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -9,9 +9,6 @@ LL | fn can_parse_zero_as_f32() -> Result<f32, ParseFloatError> {\n    = note: required for `Result<f32, ParseFloatError>` to implement `Termination`\n note: required by a bound in `assert_test_result`\n   --> $SRC_DIR/test/src/lib.rs:LL:COL\n-   |\n-LL | pub fn assert_test_result<T: Termination>(result: T) -> Result<(), String> {\n-   |                              ^^^^^^^^^^^ required by this bound in `assert_test_result`\n    = note: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "07991af6ef97c60bd5314f186fdcee1175de73c6", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,6 +6,11 @@ LL |     for (n, mut m) in &tups {\n    |             |\n    |             data moved here\n    |             move occurs because `m` has type `Foo`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     for (n, ref mut m) in &tups {\n+   |             +++\n \n error: aborting due to previous error\n "}, {"sha": "e97fdcce1c18f0913a55090db7eb2d05ffd80ec2", "filename": "src/test/ui/rfc-2361-dbg-macro/dbg-macro-move-semantics.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -8,11 +8,6 @@ LL |     let _ = dbg!(a);\n LL |     let _ = dbg!(a);\n    |                  ^ value used here after move\n    |\n-help: borrow this binding in the pattern to avoid moving the value\n-  --> $SRC_DIR/std/src/macros.rs:LL:COL\n-   |\n-LL |             ref tmp => {\n-   |             +++\n \n error: aborting due to previous error\n "}, {"sha": "5d4d692b2cffb7e5c39ccc0754002018c7ca9ed1", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -26,11 +26,8 @@ note: an implementation of `Add<_>` might be missing for `World`\n    |\n LL | enum World {\n    | ^^^^^^^^^^ must implement `Add<_>`\n-note: the following trait must be implemented\n+note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-   |\n-LL | pub trait Add<Rhs = Self> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0369]: cannot add `String` to `&str`\n   --> $DIR/issue-39018.rs:11:22"}, {"sha": "8014f3796250a1c5c217a24c6e0977c089abbf88", "filename": "src/test/ui/span/issue-71363.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspan%2Fissue-71363.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspan%2Fissue-71363.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-71363.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Z simulate-remapped-rust-src-base=/rustc/FAKE_PREFIX -Z translate-remapped-path-to-local-path=no -Z ui-testing=no\n+// compile-flags: -Z ui-testing=no\n \n struct MyError;\n impl std::error::Error for MyError {}"}, {"sha": "48a2e763af615a23e15104e5ffcf57f0c127cf30", "filename": "src/test/ui/span/missing-unit-argument.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspan%2Fmissing-unit-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspan%2Fmissing-unit-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmissing-unit-argument.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL |     let _: Result<(), String> = Ok();\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^\n help: provide the argument\n    |\n LL |     let _: Result<(), String> = Ok(());"}, {"sha": "37788612f4371dd6ce95af228211a59799424d6a", "filename": "src/test/ui/specialization/defaultimpl/specialization-trait-not-implemented.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -27,7 +27,7 @@ LL | default impl<T> Foo for T {\n    | ^^^^^^^^^^^^^^^^---^^^^^-\n    | |\n    | unsatisfied trait bound introduced here\n-note: the following trait must be implemented\n+note: the trait `Foo` must be implemented\n   --> $DIR/specialization-trait-not-implemented.rs:7:1\n    |\n LL | trait Foo {"}, {"sha": "2f02a24960e01af20612e1bd026baf58e6df45f9", "filename": "src/test/ui/stability-attribute/stability-in-private-module.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-in-private-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-in-private-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-in-private-module.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL |     let _ = std::thread::thread_info::current_thread();\n    |\n note: the module `thread_info` is defined here\n   --> $SRC_DIR/std/src/thread/mod.rs:LL:COL\n-   |\n-LL | use crate::sys_common::thread_info;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8c5d0b9609627f04d183d7223c52d5bb7006d4b0", "filename": "src/test/ui/std-uncopyable-atomics.stderr", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstd-uncopyable-atomics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstd-uncopyable-atomics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstd-uncopyable-atomics.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,37 +2,49 @@ error[E0507]: cannot move out of a shared reference\n   --> $DIR/std-uncopyable-atomics.rs:9:13\n    |\n LL |     let x = *&x;\n-   |             ^^^\n-   |             |\n-   |             move occurs because value has type `std::sync::atomic::AtomicBool`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*&x`\n+   |             ^^^ move occurs because value has type `std::sync::atomic::AtomicBool`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let x = *&x;\n+LL +     let x = &x;\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/std-uncopyable-atomics.rs:11:13\n    |\n LL |     let x = *&x;\n-   |             ^^^\n-   |             |\n-   |             move occurs because value has type `std::sync::atomic::AtomicIsize`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*&x`\n+   |             ^^^ move occurs because value has type `std::sync::atomic::AtomicIsize`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let x = *&x;\n+LL +     let x = &x;\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/std-uncopyable-atomics.rs:13:13\n    |\n LL |     let x = *&x;\n-   |             ^^^\n-   |             |\n-   |             move occurs because value has type `std::sync::atomic::AtomicUsize`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*&x`\n+   |             ^^^ move occurs because value has type `std::sync::atomic::AtomicUsize`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let x = *&x;\n+LL +     let x = &x;\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/std-uncopyable-atomics.rs:15:13\n    |\n LL |     let x = *&x;\n-   |             ^^^\n-   |             |\n-   |             move occurs because value has type `std::sync::atomic::AtomicPtr<usize>`, which does not implement the `Copy` trait\n-   |             help: consider borrowing here: `&*&x`\n+   |             ^^^ move occurs because value has type `std::sync::atomic::AtomicPtr<usize>`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let x = *&x;\n+LL +     let x = &x;\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "cb1a6fcacfc9b5d24d8d6caae1a5f53e63304074", "filename": "src/test/ui/str/str-idx.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -24,9 +24,6 @@ LL |     let _ = s.get(4);\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n-   |\n-LL |     pub const fn get<I: ~const SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `core::str::<impl str>::get`\n \n error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> $DIR/str-idx.rs:5:29\n@@ -42,9 +39,6 @@ LL |     let _ = s.get_unchecked(4);\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get_unchecked`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n-   |\n-LL |     pub const unsafe fn get_unchecked<I: ~const SliceIndex<str>>(&self, i: I) -> &I::Output {\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `core::str::<impl str>::get_unchecked`\n \n error[E0277]: the type `str` cannot be indexed by `char`\n   --> $DIR/str-idx.rs:6:19"}, {"sha": "ca4b86ba3065b79af5c536f86b0f061e3743cd8e", "filename": "src/test/ui/str/str-mut-idx.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -48,9 +48,6 @@ LL |     s.get_mut(1);\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get_mut`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n-   |\n-LL |     pub const fn get_mut<I: ~const SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `core::str::<impl str>::get_mut`\n \n error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> $DIR/str-mut-idx.rs:11:25\n@@ -66,9 +63,6 @@ LL |     s.get_unchecked_mut(1);\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get_unchecked_mut`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n-   |\n-LL |     pub const unsafe fn get_unchecked_mut<I: ~const SliceIndex<str>>(\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `core::str::<impl str>::get_unchecked_mut`\n \n error[E0277]: the type `str` cannot be indexed by `char`\n   --> $DIR/str-mut-idx.rs:13:7"}, {"sha": "44a39efdf25425015543ec99292f7e9c78ad7ed3", "filename": "src/test/ui/suggestions/args-instead-of-tuple-errors.stderr", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -13,9 +13,6 @@ LL |     let _: Option<(i32, bool)> = Some(1, 2);\n                found type `{integer}`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n help: remove the extra argument\n    |\n LL |     let _: Option<(i32, bool)> = Some(/* (i32, bool) */);\n@@ -52,9 +49,6 @@ LL |     let _: Option<(i8,)> = Some();\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n help: provide the argument\n    |\n LL |     let _: Option<(i8,)> = Some(/* (i8,) */);\n@@ -72,9 +66,6 @@ LL |     let _: Option<(i32,)> = Some(5_usize);\n                found type `usize`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/args-instead-of-tuple-errors.rs:17:34\n@@ -88,9 +79,6 @@ LL |     let _: Option<(i32,)> = Some((5_usize));\n                found type `usize`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "c8499010d6896365bccf42f5689638ca088156e0", "filename": "src/test/ui/suggestions/args-instead-of-tuple.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -6,9 +6,6 @@ LL |     let _: Result<(i32, i8), ()> = Ok(1, 2);\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^\n help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Result<(i32, i8), ()> = Ok((1, 2));\n@@ -22,9 +19,6 @@ LL |     let _: Option<(i32, i8, &'static str)> = Some(1, 2, \"hi\");\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Option<(i32, i8, &'static str)> = Some((1, 2, \"hi\"));\n@@ -38,9 +32,6 @@ LL |     let _: Option<()> = Some();\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n help: provide the argument\n    |\n LL |     let _: Option<()> = Some(());\n@@ -58,9 +49,6 @@ LL |     let _: Option<(i32,)> = Some(3);\n                found type `{integer}`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n help: use a trailing comma to create a tuple with one element\n    |\n LL |     let _: Option<(i32,)> = Some((3,));\n@@ -78,9 +66,6 @@ LL |     let _: Option<(i32,)> = Some((3));\n                found type `{integer}`\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n-   |     ^^^^\n help: use a trailing comma to create a tuple with one element\n    |\n LL |     let _: Option<(i32,)> = Some((3,));"}, {"sha": "e2129b4502abea13774d1917bbf23c3eedbb8bee", "filename": "src/test/ui/suggestions/as-ref-2.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref-2.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -10,11 +10,8 @@ LL |     let _x: Option<Struct> = foo.map(|s| bar(&s));\n LL |     let _y = foo;\n    |              ^^^ value used here after move\n    |\n-note: this function takes ownership of the receiver `self`, which moves `foo`\n+note: `Option::<T>::map` takes ownership of the receiver `self`, which moves `foo`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-LL |     pub const fn map<U, F>(self, f: F) -> Option<U>\n-   |                            ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b871c9b45a56c7c675c5d8ec6476c41298585bc0", "filename": "src/test/ui/suggestions/attribute-typos.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -15,11 +15,9 @@ error: cannot find attribute `tests` in this scope\n    |\n LL | #[tests]\n    |   ^^^^^ help: an attribute macro with a similar name exists: `test`\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |     pub macro test($item:item) {\n-   |     -------------- similarly named attribute macro `test` defined here\n+   = note: similarly named attribute macro `test` defined here\n \n error: cannot find attribute `deprcated` in this scope\n   --> $DIR/attribute-typos.rs:1:3"}, {"sha": "cbdb94877bdb7fbf897d0020c928bc6d718646a8", "filename": "src/test/ui/suggestions/borrow-for-loop-head.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -16,11 +16,8 @@ LL |     for i in &a {\n LL |         for j in a {\n    |                  ^ `a` moved due to this implicit call to `.into_iter()`, in previous iteration of loop\n    |\n-note: this function takes ownership of the receiver `self`, which moves `a`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `a`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider iterating over a slice of the `Vec<i32>`'s content to avoid moving into the `for` loop\n    |\n LL |         for j in &a {"}, {"sha": "cd27947f02fad5cc111ec107e250eaf82c8fb4ce", "filename": "src/test/ui/suggestions/bound-suggestions.stderr", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fbound-suggestions.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -78,9 +78,6 @@ LL |     const SIZE: usize = core::mem::size_of::<Self>();\n    |\n note: required by a bound in `std::mem::size_of`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL | pub const fn size_of<T>() -> usize {\n-   |                      ^ required by this bound in `size_of`\n help: consider further restricting `Self`\n    |\n LL | trait Foo<T>: Sized {\n@@ -94,9 +91,6 @@ LL |     const SIZE: usize = core::mem::size_of::<Self>();\n    |\n note: required by a bound in `std::mem::size_of`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL | pub const fn size_of<T>() -> usize {\n-   |                      ^ required by this bound in `size_of`\n help: consider further restricting `Self`\n    |\n LL | trait Bar: std::fmt::Display + Sized {\n@@ -110,9 +104,6 @@ LL |     const SIZE: usize = core::mem::size_of::<Self>();\n    |\n note: required by a bound in `std::mem::size_of`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL | pub const fn size_of<T>() -> usize {\n-   |                      ^ required by this bound in `size_of`\n help: consider further restricting `Self`\n    |\n LL | trait Baz: Sized where Self: std::fmt::Display {\n@@ -126,9 +117,6 @@ LL |     const SIZE: usize = core::mem::size_of::<Self>();\n    |\n note: required by a bound in `std::mem::size_of`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL | pub const fn size_of<T>() -> usize {\n-   |                      ^ required by this bound in `size_of`\n help: consider further restricting `Self`\n    |\n LL | trait Qux<T>: Sized where Self: std::fmt::Display {\n@@ -142,9 +130,6 @@ LL |     const SIZE: usize = core::mem::size_of::<Self>();\n    |\n note: required by a bound in `std::mem::size_of`\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |\n-LL | pub const fn size_of<T>() -> usize {\n-   |                      ^ required by this bound in `size_of`\n help: consider further restricting `Self`\n    |\n LL | trait Bat<T>: std::fmt::Display + Sized {"}, {"sha": "0a18b770405c1d2629d319478030493fcd6b3f3a", "filename": "src/test/ui/suggestions/derive-clone-for-eq.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fderive-clone-for-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fderive-clone-for-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-clone-for-eq.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -11,9 +11,6 @@ LL | impl<T: Clone, U> PartialEq<U> for Struct<T>\n    |                   ^^^^^^^^^^^^     ^^^^^^^^^\n note: required by a bound in `Eq`\n   --> $SRC_DIR/core/src/cmp.rs:LL:COL\n-   |\n-LL | pub trait Eq: PartialEq<Self> {\n-   |               ^^^^^^^^^^^^^^^ required by this bound in `Eq`\n    = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |"}, {"sha": "14e8a2675dd18dca6b2dc57fc4c4a973d1d2ebee", "filename": "src/test/ui/suggestions/derive-trait-for-method-call.stderr", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fderive-trait-for-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fderive-trait-for-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-trait-for-method-call.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -20,11 +20,8 @@ LL |     let y = x.test();\n            `Enum: Clone`\n            `Enum: Default`\n            `CloneEnum: Default`\n-note: the following trait must be implemented\n+note: the trait `Default` must be implemented\n   --> $SRC_DIR/core/src/default.rs:LL:COL\n-   |\n-LL | pub trait Default: Sized {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n help: consider annotating `Enum` with `#[derive(Clone)]`\n    |\n LL | #[derive(Clone)]\n@@ -69,16 +66,12 @@ LL | struct Foo<X, Y> (X, Y);\n ...\n LL |     let y = x.test();\n    |               ^^^^ method cannot be called on `Foo<Vec<Enum>, Instant>` due to unsatisfied trait bounds\n+  --> $SRC_DIR/std/src/time.rs:LL:COL\n    |\n-  ::: $SRC_DIR/std/src/time.rs:LL:COL\n-   |\n-LL | pub struct Instant(time::Instant);\n-   | ------------------ doesn't satisfy `Instant: Default`\n-   |\n-  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+   = note: doesn't satisfy `Instant: Default`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n-LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n-   | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<Enum>: Clone`\n+   = note: doesn't satisfy `Vec<Enum>: Clone`\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<Enum>: Clone`"}, {"sha": "0cd6267b3b313ebfa8f50125af998bdef20a1d8f", "filename": "src/test/ui/suggestions/do-not-attempt-to-add-suggestions-with-no-changes.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdo-not-attempt-to-add-suggestions-with-no-changes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdo-not-attempt-to-add-suggestions-with-no-changes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdo-not-attempt-to-add-suggestions-with-no-changes.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error[E0573]: expected type, found module `result`\n    |\n LL | impl result {\n    |      ^^^^^^ help: an enum with a similar name exists: `Result`\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-LL | pub enum Result<T, E> {\n-   | --------------------- similarly named enum `Result` defined here\n+   = note: similarly named enum `Result` defined here\n \n error[E0573]: expected type, found variant `Err`\n   --> $DIR/do-not-attempt-to-add-suggestions-with-no-changes.rs:3:25"}, {"sha": "e19d497f21d29f9386a85308ee6c3e027ed5d960", "filename": "src/test/ui/suggestions/dont-suggest-ref/duplicate-suggestions.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -38,113 +38,94 @@ pub fn main() {\n \n     let &(X(_t), X(_u)) = &(x.clone(), x.clone());\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION (X(_t), X(_u))\n+    //~| HELP consider removing the borrow\n     if let &(Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+    //~| HELP consider removing the borrow\n     while let &(Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+    //~| HELP consider removing the borrow\n     match &(e.clone(), e.clone()) {\n         //~^ ERROR cannot move\n         &(Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the borrow\n         &(Either::Two(_t), Either::One(_u)) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION (Either::Two(_t), Either::One(_u))\n+        //~^ HELP consider removing the borrow\n         _ => (),\n     }\n     match &(e.clone(), e.clone()) {\n         //~^ ERROR cannot move\n         &(Either::One(_t), Either::Two(_u))\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the borrow\n         | &(Either::Two(_t), Either::One(_u)) => (),\n         // FIXME: would really like a suggestion here too\n         _ => (),\n     }\n     match &(e.clone(), e.clone()) {\n         //~^ ERROR cannot move\n         &(Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the borrow\n         &(Either::Two(ref _t), Either::One(ref _u)) => (),\n         _ => (),\n     }\n     match &(e.clone(), e.clone()) {\n         //~^ ERROR cannot move\n         &(Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the borrow\n         (Either::Two(_t), Either::One(_u)) => (),\n         _ => (),\n     }\n     fn f5(&(X(_t), X(_u)): &(X, X)) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION (X(_t), X(_u))\n+    //~| HELP consider removing the borrow\n \n     let &mut (X(_t), X(_u)) = &mut (xm.clone(), xm.clone());\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION (X(_t), X(_u))\n+    //~| HELP consider removing the mutable borrow\n     if let &mut (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+    //~| HELP consider removing the mutable borrow\n     while let &mut (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+    //~| HELP consider removing the mutable borrow\n     match &mut (em.clone(), em.clone()) {\n         //~^ ERROR cannot move\n         &mut (Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the mutable borrow\n         &mut (Either::Two(_t), Either::One(_u)) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION (Either::Two(_t), Either::One(_u))\n+        //~^ HELP consider removing the mutable borrow\n         _ => (),\n     }\n     match &mut (em.clone(), em.clone()) {\n         //~^ ERROR cannot move\n         &mut (Either::One(_t), Either::Two(_u))\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the mutable borrow\n         | &mut (Either::Two(_t), Either::One(_u)) => (),\n         // FIXME: would really like a suggestion here too\n         _ => (),\n     }\n     match &mut (em.clone(), em.clone()) {\n         //~^ ERROR cannot move\n         &mut (Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the mutable borrow\n         &mut (Either::Two(ref _t), Either::One(ref _u)) => (),\n         _ => (),\n     }\n     match &mut (em.clone(), em.clone()) {\n         //~^ ERROR cannot move\n         &mut (Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the mutable borrow\n         &mut (Either::Two(ref mut _t), Either::One(ref mut _u)) => (),\n         _ => (),\n     }\n     match &mut (em.clone(), em.clone()) {\n         //~^ ERROR cannot move\n         &mut (Either::One(_t), Either::Two(_u)) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION (Either::One(_t), Either::Two(_u))\n+        //~^ HELP consider removing the mutable borrow\n         (Either::Two(_t), Either::One(_u)) => (),\n         _ => (),\n     }\n     fn f6(&mut (X(_t), X(_u)): &mut (X, X)) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION (X(_t), X(_u))\n+    //~| HELP consider removing the mutable borrow\n }"}, {"sha": "b96b3713f2a7ab74d37d5763832a0d2198a04462", "filename": "src/test/ui/suggestions/dont-suggest-ref/duplicate-suggestions.stderr", "status": "modified", "additions": 150, "deletions": 103, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,40 +2,52 @@ error[E0507]: cannot move out of a shared reference\n   --> $DIR/duplicate-suggestions.rs:39:27\n    |\n LL |     let &(X(_t), X(_u)) = &(x.clone(), x.clone());\n-   |         ---------------   ^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |   |      |\n-   |         |   |      ...and here\n-   |         |   data moved here\n-   |         help: consider removing the `&`: `(X(_t), X(_u))`\n+   |             --     --     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |             |      |\n+   |             |      ...and here\n+   |             data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the borrow\n+   |\n+LL -     let &(X(_t), X(_u)) = &(x.clone(), x.clone());\n+LL +     let (X(_t), X(_u)) = &(x.clone(), x.clone());\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:43:50\n+  --> $DIR/duplicate-suggestions.rs:42:50\n    |\n LL |     if let &(Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n-   |            -----------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^\n-   |            |             |                |\n-   |            |             |                ...and here\n-   |            |             data moved here\n-   |            help: consider removing the `&`: `(Either::One(_t), Either::Two(_u))`\n+   |                          --               --     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                          |                |\n+   |                          |                ...and here\n+   |                          data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the borrow\n+   |\n+LL -     if let &(Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n+LL +     if let (Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:47:53\n+  --> $DIR/duplicate-suggestions.rs:45:53\n    |\n LL |     while let &(Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n-   |               -----------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^\n-   |               |             |                |\n-   |               |             |                ...and here\n-   |               |             data moved here\n-   |               help: consider removing the `&`: `(Either::One(_t), Either::Two(_u))`\n+   |                             --               --     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             |                |\n+   |                             |                ...and here\n+   |                             data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the borrow\n+   |\n+LL -     while let &(Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n+LL +     while let (Either::One(_t), Either::Two(_u)) = &(e.clone(), e.clone()) { }\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:51:11\n+  --> $DIR/duplicate-suggestions.rs:48:11\n    |\n LL |     match &(e.clone(), e.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -44,22 +56,24 @@ LL |         &(Either::One(_t), Either::Two(_u)) => (),\n    |                       --               -- ...and here\n    |                       |\n    |                       data moved here\n-...\n+LL |\n LL |         &(Either::Two(_t), Either::One(_u)) => (),\n    |                       -- ...and here   -- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n-help: consider removing the `&`\n+help: consider removing the borrow\n    |\n-LL |         (Either::One(_t), Either::Two(_u)) => (),\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-help: consider removing the `&`\n+LL -         &(Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &(Either::Two(_t), Either::One(_u)) => (),\n+LL +         (Either::Two(_t), Either::One(_u)) => (),\n    |\n-LL |         (Either::Two(_t), Either::One(_u)) => (),\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:61:11\n+  --> $DIR/duplicate-suggestions.rs:56:11\n    |\n LL |     match &(e.clone(), e.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -70,82 +84,98 @@ LL |         &(Either::One(_t), Either::Two(_u))\n    |                       data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n-help: consider removing the `&`\n+help: consider removing the borrow\n    |\n-LL ~         (Either::One(_t), Either::Two(_u))\n-LL +\n-LL +\n-LL ~         | &(Either::Two(_t), Either::One(_u)) => (),\n+LL -         &(Either::One(_t), Either::Two(_u))\n+LL +         (Either::One(_t), Either::Two(_u))\n    |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:70:11\n+  --> $DIR/duplicate-suggestions.rs:64:11\n    |\n LL |     match &(e.clone(), e.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &(Either::One(_t), Either::Two(_u)) => (),\n-   |         -----------------------------------\n-   |         |             |                |\n-   |         |             |                ...and here\n-   |         |             data moved here\n-   |         help: consider removing the `&`: `(Either::One(_t), Either::Two(_u))`\n+   |                       --               -- ...and here\n+   |                       |\n+   |                       data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the borrow\n+   |\n+LL -         &(Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:78:11\n+  --> $DIR/duplicate-suggestions.rs:71:11\n    |\n LL |     match &(e.clone(), e.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &(Either::One(_t), Either::Two(_u)) => (),\n-   |         -----------------------------------\n-   |         |             |                |\n-   |         |             |                ...and here\n-   |         |             data moved here\n-   |         help: consider removing the `&`: `(Either::One(_t), Either::Two(_u))`\n+   |                       --               -- ...and here\n+   |                       |\n+   |                       data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the borrow\n+   |\n+LL -         &(Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:91:31\n+  --> $DIR/duplicate-suggestions.rs:82:31\n    |\n LL |     let &mut (X(_t), X(_u)) = &mut (xm.clone(), xm.clone());\n-   |         -------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |       |      |\n-   |         |       |      ...and here\n-   |         |       data moved here\n-   |         help: consider removing the `&mut`: `(X(_t), X(_u))`\n+   |                 --     --     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 |      |\n+   |                 |      ...and here\n+   |                 data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -     let &mut (X(_t), X(_u)) = &mut (xm.clone(), xm.clone());\n+LL +     let (X(_t), X(_u)) = &mut (xm.clone(), xm.clone());\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:95:54\n+  --> $DIR/duplicate-suggestions.rs:85:54\n    |\n LL |     if let &mut (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n-   |            ---------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |            |                 |                |\n-   |            |                 |                ...and here\n-   |            |                 data moved here\n-   |            help: consider removing the `&mut`: `(Either::One(_t), Either::Two(_u))`\n+   |                              --               --     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                              |                |\n+   |                              |                ...and here\n+   |                              data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -     if let &mut (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n+LL +     if let (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:99:57\n+  --> $DIR/duplicate-suggestions.rs:88:57\n    |\n LL |     while let &mut (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n-   |               ---------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |               |                 |                |\n-   |               |                 |                ...and here\n-   |               |                 data moved here\n-   |               help: consider removing the `&mut`: `(Either::One(_t), Either::Two(_u))`\n+   |                                 --               --     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                 |                |\n+   |                                 |                ...and here\n+   |                                 data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -     while let &mut (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n+LL +     while let (Either::One(_t), Either::Two(_u)) = &mut (em.clone(), em.clone()) { }\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:103:11\n+  --> $DIR/duplicate-suggestions.rs:91:11\n    |\n LL |     match &mut (em.clone(), em.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -154,22 +184,24 @@ LL |         &mut (Either::One(_t), Either::Two(_u)) => (),\n    |                           --               -- ...and here\n    |                           |\n    |                           data moved here\n-...\n+LL |\n LL |         &mut (Either::Two(_t), Either::One(_u)) => (),\n    |                           -- ...and here   -- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut (Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n    |\n-LL |         (Either::One(_t), Either::Two(_u)) => (),\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut (Either::Two(_t), Either::One(_u)) => (),\n+LL +         (Either::Two(_t), Either::One(_u)) => (),\n    |\n-LL |         (Either::Two(_t), Either::One(_u)) => (),\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:113:11\n+  --> $DIR/duplicate-suggestions.rs:99:11\n    |\n LL |     match &mut (em.clone(), em.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -180,82 +212,97 @@ LL |         &mut (Either::One(_t), Either::Two(_u))\n    |                           data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n    |\n-LL ~         (Either::One(_t), Either::Two(_u))\n-LL +\n-LL +\n-LL ~         | &mut (Either::Two(_t), Either::One(_u)) => (),\n+LL -         &mut (Either::One(_t), Either::Two(_u))\n+LL +         (Either::One(_t), Either::Two(_u))\n    |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:122:11\n+  --> $DIR/duplicate-suggestions.rs:107:11\n    |\n LL |     match &mut (em.clone(), em.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &mut (Either::One(_t), Either::Two(_u)) => (),\n-   |         ---------------------------------------\n-   |         |                 |                |\n-   |         |                 |                ...and here\n-   |         |                 data moved here\n-   |         help: consider removing the `&mut`: `(Either::One(_t), Either::Two(_u))`\n+   |                           --               -- ...and here\n+   |                           |\n+   |                           data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut (Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:130:11\n+  --> $DIR/duplicate-suggestions.rs:114:11\n    |\n LL |     match &mut (em.clone(), em.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &mut (Either::One(_t), Either::Two(_u)) => (),\n-   |         ---------------------------------------\n-   |         |                 |                |\n-   |         |                 |                ...and here\n-   |         |                 data moved here\n-   |         help: consider removing the `&mut`: `(Either::One(_t), Either::Two(_u))`\n+   |                           --               -- ...and here\n+   |                           |\n+   |                           data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut (Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:138:11\n+  --> $DIR/duplicate-suggestions.rs:121:11\n    |\n LL |     match &mut (em.clone(), em.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &mut (Either::One(_t), Either::Two(_u)) => (),\n-   |         ---------------------------------------\n-   |         |                 |                |\n-   |         |                 |                ...and here\n-   |         |                 data moved here\n-   |         help: consider removing the `&mut`: `(Either::One(_t), Either::Two(_u))`\n+   |                           --               -- ...and here\n+   |                           |\n+   |                           data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut (Either::One(_t), Either::Two(_u)) => (),\n+LL +         (Either::One(_t), Either::Two(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/duplicate-suggestions.rs:86:11\n+  --> $DIR/duplicate-suggestions.rs:78:11\n    |\n LL |     fn f5(&(X(_t), X(_u)): &(X, X)) { }\n    |           ^^^^--^^^^^--^^\n-   |           |   |      |\n-   |           |   |      ...and here\n-   |           |   data moved here\n-   |           help: consider removing the `&`: `(X(_t), X(_u))`\n+   |               |      |\n+   |               |      ...and here\n+   |               data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the borrow\n+   |\n+LL -     fn f5(&(X(_t), X(_u)): &(X, X)) { }\n+LL +     fn f5((X(_t), X(_u)): &(X, X)) { }\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/duplicate-suggestions.rs:146:11\n+  --> $DIR/duplicate-suggestions.rs:128:11\n    |\n LL |     fn f6(&mut (X(_t), X(_u)): &mut (X, X)) { }\n    |           ^^^^^^^^--^^^^^--^^\n-   |           |       |      |\n-   |           |       |      ...and here\n-   |           |       data moved here\n-   |           help: consider removing the `&mut`: `(X(_t), X(_u))`\n+   |                   |      |\n+   |                   |      ...and here\n+   |                   data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the mutable borrow\n+   |\n+LL -     fn f6(&mut (X(_t), X(_u)): &mut (X, X)) { }\n+LL +     fn f6((X(_t), X(_u)): &mut (X, X)) { }\n+   |\n \n error: aborting due to 17 previous errors\n "}, {"sha": "44eac3691a3beb89ab81bb4b7f882dc35bd55dd5", "filename": "src/test/ui/suggestions/dont-suggest-ref/move-into-closure.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fmove-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fmove-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fmove-into-closure.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -28,26 +28,21 @@ fn move_into_fn() {\n         let X(_t) = x;\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &x\n         if let Either::One(_t) = e { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &e\n         while let Either::One(_t) = e { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &e\n         match e {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &e\n             Either::One(_t)\n             | Either::Two(_t) => (),\n         }\n         match e {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &e\n             Either::One(_t) => (),\n             Either::Two(ref _t) => (),\n             // FIXME: should suggest removing `ref` too\n@@ -56,26 +51,21 @@ fn move_into_fn() {\n         let X(mut _t) = x;\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &x\n         if let Either::One(mut _t) = em { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &em\n         while let Either::One(mut _t) = em { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &em\n         match em {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &em\n             Either::One(mut _t)\n             | Either::Two(mut _t) => (),\n         }\n         match em {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &em\n             Either::One(mut _t) => (),\n             Either::Two(ref _t) => (),\n             // FIXME: should suggest removing `ref` too\n@@ -95,26 +85,21 @@ fn move_into_fnmut() {\n         let X(_t) = x;\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &x\n         if let Either::One(_t) = e { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &e\n         while let Either::One(_t) = e { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &e\n         match e {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &e\n             Either::One(_t)\n             | Either::Two(_t) => (),\n         }\n         match e {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &e\n             Either::One(_t) => (),\n             Either::Two(ref _t) => (),\n             // FIXME: should suggest removing `ref` too\n@@ -123,34 +108,28 @@ fn move_into_fnmut() {\n         let X(mut _t) = x;\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &x\n         if let Either::One(mut _t) = em { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &em\n         while let Either::One(mut _t) = em { }\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &em\n         match em {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &em\n             Either::One(mut _t)\n             | Either::Two(mut _t) => (),\n         }\n         match em {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &em\n             Either::One(mut _t) => (),\n             Either::Two(ref _t) => (),\n             // FIXME: should suggest removing `ref` too\n         }\n         match em {\n             //~^ ERROR cannot move\n             //~| HELP consider borrowing here\n-            //~| SUGGESTION &em\n             Either::One(mut _t) => (),\n             Either::Two(ref mut _t) => (),\n             // FIXME: should suggest removing `ref` too"}, {"sha": "edda2cbc735a25dc541d5ff80cbf0642bb634224", "filename": "src/test/ui/suggestions/dont-suggest-ref/move-into-closure.stderr", "status": "modified", "additions": 146, "deletions": 41, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fmove-into-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fmove-into-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fmove-into-closure.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,13 +7,18 @@ LL |     let x = X(Y);\n LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n LL |         let X(_t) = x;\n-   |               --    ^ help: consider borrowing here: `&x`\n+   |               --    ^\n    |               |\n    |               data moved here\n    |               move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         let X(_t) = &x;\n+   |                     +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:32:34\n+  --> $DIR/move-into-closure.rs:31:34\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -22,13 +27,18 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         if let Either::One(_t) = e { }\n-   |                            --    ^ help: consider borrowing here: `&e`\n+   |                            --    ^\n    |                            |\n    |                            data moved here\n    |                            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         if let Either::One(_t) = &e { }\n+   |                                  +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:36:37\n+  --> $DIR/move-into-closure.rs:34:37\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -37,13 +47,18 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         while let Either::One(_t) = e { }\n-   |                               --    ^ help: consider borrowing here: `&e`\n+   |                               --    ^\n    |                               |\n    |                               data moved here\n    |                               move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         while let Either::One(_t) = &e { }\n+   |                                     +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:40:15\n+  --> $DIR/move-into-closure.rs:37:15\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -52,16 +67,21 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         match e {\n-   |               ^ help: consider borrowing here: `&e`\n+   |               ^\n ...\n LL |             Either::One(_t)\n    |                         --\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &e {\n+   |               +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:47:15\n+  --> $DIR/move-into-closure.rs:43:15\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -70,16 +90,21 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         match e {\n-   |               ^ help: consider borrowing here: `&e`\n+   |               ^\n ...\n LL |             Either::One(_t) => (),\n    |                         --\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &e {\n+   |               +\n \n error[E0507]: cannot move out of `x.0`, as `x` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:56:25\n+  --> $DIR/move-into-closure.rs:51:25\n    |\n LL |     let x = X(Y);\n    |         - captured outer variable\n@@ -88,13 +113,18 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         let X(mut _t) = x;\n-   |               ------    ^ help: consider borrowing here: `&x`\n+   |               ------    ^\n    |               |\n    |               data moved here\n    |               move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         let X(mut _t) = &x;\n+   |                         +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:60:38\n+  --> $DIR/move-into-closure.rs:54:38\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -103,13 +133,18 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         if let Either::One(mut _t) = em { }\n-   |                            ------    ^^ help: consider borrowing here: `&em`\n+   |                            ------    ^^\n    |                            |\n    |                            data moved here\n    |                            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         if let Either::One(mut _t) = &em { }\n+   |                                      +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:64:41\n+  --> $DIR/move-into-closure.rs:57:41\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -118,13 +153,18 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         while let Either::One(mut _t) = em { }\n-   |                               ------    ^^ help: consider borrowing here: `&em`\n+   |                               ------    ^^\n    |                               |\n    |                               data moved here\n    |                               move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         while let Either::One(mut _t) = &em { }\n+   |                                         +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:68:15\n+  --> $DIR/move-into-closure.rs:60:15\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -133,16 +173,21 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         match em {\n-   |               ^^ help: consider borrowing here: `&em`\n+   |               ^^\n ...\n LL |             Either::One(mut _t)\n    |                         ------\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &em {\n+   |               +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `Fn` closure\n-  --> $DIR/move-into-closure.rs:75:15\n+  --> $DIR/move-into-closure.rs:66:15\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -151,30 +196,40 @@ LL |     consume_fn(|| {\n    |                -- captured by this `Fn` closure\n ...\n LL |         match em {\n-   |               ^^ help: consider borrowing here: `&em`\n+   |               ^^\n ...\n LL |             Either::One(mut _t) => (),\n    |                         ------\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &em {\n+   |               +\n \n error[E0507]: cannot move out of `x.0`, as `x` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:95:21\n+  --> $DIR/move-into-closure.rs:85:21\n    |\n LL |     let x = X(Y);\n    |         - captured outer variable\n ...\n LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n LL |         let X(_t) = x;\n-   |               --    ^ help: consider borrowing here: `&x`\n+   |               --    ^\n    |               |\n    |               data moved here\n    |               move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         let X(_t) = &x;\n+   |                     +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:99:34\n+  --> $DIR/move-into-closure.rs:88:34\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -183,13 +238,18 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         if let Either::One(_t) = e { }\n-   |                            --    ^ help: consider borrowing here: `&e`\n+   |                            --    ^\n    |                            |\n    |                            data moved here\n    |                            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         if let Either::One(_t) = &e { }\n+   |                                  +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:103:37\n+  --> $DIR/move-into-closure.rs:91:37\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -198,13 +258,18 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         while let Either::One(_t) = e { }\n-   |                               --    ^ help: consider borrowing here: `&e`\n+   |                               --    ^\n    |                               |\n    |                               data moved here\n    |                               move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         while let Either::One(_t) = &e { }\n+   |                                     +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:107:15\n+  --> $DIR/move-into-closure.rs:94:15\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -213,16 +278,21 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         match e {\n-   |               ^ help: consider borrowing here: `&e`\n+   |               ^\n ...\n LL |             Either::One(_t)\n    |                         --\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &e {\n+   |               +\n \n error[E0507]: cannot move out of `e.0`, as `e` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:114:15\n+  --> $DIR/move-into-closure.rs:100:15\n    |\n LL |     let e = Either::One(X(Y));\n    |         - captured outer variable\n@@ -231,16 +301,21 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         match e {\n-   |               ^ help: consider borrowing here: `&e`\n+   |               ^\n ...\n LL |             Either::One(_t) => (),\n    |                         --\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &e {\n+   |               +\n \n error[E0507]: cannot move out of `x.0`, as `x` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:123:25\n+  --> $DIR/move-into-closure.rs:108:25\n    |\n LL |     let x = X(Y);\n    |         - captured outer variable\n@@ -249,13 +324,18 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         let X(mut _t) = x;\n-   |               ------    ^ help: consider borrowing here: `&x`\n+   |               ------    ^\n    |               |\n    |               data moved here\n    |               move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         let X(mut _t) = &x;\n+   |                         +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:127:38\n+  --> $DIR/move-into-closure.rs:111:38\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -264,13 +344,18 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         if let Either::One(mut _t) = em { }\n-   |                            ------    ^^ help: consider borrowing here: `&em`\n+   |                            ------    ^^\n    |                            |\n    |                            data moved here\n    |                            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         if let Either::One(mut _t) = &em { }\n+   |                                      +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:131:41\n+  --> $DIR/move-into-closure.rs:114:41\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -279,13 +364,18 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         while let Either::One(mut _t) = em { }\n-   |                               ------    ^^ help: consider borrowing here: `&em`\n+   |                               ------    ^^\n    |                               |\n    |                               data moved here\n    |                               move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         while let Either::One(mut _t) = &em { }\n+   |                                         +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:135:15\n+  --> $DIR/move-into-closure.rs:117:15\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -294,16 +384,21 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         match em {\n-   |               ^^ help: consider borrowing here: `&em`\n+   |               ^^\n ...\n LL |             Either::One(mut _t)\n    |                         ------\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &em {\n+   |               +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:142:15\n+  --> $DIR/move-into-closure.rs:123:15\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -312,16 +407,21 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         match em {\n-   |               ^^ help: consider borrowing here: `&em`\n+   |               ^^\n ...\n LL |             Either::One(mut _t) => (),\n    |                         ------\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &em {\n+   |               +\n \n error[E0507]: cannot move out of `em.0`, as `em` is a captured variable in an `FnMut` closure\n-  --> $DIR/move-into-closure.rs:150:15\n+  --> $DIR/move-into-closure.rs:130:15\n    |\n LL |     let mut em = Either::One(X(Y));\n    |         ------ captured outer variable\n@@ -330,13 +430,18 @@ LL |     consume_fnmut(|| {\n    |                   -- captured by this `FnMut` closure\n ...\n LL |         match em {\n-   |               ^^ help: consider borrowing here: `&em`\n+   |               ^^\n ...\n LL |             Either::One(mut _t) => (),\n    |                         ------\n    |                         |\n    |                         data moved here\n    |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |         match &em {\n+   |               +\n \n error: aborting due to 21 previous errors\n "}, {"sha": "1e40e60a1ce12c4785d17e5b7c61ee5dc3fa5b52", "filename": "src/test/ui/suggestions/dont-suggest-ref/simple.rs", "status": "modified", "additions": 63, "deletions": 91, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.rs?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -37,63 +37,52 @@ pub fn main() {\n \n     let X(_t) = *s;\n     //~^ ERROR cannot move\n-    //~| HELP consider borrowing here\n-    //~| SUGGESTION s\n+    //~| HELP consider removing the dereference here\n     if let Either::One(_t) = *r { }\n     //~^ ERROR cannot move\n-    //~| HELP consider borrowing here\n-    //~| SUGGESTION r\n+    //~| HELP consider removing the dereference here\n     while let Either::One(_t) = *r { }\n     //~^ ERROR cannot move\n-    //~| HELP consider borrowing here\n-    //~| SUGGESTION r\n+    //~| HELP consider removing the dereference here\n     match *r {\n         //~^ ERROR cannot move\n-        //~| HELP consider borrowing here\n-        //~| SUGGESTION r\n+        //~| HELP consider removing the dereference here\n         Either::One(_t)\n         | Either::Two(_t) => (),\n     }\n     match *r {\n         //~^ ERROR cannot move\n-        //~| HELP consider borrowing here\n-        //~| SUGGESTION r\n+        //~| HELP consider removing the dereference here\n         Either::One(_t) => (),\n         Either::Two(ref _t) => (),\n         // FIXME: should suggest removing `ref` too\n     }\n \n     let X(_t) = *sm;\n     //~^ ERROR cannot move\n-    //~| HELP consider borrowing here\n-    //~| SUGGESTION sm\n+    //~| HELP consider removing the dereference here\n     if let Either::One(_t) = *rm { }\n     //~^ ERROR cannot move\n-    //~| HELP consider borrowing here\n-    //~| SUGGESTION rm\n+    //~| HELP consider removing the dereference here\n     while let Either::One(_t) = *rm { }\n     //~^ ERROR cannot move\n-    //~| HELP consider borrowing here\n-    //~| SUGGESTION rm\n+    //~| HELP consider removing the dereference here\n     match *rm {\n         //~^ ERROR cannot move\n-        //~| HELP consider borrowing here\n-        //~| SUGGESTION rm\n+        //~| HELP consider removing the dereference here\n         Either::One(_t)\n         | Either::Two(_t) => (),\n     }\n     match *rm {\n         //~^ ERROR cannot move\n-        //~| HELP consider borrowing here\n-        //~| SUGGESTION rm\n+        //~| HELP consider removing the dereference here\n         Either::One(_t) => (),\n         Either::Two(ref _t) => (),\n         // FIXME: should suggest removing `ref` too\n     }\n     match *rm {\n         //~^ ERROR cannot move\n-        //~| HELP consider borrowing here\n-        //~| SUGGESTION rm\n+        //~| HELP consider removing the dereference here\n         Either::One(_t) => (),\n         Either::Two(ref mut _t) => (),\n         // FIXME: should suggest removing `ref` too\n@@ -102,26 +91,21 @@ pub fn main() {\n     let X(_t) = vs[0];\n     //~^ ERROR cannot move\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &vs[0]\n     if let Either::One(_t) = vr[0] { }\n     //~^ ERROR cannot move\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &vr[0]\n     while let Either::One(_t) = vr[0] { }\n     //~^ ERROR cannot move\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &vr[0]\n     match vr[0] {\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &vr[0]\n         Either::One(_t)\n         | Either::Two(_t) => (),\n     }\n     match vr[0] {\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &vr[0]\n         Either::One(_t) => (),\n         Either::Two(ref _t) => (),\n         // FIXME: should suggest removing `ref` too\n@@ -130,34 +114,28 @@ pub fn main() {\n     let X(_t) = vsm[0];\n     //~^ ERROR cannot move\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &vsm[0]\n     if let Either::One(_t) = vrm[0] { }\n     //~^ ERROR cannot move\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &vrm[0]\n     while let Either::One(_t) = vrm[0] { }\n     //~^ ERROR cannot move\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &vrm[0]\n     match vrm[0] {\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &vrm[0]\n         Either::One(_t)\n         | Either::Two(_t) => (),\n     }\n     match vrm[0] {\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &vrm[0]\n         Either::One(_t) => (),\n         Either::Two(ref _t) => (),\n         // FIXME: should suggest removing `ref` too\n     }\n     match vrm[0] {\n         //~^ ERROR cannot move\n         //~| HELP consider borrowing here\n-        //~| SUGGESTION &vrm[0]\n         Either::One(_t) => (),\n         Either::Two(ref mut _t) => (),\n         // FIXME: should suggest removing `ref` too\n@@ -167,198 +145,192 @@ pub fn main() {\n \n     let &X(_t) = s;\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION X(_t)\n+    //~| HELP consider removing\n     if let &Either::One(_t) = r { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     while let &Either::One(_t) = r { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     match r {\n         //~^ ERROR cannot move\n         &Either::One(_t)\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         | &Either::Two(_t) => (),\n         // FIXME: would really like a suggestion here too\n     }\n     match r {\n         //~^ ERROR cannot move\n         &Either::One(_t) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &Either::Two(ref _t) => (),\n     }\n     match r {\n         //~^ ERROR cannot move\n         &Either::One(_t) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         Either::Two(_t) => (),\n     }\n     fn f1(&X(_t): &X) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION X(_t)\n+    //~| HELP consider removing\n \n     let &mut X(_t) = sm;\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION X(_t)\n+    //~| HELP consider removing\n     if let &mut Either::One(_t) = rm { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     while let &mut Either::One(_t) = rm { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     match rm {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &mut Either::Two(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::Two(_t)\n+        //~^ HELP consider removing\n     }\n     match rm {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &mut Either::Two(ref _t) => (),\n     }\n     match rm {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &mut Either::Two(ref mut _t) => (),\n     }\n     match rm {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         Either::Two(_t) => (),\n     }\n     fn f2(&mut X(_t): &mut X) { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION X(_t)\n+    //~| HELP consider removing\n \n     // move from tuple of &Either/&X\n \n     // FIXME: These should have suggestions.\n \n     let (&X(_t),) = (&x.clone(),);\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n     if let (&Either::One(_t),) = (&e.clone(),) { }\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n     while let (&Either::One(_t),) = (&e.clone(),) { }\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n     match (&e.clone(),) {\n         //~^ ERROR cannot move\n         (&Either::One(_t),)\n+        //~^ HELP consider borrowing the pattern binding\n         | (&Either::Two(_t),) => (),\n     }\n     fn f3((&X(_t),): (&X,)) { }\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n \n     let (&mut X(_t),) = (&mut xm.clone(),);\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n     if let (&mut Either::One(_t),) = (&mut em.clone(),) { }\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n     while let (&mut Either::One(_t),) = (&mut em.clone(),) { }\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n     match (&mut em.clone(),) {\n         //~^ ERROR cannot move\n         (&mut Either::One(_t),) => (),\n+        //~^ HELP consider borrowing the pattern binding\n         (&mut Either::Two(_t),) => (),\n+        //~^ HELP consider borrowing the pattern binding\n     }\n     fn f4((&mut X(_t),): (&mut X,)) { }\n     //~^ ERROR cannot move\n+    //~| HELP consider borrowing the pattern binding\n \n     // move from &Either/&X value\n \n     let &X(_t) = &x;\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION X(_t)\n+    //~| HELP consider removing\n     if let &Either::One(_t) = &e { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     while let &Either::One(_t) = &e { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     match &e {\n         //~^ ERROR cannot move\n         &Either::One(_t)\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         | &Either::Two(_t) => (),\n         // FIXME: would really like a suggestion here too\n     }\n     match &e {\n         //~^ ERROR cannot move\n         &Either::One(_t) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &Either::Two(ref _t) => (),\n     }\n     match &e {\n         //~^ ERROR cannot move\n         &Either::One(_t) => (),\n-        //~^ HELP consider removing the `&`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         Either::Two(_t) => (),\n     }\n \n     let &mut X(_t) = &mut xm;\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION X(_t)\n+    //~| HELP consider removing\n     if let &mut Either::One(_t) = &mut em { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     while let &mut Either::One(_t) = &mut em { }\n     //~^ ERROR cannot move\n-    //~| HELP consider removing the `&mut`\n-    //~| SUGGESTION Either::One(_t)\n+    //~| HELP consider removing\n     match &mut em {\n         //~^ ERROR cannot move\n         &mut Either::One(_t)\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         | &mut Either::Two(_t) => (),\n         // FIXME: would really like a suggestion here too\n     }\n     match &mut em {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &mut Either::Two(ref _t) => (),\n     }\n     match &mut em {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         &mut Either::Two(ref mut _t) => (),\n     }\n     match &mut em {\n         //~^ ERROR cannot move\n         &mut Either::One(_t) => (),\n-        //~^ HELP consider removing the `&mut`\n-        //~| SUGGESTION Either::One(_t)\n+        //~^ HELP consider removing\n         Either::Two(_t) => (),\n     }\n }\n+\n+struct Testing {\n+    a: Option<String>\n+}\n+\n+fn testing(a: &Testing) {\n+    let Some(_s) = a.a else {\n+        //~^ ERROR cannot move\n+        //~| HELP consider borrowing the pattern binding\n+        return;\n+    };\n+}"}, {"sha": "5263265242318f13d4a9cfe85abda0446f15424b", "filename": "src/test/ui/suggestions/dont-suggest-ref/simple.stderr", "status": "modified", "additions": 527, "deletions": 222, "changes": 749, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -2,262 +2,398 @@ error[E0507]: cannot move out of `s` which is behind a shared reference\n   --> $DIR/simple.rs:38:17\n    |\n LL |     let X(_t) = *s;\n-   |           --    ^^ help: consider borrowing here: `&*s`\n+   |           --    ^^\n    |           |\n    |           data moved here\n    |           move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let X(_t) = *s;\n+LL +     let X(_t) = s;\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:42:30\n+  --> $DIR/simple.rs:41:30\n    |\n LL |     if let Either::One(_t) = *r { }\n-   |                        --    ^^ help: consider borrowing here: `&*r`\n+   |                        --    ^^\n    |                        |\n    |                        data moved here\n    |                        move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     if let Either::One(_t) = *r { }\n+LL +     if let Either::One(_t) = r { }\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:46:33\n+  --> $DIR/simple.rs:44:33\n    |\n LL |     while let Either::One(_t) = *r { }\n-   |                           --    ^^ help: consider borrowing here: `&*r`\n+   |                           --    ^^\n    |                           |\n    |                           data moved here\n    |                           move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     while let Either::One(_t) = *r { }\n+LL +     while let Either::One(_t) = r { }\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `Two` which is behind a shared reference\n-  --> $DIR/simple.rs:50:11\n+  --> $DIR/simple.rs:47:11\n    |\n LL |     match *r {\n-   |           ^^ help: consider borrowing here: `&*r`\n+   |           ^^\n ...\n LL |         Either::One(_t)\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     match *r {\n+LL +     match r {\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:57:11\n+  --> $DIR/simple.rs:53:11\n    |\n LL |     match *r {\n-   |           ^^ help: consider borrowing here: `&*r`\n+   |           ^^\n ...\n LL |         Either::One(_t) => (),\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     match *r {\n+LL +     match r {\n+   |\n \n error[E0507]: cannot move out of `sm` which is behind a mutable reference\n-  --> $DIR/simple.rs:66:17\n+  --> $DIR/simple.rs:61:17\n    |\n LL |     let X(_t) = *sm;\n-   |           --    ^^^ help: consider borrowing here: `&*sm`\n+   |           --    ^^^\n    |           |\n    |           data moved here\n    |           move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     let X(_t) = *sm;\n+LL +     let X(_t) = sm;\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:70:30\n+  --> $DIR/simple.rs:64:30\n    |\n LL |     if let Either::One(_t) = *rm { }\n-   |                        --    ^^^ help: consider borrowing here: `&*rm`\n+   |                        --    ^^^\n    |                        |\n    |                        data moved here\n    |                        move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     if let Either::One(_t) = *rm { }\n+LL +     if let Either::One(_t) = rm { }\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:74:33\n+  --> $DIR/simple.rs:67:33\n    |\n LL |     while let Either::One(_t) = *rm { }\n-   |                           --    ^^^ help: consider borrowing here: `&*rm`\n+   |                           --    ^^^\n    |                           |\n    |                           data moved here\n    |                           move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     while let Either::One(_t) = *rm { }\n+LL +     while let Either::One(_t) = rm { }\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `Two` which is behind a mutable reference\n-  --> $DIR/simple.rs:78:11\n+  --> $DIR/simple.rs:70:11\n    |\n LL |     match *rm {\n-   |           ^^^ help: consider borrowing here: `&*rm`\n+   |           ^^^\n ...\n LL |         Either::One(_t)\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     match *rm {\n+LL +     match rm {\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:85:11\n+  --> $DIR/simple.rs:76:11\n    |\n LL |     match *rm {\n-   |           ^^^ help: consider borrowing here: `&*rm`\n+   |           ^^^\n ...\n LL |         Either::One(_t) => (),\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     match *rm {\n+LL +     match rm {\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:93:11\n+  --> $DIR/simple.rs:83:11\n    |\n LL |     match *rm {\n-   |           ^^^ help: consider borrowing here: `&*rm`\n+   |           ^^^\n ...\n LL |         Either::One(_t) => (),\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the dereference here\n+   |\n+LL -     match *rm {\n+LL +     match rm {\n+   |\n \n error[E0507]: cannot move out of index of `Vec<X>`\n-  --> $DIR/simple.rs:102:17\n+  --> $DIR/simple.rs:91:17\n    |\n LL |     let X(_t) = vs[0];\n-   |           --    ^^^^^ help: consider borrowing here: `&vs[0]`\n+   |           --    ^^^^^\n    |           |\n    |           data moved here\n    |           move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let X(_t) = &vs[0];\n+   |                 +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:106:30\n+  --> $DIR/simple.rs:94:30\n    |\n LL |     if let Either::One(_t) = vr[0] { }\n-   |                        --    ^^^^^ help: consider borrowing here: `&vr[0]`\n+   |                        --    ^^^^^\n    |                        |\n    |                        data moved here\n    |                        move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     if let Either::One(_t) = &vr[0] { }\n+   |                              +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:110:33\n+  --> $DIR/simple.rs:97:33\n    |\n LL |     while let Either::One(_t) = vr[0] { }\n-   |                           --    ^^^^^ help: consider borrowing here: `&vr[0]`\n+   |                           --    ^^^^^\n    |                           |\n    |                           data moved here\n    |                           move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     while let Either::One(_t) = &vr[0] { }\n+   |                                 +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:114:11\n+  --> $DIR/simple.rs:100:11\n    |\n LL |     match vr[0] {\n-   |           ^^^^^ help: consider borrowing here: `&vr[0]`\n+   |           ^^^^^\n ...\n LL |         Either::One(_t)\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     match &vr[0] {\n+   |           +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:121:11\n+  --> $DIR/simple.rs:106:11\n    |\n LL |     match vr[0] {\n-   |           ^^^^^ help: consider borrowing here: `&vr[0]`\n+   |           ^^^^^\n ...\n LL |         Either::One(_t) => (),\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     match &vr[0] {\n+   |           +\n \n error[E0507]: cannot move out of index of `Vec<X>`\n-  --> $DIR/simple.rs:130:17\n+  --> $DIR/simple.rs:114:17\n    |\n LL |     let X(_t) = vsm[0];\n-   |           --    ^^^^^^ help: consider borrowing here: `&vsm[0]`\n+   |           --    ^^^^^^\n    |           |\n    |           data moved here\n    |           move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let X(_t) = &vsm[0];\n+   |                 +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:134:30\n+  --> $DIR/simple.rs:117:30\n    |\n LL |     if let Either::One(_t) = vrm[0] { }\n-   |                        --    ^^^^^^ help: consider borrowing here: `&vrm[0]`\n+   |                        --    ^^^^^^\n    |                        |\n    |                        data moved here\n    |                        move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     if let Either::One(_t) = &vrm[0] { }\n+   |                              +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:138:33\n+  --> $DIR/simple.rs:120:33\n    |\n LL |     while let Either::One(_t) = vrm[0] { }\n-   |                           --    ^^^^^^ help: consider borrowing here: `&vrm[0]`\n+   |                           --    ^^^^^^\n    |                           |\n    |                           data moved here\n    |                           move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     while let Either::One(_t) = &vrm[0] { }\n+   |                                 +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:142:11\n+  --> $DIR/simple.rs:123:11\n    |\n LL |     match vrm[0] {\n-   |           ^^^^^^ help: consider borrowing here: `&vrm[0]`\n+   |           ^^^^^^\n ...\n LL |         Either::One(_t)\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     match &vrm[0] {\n+   |           +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:149:11\n+  --> $DIR/simple.rs:129:11\n    |\n LL |     match vrm[0] {\n-   |           ^^^^^^ help: consider borrowing here: `&vrm[0]`\n+   |           ^^^^^^\n ...\n LL |         Either::One(_t) => (),\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     match &vrm[0] {\n+   |           +\n \n error[E0507]: cannot move out of index of `Vec<Either>`\n-  --> $DIR/simple.rs:157:11\n+  --> $DIR/simple.rs:136:11\n    |\n LL |     match vrm[0] {\n-   |           ^^^^^^ help: consider borrowing here: `&vrm[0]`\n+   |           ^^^^^^\n ...\n LL |         Either::One(_t) => (),\n    |                     --\n    |                     |\n    |                     data moved here\n    |                     move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing here\n+   |\n+LL |     match &vrm[0] {\n+   |           +\n \n error[E0507]: cannot move out of `s` which is behind a shared reference\n-  --> $DIR/simple.rs:168:18\n+  --> $DIR/simple.rs:146:18\n    |\n LL |     let &X(_t) = s;\n-   |         ------   ^\n-   |         |  |\n-   |         |  data moved here\n-   |         |  move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `X(_t)`\n+   |            --    ^\n+   |            |\n+   |            data moved here\n+   |            move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     let &X(_t) = s;\n+LL +     let X(_t) = s;\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:172:31\n+  --> $DIR/simple.rs:149:31\n    |\n LL |     if let &Either::One(_t) = r { }\n-   |            ----------------   ^\n-   |            |            |\n-   |            |            data moved here\n-   |            |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |            help: consider removing the `&`: `Either::One(_t)`\n+   |                         --    ^\n+   |                         |\n+   |                         data moved here\n+   |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     if let &Either::One(_t) = r { }\n+LL +     if let Either::One(_t) = r { }\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:176:34\n+  --> $DIR/simple.rs:152:34\n    |\n LL |     while let &Either::One(_t) = r { }\n-   |               ----------------   ^\n-   |               |            |\n-   |               |            data moved here\n-   |               |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |               help: consider removing the `&`: `Either::One(_t)`\n+   |                            --    ^\n+   |                            |\n+   |                            data moved here\n+   |                            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     while let &Either::One(_t) = r { }\n+LL +     while let Either::One(_t) = r { }\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `Two` which is behind a shared reference\n-  --> $DIR/simple.rs:180:11\n+  --> $DIR/simple.rs:155:11\n    |\n LL |     match r {\n    |           ^\n@@ -268,160 +404,215 @@ LL |         &Either::One(_t)\n    |                      data moved here\n    |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |\n-help: consider removing the `&`\n+help: consider removing the borrow\n    |\n-LL ~         Either::One(_t)\n-LL +\n-LL +\n-LL ~         | &Either::Two(_t) => (),\n+LL -         &Either::One(_t)\n+LL +         Either::One(_t)\n    |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:188:11\n+  --> $DIR/simple.rs:162:11\n    |\n LL |     match r {\n    |           ^\n LL |\n LL |         &Either::One(_t) => (),\n-   |         ----------------\n-   |         |            |\n-   |         |            data moved here\n-   |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Either::One(_t)`\n+   |                      --\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of `r` as enum variant `One` which is behind a shared reference\n-  --> $DIR/simple.rs:195:11\n+  --> $DIR/simple.rs:168:11\n    |\n LL |     match r {\n    |           ^\n LL |\n LL |         &Either::One(_t) => (),\n-   |         ----------------\n-   |         |            |\n-   |         |            data moved here\n-   |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Either::One(_t)`\n+   |                      --\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of `sm` which is behind a mutable reference\n-  --> $DIR/simple.rs:207:22\n+  --> $DIR/simple.rs:178:22\n    |\n LL |     let &mut X(_t) = sm;\n-   |         ----------   ^^\n-   |         |      |\n-   |         |      data moved here\n-   |         |      move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `X(_t)`\n+   |                --    ^^\n+   |                |\n+   |                data moved here\n+   |                move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     let &mut X(_t) = sm;\n+LL +     let X(_t) = sm;\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:211:35\n+  --> $DIR/simple.rs:181:35\n    |\n LL |     if let &mut Either::One(_t) = rm { }\n-   |            --------------------   ^^\n-   |            |                |\n-   |            |                data moved here\n-   |            |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |            help: consider removing the `&mut`: `Either::One(_t)`\n+   |                             --    ^^\n+   |                             |\n+   |                             data moved here\n+   |                             move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     if let &mut Either::One(_t) = rm { }\n+LL +     if let Either::One(_t) = rm { }\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:215:38\n+  --> $DIR/simple.rs:184:38\n    |\n LL |     while let &mut Either::One(_t) = rm { }\n-   |               --------------------   ^^\n-   |               |                |\n-   |               |                data moved here\n-   |               |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |               help: consider removing the `&mut`: `Either::One(_t)`\n+   |                                --    ^^\n+   |                                |\n+   |                                data moved here\n+   |                                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     while let &mut Either::One(_t) = rm { }\n+LL +     while let Either::One(_t) = rm { }\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `Two` which is behind a mutable reference\n-  --> $DIR/simple.rs:219:11\n+  --> $DIR/simple.rs:187:11\n    |\n LL |     match rm {\n    |           ^^\n LL |\n LL |         &mut Either::One(_t) => (),\n    |                          -- data moved here\n-...\n+LL |\n LL |         &mut Either::Two(_t) => (),\n    |                          -- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n    |\n-LL |         Either::One(_t) => (),\n-   |         ~~~~~~~~~~~~~~~\n-help: consider removing the `&mut`\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::Two(_t) => (),\n+LL +         Either::Two(_t) => (),\n    |\n-LL |         Either::Two(_t) => (),\n-   |         ~~~~~~~~~~~~~~~\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:228:11\n+  --> $DIR/simple.rs:194:11\n    |\n LL |     match rm {\n    |           ^^\n LL |\n LL |         &mut Either::One(_t) => (),\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:235:11\n+  --> $DIR/simple.rs:200:11\n    |\n LL |     match rm {\n    |           ^^\n LL |\n LL |         &mut Either::One(_t) => (),\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of `rm` as enum variant `One` which is behind a mutable reference\n-  --> $DIR/simple.rs:242:11\n+  --> $DIR/simple.rs:206:11\n    |\n LL |     match rm {\n    |           ^^\n LL |\n LL |         &mut Either::One(_t) => (),\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:258:21\n+  --> $DIR/simple.rs:220:21\n    |\n LL |     let (&X(_t),) = (&x.clone(),);\n    |             --      ^^^^^^^^^^^^^\n    |             |\n    |             data moved here\n    |             move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let (&X(ref _t),) = (&x.clone(),);\n+   |             +++\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:260:34\n+  --> $DIR/simple.rs:223:34\n    |\n LL |     if let (&Either::One(_t),) = (&e.clone(),) { }\n    |                          --      ^^^^^^^^^^^^^\n    |                          |\n    |                          data moved here\n    |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     if let (&Either::One(ref _t),) = (&e.clone(),) { }\n+   |                          +++\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:262:37\n+  --> $DIR/simple.rs:226:37\n    |\n LL |     while let (&Either::One(_t),) = (&e.clone(),) { }\n    |                             --      ^^^^^^^^^^^^^\n    |                             |\n    |                             data moved here\n    |                             move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     while let (&Either::One(ref _t),) = (&e.clone(),) { }\n+   |                             +++\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:264:11\n+  --> $DIR/simple.rs:229:11\n    |\n LL |     match (&e.clone(),) {\n    |           ^^^^^^^^^^^^^\n@@ -431,79 +622,123 @@ LL |         (&Either::One(_t),)\n    |                       |\n    |                       data moved here\n    |                       move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&Either::One(ref _t),)\n+   |                       +++\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:272:25\n+  --> $DIR/simple.rs:239:25\n    |\n LL |     let (&mut X(_t),) = (&mut xm.clone(),);\n    |                 --      ^^^^^^^^^^^^^^^^^^\n    |                 |\n    |                 data moved here\n    |                 move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let (&mut X(ref _t),) = (&mut xm.clone(),);\n+   |                 +++\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:274:38\n+  --> $DIR/simple.rs:242:38\n    |\n LL |     if let (&mut Either::One(_t),) = (&mut em.clone(),) { }\n    |                              --      ^^^^^^^^^^^^^^^^^^\n    |                              |\n    |                              data moved here\n    |                              move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     if let (&mut Either::One(ref _t),) = (&mut em.clone(),) { }\n+   |                              +++\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:276:41\n+  --> $DIR/simple.rs:245:41\n    |\n LL |     while let (&mut Either::One(_t),) = (&mut em.clone(),) { }\n    |                                 --      ^^^^^^^^^^^^^^^^^^\n    |                                 |\n    |                                 data moved here\n    |                                 move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     while let (&mut Either::One(ref _t),) = (&mut em.clone(),) { }\n+   |                                 +++\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:278:11\n+  --> $DIR/simple.rs:248:11\n    |\n LL |     match (&mut em.clone(),) {\n    |           ^^^^^^^^^^^^^^^^^^\n LL |\n LL |         (&mut Either::One(_t),) => (),\n    |                           -- data moved here\n+LL |\n LL |         (&mut Either::Two(_t),) => (),\n    |                           -- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&mut Either::One(ref _t),) => (),\n+   |                           +++\n+help: consider borrowing the pattern binding\n+   |\n+LL |         (&mut Either::Two(ref _t),) => (),\n+   |                           +++\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:288:18\n+  --> $DIR/simple.rs:261:18\n    |\n LL |     let &X(_t) = &x;\n-   |         ------   ^^\n-   |         |  |\n-   |         |  data moved here\n-   |         |  move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `X(_t)`\n+   |            --    ^^\n+   |            |\n+   |            data moved here\n+   |            move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     let &X(_t) = &x;\n+LL +     let X(_t) = &x;\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:292:31\n+  --> $DIR/simple.rs:264:31\n    |\n LL |     if let &Either::One(_t) = &e { }\n-   |            ----------------   ^^\n-   |            |            |\n-   |            |            data moved here\n-   |            |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |            help: consider removing the `&`: `Either::One(_t)`\n+   |                         --    ^^\n+   |                         |\n+   |                         data moved here\n+   |                         move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     if let &Either::One(_t) = &e { }\n+LL +     if let Either::One(_t) = &e { }\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:296:34\n+  --> $DIR/simple.rs:267:34\n    |\n LL |     while let &Either::One(_t) = &e { }\n-   |               ----------------   ^^\n-   |               |            |\n-   |               |            data moved here\n-   |               |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |               help: consider removing the `&`: `Either::One(_t)`\n+   |                            --    ^^\n+   |                            |\n+   |                            data moved here\n+   |                            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     while let &Either::One(_t) = &e { }\n+LL +     while let Either::One(_t) = &e { }\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:300:11\n+  --> $DIR/simple.rs:270:11\n    |\n LL |     match &e {\n    |           ^^\n@@ -514,72 +749,95 @@ LL |         &Either::One(_t)\n    |                      data moved here\n    |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |\n-help: consider removing the `&`\n+help: consider removing the borrow\n    |\n-LL ~         Either::One(_t)\n-LL +\n-LL +\n-LL ~         | &Either::Two(_t) => (),\n+LL -         &Either::One(_t)\n+LL +         Either::One(_t)\n    |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:308:11\n+  --> $DIR/simple.rs:277:11\n    |\n LL |     match &e {\n    |           ^^\n LL |\n LL |         &Either::One(_t) => (),\n-   |         ----------------\n-   |         |            |\n-   |         |            data moved here\n-   |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Either::One(_t)`\n+   |                      --\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:315:11\n+  --> $DIR/simple.rs:283:11\n    |\n LL |     match &e {\n    |           ^^\n LL |\n LL |         &Either::One(_t) => (),\n-   |         ----------------\n-   |         |            |\n-   |         |            data moved here\n-   |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Either::One(_t)`\n+   |                      --\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -         &Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:323:22\n+  --> $DIR/simple.rs:290:22\n    |\n LL |     let &mut X(_t) = &mut xm;\n-   |         ----------   ^^^^^^^\n-   |         |      |\n-   |         |      data moved here\n-   |         |      move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `X(_t)`\n+   |                --    ^^^^^^^\n+   |                |\n+   |                data moved here\n+   |                move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     let &mut X(_t) = &mut xm;\n+LL +     let X(_t) = &mut xm;\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:327:35\n+  --> $DIR/simple.rs:293:35\n    |\n LL |     if let &mut Either::One(_t) = &mut em { }\n-   |            --------------------   ^^^^^^^\n-   |            |                |\n-   |            |                data moved here\n-   |            |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |            help: consider removing the `&mut`: `Either::One(_t)`\n+   |                             --    ^^^^^^^\n+   |                             |\n+   |                             data moved here\n+   |                             move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     if let &mut Either::One(_t) = &mut em { }\n+LL +     if let Either::One(_t) = &mut em { }\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:331:38\n+  --> $DIR/simple.rs:296:38\n    |\n LL |     while let &mut Either::One(_t) = &mut em { }\n-   |               --------------------   ^^^^^^^\n-   |               |                |\n-   |               |                data moved here\n-   |               |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |               help: consider removing the `&mut`: `Either::One(_t)`\n+   |                                --    ^^^^^^^\n+   |                                |\n+   |                                data moved here\n+   |                                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     while let &mut Either::One(_t) = &mut em { }\n+LL +     while let Either::One(_t) = &mut em { }\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:335:11\n+  --> $DIR/simple.rs:299:11\n    |\n LL |     match &mut em {\n    |           ^^^^^^^\n@@ -590,91 +848,138 @@ LL |         &mut Either::One(_t)\n    |                          data moved here\n    |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n    |\n-help: consider removing the `&mut`\n+help: consider removing the mutable borrow\n    |\n-LL ~         Either::One(_t)\n-LL +\n-LL +\n-LL ~         | &mut Either::Two(_t) => (),\n+LL -         &mut Either::One(_t)\n+LL +         Either::One(_t)\n    |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:343:11\n+  --> $DIR/simple.rs:306:11\n    |\n LL |     match &mut em {\n    |           ^^^^^^^\n LL |\n LL |         &mut Either::One(_t) => (),\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:350:11\n+  --> $DIR/simple.rs:312:11\n    |\n LL |     match &mut em {\n    |           ^^^^^^^\n LL |\n LL |         &mut Either::One(_t) => (),\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:357:11\n+  --> $DIR/simple.rs:318:11\n    |\n LL |     match &mut em {\n    |           ^^^^^^^\n LL |\n LL |         &mut Either::One(_t) => (),\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -         &mut Either::One(_t) => (),\n+LL +         Either::One(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:202:11\n+  --> $DIR/simple.rs:174:11\n    |\n LL |     fn f1(&X(_t): &X) { }\n    |           ^^^--^\n-   |           |  |\n-   |           |  data moved here\n-   |           |  move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n-   |           help: consider removing the `&`: `X(_t)`\n+   |              |\n+   |              data moved here\n+   |              move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     fn f1(&X(_t): &X) { }\n+LL +     fn f1(X(_t): &X) { }\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:249:11\n+  --> $DIR/simple.rs:212:11\n    |\n LL |     fn f2(&mut X(_t): &mut X) { }\n    |           ^^^^^^^--^\n-   |           |      |\n-   |           |      data moved here\n-   |           |      move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n-   |           help: consider removing the `&mut`: `X(_t)`\n+   |                  |\n+   |                  data moved here\n+   |                  move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the mutable borrow\n+   |\n+LL -     fn f2(&mut X(_t): &mut X) { }\n+LL +     fn f2(X(_t): &mut X) { }\n+   |\n \n error[E0507]: cannot move out of a shared reference\n-  --> $DIR/simple.rs:269:11\n+  --> $DIR/simple.rs:235:11\n    |\n LL |     fn f3((&X(_t),): (&X,)) { }\n    |           ^^^^--^^^\n    |               |\n    |               data moved here\n    |               move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     fn f3((&X(ref _t),): (&X,)) { }\n+   |               +++\n \n error[E0507]: cannot move out of a mutable reference\n-  --> $DIR/simple.rs:283:11\n+  --> $DIR/simple.rs:255:11\n    |\n LL |     fn f4((&mut X(_t),): (&mut X,)) { }\n    |           ^^^^^^^^--^^^\n    |                   |\n    |                   data moved here\n    |                   move occurs because `_t` has type `Y`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     fn f4((&mut X(ref _t),): (&mut X,)) { }\n+   |                   +++\n+\n+error[E0507]: cannot move out of `a.a` as enum variant `Some` which is behind a shared reference\n+  --> $DIR/simple.rs:331:20\n+   |\n+LL |     let Some(_s) = a.a else {\n+   |              --    ^^^\n+   |              |\n+   |              data moved here\n+   |              move occurs because `_s` has type `String`, which does not implement the `Copy` trait\n+   |\n+help: consider borrowing the pattern binding\n+   |\n+LL |     let Some(ref _s) = a.a else {\n+   |              +++\n \n-error: aborting due to 60 previous errors\n+error: aborting due to 61 previous errors\n \n For more information about this error, try `rustc --explain E0507`."}, {"sha": "b1e04dab8f623853794cc53cc468b1fdaf3a876d", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -41,9 +41,6 @@ LL |     Pin::new(x)\n            found type parameter `F`\n note: associated function defined here\n   --> $SRC_DIR/core/src/pin.rs:LL:COL\n-   |\n-LL |     pub const fn new(pointer: P) -> Pin<P> {\n-   |                  ^^^\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n   --> $DIR/expected-boxed-future-isnt-pinned.rs:19:14\n@@ -56,9 +53,6 @@ LL |     Pin::new(x)\n    = note: consider using `Box::pin`\n note: required by a bound in `Pin::<P>::new`\n   --> $SRC_DIR/core/src/pin.rs:LL:COL\n-   |\n-LL | impl<P: Deref<Target: Unpin>> Pin<P> {\n-   |                       ^^^^^ required by this bound in `Pin::<P>::new`\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n   --> $DIR/expected-boxed-future-isnt-pinned.rs:24:14\n@@ -71,9 +65,6 @@ LL |     Pin::new(Box::new(x))\n    = note: consider using `Box::pin`\n note: required by a bound in `Pin::<P>::new`\n   --> $SRC_DIR/core/src/pin.rs:LL:COL\n-   |\n-LL | impl<P: Deref<Target: Unpin>> Pin<P> {\n-   |                       ^^^^^ required by this bound in `Pin::<P>::new`\n \n error[E0308]: mismatched types\n   --> $DIR/expected-boxed-future-isnt-pinned.rs:28:5\n@@ -90,9 +81,6 @@ LL | |     }\n            found `async` block `[async block@$DIR/expected-boxed-future-isnt-pinned.rs:28:5: 30:6]`\n note: function defined here\n   --> $SRC_DIR/core/src/future/mod.rs:LL:COL\n-   |\n-LL | pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n-   |              ^^^^^^^^^^^^^^^\n help: you need to pin and box this expression\n    |\n LL ~     Box::pin(async {"}, {"sha": "c5b81e6b87174d209ce65331def3447c7f8df707", "filename": "src/test/ui/suggestions/for-i-in-vec.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Ffor-i-in-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Ffor-i-in-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffor-i-in-vec.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -7,11 +7,8 @@ LL |         for _ in self.v {\n    |                  `self.v` moved due to this implicit call to `.into_iter()`\n    |                  move occurs because `self.v` has type `Vec<u32>`, which does not implement the `Copy` trait\n    |\n-note: this function takes ownership of the receiver `self`, which moves `self.v`\n+note: `into_iter` takes ownership of the receiver `self`, which moves `self.v`\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider iterating over a slice of the `Vec<u32>`'s content to avoid moving into the `for` loop\n    |\n LL |         for _ in &self.v {\n@@ -40,11 +37,8 @@ LL |     for loader in *LOADERS {\n    |                   value moved due to this implicit call to `.into_iter()`\n    |                   move occurs because value has type `Vec<&u8>`, which does not implement the `Copy` trait\n    |\n-note: this function takes ownership of the receiver `self`, which moves value\n+note: `into_iter` takes ownership of the receiver `self`, which moves value\n   --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n-   |\n-LL |     fn into_iter(self) -> Self::IntoIter;\n-   |                  ^^^^\n help: consider iterating over a slice of the `Vec<&u8>`'s content to avoid moving into the `for` loop\n    |\n LL |     for loader in &*LOADERS {"}, {"sha": "7791b308d5d0e597a4263c6afb85570b07f1158a", "filename": "src/test/ui/suggestions/imm-ref-trait-object.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21ee03e0621c70b894e1bfdd8c82ba5aeaabc812/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr?ref=21ee03e0621c70b894e1bfdd8c82ba5aeaabc812", "patch": "@@ -3,11 +3,9 @@ error: the `min` method cannot be invoked on a trait object\n    |\n LL |      t.min().unwrap()\n    |        ^^^\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n-   |\n-LL |         Self: Sized,\n-   |               ----- this has a `Sized` requirement\n+   = note: this has a `Sized` requirement\n    |\n    = note: you need `&mut dyn Iterator<Item = &u64>` instead of `&dyn Iterator<Item = &u64>`\n "}]}