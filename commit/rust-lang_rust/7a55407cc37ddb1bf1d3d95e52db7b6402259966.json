{"sha": "7a55407cc37ddb1bf1d3d95e52db7b6402259966", "node_id": "C_kwDOAAsO6NoAKDdhNTU0MDdjYzM3ZGRiMWJmMWQzZDk1ZTUyZGI3YjY0MDIyNTk5NjY", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-09-21T12:54:19Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-20T08:40:11Z"}, "message": "Fix suggestions when call functions involved taking by ref", "tree": {"sha": "9d7d97cee987fa2948b1ee51622d155ea2d3ca14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d7d97cee987fa2948b1ee51622d155ea2d3ca14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a55407cc37ddb1bf1d3d95e52db7b6402259966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a55407cc37ddb1bf1d3d95e52db7b6402259966", "html_url": "https://github.com/rust-lang/rust/commit/7a55407cc37ddb1bf1d3d95e52db7b6402259966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a55407cc37ddb1bf1d3d95e52db7b6402259966/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d1ccbf46682b99f0301488bfffff403e824b4d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d1ccbf46682b99f0301488bfffff403e824b4d7", "html_url": "https://github.com/rust-lang/rust/commit/6d1ccbf46682b99f0301488bfffff403e824b4d7"}], "stats": {"total": 382, "additions": 325, "deletions": 57}, "files": [{"sha": "25a2c48e26991cf19a58f5ad5c85ac50717ae861", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 56, "deletions": 37, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -1,3 +1,5 @@\n+use std::iter;\n+\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -223,6 +225,26 @@ impl DerefDelegate<'_, 'tcx> {\n         let end_snip = snippet_with_applicability(self.cx, end_span, \"..\", &mut self.applicability);\n         format!(\"{}{}\", self.suggestion_start, end_snip)\n     }\n+\n+    fn func_takes_arg_by_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n+        if_chain! {\n+            if let ExprKind::Call(func, call_args) = parent_expr.kind;\n+            let typ = self.cx.typeck_results().expr_ty(func);\n+            if let ty::FnDef(..) = typ.kind();\n+\n+            then {\n+                let mut takes_by_ref = false;\n+                for (arg, ty) in iter::zip(call_args, typ.fn_sig(self.cx.tcx).skip_binder().inputs()) {\n+                    if arg.hir_id == cmt_hir_id {\n+                        takes_by_ref = matches!(ty.kind(), ty::Ref(_, inner, _) if inner.is_ref());\n+                    }\n+                }\n+                takes_by_ref\n+            } else {\n+                false\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n@@ -252,42 +274,32 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                             let start_span = Span::new(self.next_pos, span.lo(), span.ctxt());\n                             let start_snip =\n                                 snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+\n+                            // suggest ampersand if call function is taking args by ref\n+                            let takes_arg_by_ref = self.func_takes_arg_by_ref(parent_expr, cmt.hir_id);\n+\n                             // do not suggest ampersand if the ident is the method caller\n-                            let ident_sugg = if !call_args.is_empty() && call_args[0].hir_id == cmt.hir_id {\n-                                format!(\"{}{}\", start_snip, ident_str)\n-                            } else {\n-                                format!(\"{}&{}\", start_snip, ident_str)\n-                            };\n+                            let ident_sugg =\n+                                if !call_args.is_empty() && call_args[0].hir_id == cmt.hir_id && !takes_arg_by_ref {\n+                                    format!(\"{}{}\", start_snip, ident_str)\n+                                } else {\n+                                    format!(\"{}&{}\", start_snip, ident_str)\n+                                };\n                             self.suggestion_start.push_str(&ident_sugg);\n                             self.next_pos = span.hi();\n                             return;\n-                        } else {\n-                            self.applicability = Applicability::Unspecified;\n                         }\n+\n+                        self.applicability = Applicability::Unspecified;\n                     }\n                 }\n \n                 // handle item projections by removing one explicit deref\n                 // i.e.: suggest `*x` instead of `**x`\n                 let mut replacement_str = ident_str;\n \n-                // handle index projection first\n-                let index_handled = cmt.place.projections.iter().any(|proj| match proj.kind {\n-                    // Index projection like `|x| foo[x]`\n-                    // the index is dropped so we can't get it to build the suggestion,\n-                    // so the span is set-up again to get more code, using `span.hi()` (i.e.: `foo[x]`)\n-                    // instead of `span.lo()` (i.e.: `foo`)\n-                    ProjectionKind::Index => {\n-                        let start_span = Span::new(self.next_pos, span.hi(), span.ctxt());\n-                        start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n-                        replacement_str.clear();\n-                        true\n-                    },\n-                    _ => false,\n-                });\n-\n-                // looking for projections other that need to be handled differently\n-                let other_projections_handled = cmt.place.projections.iter().enumerate().any(|(i, proj)| {\n+                let mut projections_handled = false;\n+                cmt.place.projections.iter().enumerate().for_each(|(i, proj)| {\n                     match proj.kind {\n                         // Field projection like `|v| v.foo`\n                         ProjectionKind::Field(idx, variant) => match cmt.place.ty_before_projection(i).kind() {\n@@ -297,34 +309,41 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                                     replacement_str,\n                                     def.variants[variant].fields[idx as usize].ident.name.as_str()\n                                 );\n-                                true\n+                                projections_handled = true;\n                             },\n                             ty::Tuple(_) => {\n                                 replacement_str = format!(\"{}.{}\", replacement_str, idx);\n-                                true\n+                                projections_handled = true;\n                             },\n-                            _ => false,\n+                            _ => (),\n+                        },\n+                        // Index projection like `|x| foo[x]`\n+                        // the index is dropped so we can't get it to build the suggestion,\n+                        // so the span is set-up again to get more code, using `span.hi()` (i.e.: `foo[x]`)\n+                        // instead of `span.lo()` (i.e.: `foo`)\n+                        ProjectionKind::Index => {\n+                            let start_span = Span::new(self.next_pos, span.hi(), span.ctxt());\n+                            start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+                            replacement_str.clear();\n+                            projections_handled = true;\n                         },\n-                        // handled previously\n-                        ProjectionKind::Index |\n-                            // note: unable to trigger `Subslice` kind in tests\n-                            ProjectionKind::Subslice => false,\n+                        // note: unable to trigger `Subslice` kind in tests\n+                        ProjectionKind::Subslice => (),\n                         ProjectionKind::Deref => {\n                             // explicit deref for arrays should be avoided in the suggestion\n                             // i.e.: `|sub| *sub[1..4].len() == 3` is not expected\n-                            match cmt.place.ty_before_projection(i).kind() {\n+                            if let ty::Ref(_, inner, _) = cmt.place.ty_before_projection(i).kind() {\n                                 // dereferencing an array (i.e.: `|sub| sub[1..4].len() == 3`)\n-                                ty::Ref(_, inner, _) => {\n-                                    matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_array())\n-                                },\n-                                _ => false,\n+                                if matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_array()) {\n+                                    projections_handled = true;\n+                                }\n                             }\n                         },\n                     }\n                 });\n \n                 // handle `ProjectionKind::Deref` if no special case detected\n-                if !index_handled && !other_projections_handled {\n+                if !projections_handled {\n                     let last_deref = cmt\n                         .place\n                         .projections"}, {"sha": "6b8a614bbdaa8ae97814816fd82384fc6c880ae4", "filename": "tests/ui/search_is_some_fixable_none.fixed", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.fixed?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -102,17 +102,63 @@ mod issue7392 {\n         *x == 9\n     }\n \n-    fn simple_fn(x: u32) -> bool {\n+    fn deref_enough(x: u32) -> bool {\n         x == 78\n     }\n \n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n     fn more_projections() {\n         let x = 19;\n         let ppx: &u32 = &x;\n         let _ = ![ppx].iter().any(|ppp_x: &&u32| please(ppp_x));\n         let _ = ![String::from(\"Hey hey\")].iter().any(|s| s.len() == 2);\n \n         let v = vec![3, 2, 1, 0];\n-        let _ = !v.iter().any(|x| simple_fn(*x));\n+        let _ = !v.iter().any(|x| deref_enough(*x));\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = !v.iter().any(|x| arg_no_deref(&x));\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = !vfoo\n+            .iter().any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2);\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = !vfoo.iter().any(|v| v.inner[0].bar == 2);\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = !vfoo.iter().any(|x| (**x)[0] == 9);\n     }\n }"}, {"sha": "acaae650921f8f0fa78d9ef3d381bd4eba6aa79f", "filename": "tests/ui/search_is_some_fixable_none.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -106,17 +106,65 @@ mod issue7392 {\n         *x == 9\n     }\n \n-    fn simple_fn(x: u32) -> bool {\n+    fn deref_enough(x: u32) -> bool {\n         x == 78\n     }\n \n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n     fn more_projections() {\n         let x = 19;\n         let ppx: &u32 = &x;\n         let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_none();\n         let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_none();\n \n         let v = vec![3, 2, 1, 0];\n-        let _ = v.iter().find(|x| simple_fn(**x)).is_none();\n+        let _ = v.iter().find(|x| deref_enough(**x)).is_none();\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x| arg_no_deref(x)).is_none();\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = vfoo\n+            .iter()\n+            .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+            .is_none();\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_none();\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_none();\n     }\n }"}, {"sha": "64e81c6b94a2539d381fb37a8f08b1d709cc3a97", "filename": "tests/ui/search_is_some_fixable_none.stderr", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.stderr?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -170,22 +170,56 @@ LL |         let _ = vfoo.iter().find(|sub| sub[1..4].len() == 3).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|sub| sub[1..4].len() == 3)`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:116:17\n+  --> $DIR/search_is_some_fixable_none.rs:120:17\n    |\n LL |         let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![ppx].iter().any(|ppp_x: &&u32| please(ppp_x))`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:117:17\n+  --> $DIR/search_is_some_fixable_none.rs:121:17\n    |\n LL |         let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![String::from(\"Hey hey\")].iter().any(|s| s.len() == 2)`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:120:17\n+  --> $DIR/search_is_some_fixable_none.rs:124:17\n+   |\n+LL |         let _ = v.iter().find(|x| deref_enough(**x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| deref_enough(*x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:127:17\n+   |\n+LL |         let _ = v.iter().find(|x| arg_no_deref(x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| arg_no_deref(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:147:17\n+   |\n+LL |           let _ = vfoo\n+   |  _________________^\n+LL | |             .iter()\n+LL | |             .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+LL | |             .is_none();\n+   | |______________________^\n+   |\n+help: use `!_.any()` instead\n+   |\n+LL ~         let _ = !vfoo\n+LL ~             .iter().any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2);\n+   |\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:163:17\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|v| v.inner[0].bar == 2)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:168:17\n    |\n-LL |         let _ = v.iter().find(|x| simple_fn(**x)).is_none();\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| simple_fn(*x))`\n+LL |         let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|x| (**x)[0] == 9)`\n \n-error: aborting due to 29 previous errors\n+error: aborting due to 33 previous errors\n "}, {"sha": "7eb07d639a56915de6dc15795d882635746650f6", "filename": "tests/ui/search_is_some_fixable_some.fixed", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.fixed?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -103,17 +103,64 @@ mod issue7392 {\n         *x == 9\n     }\n \n-    fn simple_fn(x: u32) -> bool {\n+    fn deref_enough(x: u32) -> bool {\n         x == 78\n     }\n \n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n     fn more_projections() {\n         let x = 19;\n         let ppx: &u32 = &x;\n         let _ = [ppx].iter().any(|ppp_x: &&u32| please(ppp_x));\n         let _ = [String::from(\"Hey hey\")].iter().any(|s| s.len() == 2);\n \n         let v = vec![3, 2, 1, 0];\n-        let _ = v.iter().any(|x| simple_fn(*x));\n+        let _ = v.iter().any(|x| deref_enough(*x));\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().any(|x| arg_no_deref(&x));\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = vfoo\n+            .iter()\n+            .any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2);\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = vfoo.iter().any(|v| v.inner[0].bar == 2);\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = vfoo.iter().any(|x| (**x)[0] == 9);\n     }\n }"}, {"sha": "b9ebd399a3507f53ebc02315f9a0d96645502298", "filename": "tests/ui/search_is_some_fixable_some.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -105,17 +105,65 @@ mod issue7392 {\n         *x == 9\n     }\n \n-    fn simple_fn(x: u32) -> bool {\n+    fn deref_enough(x: u32) -> bool {\n         x == 78\n     }\n \n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n     fn more_projections() {\n         let x = 19;\n         let ppx: &u32 = &x;\n         let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_some();\n         let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_some();\n \n         let v = vec![3, 2, 1, 0];\n-        let _ = v.iter().find(|x| simple_fn(**x)).is_some();\n+        let _ = v.iter().find(|x| deref_enough(**x)).is_some();\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x| arg_no_deref(x)).is_some();\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = vfoo\n+            .iter()\n+            .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+            .is_some();\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_some();\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_some();\n     }\n }"}, {"sha": "b62cf9c470290d2685db81a69e143ecf13a08c59", "filename": "tests/ui/search_is_some_fixable_some.stderr", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a55407cc37ddb1bf1d3d95e52db7b6402259966/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.stderr?ref=7a55407cc37ddb1bf1d3d95e52db7b6402259966", "patch": "@@ -161,22 +161,48 @@ LL |         let _ = vfoo.iter().find(|sub| sub[1..4].len() == 3).is_some();\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|sub| sub[1..4].len() == 3)`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:115:30\n+  --> $DIR/search_is_some_fixable_some.rs:119:30\n    |\n LL |         let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_some();\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|ppp_x: &&u32| please(ppp_x))`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:116:50\n+  --> $DIR/search_is_some_fixable_some.rs:120:50\n    |\n LL |         let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_some();\n    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|s| s.len() == 2)`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:119:26\n+  --> $DIR/search_is_some_fixable_some.rs:123:26\n    |\n-LL |         let _ = v.iter().find(|x| simple_fn(**x)).is_some();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| simple_fn(*x))`\n+LL |         let _ = v.iter().find(|x| deref_enough(**x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| deref_enough(*x))`\n \n-error: aborting due to 29 previous errors\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:126:26\n+   |\n+LL |         let _ = v.iter().find(|x| arg_no_deref(x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| arg_no_deref(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:148:14\n+   |\n+LL |               .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+   |  ______________^\n+LL | |             .is_some();\n+   | |______________________^ help: use `any()` instead: `any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:162:29\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|v| v.inner[0].bar == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:167:29\n+   |\n+LL |         let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| (**x)[0] == 9)`\n+\n+error: aborting due to 33 previous errors\n "}]}