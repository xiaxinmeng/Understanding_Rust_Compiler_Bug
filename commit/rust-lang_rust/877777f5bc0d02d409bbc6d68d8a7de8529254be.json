{"sha": "877777f5bc0d02d409bbc6d68d8a7de8529254be", "node_id": "C_kwDOAAsO6NoAKDg3Nzc3N2Y1YmMwZDAyZDQwOWJiYzZkNjhkOGE3ZGU4NTI5MjU0YmU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-11T07:14:41Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-04-11T22:02:38Z"}, "message": "Inline and remove `DescriptionCtx::from_early_bound_and_free_regions`.\n\nIt has a single call site, and the code is clearer with all region kinds\nhandled in one function, instead of splitting the handling across two\nfunctions.\n\nThe commit also changes `DescriptionCtx::new` to use a more declarative\nstyle, instead of creating a default `DescriptionCtx` and modifying it,\nwhich I find easier to read.", "tree": {"sha": "13cc308502fa3e394fa009b062d01cee4cdbc544", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13cc308502fa3e394fa009b062d01cee4cdbc544"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/877777f5bc0d02d409bbc6d68d8a7de8529254be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/877777f5bc0d02d409bbc6d68d8a7de8529254be", "html_url": "https://github.com/rust-lang/rust/commit/877777f5bc0d02d409bbc6d68d8a7de8529254be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/877777f5bc0d02d409bbc6d68d8a7de8529254be/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b0635679fc5bb4fd157e1eaad8e7f21705d68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b0635679fc5bb4fd157e1eaad8e7f21705d68a", "html_url": "https://github.com/rust-lang/rust/commit/c9b0635679fc5bb4fd157e1eaad8e7f21705d68a"}], "stats": {"total": 111, "additions": 44, "deletions": 67}, "files": [{"sha": "7328241dfbcaf3a48cdd2f05dd637cee16537c50", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 44, "deletions": 67, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/877777f5bc0d02d409bbc6d68d8a7de8529254be/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877777f5bc0d02d409bbc6d68d8a7de8529254be/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=877777f5bc0d02d409bbc6d68d8a7de8529254be", "patch": "@@ -4,7 +4,6 @@ use rustc_errors::{self, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, Subdiag\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n \n-#[derive(Default)]\n struct DescriptionCtx<'a> {\n     span: Option<Span>,\n     kind: &'a str,\n@@ -17,96 +16,74 @@ impl<'a> DescriptionCtx<'a> {\n         region: ty::Region<'tcx>,\n         alt_span: Option<Span>,\n     ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        me.span = alt_span;\n-        match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                return Self::from_early_bound_and_free_regions(tcx, region);\n-            }\n-            ty::ReStatic => {\n-                me.kind = \"restatic\";\n-            }\n-\n-            ty::RePlaceholder(_) => return None,\n-\n-            ty::ReError(_) => return None,\n-\n-            // FIXME(#13998) RePlaceholder should probably print like\n-            // ReFree rather than dumping Debug output on the user.\n-            //\n-            // We shouldn't really be having unification failures with ReVar\n-            // and ReLateBound though.\n-            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-                me.kind = \"revar\";\n-                me.arg = format!(\"{:?}\", region);\n-            }\n-        };\n-        Some(me)\n-    }\n-\n-    fn from_early_bound_and_free_regions<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) -> Option<Self> {\n-        let mut me = DescriptionCtx::default();\n-        let scope = region.free_region_binding_scope(tcx).expect_local();\n-        match *region {\n+        let (span, kind, arg) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = tcx.def_span(scope);\n-                if let Some(param) =\n+                let scope = region.free_region_binding_scope(tcx).expect_local();\n+                let span = if let Some(param) =\n                     tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n                 {\n-                    sp = param.span;\n-                }\n-                if br.has_name() {\n-                    me.kind = \"as_defined\";\n-                    me.arg = br.name.to_string();\n+                    param.span\n                 } else {\n-                    me.kind = \"as_defined_anon\";\n+                    tcx.def_span(scope)\n                 };\n-                me.span = Some(sp)\n+                if br.has_name() {\n+                    (Some(span), \"as_defined\", br.name.to_string())\n+                } else {\n+                    (Some(span), \"as_defined_anon\", String::new())\n+                }\n             }\n             ty::ReFree(ref fr) => {\n                 if !fr.bound_region.is_named()\n                     && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n                 {\n-                    me.kind = \"defined_here\";\n-                    me.span = Some(ty.span);\n+                    (Some(ty.span), \"defined_here\", String::new())\n                 } else {\n+                    let scope = region.free_region_binding_scope(tcx).expect_local();\n                     match fr.bound_region {\n                         ty::BoundRegionKind::BrNamed(_, name) => {\n-                            let mut sp = tcx.def_span(scope);\n-                            if let Some(param) =\n-                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            let span = if let Some(param) = tcx\n+                                .hir()\n+                                .get_generics(scope)\n+                                .and_then(|generics| generics.get_named(name))\n                             {\n-                                sp = param.span;\n-                            }\n-                            if name == kw::UnderscoreLifetime {\n-                                me.kind = \"as_defined_anon\";\n+                                param.span\n                             } else {\n-                                me.kind = \"as_defined\";\n-                                me.arg = name.to_string();\n+                                tcx.def_span(scope)\n                             };\n-                            me.span = Some(sp);\n+                            if name == kw::UnderscoreLifetime {\n+                                (Some(span), \"as_defined_anon\", String::new())\n+                            } else {\n+                                (Some(span), \"as_defined\", name.to_string())\n+                            }\n                         }\n                         ty::BrAnon(span) => {\n-                            me.kind = \"defined_here\";\n-                            me.span = match span {\n+                            let span = match span {\n                                 Some(_) => span,\n                                 None => Some(tcx.def_span(scope)),\n-                            }\n-                        },\n+                            };\n+                            (span, \"defined_here\", String::new())\n+                        }\n                         _ => {\n-                            me.kind = \"defined_here_reg\";\n-                            me.arg = region.to_string();\n-                            me.span = Some(tcx.def_span(scope));\n-                        },\n+                            (Some(tcx.def_span(scope)), \"defined_here_reg\", region.to_string())\n+                        }\n                     }\n                 }\n             }\n-            _ => bug!(),\n-        }\n-        Some(me)\n+\n+            ty::ReStatic => (alt_span, \"restatic\", String::new()),\n+\n+            ty::RePlaceholder(_) | ty::ReError(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                (alt_span, \"revar\", format!(\"{:?}\", region))\n+            }\n+        };\n+        Some(DescriptionCtx { span, kind, arg })\n     }\n }\n "}]}