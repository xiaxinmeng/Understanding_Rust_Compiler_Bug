{"sha": "c14d86fd3ff3ba2d01a6e859290b30e74081313b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNGQ4NmZkM2ZmM2JhMmQwMWE2ZTg1OTI5MGIzMGU3NDA4MTMxM2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-09T18:18:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-17T16:06:59Z"}, "message": "core: Split apart the global `core` feature\n\nThis commit shards the broad `core` feature of the libcore library into finer\ngrained features. This split groups together similar APIs and enables tracking\neach API separately, giving a better sense of where each feature is within the\nstabilization process.\n\nA few minor APIs were deprecated along the way:\n\n* Iterator::reverse_in_place\n* marker::NoCopy", "tree": {"sha": "79ec999c2885ff0d2f3b9836be5938bc0d6339b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79ec999c2885ff0d2f3b9836be5938bc0d6339b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14d86fd3ff3ba2d01a6e859290b30e74081313b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14d86fd3ff3ba2d01a6e859290b30e74081313b", "html_url": "https://github.com/rust-lang/rust/commit/c14d86fd3ff3ba2d01a6e859290b30e74081313b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14d86fd3ff3ba2d01a6e859290b30e74081313b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7a5a1c33a7794a97eb11a38cc576375a3553a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a5a1c33a7794a97eb11a38cc576375a3553a64", "html_url": "https://github.com/rust-lang/rust/commit/e7a5a1c33a7794a97eb11a38cc576375a3553a64"}], "stats": {"total": 667, "additions": 379, "deletions": 288}, "files": [{"sha": "91cbd3915d0069d5fc3f4fef0920ff3d677877f5", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -10,9 +10,9 @@\n \n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n-//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n-//! scope.\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n+//! drop their contents when they go out of scope.\n //!\n //! # Examples\n //!\n@@ -39,15 +39,17 @@\n //!\n //! This will print `Cons(1, Cons(2, Nil))`.\n //!\n-//! Recursive structures must be boxed, because if the definition of `Cons` looked like this:\n+//! Recursive structures must be boxed, because if the definition of `Cons`\n+//! looked like this:\n //!\n //! ```rust,ignore\n //! Cons(T, List<T>),\n //! ```\n //!\n-//! It wouldn't work. This is because the size of a `List` depends on how many elements are in the\n-//! list, and so we don't know how much memory to allocate for a `Cons`. By introducing a `Box`,\n-//! which has a defined size, we know how big `Cons` needs to be.\n+//! It wouldn't work. This is because the size of a `List` depends on how many\n+//! elements are in the list, and so we don't know how much memory to allocate\n+//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n+//! big `Cons` needs to be.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -355,7 +357,7 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n /// }\n /// ```\n #[rustc_paren_sugar]\n-#[unstable(feature = \"core\", reason = \"Newly introduced\")]\n+#[unstable(feature = \"fnbox\", reason = \"Newly introduced\")]\n pub trait FnBox<A> {\n     type Output;\n "}, {"sha": "91585c3cb6cf7be74ba79b1ba9b5973526432c16", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -60,26 +60,32 @@\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"alloc\"]\n #![unstable(feature = \"alloc\")]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![doc(test(no_crate_inject))]\n-\n-#![feature(no_std)]\n+       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n+       test(no_crate_inject))]\n #![no_std]\n+\n #![feature(allocator)]\n+#![feature(box_syntax)]\n+#![feature(coerce_unsized)]\n+#![feature(core)]\n+#![feature(core_intrinsics)]\n+#![feature(core_prelude)]\n #![feature(custom_attribute)]\n #![feature(fundamental)]\n #![feature(lang_items)]\n-#![feature(box_syntax)]\n+#![feature(no_std)]\n+#![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n+#![feature(raw)]\n+#![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(core)]\n #![feature(unique)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(unsize)]\n #![cfg_attr(test, feature(test, alloc, rustc_private))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]"}, {"sha": "73641647bf4262d41df5ce5d9805361b56e74b77", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -32,7 +32,9 @@\n \n #![feature(alloc)]\n #![feature(box_syntax)]\n-#![feature(core)]\n+#![feature(core_intrinsics)]\n+#![feature(ptr_as_ref)]\n+#![feature(raw)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "0c1349bc2e6c85e7bf195cc8bc141c266c9b2fd9", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -21,26 +21,42 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![doc(test(no_crate_inject))]\n+       html_playground_url = \"http://play.rust-lang.org/\",\n+       test(no_crate_inject))]\n \n #![allow(trivial_casts)]\n+#![cfg_attr(test, allow(deprecated))] // rand\n+\n #![feature(alloc)]\n-#![feature(box_syntax)]\n #![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(copy_lifetime)]\n #![feature(core)]\n+#![feature(core_intrinsics)]\n+#![feature(core_prelude)]\n+#![feature(core_slice_ext)]\n+#![feature(core_str_ext)]\n+#![feature(iter_cmp)]\n+#![feature(iter_idx)]\n+#![feature(iter_order)]\n+#![feature(iter_product)]\n+#![feature(iter_sum)]\n #![feature(lang_items)]\n+#![feature(num_bits_bytes)]\n+#![feature(pattern)]\n+#![feature(ptr_as_ref)]\n+#![feature(raw)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(step_by)]\n+#![feature(str_char)]\n+#![feature(str_internals)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(step_by)]\n-#![feature(str_char)]\n-#![feature(slice_patterns)]\n #![feature(utf8_error)]\n #![cfg_attr(test, feature(rand, test))]\n-#![cfg_attr(test, allow(deprecated))] // rand\n #![cfg_attr(not(test), feature(str_words))]\n \n #![feature(no_std)]"}, {"sha": "f0c77ae866d599dcf374caf103c793893baa3c89", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -92,7 +92,7 @@ use marker::{Reflect, Sized};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: Reflect + 'static {\n     /// Gets the `TypeId` of `self`.\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"get_type_id\",\n                reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }"}, {"sha": "a9b240de30befe0175d12aa17d967ce0f2f25107", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -12,9 +12,10 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![unstable(feature = \"core\")] // not yet reviewed\n-\n #![doc(primitive = \"array\")]\n+#![unstable(feature = \"fixed_size_array\",\n+            reason = \"traits and impls are better expressed through generic \\\n+                      integer constants\")]\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -30,7 +31,6 @@ use slice::{Iter, IterMut, SliceExt};\n ///\n /// This trait can be used to implement other traits on fixed-size arrays\n /// without causing much metadata bloat.\n-#[unstable(feature = \"core\")]\n pub trait FixedSizeArray<T> {\n     /// Converts the array to immutable slice\n     fn as_slice(&self) -> &[T];\n@@ -42,7 +42,6 @@ pub trait FixedSizeArray<T> {\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[unstable(feature = \"core\")]\n             impl<T> FixedSizeArray<T> for [T; $N] {\n                 #[inline]\n                 fn as_slice(&self) -> &[T] {\n@@ -54,17 +53,13 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"array_as_ref\",\n-                       reason = \"should ideally be implemented for all fixed-sized arrays\")]\n             impl<T> AsRef<[T]> for [T; $N] {\n                 #[inline]\n                 fn as_ref(&self) -> &[T] {\n                     &self[..]\n                 }\n             }\n \n-            #[unstable(feature = \"array_as_ref\",\n-                       reason = \"should ideally be implemented for all fixed-sized arrays\")]\n             impl<T> AsMut<[T]> for [T; $N] {\n                 #[inline]\n                 fn as_mut(&mut self) -> &mut [T] {"}, {"sha": "56dfd922dc1886ec75b0341414f5c4642c595c26", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -229,7 +229,7 @@ impl<T:Copy> Cell<T> {\n     /// let uc = unsafe { c.as_unsafe_cell() };\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"as_unsafe_cell\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -277,7 +277,7 @@ pub struct RefCell<T: ?Sized> {\n \n /// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"std_misc\")]\n+#[unstable(feature = \"borrow_state\")]\n pub enum BorrowState {\n     /// The cell is currently being read, there is at least one active `borrow`.\n     Reading,\n@@ -339,7 +339,7 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// The returned value can be dispatched on to determine if a call to\n     /// `borrow` or `borrow_mut` would succeed.\n-    #[unstable(feature = \"std_misc\")]\n+    #[unstable(feature = \"borrow_state\")]\n     #[inline]\n     pub fn borrow_state(&self) -> BorrowState {\n         match self.borrow.get() {\n@@ -448,7 +448,7 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"as_unsafe_cell\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -564,9 +564,10 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `Ref::clone(...)`.\n-    /// A `Clone` implementation or a method would interfere with the widespread\n-    /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n+    /// with the widespread use of `r.borrow().clone()` to clone the contents of\n+    /// a `RefCell`.\n     #[unstable(feature = \"cell_extras\",\n                reason = \"likely to be moved to a method, pending language changes\")]\n     #[inline]\n@@ -582,8 +583,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as `Ref::map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// A method would interfere with methods of the same name on the contents\n+    /// of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -607,13 +608,14 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Make a new `Ref` for a optional component of the borrowed data, e.g. an enum variant.\n+    /// Make a new `Ref` for a optional component of the borrowed data, e.g. an\n+    /// enum variant.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `Ref::filter_map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::filter_map(...)`.  A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -639,13 +641,14 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum variant.\n+    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum\n+    /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `RefMut::map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n+    /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -673,13 +676,14 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         }\n     }\n \n-    /// Make a new `RefMut` for a optional component of the borrowed data, e.g. an enum variant.\n+    /// Make a new `RefMut` for a optional component of the borrowed data, e.g.\n+    /// an enum variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n-    /// This is an associated function that needs to be used as `RefMut::filter_map(...)`.\n-    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n-    /// used through `Deref`.\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::filter_map(...)`.  A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Example\n     ///\n@@ -690,7 +694,9 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// let c = RefCell::new(Ok(5));\n     /// {\n     ///     let b1: RefMut<Result<u32, ()>> = c.borrow_mut();\n-    ///     let mut b2: RefMut<u32> = RefMut::filter_map(b1, |o| o.as_mut().ok()).unwrap();\n+    ///     let mut b2: RefMut<u32> = RefMut::filter_map(b1, |o| {\n+    ///         o.as_mut().ok()\n+    ///     }).unwrap();\n     ///     assert_eq!(*b2, 5);\n     ///     *b2 = 42;\n     /// }"}, {"sha": "9f5944d3c9c71319a55e78553c8c7818dc99e19c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -14,6 +14,7 @@\n \n #![allow(non_snake_case)]\n #![doc(primitive = \"char\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use iter::Iterator;\n use mem::transmute;\n@@ -131,6 +132,8 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n // unicode/char.rs, not here\n #[allow(missing_docs)] // docs in libunicode/u_char.rs\n #[doc(hidden)]\n+#[unstable(feature = \"core_char_ext\",\n+           reason = \"the stable interface is `impl char` in later crate\")]\n pub trait CharExt {\n     fn is_digit(self, radix: u32) -> bool;\n     fn to_digit(self, radix: u32) -> Option<u32>;\n@@ -220,6 +223,8 @@ impl CharExt for char {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n+#[unstable(feature = \"char_internals\",\n+           reason = \"this function should not be exposed publicly\")]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && !dst.is_empty() {\n@@ -251,6 +256,8 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n+#[unstable(feature = \"char_internals\",\n+           reason = \"this function should not be exposed publicly\")]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF) == ch && !dst.is_empty() {"}, {"sha": "a13160b3a19ee48d93582d57e548aef1f3411583", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -89,29 +89,28 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[unstable(feature = \"core\",\n-                   reason = \"this may not be sufficient for fns with region parameters\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n \n-        #[unstable(feature = \"core\", reason = \"brand new\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for extern \"C\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> extern \"C\" fn($($A),*) -> ReturnType { *self }\n         }\n \n-        #[unstable(feature = \"core\", reason = \"brand new\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for unsafe extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> unsafe extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n \n-        #[unstable(feature = \"core\", reason = \"brand new\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($A,)* ReturnType> Clone for unsafe extern \"C\" fn($($A),*) -> ReturnType {\n             /// Returns a copy of a function pointer.\n             #[inline]"}, {"sha": "b12b59760106ac07bd21c000a12b31cc282e1cd1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -10,10 +10,10 @@\n \n //! Functionality for ordering and comparison.\n //!\n-//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the compiler to\n-//! implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`,\n-//! `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=`\n-//! operators.\n+//! This module defines both `PartialOrd` and `PartialEq` traits which are used\n+//! by the compiler to implement comparison operators. Rust programs may\n+//! implement `PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators,\n+//! and may implement `PartialEq` to overload the `==` and `!=` operators.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -22,29 +22,31 @@ use self::Ordering::*;\n use marker::Sized;\n use option::Option::{self, Some, None};\n \n-/// Trait for equality comparisons which are [partial equivalence relations](\n-/// http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n+/// Trait for equality comparisons which are [partial equivalence\n+/// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n-/// This trait allows for partial equality, for types that do not have a full equivalence relation.\n-/// For example, in floating point numbers `NaN != NaN`, so floating point types implement\n-/// `PartialEq` but not `Eq`.\n+/// This trait allows for partial equality, for types that do not have a full\n+/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n+/// so floating point types implement `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n-/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n-/// transitively: if `T: PartialEq<U>` and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n-/// PartialEq<V>`.\n+/// Note that these requirements mean that the trait itself must be implemented\n+/// symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\n+/// then `U: PartialEq<T>` and `T: PartialEq<V>`.\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by\n-/// default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict\n-/// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n+/// in terms of it by default. Any manual implementation of `ne` *must* respect\n+/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// only if `a != b`.\n #[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n-    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    /// This method tests for `self` and `other` values to be equal, and is used\n+    /// by `==`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n@@ -396,7 +398,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(result, None);\n /// ```\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"cmp_partial\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -429,7 +431,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// assert_eq!(result, None);\n /// ```\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"cmp_partial\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Equal) | Some(Less) => Some(v2),"}, {"sha": "70868805299f3a910a7a5858f33a508606acb1cb", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -10,11 +10,12 @@\n \n //! Traits for conversions between types.\n //!\n-//! The traits in this module provide a general way to talk about conversions from one type to\n-//! another. They follow the standard Rust conventions of `as`/`into`/`from`.\n+//! The traits in this module provide a general way to talk about conversions\n+//! from one type to another. They follow the standard Rust conventions of\n+//! `as`/`into`/`from`.\n //!\n-//! Like many traits, these are often used as bounds for generic functions, to support arguments of\n-//! multiple types.\n+//! Like many traits, these are often used as bounds for generic functions, to\n+//! support arguments of multiple types.\n //!\n //! See each trait for usage examples.\n "}, {"sha": "cbbb186af7609fc7cc431e12d9e0c83065d9a1ad", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -33,7 +33,7 @@ pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap}\n mod num;\n mod builders;\n \n-#[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n #[doc(hidden)]\n pub mod rt {\n     pub mod v1;\n@@ -146,7 +146,7 @@ enum Void {}\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy)]\n-#[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n     value: &'a Void,\n@@ -166,7 +166,7 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn new<'b, T>(x: &'b T,\n                       f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n         unsafe {\n@@ -178,7 +178,7 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1 {\n         ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n@@ -201,7 +201,7 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn new_v1(pieces: &'a [&'a str],\n                   args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -218,7 +218,7 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\")]\n     pub fn new_v1_formatted(pieces: &'a [&'a str],\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n@@ -742,19 +742,19 @@ impl<'a> Formatter<'a> {\n     pub fn flags(&self) -> u32 { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn align(&self) -> Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn width(&self) -> Option<usize> { self.width }\n \n     /// Optionally specified precision for numeric types\n-    #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[unstable(feature = \"fmt_flags\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n \n     /// Creates a `DebugStruct` builder designed to assist with creation of"}, {"sha": "6aaec20382ecffa22d8af77a2ad144e9ea741d61", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -127,7 +127,7 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[derive(Clone, Copy, PartialEq)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\")]\n pub struct Radix {\n     base: u8,\n@@ -152,7 +152,7 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\")]\n #[derive(Copy, Clone)]\n pub struct RadixFmt<T, R>(T, R);\n@@ -166,7 +166,7 @@ pub struct RadixFmt<T, R>(T, R);\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))"}, {"sha": "033834dd5aaaa59dc7941eb5a82f06271782a599", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -14,8 +14,6 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![unstable(feature = \"core\", reason = \"internal to format_args!\")]\n-\n #[derive(Copy, Clone)]\n pub struct Argument {\n     pub position: Position,"}, {"sha": "cbf2828a7dc18e0d06d2c4fa14819671af0aa50f", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -89,7 +89,8 @@ pub trait Hash {\n     fn hash<H: Hasher>(&self, state: &mut H);\n \n     /// Feeds a slice of this type into the state provided.\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hash_slice\",\n+               reason = \"module was recently redesigned\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n         for piece in data {\n             piece.hash(state);\n@@ -110,29 +111,29 @@ pub trait Hasher {\n \n     /// Write a single `u8` into this hasher\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n     /// Write a single `u16` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u16(&mut self, i: u16) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n     }\n     /// Write a single `u32` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u32(&mut self, i: u32) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n     }\n     /// Write a single `u64` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n     /// Write a single `usize` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_usize(&mut self, i: usize) {\n         if cfg!(target_pointer_width = \"32\") {\n             self.write_u32(i as u32)\n@@ -143,31 +144,33 @@ pub trait Hasher {\n \n     /// Write a single `i8` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n     /// Write a single `i16` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n     /// Write a single `i32` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n     /// Write a single `i64` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n     /// Write a single `isize` into this hasher.\n     #[inline]\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[unstable(feature = \"hasher_write\", reason = \"module was recently redesigned\")]\n     fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n /// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n ///\n /// The specified value will be hashed with this hasher and then the resulting\n /// hash will be returned.\n-#[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+#[unstable(feature = \"hash_default\",\n+           reason = \"not the most ergonomic interface unless `H` is defaulted \\\n+                     to SipHasher, but perhaps not ready to commit to that\")]\n pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n     let mut h: H = Default::default();\n     value.hash(&mut h);"}, {"sha": "455928077da462f1d17279d52353e3e617eda326", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -39,7 +39,10 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable(feature = \"core\")]\n+#![unstable(feature = \"core_intrinsics\",\n+            reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n+                      they should be used through stabilized interfaces \\\n+                      in the rest of the standard library\")]\n #![allow(missing_docs)]\n \n use marker::Sized;\n@@ -141,10 +144,10 @@ extern \"rust-intrinsic\" {\n \n     /// A compiler-only memory barrier.\n     ///\n-    /// Memory accesses will never be reordered across this barrier by the compiler,\n-    /// but no instructions will be emitted for it. This is appropriate for operations\n-    /// on the same thread that may be preempted, such as when interacting with signal\n-    /// handlers.\n+    /// Memory accesses will never be reordered across this barrier by the\n+    /// compiler, but no instructions will be emitted for it. This is\n+    /// appropriate for operations on the same thread that may be preempted,\n+    /// such as when interacting with signal handlers.\n     pub fn atomic_singlethreadfence();\n     pub fn atomic_singlethreadfence_acq();\n     pub fn atomic_singlethreadfence_rel();"}, {"sha": "da714671c572395e331814373a7868342bb6bd33", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -51,8 +51,8 @@\n //! }\n //! ```\n //!\n-//! Because `Iterator`s implement `IntoIterator`, this `for` loop syntax can be applied to any\n-//! iterator over any type.\n+//! Because `Iterator`s implement `IntoIterator`, this `for` loop syntax can be\n+//! applied to any iterator over any type.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -837,7 +837,9 @@ pub trait Iterator {\n     /// let a = [1, 1, 1, 1];\n     /// assert_eq!(a.iter().min_max(), MinMax(&1, &1));\n     /// ```\n-    #[unstable(feature = \"core\", reason = \"return type may change\")]\n+    #[unstable(feature = \"iter_min_max\",\n+               reason = \"return type may change or may wish to have a closure \\\n+                         based version as well\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n@@ -897,7 +899,7 @@ pub trait Iterator {\n     /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"iter_cmp\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n@@ -925,7 +927,7 @@ pub trait Iterator {\n     /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"iter_cmp\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n@@ -1041,6 +1043,8 @@ pub trait Iterator {\n     /// Use an iterator to reverse a container in place.\n     #[unstable(feature = \"core\",\n                reason = \"uncertain about placement or widespread use\")]\n+    #[deprecated(since = \"1.2.0\",\n+                 reason = \"not performant enough to justify inclusion\")]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Sized + Iterator<Item=&'a mut T> + DoubleEndedIterator\n     {\n@@ -1062,7 +1066,7 @@ pub trait Iterator {\n     /// let it = a.iter();\n     /// assert_eq!(it.sum::<i32>(), 15);\n     /// ```\n-    #[unstable(feature=\"core\")]\n+    #[unstable(feature=\"iter_sum\", reason = \"bounds recently changed\")]\n     fn sum<S=<Self as Iterator>::Item>(self) -> S where\n         S: Add<Self::Item, Output=S> + Zero,\n         Self: Sized,\n@@ -1083,7 +1087,7 @@ pub trait Iterator {\n     /// assert_eq!(factorial(1), 1);\n     /// assert_eq!(factorial(5), 120);\n     /// ```\n-    #[unstable(feature=\"core\")]\n+    #[unstable(feature=\"iter_product\", reason = \"bounds recently changed\")]\n     fn product<P=<Self as Iterator>::Item>(self) -> P where\n         P: Mul<Self::Item, Output=P> + One,\n         Self: Sized,\n@@ -1223,7 +1227,7 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n /// `DoubleEndedIterator`.  Calling `next()` or `next_back()` on a\n /// `RandomAccessIterator` reduces the indexable range accordingly. That is,\n /// `it.idx(1)` will become `it.idx(0)` after `it.next()` is called.\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"iter_idx\",\n            reason = \"not widely used, may be better decomposed into Index \\\n                      and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n@@ -1304,7 +1308,7 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Rev<I>\n     where I: DoubleEndedIterator + RandomAccessIterator\n {\n@@ -1324,7 +1328,7 @@ impl<I> RandomAccessIterator for Rev<I>\n /// `MinMaxResult` is an enum returned by `min_max`. See `Iterator::min_max` for\n /// more detail.\n #[derive(Clone, PartialEq, Debug)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"iter_min_max\",\n            reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n@@ -1338,6 +1342,7 @@ pub enum MinMaxResult<T> {\n     MinMax(T, T)\n }\n \n+#[unstable(feature = \"iter_min_max\", reason = \"type is unstable\")]\n impl<T: Clone> MinMaxResult<T> {\n     /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option`\n     /// has variant `None` if and only if the `MinMaxResult` has variant\n@@ -1360,7 +1365,6 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1, 2);\n     /// assert_eq!(r.into_option(), Some((1, 2)));\n     /// ```\n-    #[unstable(feature = \"core\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1407,7 +1411,7 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     where I: ExactSizeIterator<Item=&'a T>, T: Clone\n {}\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<'a, I, T: 'a> RandomAccessIterator for Cloned<I>\n     where I: RandomAccessIterator<Item=&'a T>, T: Clone\n {\n@@ -1454,7 +1458,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1568,7 +1572,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator,\n     B: RandomAccessIterator<Item = A::Item>,\n@@ -1656,7 +1660,7 @@ impl<A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator,\n     B: RandomAccessIterator\n@@ -1710,7 +1714,7 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<B, I: RandomAccessIterator, F> RandomAccessIterator for Map<I, F> where\n     F: FnMut(I::Item) -> B,\n {\n@@ -1884,7 +1888,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2134,7 +2138,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2206,7 +2210,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2236,7 +2240,8 @@ pub struct Scan<I, St, F> {\n     f: F,\n \n     /// The current internal state to be passed to the closure next.\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"scan_state\",\n+               reason = \"public fields are otherwise rare in the stdlib\")]\n     pub state: St,\n }\n \n@@ -2406,7 +2411,7 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -2427,7 +2432,7 @@ impl<I> Fuse<I> {\n     /// `.next_back()` will call the underlying iterator again even if it\n     /// previously returned `None`.\n     #[inline]\n-    #[unstable(feature = \"core\", reason = \"seems marginal\")]\n+    #[unstable(feature = \"iter_reset_fuse\", reason = \"seems marginal\")]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2481,7 +2486,7 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n     where F: FnMut(&I::Item),\n {\n@@ -2531,16 +2536,16 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_unfold\")]\n #[derive(Clone)]\n pub struct Unfold<St, F> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"iter_unfold\")]\n     pub state: St,\n }\n \n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_unfold\")]\n impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2767,7 +2772,7 @@ impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeInclusive<A> {\n     range: ops::Range<A>,\n@@ -2776,7 +2781,7 @@ pub struct RangeInclusive<A> {\n \n /// Returns an iterator over the range [start, stop].\n #[inline]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n     where A: Step + One + Clone\n@@ -2787,7 +2792,7 @@ pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>\n     }\n }\n \n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A> Iterator for RangeInclusive<A> where\n     A: PartialEq + Step + One + Clone,\n@@ -2820,7 +2825,7 @@ impl<A> Iterator for RangeInclusive<A> where\n     }\n }\n \n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"range_inclusive\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A> DoubleEndedIterator for RangeInclusive<A> where\n     A: PartialEq + Step + One + Clone,\n@@ -2973,7 +2978,7 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> usize { usize::MAX }\n@@ -2985,12 +2990,12 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_iterate\")]\n pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Creates a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"iter_iterate\")]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,\n@@ -3123,7 +3128,7 @@ pub fn once<T>(value: T) -> Once<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[unstable(feature = \"core\", reason = \"needs review and revision\")]\n+#[unstable(feature = \"iter_order\", reason = \"needs review and revision\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "030d2a33f8f65625449894f4af05f7778b777bb6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -49,7 +49,9 @@\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"core\"]\n-#![unstable(feature = \"core\")]\n+#![unstable(feature = \"core\",\n+            reason = \"the libcore library has not yet been scrutinized for \\\n+                      stabilization in terms of structure and naming\")]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -63,7 +65,8 @@\n #![allow(raw_pointer_derive)]\n #![deny(missing_docs)]\n \n-#![feature(intrinsics, lang_items)]\n+#![feature(intrinsics)]\n+#![feature(lang_items)]\n #![feature(on_unimplemented)]\n #![feature(simd)]\n #![feature(staged_api)]\n@@ -75,6 +78,7 @@\n #![feature(reflect)]\n #![feature(custom_attribute)]\n #![feature(const_fn)]\n+#![feature(allow_internal_unstable)]\n \n #[macro_use]\n mod macros;"}, {"sha": "14bb82dff7d6eacfaae85a68032266ea37fb6ab0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -10,6 +10,7 @@\n \n /// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n+#[allow_internal_unstable]\n macro_rules! panic {\n     () => (\n         panic!(\"explicit panic\")"}, {"sha": "dc3b06977d6c6ae715f0d4a770ca2936d560de49", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -54,7 +54,7 @@ pub trait Sized {\n }\n \n /// Types that can be \"unsized\" to a dynamically sized type.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"unsize\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T> {\n     // Empty.\n@@ -223,7 +223,10 @@ impl<T> !Sync for *mut T { }\n /// ensure that they are never copied, even if they lack a destructor.\n #[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n+#[deprecated(since = \"1.2.0\",\n+             reason = \"structs are by default not copyable\")]\n #[lang = \"no_copy_bound\"]\n+#[allow(deprecated)]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct NoCopy;\n \n@@ -410,7 +413,8 @@ mod impls {\n ///\n /// [1]: http://en.wikipedia.org/wiki/Parametricity\n #[rustc_reflect_like]\n-#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+#[unstable(feature = \"reflect_marker\",\n+           reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n #[rustc_on_unimplemented = \"`{Self}` does not implement `Any`; \\\n                             ensure all type parameters are bounded by `Any`\"]"}, {"sha": "4e9613454ab97f10f8be7ed7fb77584801964c6f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -459,7 +459,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"copy_lifetime\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n@@ -469,7 +469,7 @@ pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"copy_lifetime\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,"}, {"sha": "1b5fa4e0e950b9ba113e16c143f6103452812d0d", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n //! Exposes the NonZero lang item which provides optimization hints.\n+#![unstable(feature = \"nonzero\",\n+            reason = \"needs an RFC to flesh out the design\")]\n \n use marker::Sized;\n use ops::{CoerceUnsized, Deref};\n@@ -33,7 +35,6 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n-#[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {"}, {"sha": "229414fe766647939db28ecf5e1db51fe3cbecd1", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -71,7 +71,8 @@ pub mod consts {\n     pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi * 2.0\n-    #[unstable(feature = \"core\", reason = \"unclear naming convention/usefulness\")]\n+    #[unstable(feature = \"float_consts\",\n+               reason = \"unclear naming convention/usefulness\")]\n     pub const PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n \n     /// pi/2.0\n@@ -135,7 +136,6 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "bbc1bdacde713a067636656744da0d657e6df7ef", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -71,7 +71,8 @@ pub mod consts {\n     pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi * 2.0\n-    #[unstable(feature = \"core\", reason = \"unclear naming convention/usefulness\")]\n+    #[unstable(feature = \"float_consts\",\n+               reason = \"unclear naming convention/usefulness\")]\n     pub const PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n \n     /// pi/2.0\n@@ -135,7 +136,6 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "f3a7e8f09a9eb77c3dec1d9938f352ff43c75600", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -126,6 +126,8 @@ functions.\n // while this is extensively documented, this is in principle private which is\n // only made public for testing. do not expose us.\n #![doc(hidden)]\n+#![unstable(feature = \"flt2dec\",\n+            reason = \"internal routines only exposed for testing\")]\n \n use prelude::*;\n use i16;"}, {"sha": "efc91238809784650f60a6657e1d4c38b38fb871", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -14,11 +14,13 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BITS : usize = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BYTES : usize = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of"}, {"sha": "c8a0ae47637d2ee7904d8c581fb8e5bea9324663", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -41,10 +41,7 @@ use str::{FromStr, StrExt};\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug)]\n pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n-#[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n pub mod wrapping;\n-\n-#[unstable(feature = \"core\", reason = \"internal routines only exposed for testing\")]\n pub mod flt2dec;\n \n /// Types that have a \"zero\" value.\n@@ -471,7 +468,7 @@ macro_rules! int_impl {\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself..\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n@@ -484,7 +481,7 @@ macro_rules! int_impl {\n         /// implementation artifacts make `x % y` illegal for `MIN /\n         /// -1` on a signed type illegal (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n@@ -498,7 +495,7 @@ macro_rules! int_impl {\n         /// negative minimal value for the type); this is a positive\n         /// value that is too large to represent in the type. In such\n         /// a case, this function returns `MIN` itself.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n@@ -507,7 +504,7 @@ macro_rules! int_impl {\n         /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n@@ -516,7 +513,7 @@ macro_rules! int_impl {\n         /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n@@ -1041,7 +1038,7 @@ macro_rules! uint_impl {\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself..\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n@@ -1054,7 +1051,7 @@ macro_rules! uint_impl {\n         /// implementation artifacts make `x % y` illegal for `MIN /\n         /// -1` on a signed type illegal (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n@@ -1068,7 +1065,7 @@ macro_rules! uint_impl {\n         /// negative minimal value for the type); this is a positive\n         /// value that is too large to represent in the type. In such\n         /// a case, this function returns `MIN` itself.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n@@ -1077,7 +1074,7 @@ macro_rules! uint_impl {\n         /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n@@ -1086,7 +1083,7 @@ macro_rules! uint_impl {\n         /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n-        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[unstable(feature = \"num_wrapping\")]\n         #[inline(always)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n@@ -1262,6 +1259,8 @@ pub enum FpCategory {\n \n /// A built-in floating point number.\n #[doc(hidden)]\n+#[unstable(feature = \"core_float\",\n+           reason = \"stable interface is via `impl f{32,64}` in later crates\")]\n pub trait Float {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n@@ -1512,7 +1511,9 @@ enum IntErrorKind {\n }\n \n impl ParseIntError {\n-    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n+    #[unstable(feature = \"int_error_internals\",\n+               reason = \"available through Error trait and this method should \\\n+                         not be exposed publicly\")]\n     pub fn description(&self) -> &str {\n         match self.kind {\n             IntErrorKind::Empty => \"cannot parse integer from empty string\",\n@@ -1535,10 +1536,14 @@ impl fmt::Display for ParseIntError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n     #[doc(hidden)]\n+    #[unstable(feature = \"float_error_internals\",\n+               reason = \"should not be exposed publicly\")]\n     pub __kind: FloatErrorKind\n }\n \n #[derive(Debug, Clone, PartialEq)]\n+#[unstable(feature = \"float_error_internals\",\n+           reason = \"should not be exposed publicly\")]\n pub enum FloatErrorKind {\n     Empty,\n     Invalid,"}, {"sha": "0719d7c17cc4e44fbf2a6b99ca74ba8b1fa52410", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -12,9 +12,11 @@\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BITS : usize = $bits;\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"num_bits_bytes\",\n+           reason = \"may want to be an associated function\")]\n pub const BYTES : usize = ($bits / 8);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "748ed29e3a30682e0c39d0863f166d46acda2c91", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(missing_docs)]\n #![allow(deprecated)]\n+#![unstable(feature = \"wrapping\", reason = \"may be removed or relocated\")]\n \n use super::Wrapping;\n \n@@ -30,7 +31,6 @@ use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n use ::{i8,i16,i32,i64};\n \n-#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n     fn overflowing_sub(self, rhs: Self) -> (Self, bool);"}, {"sha": "48b1cbeef4fddd95d401d652b114caa233b54617", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -29,8 +29,8 @@\n //!\n //! # Examples\n //!\n-//! This example creates a `Point` struct that implements `Add` and `Sub`, and then\n-//! demonstrates adding and subtracting two `Point`s.\n+//! This example creates a `Point` struct that implements `Add` and `Sub`, and\n+//! then demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n //! use std::ops::{Add, Sub};\n@@ -62,21 +62,21 @@\n //! }\n //! ```\n //!\n-//! See the documentation for each trait for a minimum implementation that prints\n-//! something to the screen.\n+//! See the documentation for each trait for a minimum implementation that\n+//! prints something to the screen.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::{Sized, Unsize};\n use fmt;\n \n-/// The `Drop` trait is used to run some code when a value goes out of scope. This\n-/// is sometimes called a 'destructor'.\n+/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// This is sometimes called a 'destructor'.\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n-/// out of scope, and therefore `main` prints `Dropping!`.\n+/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n+/// goes out of scope, and therefore `main` prints `Dropping!`.\n ///\n /// ```\n /// struct HasDrop;\n@@ -103,8 +103,7 @@ pub trait Drop {\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n \n@@ -120,8 +119,7 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -131,8 +129,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -142,8 +139,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"recently added, waiting for dust to settle\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n \n@@ -1210,7 +1206,7 @@ mod impls {\n \n /// Trait that indicates that this is a pointer or a wrapper for one,\n /// where unsizing can be performed on the pointee.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"coerce_unsized\")]\n #[lang=\"coerce_unsized\"]\n pub trait CoerceUnsized<T> {\n     // Empty."}, {"sha": "9a00d1071473fa405a5188453861610d0d4cc574", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -285,7 +285,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"as_slice\",\n                reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {"}, {"sha": "8133db097dfcf9c8b8ded1d4011cb6c525fa82cd", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -29,6 +29,9 @@\n //! library, but the location of this may change over time.\n \n #![allow(dead_code, missing_docs)]\n+#![unstable(feature = \"core_panic\",\n+            reason = \"internal details of the implementation of the `panic!` \\\n+                      and related macros\")]\n \n use fmt;\n "}, {"sha": "ac153d64ab28ffbbeb0a37a843ab3a6d1d76b36f", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -24,6 +24,10 @@\n //! use core::prelude::*;\n //! ```\n \n+#![unstable(feature = \"core_prelude\",\n+            reason = \"the libcore prelude has not been scrutinized and \\\n+                      stabilized yet\")]\n+\n // Reexported core operators\n pub use marker::{Copy, Send, Sized, Sync};\n pub use ops::{Drop, Fn, FnMut, FnOnce};\n@@ -32,7 +36,6 @@ pub use ops::{Drop, Fn, FnMut, FnOnce};\n pub use mem::drop;\n \n // Reexported types and traits\n-\n pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};"}, {"sha": "0f1831e8314d3ce511506f53f427231ad7462f32", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -204,7 +204,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"read_and_zero\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -219,7 +219,7 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n /// Variant of read_and_zero that writes the specific drop-flag byte\n /// (which may be more appropriate than zero).\n #[inline(always)]\n-#[unstable(feature = \"core\",\n+#[unstable(feature = \"filling_drop\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -267,9 +267,10 @@ impl<T: ?Sized> *const T {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable(feature = \"core\",\n-               reason = \"Option is not clearly the right return type, and we may want \\\n-                         to tie the return lifetime to a borrow of the raw pointer\")]\n+    #[unstable(feature = \"ptr_as_ref\",\n+               reason = \"Option is not clearly the right return type, and we \\\n+                         may want to tie the return lifetime to a borrow of \\\n+                         the raw pointer\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n@@ -314,9 +315,10 @@ impl<T: ?Sized> *mut T {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable(feature = \"core\",\n-               reason = \"Option is not clearly the right return type, and we may want \\\n-                         to tie the return lifetime to a borrow of the raw pointer\")]\n+    #[unstable(feature = \"ptr_as_ref\",\n+               reason = \"Option is not clearly the right return type, and we \\\n+                         may want to tie the return lifetime to a borrow of \\\n+                         the raw pointer\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized {\n         if self.is_null() {\n@@ -347,7 +349,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"ptr_as_ref\",\n                reason = \"return value does not necessarily convey all possible \\\n                          information\")]\n     #[inline]\n@@ -507,7 +509,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n /// modified without a unique path to the `Unique` reference. Useful\n /// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable(feature = \"unique\")]\n+#[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\")]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     _marker: PhantomData<T>,\n@@ -527,21 +529,19 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"unique\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n+#[unstable(feature = \"unique\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n-    #[unstable(feature = \"unique\")]\n     pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n     /// Dereferences the content.\n-    #[unstable(feature = \"unique\")]\n     pub unsafe fn get(&self) -> &T {\n         &**self.pointer\n     }\n \n     /// Mutably dereferences the content.\n-    #[unstable(feature = \"unique\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut ***self\n     }"}, {"sha": "85e1318d7a11572445e35e5993321119ceb491f1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable(feature = \"core\")]\n+#![unstable(feature = \"raw\")]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!"}, {"sha": "998657a236decc786010b0d7011162af30c8be97", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -434,7 +434,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"as_slice\",\n                reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n@@ -966,7 +966,8 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"result_fold\",\n+           reason = \"unclear if this function should exist\")]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "c3447867ce598f710ef99e9052a35d346e3edf00", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -33,10 +33,12 @@\n //! These are all experimental. The interface may change entirely, without\n //! warning.\n \n+#![unstable(feature = \"core_simd\",\n+            reason = \"needs an RFC to flesh out the design\")]\n+\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -45,26 +47,22 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -73,32 +71,27 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]"}, {"sha": "c979b97731b4f1aec4fb8804a937d8e6e918ab09", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -64,6 +64,8 @@ use raw::Slice as RawSlice;\n /// Extension methods for slices.\n #[allow(missing_docs)] // docs in libcollections\n #[doc(hidden)]\n+#[unstable(feature = \"core_slice_ext\",\n+           reason = \"stable interface provided by `impl [T]` in later crates\")]\n pub trait SliceExt {\n     type Item;\n \n@@ -148,7 +150,6 @@ macro_rules! slice_ref {\n     }};\n }\n \n-#[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -256,7 +257,6 @@ impl<T> SliceExt for [T] {\n         self.repr().data\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize> where\n         F: FnMut(&T) -> Ordering\n     {\n@@ -437,12 +437,10 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[m-n..]\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -473,7 +471,6 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[unstable(feature = \"core\")]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -774,7 +771,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"iter_to_slice\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(self.ptr, self.end)\n     }\n@@ -804,7 +801,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n }\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -842,7 +839,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[unstable(feature = \"core\")]\n+    #[unstable(feature = \"iter_to_slice\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_mut_slice!(self.ptr, self.end)\n     }\n@@ -1176,7 +1173,7 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1263,7 +1260,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1349,15 +1346,15 @@ impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"ref_slice\")]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         from_raw_parts(s, 1)\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"ref_slice\")]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         from_raw_parts_mut(s, 1)\n@@ -1415,7 +1412,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[unstable(feature = \"core\", reason = \"needs review\")]\n+#[unstable(feature = \"slice_bytes\", reason = \"needs review\")]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1503,7 +1500,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"int_slice\")]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1518,7 +1515,7 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable(feature = \"core\")]\n+        #[unstable(feature = \"int_slice\")]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "13c6ad367257de4b201e651cc861e2d6e12a66b1", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -13,6 +13,7 @@\n //! For more details, see std::str\n \n #![doc(primitive = \"str\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::OldSearcher::{TwoWay, TwoWayLong};\n use self::pattern::Pattern;\n@@ -191,7 +192,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n \n /// Reads the next code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"str_internals\")]\n #[inline]\n pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n@@ -226,7 +227,7 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n \n /// Reads the last code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"str_internals\")]\n #[inline]\n pub fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n@@ -738,7 +739,7 @@ generate_pattern_iterators! {\n         #[doc=\"Created with the method `.rmatch_indices()`.\"]\n         struct RMatchIndices;\n     stability:\n-        #[unstable(feature = \"core\",\n+        #[unstable(feature = \"str_internals\",\n                    reason = \"type may be removed or have its iterator impl changed\")]\n     internal:\n         MatchIndicesInternal yielding ((usize, usize));\n@@ -779,7 +780,7 @@ generate_pattern_iterators! {\n         #[doc=\"Created with the method `.rmatches()`.\"]\n         struct RMatches;\n     stability:\n-        #[unstable(feature = \"core\", reason = \"type got recently added\")]\n+        #[unstable(feature = \"str_internals\", reason = \"type got recently added\")]\n     internal:\n         MatchesInternal yielding (&'a str);\n     delegate double ended;\n@@ -1470,6 +1471,8 @@ mod traits {\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]\n+#[unstable(feature = \"core_str_ext\",\n+           reason = \"stable interface provided by `impl str` in later crates\")]\n pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here.\n@@ -1870,7 +1873,7 @@ impl AsRef<[u8]> for str {\n /// Pluck a code point out of a UTF-8-like byte slice and return the\n /// index of the next code point.\n #[inline]\n-#[unstable(feature = \"core\")]\n+#[unstable(feature = \"str_internals\")]\n pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n     if bytes[i] < 128 {\n         return (bytes[i] as u32, i + 1);"}, {"sha": "8bdbab55211d8cce2dc735d1d3fd670450098d15", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -13,6 +13,9 @@\n //! For more details, see the traits `Pattern`, `Searcher`,\n //! `ReverseSearcher` and `DoubleEndedSearcher`.\n \n+#![unstable(feature = \"pattern\",\n+            reason = \"API not fully fleshed out and ready to be stabilized\")]\n+\n use prelude::*;\n \n // Pattern"}, {"sha": "35c1cb09281f41cc035500f52014afca66f60754", "filename": "src/libcore/ty.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7a5a1c33a7794a97eb11a38cc576375a3553a64/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a5a1c33a7794a97eb11a38cc576375a3553a64/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=e7a5a1c33a7794a97eb11a38cc576375a3553a64", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types dealing with unsafe actions.\n-\n-use marker;"}, {"sha": "0760ccb723b198ab129c9a20a547f18dc57b6d10", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -172,8 +172,7 @@\n #![feature(alloc)]\n #![feature(staged_api)]\n #![feature(box_syntax)]\n-#![feature(core)]\n-#![feature(const_fn)]\n+#![feature(iter_cmp)]\n #![feature(std_misc)]\n \n use std::boxed;"}, {"sha": "6a6adb0db6b459ce0ac7001d8de135db4acae538", "filename": "src/librand/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -29,7 +29,11 @@\n #![unstable(feature = \"rand\",\n             reason = \"use `rand` from crates.io\")]\n #![feature(core)]\n+#![feature(core_float)]\n+#![feature(core_prelude)]\n+#![feature(core_slice_ext)]\n #![feature(no_std)]\n+#![feature(num_bits_bytes)]\n #![feature(staged_api)]\n #![feature(step_by)]\n "}, {"sha": "18b1d39ea82d80e59f068b35c215e2ccd228d897", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -123,9 +123,9 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(core)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(slice_bytes)]\n \n #![cfg_attr(test, feature(test))]\n "}, {"sha": "944af19a44313cc80c1ed63bb64f4ac7b882d0f1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -30,21 +30,26 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(const_fn)]\n-#![feature(core)]\n #![feature(duration)]\n #![feature(duration_span)]\n #![feature(fs_canonicalize)]\n-#![feature(hash)]\n+#![feature(hash_default)]\n #![feature(into_cow)]\n+#![feature(iter_sum)]\n #![feature(libc)]\n+#![feature(num_bits_bytes)]\n #![feature(path_ext)]\n #![feature(quote)]\n+#![feature(range_inclusive)]\n+#![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_bytes)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(str_char)]\n+#![feature(wrapping)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "e4d0c9aa15f7af458a635d603432f9caa008f4c6", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -34,14 +34,14 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n+#![feature(fs_canonicalize)]\n+#![feature(libc)]\n+#![feature(path_ext)]\n+#![feature(rand)]\n #![feature(rustc_private)]\n+#![feature(slice_bytes)]\n #![feature(staged_api)]\n-#![feature(rand)]\n-#![feature(path_ext)]\n #![feature(step_by)]\n-#![feature(libc)]\n-#![feature(fs_canonicalize)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;"}, {"sha": "88d307610208fe151c33c14d4b5c2dcfc3b238ec", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -32,9 +32,10 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![cfg_attr(stage0, feature(collections))]\n-#![feature(core)]\n+#![feature(collections)]\n+#![feature(num_bits_bytes)]\n #![feature(quote)]\n+#![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "6173e3c8205c1200af41cd2eeb8f47919839cf49", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -29,17 +29,23 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(const_fn)]\n+#![feature(fs)]\n+#![feature(iter_cmp)]\n+#![feature(iter_sum)]\n+#![feature(iter_unfold)]\n #![feature(libc)]\n+#![feature(path_ext)]\n+#![feature(path_ext)]\n+#![feature(path_relative_from)]\n+#![feature(path_relative_from)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(unicode)]\n-#![feature(path_ext)]\n-#![feature(path_relative_from)]\n #![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(unicode)]\n \n #![allow(trivial_casts)]\n "}, {"sha": "f5a7ec4dbd24606d00b40c1a059b67d43a614f3f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -78,8 +78,10 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections, collections_drain)]\n-#![feature(core)]\n+#![feature(iter_cmp)]\n+#![feature(iter_sum)]\n #![feature(quote)]\n+#![feature(ref_slice)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "750df19047d733d51a016e600a3a3fe1e958766e", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -24,18 +24,24 @@\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"rustc_unicode\"]\n #![unstable(feature = \"unicode\")]\n-#![feature(lang_items)]\n-#![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(no_std)]\n+       html_playground_url = \"http://play.rust-lang.org/\",\n+       test(no_crate_inject))]\n #![no_std]\n+\n #![feature(core)]\n-#![doc(test(no_crate_inject))]\n+#![feature(core_char_ext)]\n+#![feature(core_prelude)]\n+#![feature(core_slice_ext)]\n+#![feature(core_str_ext)]\n+#![feature(iter_sum)]\n+#![feature(lang_items)]\n+#![feature(no_std)]\n+#![feature(staged_api)]\n \n extern crate core;\n "}, {"sha": "8170dd957307b9a92b065cc16571040da27d404c", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -29,12 +29,13 @@ Core encoding and decoding interfaces.\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(core)]\n+#![feature(num_bits_bytes)]\n+#![feature(num_wrapping)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(unicode)]\n #![feature(str_char)]\n+#![feature(unicode)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "1677f95ca903980897c818837918e3a5cd11c021", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -77,7 +77,7 @@ pub trait Error: Debug + Display + Reflect {\n \n     /// Get the `TypeId` of `self`\n     #[doc(hidden)]\n-    #[unstable(feature = \"core\",\n+    #[unstable(feature = \"error_type_id\",\n                reason = \"unclear whether to commit to this public implementation detail\")]\n     fn type_id(&self) -> TypeId where Self: 'static {\n         TypeId::of::<Self>()"}, {"sha": "8f7ed6388f575c55b0ffb83ec561863ad842d7a1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -99,38 +99,52 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![doc(test(no_crate_inject, attr(deny(warnings))))]\n-#![doc(test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n+       html_playground_url = \"http://play.rust-lang.org/\",\n+       test(no_crate_inject, attr(deny(warnings))),\n+       test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(box_syntax)]\n+#![feature(char_internals)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(const_fn)]\n+#![feature(core)]\n+#![feature(core_float)]\n+#![feature(core_intrinsics)]\n+#![feature(core_prelude)]\n+#![feature(core_simd)]\n+#![feature(fnbox)]\n+#![feature(int_error_internals)]\n #![feature(into_cow)]\n+#![feature(iter_order)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n #![feature(macro_reexport)]\n+#![feature(no_std)]\n+#![feature(num_bits_bytes)]\n #![feature(optin_builtin_traits)]\n #![feature(rand)]\n+#![feature(raw)]\n+#![feature(reflect_marker)]\n+#![feature(slice_bytes)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(str_char)]\n+#![feature(str_internals)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(wrapping)]\n #![feature(zero_one)]\n #![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std.\n-#![feature(no_std)]\n #![no_std]\n \n #![allow(trivial_casts)]"}, {"sha": "432cdbdfef05ea4e1564bb9a71ea26b93a28f35d", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d86fd3ff3ba2d01a6e859290b30e74081313b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c14d86fd3ff3ba2d01a6e859290b30e74081313b", "patch": "@@ -28,8 +28,9 @@\n #![feature(associated_consts)]\n #![feature(collections)]\n #![feature(collections_drain)]\n-#![feature(core)]\n+#![feature(filling_drop)]\n #![feature(libc)]\n+#![feature(ref_slice)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_char)]"}]}