{"sha": "2a3355920777956d537db7a0f4c278a280af9abb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMzM1NTkyMDc3Nzk1NmQ1MzdkYjdhMGY0YzI3OGEyODBhZjlhYmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-04-11T18:58:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-04-13T16:47:00Z"}, "message": "rustbuild: Fix recompilation of stage0 tools dir\n\nThis commit knocks out a longstanding FIXME in rustbuild which should correctly\nrecompile stage0 compiletest and such whenever libstd itself changes. The\nsolution implemented here was to implement a notion of \"order only\" dependencies\nand then add a new dependency stage for clearing out the tools dir, using\norder-only deps to ensure that it happens correctly.\n\nThe dependency drawing for tools is a bit wonky now but I think this'll get the\njob done.\n\nCloses #39396", "tree": {"sha": "6bba96015aea04da4e39a5a5902bbfb7a0d79fd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bba96015aea04da4e39a5a5902bbfb7a0d79fd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a3355920777956d537db7a0f4c278a280af9abb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3355920777956d537db7a0f4c278a280af9abb", "html_url": "https://github.com/rust-lang/rust/commit/2a3355920777956d537db7a0f4c278a280af9abb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a3355920777956d537db7a0f4c278a280af9abb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43ef63d5b4279ef97ed921338a69b0d62101ca83", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ef63d5b4279ef97ed921338a69b0d62101ca83", "html_url": "https://github.com/rust-lang/rust/commit/43ef63d5b4279ef97ed921338a69b0d62101ca83"}], "stats": {"total": 209, "additions": 167, "deletions": 42}, "files": [{"sha": "bddd570a13d2640bfc26b8d63fb769e9f76fad95", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2a3355920777956d537db7a0f4c278a280af9abb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3355920777956d537db7a0f4c278a280af9abb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2a3355920777956d537db7a0f4c278a280af9abb", "patch": "@@ -275,6 +275,7 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n         cargo.env(\"CFG_DEFAULT_AR\", s);\n     }\n     build.run(&mut cargo);\n+    update_mtime(build, &librustc_stamp(build, compiler, target));\n }\n \n /// Same as `std_link`, only for librustc\n@@ -305,6 +306,12 @@ fn libtest_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n }\n \n+/// Cargo's output path for librustc in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+fn librustc_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n+}\n+\n fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n     let out = output(Command::new(compiler)\n                             .arg(format!(\"-print-file-name={}\", file)));\n@@ -407,6 +414,23 @@ fn add_to_sysroot(out_dir: &Path, sysroot_dst: &Path) {\n     }\n }\n \n+/// Build a tool in `src/tools`\n+///\n+/// This will build the specified tool with the specified `host` compiler in\n+/// `stage` into the normal cargo output directory.\n+pub fn maybe_clean_tools(build: &Build, stage: u32, target: &str, mode: Mode) {\n+    let compiler = Compiler::new(stage, &build.config.build);\n+\n+    let stamp = match mode {\n+        Mode::Libstd => libstd_stamp(build, &compiler, target),\n+        Mode::Libtest => libtest_stamp(build, &compiler, target),\n+        Mode::Librustc => librustc_stamp(build, &compiler, target),\n+        _ => panic!(),\n+    };\n+    let out_dir = build.cargo_out(&compiler, Mode::Tool, target);\n+    build.clear_if_dirty(&out_dir, &stamp);\n+}\n+\n /// Build a tool in `src/tools`\n ///\n /// This will build the specified tool with the specified `host` compiler in\n@@ -416,15 +440,6 @@ pub fn tool(build: &Build, stage: u32, target: &str, tool: &str) {\n \n     let compiler = Compiler::new(stage, &build.config.build);\n \n-    // FIXME: need to clear out previous tool and ideally deps, may require\n-    //        isolating output directories or require a pseudo shim step to\n-    //        clear out all the info.\n-    //\n-    //        Maybe when libstd is compiled it should clear out the rustc of the\n-    //        corresponding stage?\n-    // let out_dir = build.cargo_out(stage, &host, Mode::Librustc, target);\n-    // build.clear_if_dirty(&out_dir, &libstd_stamp(build, stage, &host, target));\n-\n     let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n     let mut dir = build.src.join(tool);\n     if !dir.exists() {"}, {"sha": "6008fa81c66537cc15765787d1bf5f202ddcd2bd", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 143, "deletions": 33, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/2a3355920777956d537db7a0f4c278a280af9abb/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3355920777956d537db7a0f4c278a280af9abb/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=2a3355920777956d537db7a0f4c278a280af9abb", "patch": "@@ -26,7 +26,7 @@\n //! along with the actual implementation elsewhere. You can find more comments\n //! about how to define rules themselves below.\n \n-use std::collections::{BTreeMap, HashSet};\n+use std::collections::{BTreeMap, HashSet, HashMap};\n use std::mem;\n \n use check::{self, TestKind};\n@@ -533,34 +533,44 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     //\n     // Tools used during the build system but not shipped\n     rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n-         .dep(|s| s.name(\"librustc\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"librustc-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n     rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n-         .dep(|s| s.name(\"librustc\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"librustc-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n     rules.build(\"tool-tidy\", \"src/tools/tidy\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n     rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n     rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n     rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n-         .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libtest-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n     rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n     rules.build(\"tool-qemu-test-server\", \"src/tools/qemu-test-server\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"qemu-test-server\"));\n     rules.build(\"tool-qemu-test-client\", \"src/tools/qemu-test-client\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"qemu-test-client\"));\n     rules.build(\"tool-cargo\", \"cargo\")\n-         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n          .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n          .dep(move |s| {\n              // Cargo depends on procedural macros, which requires a full host\n@@ -572,7 +582,8 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n     rules.build(\"tool-rls\", \"rls\")\n          .host(true)\n-         .dep(|s| s.name(\"librustc\"))\n+         .dep(|s| s.name(\"librustc-tool\"))\n+         .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n          .dep(move |s| {\n              // rls, like cargo, uses procedural macros\n              s.name(\"librustc-link\")\n@@ -581,6 +592,25 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          })\n          .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n \n+    // \"pseudo rule\" which represents completely cleaning out the tools dir in\n+    // one stage. This needs to happen whenever a dependency changes (e.g.\n+    // libstd, libtest, librustc) and all of the tool compilations above will\n+    // be sequenced after this rule.\n+    rules.build(\"maybe-clean-tools\", \"path/to/nowhere\")\n+         .after(\"librustc-tool\")\n+         .after(\"libtest-tool\")\n+         .after(\"libstd-tool\");\n+\n+    rules.build(\"librustc-tool\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"librustc\"))\n+         .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Librustc));\n+    rules.build(\"libtest-tool\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libtest));\n+    rules.build(\"libstd-tool\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libstd));\n+\n     // ========================================================================\n     // Documentation targets\n     rules.doc(\"doc-book\", \"src/doc/book\")\n@@ -828,6 +858,11 @@ struct Rule<'a> {\n     /// Whether this rule is only for the build triple, not anything in hosts or\n     /// targets.\n     only_build: bool,\n+\n+    /// A list of \"order only\" dependencies. This rules does not actually\n+    /// depend on these rules, but if they show up in the dependency graph then\n+    /// this rule must be executed after all these rules.\n+    after: Vec<&'a str>,\n }\n \n #[derive(PartialEq)]\n@@ -851,6 +886,7 @@ impl<'a> Rule<'a> {\n             host: false,\n             only_host_build: false,\n             only_build: false,\n+            after: Vec::new(),\n         }\n     }\n }\n@@ -870,6 +906,11 @@ impl<'a, 'b> RuleBuilder<'a, 'b> {\n         self\n     }\n \n+    fn after(&mut self, step: &'a str) -> &mut Self {\n+        self.rule.after.push(step);\n+        self\n+    }\n+\n     fn run<F>(&mut self, f: F) -> &mut Self\n         where F: Fn(&Step<'a>) + 'a,\n     {\n@@ -1153,31 +1194,52 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n     /// From the top level targets `steps` generate a topological ordering of\n     /// all steps needed to run those steps.\n     fn expand(&self, steps: &[Step<'a>]) -> Vec<Step<'a>> {\n+        // First up build a graph of steps and their dependencies. The `nodes`\n+        // map is a map from step to a unique number. The `edges` map is a\n+        // map from these unique numbers to a list of other numbers,\n+        // representing dependencies.\n+        let mut nodes = HashMap::new();\n+        nodes.insert(Step::noop(), 0);\n+        let mut edges = HashMap::new();\n+        edges.insert(0, HashSet::new());\n+        for step in steps {\n+            self.build_graph(step.clone(), &mut nodes, &mut edges);\n+        }\n+\n+        // Now that we've built up the actual dependency graph, draw more\n+        // dependency edges to satisfy the `after` dependencies field for each\n+        // rule.\n+        self.satisfy_after_deps(&nodes, &mut edges);\n+\n+        // And finally, perform a topological sort to return a list of steps to\n+        // execute.\n         let mut order = Vec::new();\n-        let mut added = HashSet::new();\n-        added.insert(Step::noop());\n-        for step in steps.iter().cloned() {\n-            self.fill(step, &mut order, &mut added);\n+        let mut visited = HashSet::new();\n+        visited.insert(0);\n+        let idx_to_node = nodes.iter().map(|p| (*p.1, p.0)).collect::<HashMap<_, _>>();\n+        for idx in nodes.values() {\n+            self.topo_sort(*idx, &idx_to_node, &edges, &mut visited, &mut order);\n         }\n         return order\n     }\n \n-    /// Performs topological sort of dependencies rooted at the `step`\n-    /// specified, pushing all results onto the `order` vector provided.\n+    /// Builds the dependency graph rooted at `step`.\n     ///\n-    /// In other words, when this method returns, the `order` vector will\n-    /// contain a list of steps which if executed in order will eventually\n-    /// complete the `step` specified as well.\n-    ///\n-    /// The `added` set specified here is the set of steps that are already\n-    /// present in `order` (and hence don't need to be added again).\n-    fn fill(&self,\n-            step: Step<'a>,\n-            order: &mut Vec<Step<'a>>,\n-            added: &mut HashSet<Step<'a>>) {\n-        if !added.insert(step.clone()) {\n-            return\n+    /// The `nodes` and `edges` maps are filled out according to the rule\n+    /// described by `step.name`.\n+    fn build_graph(&self,\n+                   step: Step<'a>,\n+                   nodes: &mut HashMap<Step<'a>, usize>,\n+                   edges: &mut HashMap<usize, HashSet<usize>>) -> usize {\n+        use std::collections::hash_map::Entry;\n+\n+        let idx = nodes.len();\n+        match nodes.entry(step.clone()) {\n+            Entry::Vacant(e) => { e.insert(idx); }\n+            Entry::Occupied(e) => return *e.get(),\n         }\n+\n+        let mut deps = Vec::new();\n         for dep in self.rules[step.name].deps.iter() {\n             let dep = dep(&step);\n             if dep.name.starts_with(\"default:\") {\n@@ -1189,13 +1251,61 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n                 let host = self.build.config.host.iter().any(|h| h == dep.target);\n                 let rules = self.rules.values().filter(|r| r.default);\n                 for rule in rules.filter(|r| r.kind == kind && (!r.host || host)) {\n-                    self.fill(dep.name(rule.name), order, added);\n+                    deps.push(self.build_graph(dep.name(rule.name), nodes, edges));\n                 }\n             } else {\n-                self.fill(dep, order, added);\n+                deps.push(self.build_graph(dep, nodes, edges));\n+            }\n+        }\n+\n+        edges.entry(idx).or_insert(HashSet::new()).extend(deps);\n+        return idx\n+    }\n+\n+    /// Given a dependency graph with a finished list of `nodes`, fill out more\n+    /// dependency `edges`.\n+    ///\n+    /// This is the step which satisfies all `after` listed dependencies in\n+    /// `Rule` above.\n+    fn satisfy_after_deps(&self,\n+                          nodes: &HashMap<Step<'a>, usize>,\n+                          edges: &mut HashMap<usize, HashSet<usize>>) {\n+        // Reverse map from the name of a step to the node indices that it\n+        // appears at.\n+        let mut name_to_idx = HashMap::new();\n+        for (step, &idx) in nodes {\n+            name_to_idx.entry(step.name).or_insert(Vec::new()).push(idx);\n+        }\n+\n+        for (step, idx) in nodes {\n+            if *step == Step::noop() {\n+                continue\n+            }\n+            for after in self.rules[step.name].after.iter() {\n+                // This is the critical piece of an `after` dependency. If the\n+                // dependency isn't actually in our graph then no edge is drawn,\n+                // only if it's already present do we draw the edges.\n+                if let Some(idxs) = name_to_idx.get(after) {\n+                    edges.get_mut(idx).unwrap()\n+                         .extend(idxs.iter().cloned());\n+                }\n             }\n         }\n-        order.push(step);\n+    }\n+\n+    fn topo_sort(&self,\n+                 cur: usize,\n+                 nodes: &HashMap<usize, &Step<'a>>,\n+                 edges: &HashMap<usize, HashSet<usize>>,\n+                 visited: &mut HashSet<usize>,\n+                 order: &mut Vec<Step<'a>>) {\n+        if !visited.insert(cur) {\n+            return\n+        }\n+        for dep in edges[&cur].iter() {\n+            self.topo_sort(*dep, nodes, edges, visited, order);\n+        }\n+        order.push(nodes[&cur].clone());\n     }\n }\n "}]}