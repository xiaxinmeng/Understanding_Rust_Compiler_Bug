{"sha": "e849f9be59d7c21a65af7d5f655b1691f5da3870", "node_id": "C_kwDOAAsO6NoAKGU4NDlmOWJlNTlkN2MyMWE2NWFmN2Q1ZjY1NWIxNjkxZjVkYTM4NzA", "commit": {"author": {"name": "David Rheinsberg", "email": "david.rheinsberg@gmail.com", "date": "2022-07-26T12:39:01Z"}, "committer": {"name": "David Rheinsberg", "email": "david.rheinsberg@gmail.com", "date": "2022-07-27T12:08:18Z"}, "message": "doc/rustc: describe the uefi target platforms\n\nAdd a `platform-support` entry to the rustc-docs for the different\n`*-unknown-uefi` targets. This describes in detail how this platform\nworks, a few basic examples, and how to compile for the platform.\n\nRed Hat is sponsoring my work on this platform, so I am putting myself\ndown as target maintainer. Co-maintainers are more than welcome to join\nme in the effort. Communication is going on off-list to coordinate the\ndifferent efforts.\n\nNote that the ultimate goal is to move the UEFI targets to Tier-2 so\nbootloaders can be more easily supported in commercial products. This\ndocumentation is the first step towards that goal, but should be a\nviable documentation even for the current Tier-3 status of the targets.\n\nI also want to point out that there is an ongoing GSoC-effort to port\nthe rust standard library to UEFI (by Ayush Singh). While this work is\nnot necessarily required to get to Tier-2, we definitely should\ncoordinate the efforts and update the documentation as soon as any such\nports are merged.\n\nNote that the targets are already used by multiple commercial and non\ncommercial production systems, including, but not limited to:\n\n * Tianocore-EDK2 (Official UEFI SDK by Intel) comes with rust support\n   in its staging repository (not part of any release, yet).\n   (https://github.com/tianocore/edk2-staging/tree)\n * Intel's research program \"Project Mu\" uses the rust UEFI targets to\n   show possible future replacements for Tianocore-EDK2.\n * The Rust OS \"Redox\" uses the UEFI targets for its bootloader.\n   (https://www.redox-os.org/)\n * The hugely popular in-depth documentation of OS development in Rust\n   by Philipp Oppermann uses the UEFI targets.\n   (https://os.phil-opp.com/)\n\nSigned-off-by: David Rheinsberg <david.rheinsberg@gmail.com>", "tree": {"sha": "ca2fe94b815c31661fb4f004a653d3138aa40a54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca2fe94b815c31661fb4f004a653d3138aa40a54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e849f9be59d7c21a65af7d5f655b1691f5da3870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e849f9be59d7c21a65af7d5f655b1691f5da3870", "html_url": "https://github.com/rust-lang/rust/commit/e849f9be59d7c21a65af7d5f655b1691f5da3870", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e849f9be59d7c21a65af7d5f655b1691f5da3870/comments", "author": {"login": "dvdhrm", "id": 623857, "node_id": "MDQ6VXNlcjYyMzg1Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/623857?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvdhrm", "html_url": "https://github.com/dvdhrm", "followers_url": "https://api.github.com/users/dvdhrm/followers", "following_url": "https://api.github.com/users/dvdhrm/following{/other_user}", "gists_url": "https://api.github.com/users/dvdhrm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvdhrm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvdhrm/subscriptions", "organizations_url": "https://api.github.com/users/dvdhrm/orgs", "repos_url": "https://api.github.com/users/dvdhrm/repos", "events_url": "https://api.github.com/users/dvdhrm/events{/privacy}", "received_events_url": "https://api.github.com/users/dvdhrm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dvdhrm", "id": 623857, "node_id": "MDQ6VXNlcjYyMzg1Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/623857?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvdhrm", "html_url": "https://github.com/dvdhrm", "followers_url": "https://api.github.com/users/dvdhrm/followers", "following_url": "https://api.github.com/users/dvdhrm/following{/other_user}", "gists_url": "https://api.github.com/users/dvdhrm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvdhrm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvdhrm/subscriptions", "organizations_url": "https://api.github.com/users/dvdhrm/orgs", "repos_url": "https://api.github.com/users/dvdhrm/repos", "events_url": "https://api.github.com/users/dvdhrm/events{/privacy}", "received_events_url": "https://api.github.com/users/dvdhrm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b", "html_url": "https://github.com/rust-lang/rust/commit/96b9bb4620f4d48aa25c381c7ea77e0cab48ac5b"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "736c30694cddb8ee5fe906d1378b572851fd2263", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e849f9be59d7c21a65af7d5f655b1691f5da3870/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/e849f9be59d7c21a65af7d5f655b1691f5da3870/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=e849f9be59d7c21a65af7d5f655b1691f5da3870", "patch": "@@ -28,6 +28,7 @@\n     - [riscv32imac-unknown-xous-elf](platform-support/riscv32imac-unknown-xous-elf.md)\n     - [*-pc-windows-gnullvm](platform-support/pc-windows-gnullvm.md)\n     - [*-unknown-openbsd](platform-support/openbsd.md)\n+    - [\\*-unknown-uefi](platform-support/unknown-uefi.md)\n     - [wasm64-unknown-unknown](platform-support/wasm64-unknown-unknown.md)\n     - [x86_64-unknown-none](platform-support/x86_64-unknown-none.md)\n - [Targets](targets/index.md)"}, {"sha": "8f90d9c7453d0a81e479f4ed8eb473cc5e028a4c", "filename": "src/doc/rustc/src/platform-support/unknown-uefi.md", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/e849f9be59d7c21a65af7d5f655b1691f5da3870/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "raw_url": "https://github.com/rust-lang/rust/raw/e849f9be59d7c21a65af7d5f655b1691f5da3870/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md?ref=e849f9be59d7c21a65af7d5f655b1691f5da3870", "patch": "@@ -0,0 +1,254 @@\n+# `*-unknown-uefi`\n+\n+**Tier: 3**\n+\n+Unified Extensible Firmware Interface (UEFI) targets for application, driver,\n+and core UEFI binaries.\n+\n+Available targets:\n+\n+- `aarch64-unknown-uefi`\n+- `i686-unknown-uefi`\n+- `x86_64-unknown-uefi`\n+\n+## Target maintainers\n+\n+- David Rheinsberg ([@dvdhrm](https://github.com/dvdhrm))\n+- Nicholas Bishop ([@nicholasbishop](https://github.com/nicholasbishop))\n+\n+## Requirements\n+\n+All UEFI targets can be used as `no-std` environments via cross-compilation.\n+Support for `std` is missing, but actively worked on. `alloc` is supported if\n+an allocator is provided by the user. No host tools are supported.\n+\n+The UEFI environment resembles the environment for Microsoft Windows, with some\n+minor differences. Therefore, cross-compiling for UEFI works with the same\n+tools as cross-compiling for Windows. The target binaries are PE32+ encoded,\n+the calling convention is different for each architecture, but matches what\n+Windows uses (if the architecture is supported by Windows). The special\n+`efiapi` Rust calling-convention chooses the right ABI for the target platform\n+(`extern \"C\"` is incorrect on Intel targets at least). The specification has an\n+elaborate section on the different supported calling-conventions, if more\n+details are desired.\n+\n+MMX, SSE, and other FP-units are disabled by default, to allow for compilation\n+of core UEFI code that runs before they are set up. This can be overridden for\n+individual compilations via rustc command-line flags. Not all firmwares\n+correctly configure those units, though, so careful inspection is required.\n+\n+As native to PE32+, binaries are position-dependent, but can be relocated at\n+runtime if their desired location is unavailable. The code must be statically\n+linked. Dynamic linking is not supported. Code is shared via UEFI interfaces,\n+rather than dynamic linking. Additionally, UEFI forbids running code on\n+anything but the boot CPU/thread, nor is interrupt-usage allowed (apart from\n+the timer interrupt). Device drivers are required to use polling methods.\n+\n+UEFI uses a single address-space to run all code in. Multiple applications can\n+be loaded simultaneously and are dispatched via cooperative multitasking on a\n+single stack.\n+\n+By default, the UEFI targets use the `link`-flavor of the LLVM linker `lld` to\n+link binaries into the final PE32+ file suffixed with `*.efi`. The PE subsystem\n+is set to `EFI_APPLICATION`, but can be modified by passing `/subsystem:<...>`\n+to the linker. Similarly, the entry-point is to to `efi_main` but can be\n+changed via `/entry:<...>`. The panic-strategy is set to `abort`,\n+\n+The UEFI specification is available online for free:\n+[UEFI Specification Directory](https://uefi.org/specifications)\n+\n+## Building rust for UEFI targets\n+\n+Rust can be built for the UEFI targets by enabling them in the `rustc` build\n+configuration. Note that you can only build the standard libraries. The\n+compiler and host tools currently cannot be compiled for UEFI targets. A sample\n+configuration would be:\n+\n+```toml\n+[build]\n+build-stage = 1\n+target = [\"x86_64-unknown-uefi\"]\n+```\n+\n+## Building Rust programs\n+\n+Rust does not yet ship pre-compiled artifacts for this target. To compile for\n+this target, you will either need to build Rust with the target enabled (see\n+\"Building rust for UEFI targets\" above), or build your own copy of `core` by\n+using `build-std`, `cargo-buildx`, or similar.\n+\n+A native build with the unstable `build-std`-feature can be achieved via:\n+\n+```sh\n+cargo +nightly build \\\n+    -Zbuild-std=core,compiler_builtins \\\n+    -Zbuild-std-features=compiler-builtins-mem \\\n+    --target x86_64-unknown-uefi\n+```\n+\n+Alternatively, you can install `cargo-xbuild` via\n+`cargo install --force cargo-xbuild` and build for the UEFI targets via:\n+\n+```sh\n+cargo \\\n+    +nightly \\\n+    xbuild \\\n+    --target x86_64-unknown-uefi\n+```\n+\n+## Testing\n+\n+UEFI applications can be copied into the ESP on any UEFI system and executed\n+via the firmware boot menu. The qemu suite allows emulating UEFI systems and\n+executing UEFI applications as well. See its documentation for details.\n+\n+The [uefi-run](https://github.com/Richard-W/uefi-run) rust tool is a simple\n+wrapper around `qemu` that can spawn UEFI applications in qemu. You can install\n+it via `cargo install uefi-run` and execute qemu applications as\n+`uefi-run ./application.efi`.\n+\n+## Cross-compilation toolchains and C code\n+\n+There are 3 common ways to compile native C code for UEFI targets:\n+\n+- Use the official SDK by Intel:\n+  [Tianocore/EDK2](https://github.com/tianocore/edk2). This supports a\n+  multitude of platforms, comes with the full specification transposed into C,\n+  lots of examples and build-system integrations. This is also the only\n+  officially supported platform by Intel, and is used by many major firmware\n+  implementations. Any code compiled via the SDK is compatible to rust binaries\n+  compiled for the UEFI targets. You can link them directly into your rust\n+  binaries, or call into each other via UEFI protocols.\n+- Use the **GNU-EFI** suite. This approach is used by many UEFI applications\n+  in the Linux/OSS ecosystem. The GCC compiler is used to compile ELF binaries,\n+  and linked with a pre-loader that converts the ELF binary to PE32+\n+  **at runtime**. You can combine such binaries with the rust UEFI targets only\n+  via UEFI protocols. Linking both into the same executable will fail, since\n+  one is an ELF executable, and one a PE32+. If linking to **GNU-EFI**\n+  executables is desired, you must compile your rust code natively for the same\n+  GNU target as **GNU-EFI** and use their pre-loader. This requires careful\n+  consideration about which calling-convention to use when calling into native\n+  UEFI protocols, or calling into linked **GNU-EFI** code (similar to how these\n+  differences need to be accounted for when writing **GNU-EFI** C code).\n+- Use native Windows targets. This means compiling your C code for the Windows\n+  platform as if it was the UEFI platform. This works for static libraries, but\n+  needs adjustments when linking into an UEFI executable. You can, however,\n+  link such static libraries seemlessly into rust code compiled for UEFI\n+  targets. Be wary of any includes that are not specifically suitable for UEFI\n+  targets (especially the C standard library includes are not always\n+  compatible). Freestanding compilations are recommended to avoid\n+  incompatibilites.\n+\n+## Ecosystem\n+\n+The rust language has a long history of supporting UEFI targets. Many crates\n+have been developed to provide access to UEFI protocols and make UEFI\n+programming more ergonomic in rust. The following list is a short overview (in\n+alphabetical ordering):\n+\n+- **efi**: *Ergonomic Rust bindings for writing UEFI applications*. Provides\n+  _rustified_ access to UEFI protocols, implements allocators and a safe\n+  environment to write UEFI applications.\n+- **r-efi**: *UEFI Reference Specification Protocol Constants and Definitions*.\n+  A pure transpose of the UEFI specification into rust. This provides the raw\n+  definitions from the specification, without any extended helpers or\n+  _rustification_. It serves as baseline to implement any more elaborate rust\n+  UEFI layers.\n+- **uefi-rs**: *Safe and easy-to-use wrapper for building UEFI apps*. An\n+  elaborate library providing safe abstractions for UEFI protocols and\n+  features. It implements allocators and provides an execution environment to\n+  UEFI applications written in rust.\n+- **uefi-run**: *Run UEFI applications*. A small wrapper around _qemu_ to spawn\n+  UEFI applications in an emulated `x86_64` machine.\n+\n+## Example: Freestanding\n+\n+The following code is a valid UEFI application returning immediately upon\n+execution with an exit code of 0. A panic handler is provided. This is executed\n+by rust on panic. For simplicity, we simply end up in an infinite loop.\n+\n+Note that as of rust-1.31.0, all features used here are stabilized. No unstable\n+features are required, nor do we rely on nightly compilers. However, if you do\n+not compile rustc for the UEFI targets, you need a nightly compiler to support\n+the `-Z build-std` flag.\n+\n+This example can be compiled as binary crate via `cargo`:\n+\n+```sh\n+cargo +nightly build \\\n+    -Zbuild-std=core,compiler_builtins \\\n+    -Zbuild-std-features=compiler-builtins-mem \\\n+    --target x86_64-unknown-uefi\n+```\n+\n+```rust,ignore (platform-specific,eh-personality-is-unstable)\n+#![no_main]\n+#![no_std]\n+\n+#[panic_handler]\n+fn panic_handler(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[export_name = \"efi_main\"]\n+pub extern \"C\" fn main(_h: *mut core::ffi::c_void, _st: *mut core::ffi::c_void) -> usize {\n+    0\n+}\n+```\n+\n+## Example: Hello World\n+\n+This is an example UEFI application that prints \"Hello World!\", then waits for\n+key input before it exits. It serves as base example how to write UEFI\n+applications without any helper modules other than the standalone UEFI protocol\n+definitions provided by the `r-efi` crate.\n+\n+This extends the \"Freestanding\" example and builds upon its setup. See there\n+for instruction how to compile this as binary crate.\n+\n+Note that UEFI uses UTF-16 strings. Since rust literals are UTF-8, we have to\n+use an open-coded, zero-terminated, UTF-16 array as argument to\n+`output_string()`. Similarly to the panic handler, real applications should\n+rather use UTF-16 modules.\n+\n+```rust,ignore (platform-specific,eh-personality-is-unstable)\n+#![no_main]\n+#![no_std]\n+\n+use r_efi::efi;\n+\n+#[panic_handler]\n+fn panic_handler(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[export_name = \"efi_main\"]\n+pub extern \"C\" fn main(_h: efi::Handle, st: *mut efi::SystemTable) -> efi::Status {\n+    let s = [\n+        0x0048u16, 0x0065u16, 0x006cu16, 0x006cu16, 0x006fu16, // \"Hello\"\n+        0x0020u16, //                                             \" \"\n+        0x0057u16, 0x006fu16, 0x0072u16, 0x006cu16, 0x0064u16, // \"World\"\n+        0x0021u16, //                                             \"!\"\n+        0x000au16, //                                             \"\\n\"\n+        0x0000u16, //                                             NUL\n+    ];\n+\n+    // Print \"Hello World!\".\n+    let r =\n+        unsafe { ((*(*st).con_out).output_string)((*st).con_out, s.as_ptr() as *mut efi::Char16) };\n+    if r.is_error() {\n+        return r;\n+    }\n+\n+    // Wait for key input, by waiting on the `wait_for_key` event hook.\n+    let r = unsafe {\n+        let mut x: usize = 0;\n+        ((*(*st).boot_services).wait_for_event)(1, &mut (*(*st).con_in).wait_for_key, &mut x)\n+    };\n+    if r.is_error() {\n+        return r;\n+    }\n+\n+    efi::Status::SUCCESS\n+}\n+```"}]}