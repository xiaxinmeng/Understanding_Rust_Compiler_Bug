{"sha": "53403ee8bd9d9fde1a025dba5e88392cfdbc6035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDAzZWU4YmQ5ZDlmZGUxYTAyNWRiYTVlODgzOTJjZmRiYzYwMzU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-05T05:17:31Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-05T05:22:24Z"}, "message": "WIP: Add some support for tuples. Optimize memory copies.", "tree": {"sha": "d1fbc95b8d0d45ce410db04a9f376447058c1a00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1fbc95b8d0d45ce410db04a9f376447058c1a00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53403ee8bd9d9fde1a025dba5e88392cfdbc6035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53403ee8bd9d9fde1a025dba5e88392cfdbc6035", "html_url": "https://github.com/rust-lang/rust/commit/53403ee8bd9d9fde1a025dba5e88392cfdbc6035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53403ee8bd9d9fde1a025dba5e88392cfdbc6035/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "url": "https://api.github.com/repos/rust-lang/rust/commits/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a", "html_url": "https://github.com/rust-lang/rust/commit/83fbfb95c03d2cb3dee8b1adf9e24687b2cdf99a"}], "stats": {"total": 199, "additions": 129, "deletions": 70}, "files": [{"sha": "c031876753616e8126072d0da0e6a0dde004a0cb", "filename": "src/interpreter.rs", "status": "modified", "additions": 111, "deletions": 70, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/53403ee8bd9d9fde1a025dba5e88392cfdbc6035/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53403ee8bd9d9fde1a025dba5e88392cfdbc6035/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=53403ee8bd9d9fde1a025dba5e88392cfdbc6035", "patch": "@@ -3,8 +3,10 @@\n \n use byteorder;\n use byteorder::ByteOrder;\n-use rustc::middle::{const_eval, def_id, ty};\n+use rustc::middle::const_eval;\n+use rustc::middle::def_id;\n use rustc::middle::cstore::CrateStore;\n+use rustc::middle::ty::{self, TyCtxt};\n use rustc::mir::repr::{self as mir, Mir};\n use rustc::mir::mir_map::MirMap;\n use std::collections::HashMap;\n@@ -22,6 +24,9 @@ mod memory {\n     use rustc::middle::ty;\n     use std::collections::HashMap;\n     use std::mem;\n+    use std::ops::Add;\n+    use std::ptr;\n+    use super::{EvalError, EvalResult};\n \n     pub struct Memory {\n         next_id: u64,\n@@ -36,7 +41,8 @@ mod memory {\n         AllocId(i)\n     }\n \n-    // TODO(tsion): Shouldn't clone values.\n+    // TODO(tsion): Shouldn't clone Values. (Audit the rest of the code.)\n+    // TODO(tsion): Rename to Allocation.\n     #[derive(Clone, Debug)]\n     pub struct Value {\n         pub bytes: Vec<u8>,\n@@ -51,46 +57,80 @@ mod memory {\n         pub repr: Repr,\n     }\n \n+    #[derive(Clone, Debug, PartialEq, Eq)]\n+    pub struct FieldRepr {\n+        pub offset: usize,\n+        pub repr: Repr,\n+    }\n+\n     #[derive(Clone, Debug, PartialEq, Eq)]\n     pub enum Repr {\n         Int,\n-\n-        StackFrame {\n-            locals: Vec<Repr>,\n-        }\n+        Aggregate {\n+            size: usize,\n+            fields: Vec<FieldRepr>,\n+        },\n     }\n \n     impl Memory {\n         pub fn new() -> Self {\n             Memory { next_id: 0, alloc_map: HashMap::new() }\n         }\n \n-        pub fn allocate(&mut self, size: usize) -> AllocId {\n+        pub fn allocate_raw(&mut self, size: usize) -> AllocId {\n             let id = AllocId(self.next_id);\n             let val = Value { bytes: vec![0; size] };\n             self.alloc_map.insert(self.next_id, val);\n             self.next_id += 1;\n             id\n         }\n \n+        pub fn allocate(&mut self, repr: Repr) -> Pointer {\n+            Pointer {\n+                alloc_id: self.allocate_raw(repr.size()),\n+                offset: 0,\n+                repr: repr,\n+            }\n+        }\n+\n         pub fn allocate_int(&mut self, n: i64) -> AllocId {\n-            let id = self.allocate(mem::size_of::<i64>());\n+            let id = self.allocate_raw(mem::size_of::<i64>());\n             byteorder::NativeEndian::write_i64(&mut self.value_mut(id).unwrap().bytes, n);\n             id\n         }\n \n-        pub fn value(&self, id: AllocId) -> Option<&Value> {\n-            self.alloc_map.get(&id.0)\n+        pub fn value(&self, id: AllocId) -> EvalResult<&Value> {\n+            self.alloc_map.get(&id.0).ok_or(EvalError::DanglingPointerDeref)\n         }\n \n-        pub fn value_mut(&mut self, id: AllocId) -> Option<&mut Value> {\n-            self.alloc_map.get_mut(&id.0)\n+        pub fn value_mut(&mut self, id: AllocId) -> EvalResult<&mut Value> {\n+            self.alloc_map.get_mut(&id.0).ok_or(EvalError::DanglingPointerDeref)\n+        }\n+\n+        pub fn copy(&mut self, src: &Pointer, dest: &Pointer, size: usize) -> EvalResult<()> {\n+            let src_bytes = try!(self.value_mut(src.alloc_id))\n+                .bytes[src.offset..src.offset + size].as_mut_ptr();\n+            let dest_bytes = try!(self.value_mut(dest.alloc_id))\n+                .bytes[dest.offset..dest.offset + size].as_mut_ptr();\n+\n+            // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n+            // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n+            // `dest` could possibly overlap.\n+            unsafe {\n+                if src.alloc_id == dest.alloc_id {\n+                    ptr::copy(src_bytes, dest_bytes, size);\n+                } else {\n+                    ptr::copy_nonoverlapping(src_bytes, dest_bytes, size);\n+                }\n+            }\n+\n+            Ok(())\n         }\n     }\n \n     impl Pointer {\n-        pub fn offset(self, i: usize) -> Self {\n-            Pointer { offset: self.offset + i, ..self }\n+        pub fn offset(&self, i: usize) -> Self {\n+            Pointer { offset: self.offset + i, ..self.clone() }\n         }\n     }\n \n@@ -99,23 +139,36 @@ mod memory {\n         pub fn from_ty(ty: ty::Ty) -> Self {\n             match ty.sty {\n                 ty::TyInt(_) => Repr::Int,\n+\n+                ty::TyTuple(ref fields) => {\n+                    let mut size = 0;\n+                    let fields = fields.iter().map(|ty| {\n+                        let repr = Repr::from_ty(ty);\n+                        let old_size = size;\n+                        size += repr.size();\n+                        FieldRepr { offset: old_size, repr: repr }\n+                    }).collect();\n+                    Repr::Aggregate { size: size, fields: fields }\n+                },\n+\n                 _ => unimplemented!(),\n             }\n         }\n \n         pub fn size(&self) -> usize {\n             match *self {\n                 Repr::Int => 8,\n-                Repr::StackFrame { ref locals } =>\n-                    locals.iter().map(Repr::size).fold(0, |a, b| a + b)\n+                Repr::Aggregate { size, .. } => size,\n             }\n         }\n     }\n }\n use self::memory::{Pointer, Repr, Value};\n \n #[derive(Clone, Debug)]\n-pub struct EvalError;\n+pub enum EvalError {\n+    DanglingPointerDeref\n+}\n \n pub type EvalResult<T> = Result<T, EvalError>;\n \n@@ -199,21 +252,23 @@ impl fmt::Display for EvalError {\n // }\n \n struct Interpreter<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n+    tcx: &'a TyCtxt<'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n     // value_stack: Vec<Value>,\n     // call_stack: Vec<Frame>,\n     memory: memory::Memory,\n+    return_ptr: Option<Pointer>,\n }\n \n impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n-    fn new(tcx: &'a ty::ctxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n+    fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n             tcx: tcx,\n             mir_map: mir_map,\n             // value_stack: vec![Value::Uninit], // Allocate a spot for the top-level return value.\n             // call_stack: Vec::new(),\n             memory: memory::Memory::new(),\n+            return_ptr: None,\n         }\n     }\n \n@@ -251,6 +306,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     // }\n \n     fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) -> EvalResult<()> {\n+        self.return_ptr = return_ptr;\n         // self.push_stack_frame(mir, args, return_ptr);\n         let mut block = mir::START_BLOCK;\n \n@@ -264,7 +320,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 match stmt.kind {\n                     mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                         let ptr = try!(self.lvalue_to_ptr(lvalue));\n-                        try!(self.eval_rvalue_into(rvalue, ptr));\n+                        try!(self.eval_rvalue_into(rvalue, &ptr));\n                     }\n                 }\n             }\n@@ -347,12 +403,8 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n     fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> EvalResult<Pointer> {\n         let ptr = match *lvalue {\n-            mir::Lvalue::ReturnPointer => Pointer {\n-                alloc_id: self::memory::alloc_id_hack(0),\n-                offset: 0,\n-                repr: Repr::Int,\n-            },\n-\n+            mir::Lvalue::ReturnPointer =>\n+                self.return_ptr.clone().expect(\"fn has no return pointer\"),\n             _ => unimplemented!(),\n         };\n \n@@ -403,9 +455,9 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         // }\n     }\n \n-    fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, out: Pointer) {\n-        match (left.repr, right.repr, out.repr) {\n-            (Repr::Int, Repr::Int, Repr::Int) => {\n+    fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, dest: &Pointer) {\n+        match (left.repr, right.repr, &dest.repr) {\n+            (Repr::Int, Repr::Int, &Repr::Int) => {\n                 let l = byteorder::NativeEndian::read_i64(&self.memory.value(left.alloc_id).unwrap().bytes);\n                 let r = byteorder::NativeEndian::read_i64(&self.memory.value(right.alloc_id).unwrap().bytes);\n                 let n = match bin_op {\n@@ -427,25 +479,24 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                     // mir::BinOp::Ge     => Value::Bool(l >= r),\n                     // mir::BinOp::Gt     => Value::Bool(l > r),\n                 };\n-                byteorder::NativeEndian::write_i64(&mut self.memory.value_mut(out.alloc_id).unwrap().bytes, n);\n+                byteorder::NativeEndian::write_i64(&mut self.memory.value_mut(dest.alloc_id).unwrap().bytes, n);\n             }\n-\n-            _ => unimplemented!(),\n+            (ref l, ref r, ref o) =>\n+                panic!(\"unhandled binary operation: {:?}({:?}, {:?}) into {:?}\", bin_op, l, r, o),\n         }\n     }\n \n-    fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, out: Pointer) -> EvalResult<()> {\n+    fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, dest: &Pointer) -> EvalResult<()> {\n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n-                let ptr = try!(self.operand_to_ptr(operand));\n-                let val = self.read_pointer(ptr);\n-                self.write_pointer(out, val);\n+                let src = try!(self.operand_to_ptr(operand));\n+                try!(self.memory.copy(&src, dest, src.repr.size()));\n             }\n \n             mir::Rvalue::BinaryOp(bin_op, ref left, ref right) => {\n                 let left_ptr = try!(self.operand_to_ptr(left));\n                 let right_ptr = try!(self.operand_to_ptr(right));\n-                self.eval_binary_op(bin_op, left_ptr, right_ptr, out)\n+                self.eval_binary_op(bin_op, left_ptr, right_ptr, dest);\n             }\n \n             mir::Rvalue::UnaryOp(un_op, ref operand) => {\n@@ -454,9 +505,23 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 let n = match (un_op, ptr.repr) {\n                     (mir::UnOp::Not, Repr::Int) => !m,\n                     (mir::UnOp::Neg, Repr::Int) => -m,\n-                    _ => unimplemented!(),\n+                    (_, ref p) => panic!(\"unhandled binary operation: {:?}({:?})\", un_op, p),\n                 };\n-                byteorder::NativeEndian::write_i64(&mut self.memory.value_mut(out.alloc_id).unwrap().bytes, n);\n+                byteorder::NativeEndian::write_i64(&mut self.memory.value_mut(dest.alloc_id).unwrap().bytes, n);\n+            }\n+\n+            mir::Rvalue::Aggregate(mir::AggregateKind::Tuple, ref operands) => {\n+                match dest.repr {\n+                    Repr::Aggregate { ref fields, .. } => {\n+                        for (field, operand) in fields.iter().zip(operands) {\n+                            let src = try!(self.operand_to_ptr(operand));\n+                            try!(self.memory.copy(&src, &dest.offset(field.offset), src.repr.size()));\n+                        }\n+                    }\n+\n+                    _ => panic!(\"attempted to write tuple rvalue '{:?}' into non-aggregate pointer '{:?}'\",\n+                                rvalue, dest)\n+                }\n             }\n \n             // mir::Rvalue::Ref(_region, _kind, ref lvalue) => {\n@@ -523,49 +588,25 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n             const_eval::ConstVal::Repeat(_, _)      => unimplemented!(),\n         }\n     }\n-\n-    // fn read_lvalue(&self, lvalue: &mir::Lvalue) -> Value {\n-    //     self.read_pointer(self.lvalue_to_ptr(lvalue))\n-    // }\n-\n-    fn read_pointer(&self, p: Pointer) -> Value {\n-        self.memory.value(p.alloc_id).unwrap().clone()\n-    }\n-\n-    fn write_pointer(&mut self, p: Pointer, val: Value) {\n-        // TODO(tsion): Remove panics.\n-        let alloc = self.memory.value_mut(p.alloc_id).unwrap();\n-        for (i, byte) in val.bytes.into_iter().enumerate() {\n-            alloc.bytes[p.offset + i] = byte;\n-        }\n-    }\n }\n \n-pub fn interpret_start_points<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n     for (&id, mir) in &mir_map.map {\n         for attr in tcx.map.attrs(id) {\n             if attr.check_name(\"miri_run\") {\n                 let item = tcx.map.expect_item(id);\n \n                 println!(\"Interpreting: {}\", item.name);\n \n-                let mut interpreter = Interpreter::new(tcx, mir_map);\n+                let mut miri = Interpreter::new(tcx, mir_map);\n                 let return_ptr = match mir.return_ty {\n-                    ty::FnOutput::FnConverging(ty) => {\n-                        let repr = Repr::from_ty(ty);\n-                        Some(Pointer {\n-                            alloc_id: interpreter.memory.allocate(repr.size()),\n-                            offset: 0,\n-                            repr: repr,\n-                        })\n-                    }\n-                    ty::FnOutput::FnDiverging => None,\n+                    ty::FnConverging(ty) => Some(miri.memory.allocate(Repr::from_ty(ty))),\n+                    ty::FnDiverging => None,\n                 };\n-                interpreter.call(mir, &[], return_ptr.clone()).unwrap();\n+                miri.call(mir, &[], return_ptr.clone()).unwrap();\n \n-                let val_str = format!(\"{:?}\", interpreter.read_pointer(return_ptr.unwrap()));\n-                if !check_expected(&val_str, attr) {\n-                    println!(\"=> {}\\n\", val_str);\n+                if let Some(ret) = return_ptr {\n+                    println!(\"Returned: {:?}\\n\", miri.memory.value(ret.alloc_id).unwrap());\n                 }\n             }\n         }"}, {"sha": "3e5f53af589a44e3b1d9b078af52c1a06eb28432", "filename": "test/new_values.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53403ee8bd9d9fde1a025dba5e88392cfdbc6035/test%2Fnew_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53403ee8bd9d9fde1a025dba5e88392cfdbc6035/test%2Fnew_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fnew_values.rs?ref=53403ee8bd9d9fde1a025dba5e88392cfdbc6035", "patch": "@@ -16,6 +16,24 @@ fn add() -> i32 {\n     1 + 2\n }\n \n+#[miri_run(expected = \"Int(3)\")]\n+fn empty() {}\n+\n+#[miri_run(expected = \"Int(3)\")]\n+fn tuple() -> (i32,) {\n+    (1,)\n+}\n+\n+#[miri_run(expected = \"Int(3)\")]\n+fn tuple_2() -> (i32, i32) {\n+    (1, 2)\n+}\n+\n+#[miri_run(expected = \"Int(3)\")]\n+fn tuple_5() -> (i32, i32, i32, i32, i32) {\n+    (1, 2, 3, 4, 5)\n+}\n+\n // #[miri_run(expected = \"Int(3)\")]\n // fn indirect_add() -> i32 {\n //     let x = 1;"}]}