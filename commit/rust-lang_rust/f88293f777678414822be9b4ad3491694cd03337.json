{"sha": "f88293f777678414822be9b4ad3491694cd03337", "node_id": "C_kwDOAAsO6NoAKGY4ODI5M2Y3Nzc2Nzg0MTQ4MjJiZTliNGFkMzQ5MTY5NGNkMDMzMzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-01T13:35:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-01T13:35:08Z"}, "message": "Auto merge of #13324 - Veykril:trait-impl-completion, r=Veykril\n\nFix trait impl item completions using macro file text ranges\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/13323", "tree": {"sha": "3167c478357c7449ebbb47455276bfa042697529", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3167c478357c7449ebbb47455276bfa042697529"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f88293f777678414822be9b4ad3491694cd03337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f88293f777678414822be9b4ad3491694cd03337", "html_url": "https://github.com/rust-lang/rust/commit/f88293f777678414822be9b4ad3491694cd03337", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f88293f777678414822be9b4ad3491694cd03337/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7e40014ef172839108af860487fe4209a02135", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7e40014ef172839108af860487fe4209a02135", "html_url": "https://github.com/rust-lang/rust/commit/5b7e40014ef172839108af860487fe4209a02135"}, {"sha": "bfd5f00bfc97a90f190b1f402b67d707e4bcfcc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfd5f00bfc97a90f190b1f402b67d707e4bcfcc4", "html_url": "https://github.com/rust-lang/rust/commit/bfd5f00bfc97a90f190b1f402b67d707e4bcfcc4"}], "stats": {"total": 91, "additions": 68, "deletions": 23}, "files": [{"sha": "a5b499fe8d9d44809e0fcbd8847e61ce3ffd5c7e", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f88293f777678414822be9b4ad3491694cd03337/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88293f777678414822be9b4ad3491694cd03337/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=f88293f777678414822be9b4ad3491694cd03337", "patch": "@@ -811,6 +811,31 @@ impl<'a> InFile<&'a SyntaxNode> {\n             _ => None,\n         }\n     }\n+\n+    pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+        // This kind of upmapping can only be achieved in attribute expanded files,\n+        // as we don't have node inputs otherwise and  therefor can't find an `N` node in the input\n+        if !self.file_id.is_macro() {\n+            return Some(self.map(Clone::clone));\n+        } else if !self.file_id.is_attr_macro(db) {\n+            return None;\n+        }\n+\n+        if let Some(InFile { file_id, value: (first, last) }) = ascend_node_border_tokens(db, self)\n+        {\n+            if file_id.is_macro() {\n+                let range = first.text_range().cover(last.text_range());\n+                tracing::error!(\"Failed mapping out of macro file for {:?}\", range);\n+                return None;\n+            }\n+            // FIXME: This heuristic is brittle and with the right macro may select completely unrelated nodes\n+            let anc = algo::least_common_ancestor(&first.parent()?, &last.parent()?)?;\n+            let kind = self.value.kind();\n+            let value = anc.ancestors().find(|it| it.kind() == kind)?;\n+            return Some(InFile::new(file_id, value));\n+        }\n+        None\n+    }\n }\n \n impl InFile<SyntaxToken> {"}, {"sha": "119ec3210e175b0ca417420c3c480f57805b9156", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f88293f777678414822be9b4ad3491694cd03337/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88293f777678414822be9b4ad3491694cd03337/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=f88293f777678414822be9b4ad3491694cd03337", "patch": "@@ -257,6 +257,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn original_ast_node<N: AstNode>(&self, node: N) -> Option<N> {\n         self.imp.original_ast_node(node)\n     }\n+    /// Attempts to map the node out of macro expanded files.\n+    /// This only work for attribute expansions, as other ones do not have nodes as input.\n+    pub fn original_syntax_node(&self, node: &SyntaxNode) -> Option<SyntaxNode> {\n+        self.imp.original_syntax_node(node)\n+    }\n \n     pub fn diagnostics_display_range(&self, diagnostics: InFile<SyntaxNodePtr>) -> FileRange {\n         self.imp.diagnostics_display_range(diagnostics)\n@@ -956,6 +961,16 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n+    fn original_syntax_node(&self, node: &SyntaxNode) -> Option<SyntaxNode> {\n+        let InFile { file_id, .. } = self.find_file(node);\n+        InFile::new(file_id, node).original_syntax_node(self.db.upcast()).map(\n+            |InFile { file_id, value }| {\n+                self.cache(find_root(&value), file_id);\n+                value\n+            },\n+        )\n+    }\n+\n     fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n         let root = self.parse_or_expand(src.file_id).unwrap();\n         let node = src.map(|it| it.to_node(&root));"}, {"sha": "e82cbfdcb8402e6dbc0518c60a8d8621bc38922b", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f88293f777678414822be9b4ad3491694cd03337/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88293f777678414822be9b4ad3491694cd03337/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=f88293f777678414822be9b4ad3491694cd03337", "patch": "@@ -38,7 +38,7 @@ use ide_db::{\n };\n use syntax::{\n     ast::{self, edit_in_place::AttrsOwnerEdit},\n-    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,\n+    AstNode, SyntaxElement, SyntaxKind, TextRange, T,\n };\n use text_edit::TextEdit;\n \n@@ -85,20 +85,36 @@ fn complete_trait_impl_name(\n     name: &Option<ast::Name>,\n     kind: ImplCompletionKind,\n ) -> Option<()> {\n-    let token = ctx.token.clone();\n     let item = match name {\n         Some(name) => name.syntax().parent(),\n-        None => if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n-            .parent(),\n+        None => {\n+            let token = &ctx.token;\n+            match token.kind() {\n+                SyntaxKind::WHITESPACE => token.prev_token()?,\n+                _ => token.clone(),\n+            }\n+            .parent()\n+        }\n     }?;\n-    complete_trait_impl(\n-        acc,\n-        ctx,\n-        kind,\n-        replacement_range(ctx, &item),\n-        // item -> ASSOC_ITEM_LIST -> IMPL\n-        &ast::Impl::cast(item.parent()?.parent()?)?,\n-    );\n+    let item = ctx.sema.original_syntax_node(&item)?;\n+    // item -> ASSOC_ITEM_LIST -> IMPL\n+    let impl_def = ast::Impl::cast(item.parent()?.parent()?)?;\n+    let replacement_range = {\n+        // ctx.sema.original_ast_node(item)?;\n+        let first_child = item\n+            .children_with_tokens()\n+            .find(|child| {\n+                !matches!(\n+                    child.kind(),\n+                    SyntaxKind::COMMENT | SyntaxKind::WHITESPACE | SyntaxKind::ATTR\n+                )\n+            })\n+            .unwrap_or_else(|| SyntaxElement::Node(item.clone()));\n+\n+        TextRange::new(first_child.text_range().start(), ctx.source_range().end())\n+    };\n+\n+    complete_trait_impl(acc, ctx, kind, replacement_range, &impl_def);\n     Some(())\n }\n \n@@ -341,17 +357,6 @@ fn function_declaration(node: &ast::Fn, needs_whitespace: bool) -> String {\n     syntax.trim_end().to_owned()\n }\n \n-fn replacement_range(ctx: &CompletionContext<'_>, item: &SyntaxNode) -> TextRange {\n-    let first_child = item\n-        .children_with_tokens()\n-        .find(|child| {\n-            !matches!(child.kind(), SyntaxKind::COMMENT | SyntaxKind::WHITESPACE | SyntaxKind::ATTR)\n-        })\n-        .unwrap_or_else(|| SyntaxElement::Node(item.clone()));\n-\n-    TextRange::new(first_child.text_range().start(), ctx.source_range().end())\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}]}