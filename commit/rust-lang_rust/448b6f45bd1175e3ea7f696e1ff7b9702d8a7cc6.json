{"sha": "448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "node_id": "C_kwDOAAsO6NoAKDQ0OGI2ZjQ1YmQxMTc1ZTNlYTdmNjk2ZTFmZjdiOTcwMmQ4YTdjYzY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-01T01:27:29Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:51:00Z"}, "message": "Move `Arithmetic` into `Operators` lint pass", "tree": {"sha": "0495f5567c8b9126f70fbe4355b65501de626c99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0495f5567c8b9126f70fbe4355b65501de626c99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "html_url": "https://github.com/rust-lang/rust/commit/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd78ce7bbe70fcb87ecc4f0ce11611be0b3a7e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd78ce7bbe70fcb87ecc4f0ce11611be0b3a7e59", "html_url": "https://github.com/rust-lang/rust/commit/dd78ce7bbe70fcb87ecc4f0ce11611be0b3a7e59"}], "stats": {"total": 396, "additions": 213, "deletions": 183}, "files": [{"sha": "787ae1e79ec01e2df132c8990075a354d1c0f636", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "patch": "@@ -431,12 +431,12 @@ store.register_lints(&[\n     non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n-    numeric_arithmetic::FLOAT_ARITHMETIC,\n-    numeric_arithmetic::INTEGER_ARITHMETIC,\n     octal_escapes::OCTAL_ESCAPES,\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     operators::ABSURD_EXTREME_COMPARISONS,\n+    operators::FLOAT_ARITHMETIC,\n+    operators::INTEGER_ARITHMETIC,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,\n     overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,"}, {"sha": "b7441385230e2d657346280cf6dd9dd93b2cae2a", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "patch": "@@ -50,8 +50,8 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(module_style::MOD_MODULE_FILES),\n     LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n     LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n-    LintId::of(numeric_arithmetic::FLOAT_ARITHMETIC),\n-    LintId::of(numeric_arithmetic::INTEGER_ARITHMETIC),\n+    LintId::of(operators::FLOAT_ARITHMETIC),\n+    LintId::of(operators::INTEGER_ARITHMETIC),\n     LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n     LintId::of(panic_unimplemented::PANIC),\n     LintId::of(panic_unimplemented::TODO),"}, {"sha": "f1d282013091c132337c0a30b1d5cde0c5c25fe9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "patch": "@@ -331,7 +331,6 @@ mod non_expressive_names;\n mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n-mod numeric_arithmetic;\n mod octal_escapes;\n mod only_used_in_recursion;\n mod open_options;\n@@ -705,7 +704,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n     store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n     store.register_late_pass(|| Box::new(mem_forget::MemForget));\n-    store.register_late_pass(|| Box::new(numeric_arithmetic::NumericArithmetic::default()));\n     store.register_late_pass(|| Box::new(assign_ops::AssignOps));\n     store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n     store.register_late_pass(|| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n@@ -940,7 +938,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n     store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_retain::ManualRetain::new(msrv)));\n-    store.register_late_pass(|| Box::new(operators::Operators));\n+    store.register_late_pass(|| Box::new(operators::Operators::default()));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "5c4de3381496cd839567ba17a5b2de1eef2e2b99", "filename": "clippy_lints/src/numeric_arithmetic.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/dd78ce7bbe70fcb87ecc4f0ce11611be0b3a7e59/clippy_lints%2Fsrc%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd78ce7bbe70fcb87ecc4f0ce11611be0b3a7e59/clippy_lints%2Fsrc%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnumeric_arithmetic.rs?ref=dd78ce7bbe70fcb87ecc4f0ce11611be0b3a7e59", "patch": "@@ -1,170 +0,0 @@\n-use clippy_utils::consts::constant_simple;\n-use clippy_utils::diagnostics::span_lint;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for integer arithmetic operations which could overflow or panic.\n-    ///\n-    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n-    /// of overflowing according to the [Rust\n-    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n-    /// attempted.\n-    ///\n-    /// ### Why is this bad?\n-    /// Integer overflow will trigger a panic in debug builds or will wrap in\n-    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n-    /// wants explicitly checked, wrapping or saturating arithmetic.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0;\n-    /// a + 1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INTEGER_ARITHMETIC,\n-    restriction,\n-    \"any integer arithmetic expression which could overflow or panic\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for float arithmetic.\n-    ///\n-    /// ### Why is this bad?\n-    /// For some embedded systems or kernel development, it\n-    /// can be useful to rule out floating-point numbers.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0.0;\n-    /// a + 1.0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_ARITHMETIC,\n-    restriction,\n-    \"any floating-point arithmetic statement\"\n-}\n-\n-#[derive(Copy, Clone, Default)]\n-pub struct NumericArithmetic {\n-    expr_span: Option<Span>,\n-    /// This field is used to check whether expressions are constants, such as in enum discriminants\n-    /// and consts\n-    const_span: Option<Span>,\n-}\n-\n-impl_lint_pass!(NumericArithmetic => [INTEGER_ARITHMETIC, FLOAT_ARITHMETIC]);\n-\n-impl<'tcx> LateLintPass<'tcx> for NumericArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if self.expr_span.is_some() {\n-            return;\n-        }\n-\n-        if let Some(span) = self.const_span {\n-            if span.contains(expr.span) {\n-                return;\n-            }\n-        }\n-        match &expr.kind {\n-            hir::ExprKind::Binary(op, l, r) | hir::ExprKind::AssignOp(op, l, r) => {\n-                match op.node {\n-                    hir::BinOpKind::And\n-                    | hir::BinOpKind::Or\n-                    | hir::BinOpKind::BitAnd\n-                    | hir::BinOpKind::BitOr\n-                    | hir::BinOpKind::BitXor\n-                    | hir::BinOpKind::Eq\n-                    | hir::BinOpKind::Lt\n-                    | hir::BinOpKind::Le\n-                    | hir::BinOpKind::Ne\n-                    | hir::BinOpKind::Ge\n-                    | hir::BinOpKind::Gt => return,\n-                    _ => (),\n-                }\n-\n-                let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n-                if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n-                    match op.node {\n-                        hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n-                            hir::ExprKind::Lit(_lit) => (),\n-                            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n-                                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                                    if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n-                                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                        self.expr_span = Some(expr.span);\n-                                    }\n-                                }\n-                            },\n-                            _ => {\n-                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                self.expr_span = Some(expr.span);\n-                            },\n-                        },\n-                        _ => {\n-                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                            self.expr_span = Some(expr.span);\n-                        },\n-                    }\n-                } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n-                    span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                    self.expr_span = Some(expr.span);\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Neg, arg) => {\n-                let ty = cx.typeck_results().expr_ty(arg);\n-                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n-                    if ty.is_integral() {\n-                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                        self.expr_span = Some(expr.span);\n-                    } else if ty.is_floating_point() {\n-                        span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                        self.expr_span = Some(expr.span);\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_expr_post(&mut self, _: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if Some(expr.span) == self.expr_span {\n-            self.expr_span = None;\n-        }\n-    }\n-\n-    fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n-\n-        match cx.tcx.hir().body_owner_kind(body_owner) {\n-            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n-                let body_span = cx.tcx.def_span(body_owner);\n-\n-                if let Some(span) = self.const_span {\n-                    if span.contains(body_span) {\n-                        return;\n-                    }\n-                }\n-                self.const_span = Some(body_span);\n-            },\n-            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n-        }\n-    }\n-\n-    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner(body.id());\n-        let body_span = cx.tcx.hir().span(body_owner);\n-\n-        if let Some(span) = self.const_span {\n-            if span.contains(body_span) {\n-                return;\n-            }\n-        }\n-        self.const_span = None;\n-    }\n-}"}, {"sha": "a7495f042da41e9aeaf24ad009998219b79b2029", "filename": "clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "patch": "@@ -1,8 +1,9 @@\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Body, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n mod absurd_extreme_comparisons;\n+mod numeric_arithmetic;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -36,16 +37,90 @@ declare_clippy_lint! {\n     \"a comparison with a maximum or minimum value that is always true or false\"\n }\n \n-pub struct Operators;\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for integer arithmetic operations which could overflow or panic.\n+    ///\n+    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n+    /// of overflowing according to the [Rust\n+    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n+    /// attempted.\n+    ///\n+    /// ### Why is this bad?\n+    /// Integer overflow will trigger a panic in debug builds or will wrap in\n+    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n+    /// wants explicitly checked, wrapping or saturating arithmetic.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 0;\n+    /// a + 1;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INTEGER_ARITHMETIC,\n+    restriction,\n+    \"any integer arithmetic expression which could overflow or panic\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for float arithmetic.\n+    ///\n+    /// ### Why is this bad?\n+    /// For some embedded systems or kernel development, it\n+    /// can be useful to rule out floating-point numbers.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 0.0;\n+    /// a + 1.0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_ARITHMETIC,\n+    restriction,\n+    \"any floating-point arithmetic statement\"\n+}\n+\n+#[derive(Default)]\n+pub struct Operators {\n+    arithmetic_context: numeric_arithmetic::Context,\n+}\n impl_lint_pass!(Operators => [\n     ABSURD_EXTREME_COMPARISONS,\n+    INTEGER_ARITHMETIC,\n+    FLOAT_ARITHMETIC,\n ]);\n impl<'tcx> LateLintPass<'tcx> for Operators {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(op, lhs, rhs) = e.kind {\n-            if !e.span.from_expansion() {\n-                absurd_extreme_comparisons::check(cx, e, op.node, lhs, rhs);\n-            }\n+        match e.kind {\n+            ExprKind::Binary(op, lhs, rhs) => {\n+                if !e.span.from_expansion() {\n+                    absurd_extreme_comparisons::check(cx, e, op.node, lhs, rhs);\n+                }\n+                self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::AssignOp(op, lhs, rhs) => {\n+                self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::Unary(op, arg) => {\n+                if op == UnOp::Neg {\n+                    self.arithmetic_context.check_negate(cx, e, arg);\n+                }\n+            },\n+            _ => (),\n         }\n     }\n+\n+    fn check_expr_post(&mut self, _: &LateContext<'_>, e: &Expr<'_>) {\n+        self.arithmetic_context.expr_post(e.hir_id);\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, b: &'tcx Body<'_>) {\n+        self.arithmetic_context.enter_body(cx, b);\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, b: &'tcx Body<'_>) {\n+        self.arithmetic_context.body_post(cx, b);\n+    }\n }"}, {"sha": "82f454d02f713ad6bf90522c4ba779126294f5bc", "filename": "clippy_lints/src/operators/numeric_arithmetic.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs?ref=448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "patch": "@@ -0,0 +1,127 @@\n+use clippy_utils::consts::constant_simple;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::{FLOAT_ARITHMETIC, INTEGER_ARITHMETIC};\n+\n+#[derive(Default)]\n+pub struct Context {\n+    expr_id: Option<hir::HirId>,\n+    /// This field is used to check whether expressions are constants, such as in enum discriminants\n+    /// and consts\n+    const_span: Option<Span>,\n+}\n+impl Context {\n+    fn skip_expr(&mut self, e: &hir::Expr<'_>) -> bool {\n+        self.expr_id.is_some() || self.const_span.map_or(false, |span| span.contains(e.span))\n+    }\n+\n+    pub fn check_binary<'tcx>(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx hir::Expr<'_>,\n+        op: hir::BinOpKind,\n+        l: &'tcx hir::Expr<'_>,\n+        r: &'tcx hir::Expr<'_>,\n+    ) {\n+        if self.skip_expr(expr) {\n+            return;\n+        }\n+        match op {\n+            hir::BinOpKind::And\n+            | hir::BinOpKind::Or\n+            | hir::BinOpKind::BitAnd\n+            | hir::BinOpKind::BitOr\n+            | hir::BinOpKind::BitXor\n+            | hir::BinOpKind::Eq\n+            | hir::BinOpKind::Lt\n+            | hir::BinOpKind::Le\n+            | hir::BinOpKind::Ne\n+            | hir::BinOpKind::Ge\n+            | hir::BinOpKind::Gt => return,\n+            _ => (),\n+        }\n+\n+        let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n+        if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n+            match op {\n+                hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n+                    hir::ExprKind::Lit(_lit) => (),\n+                    hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n+                        if let hir::ExprKind::Lit(lit) = &expr.kind {\n+                            if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n+                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                                self.expr_id = Some(expr.hir_id);\n+                            }\n+                        }\n+                    },\n+                    _ => {\n+                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                        self.expr_id = Some(expr.hir_id);\n+                    },\n+                },\n+                _ => {\n+                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                    self.expr_id = Some(expr.hir_id);\n+                },\n+            }\n+        } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n+            span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+            self.expr_id = Some(expr.hir_id);\n+        }\n+    }\n+\n+    pub fn check_negate<'tcx>(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n+        if self.skip_expr(expr) {\n+            return;\n+        }\n+        let ty = cx.typeck_results().expr_ty(arg);\n+        if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n+            if ty.is_integral() {\n+                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                self.expr_id = Some(expr.hir_id);\n+            } else if ty.is_floating_point() {\n+                span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+                self.expr_id = Some(expr.hir_id);\n+            }\n+        }\n+    }\n+\n+    pub fn expr_post(&mut self, id: hir::HirId) {\n+        if Some(id) == self.expr_id {\n+            self.expr_id = None;\n+        }\n+    }\n+\n+    pub fn enter_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n+\n+        match cx.tcx.hir().body_owner_kind(body_owner) {\n+            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n+                let body_span = cx.tcx.def_span(body_owner);\n+\n+                if let Some(span) = self.const_span {\n+                    if span.contains(body_span) {\n+                        return;\n+                    }\n+                }\n+                self.const_span = Some(body_span);\n+            },\n+            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n+        }\n+    }\n+\n+    pub fn body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_span = cx.tcx.hir().span(body_owner);\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(body_span) {\n+                return;\n+            }\n+        }\n+        self.const_span = None;\n+    }\n+}"}]}