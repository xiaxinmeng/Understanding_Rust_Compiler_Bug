{"sha": "19c5fdda7c76d57b07d85054400ca14bf3849023", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzVmZGRhN2M3NmQ1N2IwN2Q4NTA1NDQwMGNhMTRiZjM4NDkwMjM=", "commit": {"author": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-09-01T14:32:13Z"}, "committer": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-10-10T13:19:12Z"}, "message": "Rename `test.rs` to `tests.rs`", "tree": {"sha": "38dec76258ac43fbc5d6515aa43fc3f0339896f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38dec76258ac43fbc5d6515aa43fc3f0339896f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c5fdda7c76d57b07d85054400ca14bf3849023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c5fdda7c76d57b07d85054400ca14bf3849023", "html_url": "https://github.com/rust-lang/rust/commit/19c5fdda7c76d57b07d85054400ca14bf3849023", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c5fdda7c76d57b07d85054400ca14bf3849023/comments", "author": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a91fd7328c5742360d0c50e3516e173e61bf7b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/a91fd7328c5742360d0c50e3516e173e61bf7b78", "html_url": "https://github.com/rust-lang/rust/commit/a91fd7328c5742360d0c50e3516e173e61bf7b78"}], "stats": {"total": 644, "additions": 19, "deletions": 625}, "files": [{"sha": "c37e856e5bc22fdad9ed1a4a293de83040f0a8e8", "filename": "library/std/src/sys/unix/ext/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c5fdda7c76d57b07d85054400ca14bf3849023/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5fdda7c76d57b07d85054400ca14bf3849023/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs?ref=19c5fdda7c76d57b07d85054400ca14bf3849023", "patch": "@@ -42,7 +42,7 @@ mod listener;\n mod raw_fd;\n mod stream;\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod test;\n+mod tests;\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub use self::addr::*;"}, {"sha": "a39b97f2c31b9481efa6b1816739db3ef386dc9b", "filename": "library/std/src/sys/unix/ext/net/test.rs", "status": "removed", "additions": 0, "deletions": 613, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/a91fd7328c5742360d0c50e3516e173e61bf7b78/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a91fd7328c5742360d0c50e3516e173e61bf7b78/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftest.rs?ref=a91fd7328c5742360d0c50e3516e173e61bf7b78", "patch": "@@ -1,613 +0,0 @@\n-use super::*;\n-use crate::io::prelude::*;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n-use crate::iter::FromIterator;\n-use crate::mem;\n-use crate::sys::unix::ext::io::AsRawFd;\n-use crate::sys_common::io::test::tmpdir;\n-use crate::thread;\n-use crate::time::Duration;\n-\n-macro_rules! or_panic {\n-    ($e:expr) => {\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => panic!(\"{}\", e),\n-        }\n-    };\n-}\n-\n-#[test]\n-fn basic() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-    let msg1 = b\"hello\";\n-    let msg2 = b\"world!\";\n-\n-    let listener = or_panic!(UnixListener::bind(&socket_path));\n-    let thread = thread::spawn(move || {\n-        let mut stream = or_panic!(listener.accept()).0;\n-        let mut buf = [0; 5];\n-        or_panic!(stream.read(&mut buf));\n-        assert_eq!(&msg1[..], &buf[..]);\n-        or_panic!(stream.write_all(msg2));\n-    });\n-\n-    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-    assert_eq!(Some(&*socket_path), stream.peer_addr().unwrap().as_pathname());\n-    or_panic!(stream.write_all(msg1));\n-    let mut buf = vec![];\n-    or_panic!(stream.read_to_end(&mut buf));\n-    assert_eq!(&msg2[..], &buf[..]);\n-    drop(stream);\n-\n-    thread.join().unwrap();\n-}\n-\n-#[test]\n-fn vectored() {\n-    let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n-\n-    let len = or_panic!(s1.write_vectored(&[\n-        IoSlice::new(b\"hello\"),\n-        IoSlice::new(b\" \"),\n-        IoSlice::new(b\"world!\")\n-    ],));\n-    assert_eq!(len, 12);\n-\n-    let mut buf1 = [0; 6];\n-    let mut buf2 = [0; 7];\n-    let len =\n-        or_panic!(s2.read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],));\n-    assert_eq!(len, 12);\n-    assert_eq!(&buf1, b\"hello \");\n-    assert_eq!(&buf2, b\"world!\\0\");\n-}\n-\n-#[test]\n-fn pair() {\n-    let msg1 = b\"hello\";\n-    let msg2 = b\"world!\";\n-\n-    let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n-    let thread = thread::spawn(move || {\n-        // s1 must be moved in or the test will hang!\n-        let mut buf = [0; 5];\n-        or_panic!(s1.read(&mut buf));\n-        assert_eq!(&msg1[..], &buf[..]);\n-        or_panic!(s1.write_all(msg2));\n-    });\n-\n-    or_panic!(s2.write_all(msg1));\n-    let mut buf = vec![];\n-    or_panic!(s2.read_to_end(&mut buf));\n-    assert_eq!(&msg2[..], &buf[..]);\n-    drop(s2);\n-\n-    thread.join().unwrap();\n-}\n-\n-#[test]\n-fn try_clone() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-    let msg1 = b\"hello\";\n-    let msg2 = b\"world\";\n-\n-    let listener = or_panic!(UnixListener::bind(&socket_path));\n-    let thread = thread::spawn(move || {\n-        let mut stream = or_panic!(listener.accept()).0;\n-        or_panic!(stream.write_all(msg1));\n-        or_panic!(stream.write_all(msg2));\n-    });\n-\n-    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-    let mut stream2 = or_panic!(stream.try_clone());\n-\n-    let mut buf = [0; 5];\n-    or_panic!(stream.read(&mut buf));\n-    assert_eq!(&msg1[..], &buf[..]);\n-    or_panic!(stream2.read(&mut buf));\n-    assert_eq!(&msg2[..], &buf[..]);\n-\n-    thread.join().unwrap();\n-}\n-\n-#[test]\n-fn iter() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-\n-    let listener = or_panic!(UnixListener::bind(&socket_path));\n-    let thread = thread::spawn(move || {\n-        for stream in listener.incoming().take(2) {\n-            let mut stream = or_panic!(stream);\n-            let mut buf = [0];\n-            or_panic!(stream.read(&mut buf));\n-        }\n-    });\n-\n-    for _ in 0..2 {\n-        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-        or_panic!(stream.write_all(&[0]));\n-    }\n-\n-    thread.join().unwrap();\n-}\n-\n-#[test]\n-fn long_path() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\n-        \"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfa\\\n-                                sasdfasdfasdasdfasdfasdfadfasdfasdfasdfasdfasdf\",\n-    );\n-    match UnixStream::connect(&socket_path) {\n-        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-        Err(e) => panic!(\"unexpected error {}\", e),\n-        Ok(_) => panic!(\"unexpected success\"),\n-    }\n-\n-    match UnixListener::bind(&socket_path) {\n-        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-        Err(e) => panic!(\"unexpected error {}\", e),\n-        Ok(_) => panic!(\"unexpected success\"),\n-    }\n-\n-    match UnixDatagram::bind(&socket_path) {\n-        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n-        Err(e) => panic!(\"unexpected error {}\", e),\n-        Ok(_) => panic!(\"unexpected success\"),\n-    }\n-}\n-\n-#[test]\n-fn timeouts() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-\n-    let _listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-    let stream = or_panic!(UnixStream::connect(&socket_path));\n-    let dur = Duration::new(15410, 0);\n-\n-    assert_eq!(None, or_panic!(stream.read_timeout()));\n-\n-    or_panic!(stream.set_read_timeout(Some(dur)));\n-    assert_eq!(Some(dur), or_panic!(stream.read_timeout()));\n-\n-    assert_eq!(None, or_panic!(stream.write_timeout()));\n-\n-    or_panic!(stream.set_write_timeout(Some(dur)));\n-    assert_eq!(Some(dur), or_panic!(stream.write_timeout()));\n-\n-    or_panic!(stream.set_read_timeout(None));\n-    assert_eq!(None, or_panic!(stream.read_timeout()));\n-\n-    or_panic!(stream.set_write_timeout(None));\n-    assert_eq!(None, or_panic!(stream.write_timeout()));\n-}\n-\n-#[test]\n-fn test_read_timeout() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-\n-    let _listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-    or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-    let mut buf = [0; 10];\n-    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-    assert!(\n-        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-        \"unexpected_error: {:?}\",\n-        kind\n-    );\n-}\n-\n-#[test]\n-fn test_read_with_timeout() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-\n-    let listener = or_panic!(UnixListener::bind(&socket_path));\n-\n-    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n-    or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-    let mut other_end = or_panic!(listener.accept()).0;\n-    or_panic!(other_end.write_all(b\"hello world\"));\n-\n-    let mut buf = [0; 11];\n-    or_panic!(stream.read(&mut buf));\n-    assert_eq!(b\"hello world\", &buf[..]);\n-\n-    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-    assert!(\n-        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-        \"unexpected_error: {:?}\",\n-        kind\n-    );\n-}\n-\n-// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-// when passed zero Durations\n-#[test]\n-fn test_unix_stream_timeout_zero_duration() {\n-    let dir = tmpdir();\n-    let socket_path = dir.path().join(\"sock\");\n-\n-    let listener = or_panic!(UnixListener::bind(&socket_path));\n-    let stream = or_panic!(UnixStream::connect(&socket_path));\n-\n-    let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n-    let err = result.unwrap_err();\n-    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-    let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n-    let err = result.unwrap_err();\n-    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-    drop(listener);\n-}\n-\n-#[test]\n-fn test_unix_datagram() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock1\");\n-    let path2 = dir.path().join(\"sock2\");\n-\n-    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let sock2 = or_panic!(UnixDatagram::bind(&path2));\n-\n-    let msg = b\"hello world\";\n-    or_panic!(sock1.send_to(msg, &path2));\n-    let mut buf = [0; 11];\n-    or_panic!(sock2.recv_from(&mut buf));\n-    assert_eq!(msg, &buf[..]);\n-}\n-\n-#[test]\n-fn test_unnamed_unix_datagram() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock1\");\n-\n-    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let sock2 = or_panic!(UnixDatagram::unbound());\n-\n-    let msg = b\"hello world\";\n-    or_panic!(sock2.send_to(msg, &path1));\n-    let mut buf = [0; 11];\n-    let (usize, addr) = or_panic!(sock1.recv_from(&mut buf));\n-    assert_eq!(usize, 11);\n-    assert!(addr.is_unnamed());\n-    assert_eq!(msg, &buf[..]);\n-}\n-\n-#[test]\n-fn test_connect_unix_datagram() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock1\");\n-    let path2 = dir.path().join(\"sock2\");\n-\n-    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n-    let sock = or_panic!(UnixDatagram::unbound());\n-    or_panic!(sock.connect(&path1));\n-\n-    // Check send()\n-    let msg = b\"hello there\";\n-    or_panic!(sock.send(msg));\n-    let mut buf = [0; 11];\n-    let (usize, addr) = or_panic!(bsock1.recv_from(&mut buf));\n-    assert_eq!(usize, 11);\n-    assert!(addr.is_unnamed());\n-    assert_eq!(msg, &buf[..]);\n-\n-    // Changing default socket works too\n-    or_panic!(sock.connect(&path2));\n-    or_panic!(sock.send(msg));\n-    or_panic!(bsock2.recv_from(&mut buf));\n-}\n-\n-#[test]\n-fn test_unix_datagram_recv() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock1\");\n-\n-    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let sock2 = or_panic!(UnixDatagram::unbound());\n-    or_panic!(sock2.connect(&path1));\n-\n-    let msg = b\"hello world\";\n-    or_panic!(sock2.send(msg));\n-    let mut buf = [0; 11];\n-    let size = or_panic!(sock1.recv(&mut buf));\n-    assert_eq!(size, 11);\n-    assert_eq!(msg, &buf[..]);\n-}\n-\n-#[test]\n-fn datagram_pair() {\n-    let msg1 = b\"hello\";\n-    let msg2 = b\"world!\";\n-\n-    let (s1, s2) = or_panic!(UnixDatagram::pair());\n-    let thread = thread::spawn(move || {\n-        // s1 must be moved in or the test will hang!\n-        let mut buf = [0; 5];\n-        or_panic!(s1.recv(&mut buf));\n-        assert_eq!(&msg1[..], &buf[..]);\n-        or_panic!(s1.send(msg2));\n-    });\n-\n-    or_panic!(s2.send(msg1));\n-    let mut buf = [0; 6];\n-    or_panic!(s2.recv(&mut buf));\n-    assert_eq!(&msg2[..], &buf[..]);\n-    drop(s2);\n-\n-    thread.join().unwrap();\n-}\n-\n-// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-// when passed zero Durations\n-#[test]\n-fn test_unix_datagram_timeout_zero_duration() {\n-    let dir = tmpdir();\n-    let path = dir.path().join(\"sock\");\n-\n-    let datagram = or_panic!(UnixDatagram::bind(&path));\n-\n-    let result = datagram.set_write_timeout(Some(Duration::new(0, 0)));\n-    let err = result.unwrap_err();\n-    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-    let result = datagram.set_read_timeout(Some(Duration::new(0, 0)));\n-    let err = result.unwrap_err();\n-    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-}\n-\n-#[test]\n-fn abstract_namespace_not_allowed() {\n-    assert!(UnixStream::connect(\"\\0asdf\").is_err());\n-}\n-\n-#[test]\n-fn test_unix_stream_peek() {\n-    let (txdone, rxdone) = crate::sync::mpsc::channel();\n-\n-    let dir = tmpdir();\n-    let path = dir.path().join(\"sock\");\n-\n-    let listener = or_panic!(UnixListener::bind(&path));\n-    let thread = thread::spawn(move || {\n-        let mut stream = or_panic!(listener.accept()).0;\n-        or_panic!(stream.write_all(&[1, 3, 3, 7]));\n-        or_panic!(rxdone.recv());\n-    });\n-\n-    let mut stream = or_panic!(UnixStream::connect(&path));\n-    let mut buf = [0; 10];\n-    for _ in 0..2 {\n-        assert_eq!(or_panic!(stream.peek(&mut buf)), 4);\n-    }\n-    assert_eq!(or_panic!(stream.read(&mut buf)), 4);\n-\n-    or_panic!(stream.set_nonblocking(true));\n-    match stream.peek(&mut buf) {\n-        Ok(_) => panic!(\"expected error\"),\n-        Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n-        Err(e) => panic!(\"unexpected error: {}\", e),\n-    }\n-\n-    or_panic!(txdone.send(()));\n-    thread.join().unwrap();\n-}\n-\n-#[test]\n-fn test_unix_datagram_peek() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock\");\n-\n-    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let sock2 = or_panic!(UnixDatagram::unbound());\n-    or_panic!(sock2.connect(&path1));\n-\n-    let msg = b\"hello world\";\n-    or_panic!(sock2.send(msg));\n-    for _ in 0..2 {\n-        let mut buf = [0; 11];\n-        let size = or_panic!(sock1.peek(&mut buf));\n-        assert_eq!(size, 11);\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    let mut buf = [0; 11];\n-    let size = or_panic!(sock1.recv(&mut buf));\n-    assert_eq!(size, 11);\n-    assert_eq!(msg, &buf[..]);\n-}\n-\n-#[test]\n-fn test_unix_datagram_peek_from() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock\");\n-\n-    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let sock2 = or_panic!(UnixDatagram::unbound());\n-    or_panic!(sock2.connect(&path1));\n-\n-    let msg = b\"hello world\";\n-    or_panic!(sock2.send(msg));\n-    for _ in 0..2 {\n-        let mut buf = [0; 11];\n-        let (size, _) = or_panic!(sock1.peek_from(&mut buf));\n-        assert_eq!(size, 11);\n-        assert_eq!(msg, &buf[..]);\n-    }\n-\n-    let mut buf = [0; 11];\n-    let size = or_panic!(sock1.recv(&mut buf));\n-    assert_eq!(size, 11);\n-    assert_eq!(msg, &buf[..]);\n-}\n-\n-#[test]\n-fn test_send_vectored_fds_unix_stream() {\n-    let (s1, s2) = or_panic!(UnixStream::pair());\n-\n-    let mut buf1 = [1; 8];\n-    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n-\n-    let mut ancillary1_buffer = [0; 128];\n-    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n-    assert!(ancillary1.add_fds(&[s1.as_raw_fd()][..]));\n-\n-    let usize = or_panic!(s1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n-    assert_eq!(usize, 8);\n-\n-    let mut buf2 = [0; 8];\n-    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n-\n-    let mut ancillary2_buffer = [0; 128];\n-    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n-\n-    let usize = or_panic!(s2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n-    assert_eq!(usize, 8);\n-    assert_eq!(buf1, buf2);\n-\n-    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n-    assert_eq!(ancillary_data_vec.len(), 1);\n-    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap().unwrap() {\n-        let fd_vec = Vec::from_iter(scm_rights);\n-        assert_eq!(fd_vec.len(), 1);\n-        unsafe {\n-            libc::close(fd_vec[0]);\n-        }\n-    } else {\n-        assert!(false);\n-    }\n-}\n-\n-#[test]\n-fn test_send_vectored_with_ancillary_to_unix_datagram() {\n-    fn getpid() -> libc::pid_t {\n-        unsafe { libc::getpid() }\n-    }\n-\n-    fn getuid() -> libc::uid_t {\n-        unsafe { libc::getuid() }\n-    }\n-\n-    fn getgid() -> libc::gid_t {\n-        unsafe { libc::getgid() }\n-    }\n-\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock1\");\n-    let path2 = dir.path().join(\"sock2\");\n-\n-    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n-\n-    unsafe {\n-        let optval: libc::c_int = 1;\n-        libc::setsockopt(\n-            bsock2.as_raw_fd(),\n-            libc::SOL_SOCKET,\n-            libc::SO_PASSCRED,\n-            &optval as *const _ as *const _,\n-            mem::size_of::<libc::c_int>() as u32,\n-        );\n-    }\n-\n-    let mut buf1 = [1; 8];\n-    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n-\n-    let mut ancillary1_buffer = [0; 128];\n-    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n-    let mut cred1 = UCred::new();\n-    cred1.set_pid(getpid());\n-    cred1.set_uid(getuid());\n-    cred1.set_gid(getgid());\n-    assert!(ancillary1.add_creds(&[cred1.clone()][..]));\n-\n-    let usize =\n-        or_panic!(bsock1.send_vectored_with_ancillary_to(&mut bufs_send, &mut ancillary1, &path2));\n-    assert_eq!(usize, 8);\n-\n-    let mut buf2 = [0; 8];\n-    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n-\n-    let mut ancillary2_buffer = [0; 128];\n-    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n-\n-    let (usize, truncated, _addr) =\n-        or_panic!(bsock2.recv_vectored_with_ancillary_from(&mut bufs_recv, &mut ancillary2));\n-    assert_eq!(ancillary2.truncated(), false);\n-    assert_eq!(usize, 8);\n-    assert_eq!(truncated, false);\n-    assert_eq!(buf1, buf2);\n-\n-    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n-    assert_eq!(ancillary_data_vec.len(), 1);\n-    if let AncillaryData::ScmCredentials(scm_credentials) =\n-        ancillary_data_vec.pop().unwrap().unwrap()\n-    {\n-        let cred_vec = Vec::from_iter(scm_credentials);\n-        assert_eq!(cred_vec.len(), 1);\n-        assert_eq!(cred1.get_pid(), cred_vec[0].get_pid());\n-        assert_eq!(cred1.get_uid(), cred_vec[0].get_uid());\n-        assert_eq!(cred1.get_gid(), cred_vec[0].get_gid());\n-    } else {\n-        assert!(false);\n-    }\n-}\n-\n-#[test]\n-fn test_send_vectored_with_ancillary_unix_datagram() {\n-    let dir = tmpdir();\n-    let path1 = dir.path().join(\"sock1\");\n-    let path2 = dir.path().join(\"sock2\");\n-\n-    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n-    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n-\n-    let mut buf1 = [1; 8];\n-    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n-\n-    let mut ancillary1_buffer = [0; 128];\n-    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n-    assert!(ancillary1.add_fds(&[bsock1.as_raw_fd()][..]));\n-\n-    or_panic!(bsock1.connect(&path2));\n-    let usize = or_panic!(bsock1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n-    assert_eq!(usize, 8);\n-\n-    let mut buf2 = [0; 8];\n-    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n-\n-    let mut ancillary2_buffer = [0; 128];\n-    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n-\n-    let (usize, truncated) =\n-        or_panic!(bsock2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n-    assert_eq!(usize, 8);\n-    assert_eq!(truncated, false);\n-    assert_eq!(buf1, buf2);\n-\n-    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n-    assert_eq!(ancillary_data_vec.len(), 1);\n-    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap().unwrap() {\n-        let fd_vec = Vec::from_iter(scm_rights);\n-        assert_eq!(fd_vec.len(), 1);\n-        unsafe {\n-            libc::close(fd_vec[0]);\n-        }\n-    } else {\n-        assert!(false);\n-    }\n-}"}, {"sha": "a39b97f2c31b9481efa6b1816739db3ef386dc9b", "filename": "library/std/src/sys/unix/ext/net/tests.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/19c5fdda7c76d57b07d85054400ca14bf3849023/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c5fdda7c76d57b07d85054400ca14bf3849023/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs?ref=19c5fdda7c76d57b07d85054400ca14bf3849023", "patch": "@@ -1,11 +1,13 @@\n+use super::*;\n use crate::io::prelude::*;\n-use crate::io::{self, ErrorKind};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n+use crate::iter::FromIterator;\n+use crate::mem;\n+use crate::sys::unix::ext::io::AsRawFd;\n use crate::sys_common::io::test::tmpdir;\n use crate::thread;\n use crate::time::Duration;\n \n-use super::*;\n-\n macro_rules! or_panic {\n     ($e:expr) => {\n         match $e {\n@@ -479,7 +481,7 @@ fn test_send_vectored_fds_unix_stream() {\n \n     let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n     assert_eq!(ancillary_data_vec.len(), 1);\n-    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap() {\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap().unwrap() {\n         let fd_vec = Vec::from_iter(scm_rights);\n         assert_eq!(fd_vec.len(), 1);\n         unsafe {\n@@ -527,8 +529,11 @@ fn test_send_vectored_with_ancillary_to_unix_datagram() {\n \n     let mut ancillary1_buffer = [0; 128];\n     let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n-    let cred1 = libc::ucred { pid: getpid(), uid: getuid(), gid: getgid() };\n-    assert!(ancillary1.add_creds(&[cred1][..]));\n+    let mut cred1 = UCred::new();\n+    cred1.set_pid(getpid());\n+    cred1.set_uid(getuid());\n+    cred1.set_gid(getgid());\n+    assert!(ancillary1.add_creds(&[cred1.clone()][..]));\n \n     let usize =\n         or_panic!(bsock1.send_vectored_with_ancillary_to(&mut bufs_send, &mut ancillary1, &path2));\n@@ -549,12 +554,14 @@ fn test_send_vectored_with_ancillary_to_unix_datagram() {\n \n     let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n     assert_eq!(ancillary_data_vec.len(), 1);\n-    if let AncillaryData::ScmCredentials(scm_credentials) = ancillary_data_vec.pop().unwrap() {\n+    if let AncillaryData::ScmCredentials(scm_credentials) =\n+        ancillary_data_vec.pop().unwrap().unwrap()\n+    {\n         let cred_vec = Vec::from_iter(scm_credentials);\n         assert_eq!(cred_vec.len(), 1);\n-        assert_eq!(cred1.pid, cred_vec[0].pid);\n-        assert_eq!(cred1.uid, cred_vec[0].uid);\n-        assert_eq!(cred1.gid, cred_vec[0].gid);\n+        assert_eq!(cred1.get_pid(), cred_vec[0].get_pid());\n+        assert_eq!(cred1.get_uid(), cred_vec[0].get_uid());\n+        assert_eq!(cred1.get_gid(), cred_vec[0].get_gid());\n     } else {\n         assert!(false);\n     }\n@@ -594,7 +601,7 @@ fn test_send_vectored_with_ancillary_unix_datagram() {\n \n     let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n     assert_eq!(ancillary_data_vec.len(), 1);\n-    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap() {\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap().unwrap() {\n         let fd_vec = Vec::from_iter(scm_rights);\n         assert_eq!(fd_vec.len(), 1);\n         unsafe {"}]}