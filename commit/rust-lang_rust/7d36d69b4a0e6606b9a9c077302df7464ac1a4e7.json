{"sha": "7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMzZkNjliNGEwZTY2MDZiOWE5YzA3NzMwMmRmNzQ2NGFjMWE0ZTc=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-07-16T17:54:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-16T17:54:12Z"}, "message": "Rollup merge of #87200 - oli-obk:fixup_fixup_opaque_types, r=nikomatsakis\n\nTAIT: Infer all inference variables in opaque type substitutions via InferCx\n\nThe previous algorithm was correct for the example given in its\ndocumentation, but when the TAIT was declared as a free item\ninstead of an associated item, the generic parameters were the\nwrong ones.\n\ncc `@spastorino`\n\nr? `@nikomatsakis`", "tree": {"sha": "bb4fc63696280d1c70ee2b0b57d652c3b5dd1d2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb4fc63696280d1c70ee2b0b57d652c3b5dd1d2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8cfECRBK7hj4Ov3rIwAAGQQIAESSHvy9DFshUyMHDGFybZlC\n9kZGM6vJjNL7D/U/nMvg5Sx8lIN7lxd1KluGQPYvunzjeZg9LHmr+Z/4RZN8njrb\nqzvqKsASjg8vk9LC7jkkR5vHDDAaP5pgZPxPNPg7CwCUDJeyqA9bJB/03nlW/Eh8\n2w22w+VAD6GwMApavPpmYZ3nx4nPOcaLA2w1qWrJl+Tc9TN7iWYGMesQYJag0TTJ\nIw/Xg5lFSwDZgEObeI6ja7sbGyAPho0vjRq20Y6tsVN8UMU9g3r5Hre6pHo3Qnpx\noNyndA3V9TU/gtz+Qi/nxRmYl65Dv/FPhbTVkir/QZqQroeglgqhMVRKZzfsUkA=\n=cHi3\n-----END PGP SIGNATURE-----\n", "payload": "tree bb4fc63696280d1c70ee2b0b57d652c3b5dd1d2f\nparent e596aa294b9f0d2413897da2d6b313d1b8d42bf5\nparent ebe21ac23a8a259079c9c59669c1d7da1fa88d0c\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1626458052 +0200\ncommitter GitHub <noreply@github.com> 1626458052 +0200\n\nRollup merge of #87200 - oli-obk:fixup_fixup_opaque_types, r=nikomatsakis\n\nTAIT: Infer all inference variables in opaque type substitutions via InferCx\n\nThe previous algorithm was correct for the example given in its\ndocumentation, but when the TAIT was declared as a free item\ninstead of an associated item, the generic parameters were the\nwrong ones.\n\ncc `@spastorino`\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "html_url": "https://github.com/rust-lang/rust/commit/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e596aa294b9f0d2413897da2d6b313d1b8d42bf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e596aa294b9f0d2413897da2d6b313d1b8d42bf5", "html_url": "https://github.com/rust-lang/rust/commit/e596aa294b9f0d2413897da2d6b313d1b8d42bf5"}, {"sha": "ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "html_url": "https://github.com/rust-lang/rust/commit/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c"}], "stats": {"total": 194, "additions": 42, "deletions": 152}, "files": [{"sha": "bfc942e6f10ff0e7cb7ae6ace99a4c2ae30bfd40", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "patch": "@@ -857,7 +857,7 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "d5e334b5c65958887303dfadad538aa59bd82a5e", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "patch": "@@ -568,6 +568,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// - `substs`, the substs  used to instantiate this opaque type\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n+    #[instrument(skip(self))]\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n@@ -576,18 +577,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n-        debug!(\n-            \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n-            def_id, instantiated_ty\n-        );\n-\n         // Use substs to build up a reverse map from regions to their\n         // identity mappings. This is necessary because of `impl\n         // Trait` lifetimes are computed by replacing existing\n         // lifetimes with 'static and remapping only those used in the\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n         let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n+        debug!(?id_substs);\n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n             substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n \n@@ -602,7 +599,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             instantiated_ty,\n             span,\n         ));\n-        debug!(\"infer_opaque_definition_from_instantiation: definition_ty={:?}\", definition_ty);\n+        debug!(?definition_ty);\n \n         definition_ty\n     }\n@@ -857,14 +854,15 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 self.tcx.mk_generator(def_id, substs, movability)\n             }\n \n-            ty::Param(..) => {\n+            ty::Param(param) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list; replace with the parameter from the\n                     // opaque type.\n                     Some(GenericArgKind::Type(t1)) => t1,\n                     Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n                     None => {\n+                        debug!(?param, ?self.map);\n                         self.tcx\n                             .sess\n                             .struct_span_err(\n@@ -931,8 +929,8 @@ struct Instantiator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n+    #[instrument(skip(self))]\n     fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        debug!(\"instantiate_opaque_types_in_map(value={:?})\", value);\n         let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n             tcx,"}, {"sha": "34d0908bcc74ea2df8f1aad5e16ef24a5f869537", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 116, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "patch": "@@ -112,11 +112,9 @@ use rustc_hir::{HirIdMap, ImplicitSelfKind, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, RegionKind, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::{self, Ty, TyCtxt, UserType};\n use rustc_session::config;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -321,117 +319,6 @@ fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDe\n     &*tcx.typeck(def_id).used_trait_imports\n }\n \n-/// Inspects the substs of opaque types, replacing any inference variables\n-/// with proper generic parameter from the identity substs.\n-///\n-/// This is run after we normalize the function signature, to fix any inference\n-/// variables introduced by the projection of associated types. This ensures that\n-/// any opaque types used in the signature continue to refer to generic parameters,\n-/// allowing them to be considered for defining uses in the function body\n-///\n-/// For example, consider this code.\n-///\n-/// ```rust\n-/// trait MyTrait {\n-///     type MyItem;\n-///     fn use_it(self) -> Self::MyItem\n-/// }\n-/// impl<T, I> MyTrait for T where T: Iterator<Item = I> {\n-///     type MyItem = impl Iterator<Item = I>;\n-///     fn use_it(self) -> Self::MyItem {\n-///         self\n-///     }\n-/// }\n-/// ```\n-///\n-/// When we normalize the signature of `use_it` from the impl block,\n-/// we will normalize `Self::MyItem` to the opaque type `impl Iterator<Item = I>`\n-/// However, this projection result may contain inference variables, due\n-/// to the way that projection works. We didn't have any inference variables\n-/// in the signature to begin with - leaving them in will cause us to incorrectly\n-/// conclude that we don't have a defining use of `MyItem`. By mapping inference\n-/// variables back to the actual generic parameters, we will correctly see that\n-/// we have a defining use of `MyItem`\n-fn fixup_opaque_types<'tcx, T>(tcx: TyCtxt<'tcx>, val: T) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    struct FixupFolder<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-    }\n-\n-    impl<'tcx> TypeFolder<'tcx> for FixupFolder<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-            self.tcx\n-        }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match *ty.kind() {\n-                ty::Opaque(def_id, substs) => {\n-                    debug!(\"fixup_opaque_types: found type {:?}\", ty);\n-                    // Here, we replace any inference variables that occur within\n-                    // the substs of an opaque type. By definition, any type occurring\n-                    // in the substs has a corresponding generic parameter, which is what\n-                    // we replace it with.\n-                    // This replacement is only run on the function signature, so any\n-                    // inference variables that we come across must be the rust of projection\n-                    // (there's no other way for a user to get inference variables into\n-                    // a function signature).\n-                    if ty.needs_infer() {\n-                        let new_substs = InternalSubsts::for_item(self.tcx, def_id, |param, _| {\n-                            let old_param = substs[param.index as usize];\n-                            match old_param.unpack() {\n-                                GenericArgKind::Type(old_ty) => {\n-                                    if let ty::Infer(_) = old_ty.kind() {\n-                                        // Replace inference type with a generic parameter\n-                                        self.tcx.mk_param_from_def(param)\n-                                    } else {\n-                                        old_param.fold_with(self)\n-                                    }\n-                                }\n-                                GenericArgKind::Const(old_const) => {\n-                                    if let ty::ConstKind::Infer(_) = old_const.val {\n-                                        // This should never happen - we currently do not support\n-                                        // 'const projections', e.g.:\n-                                        // `impl<T: SomeTrait> MyTrait for T where <T as SomeTrait>::MyConst == 25`\n-                                        // which should be the only way for us to end up with a const inference\n-                                        // variable after projection. If Rust ever gains support for this kind\n-                                        // of projection, this should *probably* be changed to\n-                                        // `self.tcx.mk_param_from_def(param)`\n-                                        bug!(\n-                                            \"Found infer const: `{:?}` in opaque type: {:?}\",\n-                                            old_const,\n-                                            ty\n-                                        );\n-                                    } else {\n-                                        old_param.fold_with(self)\n-                                    }\n-                                }\n-                                GenericArgKind::Lifetime(old_region) => {\n-                                    if let RegionKind::ReVar(_) = old_region {\n-                                        self.tcx.mk_param_from_def(param)\n-                                    } else {\n-                                        old_param.fold_with(self)\n-                                    }\n-                                }\n-                            }\n-                        });\n-                        let new_ty = self.tcx.mk_opaque(def_id, new_substs);\n-                        debug!(\"fixup_opaque_types: new type: {:?}\", new_ty);\n-                        new_ty\n-                    } else {\n-                        ty\n-                    }\n-                }\n-                _ => ty.super_fold_with(self),\n-            }\n-        }\n-    }\n-\n-    debug!(\"fixup_opaque_types({:?})\", val);\n-    val.fold_with(&mut FixupFolder { tcx })\n-}\n-\n fn typeck_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n@@ -510,8 +397,6 @@ fn typeck_with_fallback<'tcx>(\n                 fn_sig,\n             );\n \n-            let fn_sig = fixup_opaque_types(tcx, fn_sig);\n-\n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {"}, {"sha": "0aa059b7de80fde78df7e570f621be4bbb307541", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "patch": "@@ -496,6 +496,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n+            let opaque_type_key = self.fcx.fully_resolve(opaque_type_key).unwrap();\n+\n             // Prevent:\n             // * `fn foo<T>() -> Foo<T>`\n             // * `fn foo<T: Bound + Other>() -> Foo<T>`\n@@ -508,6 +510,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // fn foo<U>() -> Foo<U> { .. }\n             // ```\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n+\n+            // FIXME: why are we calling this here? This seems too early, and duplicated.\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n                 opaque_type_key,\n                 instantiated_ty,\n@@ -529,33 +533,33 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             }\n \n-            if !opaque_type_key.substs.needs_infer() {\n-                // We only want to add an entry into `concrete_opaque_types`\n-                // if we actually found a defining usage of this opaque type.\n-                // Otherwise, we do nothing - we'll either find a defining usage\n-                // in some other location, or we'll end up emitting an error due\n-                // to the lack of defining usage\n-                if !skip_add {\n-                    let old_concrete_ty = self\n-                        .typeck_results\n-                        .concrete_opaque_types\n-                        .insert(opaque_type_key, definition_ty);\n-                    if let Some(old_concrete_ty) = old_concrete_ty {\n-                        if old_concrete_ty != definition_ty {\n-                            span_bug!(\n-                                span,\n-                                \"`visit_opaque_types` tried to write different types for the same \\\n+            if opaque_type_key.substs.needs_infer() {\n+                span_bug!(span, \"{:#?} has inference variables\", opaque_type_key.substs)\n+            }\n+\n+            // We only want to add an entry into `concrete_opaque_types`\n+            // if we actually found a defining usage of this opaque type.\n+            // Otherwise, we do nothing - we'll either find a defining usage\n+            // in some other location, or we'll end up emitting an error due\n+            // to the lack of defining usage\n+            if !skip_add {\n+                let old_concrete_ty = self\n+                    .typeck_results\n+                    .concrete_opaque_types\n+                    .insert(opaque_type_key, definition_ty);\n+                if let Some(old_concrete_ty) = old_concrete_ty {\n+                    if old_concrete_ty != definition_ty {\n+                        span_bug!(\n+                            span,\n+                            \"`visit_opaque_types` tried to write different types for the same \\\n                                  opaque type: {:?}, {:?}, {:?}, {:?}\",\n-                                opaque_type_key.def_id,\n-                                definition_ty,\n-                                opaque_defn,\n-                                old_concrete_ty,\n-                            );\n-                        }\n+                            opaque_type_key.def_id,\n+                            definition_ty,\n+                            opaque_defn,\n+                            old_concrete_ty,\n+                        );\n                     }\n                 }\n-            } else {\n-                self.tcx().sess.delay_span_bug(span, \"`opaque_defn` has inference variables\");\n             }\n         }\n     }"}, {"sha": "b7c8a58a656290da2fabd82e5ca7133a2c586c55", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "patch": "@@ -9,7 +9,7 @@ trait Bug {\n impl Bug for &() {\n     type Item = impl Bug; //~ ERROR `impl Trait` in type aliases is unstable\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n-    //~^^ ERROR could not find defining uses\n+    //~^^ ERROR the trait bound `(): Bug` is not satisfied\n \n     const FUN: fn() -> Self::Item = || ();\n     //~^ ERROR type alias impl trait is not permitted here"}, {"sha": "6857d5264b65ed717bc5bdf1410d3941fe57588d", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d36d69b4a0e6606b9a9c077302df7464ac1a4e7/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=7d36d69b4a0e6606b9a9c077302df7464ac1a4e7", "patch": "@@ -25,11 +25,14 @@ LL |     type Item = impl Bug;\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: could not find defining uses\n+error[E0277]: the trait bound `(): Bug` is not satisfied\n   --> $DIR/issue-60371.rs:10:17\n    |\n LL |     type Item = impl Bug;\n-   |                 ^^^^^^^^\n+   |                 ^^^^^^^^ the trait `Bug` is not implemented for `()`\n+   |\n+   = help: the following implementations were found:\n+             <&() as Bug>\n \n error: aborting due to 4 previous errors\n "}]}