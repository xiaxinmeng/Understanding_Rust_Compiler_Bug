{"sha": "b318bcfa784cead43a8b5aa553dcc4999e46b32e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMThiY2ZhNzg0Y2VhZDQzYThiNWFhNTUzZGNjNDk5OWU0NmIzMmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-24T18:05:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-02T20:33:36Z"}, "message": "refactor cast_immediate to dispatch on the type first, and on the value second", "tree": {"sha": "48dbd3479414518b8471c1b68ac43b70996dfaae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48dbd3479414518b8471c1b68ac43b70996dfaae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b318bcfa784cead43a8b5aa553dcc4999e46b32e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b318bcfa784cead43a8b5aa553dcc4999e46b32e", "html_url": "https://github.com/rust-lang/rust/commit/b318bcfa784cead43a8b5aa553dcc4999e46b32e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b318bcfa784cead43a8b5aa553dcc4999e46b32e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1e71895aa450606d99d7705dac20d689a330d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1e71895aa450606d99d7705dac20d689a330d1", "html_url": "https://github.com/rust-lang/rust/commit/ec1e71895aa450606d99d7705dac20d689a330d1"}], "stats": {"total": 110, "additions": 46, "deletions": 64}, "files": [{"sha": "4758e7ff170bdd13aef2e777b0b5e6801c61b192", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 46, "deletions": 64, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b318bcfa784cead43a8b5aa553dcc4999e46b32e/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b318bcfa784cead43a8b5aa553dcc4999e46b32e/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b318bcfa784cead43a8b5aa553dcc4999e46b32e", "patch": "@@ -14,15 +14,6 @@ use rustc::mir::CastKind;\n use super::{InterpCx, Machine, PlaceTy, OpTy, ImmTy, Immediate, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::Ref(_, ty, _) => !self.type_is_sized(ty),\n-            ty::Adt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n-            _ => false,\n-        }\n-    }\n-\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n@@ -99,68 +90,59 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: ImmTy<'tcx, M::PointerTag>,\n         dest_layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n-        if self.type_is_fat_ptr(src.layout.ty) {\n-            return match (*src, self.type_is_fat_ptr(dest_layout.ty)) {\n-                // pointers to extern types\n-                (Immediate::Scalar(_),_) |\n-                // slices and trait objects to other slices/trait objects\n-                (Immediate::ScalarPair(..), true) => {\n-                    // No change to immediate\n-                    Ok(*src)\n-                }\n-                // slices and trait objects to thin pointers (dropping the metadata)\n-                (Immediate::ScalarPair(data, _), false) => {\n-                    Ok(data.into())\n-                }\n-            };\n-        } else {\n-            match src.layout.variants {\n-                layout::Variants::Single { index } => {\n-                    if let Some(discr) =\n-                        src.layout.ty.discriminant_for_variant(*self.tcx, index)\n-                    {\n-                        // Cast from a univariant enum\n-                        assert!(src.layout.is_zst());\n-                        return Ok(Scalar::from_uint(discr.val, dest_layout.size).into());\n-                    }\n-                }\n-                layout::Variants::Multiple { .. } => {},\n-            }\n-\n-            return Ok(self.cast_scalar(src.to_scalar()?, src.layout, dest_layout)?.into());\n-        }\n-    }\n-\n-    fn cast_scalar(\n-        &self,\n-        val: Scalar<M::PointerTag>,\n-        src_layout: TyLayout<'tcx>,\n-        dest_layout: TyLayout<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n+        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n \n-        match src_layout.ty.sty {\n+        match src.layout.ty.sty {\n             // Floating point\n-            Float(FloatTy::F32) => self.cast_from_float(val.to_f32()?, dest_layout.ty),\n-            Float(FloatTy::F64) => self.cast_from_float(val.to_f64()?, dest_layout.ty),\n-            // Integer(-like), including fn ptr casts and casts from enums that\n-            // are represented as integers (this excludes univariant enums, which\n-            // are handled in `cast` directly).\n-            _ => {\n+            Float(FloatTy::F32) =>\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty)?.into()),\n+            Float(FloatTy::F64) =>\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty)?.into()),\n+            // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n+            // are represented as integers.\n+            _ =>\n                 assert!(\n-                    src_layout.ty.is_bool()       || src_layout.ty.is_char()     ||\n-                    src_layout.ty.is_enum()       || src_layout.ty.is_integral() ||\n-                    src_layout.ty.is_unsafe_ptr() || src_layout.ty.is_fn_ptr()   ||\n-                    src_layout.ty.is_region_ptr(),\n-                    \"Unexpected cast from type {:?}\", src_layout.ty\n-                );\n-                match val.to_bits_or_ptr(src_layout.size, self) {\n-                    Err(ptr) => self.cast_from_ptr(ptr, src_layout, dest_layout),\n-                    Ok(data) => self.cast_from_int(data, src_layout, dest_layout),\n+                    src.layout.ty.is_bool()       || src.layout.ty.is_char()     ||\n+                    src.layout.ty.is_enum()       || src.layout.ty.is_integral() ||\n+                    src.layout.ty.is_unsafe_ptr() || src.layout.ty.is_fn_ptr()   ||\n+                    src.layout.ty.is_region_ptr(),\n+                    \"Unexpected cast from type {:?}\", src.layout.ty\n+                )\n+        }\n+\n+        // Handle cast the metadata away from a fat pointer.\n+        if dest_layout.size != src.layout.size {\n+            assert_eq!(dest_layout.size, self.memory.pointer_size());\n+            return match *src {\n+                Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                Immediate::Scalar(..) =>\n+                    bug!(\n+                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                        *src, src.layout.ty, dest_layout.ty\n+                    ),\n+            };\n+        }\n+\n+        // Handle cast from a univariant (ZST) enum\n+        match src.layout.variants {\n+            layout::Variants::Single { index } => {\n+                if let Some(discr) =\n+                    src.layout.ty.discriminant_for_variant(*self.tcx, index)\n+                {\n+                    assert!(src.layout.is_zst());\n+                    return Ok(Scalar::from_uint(discr.val, dest_layout.size).into());\n                 }\n             }\n+            layout::Variants::Multiple { .. } => {},\n         }\n+\n+        // Handle all the rest.\n+        let val = src.to_scalar()?;\n+        Ok(match val.to_bits_or_ptr(src.layout.size, self) {\n+            Err(ptr) => self.cast_from_ptr(ptr, src.layout, dest_layout)?,\n+            Ok(data) => self.cast_from_int(data, src.layout, dest_layout)?,\n+        }.into())\n     }\n \n     fn cast_from_int("}]}