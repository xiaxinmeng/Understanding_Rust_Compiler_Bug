{"sha": "d7f94516345a36ddfcd68cbdf1df835d356795c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3Zjk0NTE2MzQ1YTM2ZGRmY2Q2OGNiZGYxZGY4MzVkMzU2Nzk1YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-19T14:17:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-19T14:17:08Z"}, "message": "Auto merge of #74518 - Manishearth:rollup-jfmnh1r, r=Manishearth\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #74333 (Deny unsafe operations in unsafe functions in libstd/alloc.rs)\n - #74356 (Remove combine function)\n - #74419 (Add a thumbv4t-none-eabi target)\n - #74485 (More intra-doc links, add explicit exception list to linkchecker)\n\nFailed merges:\n\n - #74486 (Improve Read::read_exact documentation)\n\nr? @ghost", "tree": {"sha": "bea3e4ab40d0c1eaf79c02d717cf8f5be4d3366f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bea3e4ab40d0c1eaf79c02d717cf8f5be4d3366f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7f94516345a36ddfcd68cbdf1df835d356795c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f94516345a36ddfcd68cbdf1df835d356795c3", "html_url": "https://github.com/rust-lang/rust/commit/d7f94516345a36ddfcd68cbdf1df835d356795c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7f94516345a36ddfcd68cbdf1df835d356795c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48036804d2bc461b243c5d291b850e44bcca68ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/48036804d2bc461b243c5d291b850e44bcca68ef", "html_url": "https://github.com/rust-lang/rust/commit/48036804d2bc461b243c5d291b850e44bcca68ef"}, {"sha": "1636961a0e02adb7a1200d98a3c94f68decd3a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/1636961a0e02adb7a1200d98a3c94f68decd3a13", "html_url": "https://github.com/rust-lang/rust/commit/1636961a0e02adb7a1200d98a3c94f68decd3a13"}], "stats": {"total": 701, "additions": 322, "deletions": 379}, "files": [{"sha": "d2f4278d0d0e0a817d51246c971265c4056c6103", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -47,9 +47,9 @@ use UnderflowResult::*;\n /// any other key, as determined by the [`Ord`] trait, changes while it is in the map. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// [`Ord`]: ../../std/cmp/trait.Ord.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Ord`]: core::cmp::Ord\n+/// [`Cell`]: core::cell::Cell\n+/// [`RefCell`]: core::cell::RefCell\n ///\n /// # Examples\n ///\n@@ -256,8 +256,7 @@ where\n /// This `struct` is created by the [`iter`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter`]: struct.BTreeMap.html#method.iter\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`iter`]: BTreeMap::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     range: Range<'a, K, V>,\n@@ -276,8 +275,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Iter<'_, K, V> {\n /// This `struct` is created by the [`iter_mut`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter_mut`]: struct.BTreeMap.html#method.iter_mut\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`iter_mut`]: BTreeMap::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n@@ -290,8 +288,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// This `struct` is created by the [`into_iter`] method on [`BTreeMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`into_iter`]: struct.BTreeMap.html#method.into_iter\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n@@ -315,8 +312,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n /// This `struct` is created by the [`keys`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`keys`]: struct.BTreeMap.html#method.keys\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`keys`]: BTreeMap::keys\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -334,8 +330,7 @@ impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// This `struct` is created by the [`values`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`values`]: struct.BTreeMap.html#method.values\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`values`]: BTreeMap::values\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -353,8 +348,7 @@ impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n /// This `struct` is created by the [`values_mut`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`values_mut`]: struct.BTreeMap.html#method.values_mut\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`values_mut`]: BTreeMap::values_mut\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n #[derive(Debug)]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n@@ -366,8 +360,7 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// This `struct` is created by the [`range`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`range`]: struct.BTreeMap.html#method.range\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`range`]: BTreeMap::range\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n     front: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n@@ -386,8 +379,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// This `struct` is created by the [`range_mut`] method on [`BTreeMap`]. See its\n /// documentation for more.\n ///\n-/// [`range_mut`]: struct.BTreeMap.html#method.range_mut\n-/// [`BTreeMap`]: struct.BTreeMap.html\n+/// [`range_mut`]: BTreeMap::range_mut\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n     front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n@@ -412,8 +404,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n ///\n /// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n ///\n-/// [`BTreeMap`]: struct.BTreeMap.html\n-/// [`entry`]: struct.BTreeMap.html#method.entry\n+/// [`entry`]: BTreeMap::entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant entry."}, {"sha": "35f4ef1d9b4c7a3750e15cd76bfe714833b632a2", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -22,9 +22,9 @@ use super::Recover;\n /// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n-/// [`Ord`]: ../../std/cmp/trait.Ord.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Ord`]: core::cmp::Ord\n+/// [`Cell`]: core::cell::Cell\n+/// [`RefCell`]: core::cell::RefCell\n ///\n /// # Examples\n ///"}, {"sha": "339592728ac24b012451fb6ce5999afcfe458c28", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -240,8 +240,6 @@ impl str {\n     /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n     /// replaces them with the replacement string slice.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -280,8 +278,6 @@ impl str {\n     /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n     /// replaces them with the replacement string slice at most `count` times.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -324,8 +320,6 @@ impl str {\n     /// the case, this function returns a [`String`] instead of modifying the\n     /// parameter in-place.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -411,8 +405,6 @@ impl str {\n     /// the case, this function returns a [`String`] instead of modifying the\n     /// parameter in-place.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -459,8 +451,7 @@ impl str {\n \n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    /// [`Box<str>`]: boxed/struct.Box.html\n+    /// [`Box<str>`]: Box\n     ///\n     /// # Examples\n     ///\n@@ -485,8 +476,6 @@ impl str {\n     ///\n     /// This function will panic if the capacity would overflow.\n     ///\n-    /// [`String`]: string/struct.String.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -525,7 +514,7 @@ impl str {\n     /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n     /// ```\n     ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`make_ascii_uppercase`]: str::make_ascii_uppercase\n     /// [`to_uppercase`]: #method.to_uppercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n@@ -555,7 +544,7 @@ impl str {\n     /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n     /// ```\n     ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`make_ascii_lowercase`]: str::make_ascii_lowercase\n     /// [`to_lowercase`]: #method.to_lowercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]"}, {"sha": "1c3879c40c2f94c384009967e4c5e5a73bdb5bde", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 45, "deletions": 87, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -4,8 +4,6 @@\n //! [`ToString`]s, and several error types that may result from working with\n //! [`String`]s.\n //!\n-//! [`ToString`]: trait.ToString.html\n-//!\n //! # Examples\n //!\n //! There are multiple ways to create a new [`String`] from a string literal:\n@@ -20,8 +18,6 @@\n //! You can create a new [`String`] from an existing one by concatenating with\n //! `+`:\n //!\n-//! [`String`]: struct.String.html\n-//!\n //! ```\n //! let s = \"Hello\".to_string();\n //!\n@@ -67,11 +63,11 @@ use crate::vec::Vec;\n /// contents of the string. It has a close relationship with its borrowed\n /// counterpart, the primitive [`str`].\n ///\n-/// [`str`]: ../../std/primitive.str.html\n-///\n /// # Examples\n ///\n-/// You can create a `String` from a literal string with [`String::from`]:\n+/// You can create a `String` from [a literal string][str] with [`String::from`]:\n+///\n+/// [`String::from`]: From::from\n ///\n /// ```\n /// let hello = String::from(\"Hello, world!\");\n@@ -87,10 +83,8 @@ use crate::vec::Vec;\n /// hello.push_str(\"orld!\");\n /// ```\n ///\n-/// [`String::from`]: #method.from\n-/// [`char`]: ../../std/primitive.char.html\n-/// [`push`]: #method.push\n-/// [`push_str`]: #method.push_str\n+/// [`push`]: String::push\n+/// [`push_str`]: String::push_str\n ///\n /// If you have a vector of UTF-8 bytes, you can create a `String` from it with\n /// the [`from_utf8`] method:\n@@ -105,7 +99,7 @@ use crate::vec::Vec;\n /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n /// ```\n ///\n-/// [`from_utf8`]: #method.from_utf8\n+/// [`from_utf8`]: String::from_utf8\n ///\n /// # UTF-8\n ///\n@@ -128,8 +122,8 @@ use crate::vec::Vec;\n /// The [`bytes`] and [`chars`] methods return iterators over the first\n /// two, respectively.\n ///\n-/// [`bytes`]: #method.bytes\n-/// [`chars`]: #method.chars\n+/// [`bytes`]: str::bytes\n+/// [`chars`]: str::chars\n ///\n /// # Deref\n ///\n@@ -215,9 +209,9 @@ use crate::vec::Vec;\n /// assert_eq!(String::from(\"Once upon a time...\"), s);\n /// ```\n ///\n-/// [`as_ptr`]: #method.as_ptr\n-/// [`len`]: #method.len\n-/// [`capacity`]: #method.capacity\n+/// [`as_ptr`]: str::as_ptr\n+/// [`len`]: String::len\n+/// [`capacity`]: String::capacity\n ///\n /// If a `String` has enough capacity, adding elements to it will not\n /// re-allocate. For example, consider this program:\n@@ -259,7 +253,7 @@ use crate::vec::Vec;\n /// }\n /// ```\n ///\n-/// [`with_capacity`]: #method.with_capacity\n+/// [`with_capacity`]: String::with_capacity\n ///\n /// We end up with a different output:\n ///\n@@ -274,9 +268,9 @@ use crate::vec::Vec;\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n ///\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`Deref`]: ../../std/ops/trait.Deref.html\n-/// [`as_str()`]: struct.String.html#method.as_str\n+/// [`&str`]: str\n+/// [`Deref`]: core::ops::Deref\n+/// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"string_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -291,20 +285,18 @@ pub struct String {\n /// [`into_bytes`] method will give back the byte vector that was used in the\n /// conversion attempt.\n ///\n-/// [`from_utf8`]: struct.String.html#method.from_utf8\n-/// [`String`]: struct.String.html\n-/// [`into_bytes`]: struct.FromUtf8Error.html#method.into_bytes\n+/// [`from_utf8`]: String::from_utf8\n+/// [`into_bytes`]: FromUtf8Error::into_bytes\n ///\n /// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n /// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n /// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n /// through the [`utf8_error`] method.\n ///\n-/// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n-/// [`std::str`]: ../../std/str/index.html\n-/// [`u8`]: ../../std/primitive.u8.html\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`utf8_error`]: #method.utf8_error\n+/// [`Utf8Error`]: core::str::Utf8Error\n+/// [`std::str`]: core::str\n+/// [`&str`]: str\n+/// [`utf8_error`]: Self::utf8_error\n ///\n /// # Examples\n ///\n@@ -330,9 +322,7 @@ pub struct FromUtf8Error {\n ///\n /// This type is the error type for the [`from_utf16`] method on [`String`].\n ///\n-/// [`from_utf16`]: struct.String.html#method.from_utf16\n-/// [`String`]: struct.String.html\n-///\n+/// [`from_utf16`]: String::from_utf16\n /// # Examples\n ///\n /// Basic usage:\n@@ -358,7 +348,7 @@ impl String {\n     /// consider the [`with_capacity`] method to prevent excessive\n     /// re-allocation.\n     ///\n-    /// [`with_capacity`]: #method.with_capacity\n+    /// [`with_capacity`]: String::with_capacity\n     ///\n     /// # Examples\n     ///\n@@ -383,12 +373,12 @@ impl String {\n     /// appending a bunch of data to the `String`, reducing the number of\n     /// reallocations it needs to do.\n     ///\n-    /// [`capacity`]: #method.capacity\n+    /// [`capacity`]: String::capacity\n     ///\n     /// If the given capacity is `0`, no allocation will occur, and this method\n     /// is identical to the [`new`] method.\n     ///\n-    /// [`new`]: #method.new\n+    /// [`new`]: String::new\n     ///\n     /// # Examples\n     ///\n@@ -479,15 +469,10 @@ impl String {\n     /// See the docs for [`FromUtf8Error`] for more details on what you can do\n     /// with this error.\n     ///\n-    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n-    /// [`String`]: struct.String.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n-    /// [`&str`]: ../../std/primitive.str.html\n-    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n-    /// [`into_bytes`]: struct.String.html#method.into_bytes\n-    /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`from_utf8_unchecked`]: String::from_utf8_unchecked\n+    /// [`Vec<u8>`]: crate::vec::Vec\n+    /// [`&str`]: str\n+    /// [`into_bytes`]: String::into_bytes\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -506,24 +491,23 @@ impl String {\n     /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD], which looks like this: \ufffd\n     ///\n-    /// [`u8`]: ../../std/primitive.u8.html\n     /// [byteslice]: ../../std/primitive.slice.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [U+FFFD]: core::char::REPLACEMENT_CHARACTER\n     ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the conversion, there is an unsafe version\n     /// of this function, [`from_utf8_unchecked`], which has the same behavior\n     /// but skips the checks.\n     ///\n-    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n+    /// [`from_utf8_unchecked`]: String::from_utf8_unchecked\n     ///\n     /// This function returns a [`Cow<'a, str>`]. If our byte slice is invalid\n     /// UTF-8, then we need to insert the replacement characters, which will\n     /// change the size of the string, and hence, require a `String`. But if\n     /// it's already valid UTF-8, we don't need a new allocation. This return\n     /// type allows us to handle both cases.\n     ///\n-    /// [`Cow<'a, str>`]: ../../std/borrow/enum.Cow.html\n+    /// [`Cow<'a, str>`]: crate::borrow::Cow\n     ///\n     /// # Examples\n     ///\n@@ -583,8 +567,6 @@ impl String {\n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -623,9 +605,9 @@ impl String {\n     /// `from_utf16_lossy` returns a `String` since the UTF-16 to UTF-8\n     /// conversion requires a memory allocation.\n     ///\n-    /// [`from_utf8_lossy`]: #method.from_utf8_lossy\n-    /// [`Cow<'a, str>`]: ../borrow/enum.Cow.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`from_utf8_lossy`]: String::from_utf8_lossy\n+    /// [`Cow<'a, str>`]: crate::borrow::Cow\n+    /// [U+FFFD]: core::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -659,7 +641,7 @@ impl String {\n     /// into a `String` with the [`from_raw_parts`] function, allowing\n     /// the destructor to perform the cleanup.\n     ///\n-    /// [`from_raw_parts`]: #method.from_raw_parts\n+    /// [`from_raw_parts`]: String::from_raw_parts\n     ///\n     /// # Examples\n     ///\n@@ -732,7 +714,7 @@ impl String {\n     ///\n     /// See the safe version, [`from_utf8`], for more details.\n     ///\n-    /// [`from_utf8`]: struct.String.html#method.from_utf8\n+    /// [`from_utf8`]: String::from_utf8\n     ///\n     /// # Safety\n     ///\n@@ -867,8 +849,7 @@ impl String {\n     ///\n     /// Panics if the new capacity overflows [`usize`].\n     ///\n-    /// [`reserve_exact`]: struct.String.html#method.reserve_exact\n-    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`reserve_exact`]: String::reserve_exact\n     ///\n     /// # Examples\n     ///\n@@ -911,7 +892,7 @@ impl String {\n     /// Consider using the [`reserve`] method unless you absolutely know\n     /// better than the allocator.\n     ///\n-    /// [`reserve`]: #method.reserve\n+    /// [`reserve`]: String::reserve\n     ///\n     /// # Panics\n     ///\n@@ -1076,8 +1057,6 @@ impl String {\n \n     /// Appends the given [`char`] to the end of this `String`.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1104,7 +1083,7 @@ impl String {\n     ///\n     /// The inverse of this method is [`from_utf8`].\n     ///\n-    /// [`from_utf8`]: #method.from_utf8\n+    /// [`from_utf8`]: String::from_utf8\n     ///\n     /// # Examples\n     ///\n@@ -1133,8 +1112,6 @@ impl String {\n     ///\n     /// Panics if `new_len` does not lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1159,8 +1136,6 @@ impl String {\n     ///\n     /// Returns [`None`] if this `String` is empty.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1195,8 +1170,6 @@ impl String {\n     /// Panics if `idx` is larger than or equal to the `String`'s length,\n     /// or if it does not lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1297,8 +1270,6 @@ impl String {\n     /// Panics if `idx` is larger than the `String`'s length, or if it does not\n     /// lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1346,8 +1317,6 @@ impl String {\n     /// Panics if `idx` is larger than the `String`'s length, or if it does not\n     /// lie on a [`char`] boundary.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1507,8 +1476,6 @@ impl String {\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1567,9 +1534,6 @@ impl String {\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n-    /// [`char`]: ../../std/primitive.char.html\n-    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1610,9 +1574,6 @@ impl String {\n     ///\n     /// This will drop any excess capacity.\n     ///\n-    /// [`Box`]: ../../std/boxed/struct.Box.html\n-    /// [`str`]: ../../std/primitive.str.html\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1680,10 +1641,8 @@ impl FromUtf8Error {\n     /// an analogue to `FromUtf8Error`. See its documentation for more details\n     /// on using it.\n     ///\n-    /// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n-    /// [`std::str`]: ../../std/str/index.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`std::str`]: core::str\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -2187,7 +2146,7 @@ impl ops::DerefMut for String {\n ///\n /// This alias exists for backwards compatibility, and may be eventually deprecated.\n ///\n-/// [`Infallible`]: ../../core/convert/enum.Infallible.html\n+/// [`Infallible`]: core::convert::Infallible\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n pub type ParseError = core::convert::Infallible;\n \n@@ -2207,7 +2166,7 @@ impl FromStr for String {\n /// [`Display`] should be implemented instead, and you get the `ToString`\n /// implementation for free.\n ///\n-/// [`Display`]: ../../std/fmt/trait.Display.html\n+/// [`Display`]: fmt::Display\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToString {\n     /// Converts the given value to a `String`.\n@@ -2465,8 +2424,7 @@ impl fmt::Write for String {\n /// This struct is created by the [`drain`] method on [`String`]. See its\n /// documentation for more.\n ///\n-/// [`drain`]: struct.String.html#method.drain\n-/// [`String`]: struct.String.html\n+/// [`drain`]: String::drain\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a> {\n     /// Will be used as &'a mut String in the destructor"}, {"sha": "790ec4bd24f8dcab225c7a3c52ee4550f497e270", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -4,7 +4,7 @@\n //!\n //! For more details, see the [`std::str`] module.\n //!\n-//! [`std::str`]: ../../std/str/index.html\n+//! [`std::str`]: self\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -163,13 +163,11 @@ Section: Creating a string\n /// Errors which can occur when attempting to interpret a sequence of [`u8`]\n /// as a string.\n ///\n-/// [`u8`]: ../../std/primitive.u8.html\n-///\n /// As such, the `from_utf8` family of functions and methods for both [`String`]s\n /// and [`&str`]s make use of this error, for example.\n ///\n /// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n-/// [`&str`]: ../../std/str/fn.from_utf8.html\n+/// [`&str`]: from_utf8\n ///\n /// # Examples\n ///"}, {"sha": "d53033ba3ba2043d79e4330df412e17455f5f782", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -676,6 +676,7 @@ supported_targets! {\n     (\"powerpc64-wrs-vxworks\", powerpc64_wrs_vxworks),\n \n     (\"mipsel-sony-psp\", mipsel_sony_psp),\n+    (\"thumbv4t-none-eabi\", thumbv4t_none_eabi),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target."}, {"sha": "31417b0154759faa03b14f51e61fc522ca407890", "filename": "src/librustc_target/spec/thumbv4t_none_eabi.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -0,0 +1,62 @@\n+//! Targets the ARMv4T, with code as `t32` code by default.\n+//!\n+//! Primarily of use for the GBA, but usable with other devices too.\n+//!\n+//! Please ping @Lokathor if changes are needed.\n+//!\n+//! This target profile assumes that you have the ARM binutils in your path (specifically the linker, `arm-none-eabi-ld`). They can be obtained for free for all major OSes from the ARM developer's website, and they may also be available in your system's package manager. Unfortunately, the standard linker that Rust uses (`lld`) only supports as far back as `ARMv5TE`, so we must use the GNU `ld` linker.\n+//!\n+//! **Important:** This target profile **does not** specify a linker script. You just get the default link script when you build a binary for this target. The default link script is very likely wrong, so you should use `-Clink-arg=-Tmy_script.ld` to override that with a correct linker script.\n+\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"thumbv4t-none-eabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"\".to_string(),\n+        arch: \"arm\".to_string(),\n+        /* Data layout args are '-' separated:\n+         * little endian\n+         * stack is 64-bit aligned (EABI)\n+         * pointers are 32-bit\n+         * i64 must be 64-bit aligned (EABI)\n+         * mangle names with ELF style\n+         * native integers are 32-bit\n+         * All other elements are default\n+         */\n+        data_layout: \"e-S64-p:32:32-i64:64-m:e-n32\".to_string(),\n+        linker_flavor: LinkerFlavor::Ld,\n+        options: TargetOptions {\n+            linker: Some(\"arm-none-eabi-ld\".to_string()),\n+            linker_is_gnu: true,\n+\n+            // extra args passed to the external assembler (assuming `arm-none-eabi-as`):\n+            // * activate t32/a32 interworking\n+            // * use arch ARMv4T\n+            // * use little-endian\n+            asm_args: vec![\n+                \"-mthumb-interwork\".to_string(),\n+                \"-march=armv4t\".to_string(),\n+                \"-mlittle-endian\".to_string(),\n+            ],\n+\n+            // minimum extra features, these cannot be disabled via -C\n+            features: \"+soft-float,+strict-align\".to_string(),\n+\n+            main_needs_argc_argv: false,\n+\n+            // No thread-local storage (just use a static Cell)\n+            has_elf_tls: false,\n+\n+            // don't have atomic compare-and-swap\n+            atomic_cas: false,\n+\n+            ..super::thumb_base::opts()\n+        },\n+    })\n+}"}, {"sha": "ecfaaeace513e329873de16187a83875b0c5a4c4", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -59,6 +59,7 @@\n //! The `#[global_allocator]` can only be used once in a crate\n //! or its recursive dependencies.\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics;\n@@ -158,7 +159,9 @@ unsafe impl AllocRef for System {\n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+            // SAFETY: The safety guarantees are explained in the documentation\n+            // for the `GlobalAlloc` trait and its `dealloc` method.\n+            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -184,16 +187,36 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: The new size and layout alignement guarantees\n+                    // are transfered to the caller (they come from parameters).\n+                    //\n+                    // See the preconditions for `Layout::from_size_align` to\n+                    // see what must be checked.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size > size` or something similar.\n-                intrinsics::assume(new_size > size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                init.init_offset(memory, size);\n+                // SAFETY:\n+                //\n+                // The safety guarantees are explained in the documentation\n+                // for the `GlobalAlloc` trait and its `dealloc` method.\n+                //\n+                // `realloc` probably checks for `new_size > size` or something\n+                // similar.\n+                //\n+                // For the guarantees about `init_offset`, see its documentation:\n+                // `ptr` is assumed valid (and checked for non-NUL) and\n+                // `memory.size` is set to `new_size` so the offset being `size`\n+                // is valid.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    let memory =\n+                        MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                    init.init_offset(memory, size);\n+                    memory\n+                };\n                 Ok(memory)\n             }\n         }\n@@ -220,14 +243,28 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                self.dealloc(ptr, layout);\n+                // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n+                // must be respected. `ptr` and `layout` are parameters and so\n+                // those guarantees must be checked by the caller.\n+                unsafe { self.dealloc(ptr, layout) };\n                 Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size < size` or something similar.\n-                intrinsics::assume(new_size < size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n+                // SAFETY:\n+                //\n+                // See `GlobalAlloc::realloc` for more informations about the\n+                // guarantees expected by this method. `ptr`, `layout` and\n+                // `new_size` are parameters and the responsability for their\n+                // correctness is left to the caller.\n+                //\n+                // `realloc` probably checks for `new_size < size` or something\n+                // similar.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n+                };\n+                Ok(memory)\n             }\n         }\n     }\n@@ -300,13 +337,19 @@ pub mod __default_lib_allocator {\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc(layout)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_dealloc(ptr: *mut u8, size: usize, align: usize) {\n-        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::dealloc`.\n+        unsafe { System.dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n     }\n \n     #[rustc_std_internal_symbol]\n@@ -316,13 +359,21 @@ pub mod __default_lib_allocator {\n         align: usize,\n         new_size: usize,\n     ) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr, old_layout, new_size)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::realloc`.\n+        unsafe {\n+            let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+            System.realloc(ptr, old_layout, new_size)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc_zeroed(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc_zeroed`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc_zeroed(layout)\n+        }\n     }\n }"}, {"sha": "7b48deee1abdf73f013f49637742fc7e13424d46", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 19, "deletions": 68, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -148,14 +148,11 @@ use crate::sys;\n /// The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n /// We must also derive [`PartialEq`].\n ///\n-/// [`Eq`]: ../../std/cmp/trait.Eq.html\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n-/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`default`]: #method.default\n-/// [`with_hasher`]: #method.with_hasher\n-/// [`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n+/// [`RefCell`]: crate::cell::RefCell\n+/// [`Cell`]: crate::cell::Cell\n+/// [`default`]: Default::default\n+/// [`with_hasher`]: Self::with_hasher\n+/// [`with_capacity_and_hasher`]: Self::with_capacity_and_hasher\n /// [`fnv`]: https://crates.io/crates/fnv\n ///\n /// ```\n@@ -264,8 +261,6 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_hasher(s);\n     /// map.insert(1, 2);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n@@ -296,8 +291,6 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n     /// map.insert(1, 2);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n@@ -524,8 +517,6 @@ impl<K, V, S> HashMap<K, V, S> {\n \n     /// Returns a reference to the map's [`BuildHasher`].\n     ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -556,8 +547,6 @@ where\n     ///\n     /// Panics if the new allocation size overflows [`usize`].\n     ///\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -676,9 +665,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -705,9 +691,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -734,9 +717,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -763,9 +743,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -797,8 +774,7 @@ where\n     /// types that can be `==` without being identical. See the [module-level\n     /// documentation] for more.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [module-level documentation]: index.html#insert-and-complex-keys\n+    /// [module-level documentation]: crate::collections#insert-and-complex-keys\n     ///\n     /// # Examples\n     ///\n@@ -826,9 +802,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -856,9 +829,6 @@ where\n     /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1040,8 +1010,7 @@ where\n /// This `struct` is created by the [`iter`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter`]: struct.HashMap.html#method.iter\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`iter`]: HashMap::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     base: base::Iter<'a, K, V>,\n@@ -1068,8 +1037,7 @@ impl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n /// This `struct` is created by the [`iter_mut`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`iter_mut`]: struct.HashMap.html#method.iter_mut\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`iter_mut`]: HashMap::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     base: base::IterMut<'a, K, V>,\n@@ -1088,8 +1056,7 @@ impl<'a, K, V> IterMut<'a, K, V> {\n /// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`into_iter`]: struct.HashMap.html#method.into_iter\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     base: base::IntoIter<K, V>,\n@@ -1108,8 +1075,7 @@ impl<K, V> IntoIter<K, V> {\n /// This `struct` is created by the [`keys`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`keys`]: struct.HashMap.html#method.keys\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`keys`]: HashMap::keys\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -1136,8 +1102,7 @@ impl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n /// This `struct` is created by the [`values`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`values`]: struct.HashMap.html#method.values\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`values`]: HashMap::values\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Iter<'a, K, V>,\n@@ -1164,8 +1129,7 @@ impl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n /// This `struct` is created by the [`drain`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`drain`]: struct.HashMap.html#method.drain\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`drain`]: HashMap::drain\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     base: base::Drain<'a, K, V>,\n@@ -1184,8 +1148,7 @@ impl<'a, K, V> Drain<'a, K, V> {\n /// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n /// documentation for more.\n ///\n-/// [`values_mut`]: struct.HashMap.html#method.values_mut\n-/// [`HashMap`]: struct.HashMap.html\n+/// [`values_mut`]: HashMap::values_mut\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n@@ -1195,7 +1158,7 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n ///\n /// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n ///\n-/// [`HashMap::raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n+/// [`HashMap::raw_entry_mut`]: HashMap::raw_entry_mut\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n@@ -1209,9 +1172,8 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n /// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n /// then calling one of the methods of that [`RawEntryBuilderMut`].\n ///\n-/// [`HashMap`]: struct.HashMap.html\n /// [`Entry`]: enum.Entry.html\n-/// [`raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n+/// [`raw_entry_mut`]: HashMap::raw_entry_mut\n /// [`RawEntryBuilderMut`]: struct.RawEntryBuilderMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n@@ -1223,17 +1185,13 @@ pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n \n /// A view into an occupied entry in a `HashMap`.\n /// It is part of the [`RawEntryMut`] enum.\n-///\n-/// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n     base: base::RawOccupiedEntryMut<'a, K, V>,\n }\n \n /// A view into a vacant entry in a `HashMap`.\n /// It is part of the [`RawEntryMut`] enum.\n-///\n-/// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     base: base::RawVacantEntryMut<'a, K, V, S>,\n@@ -1243,7 +1201,7 @@ pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n ///\n /// See the [`HashMap::raw_entry`] docs for usage examples.\n ///\n-/// [`HashMap::raw_entry`]: struct.HashMap.html#method.raw_entry\n+/// [`HashMap::raw_entry`]: HashMap::raw_entry\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a HashMap<K, V, S>,\n@@ -1597,8 +1555,7 @@ impl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n ///\n /// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n ///\n-/// [`HashMap`]: struct.HashMap.html\n-/// [`entry`]: struct.HashMap.html#method.entry\n+/// [`entry`]: HashMap::entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied entry.\n@@ -2156,7 +2113,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// If you need a reference to the `OccupiedEntry` which may outlive the\n     /// destruction of the `Entry` value, see [`into_mut`].\n     ///\n-    /// [`into_mut`]: #method.into_mut\n+    /// [`into_mut`]: Self::into_mut\n     ///\n     /// # Examples\n     ///\n@@ -2189,7 +2146,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n     ///\n-    /// [`get_mut`]: #method.get_mut\n+    /// [`get_mut`]: Self::get_mut\n     ///\n     /// # Examples\n     ///\n@@ -2475,9 +2432,6 @@ where\n /// [`Hasher`], but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n ///\n-/// [`HashMap`]: struct.HashMap.html\n-/// [`Hasher`]: ../../hash/trait.Hasher.html\n-///\n /// # Examples\n ///\n /// ```\n@@ -2547,9 +2501,6 @@ impl BuildHasher for RandomState {\n ///\n /// The internal algorithm is not specified, and so it and its hashes should\n /// not be relied upon over releases.\n-///\n-/// [`RandomState`]: struct.RandomState.html\n-/// [`Hasher`]: ../../hash/trait.Hasher.html\n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n #[allow(deprecated)]\n #[derive(Clone, Debug)]"}, {"sha": "10bf917daea4680534d685b4ba7678b98974d6f3", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 9, "deletions": 38, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -98,12 +98,8 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// // use the values stored in the set\n /// ```\n ///\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`Eq`]: ../../std/cmp/trait.Eq.html\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n-/// [`HashMap`]: struct.HashMap.html\n-/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`RefCell`]: crate::cell::RefCell\n+/// [`Cell`]: crate::cell::Cell\n #[derive(Clone)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -286,8 +282,6 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_hasher(s);\n     /// set.insert(2);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n@@ -318,8 +312,6 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n     /// set.insert(1);\n     /// ```\n-    ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n@@ -328,8 +320,6 @@ impl<T, S> HashSet<T, S> {\n \n     /// Returns a reference to the set's [`BuildHasher`].\n     ///\n-    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -577,9 +567,6 @@ where\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n@@ -605,9 +592,6 @@ where\n     /// assert_eq!(set.get(&2), Some(&2));\n     /// assert_eq!(set.get(&4), None);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n@@ -849,9 +833,6 @@ where\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n@@ -877,9 +858,6 @@ where\n     /// assert_eq!(set.take(&2), Some(2));\n     /// assert_eq!(set.take(&2), None);\n     /// ```\n-    ///\n-    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n-    /// [`Hash`]: ../../std/hash/trait.Hash.html\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n@@ -1153,8 +1131,7 @@ where\n /// This `struct` is created by the [`iter`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`iter`]: struct.HashSet.html#method.iter\n+/// [`iter`]: HashSet::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>,\n@@ -1165,8 +1142,7 @@ pub struct Iter<'a, K: 'a> {\n /// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`into_iter`]: struct.HashSet.html#method.into_iter\n+/// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n     iter: map::IntoIter<K, ()>,\n@@ -1177,8 +1153,7 @@ pub struct IntoIter<K> {\n /// This `struct` is created by the [`drain`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`drain`]: struct.HashSet.html#method.drain\n+/// [`drain`]: HashSet::drain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n     iter: map::Drain<'a, K, ()>,\n@@ -1189,8 +1164,7 @@ pub struct Drain<'a, K: 'a> {\n /// This `struct` is created by the [`intersection`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`intersection`]: struct.HashSet.html#method.intersection\n+/// [`intersection`]: HashSet::intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n@@ -1204,8 +1178,7 @@ pub struct Intersection<'a, T: 'a, S: 'a> {\n /// This `struct` is created by the [`difference`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`difference`]: struct.HashSet.html#method.difference\n+/// [`difference`]: HashSet::difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n@@ -1219,8 +1192,7 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n /// This `struct` is created by the [`symmetric_difference`] method on\n /// [`HashSet`]. See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`symmetric_difference`]: struct.HashSet.html#method.symmetric_difference\n+/// [`symmetric_difference`]: HashSet::symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n     iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n@@ -1231,8 +1203,7 @@ pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n /// This `struct` is created by the [`union`] method on [`HashSet`].\n /// See its documentation for more.\n ///\n-/// [`HashSet`]: struct.HashSet.html\n-/// [`union`]: struct.HashSet.html#method.union\n+/// [`union`]: HashSet::union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,"}, {"sha": "823ce30febed425ac794e6e1440a203b43029edb", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 51, "deletions": 90, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -238,25 +238,14 @@\n //! contract. The implementation of many of these functions are subject to change over\n //! time and may call fewer or more syscalls/library functions.\n //!\n-//! [`Read`]: trait.Read.html\n-//! [`Write`]: trait.Write.html\n-//! [`Seek`]: trait.Seek.html\n-//! [`BufRead`]: trait.BufRead.html\n-//! [`File`]: ../fs/struct.File.html\n-//! [`TcpStream`]: ../net/struct.TcpStream.html\n-//! [`Vec<T>`]: ../vec/struct.Vec.html\n-//! [`BufReader`]: struct.BufReader.html\n-//! [`BufWriter`]: struct.BufWriter.html\n-//! [`Write::write`]: trait.Write.html#tymethod.write\n-//! [`io::stdout`]: fn.stdout.html\n-//! [`println!`]: ../macro.println.html\n-//! [`Lines`]: struct.Lines.html\n-//! [`io::Result`]: type.Result.html\n+//! [`File`]: crate::fs::File\n+//! [`TcpStream`]: crate::net::TcpStream\n+//! [`Vec<T>`]: crate::vec::Vec\n+//! [`io::stdout`]: stdout\n+//! [`io::Result`]: crate::io::Result\n //! [`?` operator]: ../../book/appendix-02-operators.html\n-//! [`Read::read`]: trait.Read.html#tymethod.read\n-//! [`Result`]: ../result/enum.Result.html\n-//! [`.unwrap()`]: ../result/enum.Result.html#method.unwrap\n-// ignore-tidy-filelength\n+//! [`Result`]: crate::result::Result\n+//! [`.unwrap()`]: crate::result::Result::unwrap\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -491,12 +480,10 @@ where\n /// }\n /// ```\n ///\n-/// [`read()`]: trait.Read.html#tymethod.read\n-/// [`std::io`]: ../../std/io/index.html\n-/// [`File`]: ../fs/struct.File.html\n-/// [`BufRead`]: trait.BufRead.html\n-/// [`BufReader`]: struct.BufReader.html\n-/// [`&str`]: ../../std/primitive.str.html\n+/// [`read()`]: Read::read\n+/// [`&str`]: str\n+/// [`std::io`]: self\n+/// [`File`]: crate::fs::File\n /// [slice]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n@@ -535,7 +522,7 @@ pub trait Read {\n     /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n     /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n     ///\n-    /// [`MaybeUninit<T>`]: ../mem/union.MaybeUninit.html\n+    /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n     ///\n     /// # Errors\n     ///\n@@ -550,10 +537,8 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok(n)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`File`]: ../fs/struct.File.html\n+    /// [`Ok(n)`]: Ok\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -620,9 +605,6 @@ pub trait Read {\n     /// This method is unsafe because a `Read`er could otherwise return a\n     /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n     /// block.\n-    ///\n-    /// [`Initializer::nop()`]: ../../std/io/struct.Initializer.html#method.nop\n-    /// [`Initializer`]: ../../std/io/struct.Initializer.html\n     #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n@@ -652,10 +634,9 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`read()`]: trait.Read.html#tymethod.read\n-    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`File`]: ../fs/struct.File.html\n+    /// [`read()`]: Read::read\n+    /// [`Ok(0)`]: Ok\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -675,7 +656,7 @@ pub trait Read {\n     /// (See also the [`std::fs::read`] convenience function for reading from a\n     /// file.)\n     ///\n-    /// [`std::fs::read`]: ../fs/fn.read.html\n+    /// [`std::fs::read`]: crate::fs::read\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n@@ -693,13 +674,13 @@ pub trait Read {\n     ///\n     /// See [`read_to_end`][readtoend] for other error semantics.\n     ///\n-    /// [readtoend]: #method.read_to_end\n+    /// [readtoend]: Self::read_to_end\n     ///\n     /// # Examples\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -718,7 +699,7 @@ pub trait Read {\n     /// (See also the [`std::fs::read_to_string`] convenience function for\n     /// reading from a file.)\n     ///\n-    /// [`std::fs::read_to_string`]: ../fs/fn.read_to_string.html\n+    /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n@@ -764,9 +745,7 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: ../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -811,7 +790,7 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -855,14 +834,10 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n-    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n-    /// [`Result`]: ../../std/result/enum.Result.html\n-    /// [`io::Error`]: ../../std/io/struct.Error.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [file]: crate::fs::File\n+    /// [`Iterator`]: crate::iter::Iterator\n+    /// [`Result`]: crate::result::Result\n+    /// [`io::Error`]: self::Error\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -896,7 +871,7 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -935,9 +910,9 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`read()`]: trait.Read.html#tymethod.read\n+    /// [`File`]: crate::fs::File\n+    /// [`Ok(0)`]: Ok\n+    /// [`read()`]: Read::read\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -1233,8 +1208,8 @@ impl Initializer {\n /// throughout [`std::io`] take and provide types which implement the `Write`\n /// trait.\n ///\n-/// [`write`]: #tymethod.write\n-/// [`flush`]: #tymethod.flush\n+/// [`write`]: Self::write\n+/// [`flush`]: Self::flush\n /// [`std::io`]: index.html\n ///\n /// # Examples\n@@ -1260,7 +1235,7 @@ impl Initializer {\n /// The trait also provides convenience methods like [`write_all`], which calls\n /// `write` in a loop until its entire input has been written.\n ///\n-/// [`write_all`]: #method.write_all\n+/// [`write_all`]: Self::write_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n pub trait Write {\n@@ -1292,10 +1267,6 @@ pub trait Write {\n     /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n     /// write operation should be retried if there is nothing else to do.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok(n)`]:  ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -1381,8 +1352,7 @@ pub trait Write {\n     /// This function will return the first error of\n     /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n     ///\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`write`]: #tymethod.write\n+    /// [`write`]: Self::write\n     ///\n     /// # Examples\n     ///\n@@ -1423,8 +1393,7 @@ pub trait Write {\n     ///\n     /// If the buffer contains no data, this will never call [`write_vectored`].\n     ///\n-    /// [`write_vectored`]: #method.write_vectored\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_vectored`]: Self::write_vectored\n     ///\n     /// # Notes\n     ///\n@@ -1480,19 +1449,16 @@ pub trait Write {\n     /// encountered.\n     ///\n     /// This method is primarily used to interface with the\n-    /// [`format_args!`][formatargs] macro, but it is rare that this should\n-    /// explicitly be called. The [`write!`][write] macro should be favored to\n+    /// [`format_args!()`] macro, but it is rare that this should\n+    /// explicitly be called. The [`write!()`] macro should be favored to\n     /// invoke this method instead.\n     ///\n-    /// [formatargs]: ../macro.format_args.html\n-    /// [write]: ../macro.write.html\n-    ///\n     /// This function internally uses the [`write_all`][writeall] method on\n     /// this trait and hence will continuously write data so long as no errors\n     /// are received. This also means that partial writes are not indicated in\n     /// this signature.\n     ///\n-    /// [writeall]: #method.write_all\n+    /// [writeall]: Self::write_all\n     ///\n     /// # Errors\n     ///\n@@ -1589,7 +1555,7 @@ pub trait Write {\n ///\n /// [`File`][file]s implement `Seek`:\n ///\n-/// [file]: ../fs/struct.File.html\n+/// [file]: crate::fs::File\n ///\n /// ```no_run\n /// use std::io;\n@@ -1789,9 +1755,9 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n /// [`BufReader`] to the rescue!\n ///\n /// [`BufReader`]: struct.BufReader.html\n-/// [`File`]: ../fs/struct.File.html\n-/// [`read_line`]: #method.read_line\n-/// [`lines`]: #method.lines\n+/// [`File`]: crate::fs::File\n+/// [`read_line`]: Self::read_line\n+/// [`lines`]: Self::lines\n /// [`Read`]: trait.Read.html\n ///\n /// ```no_run\n@@ -1823,7 +1789,7 @@ pub trait BufRead: Read {\n     /// be called with the number of bytes that are consumed from this buffer to\n     /// ensure that the bytes are never returned twice.\n     ///\n-    /// [`consume`]: #tymethod.consume\n+    /// [`consume`]: Self::consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n@@ -1873,7 +1839,7 @@ pub trait BufRead: Read {\n     /// Since `consume()` is meant to be used with [`fill_buf`],\n     /// that method's example includes an example of `consume()`.\n     ///\n-    /// [`fill_buf`]: #tymethod.fill_buf\n+    /// [`fill_buf`]: Self::fill_buf\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n@@ -1897,7 +1863,7 @@ pub trait BufRead: Read {\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n-    /// [`fill_buf`]: #tymethod.fill_buf\n+    /// [`fill_buf`]: Self::fill_buf\n     /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n     ///\n     /// # Examples\n@@ -1962,7 +1928,7 @@ pub trait BufRead: Read {\n     /// error is encountered then `buf` may contain some bytes already read in\n     /// the event that all data read so far was valid UTF-8.\n     ///\n-    /// [`read_until`]: #method.read_until\n+    /// [`read_until`]: Self::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2015,9 +1981,9 @@ pub trait BufRead: Read {\n     /// This function will yield errors whenever [`read_until`] would have\n     /// also yielded an error.\n     ///\n-    /// [`io::Result`]: type.Result.html\n-    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n-    /// [`read_until`]: #method.read_until\n+    /// [`io::Result`]: self::Result\n+    /// [`Vec<u8>`]: crate::vec::Vec\n+    /// [`read_until`]: Self::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2052,17 +2018,14 @@ pub trait BufRead: Read {\n     /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n     /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n     ///\n-    /// [`io::Result`]: type.Result.html\n-    /// [`String`]: ../string/struct.String.html\n+    /// [`io::Result`]: self::Result\n     ///\n     /// # Examples\n     ///\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n     /// slice.\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -2253,8 +2216,6 @@ impl<T> Take<T> {\n     /// This instance may reach `EOF` after reading fewer bytes than indicated by\n     /// this method if the underlying [`Read`] instance reaches EOF.\n     ///\n-    /// [`Read`]: ../../std/io/trait.Read.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "0f349dfa3021611fdb3513aa9b87b2fd9f912bd1", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -84,12 +84,12 @@ impl Command {\n                 Ok(0) => return Ok((p, ours)),\n                 Ok(8) => {\n                     let (errno, footer) = bytes.split_at(4);\n-                    assert!(\n-                        combine(CLOEXEC_MSG_FOOTER) == combine(footer.try_into().unwrap()),\n+                    assert_eq!(\n+                        CLOEXEC_MSG_FOOTER, footer,\n                         \"Validation on the CLOEXEC pipe failed: {:?}\",\n                         bytes\n                     );\n-                    let errno = combine(errno.try_into().unwrap());\n+                    let errno = i32::from_be_bytes(errno.try_into().unwrap());\n                     assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                     return Err(Error::from_raw_os_error(errno));\n                 }\n@@ -105,10 +105,6 @@ impl Command {\n                 }\n             }\n         }\n-\n-        fn combine(arr: [u8; 4]) -> i32 {\n-            i32::from_be_bytes(arr)\n-        }\n     }\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {"}, {"sha": "194318d7a59b5ec5c9ed56fd8df5f6ae4310084a", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f94516345a36ddfcd68cbdf1df835d356795c3/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d7f94516345a36ddfcd68cbdf1df835d356795c3", "patch": "@@ -23,6 +23,32 @@ use std::rc::Rc;\n \n use crate::Redirect::*;\n \n+// Add linkcheck exceptions here\n+// If at all possible you should use intra-doc links to avoid linkcheck issues. These\n+// are cases where that does not work\n+// [(generated_documentation_page, &[broken_links])]\n+const LINKCHECK_EXCEPTIONS: &[(&str, &[&str])] = &[\n+    // These are methods on slice, and `Self` does not work on primitive impls\n+    // in intra-doc links (primitive impls are weird)\n+    // https://github.com/rust-lang/rust/issues/62834 is necessary to be\n+    // able to link to slices\n+    (\n+        \"std/io/struct.IoSlice.html\",\n+        &[\n+            \"#method.as_mut_ptr\",\n+            \"#method.sort_by_key\",\n+            \"#method.make_ascii_uppercase\",\n+            \"#method.make_ascii_lowercase\",\n+        ],\n+    ),\n+    // These try to link to std::collections, but are defined in alloc\n+    // https://github.com/rust-lang/rust/issues/74481\n+    (\"std/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),\n+    (\"std/collections/btree_set/struct.BTreeSet.html\", &[\"#insert-and-complex-keys\"]),\n+    (\"alloc/collections/btree_map/struct.BTreeMap.html\", &[\"#insert-and-complex-keys\"]),\n+    (\"alloc/collections/btree_set/struct.BTreeSet.html\", &[\"#insert-and-complex-keys\"]),\n+];\n+\n macro_rules! t {\n     ($e:expr) => {\n         match $e {\n@@ -111,35 +137,20 @@ fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n     }\n }\n \n+fn is_exception(file: &Path, link: &str) -> bool {\n+    if let Some(entry) = LINKCHECK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n+        entry.1.contains(&link)\n+    } else {\n+        false\n+    }\n+}\n+\n fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Option<PathBuf> {\n     // Ignore non-HTML files.\n     if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n         return None;\n     }\n \n-    // Unfortunately we're not 100% full of valid links today to we need a few\n-    // exceptions to get this past `make check` today.\n-    // FIXME(#32129)\n-    if file.ends_with(\"std/io/struct.IoSlice.html\")\n-        || file.ends_with(\"std/string/struct.String.html\")\n-    {\n-        return None;\n-    }\n-    // FIXME(#32553)\n-    if file.ends_with(\"alloc/string/struct.String.html\") {\n-        return None;\n-    }\n-    // FIXME(#32130)\n-    if file.ends_with(\"alloc/collections/btree_map/struct.BTreeMap.html\")\n-        || file.ends_with(\"alloc/collections/btree_set/struct.BTreeSet.html\")\n-        || file.ends_with(\"std/collections/btree_map/struct.BTreeMap.html\")\n-        || file.ends_with(\"std/collections/btree_set/struct.BTreeSet.html\")\n-        || file.ends_with(\"std/collections/hash_map/struct.HashMap.html\")\n-        || file.ends_with(\"std/collections/hash_set/struct.HashSet.html\")\n-    {\n-        return None;\n-    }\n-\n     let res = load_file(cache, root, file, SkipRedirect);\n     let (pretty_file, contents) = match res {\n         Ok(res) => res,\n@@ -254,17 +265,20 @@ fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Opti\n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n \n-                if !entry.ids.contains(*fragment) {\n+                if !entry.ids.contains(*fragment) && !is_exception(file, &format!(\"#{}\", fragment))\n+                {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment \", pretty_file.display(), i + 1);\n                     println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n                 };\n             }\n         } else {\n-            *errors = true;\n-            print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n             let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-            println!(\"{}\", pretty_path.display());\n+            if !is_exception(file, pretty_path.to_str().unwrap()) {\n+                *errors = true;\n+                print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n+                println!(\"{}\", pretty_path.display());\n+            }\n         }\n     });\n     Some(pretty_file)"}]}