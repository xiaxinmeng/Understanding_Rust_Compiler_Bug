{"sha": "832b7075b6c2e4ed37978d00a7c629e468f3dab1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMmI3MDc1YjZjMmU0ZWQzNzk3OGQwMGE3YzYyOWU0NjhmM2RhYjE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-04-05T20:19:29Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-04-05T20:25:09Z"}, "message": "clean the note-reporting code in report_selection_error", "tree": {"sha": "a7eb25fc6ff4c9af5cf95f30f6de275a96bd4e8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7eb25fc6ff4c9af5cf95f30f6de275a96bd4e8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/832b7075b6c2e4ed37978d00a7c629e468f3dab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/832b7075b6c2e4ed37978d00a7c629e468f3dab1", "html_url": "https://github.com/rust-lang/rust/commit/832b7075b6c2e4ed37978d00a7c629e468f3dab1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/832b7075b6c2e4ed37978d00a7c629e468f3dab1/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b23648fe4aa46e9a2bf72c6f68590e799c4cdb07", "url": "https://api.github.com/repos/rust-lang/rust/commits/b23648fe4aa46e9a2bf72c6f68590e799c4cdb07", "html_url": "https://github.com/rust-lang/rust/commit/b23648fe4aa46e9a2bf72c6f68590e799c4cdb07"}], "stats": {"total": 101, "additions": 62, "deletions": 39}, "files": [{"sha": "5b5bea012ead0246fa96e9f8d6926b7a8b82f920", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/832b7075b6c2e4ed37978d00a7c629e468f3dab1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832b7075b6c2e4ed37978d00a7c629e468f3dab1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=832b7075b6c2e4ed37978d00a7c629e468f3dab1", "patch": "@@ -174,6 +174,53 @@ fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     report\n }\n \n+fn find_similar_impl_candidates<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>)\n+    -> Vec<ty::TraitRef<'tcx>>\n+{\n+    let simp = fast_reject::simplify_type(infcx.tcx,\n+                                          trait_ref.skip_binder().self_ty(),\n+                                          true);\n+    let mut impl_candidates = Vec::new();\n+    let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id());\n+\n+    match simp {\n+        Some(simp) => trait_def.for_each_impl(infcx.tcx, |def_id| {\n+            let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n+            let imp_simp = fast_reject::simplify_type(infcx.tcx,\n+                                                      imp.self_ty(),\n+                                                      true);\n+            if let Some(imp_simp) = imp_simp {\n+                if simp != imp_simp {\n+                    return;\n+                }\n+            }\n+            impl_candidates.push(imp);\n+        }),\n+        None => trait_def.for_each_impl(infcx.tcx, |def_id| {\n+            impl_candidates.push(\n+                infcx.tcx.impl_trait_ref(def_id).unwrap());\n+        })\n+    };\n+    impl_candidates\n+}\n+\n+fn report_similar_impl_candidates(span: Span,\n+                                  err: &mut DiagnosticBuilder,\n+                                  impl_candidates: &[ty::TraitRef])\n+{\n+    err.fileline_help(span, &format!(\"the following implementations were found:\"));\n+\n+    let end = cmp::min(4, impl_candidates.len());\n+    for candidate in &impl_candidates[0..end] {\n+        err.fileline_help(span, &format!(\"  {:?}\", candidate));\n+    }\n+    if impl_candidates.len() > 4 {\n+        err.fileline_help(span, &format!(\"and {} others\", impl_candidates.len()-4));\n+    }\n+}\n+\n /// Reports that an overflow has occurred and halts compilation. We\n /// halt compilation unconditionally because it is important that\n /// overflows never be masked -- they basically represent computations\n@@ -364,59 +411,35 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 \"the trait bound `{}` is not satisfied\",\n                                 trait_ref.to_predicate());\n \n-                            // Try to report a good error message.\n+                            // Try to report a help message\n \n                             if !trait_ref.has_infer_types() &&\n                                 predicate_can_apply(infcx, trait_ref)\n                             {\n+                                // If a where-clause may be useful, remind the\n+                                // user that they can add it.\n+                                //\n+                                // don't display an on-unimplemented note, as\n+                                // these notes will often be of the form\n+                                //     \"the type `T` can't be frobnicated\"\n+                                // which is somewhat confusing.\n                                 err.fileline_help(obligation.cause.span, &format!(\n                                     \"consider adding a `where {}` bound\",\n                                     trait_ref.to_predicate()\n                                     ));\n                             } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n                                                                           obligation.cause.span) {\n+                                // Otherwise, if there is an on-unimplemented note,\n+                                // display it.\n                                 err.fileline_note(obligation.cause.span, &s);\n                             } else {\n-                                let simp = fast_reject::simplify_type(infcx.tcx,\n-                                                                      trait_ref.self_ty(),\n-                                                                      true);\n-                                let mut impl_candidates = Vec::new();\n-                                let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id());\n-\n-                                match simp {\n-                                    Some(simp) => trait_def.for_each_impl(infcx.tcx, |def_id| {\n-                                        let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n-                                        let imp_simp = fast_reject::simplify_type(infcx.tcx,\n-                                                                                  imp.self_ty(),\n-                                                                                  true);\n-                                        if let Some(imp_simp) = imp_simp {\n-                                            if simp != imp_simp {\n-                                                return;\n-                                            }\n-                                        }\n-                                        impl_candidates.push(imp);\n-                                    }),\n-                                    None => trait_def.for_each_impl(infcx.tcx, |def_id| {\n-                                        impl_candidates.push(\n-                                            infcx.tcx.impl_trait_ref(def_id).unwrap());\n-                                    })\n-                                };\n+                                // If we can't show anything useful, try to find\n+                                // similar impls.\n \n+                                let impl_candidates = find_similar_impl_candidates(infcx, trait_ref);\n                                 if impl_candidates.len() > 0 {\n-                                    err.fileline_help(\n-                                        obligation.cause.span,\n-                                        &format!(\"the following implementations were found:\"));\n-\n-                                    let end = cmp::min(4, impl_candidates.len());\n-                                    for candidate in &impl_candidates[0..end] {\n-                                        err.fileline_help(obligation.cause.span,\n-                                                          &format!(\"  {:?}\", candidate));\n-                                    }\n-                                    if impl_candidates.len() > 4 {\n-                                        err.fileline_help(obligation.cause.span,\n-                                                          &format!(\"and {} others\",\n-                                                                   impl_candidates.len()-4));\n-                                    }\n+                                    report_similar_impl_candidates(obligation.cause.span,\n+                                                                   &mut err, &impl_candidates);\n                                 }\n                             }\n                             note_obligation_cause(infcx, &mut err, obligation);"}]}