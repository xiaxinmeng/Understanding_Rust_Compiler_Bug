{"sha": "96e3fb255bfcae8ce7210985bf75e77335d22580", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZTNmYjI1NWJmY2FlOGNlNzIxMDk4NWJmNzVlNzczMzVkMjI1ODA=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-05-25T19:45:51Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-05-28T06:34:44Z"}, "message": "librustc_errors: Move annotation collection to own impl\n\nExtracted from work on #59346. This moves the annotation collection to\nthe `FileWithAnnotatedLines` impl to allow re-use in a separate\nEmitterWriter.", "tree": {"sha": "7dd07b4845371a962f14d8745f85dee26728e0b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dd07b4845371a962f14d8745f85dee26728e0b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96e3fb255bfcae8ce7210985bf75e77335d22580", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJEBAABCgAuFiEEj4U0bmbiMSg/mWqvgqphyqETl+YFAlzs1ocQHGRldkBwaGFu\nc2NoLm5ldAAKCRCCqmHKoROX5v2KEADOe/y212qHBR4zoTMGZqQn9LVmXD+wg4ed\nEdvpNbTA6VtxBJXHfkzt8JhhZyl5k+9bIWqs/XP29uA87gxKiSVck/1cmY8GMoiY\nWKv3R8HNok5ewp8KjLYL3kBf9xZPzTCpH4HMiilpVse/4t373/QWAxhdgGkMflPT\ncOSI6ZKY7ALnwZrHh6bDybTFB9MgT54+1uSOOe3g5FP1n5w9kLmpzZf6vx73UNEu\nwHWNhbS5xqiUVBb2mYLxJRm1GaGb0R0PxEQd1b5iNijEqwla9P3mxdTwuOmPhFKV\nmpiW0TYQZMPWM7Ntld1flV6+NaRoKFyTm/Ov5KW9407USioRN13gPkyE7eTQOq8a\nDA86EwOgzDJBzk1rb004JThTXqCYIjRlXIICEGcSXVo/DxyMm3ETiE34OmgS0ML7\njniaL54KfTmzfeIlVgOV4UrKuFV0RpFAhRIHOM3pf1lYtjQOMsVqZ5c6FY2S/iT3\nDgSD65mRDyAmxrRTx9hr6/GT+qB6KZXYdVw5VVqFTux8vDaAUc3E+A3s2ZgUcsVo\ns3m2FEiywv5cfDz0CbQOSD7HWhhPafYREEEFfdX583YAZNqzYGnyq83/EvKLjo11\nwTLGO3VV4neykzKN4o+yvW3Be73/uw/hIewrqvUiMt+ov4hcdhFl++fvt9OS6xAR\nwLW5BIIQIQ==\n=Sm9P\n-----END PGP SIGNATURE-----", "payload": "tree 7dd07b4845371a962f14d8745f85dee26728e0b6\nparent f492693982d1e252f5411ae3e4d560ab0dfea48a\nauthor Philipp Hansch <dev@phansch.net> 1558813551 +0200\ncommitter Philipp Hansch <dev@phansch.net> 1559025284 +0200\n\nlibrustc_errors: Move annotation collection to own impl\n\nExtracted from work on #59346. This moves the annotation collection to\nthe `FileWithAnnotatedLines` impl to allow re-use in a separate\nEmitterWriter.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96e3fb255bfcae8ce7210985bf75e77335d22580", "html_url": "https://github.com/rust-lang/rust/commit/96e3fb255bfcae8ce7210985bf75e77335d22580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96e3fb255bfcae8ce7210985bf75e77335d22580/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f492693982d1e252f5411ae3e4d560ab0dfea48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f492693982d1e252f5411ae3e4d560ab0dfea48a", "html_url": "https://github.com/rust-lang/rust/commit/f492693982d1e252f5411ae3e4d560ab0dfea48a"}], "stats": {"total": 341, "additions": 174, "deletions": 167}, "files": [{"sha": "e1112a1557771c7e4b7f6fa4c34ba452801ec52f", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 174, "deletions": 167, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/96e3fb255bfcae8ce7210985bf75e77335d22580/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e3fb255bfcae8ce7210985bf75e77335d22580/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=96e3fb255bfcae8ce7210985bf75e77335d22580", "patch": "@@ -162,6 +162,7 @@ impl ColorConfig {\n     }\n }\n \n+/// Handles the writing of `HumanReadableErrorType::Default` and `HumanReadableErrorType::Short`\n pub struct EmitterWriter {\n     dst: Destination,\n     sm: Option<Lrc<SourceMapperDyn>>,\n@@ -170,7 +171,8 @@ pub struct EmitterWriter {\n     ui_testing: bool,\n }\n \n-struct FileWithAnnotatedLines {\n+#[derive(Debug)]\n+pub struct FileWithAnnotatedLines {\n     file: Lrc<SourceFile>,\n     lines: Vec<Line>,\n     multiline_depth: usize,\n@@ -221,169 +223,6 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n-        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Lrc<SourceFile>,\n-                                  line_index: usize,\n-                                  ann: Annotation) {\n-\n-            for slot in file_vec.iter_mut() {\n-                // Look through each of our files for the one we're adding to\n-                if slot.file.name == file.name {\n-                    // See if we already have a line for it\n-                    for line_slot in &mut slot.lines {\n-                        if line_slot.line_index == line_index {\n-                            line_slot.annotations.push(ann);\n-                            return;\n-                        }\n-                    }\n-                    // We don't have a line yet, create one\n-                    slot.lines.push(Line {\n-                        line_index,\n-                        annotations: vec![ann],\n-                    });\n-                    slot.lines.sort();\n-                    return;\n-                }\n-            }\n-            // This is the first time we're seeing the file\n-            file_vec.push(FileWithAnnotatedLines {\n-                file,\n-                lines: vec![Line {\n-                                line_index,\n-                                annotations: vec![ann],\n-                            }],\n-                multiline_depth: 0,\n-            });\n-        }\n-\n-        let mut output = vec![];\n-        let mut multiline_annotations = vec![];\n-\n-        if let Some(ref sm) = self.sm {\n-            for span_label in msp.span_labels() {\n-                if span_label.span.is_dummy() {\n-                    continue;\n-                }\n-\n-                let lo = sm.lookup_char_pos(span_label.span.lo());\n-                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n-\n-                // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                // want to just display a `^` at 6, so convert that to\n-                // 6..7. This is degenerate input, but it's best to degrade\n-                // gracefully -- and the parser likes to supply a span like\n-                // that for EOF, in particular.\n-\n-                if lo.col_display == hi.col_display && lo.line == hi.line {\n-                    hi.col_display += 1;\n-                }\n-\n-                let ann_type = if lo.line != hi.line {\n-                    let ml = MultilineAnnotation {\n-                        depth: 1,\n-                        line_start: lo.line,\n-                        line_end: hi.line,\n-                        start_col: lo.col_display,\n-                        end_col: hi.col_display,\n-                        is_primary: span_label.is_primary,\n-                        label: span_label.label.clone(),\n-                        overlaps_exactly: false,\n-                    };\n-                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n-                    AnnotationType::Multiline(ml)\n-                } else {\n-                    AnnotationType::Singleline\n-                };\n-                let ann = Annotation {\n-                    start_col: lo.col_display,\n-                    end_col: hi.col_display,\n-                    is_primary: span_label.is_primary,\n-                    label: span_label.label.clone(),\n-                    annotation_type: ann_type,\n-                };\n-\n-                if !ann.is_multiline() {\n-                    add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n-                }\n-            }\n-        }\n-\n-        // Find overlapping multiline annotations, put them at different depths\n-        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n-        for item in multiline_annotations.clone() {\n-            let ann = item.1;\n-            for item in multiline_annotations.iter_mut() {\n-                let ref mut a = item.1;\n-                // Move all other multiline annotations overlapping with this one\n-                // one level to the right.\n-                if !(ann.same_span(a)) &&\n-                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n-                {\n-                    a.increase_depth();\n-                } else if ann.same_span(a) && &ann != a {\n-                    a.overlaps_exactly = true;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        let mut max_depth = 0;  // max overlapping multiline spans\n-        for (file, ann) in multiline_annotations {\n-            if ann.depth > max_depth {\n-                max_depth = ann.depth;\n-            }\n-            let mut end_ann = ann.as_end();\n-            if !ann.overlaps_exactly {\n-                // avoid output like\n-                //\n-                //  |        foo(\n-                //  |   _____^\n-                //  |  |_____|\n-                //  | ||         bar,\n-                //  | ||     );\n-                //  | ||      ^\n-                //  | ||______|\n-                //  |  |______foo\n-                //  |         baz\n-                //\n-                // and instead get\n-                //\n-                //  |       foo(\n-                //  |  _____^\n-                //  | |         bar,\n-                //  | |     );\n-                //  | |      ^\n-                //  | |      |\n-                //  | |______foo\n-                //  |        baz\n-                add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n-                // 4 is the minimum vertical length of a multiline span when presented: two lines\n-                // of code and two lines of underline. This is not true for the special case where\n-                // the beginning doesn't have an underline, but the current logic seems to be\n-                // working correctly.\n-                let middle = min(ann.line_start + 4, ann.line_end);\n-                for line in ann.line_start + 1..middle {\n-                    // Every `|` that joins the beginning of the span (`___^`) to the end (`|__^`).\n-                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                }\n-                if middle < ann.line_end - 1 {\n-                    for line in ann.line_end - 1..ann.line_end {\n-                        add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                    }\n-                }\n-            } else {\n-                end_ann.annotation_type = AnnotationType::Singleline;\n-            }\n-            add_annotation_to_file(&mut output, file, ann.line_end, end_ann);\n-        }\n-        for file_vec in output.iter_mut() {\n-            file_vec.multiline_depth = max_depth;\n-        }\n-        output\n-    }\n-\n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n                           file: Lrc<SourceFile>,\n@@ -1093,9 +932,7 @@ impl EmitterWriter {\n             }\n         }\n \n-        // Preprocess all the annotations so that they are grouped by file and by line number\n-        // This helps us quickly iterate over the whole message (including secondary file spans)\n-        let mut annotated_files = self.preprocess_annotations(msp);\n+        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(msp, &self.sm);\n \n         // Make sure our primary file comes first\n         let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n@@ -1503,6 +1340,176 @@ impl EmitterWriter {\n     }\n }\n \n+impl FileWithAnnotatedLines {\n+    /// Preprocess all the annotations so that they are grouped by file and by line number\n+    /// This helps us quickly iterate over the whole message (including secondary file spans)\n+    pub fn collect_annotations(\n+        msp: &MultiSpan,\n+        source_map: &Option<Lrc<SourceMapperDyn>>\n+    ) -> Vec<FileWithAnnotatedLines> {\n+        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n+                                  file: Lrc<SourceFile>,\n+                                  line_index: usize,\n+                                  ann: Annotation) {\n+\n+            for slot in file_vec.iter_mut() {\n+                // Look through each of our files for the one we're adding to\n+                if slot.file.name == file.name {\n+                    // See if we already have a line for it\n+                    for line_slot in &mut slot.lines {\n+                        if line_slot.line_index == line_index {\n+                            line_slot.annotations.push(ann);\n+                            return;\n+                        }\n+                    }\n+                    // We don't have a line yet, create one\n+                    slot.lines.push(Line {\n+                        line_index,\n+                        annotations: vec![ann],\n+                    });\n+                    slot.lines.sort();\n+                    return;\n+                }\n+            }\n+            // This is the first time we're seeing the file\n+            file_vec.push(FileWithAnnotatedLines {\n+                file,\n+                lines: vec![Line {\n+                                line_index,\n+                                annotations: vec![ann],\n+                            }],\n+                multiline_depth: 0,\n+            });\n+        }\n+\n+        let mut output = vec![];\n+        let mut multiline_annotations = vec![];\n+\n+        if let Some(ref sm) = source_map {\n+            for span_label in msp.span_labels() {\n+                if span_label.span.is_dummy() {\n+                    continue;\n+                }\n+\n+                let lo = sm.lookup_char_pos(span_label.span.lo());\n+                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n+\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+\n+                if lo.col_display == hi.col_display && lo.line == hi.line {\n+                    hi.col_display += 1;\n+                }\n+\n+                let ann_type = if lo.line != hi.line {\n+                    let ml = MultilineAnnotation {\n+                        depth: 1,\n+                        line_start: lo.line,\n+                        line_end: hi.line,\n+                        start_col: lo.col_display,\n+                        end_col: hi.col_display,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label.clone(),\n+                        overlaps_exactly: false,\n+                    };\n+                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n+                    AnnotationType::Multiline(ml)\n+                } else {\n+                    AnnotationType::Singleline\n+                };\n+                let ann = Annotation {\n+                    start_col: lo.col_display,\n+                    end_col: hi.col_display,\n+                    is_primary: span_label.is_primary,\n+                    label: span_label.label.clone(),\n+                    annotation_type: ann_type,\n+                };\n+\n+                if !ann.is_multiline() {\n+                    add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n+                }\n+            }\n+        }\n+\n+        // Find overlapping multiline annotations, put them at different depths\n+        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n+        for item in multiline_annotations.clone() {\n+            let ann = item.1;\n+            for item in multiline_annotations.iter_mut() {\n+                let ref mut a = item.1;\n+                // Move all other multiline annotations overlapping with this one\n+                // one level to the right.\n+                if !(ann.same_span(a)) &&\n+                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n+                {\n+                    a.increase_depth();\n+                } else if ann.same_span(a) && &ann != a {\n+                    a.overlaps_exactly = true;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let mut max_depth = 0;  // max overlapping multiline spans\n+        for (file, ann) in multiline_annotations {\n+            if ann.depth > max_depth {\n+                max_depth = ann.depth;\n+            }\n+            let mut end_ann = ann.as_end();\n+            if !ann.overlaps_exactly {\n+                // avoid output like\n+                //\n+                //  |        foo(\n+                //  |   _____^\n+                //  |  |_____|\n+                //  | ||         bar,\n+                //  | ||     );\n+                //  | ||      ^\n+                //  | ||______|\n+                //  |  |______foo\n+                //  |         baz\n+                //\n+                // and instead get\n+                //\n+                //  |       foo(\n+                //  |  _____^\n+                //  | |         bar,\n+                //  | |     );\n+                //  | |      ^\n+                //  | |      |\n+                //  | |______foo\n+                //  |        baz\n+                add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n+                // 4 is the minimum vertical length of a multiline span when presented: two lines\n+                // of code and two lines of underline. This is not true for the special case where\n+                // the beginning doesn't have an underline, but the current logic seems to be\n+                // working correctly.\n+                let middle = min(ann.line_start + 4, ann.line_end);\n+                for line in ann.line_start + 1..middle {\n+                    // Every `|` that joins the beginning of the span (`___^`) to the end (`|__^`).\n+                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                }\n+                if middle < ann.line_end - 1 {\n+                    for line in ann.line_end - 1..ann.line_end {\n+                        add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                    }\n+                }\n+            } else {\n+                end_ann.annotation_type = AnnotationType::Singleline;\n+            }\n+            add_annotation_to_file(&mut output, file, ann.line_end, end_ann);\n+        }\n+        for file_vec in output.iter_mut() {\n+            file_vec.multiline_depth = max_depth;\n+        }\n+        output\n+    }\n+}\n+\n fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"| \", Style::LineNumber);\n }"}]}