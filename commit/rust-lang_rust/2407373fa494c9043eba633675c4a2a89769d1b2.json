{"sha": "2407373fa494c9043eba633675c4a2a89769d1b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MDczNzNmYTQ5NGM5MDQzZWJhNjMzNjc1YzRhMmE4OTc2OWQxYjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-27T21:54:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-27T22:11:22Z"}, "message": "core: Make #fmt pure", "tree": {"sha": "60bfba52a784eafa4f1b09656ff0ef6796e2e058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60bfba52a784eafa4f1b09656ff0ef6796e2e058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2407373fa494c9043eba633675c4a2a89769d1b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2407373fa494c9043eba633675c4a2a89769d1b2", "html_url": "https://github.com/rust-lang/rust/commit/2407373fa494c9043eba633675c4a2a89769d1b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2407373fa494c9043eba633675c4a2a89769d1b2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e2471cb7bc7f84863bdb0d67cfa2af16d54f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e2471cb7bc7f84863bdb0d67cfa2af16d54f9e", "html_url": "https://github.com/rust-lang/rust/commit/01e2471cb7bc7f84863bdb0d67cfa2af16d54f9e"}], "stats": {"total": 57, "additions": 39, "deletions": 18}, "files": [{"sha": "21a1fd09c62296517279f0b9f1947d12efabacbc", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2407373fa494c9043eba633675c4a2a89769d1b2/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2407373fa494c9043eba633675c4a2a89769d1b2/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2407373fa494c9043eba633675c4a2a89769d1b2", "patch": "@@ -277,20 +277,20 @@ mod rt {\n \n     type conv = {flags: u32, width: count, precision: count, ty: ty};\n \n-    fn conv_int(cv: conv, i: int) -> ~str {\n+    pure fn conv_int(cv: conv, i: int) -> ~str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n-                str::unshift_char(s, '+');\n+                unchecked { str::unshift_char(s, '+') };\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                str::unshift_char(s, ' ');\n+                unchecked { str::unshift_char(s, ' ') };\n             }\n         }\n-        ret pad(cv, s, pad_signed);\n+        ret unchecked { pad(cv, s, pad_signed) };\n     }\n-    fn conv_uint(cv: conv, u: uint) -> ~str {\n+    pure fn conv_uint(cv: conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             alt cv.ty {\n@@ -300,17 +300,17 @@ mod rt {\n               ty_bits { uint_to_str_prec(u, 2u, prec) }\n               ty_octal { uint_to_str_prec(u, 8u, prec) }\n             };\n-        ret pad(cv, rs, pad_unsigned);\n+        ret unchecked { pad(cv, rs, pad_unsigned) };\n     }\n-    fn conv_bool(cv: conv, b: bool) -> ~str {\n+    pure fn conv_bool(cv: conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         ret conv_str(cv, s);\n     }\n-    fn conv_char(cv: conv, c: char) -> ~str {\n+    pure fn conv_char(cv: conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        ret pad(cv, s, pad_nozero);\n+        ret unchecked { pad(cv, s, pad_nozero) };\n     }\n     pure fn conv_str(cv: conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -325,29 +325,29 @@ mod rt {\n         };\n         ret unchecked { pad(cv, unpadded, pad_nozero) };\n     }\n-    fn conv_float(cv: conv, f: float) -> ~str {\n+    pure fn conv_float(cv: conv, f: float) -> ~str {\n         let (to_str, digits) = alt cv.precision {\n               count_is(c) { (float::to_str_exact, c as uint) }\n               count_implied { (float::to_str, 6u) }\n         };\n-        let mut s = to_str(f, digits);\n+        let mut s = unchecked { to_str(f, digits) };\n         if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 s = ~\"+\" + s;\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n                 s = ~\" \" + s;\n             }\n         }\n-        ret pad(cv, s, pad_float);\n+        ret unchecked { pad(cv, s, pad_float) };\n     }\n-    fn conv_poly<T>(cv: conv, v: T) -> ~str {\n+    pure fn conv_poly<T>(cv: conv, v: T) -> ~str {\n         let s = sys::log_str(v);\n         ret conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+    pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         ret if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n@@ -356,7 +356,7 @@ mod rt {\n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n+    pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n         ret if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n@@ -369,7 +369,7 @@ mod rt {\n                 } else { s }\n             };\n     }\n-    fn get_int_precision(cv: conv) -> uint {\n+    pure fn get_int_precision(cv: conv) -> uint {\n         ret alt cv.precision {\n               count_is(c) { c as uint }\n               count_implied { 1u }"}, {"sha": "3a420d103a3f386523ad070b0dee6513816de02f", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2407373fa494c9043eba633675c4a2a89769d1b2/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2407373fa494c9043eba633675c4a2a89769d1b2/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=2407373fa494c9043eba633675c4a2a89769d1b2", "patch": "@@ -159,7 +159,7 @@ fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n  *\n  * Fails if `radix` < 2 or `radix` > 16\n  */\n-fn to_str(num: T, radix: uint) -> ~str {\n+pure fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::as_buf(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n@@ -168,7 +168,7 @@ fn to_str(num: T, radix: uint) -> ~str {\n }\n \n /// Low-level helper routine for string conversion.\n-fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n+pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n                    f: fn(v: &[u8]) -> U) -> U {\n \n     #[inline(always)]"}, {"sha": "47af01d5b16a296ba1c8ce9ab918a8ed22896b2b", "filename": "src/test/run-pass/pure-fmt.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2407373fa494c9043eba633675c4a2a89769d1b2/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2407373fa494c9043eba633675c4a2a89769d1b2/src%2Ftest%2Frun-pass%2Fpure-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-fmt.rs?ref=2407373fa494c9043eba633675c4a2a89769d1b2", "patch": "@@ -0,0 +1,21 @@\n+// Testing that calling #fmt (via #debug) doesn't complain about impure borrows\n+\n+pure fn foo() {\n+    let a = {\n+        b: @\"hi\",\n+        c: 0,\n+        d: 1,\n+        e: 'a',\n+        f: 0.0,\n+        g: true\n+    };\n+    #debug(\"test %?\", a.b);\n+    #debug(\"test %u\", a.c);\n+    #debug(\"test %i\", a.d);\n+    #debug(\"test %c\", a.e);\n+    #debug(\"test %f\", a.f);\n+    #debug(\"test %b\", a.g);\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}]}