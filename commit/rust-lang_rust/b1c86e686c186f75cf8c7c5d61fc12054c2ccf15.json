{"sha": "b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzg2ZTY4NmMxODZmNzVjZjhjN2M1ZDYxZmMxMjA1NGMyY2NmMTU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-05T14:42:10Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-05T14:42:10Z"}, "message": "Merge #435\n\n435: Refactor hover r=matklad a=matklad\n\nPrimaraly this moves `hover` to `ra_analysis`, so that we finally can write tests for it!\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "232dc42dc6e42812f1b6bf4d33b2b9cf05465792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/232dc42dc6e42812f1b6bf4d33b2b9cf05465792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "html_url": "https://github.com/rust-lang/rust/commit/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8d51b02362109d71355aed63d48b5e7ccd0e51f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d51b02362109d71355aed63d48b5e7ccd0e51f4", "html_url": "https://github.com/rust-lang/rust/commit/8d51b02362109d71355aed63d48b5e7ccd0e51f4"}, {"sha": "bdbdade036fe71c4438f931f450beb711d1379ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbdade036fe71c4438f931f450beb711d1379ed", "html_url": "https://github.com/rust-lang/rust/commit/bdbdade036fe71c4438f931f450beb711d1379ed"}], "stats": {"total": 365, "additions": 204, "deletions": 161}, "files": [{"sha": "766fa05478f5ce06db3e9a056e0c0bb39c259af0", "filename": "crates/ra_analysis/src/hover.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "patch": "@@ -0,0 +1,176 @@\n+use ra_db::{Cancelable, SyntaxDatabase};\n+use ra_syntax::{\n+    AstNode, SyntaxNode,\n+    ast::{self, NameOwner},\n+    algo::{find_covering_node, visit::{visitor, Visitor}},\n+};\n+\n+use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n+\n+pub(crate) fn hover(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+) -> Cancelable<Option<RangeInfo<String>>> {\n+    let mut res = Vec::new();\n+    let range = if let Some(rr) = db.approximately_resolve_symbol(position)? {\n+        for nav in rr.resolves_to {\n+            res.extend(doc_text_for(db, nav)?)\n+        }\n+        rr.reference_range\n+    } else {\n+        let file = db.source_file(position.file_id);\n+        let expr: ast::Expr = ctry!(ra_editor::find_node_at_offset(\n+            file.syntax(),\n+            position.offset\n+        ));\n+        let frange = FileRange {\n+            file_id: position.file_id,\n+            range: expr.syntax().range(),\n+        };\n+        res.extend(type_of(db, frange)?);\n+        expr.syntax().range()\n+    };\n+    if res.is_empty() {\n+        return Ok(None);\n+    }\n+    let res = RangeInfo::new(range, res.join(\"\\n\\n---\\n\"));\n+    Ok(Some(res))\n+}\n+\n+pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option<String>> {\n+    let file = db.source_file(frange.file_id);\n+    let syntax = file.syntax();\n+    let node = find_covering_node(syntax, frange.range);\n+    let parent_fn = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n+    let function = ctry!(hir::source_binder::function_from_source(\n+        db,\n+        frange.file_id,\n+        parent_fn\n+    )?);\n+    let infer = function.infer(db)?;\n+    Ok(infer.type_of_node(node).map(|t| t.to_string()))\n+}\n+\n+// FIXME: this should not really use navigation target. Rather, approximatelly\n+// resovled symbol should return a `DefId`.\n+fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<String>> {\n+    let result = match (nav.description(db), nav.docs(db)) {\n+        (Some(desc), Some(docs)) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs),\n+        (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n+        (None, Some(docs)) => Some(docs),\n+        _ => None,\n+    };\n+\n+    Ok(result)\n+}\n+\n+impl NavigationTarget {\n+    fn node(&self, db: &RootDatabase) -> Option<SyntaxNode> {\n+        let source_file = db.source_file(self.file_id);\n+        let source_file = source_file.syntax();\n+        let node = source_file\n+            .descendants()\n+            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n+            .owned();\n+        Some(node)\n+    }\n+\n+    fn docs(&self, db: &RootDatabase) -> Option<String> {\n+        let node = self.node(db)?;\n+        let node = node.borrowed();\n+        fn doc_comments<'a, N: ast::DocCommentsOwner<'a>>(node: N) -> Option<String> {\n+            let comments = node.doc_comment_text();\n+            if comments.is_empty() {\n+                None\n+            } else {\n+                Some(comments)\n+            }\n+        }\n+\n+        visitor()\n+            .visit(doc_comments::<ast::FnDef>)\n+            .visit(doc_comments::<ast::StructDef>)\n+            .visit(doc_comments::<ast::EnumDef>)\n+            .visit(doc_comments::<ast::TraitDef>)\n+            .visit(doc_comments::<ast::Module>)\n+            .visit(doc_comments::<ast::TypeDef>)\n+            .visit(doc_comments::<ast::ConstDef>)\n+            .visit(doc_comments::<ast::StaticDef>)\n+            .accept(node)?\n+    }\n+\n+    /// Get a description of this node.\n+    ///\n+    /// e.g. `struct Name`, `enum Name`, `fn Name`\n+    fn description(&self, db: &RootDatabase) -> Option<String> {\n+        // TODO: After type inference is done, add type information to improve the output\n+        let node = self.node(db)?;\n+        let node = node.borrowed();\n+        // TODO: Refactor to be have less repetition\n+        visitor()\n+            .visit(|node: ast::FnDef| {\n+                let mut string = \"fn \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::StructDef| {\n+                let mut string = \"struct \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::EnumDef| {\n+                let mut string = \"enum \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::TraitDef| {\n+                let mut string = \"trait \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::Module| {\n+                let mut string = \"mod \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::TypeDef| {\n+                let mut string = \"type \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::ConstDef| {\n+                let mut string = \"const \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::StaticDef| {\n+                let mut string = \"static \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .accept(node)?\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::TextRange;\n+\n+    use crate::mock_analysis::single_file_with_position;\n+\n+    #[test]\n+    fn hover_shows_type_of_an_expression() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            pub fn foo() -> u32 { 1 }\n+\n+            fn main() {\n+                let foo_test = foo()<|>;\n+            }\n+        \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        assert_eq!(hover.range, TextRange::from_to(95.into(), 100.into()));\n+        assert_eq!(hover.info, \"u32\");\n+    }\n+}"}, {"sha": "e2871451c220ea0a824a40f6aff14916e795a99b", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 116, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "patch": "@@ -8,11 +8,10 @@ use hir::{\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use ra_editor::{self, find_node_at_offset, assists, LocalEdit, Severity};\n use ra_syntax::{\n-    algo::{find_covering_node, visit::{visitor, Visitor}},\n-    ast::{self, ArgListOwner, Expr, FnDef, NameOwner},\n+    ast::{self, ArgListOwner, Expr, NameOwner},\n     AstNode, SourceFileNode,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n use crate::{\n@@ -256,18 +255,6 @@ impl db::RootDatabase {\n             Ok(Some((binding, descr)))\n         }\n     }\n-    pub(crate) fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        let result = match (nav.description(self), nav.docs(self)) {\n-            (Some(desc), Some(docs)) => {\n-                Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs)\n-            }\n-            (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n-            (None, Some(docs)) => Some(docs),\n-            _ => None,\n-        };\n-\n-        Ok(result)\n-    }\n \n     pub(crate) fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n         let syntax = self.source_file(file_id);\n@@ -410,19 +397,6 @@ impl db::RootDatabase {\n         Ok(None)\n     }\n \n-    pub(crate) fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        let file = self.source_file(frange.file_id);\n-        let syntax = file.syntax();\n-        let node = find_covering_node(syntax, frange.range);\n-        let parent_fn = ctry!(node.ancestors().find_map(FnDef::cast));\n-        let function = ctry!(source_binder::function_from_source(\n-            self,\n-            frange.file_id,\n-            parent_fn\n-        )?);\n-        let infer = function.infer(self)?;\n-        Ok(infer.type_of_node(node).map(|t| t.to_string()))\n-    }\n     pub(crate) fn rename(\n         &self,\n         position: FilePosition,\n@@ -506,91 +480,3 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n }\n-\n-impl NavigationTarget {\n-    fn node(&self, db: &db::RootDatabase) -> Option<SyntaxNode> {\n-        let source_file = db.source_file(self.file_id);\n-        let source_file = source_file.syntax();\n-        let node = source_file\n-            .descendants()\n-            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n-            .owned();\n-        Some(node)\n-    }\n-\n-    fn docs(&self, db: &db::RootDatabase) -> Option<String> {\n-        let node = self.node(db)?;\n-        let node = node.borrowed();\n-        fn doc_comments<'a, N: ast::DocCommentsOwner<'a>>(node: N) -> Option<String> {\n-            let comments = node.doc_comment_text();\n-            if comments.is_empty() {\n-                None\n-            } else {\n-                Some(comments)\n-            }\n-        }\n-\n-        visitor()\n-            .visit(doc_comments::<ast::FnDef>)\n-            .visit(doc_comments::<ast::StructDef>)\n-            .visit(doc_comments::<ast::EnumDef>)\n-            .visit(doc_comments::<ast::TraitDef>)\n-            .visit(doc_comments::<ast::Module>)\n-            .visit(doc_comments::<ast::TypeDef>)\n-            .visit(doc_comments::<ast::ConstDef>)\n-            .visit(doc_comments::<ast::StaticDef>)\n-            .accept(node)?\n-    }\n-\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    fn description(&self, db: &db::RootDatabase) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n-        let node = self.node(db)?;\n-        let node = node.borrowed();\n-        // TODO: Refactor to be have less repetition\n-        visitor()\n-            .visit(|node: ast::FnDef| {\n-                let mut string = \"fn \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::StructDef| {\n-                let mut string = \"struct \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::EnumDef| {\n-                let mut string = \"enum \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::TraitDef| {\n-                let mut string = \"trait \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::Module| {\n-                let mut string = \"mod \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::TypeDef| {\n-                let mut string = \"type \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::ConstDef| {\n-                let mut string = \"const \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::StaticDef| {\n-                let mut string = \"static \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .accept(node)?\n-    }\n-}"}, {"sha": "b068119d2b2c22ededc808b2b7c805c24b016d26", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "patch": "@@ -21,6 +21,7 @@ mod runnables;\n \n mod extend_selection;\n mod syntax_highlighting;\n+mod hover;\n \n use std::{fmt, sync::Arc};\n \n@@ -260,6 +261,18 @@ impl NavigationTarget {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct RangeInfo<T> {\n+    pub range: TextRange,\n+    pub info: T,\n+}\n+\n+impl<T> RangeInfo<T> {\n+    fn new(range: TextRange, info: T) -> RangeInfo<T> {\n+        RangeInfo { range, info }\n+    }\n+}\n+\n /// Result of \"goto def\" query.\n #[derive(Debug)]\n pub struct ReferenceResolution {\n@@ -390,9 +403,9 @@ impl Analysis {\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n         self.db.find_all_refs(position)\n     }\n-    /// Returns documentation string for a given target.\n-    pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        self.db.doc_text_for(nav)\n+    /// Returns a short text descrbing element at position.\n+    pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n+        hover::hover(&*self.db, position)\n     }\n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n@@ -437,7 +450,7 @@ impl Analysis {\n     }\n     /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        self.db.type_of(frange)\n+        hover::type_of(&*self.db, frange)\n     }\n     /// Returns the edit required to rename reference at the position to the new\n     /// name."}, {"sha": "ffca3f51cbe11faccbfc66e8040f375f110b07dd", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c86e686c186f75cf8c7c5d61fc12054c2ccf15/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=b1c86e686c186f75cf8c7c5d61fc12054c2ccf15", "patch": "@@ -9,7 +9,7 @@ use languageserver_types::{\n     Range, WorkspaceEdit, ParameterInformation, ParameterLabel, SignatureInformation, Hover,\n     HoverContents, DocumentFormattingParams, DocumentHighlight,\n };\n-use ra_analysis::{FileId, FoldKind, Query, RunnableKind, FileRange, FilePosition, Severity, NavigationTarget};\n+use ra_analysis::{FileId, FoldKind, Query, RunnableKind, FileRange, FilePosition, Severity};\n use ra_syntax::{TextUnit, text_utils::intersect};\n use ra_text_edit::text_utils::contains_offset_nonstrict;\n use rustc_hash::FxHashMap;\n@@ -509,36 +509,18 @@ pub fn handle_hover(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<Hover>> {\n-    // TODO: Cut down on number of allocations\n     let position = params.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(position.file_id);\n-    let rr = match world.analysis().approximately_resolve_symbol(position)? {\n+    let info = match world.analysis().hover(position)? {\n         None => return Ok(None),\n-        Some(it) => it,\n+        Some(info) => info,\n     };\n-    let mut result = Vec::new();\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let file_range = FileRange {\n-        file_id,\n-        range: rr.reference_range,\n+    let line_index = world.analysis.file_line_index(position.file_id);\n+    let range = info.range.conv_with(&line_index);\n+    let res = Hover {\n+        contents: HoverContents::Scalar(MarkedString::String(info.info)),\n+        range: Some(range),\n     };\n-    if let Some(type_name) = get_type(&world, file_range) {\n-        result.push(type_name);\n-    }\n-    for nav in rr.resolves_to {\n-        if let Some(docs) = get_doc_text(&world, nav) {\n-            result.push(docs);\n-        }\n-    }\n-\n-    let range = rr.reference_range.conv_with(&line_index);\n-    if result.len() > 0 {\n-        return Ok(Some(Hover {\n-            contents: HoverContents::Scalar(MarkedString::String(result.join(\"\\n\\n---\\n\"))),\n-            range: Some(range),\n-        }));\n-    }\n-    Ok(None)\n+    Ok(Some(res))\n }\n \n /// Test doc comment\n@@ -762,17 +744,3 @@ fn to_diagnostic_severity(severity: Severity) -> DiagnosticSeverity {\n         WeakWarning => DiagnosticSeverity::Hint,\n     }\n }\n-\n-fn get_type(world: &ServerWorld, file_range: FileRange) -> Option<String> {\n-    match world.analysis().type_of(file_range) {\n-        Ok(result) => result,\n-        _ => None,\n-    }\n-}\n-\n-fn get_doc_text(world: &ServerWorld, nav: NavigationTarget) -> Option<String> {\n-    match world.analysis().doc_text_for(nav) {\n-        Ok(result) => result,\n-        _ => None,\n-    }\n-}"}]}