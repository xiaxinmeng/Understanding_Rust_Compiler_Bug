{"sha": "0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMmQ0NmYzOTYwYjEwMTFkNGU5NmFiMDA1YjhlYmE2ZjdiMzJiNzU=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-03-16T23:04:29Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-03-19T05:03:17Z"}, "message": "Docify std::vec_ng\n\nI also removed a couple of methods that were silly and added sort.", "tree": {"sha": "bef33decaf2850c2d2807e7a2978674e1ab57b2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bef33decaf2850c2d2807e7a2978674e1ab57b2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "html_url": "https://github.com/rust-lang/rust/commit/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87e72c38122cbd24199365232217ca8c15ebe995", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e72c38122cbd24199365232217ca8c15ebe995", "html_url": "https://github.com/rust-lang/rust/commit/87e72c38122cbd24199365232217ca8c15ebe995"}], "stats": {"total": 672, "additions": 626, "deletions": 46}, "files": [{"sha": "8861f90b92890be96a07e49fcb18dd17cf30c3a2", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -117,7 +117,7 @@ impl TotalOrd for BigUint {\n         if s_len < o_len { return Less; }\n         if s_len > o_len { return Greater;  }\n \n-        for (&self_i, &other_i) in self.data.rev_iter().zip(other.data.rev_iter()) {\n+        for (&self_i, &other_i) in self.data.iter().rev().zip(other.data.iter().rev()) {\n             if self_i < other_i { return Less; }\n             if self_i > other_i { return Greater; }\n         }\n@@ -788,7 +788,7 @@ impl BigUint {\n \n         let mut borrow = 0;\n         let mut shifted_rev = Vec::with_capacity(self.data.len());\n-        for elem in self.data.rev_iter() {\n+        for elem in self.data.iter().rev() {\n             shifted_rev.push((*elem >> n_bits) | borrow);\n             borrow = *elem << (BigDigit::bits - n_bits);\n         }"}, {"sha": "ee759e65240a87a0f446133d72e4610fdf64ac4b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -288,7 +288,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n               ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n-                let max_len = m.rev_iter().fold(0, |max_len, r| {\n+                let max_len = m.iter().rev().fold(0, |max_len, r| {\n                   match r.get(0).node {\n                     PatVec(ref before, _, ref after) => {\n                       cmp::max(before.len() + after.len(), max_len)"}, {"sha": "62998186ba384f6161ab7e64295b291f03fb740d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -879,7 +879,7 @@ impl<'a> Liveness<'a> {\n     fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n-        blk.stmts.rev_iter().fold(succ, |succ, stmt| {\n+        blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n         })\n     }\n@@ -980,7 +980,7 @@ impl<'a> Liveness<'a> {\n                         this.ir.tcx.sess.span_bug(expr.span, \"no registered caps\");\n                      }\n                  };\n-                 caps.deref().rev_iter().fold(succ, |succ, cap| {\n+                 caps.deref().iter().rev().fold(succ, |succ, cap| {\n                      this.init_from_succ(cap.ln, succ);\n                      let var = this.variable(cap.var_nid, expr.span);\n                      this.acc(cap.ln, var, ACC_READ | ACC_USE);\n@@ -1121,7 +1121,7 @@ impl<'a> Liveness<'a> {\n \n           ExprStruct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            fields.rev_iter().fold(succ, |succ, field| {\n+            fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(field.expr, succ)\n             })\n           }\n@@ -1173,14 +1173,14 @@ impl<'a> Liveness<'a> {\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = ia.outputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n+            let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, expr)| {\n                 // see comment on lvalues in\n                 // propagate_through_lvalue_components()\n                 let succ = self.write_lvalue(expr, succ, ACC_WRITE);\n                 self.propagate_through_lvalue_components(expr, succ)\n             });\n             // Inputs are executed first. Propagate last because of rev order\n-            ia.inputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n+            ia.inputs.iter().rev().fold(succ, |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n             })\n           }"}, {"sha": "7a14452158f62ceeb2255d09a16df940cbb37968", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -5520,7 +5520,8 @@ impl<'a> Resolver<'a> {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(idents.move_rev_iter()\n+        return self.idents_to_str(idents.move_iter()\n+                                        .rev()\n                                         .collect::<Vec<ast::Ident>>()\n                                         .as_slice());\n     }"}, {"sha": "600f0d6e3f2fa0c646365fede07c29c93e7f7def", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -94,7 +94,8 @@ fn lookup_vtables(vcx: &VtableContext,\n     // We do this backwards for reasons discussed above.\n     assert_eq!(substs.tps.len(), type_param_defs.len());\n     let mut result: Vec<vtable_param_res> =\n-        substs.tps.rev_iter()\n+        substs.tps.iter()\n+        .rev()\n         .zip(type_param_defs.rev_iter())\n         .map(|(ty, def)|\n             lookup_vtables_for_param(vcx, span, Some(substs),"}, {"sha": "04e3ad920ec7599ce5758e6eba0c6a54f323c43f", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 608, "deletions": 30, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -7,19 +7,15 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-// Migrate documentation over from `std::vec` progressively.  (This is\n-// shown in docs so that people have something to refer too, even if\n-// the page is rather empty.)\n-#[allow(missing_doc)];\n+//! A growable, owned vector\n \n use cast::{forget, transmute};\n use clone::Clone;\n use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd};\n use container::{Container, Mutable};\n use default::Default;\n use fmt;\n-use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator, Rev};\n+use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator};\n use libc::{free, c_void};\n use mem::{size_of, move_val_init};\n use mem;\n@@ -32,8 +28,21 @@ use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n use vec::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n-use vec::{RevItems};\n-\n+use vec::{MutableTotalOrdVector};\n+\n+/// An owned, growable vector\n+///\n+/// `Vec<T>` is the replacement for the deprecated `~[T]` type. The API is\n+/// largely the same. The `vec!` macro is provided to make initialization\n+/// easier.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let mut vec = vec!(1, 2, 3);\n+/// vec.push(4);\n+/// println!(\"{}\", vec); // prints [1, 2, 3, 4]\n+/// ```\n #[unsafe_no_drop_flag]\n pub struct Vec<T> {\n     priv len: uint,\n@@ -42,11 +51,32 @@ pub struct Vec<T> {\n }\n \n impl<T> Vec<T> {\n+    /// Constructs a new, empty `Vec`.\n+    ///\n+    /// The vector will not allocate until elements are pushed onto it.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let mut vec: Vec<int> = Vec::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> Vec<T> {\n         Vec { len: 0, cap: 0, ptr: 0 as *mut T }\n     }\n \n+    /// Constructs a new, empty `Vec` with the specified capacity.\n+    ///\n+    /// The vector will be able to hold exactly `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the vector will not allocate.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// ```\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if capacity == 0 {\n             Vec::new()\n@@ -57,6 +87,19 @@ impl<T> Vec<T> {\n         }\n     }\n \n+\n+    /// Creates and initializes a `Vec`.\n+    ///\n+    /// Creates a `Vec` of size `length` and initializes the elements to the\n+    /// value returned by the closure `op`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let vec = Vec::from_fn(3, |idx| idx * 2);\n+    /// assert_eq!(vec, vec!(0, 2, 4));\n+    /// ```\n     pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -68,10 +111,20 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /**\n-     * Partitions the vector into two vectors `(A,B)`, where all\n-     * elements of `A` satisfy `f` and all elements of `B` do not.\n-     */\n+    /// Consumes the `Vec`, partitioning it based on a predcate.\n+    ///\n+    /// Partitions the `Vec` into two `Vec`s `(A,B)`, where all elements of `A`\n+    /// satisfy `f` and all elements of `B` do not. The order of elements is\n+    /// preserved.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3, 4);\n+    /// let (even, odd) = vec.partition(|&n| n % 2 == 0);\n+    /// assert_eq!(even, vec!(2, 4));\n+    /// assert_eq!(odd, vec!(1, 3));\n+    /// ```\n     #[inline]\n     pub fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n@@ -90,10 +143,29 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n+    /// Constructs a `Vec` by cloning elements of a slice.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let slice = [1, 2, 3];\n+    /// let vec = Vec::from_slice(slice);\n+    /// ```\n     pub fn from_slice(values: &[T]) -> Vec<T> {\n         values.iter().map(|x| x.clone()).collect()\n     }\n \n+    /// Constructs a `Vec` with copies of a value.\n+    ///\n+    /// Creates a `Vec` with `length` copies of `value`.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let vec = Vec::from_elem(3, \"hi\");\n+    /// println!(\"{}\", vec); // prints [hi, hi, hi]\n+    /// ```\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -105,33 +177,84 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n+    /// Appends all elements in a slice to the `Vec`.\n+    ///\n+    /// Iterates over the slice `other`, clones each element, and then appends\n+    /// it to this `Vec`. The `other` vector is traversed in-order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1);\n+    /// vec.push_all([2, 3, 4]);\n+    /// assert_eq!(vec, vec!(1, 2, 3, 4));\n+    /// ```\n     #[inline]\n     pub fn push_all(&mut self, other: &[T]) {\n         for element in other.iter() {\n             self.push((*element).clone())\n         }\n     }\n \n-\n-    pub fn grow(&mut self, n: uint, initval: &T) {\n+    /// Grows the `Vec` in-place.\n+    ///\n+    /// Adds `n` copies of `value` to the `Vec`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(\"hello\");\n+    /// vec.grow(2, & &\"world\");\n+    /// assert_eq!(vec, vec!(\"hello\", \"world\", \"world\"));\n+    /// ```\n+    pub fn grow(&mut self, n: uint, value: &T) {\n         let new_len = self.len() + n;\n         self.reserve(new_len);\n         let mut i: uint = 0u;\n \n         while i < n {\n-            self.push((*initval).clone());\n+            self.push((*value).clone());\n             i += 1u;\n         }\n     }\n \n-    pub fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n+    /// Sets the value of a vector element at a given index, growing the vector\n+    /// as needed.\n+    ///\n+    /// Sets the element at position `index` to `value`. If `index` is past the\n+    /// end of the vector, expands the vector by replicating `initval` to fill\n+    /// the intervening space.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(\"a\", \"b\", \"c\");\n+    /// vec.grow_set(1, & &\"fill\", \"d\");\n+    /// vec.grow_set(4, & &\"fill\", \"e\");\n+    /// assert_eq!(vec, vec!(\"a\", \"d\", \"c\", \"fill\", \"e\"));\n+    /// ```\n+    pub fn grow_set(&mut self, index: uint, initval: &T, value: T) {\n         let l = self.len();\n         if index >= l {\n             self.grow(index - l + 1u, initval);\n         }\n-        *self.get_mut(index) = val;\n-    }\n-\n+        *self.get_mut(index) = value;\n+    }\n+\n+    /// Partitions a vector based on a predcate.\n+    ///\n+    /// Clones the elements of the vector, partitioning them into two `Vec`s\n+    /// `(A,B)`, where all elements of `A` satisfy `f` and all elements of `B`\n+    /// do not. The order of elements is preserved.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3, 4);\n+    /// let (even, odd) = vec.partitioned(|&n| n % 2 == 0);\n+    /// assert_eq!(even, vec!(2, 4));\n+    /// assert_eq!(odd, vec!(1, 3));\n+    /// ```\n     pub fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts = Vec::new();\n         let mut rights = Vec::new();\n@@ -215,11 +338,36 @@ impl<T> Container for Vec<T> {\n }\n \n impl<T> Vec<T> {\n+    /// Returns the number of elements the vector can hold without\n+    /// reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// assert_eq!(vec.capacity(), 10);\n+    /// ```\n     #[inline]\n     pub fn capacity(&self) -> uint {\n         self.cap\n     }\n \n+     /// Reserves capacity for at least `n` additional elements in the given\n+     /// vector.\n+     ///\n+     /// # Failure\n+     ///\n+     /// Fails if the new capacity overflows `uint`.\n+     ///\n+     /// # Example\n+     ///\n+     /// ```rust\n+     /// # use std::vec_ng::Vec;\n+     /// let mut vec: Vec<int> = vec!(1);\n+     /// vec.reserve_additional(10);\n+     /// assert!(vec.capacity() >= 11);\n+     /// ```\n     pub fn reserve_additional(&mut self, extra: uint) {\n         if self.cap - self.len < extra {\n             match self.len.checked_add(&extra) {\n@@ -229,12 +377,41 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Reserves capacity for at least `n` elements in the given vector.\n+    ///\n+    /// This function will over-allocate in order to amortize the allocation\n+    /// costs in scenarios where the caller may need to repeatedly reserve\n+    /// additional space.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// vec.reserve(10);\n+    /// assert!(vec.capacity() >= 10);\n+    /// ```\n     pub fn reserve(&mut self, capacity: uint) {\n         if capacity >= self.len {\n             self.reserve_exact(num::next_power_of_two(capacity))\n         }\n     }\n \n+    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::vec_ng::Vec;\n+    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    /// vec.reserve_exact(11);\n+    /// assert_eq!(vec.capacity(), 11);\n+    /// ```\n     pub fn reserve_exact(&mut self, capacity: uint) {\n         if capacity >= self.len {\n             let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n@@ -245,6 +422,15 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Shrink the capacity of the vector to match the length\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// vec.shrink_to_fit();\n+    /// assert_eq!(vec.capacity(), vec.len());\n+    /// ```\n     pub fn shrink_to_fit(&mut self) {\n         if self.len == 0 {\n             unsafe { free(self.ptr as *mut c_void) };\n@@ -259,6 +445,16 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Remove the last element from a vector and return it, or `None` if it is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// assert_eq!(vec.pop(), Some(3));\n+    /// assert_eq!(vec, vec!(1, 2));\n+    /// ```\n     #[inline]\n     pub fn pop(&mut self) -> Option<T> {\n         if self.len == 0 {\n@@ -271,6 +467,19 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Append an element to a vector.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the number of elements in the vector overflows a `uint`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2);\n+    /// vec.push(3);\n+    /// assert_eq!(vec, vec!(1, 2, 3));\n+    /// ```\n     #[inline]\n     pub fn push(&mut self, value: T) {\n         if self.len == self.cap {\n@@ -291,6 +500,18 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Shorten a vector, dropping excess elements.\n+    ///\n+    /// If `len` is greater than the vector's current length, this has no\n+    /// effect.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3, 4);\n+    /// vec.truncate(2);\n+    /// assert_eq!(vec, vec!(1, 2));\n+    /// ```\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             let mut i = len;\n@@ -303,18 +524,51 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n+    /// Work with `self` as a slice.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// fn foo(slice: &[int]) {}\n+    ///\n+    /// let vec = vec!(1, 2);\n+    /// foo(vec.as_slice());\n+    /// ```\n     #[inline]\n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n         let slice = Slice { data: self.ptr as *T, len: self.len };\n         unsafe { transmute(slice) }\n     }\n \n+    /// Work with `self` as a mutable slice.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// fn foo(slice: &mut [int]) {}\n+    ///\n+    /// let mut vec = vec!(1, 2);\n+    /// foo(vec.as_mut_slice());\n+    /// ```\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         let slice = Slice { data: self.ptr as *T, len: self.len };\n         unsafe { transmute(slice) }\n     }\n \n+    /// Creates a consuming iterator, that is, one that moves each\n+    /// value out of the vector (from start to end). The vector cannot\n+    /// be used after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v = vec!(~\"a\", ~\"b\");\n+    /// for s in v.move_iter() {\n+    ///     // s has type ~str, not &~str\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n@@ -325,66 +579,204 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    #[inline]\n-    pub fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n-        self.move_iter().rev()\n-    }\n \n+    /// Sets the length of a vector.\n+    ///\n+    /// This will explicitly set the size of the vector, without actually\n+    /// modifying its buffers, so it is up to the caller to ensure that the\n+    /// vector is actually the specified size.\n     #[inline]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n     }\n \n+    /// Returns a reference to the value at index `index`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `index` is out of bounds\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// assert!(vec.get(1) == &2);\n+    /// ```\n     #[inline]\n     pub fn get<'a>(&'a self, index: uint) -> &'a T {\n         &self.as_slice()[index]\n     }\n \n+    /// Returns a mutable reference to the value at index `index`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `index` is out of bounds\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// *vec.get_mut(1) = 4;\n+    /// assert_eq!(vec, vec!(1, 4, 3));\n+    /// ```\n     #[inline]\n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n         &mut self.as_mut_slice()[index]\n     }\n \n+    /// Returns an iterator over references to the elements of the vector in\n+    /// order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// for num in vec.iter() {\n+    ///     println!(\"{}\", *num);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> Items<'a,T> {\n         self.as_slice().iter()\n     }\n \n+\n+    /// Returns an iterator over mutable references to the elements of the\n+    /// vector in order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// for num in vec.mut_iter() {\n+    ///     *num = 0;\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> {\n         self.as_mut_slice().mut_iter()\n     }\n \n+    /// Sort the vector, in place, using `compare` to compare elements.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = vec!(5i, 4, 1, 3, 2);\n+    /// v.sort_by(|a, b| a.cmp(b));\n+    /// assert_eq!(v, vec!(1, 2, 3, 4, 5));\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(v, vec!(5, 4, 3, 2, 1));\n+    /// ```\n     #[inline]\n     pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n         self.as_mut_slice().sort_by(compare)\n     }\n \n+    /// Returns a slice of `self` between `start` and `end`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails when `start` or `end` point outside the bounds of `self`, or when\n+    /// `start` > `end`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3, 4);\n+    /// assert!(vec.slice(0, 2) == [1, 2]);\n+    /// ```\n     #[inline]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n         self.as_slice().slice(start, end)\n     }\n \n+    /// Returns a slice containing all but the first element of the vector.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails when the vector is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// assert!(vec.tail() == [2, 3]);\n+    /// ```\n     #[inline]\n     pub fn tail<'a>(&'a self) -> &'a [T] {\n         self.as_slice().tail()\n     }\n \n+    /// Returns all but the first `n' elements of a vector.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails when there are fewer than `n` elements in the vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3, 4);\n+    /// assert!(vec.tailn(2) == [3, 4]);\n+    /// ```\n     #[inline]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n         self.as_slice().tailn(n)\n     }\n \n+    /// Returns a reference to the last element of a vector, or `None` if it is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// assert!(vec.last() == Some(&3));\n+    /// ```\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n         self.as_slice().last()\n     }\n \n+    /// Returns a mutable reference to the last element of a vector, or `None`\n+    /// if it is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// *vec.mut_last().unwrap() = 4;\n+    /// assert_eq!(vec, vec!(1, 2, 4));\n+    /// ```\n     #[inline]\n     pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n         self.as_mut_slice().mut_last()\n     }\n \n+    /// Remove an element from anywhere in the vector and return it, replacing\n+    /// it with the last element. This does not preserve ordering, but is O(1).\n+    ///\n+    /// Returns `None` if `index` is out of bounds.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let mut v = ~[~\"foo\", ~\"bar\", ~\"baz\", ~\"qux\"];\n+    ///\n+    /// assert_eq!(v.swap_remove(1), Some(~\"bar\"));\n+    /// assert_eq!(v, ~[~\"foo\", ~\"qux\", ~\"baz\"]);\n+    ///\n+    /// assert_eq!(v.swap_remove(0), Some(~\"foo\"));\n+    /// assert_eq!(v, ~[~\"baz\", ~\"qux\"]);\n+    ///\n+    /// assert_eq!(v.swap_remove(2), None);\n+    /// ```\n     #[inline]\n     pub fn swap_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n@@ -396,16 +788,59 @@ impl<T> Vec<T> {\n         self.pop()\n     }\n \n+    /// Prepend an element to the vector.\n+    ///\n+    /// # Warning\n+    ///\n+    /// This is an O(n) operation as it requires copying every element in the\n+    /// vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// vec.unshift(4);\n+    /// assert_eq!(vec, vec!(4, 1, 2, 3));\n+    /// ```\n     #[inline]\n     pub fn unshift(&mut self, element: T) {\n         self.insert(0, element)\n     }\n \n+    /// Removes the first element from a vector and returns it, or `None` if\n+    /// the vector is empty.\n+    ///\n+    /// # Warning\n+    ///\n+    /// This is an O(n) operation as it requires copying every element in the\n+    /// vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// assert!(vec.shift() == Some(1));\n+    /// assert_eq!(vec, vec!(2, 3));\n+    /// ```\n     #[inline]\n     pub fn shift(&mut self) -> Option<T> {\n         self.remove(0)\n     }\n \n+    /// Insert an element at position `index` within the vector, shifting all\n+    /// elements after position i one position to the right.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `index` is out of bounds of the vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3);\n+    /// vec.insert(1, 4);\n+    /// assert_eq!(vec, vec!(1, 4, 2, 3));\n+    /// ```\n     pub fn insert(&mut self, index: uint, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n@@ -427,6 +862,21 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Remove and return the element at position `index` within the vector,\n+    /// shifting all elements after position `index` one position to the left.\n+    /// Returns `None` if `i` is out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = ~[1, 2, 3];\n+    /// assert_eq!(v.remove(1), Some(2));\n+    /// assert_eq!(v, ~[1, 3]);\n+    ///\n+    /// assert_eq!(v.remove(4), None);\n+    /// // v is unchanged:\n+    /// assert_eq!(v, ~[1, 3]);\n+    /// ```\n     pub fn remove(&mut self, index: uint) -> Option<T> {\n         let len = self.len();\n         if index < len {\n@@ -450,62 +900,153 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> RevItems<'a,T> {\n-        self.as_slice().rev_iter()\n-    }\n-\n+    ///Apply a function to each element of a vector and return the results.\n     #[inline]\n     #[deprecated=\"Use `xs.iter().map(closure)` instead.\"]\n     pub fn map<U>(&self, f: |t: &T| -> U) -> Vec<U> {\n         self.iter().map(f).collect()\n     }\n \n+    /// Takes ownership of the vector `other`, moving all elements into\n+    /// the current vector. This does not copy any elements, and it is\n+    /// illegal to use the `other` vector after calling this method\n+    /// (because it is moved here).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(~1);\n+    /// vec.push_all_move(vec!(~2, ~3, ~4));\n+    /// assert_eq!(vec, vec!(~1, ~2, ~3, ~4));\n+    /// ```\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n         for element in other.move_iter() {\n             self.push(element)\n         }\n     }\n \n+    /// Returns a mutable slice of `self` between `start` and `end`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails when `start` or `end` point outside the bounds of `self`, or when\n+    /// `start` > `end`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 3, 4);\n+    /// assert!(vec.mut_slice(0, 2) == [1, 2]);\n+    /// ```\n     #[inline]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n-                     -> &'a mut [T] {\n+                         -> &'a mut [T] {\n         self.as_mut_slice().mut_slice(start, end)\n     }\n \n+    /// Reverse the order of elements in a vector, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = vec!(1, 2, 3);\n+    /// v.reverse();\n+    /// assert_eq!(v, vec!(3, 2, 1));\n+    /// ```\n     #[inline]\n     pub fn reverse(&mut self) {\n         self.as_mut_slice().reverse()\n     }\n \n+    /// Returns a slice of `self` from `start` to the end of the vec.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails when `start` points outside the bounds of self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// assert!(vec.slice_from(1) == [2, 3]);\n+    /// ```\n     #[inline]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n         self.as_slice().slice_from(start)\n     }\n \n+    /// Returns a slice of self from the start of the vec to `end`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails when `end` points outside the bounds of self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// assert!(vec.slice_to(2) == [1, 2]);\n+    /// ```\n     #[inline]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n         self.as_slice().slice_to(end)\n     }\n \n+    /// Returns a slice containing all but the last element of the vector.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the vector is empty\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n         self.slice(0, self.len() - 1)\n     }\n \n+\n+    /// Returns an unsafe pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_ptr(&self) -> *T {\n         self.as_slice().as_ptr()\n     }\n \n+    /// Returns a mutable unsafe pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         self.as_mut_slice().as_mut_ptr()\n     }\n }\n \n+impl<T:TotalOrd> Vec<T> {\n+    /// Sorts the vector in place.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(3i, 1, 2);\n+    /// vec.sort();\n+    /// assert_eq!(vec, vec!(1, 2, 3));\n+    /// ```\n+    pub fn sort(&mut self) {\n+        self.as_mut_slice().sort()\n+    }\n+}\n+\n impl<T> Mutable for Vec<T> {\n-    /// Clear the vector, removing all values.\n     #[inline]\n     fn clear(&mut self) {\n         self.truncate(0)\n@@ -514,10 +1055,28 @@ impl<T> Mutable for Vec<T> {\n \n impl<T:Eq> Vec<T> {\n     /// Return true if a vector contains an element with the given value\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let vec = vec!(1, 2, 3);\n+    /// assert!(vec.contains(&1));\n+    /// ```\n     pub fn contains(&self, x: &T) -> bool {\n         self.as_slice().contains(x)\n     }\n \n+    /// Remove consecutive repeated elements in the vector.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec!(1, 2, 2, 3, 2);\n+    /// vec.dedup();\n+    /// assert_eq!(vec, vec!(1, 2, 3, 2));\n+    /// ```\n     pub fn dedup(&mut self) {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -603,6 +1162,16 @@ impl<T:Eq> Vec<T> {\n     }\n }\n \n+/// Iterates over the `second` vector, copying each element and appending it to\n+/// the `first`. Afterwards, the `first` is then returned for use again.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let vec = vec!(1, 2);\n+/// let vec = std::vec_ng::append(vec, [3, 4]);\n+/// assert_eq!(vec, vec!(1, 2, 3, 4));\n+/// ```\n #[inline]\n pub fn append<T:Clone>(mut first: Vec<T>, second: &[T]) -> Vec<T> {\n     first.push_all(second);\n@@ -611,6 +1180,14 @@ pub fn append<T:Clone>(mut first: Vec<T>, second: &[T]) -> Vec<T> {\n \n /// Appends one element to the vector provided. The vector itself is then\n /// returned for use again.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let vec = vec!(1, 2);\n+/// let vec = std::vec_ng::append_one(vec, 3);\n+/// assert_eq!(vec, vec!(1, 2, 3));\n+/// ```\n #[inline]\n pub fn append_one<T>(mut lhs: Vec<T>, x: T) -> Vec<T> {\n     lhs.push(x);\n@@ -643,6 +1220,7 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n+/// An iterator that moves out of a vector.\n pub struct MoveItems<T> {\n     priv allocation: *mut c_void, // the block of memory allocated for the vector\n     priv iter: Items<'static, T>"}, {"sha": "d24bb2802c6436b3f3b961790ecfc3a2d740fb50", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -1158,7 +1158,7 @@ pub fn cs_fold(use_foldl: bool,\n                       field.other.as_slice())\n                 })\n             } else {\n-                all_fields.rev_iter().fold(base, |old, field| {\n+                all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n@@ -1235,7 +1235,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n                     f(cx, span, old, new)\n                 })\n             } else {\n-                vals.rev_iter().fold(base, |old, &new| {\n+                vals.iter().rev().fold(base, |old, &new| {\n                     f(cx, span, old, new)\n                 })\n             }"}, {"sha": "5a980cb9de90b9af5451fac3f69e9c0dcd39595d", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -60,7 +60,7 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n             cx.span_warn(mitem.span, \"empty trait list in `deriving`\");\n         }\n         MetaList(_, ref titems) => {\n-            for &titem in titems.rev_iter() {\n+            for &titem in titems.iter().rev() {\n                 match titem.node {\n                     MetaNameValue(ref tname, _) |\n                     MetaList(ref tname, _) |"}, {"sha": "49058917e3092d0d9192ce24768d02e99a067651", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -264,7 +264,7 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n     let it = expand_item_modifiers(it, fld);\n \n     let mut decorator_items = SmallVector::zero();\n-    for attr in it.attrs.rev_iter() {\n+    for attr in it.attrs.iter().rev() {\n         let mname = attr.name();\n \n         match fld.extsbox.find(&intern(mname.get())) {"}, {"sha": "4d96dd75990d62d4c58fa05a0b386ff192432259", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2d46f3960b1011d4e96ab005b8eba6f7b32b75/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=0f2d46f3960b1011d4e96ab005b8eba6f7b32b75", "patch": "@@ -309,7 +309,7 @@ mod tests {\n     // returning the resulting index\n     fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n         -> SyntaxContext {\n-        tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n+        tscs.iter().rev().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n                       M(mrk) => new_mark_internal(mrk,tail,table),\n                       R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n@@ -355,7 +355,7 @@ mod tests {\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n                     -> SyntaxContext {\n-        mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n+        mrks.iter().rev().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n                    {new_mark_internal(*mrk,tail,table)})\n     }\n "}]}