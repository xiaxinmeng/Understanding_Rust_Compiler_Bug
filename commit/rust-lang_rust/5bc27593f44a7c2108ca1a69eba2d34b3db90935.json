{"sha": "5bc27593f44a7c2108ca1a69eba2d34b3db90935", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzI3NTkzZjQ0YTdjMjEwOGNhMWE2OWViYTJkMzRiM2RiOTA5MzU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-11T02:56:26Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: minor fixups\n\n* remove unnecessary clone\n* comment formatting\n* fix bug with `?` collection\n* respect the heuristic if the root is more than just the parent", "tree": {"sha": "c534386fd4c60c7616fea9a15eb5d212f1c47b22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c534386fd4c60c7616fea9a15eb5d212f1c47b22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc27593f44a7c2108ca1a69eba2d34b3db90935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc27593f44a7c2108ca1a69eba2d34b3db90935", "html_url": "https://github.com/rust-lang/rust/commit/5bc27593f44a7c2108ca1a69eba2d34b3db90935", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc27593f44a7c2108ca1a69eba2d34b3db90935/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1", "html_url": "https://github.com/rust-lang/rust/commit/467b095d48ebf5f5e057e1a2b4c1c25aa0375ea1"}], "stats": {"total": 47, "additions": 25, "deletions": 22}, "files": [{"sha": "81be8d54128705281b2cf35dca8c46f75a4864f0", "filename": "src/chains.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5bc27593f44a7c2108ca1a69eba2d34b3db90935/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc27593f44a7c2108ca1a69eba2d34b3db90935/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=5bc27593f44a7c2108ca1a69eba2d34b3db90935", "patch": "@@ -81,8 +81,9 @@ use syntax::codemap::Span;\n use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    debug!(\"rewrite_chain {:?}\", shape);\n     let chain = Chain::from_ast(expr, context);\n+    debug!(\"rewrite_chain {:?} {:?}\", chain, shape);\n+\n     // If this is just an expression with some `?`s, then format it trivially and\n     // return early.\n     if chain.children.is_empty() {\n@@ -95,6 +96,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n // An expression plus trailing `?`s to be formatted together.\n #[derive(Debug)]\n struct ChainItem {\n+    // FIXME: we can't use a reference here because to convert `try!` to `?` we\n+    // synthesise the AST node. However, I think we could use `Cow` and that\n+    // would remove a lot of cloning.\n     expr: ast::Expr,\n     tries: usize,\n }\n@@ -185,28 +189,22 @@ impl ChainItem {\n #[derive(Debug)]\n struct Chain {\n     parent: ChainItem,\n-    // TODO do we need to clone the exprs?\n     children: Vec<ChainItem>,\n }\n \n impl Chain {\n     fn from_ast(expr: &ast::Expr, context: &RewriteContext) -> Chain {\n-        let mut subexpr_list = Self::make_subexpr_list(expr, context);\n+        let subexpr_list = Self::make_subexpr_list(expr, context);\n \n         // Un-parse the expression tree into ChainItems\n         let mut children = vec![];\n         let mut sub_tries = 0;\n-        loop {\n-            if subexpr_list.is_empty() {\n-                break;\n-            }\n-\n-            let subexpr = subexpr_list.pop().unwrap();\n+        for subexpr in subexpr_list {\n             match subexpr.node {\n                 ast::ExprKind::Try(_) => sub_tries += 1,\n                 _ => {\n                     children.push(ChainItem {\n-                        expr: subexpr.clone(),\n+                        expr: subexpr,\n                         tries: sub_tries,\n                     });\n                     sub_tries = 0;\n@@ -215,7 +213,7 @@ impl Chain {\n         }\n \n         Chain {\n-            parent: children.remove(0),\n+            parent: children.pop().unwrap(),\n             children,\n         }\n     }\n@@ -317,6 +315,9 @@ struct ChainFormatterShared<'a> {\n     rewrites: Vec<String>,\n     // Whether the chain can fit on one line.\n     fits_single_line: bool,\n+    // The number of children in the chain. This is not equal to `self.children.len()`\n+    // because `self.children` will change size as we process the chain.\n+    child_count: usize,\n }\n \n impl <'a> ChainFormatterShared<'a> {\n@@ -325,6 +326,7 @@ impl <'a> ChainFormatterShared<'a> {\n             children: &chain.children,\n             rewrites: Vec::with_capacity(chain.children.len() + 1),\n             fits_single_line: false,\n+            child_count: chain.children.len(),\n         }\n     }\n \n@@ -370,7 +372,7 @@ impl <'a> ChainFormatterShared<'a> {\n     // })\n     // ```\n     fn format_last_child(&mut self, may_extend: bool, context: &RewriteContext, shape: Shape, child_shape: Shape) -> Option<()> {\n-        let last = &self.children[self.children.len() - 1];\n+        let last = &self.children[0];\n         let extendable = may_extend && last_line_extendable(&self.rewrites[self.rewrites.len() - 1]);\n \n         // Total of all items excluding the last.\n@@ -379,7 +381,7 @@ impl <'a> ChainFormatterShared<'a> {\n         } else {\n             self.rewrites.iter().fold(0, |a, b| a + b.len())\n         } + last.tries;\n-        let one_line_budget = if self.rewrites.len() == 1 {\n+        let one_line_budget = if self.child_count == 1 {\n             shape.width\n         } else {\n             min(shape.width, context.config.width_heuristics().chain_width)\n@@ -407,9 +409,10 @@ impl <'a> ChainFormatterShared<'a> {\n                         last_subexpr_str = Some(rw);\n                         self.fits_single_line = all_in_one_line;\n                     } else {\n-                        // We could not know whether overflowing is better than using vertical layout,\n-                        // just by looking at the overflowed rewrite. Now we rewrite the last child\n-                        // on its own line, and compare two rewrites to choose which is better.\n+                        // We could not know whether overflowing is better than using vertical\n+                        // layout, just by looking at the overflowed rewrite. Now we rewrite the\n+                        // last child on its own line, and compare two rewrites to choose which is\n+                        // better.\n                         match last.rewrite_postfix(context, last_shape) {\n                             Some(ref new_rw) if !could_fit_single_line => {\n                                 last_subexpr_str = Some(new_rw.clone());\n@@ -486,7 +489,7 @@ impl <'a> ChainFormatter for ChainFormatterBlock<'a> {\n         let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n \n         while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n-            let item = &self.shared.children[0];\n+            let item = &self.shared.children[self.shared.children.len() - 1];\n             let shape = shape.offset_left(root_rewrite.len())?;\n             match &item.rewrite_postfix(context, shape) {\n                 Some(rewrite) => root_rewrite.push_str(rewrite),\n@@ -495,7 +498,7 @@ impl <'a> ChainFormatter for ChainFormatterBlock<'a> {\n \n             root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n \n-            self.shared.children = &self.shared.children[1..];\n+            self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n             if self.shared.children.is_empty() {\n                 break;\n             }\n@@ -514,7 +517,7 @@ impl <'a> ChainFormatter for ChainFormatterBlock<'a> {\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n-        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+        for item in self.shared.children[1..].iter().rev() {\n             let rewrite = item.rewrite_postfix(context, child_shape)?;\n             self.is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n             self.shared.rewrites.push(rewrite);\n@@ -567,13 +570,13 @@ impl <'a> ChainFormatter for ChainFormatterVisual<'a> {\n         let mut root_rewrite = parent.rewrite(context, parent_shape)?;\n \n         if !root_rewrite.contains('\\n') && is_continuable(&parent.expr) {\n-            let item = &self.shared.children[0];\n+            let item = &self.shared.children[self.shared.children.len() - 1];\n             let overhead = last_line_width(&root_rewrite);\n             let shape = parent_shape.offset_left(overhead)?;\n             let rewrite = item.rewrite_postfix(context, shape)?;\n             root_rewrite.push_str(&rewrite);\n \n-            self.shared.children = &self.shared.children[1..];\n+            self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n         }\n \n         self.shared.rewrites.push(root_rewrite);\n@@ -585,7 +588,7 @@ impl <'a> ChainFormatter for ChainFormatterVisual<'a> {\n     }\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n-        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+        for item in self.shared.children[1..].iter().rev() {\n             let rewrite = item.rewrite_postfix(context, child_shape)?;\n             self.shared.rewrites.push(rewrite);\n         }"}]}