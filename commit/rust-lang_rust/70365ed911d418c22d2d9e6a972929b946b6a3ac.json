{"sha": "70365ed911d418c22d2d9e6a972929b946b6a3ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMzY1ZWQ5MTFkNDE4YzIyZDJkOWU2YTk3MjkyOWI5NDZiNmEzYWM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-07-02T05:52:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-07-04T03:21:00Z"}, "message": "rustc: simplify ty::MethodOrigin and avoid trait item indices.", "tree": {"sha": "3f856608f903a99e91c00d0e79208567767a956f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f856608f903a99e91c00d0e79208567767a956f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70365ed911d418c22d2d9e6a972929b946b6a3ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70365ed911d418c22d2d9e6a972929b946b6a3ac", "html_url": "https://github.com/rust-lang/rust/commit/70365ed911d418c22d2d9e6a972929b946b6a3ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70365ed911d418c22d2d9e6a972929b946b6a3ac/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe354e58bdd17ad63f2d9278820eb7ee1ee091d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe354e58bdd17ad63f2d9278820eb7ee1ee091d5", "html_url": "https://github.com/rust-lang/rust/commit/fe354e58bdd17ad63f2d9278820eb7ee1ee091d5"}], "stats": {"total": 1019, "additions": 328, "deletions": 691}, "files": [{"sha": "6b476f92196bdbe3c6f7ef811ba5fbc14d63ec1b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 54, "deletions": 133, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -29,7 +29,7 @@ use middle::check_const::ConstQualif;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n+use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap, fold};\n use syntax::codemap::Span;\n@@ -600,48 +600,54 @@ impl tr for ty::UpvarCapture {\n \n trait read_method_callee_helper<'tcx> {\n     fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> (u32, MethodCallee<'tcx>);\n+                                  -> (u32, ty::MethodCallee<'tcx>);\n }\n \n fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n                                   autoderef: u32,\n-                                  method: &MethodCallee<'tcx>) {\n+                                  method: &ty::MethodCallee<'tcx>) {\n     use serialize::Encoder;\n \n-    rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n+    rbml_w.emit_struct(\"MethodCallee\", 5, |rbml_w| {\n         rbml_w.emit_struct_field(\"autoderef\", 0, |rbml_w| {\n             autoderef.encode(rbml_w)\n         });\n-        rbml_w.emit_struct_field(\"origin\", 1, |rbml_w| {\n-            Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n+        rbml_w.emit_struct_field(\"def_id\", 1, |rbml_w| {\n+            Ok(rbml_w.emit_def_id(method.def_id))\n         });\n-        rbml_w.emit_struct_field(\"ty\", 2, |rbml_w| {\n+        rbml_w.emit_struct_field(\"origin\", 2, |rbml_w| {\n+            Ok(rbml_w.emit_method_origin(method.origin))\n+        });\n+        rbml_w.emit_struct_field(\"ty\", 3, |rbml_w| {\n             Ok(rbml_w.emit_ty(ecx, method.ty))\n         });\n-        rbml_w.emit_struct_field(\"substs\", 3, |rbml_w| {\n+        rbml_w.emit_struct_field(\"substs\", 4, |rbml_w| {\n             Ok(rbml_w.emit_substs(ecx, &method.substs))\n         })\n     }).unwrap();\n }\n \n impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n     fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> (u32, MethodCallee<'tcx>) {\n+                                  -> (u32, ty::MethodCallee<'tcx>) {\n \n-        self.read_struct(\"MethodCallee\", 4, |this| {\n+        self.read_struct(\"MethodCallee\", 5, |this| {\n             let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n             }).unwrap();\n-            Ok((autoderef, MethodCallee {\n-                origin: this.read_struct_field(\"origin\", 1, |this| {\n+            Ok((autoderef, ty::MethodCallee {\n+                def_id: this.read_struct_field(\"def_id\", 1, |this| {\n+                    Ok(this.read_def_id(dcx))\n+                }).unwrap(),\n+                origin: this.read_struct_field(\"origin\", 2, |this| {\n                     Ok(this.read_method_origin(dcx))\n                 }).unwrap(),\n-                ty: this.read_struct_field(\"ty\", 2, |this| {\n+                ty: this.read_struct_field(\"ty\", 3, |this| {\n                     Ok(this.read_ty(dcx))\n                 }).unwrap(),\n-                substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(dcx))\n+                substs: this.read_struct_field(\"substs\", 4, |this| {\n+                    Ok(dcx.tcx.mk_substs(this.read_substs(dcx)))\n                 }).unwrap()\n             }))\n         }).unwrap()\n@@ -707,9 +713,7 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>);\n-    fn emit_method_origin<'a>(&mut self,\n-                              ecx: &e::EncodeContext<'a, 'tcx>,\n-                              method_origin: &ty::MethodOrigin<'tcx>);\n+    fn emit_method_origin(&mut self, method_origin: ty::MethodOrigin);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n@@ -741,61 +745,31 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_method_origin<'b>(&mut self,\n-                              ecx: &e::EncodeContext<'b, 'tcx>,\n-                              method_origin: &ty::MethodOrigin<'tcx>)\n-    {\n+    fn emit_method_origin(&mut self, method_origin: ty::MethodOrigin) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"MethodOrigin\", |this| {\n-            match *method_origin {\n-                ty::MethodStatic(def_id) => {\n-                    this.emit_enum_variant(\"MethodStatic\", 0, 1, |this| {\n-                        Ok(this.emit_def_id(def_id))\n-                    })\n+            match method_origin {\n+                ty::MethodOrigin::Inherent => {\n+                    this.emit_enum_variant(\"Inherent\", 0, 0, |_| Ok(()))\n                 }\n \n-                ty::MethodTypeParam(ref p) => {\n-                    this.emit_enum_variant(\"MethodTypeParam\", 1, 1, |this| {\n-                        this.emit_struct(\"MethodParam\", 2, |this| {\n-                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &p.trait_ref))\n-                            }));\n-                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n-                                this.emit_uint(p.method_num)\n-                            }));\n-                            try!(this.emit_struct_field(\"impl_def_id\", 0, |this| {\n-                                this.emit_option(|this| {\n-                                    match p.impl_def_id {\n-                                        None => this.emit_option_none(),\n-                                        Some(did) => this.emit_option_some(|this| {\n-                                            Ok(this.emit_def_id(did))\n-                                        })\n-                                    }\n+                ty::MethodOrigin::Trait(impl_def_id) => {\n+                    this.emit_enum_variant(\"Trait\", 1, 1, |this| {\n+                        this.emit_option(|this| {\n+                            match impl_def_id {\n+                                None => this.emit_option_none(),\n+                                Some(did) => this.emit_option_some(|this| {\n+                                    Ok(this.emit_def_id(did))\n                                 })\n-                            }));\n-                            Ok(())\n+                            }\n                         })\n                     })\n                 }\n \n-                ty::MethodTraitObject(ref o) => {\n-                    this.emit_enum_variant(\"MethodTraitObject\", 2, 1, |this| {\n-                        this.emit_struct(\"MethodObject\", 2, |this| {\n-                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &o.trait_ref))\n-                            }));\n-                            try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n-                                Ok(this.emit_def_id(o.object_trait_id))\n-                            }));\n-                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n-                                this.emit_uint(o.method_num)\n-                            }));\n-                            try!(this.emit_struct_field(\"vtable_index\", 0, |this| {\n-                                this.emit_uint(o.vtable_index)\n-                            }));\n-                            Ok(())\n-                        })\n+                ty::MethodOrigin::Object(vtable_index) => {\n+                    this.emit_enum_variant(\"Object\", 2, 1, |this| {\n+                        this.emit_uint(vtable_index)\n                     })\n                 }\n             }\n@@ -1071,7 +1045,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    let method_call = MethodCall::expr(id);\n+    let method_call = ty::MethodCall::expr(id);\n     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n@@ -1083,7 +1057,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         match *adjustment {\n             ty::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n-                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                    let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n@@ -1144,8 +1118,7 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers<'tcx> {\n-    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> ty::MethodOrigin<'tcx>;\n+    fn read_method_origin(&mut self, dcx: &DecodeContext) -> ty::MethodOrigin;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1229,77 +1202,25 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> ty::MethodOrigin<'tcx>\n-    {\n+    fn read_method_origin(&mut self, dcx: &DecodeContext) -> ty::MethodOrigin {\n         self.read_enum(\"MethodOrigin\", |this| {\n-            let variants = &[\"MethodStatic\", \"MethodTypeParam\", \"MethodTraitObject\"];\n+            let variants = &[\"Inherent\", \"Trait\", \"Object\"];\n             this.read_enum_variant(variants, |this, i| {\n-                Ok(match i {\n-                    0 => {\n-                        let def_id = this.read_def_id(dcx);\n-                        ty::MethodStatic(def_id)\n-                    }\n+                match i {\n+                    0 => Ok(ty::MethodOrigin::Inherent),\n \n-                    1 => {\n-                        this.read_struct(\"MethodTypeParam\", 2, |this| {\n-                            Ok(ty::MethodTypeParam(\n-                                ty::MethodParam {\n-                                    trait_ref: {\n-                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    method_num: {\n-                                        this.read_struct_field(\"method_num\", 1, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                    impl_def_id: {\n-                                        this.read_struct_field(\"impl_def_id\", 2, |this| {\n-                                            this.read_option(|this, b| {\n-                                                if b {\n-                                                    Ok(Some(this.read_def_id(dcx)))\n-                                                } else {\n-                                                    Ok(None)\n-                                                }\n-                                            })\n-                                        }).unwrap()\n-                                    }\n-                                }))\n-                        }).unwrap()\n-                    }\n+                    1 => this.read_option(|this, b| {\n+                        Ok(ty::MethodOrigin::Trait(if b {\n+                            Some(this.read_def_id(dcx))\n+                        } else {\n+                            None\n+                        }))\n+                    }),\n \n-                    2 => {\n-                        this.read_struct(\"MethodTraitObject\", 2, |this| {\n-                            Ok(ty::MethodTraitObject(\n-                                ty::MethodObject {\n-                                    trait_ref: {\n-                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    object_trait_id: {\n-                                        this.read_struct_field(\"object_trait_id\", 1, |this| {\n-                                            Ok(this.read_def_id(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    method_num: {\n-                                        this.read_struct_field(\"method_num\", 2, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                    vtable_index: {\n-                                        this.read_struct_field(\"vtable_index\", 3, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                }))\n-                        }).unwrap()\n-                    }\n+                    2 => this.read_uint().map(|idx| ty::MethodOrigin::Object(idx)),\n \n                     _ => panic!(\"..\")\n-                })\n+                }\n             })\n         }).unwrap()\n     }\n@@ -1651,7 +1572,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_method_map => {\n                         let (autoderef, method) = val_dsr.read_method_callee(dcx);\n-                        let method_call = MethodCall {\n+                        let method_call = ty::MethodCall {\n                             expr_id: id,\n                             autoderef: autoderef\n                         };"}, {"sha": "fbb7b3f235a34efd3aa487fe48a59be4a1157fe3", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -696,13 +696,11 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            let method_did = match v.tcx.tables.borrow().method_map[&method_call].origin {\n-                ty::MethodStatic(did) => Some(did),\n-                _ => None\n-            };\n-            let is_const = match method_did {\n-                Some(did) => v.handle_const_fn_call(e, did, node_ty),\n-                None => false\n+            let is_const = match v.tcx.tables.borrow().method_map[&method_call] {\n+                ty::MethodCallee { def_id, origin: ty::MethodOrigin::Inherent, .. } => {\n+                    v.handle_const_fn_call(e, def_id, node_ty)\n+                }\n+                _ => false\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);"}, {"sha": "040afcac03cc6d986bb14e6ae3a12032883069fd", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -97,29 +97,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                                 span: codemap::Span) {\n         let method_call = ty::MethodCall::expr(id);\n         match self.tcx.tables.borrow().method_map.get(&method_call) {\n-            Some(method) => {\n-                match method.origin {\n-                    ty::MethodStatic(def_id) => {\n-                        match self.tcx.provided_source(def_id) {\n-                            Some(p_did) => self.check_def_id(p_did),\n-                            None => self.check_def_id(def_id)\n-                        }\n-                    }\n-                    ty::MethodTypeParam(ty::MethodParam {\n-                        ref trait_ref,\n-                        method_num: index,\n-                        ..\n-                    }) |\n-                    ty::MethodTraitObject(ty::MethodObject {\n-                        ref trait_ref,\n-                        method_num: index,\n-                        ..\n-                    }) => {\n-                        let trait_item = self.tcx.trait_item(trait_ref.def_id, index);\n-                        self.check_def_id(trait_item.def_id());\n-                    }\n-                }\n-            }\n+            Some(method) => self.check_def_id(method.def_id),\n             None => {\n                 self.tcx.sess.span_bug(span,\n                                        \"method call expression not \\"}, {"sha": "0d204a823af04d89c60c1b1e98f0d51d914cf488", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 45, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -23,10 +23,7 @@ use self::OverloadedCallType::*;\n use middle::{def, region, pat_util};\n use middle::infer;\n use middle::mem_categorization as mc;\n-use middle::ty::{self};\n-use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n-use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::ty::{MethodStatic, MethodStaticClosure};\n+use middle::ty;\n \n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -229,42 +226,8 @@ impl OverloadedCallType {\n \n     fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n                       -> OverloadedCallType {\n-        let method_descriptor = match tcx.impl_or_trait_item(method_id) {\n-            ty::MethodTraitItem(ref method_descriptor) => {\n-                (*method_descriptor).clone()\n-            }\n-            _ => {\n-                tcx.sess.bug(\"overloaded call method wasn't in method map\")\n-            }\n-        };\n-        let impl_id = match method_descriptor.container {\n-            ty::TraitContainer(_) => {\n-                tcx.sess.bug(\"statically resolved overloaded call method \\\n-                              belonged to a trait?!\")\n-            }\n-            ty::ImplContainer(impl_id) => impl_id,\n-        };\n-        let trait_ref = match tcx.impl_trait_ref(impl_id) {\n-            None => {\n-                tcx.sess.bug(\"statically resolved overloaded call impl \\\n-                              didn't implement a trait?!\")\n-            }\n-            Some(ref trait_ref) => (*trait_ref).clone(),\n-        };\n-        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n-    }\n-\n-    fn from_method_origin(tcx: &ty::ctxt, origin: &MethodOrigin)\n-                          -> OverloadedCallType {\n-        match *origin {\n-            MethodStatic(def_id) => {\n-                OverloadedCallType::from_method_id(tcx, def_id)\n-            }\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n-            }\n-        }\n+        let method = tcx.impl_or_trait_item(method_id);\n+        OverloadedCallType::from_trait_id(tcx, method.container().id())\n     }\n }\n \n@@ -614,11 +577,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let overloaded_call_type =\n-                    match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n-                        Some(method_origin) => {\n-                            OverloadedCallType::from_method_origin(\n-                                self.tcx(),\n-                                &method_origin)\n+                    match self.typer.node_method_id(ty::MethodCall::expr(call.id)) {\n+                        Some(method_id) => {\n+                            OverloadedCallType::from_method_id(self.tcx(), method_id)\n                         }\n                         None => {\n                             self.tcx().sess.span_bug("}, {"sha": "63f31921ec2ecb1fba74cd79b91c052797e61a5b", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -1327,7 +1327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)\n-                      -> Option<Ty<'tcx>> {\n+                          -> Option<Ty<'tcx>> {\n         self.tables\n             .borrow()\n             .method_map\n@@ -1336,14 +1336,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .map(|ty| self.resolve_type_vars_if_possible(&ty))\n     }\n \n-    pub fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n+    pub fn node_method_id(&self, method_call: ty::MethodCall)\n+                          -> Option<ast::DefId> {\n         self.tables\n             .borrow()\n             .method_map\n             .get(&method_call)\n-            .map(|method| method.origin.clone())\n+            .map(|method| method.def_id)\n     }\n \n     pub fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {"}, {"sha": "dda33b28cce3ba51331f4ff888fcde8393c452d0", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -128,8 +128,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match self.tcx.tables.borrow().method_map.get(&method_call).unwrap().origin {\n-                    ty::MethodStatic(def_id) => {\n+                match self.tcx.tables.borrow().method_map[&method_call] {\n+                    ty::MethodCallee { def_id, origin: ty::MethodOrigin::Inherent, .. } => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n                                 self.worklist.push(def_id.node)"}, {"sha": "7cabf50fe093154eac47b4c37b95d095942d45b1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -407,25 +407,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n             match tcx.tables.borrow().method_map.get(&method_call) {\n-                Some(method) => {\n-                    match method.origin {\n-                        ty::MethodStatic(def_id) => {\n-                            def_id\n-                        }\n-                        ty::MethodTypeParam(ty::MethodParam {\n-                            ref trait_ref,\n-                            method_num: index,\n-                            ..\n-                        }) |\n-                        ty::MethodTraitObject(ty::MethodObject {\n-                            ref trait_ref,\n-                            method_num: index,\n-                            ..\n-                        }) => {\n-                            tcx.trait_item(trait_ref.def_id, index).def_id()\n-                        }\n-                    }\n-                }\n+                Some(method) => method.def_id,\n                 None => return\n             }\n         }"}, {"sha": "4e98ef2753105c4a0d73238feb2ea2f94d6e8a06", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -141,19 +141,25 @@ impl<'tcx> Substs<'tcx> {\n     {\n         let Substs { types, regions } = self;\n         let types = types.with_vec(FnSpace, m_types);\n-        let regions = regions.map(m_regions,\n-                                  |r, m_regions| r.with_vec(FnSpace, m_regions));\n+        let regions = regions.map(|r| r.with_vec(FnSpace, m_regions));\n+        Substs { types: types, regions: regions }\n+    }\n+\n+    pub fn method_to_trait(self) -> Substs<'tcx> {\n+        let Substs { mut types, regions } = self;\n+        types.truncate(FnSpace, 0);\n+        let regions = regions.map(|mut r| { r.truncate(FnSpace, 0); r });\n         Substs { types: types, regions: regions }\n     }\n }\n \n impl RegionSubsts {\n-    fn map<A, F>(self, a: A, op: F) -> RegionSubsts where\n-        F: FnOnce(VecPerParamSpace<ty::Region>, A) -> VecPerParamSpace<ty::Region>,\n+    fn map<F>(self, op: F) -> RegionSubsts where\n+        F: FnOnce(VecPerParamSpace<ty::Region>) -> VecPerParamSpace<ty::Region>,\n     {\n         match self {\n             ErasedRegions => ErasedRegions,\n-            NonerasedRegions(r) => NonerasedRegions(op(r, a))\n+            NonerasedRegions(r) => NonerasedRegions(op(r))\n         }\n     }\n "}, {"sha": "e8a24876b18dcd9f4df8b1f2ef8bf388435a5a86", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -397,20 +397,20 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n /// Given an object of type `object_trait_ref`, returns the index of\n-/// the method `n_method` found in the trait `trait_def_id` (which\n-/// should be a supertrait of `object_trait_ref`) within the vtable\n-/// for `object_trait_ref`.\n+/// the method `method_def_id` (which should be part of a supertrait\n+/// of `object_trait_ref`) within the vtable for `object_trait_ref`.\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object_trait_ref: ty::PolyTraitRef<'tcx>,\n-                                               trait_def_id: ast::DefId,\n-                                               method_offset_in_trait: usize) -> usize {\n+                                               method_def_id: ast::DefId) -> usize {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until\n     // we find the trait the method came from, counting up the\n     // methods from them.\n     let mut method_count = 0;\n \n+    let trait_def_id = tcx.impl_or_trait_item(method_def_id).container().id();\n+\n     for bound_ref in transitive_bounds(tcx, &[object_trait_ref]) {\n         if bound_ref.def_id() == trait_def_id {\n             break;\n@@ -427,21 +427,24 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // count number of methods preceding the one we are selecting and\n     // add them to the total offset; skip over associated types.\n-    let trait_items = tcx.trait_items(trait_def_id);\n-    for trait_item in trait_items.iter().take(method_offset_in_trait) {\n+    for trait_item in &tcx.trait_items(trait_def_id)[..] {\n+        if trait_item.def_id() == method_def_id {\n+            // The item with the ID we were given really ought to be a method.\n+            assert!(match *trait_item {\n+                ty::MethodTraitItem(_) => true,\n+                _ => false\n+            });\n+\n+            return method_count;\n+        }\n         match *trait_item {\n             ty::MethodTraitItem(_) => method_count += 1,\n             _ => {}\n         }\n     }\n \n-    // the item at the offset we were given really ought to be a method\n-    assert!(match trait_items[method_offset_in_trait] {\n-        ty::MethodTraitItem(_) => true,\n-        _ => false\n-    });\n-\n-    method_count\n+    tcx.sess.bug(&format!(\"get_vtable_index_of_object_method: {:?} was not found\",\n+                          method_def_id));\n }\n \n pub enum TupleArgumentsFlag { Yes, No }"}, {"sha": "2eb1767c92831283a9a44c222aeb8f1908793500", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 63, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -30,7 +30,6 @@ pub use self::ImplOrTraitItem::*;\n pub use self::BoundRegion::*;\n pub use self::TypeVariants::*;\n pub use self::IntVarValue::*;\n-pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n \n pub use self::BuiltinBound::Send as BoundSend;\n@@ -330,7 +329,7 @@ impl IntTypeExt for attr::IntType {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n@@ -626,65 +625,33 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-#[derive(Clone)]\n-pub enum MethodOrigin<'tcx> {\n-    // fully statically resolved method\n-    MethodStatic(ast::DefId),\n-\n-    // method invoked on a type parameter with a bounded trait\n-    MethodTypeParam(MethodParam<'tcx>),\n-\n-    // method invoked on a trait instance\n-    MethodTraitObject(MethodObject<'tcx>),\n-\n-}\n-\n-// details for a method invoked with a receiver whose type is a type parameter\n-// with a bounded trait.\n-#[derive(Clone)]\n-pub struct MethodParam<'tcx> {\n-    // the precise trait reference that occurs as a bound -- this may\n-    // be a supertrait of what the user actually typed. Note that it\n-    // never contains bound regions; those regions should have been\n-    // instantiated with fresh variables at this point.\n-    pub trait_ref: ty::TraitRef<'tcx>,\n-\n-    // index of usize in the list of trait items. Note that this is NOT\n-    // the index into the vtable, because the list of trait items\n-    // includes associated types.\n-    pub method_num: usize,\n-\n-    /// The impl for the trait from which the method comes. This\n-    /// should only be used for certain linting/heuristic purposes\n-    /// since there is no guarantee that this is Some in every\n-    /// situation that it could/should be.\n-    pub impl_def_id: Option<ast::DefId>,\n-}\n-\n-// details for a method invoked with a receiver whose type is an object\n-#[derive(Clone)]\n-pub struct MethodObject<'tcx> {\n-    // the (super)trait containing the method to be invoked\n-    pub trait_ref: TraitRef<'tcx>,\n-\n-    // the actual base trait id of the object\n-    pub object_trait_id: ast::DefId,\n+#[derive(Clone, Copy, Debug)]\n+pub enum MethodOrigin {\n+    /// Inherent impl method call.\n+    Inherent,\n \n-    // index of the method to be invoked amongst the trait's items\n-    pub method_num: usize,\n+    /// Statically dispatched trait method call.\n+    /// The DefId is the impl for the trait from which the method comes.\n+    /// This should only be used for certain linting/heuristic purposes\n+    /// since there is no guarantee that this is Some in every situation\n+    /// that it could/should be.\n+    Trait(Option<ast::DefId>),\n \n-    // index into the actual runtime vtable.\n-    // the vtable is formed by concatenating together the method lists of\n-    // the base object trait and all supertraits; this is the index into\n-    // that vtable\n-    pub vtable_index: usize,\n+    /// Dynamically dispatched trait method call.\n+    /// The usize is the index into the actual runtime vtable.\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the index into\n+    /// that vtable.\n+    Object(usize)\n }\n \n #[derive(Clone, Debug)]\n pub struct MethodCallee<'tcx> {\n-    pub origin: MethodOrigin<'tcx>,\n+    /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n+    pub def_id: ast::DefId,\n+    pub origin: MethodOrigin,\n     pub ty: Ty<'tcx>,\n-    pub substs: subst::Substs<'tcx>\n+    pub substs: &'tcx subst::Substs<'tcx>\n }\n \n /// With method calls, we store some extra information in\n@@ -5592,11 +5559,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_item(&self, trait_did: ast::DefId, idx: usize) -> ImplOrTraitItem<'tcx> {\n-        let method_def_id = self.trait_item_def_ids(trait_did)[idx].def_id();\n-        self.impl_or_trait_item(method_def_id)\n-    }\n-\n     pub fn trait_items(&self, trait_did: ast::DefId) -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n         let mut trait_items = self.trait_items_cache.borrow_mut();\n         match trait_items.get(&trait_did).cloned() {\n@@ -6440,10 +6402,9 @@ impl<'tcx> ctxt<'tcx> {\n         let name = impl_item.name();\n         match self.trait_of_item(def_id) {\n             Some(trait_did) => {\n-                let trait_items = self.trait_items(trait_did);\n-                trait_items.iter()\n-                    .position(|m| m.name() == name)\n-                    .map(|idx| self.trait_item(trait_did, idx).id())\n+                self.trait_items(trait_did).iter()\n+                    .find(|item| item.name() == name)\n+                    .map(|item| item.id())\n             }\n             None => None\n         }"}, {"sha": "402f31fc770d909e010b98b6061215d2b2d2c3b9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -310,31 +310,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::MethodOrigin<'tcx> {\n-        match *self {\n-            ty::MethodStatic(def_id) => {\n-                ty::MethodStatic(def_id)\n-            }\n-            ty::MethodTypeParam(ref param) => {\n-                ty::MethodTypeParam(ty::MethodParam {\n-                    trait_ref: param.trait_ref.fold_with(folder),\n-                    method_num: param.method_num,\n-                    impl_def_id: param.impl_def_id,\n-                })\n-            }\n-            ty::MethodTraitObject(ref object) => {\n-                ty::MethodTraitObject(ty::MethodObject {\n-                    trait_ref: object.trait_ref.fold_with(folder),\n-                    object_trait_id: object.object_trait_id,\n-                    method_num: object.method_num,\n-                    vtable_index: object.vtable_index,\n-                })\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self"}, {"sha": "9d82b0c2aa8a0ef8ab08baa1b4d3c6b4ba2372a0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -494,35 +494,6 @@ impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::MethodOrigin<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::MethodStatic(def_id) => {\n-                write!(f, \"MethodStatic({:?})\", def_id)\n-            }\n-            ty::MethodTypeParam(ref p) => write!(f, \"{:?}\", p),\n-            ty::MethodTraitObject(ref p) => write!(f, \"{:?}\", p)\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::MethodParam<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MethodParam({:?},{})\",\n-               self.trait_ref,\n-               self.method_num)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::MethodObject<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MethodObject({:?},{},{})\",\n-               self.trait_ref,\n-               self.method_num,\n-               self.vtable_index)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut empty = true;"}, {"sha": "7d14bde8a92624a47589668a99f2202072a6a1ad", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -2000,35 +2000,30 @@ impl LintPass for UnconditionalRecursion {\n                 Some(m) => match m.origin {\n                     // There's no way to know if a method call via a\n                     // vtable is recursion, so we assume it's not.\n-                    ty::MethodTraitObject(_) => return false,\n+                    ty::MethodOrigin::Object(_) => return false,\n \n                     // This `did` refers directly to the method definition.\n-                    ty::MethodStatic(did) => did,\n-\n-                    // MethodTypeParam are methods from traits:\n+                    ty::MethodOrigin::Inherent => m.def_id,\n \n                     // The `impl ... for ...` of this method call\n                     // isn't known, e.g. it might be a default method\n                     // in a trait, so we get the def-id of the trait\n                     // method instead.\n-                    ty::MethodTypeParam(\n-                        ty::MethodParam { ref trait_ref, method_num, impl_def_id: None, }) => {\n-\n+                    ty::MethodOrigin::Trait(None) => {\n                         let on_self = m.substs.self_ty().map_or(false, |t| t.is_self());\n                         if !on_self {\n                             // we can only be recurring in a default\n                             // method if we're being called literally\n                             // on the `Self` type.\n                             return false\n                         }\n-\n-                        tcx.trait_item(trait_ref.def_id, method_num).def_id()\n+                        m.def_id\n                     }\n \n+\n                     // The `impl` is known, so we check that with a\n                     // special case:\n-                    ty::MethodTypeParam(\n-                        ty::MethodParam { impl_def_id: Some(impl_def_id), .. }) => {\n+                    ty::MethodOrigin::Trait(Some(impl_def_id)) => {\n \n                         let name = match tcx.map.expect_expr(id).node {\n                             ast::ExprMethodCall(ref sp_ident, _, _) => sp_ident.node,"}, {"sha": "cf0a24ed48c61d51eaf472d089aab1a40a47886a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -40,10 +40,6 @@ use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::{ExternalExports, ExportedItems, PublicItems};\n-use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n-use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use rustc::middle::ty::{MethodStaticClosure, MethodObject};\n-use rustc::middle::ty::MethodTraitObject;\n use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n@@ -53,7 +49,7 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit::{self, Visitor};\n \n-type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a def::ExportMap);\n+type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n \n /// Result of a checking operation - None => no errors were found. Some => an\n /// error and contains the span and message for reporting that error and\n@@ -848,17 +844,17 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n+    fn check_method(&mut self, span: Span, callee: &ty::MethodCallee,\n                     name: ast::Name) {\n-        match *origin {\n-            MethodStatic(method_id) => {\n-                self.check_static_method(span, method_id, name)\n+        match callee.origin {\n+            ty::MethodOrigin::Inherent => {\n+                self.check_static_method(span, callee.def_id, name)\n             }\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_ref.def_id,\n+            ty::MethodOrigin::Trait(_) | ty::MethodOrigin::Object(_) => {\n+                let method = self.tcx.impl_or_trait_item(callee.def_id);\n+                self.report_error(self.ensure_public(span, method.container().id(),\n                                                      None, \"source trait\"));\n             }\n         }\n@@ -902,7 +898,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n-                let method_call = MethodCall::expr(expr.id);\n+                let method_call = ty::MethodCall::expr(expr.id);\n                 match self.tcx.tables.borrow().method_map.get(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n@@ -911,7 +907,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                     Some(method) => {\n                         debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, &method.origin, ident.node.name);\n+                        self.check_method(expr.span, method, ident.node.name);\n                     }\n                 }\n             }"}, {"sha": "2236eda5527fe1b4dff24e5d737101ca1c4cb174", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -889,38 +889,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let method_map = &self.tcx.tables.borrow().method_map;\n         let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n-            ty::MethodStatic(def_id) => {\n-                // method invoked on an object with a concrete type (not a static method)\n-                let decl_id =\n-                    match self.tcx.trait_item_of_item(def_id) {\n-                        None => None,\n-                        Some(decl_id) => Some(decl_id.def_id()),\n-                    };\n-\n-                // This incantation is required if the method referenced is a\n-                // trait's default implementation.\n-                let def_id = match self.tcx.impl_or_trait_item(def_id) {\n-                    ty::MethodTraitItem(method) => {\n-                        method.provided_source.unwrap_or(def_id)\n-                    }\n-                    _ => self.sess\n-                             .span_bug(ex.span,\n-                                       \"save::process_method_call: non-method \\\n-                                        DefId in MethodStatic\"),\n-                };\n-                (Some(def_id), decl_id)\n-            }\n-            ty::MethodTypeParam(ref mp) => {\n-                // method invoked on a type parameter\n-                let trait_item = self.tcx.trait_item(mp.trait_ref.def_id,\n-                                                     mp.method_num);\n-                (None, Some(trait_item.def_id()))\n+            ty::MethodOrigin::Inherent => {\n+                (Some(method_callee.def_id), None)\n             }\n-            ty::MethodTraitObject(ref mo) => {\n-                // method invoked on a trait instance\n-                let trait_item = self.tcx.trait_item(mo.trait_ref.def_id,\n-                                                     mo.method_num);\n-                (None, Some(trait_item.def_id()))\n+            ty::MethodOrigin::Trait(_) |\n+            ty::MethodOrigin::Object(_) => {\n+                (None, Some(method_callee.def_id))\n             }\n         };\n         let sub_span = self.span.sub_span_for_meth_name(ex.span);"}, {"sha": "28c2277ed1d4f3aca11f83fe4714b50661339e4e", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -612,7 +612,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let method_call = MethodCall::expr(call_expr.id);\n     let method_ty = match bcx.tcx().tables.borrow().method_map.get(&method_call) {\n         Some(method) => match method.origin {\n-            ty::MethodTraitObject(_) => match method.ty.sty {\n+            ty::MethodOrigin::Object(_) => match method.ty.sty {\n                 ty::TyBareFn(_, ref fty) => {\n                     bcx.tcx().mk_fn(None, meth::opaque_method_ty(bcx.tcx(), fty))\n                 }"}, {"sha": "e7e2793fc7e9d28e2b8a1c35c8542df33658ccc7", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -894,10 +894,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprMethodCall(_, _, ref args) => {\n               let arg_vals = map_list(args);\n               let method_call = ty::MethodCall::expr(e.id);\n-              let method_did = match cx.tcx().tables.borrow().method_map[&method_call].origin {\n-                  ty::MethodStatic(did) => did,\n-                  _ => cx.sess().span_bug(e.span, \"expected a const method def\")\n-              };\n+              let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n               const_fn_call(cx, MethodCallKey(method_call),\n                             method_did, &arg_vals, param_substs)\n           }"}, {"sha": "3d727cf3347b674496f88c31912f8a13441f8297", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -107,33 +107,36 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    let (origin, method_ty) =\n+    let (method_id, origin, method_substs, method_ty) =\n         bcx.tcx()\n            .tables\n            .borrow()\n            .method_map\n            .get(&method_call)\n-           .map(|method| (method.origin.clone(), method.ty))\n+           .map(|method| (method.def_id, method.origin, method.substs, method.ty))\n            .unwrap();\n \n     match origin {\n-        ty::MethodStatic(did) => {\n-            debug!(\"trans_method_callee: static, {:?}\", did);\n+        ty::MethodOrigin::Inherent => {\n+            debug!(\"trans_method_callee: static, {:?}\", method_id);\n             Callee {\n                 bcx: bcx,\n                 data: Fn(callee::trans_fn_ref(bcx.ccx(),\n-                                              did,\n+                                              method_id,\n                                               MethodCallKey(method_call),\n                                               bcx.fcx.param_substs).val),\n             }\n         }\n \n-        ty::MethodTypeParam(ty::MethodParam {\n-            ref trait_ref,\n-            method_num,\n-            impl_def_id: _\n-        }) => {\n-            let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n+        ty::MethodOrigin::Trait(_) => {\n+            let method_item = bcx.tcx().impl_or_trait_item(method_id);\n+            let trait_def_id = method_item.container().id();\n+\n+            let trait_substs = method_substs.clone().method_to_trait();\n+            let trait_substs = bcx.tcx().mk_substs(trait_substs);\n+            let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n+\n+            let trait_ref = ty::Binder(bcx.monomorphize(&trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={:?} trait_ref={:?} trait_ref id={:?} substs={:?}\",\n                    method_call,\n@@ -146,12 +149,12 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             debug!(\"origin = {:?}\", origin);\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n-                                       trait_ref.def_id(),\n-                                       method_num,\n+                                       trait_def_id,\n+                                       method_id,\n                                        origin)\n         }\n \n-        ty::MethodTraitObject(ref mt) => {\n+        ty::MethodOrigin::Object(vtable_index) => {\n             let self_expr = match self_expr {\n                 Some(self_expr) => self_expr,\n                 None => {\n@@ -162,7 +165,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             trans_trait_callee(bcx,\n                                monomorphize_type(bcx, method_ty),\n-                               mt.vtable_index,\n+                               vtable_index,\n                                self_expr,\n                                arg_cleanup_scope)\n         }\n@@ -281,17 +284,11 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      callee_substs)\n         }\n         traits::VtableObject(ref data) => {\n-            let trait_item_def_ids =\n-                ccx.tcx().trait_item_def_ids(trait_id);\n-            let method_offset_in_trait =\n-                trait_item_def_ids.iter()\n-                                  .position(|item| item.def_id() == method_id)\n-                                  .unwrap();\n             let (llfn, ty) =\n                 trans_object_shim(ccx,\n                                   data.object_ty,\n                                   data.upcast_trait_ref.clone(),\n-                                  method_offset_in_trait);\n+                                  method_id);\n             immediate_rvalue(llfn, ty)\n         }\n         _ => {\n@@ -326,15 +323,15 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           trait_id: ast::DefId,\n-                                          n_method: usize,\n+                                          method_id: ast::DefId,\n                                           vtable: traits::Vtable<'tcx, ()>)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtable {\n         traits::VtableImpl(vtable_impl) => {\n             let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n-            let mname = match ccx.tcx().trait_item(trait_id, n_method) {\n+            let mname = match ccx.tcx().impl_or_trait_item(method_id) {\n                 ty::MethodTraitItem(method) => method.name,\n                 _ => {\n                     bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n@@ -382,7 +379,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let (llfn, _) = trans_object_shim(bcx.ccx(),\n                                               data.object_ty,\n                                               data.upcast_trait_ref.clone(),\n-                                              n_method);\n+                                              method_id);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableBuiltin(..) |\n@@ -539,21 +536,20 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n-pub fn trans_object_shim<'a, 'tcx>(\n+fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     object_ty: Ty<'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_offset_in_trait: usize)\n+    method_id: ast::DefId)\n     -> (ValueRef, Ty<'tcx>)\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n-    let trait_id = upcast_trait_ref.def_id();\n \n-    debug!(\"trans_object_shim(object_ty={:?}, upcast_trait_ref={:?}, method_offset_in_trait={})\",\n+    debug!(\"trans_object_shim(object_ty={:?}, upcast_trait_ref={:?}, method_id={:?})\",\n            object_ty,\n            upcast_trait_ref,\n-           method_offset_in_trait);\n+           method_id);\n \n     let object_trait_ref =\n         match object_ty.sty {\n@@ -572,7 +568,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     debug!(\"trans_object_shim: object_substs={:?}\", object_substs);\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n-    let method_ty = match tcx.trait_item(trait_id, method_offset_in_trait) {\n+    let method_ty = match tcx.impl_or_trait_item(method_id) {\n         ty::MethodTraitItem(method) => method,\n         _ => {\n             tcx.sess.bug(\"can't create a method shim for a non-method item\")\n@@ -624,8 +620,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let method_offset_in_vtable =\n         traits::get_vtable_index_of_object_method(bcx.tcx(),\n                                                   object_trait_ref.clone(),\n-                                                  trait_id,\n-                                                  method_offset_in_trait);\n+                                                  method_id);\n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n            method_offset_in_vtable);\n "}, {"sha": "5fa167c7929919aea0fa0a4cc5a5662041e0e051", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -15,8 +15,6 @@ use check::UnresolvedTypeAction;\n use middle::subst::{self};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use middle::ty::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n-                 MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -52,7 +50,7 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          unadjusted_self_ty: Ty<'tcx>,\n                          pick: probe::Pick<'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n-                         -> MethodCallee<'tcx>\n+                         -> ty::MethodCallee<'tcx>\n {\n     debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n            unadjusted_self_ty,\n@@ -77,7 +75,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                supplied_method_types: Vec<Ty<'tcx>>)\n-               -> MethodCallee<'tcx>\n+               -> ty::MethodCallee<'tcx>\n     {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n@@ -112,10 +110,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n         }));\n-        let callee = MethodCallee {\n+        let callee = ty::MethodCallee {\n+            def_id: pick.item.def_id(),\n             origin: method_origin,\n             ty: fty,\n-            substs: all_substs\n+            substs: self.tcx().mk_substs(all_substs)\n         };\n \n         // If this is an `&mut self` method, bias the receiver\n@@ -194,18 +193,20 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn fresh_receiver_substs(&mut self,\n                              self_ty: Ty<'tcx>,\n                              pick: &probe::Pick<'tcx>)\n-                             -> (subst::Substs<'tcx>, MethodOrigin<'tcx>)\n+                             -> (subst::Substs<'tcx>, ty::MethodOrigin)\n     {\n         match pick.kind {\n-            probe::InherentImplPick(impl_def_id) => {\n+            probe::InherentImplPick => {\n+                let impl_def_id = pick.item.container().id();\n                 assert!(self.tcx().impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n-                (impl_polytype.substs, MethodStatic(pick.item.def_id()))\n+                (impl_polytype.substs, ty::MethodOrigin::Inherent)\n             }\n \n-            probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n+            probe::ObjectPick => {\n+                let trait_def_id = pick.item.container().id();\n                 self.extract_trait_ref(self_ty, |this, object_ty, data| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n@@ -228,17 +229,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                            upcast_trait_ref,\n                            trait_def_id);\n                     let substs = upcast_trait_ref.substs.clone();\n-                    let origin = MethodTraitObject(MethodObject {\n-                        trait_ref: upcast_trait_ref,\n-                        object_trait_id: trait_def_id,\n-                        method_num: method_num,\n-                        vtable_index: vtable_index,\n-                    });\n-                    (substs, origin)\n+\n+                    let vtable_index =\n+                        traits::get_vtable_index_of_object_method(this.tcx(),\n+                                                                  original_poly_trait_ref,\n+                                                                  pick.item.def_id());\n+                    (substs, ty::MethodOrigin::Object(vtable_index))\n                 })\n             }\n \n-            probe::ExtensionImplPick(impl_def_id, method_num) => {\n+            probe::ExtensionImplPick(impl_def_id) => {\n                 // The method being invoked is the method as defined on the trait,\n                 // so return the substitutions from the trait. Consider:\n                 //\n@@ -254,13 +254,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         self.span,\n                         &impl_polytype.substs,\n                         &self.tcx().impl_trait_ref(impl_def_id).unwrap());\n-                let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n-                                                           method_num: method_num,\n-                                                           impl_def_id: Some(impl_def_id) });\n-                (impl_trait_ref.substs.clone(), origin)\n+                let substs = impl_trait_ref.substs.clone();\n+                (substs, ty::MethodOrigin::Trait(Some(impl_def_id)))\n             }\n \n-            probe::TraitPick(trait_def_id, method_num) => {\n+            probe::TraitPick => {\n+                let trait_def_id = pick.item.container().id();\n                 let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n@@ -272,23 +271,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  &trait_def.generics,\n                                                                  self.infcx().next_ty_var());\n \n-                let trait_ref =\n-                    ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone()));\n-                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num,\n-                                                           impl_def_id: None });\n-                (substs, origin)\n+                (substs, ty::MethodOrigin::Trait(None))\n             }\n \n-            probe::WhereClausePick(ref poly_trait_ref, method_num) => {\n+            probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n                 let trait_ref = self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref);\n                 let substs = trait_ref.substs.clone();\n-                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n-                                                           method_num: method_num,\n-                                                           impl_def_id: None });\n-                (substs, origin)\n+                (substs, ty::MethodOrigin::Trait(None))\n             }\n         }\n     }\n@@ -450,7 +441,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n     /// respectively.\n     fn fixup_derefs_on_method_receiver_if_necessary(&self,\n-                                                    method_callee: &MethodCallee) {\n+                                                    method_callee: &ty::MethodCallee) {\n         let sig = match method_callee.ty.sty {\n             ty::TyBareFn(_, ref f) => f.sig.clone(),\n             _ => return,\n@@ -570,7 +561,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n                         let result = check::try_index_step(\n                             self.fcx,\n-                            MethodCall::expr(expr.id),\n+                            ty::MethodCall::expr(expr.id),\n                             expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n@@ -589,7 +580,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n                         // if this is an overloaded deref, then re-evaluate with\n                         // a preference for mut\n-                        let method_call = MethodCall::expr(expr.id);\n+                        let method_call = ty::MethodCall::expr(expr.id);\n                         if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n                             check::try_overloaded_deref(\n                                 self.fcx,"}, {"sha": "95e60a5fbe19b847b0c4f02b75319b5270329178", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -74,8 +74,6 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type ItemIndex = usize; // just for doc purposes\n-\n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span: Span,\n@@ -204,14 +202,13 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n     let tcx = fcx.tcx();\n-    let (method_num, method_ty) = trait_item(tcx, trait_def_id, m_name)\n-            .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n-            .unwrap();\n+    let method_item = trait_item(tcx, trait_def_id, m_name).unwrap();\n+    let method_ty = method_item.as_opt_method().unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n-    debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={:?}\",\n-           method_num, method_ty);\n+    debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n+           method_item, method_ty);\n \n     // Instantiate late-bound regions and substitute the trait\n     // parameters into the method type to get the actual method type.\n@@ -309,11 +306,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     let callee = ty::MethodCallee {\n-        origin: ty::MethodTypeParam(ty::MethodParam{trait_ref: trait_ref.clone(),\n-                                                    method_num: method_num,\n-                                                    impl_def_id: None}),\n+        def_id: method_item.def_id(),\n+        origin: ty::MethodOrigin::Trait(None),\n         ty: fty,\n-        substs: trait_ref.substs.clone()\n+        substs: trait_ref.substs\n     };\n \n     debug!(\"callee = {:?}\", callee);\n@@ -332,14 +328,15 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n     let def_id = pick.item.def_id();\n     let mut lp = LastMod(AllPublic);\n+    let container_def_id = pick.item.container().id();\n     let provenance = match pick.kind {\n-        probe::InherentImplPick(impl_def_id) => {\n+        probe::InherentImplPick => {\n             if pick.item.vis() != ast::Public {\n                 lp = LastMod(DependsOn(def_id));\n             }\n-            def::FromImpl(impl_def_id)\n+            def::FromImpl(container_def_id)\n         }\n-        _ => def::FromTrait(pick.item.container().id())\n+        _ => def::FromTrait(container_def_id)\n     };\n     let def_result = match pick.item {\n         ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n@@ -352,19 +349,17 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n \n-/// Find item with name `item_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such item).\n+/// Find item with name `item_name` defined in `trait_def_id`\n+/// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     trait_def_id: ast::DefId,\n                     item_name: ast::Name)\n-                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n+                    -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let trait_items = tcx.trait_items(trait_def_id);\n-    trait_items\n-        .iter()\n-        .enumerate()\n-        .find(|&(_, ref item)| item.name() == item_name)\n-        .map(|(num, item)| (num, (*item).clone()))\n+    trait_items.iter()\n+               .find(|item| item.name() == item_name)\n+               .cloned()\n }\n \n fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "c43046ba0e71641d61252788fff7e8a48de0a953", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 103, "deletions": 165, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -10,7 +10,6 @@\n \n use super::MethodError;\n use super::NoMatchData;\n-use super::ItemIndex;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n@@ -70,15 +69,13 @@ struct Candidate<'tcx> {\n \n #[derive(Debug)]\n enum CandidateKind<'tcx> {\n-    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n+    InherentImplCandidate(subst::Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, ty::TraitRef<'tcx>,\n-                           subst::Substs<'tcx>, ItemIndex,\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>,\n                            /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n-    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n-    ProjectionCandidate(ast::DefId, ItemIndex),\n+    ObjectCandidate,\n+    TraitCandidate,\n+    WhereClauseCandidate(/* Trait */ ty::PolyTraitRef<'tcx>),\n }\n \n #[derive(Debug)]\n@@ -106,11 +103,11 @@ pub struct Pick<'tcx> {\n \n #[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n-    InherentImplPick(/* Impl */ ast::DefId),\n-    ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n-    ExtensionImplPick(/* Impl */ ast::DefId, ItemIndex),\n-    TraitPick(/* Trait */ ast::DefId, ItemIndex),\n-    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, ItemIndex),\n+    InherentImplPick,\n+    ExtensionImplPick(/* Impl */ ast::DefId),\n+    ObjectPick,\n+    TraitPick,\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n@@ -430,7 +427,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n             item: item,\n-            kind: InherentImplCandidate(impl_def_id, impl_substs, obligations)\n+            kind: InherentImplCandidate(impl_substs, obligations)\n         });\n     }\n \n@@ -440,8 +437,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n-        let tcx = self.tcx();\n-\n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `Self` type. An error will be reported by\n         // `enforce_object_limitations()` if the method refers to the\n@@ -450,23 +445,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, item, item_num| {\n+        self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n-            let vtable_index =\n-                traits::get_vtable_index_of_object_method(tcx,\n-                                                          trait_ref.clone(),\n-                                                          new_trait_ref.def_id,\n-                                                          item_num);\n-\n             let xform_self_ty = this.xform_self_ty(&item,\n                                                    new_trait_ref.self_ty(),\n                                                    new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n-                kind: ObjectCandidate(new_trait_ref.def_id, item_num, vtable_index)\n+                kind: ObjectCandidate\n             });\n         });\n     }\n@@ -499,7 +488,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item, item_num| {\n+        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n@@ -533,7 +522,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item,\n-                kind: WhereClauseCandidate(poly_trait_ref, item_num)\n+                kind: WhereClauseCandidate(poly_trait_ref)\n             });\n         });\n     }\n@@ -549,24 +538,23 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n             ty::ImplOrTraitItem<'tcx>,\n-            usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let (pos, item) = match trait_item(tcx,\n-                                               bound_trait_ref.def_id(),\n-                                               self.item_name) {\n+            let item = match trait_item(tcx,\n+                                        bound_trait_ref.def_id(),\n+                                        self.item_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n             if !self.has_applicable_self(&item) {\n                 self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n-                mk_cand(self, bound_trait_ref, item, pos);\n+                mk_cand(self, bound_trait_ref, item);\n             }\n         }\n     }\n@@ -607,14 +595,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n             self.tcx().trait_items(trait_def_id);\n-        let matching_index =\n+        let maybe_item =\n             trait_items.iter()\n-                       .position(|item| item.name() == self.item_name);\n-        let matching_index = match matching_index {\n+                       .find(|item| item.name() == self.item_name);\n+        let item = match maybe_item {\n             Some(i) => i,\n             None => { return Ok(()); }\n         };\n-        let ref item = (&*trait_items)[matching_index];\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         if !self.has_applicable_self(item) {\n@@ -623,29 +610,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return Ok(());\n         }\n \n-        self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n-                                                           item.clone(),\n-                                                           matching_index);\n+        self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n \n-        try!(self.assemble_closure_candidates(trait_def_id,\n-                                              item.clone(),\n-                                              matching_index));\n+        try!(self.assemble_closure_candidates(trait_def_id, item.clone()));\n \n-        self.assemble_projection_candidates(trait_def_id,\n-                                            item.clone(),\n-                                            matching_index);\n+        self.assemble_projection_candidates(trait_def_id, item.clone());\n \n-        self.assemble_where_clause_candidates(trait_def_id,\n-                                              item.clone(),\n-                                              matching_index);\n+        self.assemble_where_clause_candidates(trait_def_id, item.clone());\n \n         Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     item: ty::ImplOrTraitItem<'tcx>,\n-                                                     item_index: usize)\n+                                                     item: ty::ImplOrTraitItem<'tcx>)\n     {\n         let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n@@ -690,11 +668,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id,\n-                                             impl_trait_ref,\n-                                             impl_substs,\n-                                             item_index,\n-                                             obligations)\n+                kind: ExtensionImplCandidate(impl_def_id, impl_substs, obligations)\n             });\n         });\n     }\n@@ -717,8 +691,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n-                                   item: ty::ImplOrTraitItem<'tcx>,\n-                                   item_index: usize)\n+                                   item: ty::ImplOrTraitItem<'tcx>)\n                                    -> Result<(), MethodError<'tcx>>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -770,7 +743,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: ClosureCandidate(trait_def_id, item_index)\n+                kind: TraitCandidate\n             });\n         }\n \n@@ -779,16 +752,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n-                                      item: ty::ImplOrTraitItem<'tcx>,\n-                                      item_index: usize)\n+                                      item: ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={:?}, \\\n-               item={:?}, \\\n-               item_index={})\",\n+               item={:?})\",\n                trait_def_id,\n-               item,\n-               item_index);\n+               item);\n \n         for step in self.steps.iter() {\n             debug!(\"assemble_projection_candidates: step={:?}\",\n@@ -830,7 +800,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n                         item: item.clone(),\n-                        kind: ProjectionCandidate(trait_def_id, item_index)\n+                        kind: TraitCandidate\n                     });\n                 }\n             }\n@@ -839,8 +809,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n-                                        item: ty::ImplOrTraitItem<'tcx>,\n-                                        item_index: usize)\n+                                        item: ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n@@ -862,7 +831,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n-                kind: WhereClauseCandidate(poly_bound, item_index)\n+                kind: WhereClauseCandidate(poly_bound)\n             });\n         }\n     }\n@@ -1048,8 +1017,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         applicable_candidates.pop().map(|probe| {\n-            let pick = probe.to_unadjusted_pick();\n-            Ok(pick)\n+            Ok(probe.to_unadjusted_pick())\n         })\n     }\n \n@@ -1073,48 +1041,52 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n-            match probe.kind {\n-                InherentImplCandidate(impl_def_id, ref substs, ref ref_obligations) |\n-                ExtensionImplCandidate(impl_def_id, _, ref substs, _, ref ref_obligations) => {\n-                    let selcx = &mut traits::SelectionContext::new(self.infcx());\n-                    let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-\n-                    // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n-                    let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n-                    let traits::Normalized { value: impl_bounds,\n-                                             obligations: norm_obligations } =\n-                        traits::normalize(selcx, cause.clone(), &impl_bounds);\n-\n-                    // Convert the bounds into obligations.\n-                    let obligations =\n-                        traits::predicates_for_generics(cause.clone(),\n-                                                        &impl_bounds);\n-                    debug!(\"impl_obligations={:?}\", obligations);\n-\n-                    // Evaluate those obligations to see if they might possibly hold.\n-                    let mut all_true = true;\n-                    for o in obligations.iter()\n-                        .chain(norm_obligations.iter())\n-                        .chain(ref_obligations.iter()) {\n-                        if !selcx.evaluate_obligation(o) {\n-                            all_true = false;\n-                            if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n-                                possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n-                            }\n-                        }\n-                    }\n-                    all_true\n+            let (impl_def_id, substs, ref_obligations) = match probe.kind {\n+                InherentImplCandidate(ref substs, ref ref_obligations) => {\n+                    (probe.item.container().id(), substs, ref_obligations)\n+                }\n+\n+                ExtensionImplCandidate(impl_def_id, ref substs, ref ref_obligations) => {\n+                    (impl_def_id, substs, ref_obligations)\n                 }\n \n-                ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n-                ClosureCandidate(..) |\n+                TraitCandidate |\n                 WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n-                    true\n+                    return true;\n+                }\n+            };\n+\n+            let selcx = &mut traits::SelectionContext::new(self.infcx());\n+            let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+\n+            // Check whether the impl imposes obligations we have to worry about.\n+            let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n+            let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n+            let traits::Normalized { value: impl_bounds,\n+                                        obligations: norm_obligations } =\n+                traits::normalize(selcx, cause.clone(), &impl_bounds);\n+\n+            // Convert the bounds into obligations.\n+            let obligations =\n+                traits::predicates_for_generics(cause.clone(),\n+                                                &impl_bounds);\n+            debug!(\"impl_obligations={:?}\", obligations);\n+\n+            // Evaluate those obligations to see if they might possibly hold.\n+            let mut all_true = true;\n+            for o in obligations.iter()\n+                .chain(norm_obligations.iter())\n+                .chain(ref_obligations.iter()) {\n+                if !selcx.evaluate_obligation(o) {\n+                    all_true = false;\n+                    if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n+                        possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n+                    }\n                 }\n             }\n+            all_true\n         })\n     }\n \n@@ -1139,20 +1111,19 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                          probes: &[&Candidate<'tcx>])\n                                          -> Option<Pick<'tcx>> {\n         // Do all probes correspond to the same trait?\n-        let trait_data = match probes[0].to_trait_data() {\n-            Some(data) => data,\n-            None => return None,\n-        };\n-        if probes[1..].iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n+        let container = probes[0].item.container();\n+        match container {\n+            ty::TraitContainer(_) => {}\n+            ty::ImplContainer(_) => return None\n+        }\n+        if probes[1..].iter().any(|p| p.item.container() != container) {\n             return None;\n         }\n \n         // If so, just use this trait and call it a day.\n-        let (trait_def_id, item_num) = trait_data;\n-        let item = probes[0].item.clone();\n         Some(Pick {\n-            item: item,\n-            kind: TraitPick(trait_def_id, item_num),\n+            item: probes[0].item.clone(),\n+            kind: TraitPick,\n             autoderefs: 0,\n             autoref: None,\n             unsize: None\n@@ -1317,51 +1288,40 @@ fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .find(|item| item.name() == item_name)\n }\n \n-/// Find item with name `item_name` defined in `trait_def_id` and return it,\n-/// along with its index (or `None`, if no such item).\n+/// Find item with name `item_name` defined in `trait_def_id`\n+/// and return it, or `None`, if no such item.\n fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     trait_def_id: ast::DefId,\n                     item_name: ast::Name)\n-                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n+                    -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let trait_items = tcx.trait_items(trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n-    trait_items\n-        .iter()\n-        .enumerate()\n-        .find(|&(_, ref item)| item.name() == item_name)\n-        .map(|(num, ref item)| (num, (*item).clone()))\n+    trait_items.iter()\n+               .find(|item| item.name() == item_name)\n+               .cloned()\n }\n \n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n             item: self.item.clone(),\n             kind: match self.kind {\n-                InherentImplCandidate(def_id, _, _) => {\n-                    InherentImplPick(def_id)\n-                }\n-                ObjectCandidate(def_id, item_num, real_index) => {\n-                    ObjectPick(def_id, item_num, real_index)\n-                }\n-                ExtensionImplCandidate(def_id, _, _, index, _) => {\n-                    ExtensionImplPick(def_id, index)\n+                InherentImplCandidate(_, _) => InherentImplPick,\n+                ExtensionImplCandidate(def_id, _, _) => {\n+                    ExtensionImplPick(def_id)\n                 }\n-                ClosureCandidate(trait_def_id, index) => {\n-                    TraitPick(trait_def_id, index)\n-                }\n-                WhereClauseCandidate(ref trait_ref, index) => {\n+                ObjectCandidate => ObjectPick,\n+                TraitCandidate => TraitPick,\n+                WhereClauseCandidate(ref trait_ref) => {\n                     // Only trait derived from where-clauses should\n                     // appear here, so they should not contain any\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n                     assert!(!trait_ref.substs().types.needs_infer());\n \n-                    WhereClausePick((*trait_ref).clone(), index)\n-                }\n-                ProjectionCandidate(def_id, index) => {\n-                    TraitPick(def_id, index)\n+                    WhereClausePick(trait_ref.clone())\n                 }\n             },\n             autoderefs: 0,\n@@ -1372,35 +1332,13 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n-            InherentImplCandidate(def_id, _, _) => ImplSource(def_id),\n-            ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n-            ExtensionImplCandidate(def_id, _, _, _, _) => ImplSource(def_id),\n-            ClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n-            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n-            ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n-        }\n-    }\n-\n-    fn to_trait_data(&self) -> Option<(ast::DefId, ItemIndex)> {\n-        match self.kind {\n-            InherentImplCandidate(..) => {\n-                None\n-            }\n-            ObjectCandidate(trait_def_id, item_num, _) => {\n-                Some((trait_def_id, item_num))\n-            }\n-            ClosureCandidate(trait_def_id, item_num) => {\n-                Some((trait_def_id, item_num))\n-            }\n-            ExtensionImplCandidate(_, ref trait_ref, _, item_num, _) => {\n-                Some((trait_ref.def_id, item_num))\n-            }\n-            WhereClauseCandidate(ref trait_ref, item_num) => {\n-                Some((trait_ref.def_id(), item_num))\n-            }\n-            ProjectionCandidate(trait_def_id, item_num) => {\n-                Some((trait_def_id, item_num))\n+            InherentImplCandidate(_, _) => {\n+                ImplSource(self.item.container().id())\n             }\n+            ExtensionImplCandidate(def_id, _, _) => ImplSource(def_id),\n+            ObjectCandidate |\n+            TraitCandidate |\n+            WhereClauseCandidate(_) => TraitSource(self.item.container().id()),\n         }\n     }\n }"}, {"sha": "4d86a4f7c70ff159fe7425cbb23d5bcd0d4e971c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -203,7 +203,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                impl_ty);\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n-                    let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n+                    let item = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n                     let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n                     span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in the trait `{}`\","}, {"sha": "8ed99ac9162494f9131e16fa12aa54726b7b429d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70365ed911d418c22d2d9e6a972929b946b6a3ac/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=70365ed911d418c22d2d9e6a972929b946b6a3ac", "patch": "@@ -302,9 +302,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                        method_call,\n                        method);\n                 let new_method = MethodCallee {\n-                    origin: self.resolve(&method.origin, reason),\n+                    def_id: method.def_id,\n+                    origin: method.origin,\n                     ty: self.resolve(&method.ty, reason),\n-                    substs: self.resolve(&method.substs, reason),\n+                    substs: self.tcx().mk_substs(self.resolve(method.substs, reason)),\n                 };\n \n                 Some(new_method)"}]}