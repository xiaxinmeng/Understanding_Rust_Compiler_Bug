{"sha": "28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YmNlZjg1ZTQwMmEzMmNmNDRiNzQwZjEyOGU1ZjliYmQyMWMwYTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T04:16:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-16T18:41:27Z"}, "message": "libserialize: Remove all uses of `~str` from `libserialize`.\n\nHad to make `struct Tm` in `libtime` not serializable for now.", "tree": {"sha": "15b222467760e8473355abe128dc7d8cdccca2b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15b222467760e8473355abe128dc7d8cdccca2b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "html_url": "https://github.com/rust-lang/rust/commit/28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67e39a8e7686bd33b9a8fbfc926f619029a33ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e39a8e7686bd33b9a8fbfc926f619029a33ac0", "html_url": "https://github.com/rust-lang/rust/commit/67e39a8e7686bd33b9a8fbfc926f619029a33ac0"}], "stats": {"total": 591, "additions": 316, "deletions": 275}, "files": [{"sha": "238d6ae3d6def79ea13bcee924d517e45d7afdb1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -364,7 +364,7 @@ fn json_input(input: &str) -> Result<Output, StrBuf> {\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n-            match obj.pop(&\"schema\".to_owned()) {\n+            match obj.pop(&\"schema\".to_strbuf()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n                         return Err(format_strbuf!(\n@@ -375,7 +375,7 @@ fn json_input(input: &str) -> Result<Output, StrBuf> {\n                 Some(..) => return Err(\"malformed json\".to_strbuf()),\n                 None => return Err(\"expected a schema version\".to_strbuf()),\n             }\n-            let krate = match obj.pop(&\"crate\".to_str()) {\n+            let krate = match obj.pop(&\"crate\".to_strbuf()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()\n@@ -404,13 +404,14 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"plugins\": { output of plugins ... }\n     // }\n     let mut json = box collections::TreeMap::new();\n-    json.insert(\"schema\".to_owned(), json::String(SCHEMA_VERSION.to_owned()));\n+    json.insert(\"schema\".to_strbuf(),\n+                json::String(SCHEMA_VERSION.to_strbuf()));\n     let plugins_json = box res.move_iter()\n                               .filter_map(|opt| {\n                                   match opt {\n                                       None => None,\n                                       Some((string, json)) => {\n-                                          Some((string.to_owned(), json))\n+                                          Some((string.to_strbuf(), json))\n                                       }\n                                   }\n                               }).collect();\n@@ -423,15 +424,15 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_strbuf()\n     };\n-    let crate_json = match json::from_str(crate_json_str) {\n+    let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n         Err(e) => fail!(\"Rust generated JSON is invalid: {:?}\", e)\n     };\n \n-    json.insert(\"crate\".to_owned(), crate_json);\n-    json.insert(\"plugins\".to_owned(), json::Object(plugins_json));\n+    json.insert(\"crate\".to_strbuf(), crate_json);\n+    json.insert(\"plugins\".to_strbuf(), json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n     try!(json::Object(json).to_writer(&mut file));"}, {"sha": "2d938bc9ae77eceaa01b02bfb00c4f9450f88d9a", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -54,7 +54,7 @@ static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n pub trait ToBase64 {\n     /// Converts the value of `self` to a base64 value following the specified\n     /// format configuration, returning the owned string.\n-    fn to_base64(&self, config: Config) -> ~str;\n+    fn to_base64(&self, config: Config) -> StrBuf;\n }\n \n impl<'a> ToBase64 for &'a [u8] {\n@@ -73,7 +73,7 @@ impl<'a> ToBase64 for &'a [u8] {\n      * }\n      * ```\n      */\n-    fn to_base64(&self, config: Config) -> ~str {\n+    fn to_base64(&self, config: Config) -> StrBuf {\n         let bytes = match config.char_set {\n             Standard => STANDARD_CHARS,\n             UrlSafe => URLSAFE_CHARS\n@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_owned()\n+            str::raw::from_utf8(v.as_slice()).to_strbuf()\n         }\n     }\n }\n@@ -195,7 +195,7 @@ impl<'a> FromBase64 for &'a str {\n      * fn main () {\n      *     let hello_str = bytes!(\"Hello, World\").to_base64(STANDARD);\n      *     println!(\"base64 output: {}\", hello_str);\n-     *     let res = hello_str.from_base64();\n+     *     let res = hello_str.as_slice().from_base64();\n      *     if res.is_ok() {\n      *       let opt_bytes = StrBuf::from_utf8(res.unwrap());\n      *       if opt_bytes.is_ok() {\n@@ -267,34 +267,35 @@ mod tests {\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_owned());\n-        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_owned());\n-        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_owned());\n-        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_owned());\n-        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_owned());\n-        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_owned());\n-        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_owned());\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_strbuf());\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_strbuf());\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_strbuf());\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_strbuf());\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_strbuf());\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_strbuf());\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_strbuf());\n     }\n \n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n-                .contains(\"\\r\\n\"));\n+                              .as_slice()\n+                              .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n-                   \"Zm9v\\r\\nYmFy\".to_owned());\n+                   \"Zm9v\\r\\nYmFy\".to_strbuf());\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_owned());\n-        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_owned());\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_strbuf());\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_strbuf());\n     }\n \n     #[test]\n     fn test_to_base64_url_safe() {\n-        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_owned());\n-        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_owned());\n+        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_strbuf());\n+        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_strbuf());\n     }\n \n     #[test]\n@@ -339,7 +340,12 @@ mod tests {\n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap().as_slice(),\n+            assert_eq!(v.as_slice()\n+                        .to_base64(STANDARD)\n+                        .as_slice()\n+                        .from_base64()\n+                        .unwrap()\n+                        .as_slice(),\n                        v.as_slice());\n         }\n     }\n@@ -360,7 +366,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_base64(STANDARD);\n         b.iter(|| {\n-            sb.from_base64().unwrap();\n+            sb.as_slice().from_base64().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "104efbeab0a3cd61ff45459399c8ca3a3311af93", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -34,8 +34,8 @@ impl<'doc> Doc<'doc> {\n         str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n     }\n \n-    pub fn as_str(&self) -> ~str {\n-        self.as_str_slice().to_owned()\n+    pub fn as_str(&self) -> StrBuf {\n+        self.as_str_slice().to_strbuf()\n     }\n }\n \n@@ -80,7 +80,7 @@ pub enum EbmlEncoderTag {\n #[deriving(Show)]\n pub enum Error {\n     IntTooBig(uint),\n-    Expected(~str),\n+    Expected(StrBuf),\n     IoError(io::IoError)\n }\n // --------------------------------------\n@@ -312,7 +312,10 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        return Err(Expected(format!(\"Expected label {} but found {}\", lbl, str)));\n+                        return Err(Expected(format_strbuf!(\"Expected label \\\n+                                                            {} but found {}\",\n+                                                           lbl,\n+                                                           str)));\n                     }\n                 }\n             }\n@@ -322,7 +325,8 @@ pub mod reader {\n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n+                return Err(Expected(format_strbuf!(\"no more documents in \\\n+                                                    current node!\")));\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n@@ -334,12 +338,18 @@ pub mod reader {\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                       exp_tag, r_tag)));\n+                return Err(Expected(format_strbuf!(\"expected EBML doc with \\\n+                                                    tag {:?} but found tag \\\n+                                                    {:?}\",\n+                                                   exp_tag,\n+                                                   r_tag)));\n             }\n             if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n-                      r_doc.end, self.parent.end)));\n+                return Err(Expected(format_strbuf!(\"invalid EBML, child \\\n+                                                    extends to {:#x}, parent \\\n+                                                    to {:#x}\",\n+                                                   r_doc.end,\n+                                                   self.parent.end)));\n             }\n             self.pos = r_doc.end;\n             Ok(r_doc)\n@@ -433,7 +443,7 @@ pub mod reader {\n         fn read_char(&mut self) -> DecodeResult<char> {\n             Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n         }\n-        fn read_str(&mut self) -> DecodeResult<~str> {\n+        fn read_str(&mut self) -> DecodeResult<StrBuf> {\n             Ok(try!(self.next_doc(EsStr)).as_str())\n         }\n \n@@ -570,7 +580,10 @@ pub mod reader {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n+                        _ => {\n+                            Err(Expected(format_strbuf!(\"Expected None or \\\n+                                                         Some\")))\n+                        }\n                     }\n                 })\n             })"}, {"sha": "3b8500753cb3f5170b7d3120152395413f9ddece", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -16,7 +16,7 @@ use std::fmt;\n pub trait ToHex {\n     /// Converts the value of `self` to a hex value, returning the owned\n     /// string.\n-    fn to_hex(&self) -> ~str;\n+    fn to_hex(&self) -> StrBuf;\n }\n \n static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n@@ -37,15 +37,15 @@ impl<'a> ToHex for &'a [u8] {\n      * }\n      * ```\n      */\n-    fn to_hex(&self) -> ~str {\n+    fn to_hex(&self) -> StrBuf {\n         let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n             v.push(CHARS[(byte >> 4) as uint]);\n             v.push(CHARS[(byte & 0xf) as uint]);\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_owned()\n+            str::raw::from_utf8(v.as_slice()).to_strbuf()\n         }\n     }\n }\n@@ -94,7 +94,7 @@ impl<'a> FromHex for &'a str {\n      * fn main () {\n      *     let hello_str = \"Hello, World\".as_bytes().to_hex();\n      *     println!(\"{}\", hello_str);\n-     *     let bytes = hello_str.from_hex().unwrap();\n+     *     let bytes = hello_str.as_slice().from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n      *     let result_str = StrBuf::from_utf8(bytes).unwrap();\n      *     println!(\"{}\", result_str);\n@@ -143,7 +143,7 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_owned());\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_strbuf());\n     }\n \n     #[test]\n@@ -174,7 +174,8 @@ mod tests {\n     #[test]\n     pub fn test_to_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n+            assert_eq!([i as u8].to_hex(),\n+                       format_strbuf!(\"{:02x}\", i as uint));\n         }\n     }\n \n@@ -202,7 +203,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_hex();\n         b.iter(|| {\n-            sb.from_hex().unwrap();\n+            sb.as_slice().from_hex().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "422914b1405706bf60ff1d9681890c7009ca18c5", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 232, "deletions": 204, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -64,11 +64,11 @@ use serialize::{json, Encodable};\n \n  #[deriving(Encodable)]\n  pub struct TestStruct   {\n-    data_str: ~str,\n+    data_str: StrBuf,\n  }\n \n fn main() {\n-    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_owned()};\n+    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_strbuf()};\n     let mut m = io::MemWriter::new();\n     {\n         let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n@@ -81,12 +81,12 @@ fn main() {\n ```\n \n Two wrapper functions are provided to encode a Encodable object\n-into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+into a string (StrBuf) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n \n ```rust\n use serialize::json;\n-let to_encode_object = \"example of string to encode\".to_owned();\n-let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+let to_encode_object = \"example of string to encode\".to_strbuf();\n+let encoded_str: StrBuf = json::Encoder::str_encode(&to_encode_object);\n ```\n \n JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n@@ -108,22 +108,22 @@ use collections::TreeMap;\n \n pub struct MyStruct  {\n     attr1: u8,\n-    attr2: ~str,\n+    attr2: StrBuf,\n }\n \n impl ToJson for MyStruct {\n     fn to_json( &self ) -> json::Json {\n         let mut d = box TreeMap::new();\n-        d.insert(\"attr1\".to_owned(), self.attr1.to_json());\n-        d.insert(\"attr2\".to_owned(), self.attr2.to_json());\n+        d.insert(\"attr1\".to_strbuf(), self.attr1.to_json());\n+        d.insert(\"attr2\".to_strbuf(), self.attr2.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_owned()};\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_strbuf()};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: ~str = tjson.to_str();\n+    let json_str: StrBuf = tjson.to_str().into_strbuf();\n }\n ```\n \n@@ -136,13 +136,13 @@ use serialize::{json, Decodable};\n #[deriving(Decodable)]\n pub struct MyStruct  {\n      attr1: u8,\n-     attr2: ~str,\n+     attr2: StrBuf,\n }\n \n fn main() {\n-    let json_str_to_decode: ~str =\n-            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_owned();\n-    let json_object = json::from_str(json_str_to_decode);\n+    let json_str_to_decode: StrBuf =\n+            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_strbuf();\n+    let json_object = json::from_str(json_str_to_decode.as_slice());\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n         Ok(v) => v,\n@@ -165,20 +165,20 @@ use serialize::{json, Encodable, Decodable};\n  #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n  pub struct TestStruct1  {\n     data_int: u8,\n-    data_str: ~str,\n+    data_str: StrBuf,\n     data_vector: Vec<u8>,\n  }\n \n // To serialize use the `json::str_encode` to encode an object in a string.\n // It calls the generated `Encodable` impl.\n fn main() {\n     let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:vec![2,3,4,5]};\n-    let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+         {data_int: 1, data_str:\"toto\".to_strbuf(), data_vector:vec![2,3,4,5]};\n+    let encoded_str: StrBuf = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n \n-    let json_object = json::from_str(encoded_str);\n+    let json_object = json::from_str(encoded_str.as_slice());\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded1: TestStruct1 = Decodable::decode(&mut decoder).unwrap(); // create the final object\n }\n@@ -200,31 +200,32 @@ use collections::TreeMap;\n #[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n pub struct TestStruct1  {\n     data_int: u8,\n-    data_str: ~str,\n+    data_str: StrBuf,\n     data_vector: Vec<u8>,\n }\n \n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n         let mut d = box TreeMap::new();\n-        d.insert(\"data_int\".to_owned(), self.data_int.to_json());\n-        d.insert(\"data_str\".to_owned(), self.data_str.to_json());\n-        d.insert(\"data_vector\".to_owned(), self.data_vector.to_json());\n+        d.insert(\"data_int\".to_strbuf(), self.data_int.to_json());\n+        d.insert(\"data_str\".to_strbuf(), self.data_str.to_json());\n+        d.insert(\"data_vector\".to_strbuf(), self.data_vector.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n     // Serialization using our impl of to_json\n \n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_owned(),\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_strbuf(),\n                                           data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: ~str = tjson.to_str();\n+    let json_str: StrBuf = tjson.to_str().into_strbuf();\n \n     // Deserialize like before.\n \n-    let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n+    let mut decoder =\n+        json::Decoder::new(json::from_str(json_str.as_slice()).unwrap());\n     // create the final object\n     let decoded2: TestStruct1 = Decodable::decode(&mut decoder).unwrap();\n }\n@@ -251,15 +252,15 @@ use collections::{HashMap, TreeMap};\n #[deriving(Clone, Eq)]\n pub enum Json {\n     Number(f64),\n-    String(~str),\n+    String(StrBuf),\n     Boolean(bool),\n     List(List),\n     Object(Box<Object>),\n     Null,\n }\n \n pub type List = Vec<Json>;\n-pub type Object = TreeMap<~str, Json>;\n+pub type Object = TreeMap<StrBuf, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, Eq)]\n@@ -295,9 +296,9 @@ pub type BuilderError = ParserError;\n #[deriving(Clone, Eq, Show)]\n pub enum DecoderError {\n     ParseError(ParserError),\n-    ExpectedError(~str, ~str),\n-    MissingFieldError(~str),\n-    UnknownVariantError(~str),\n+    ExpectedError(StrBuf, StrBuf),\n+    MissingFieldError(StrBuf),\n+    UnknownVariantError(StrBuf),\n }\n \n /// Returns a readable error string for a given error code.\n@@ -336,7 +337,7 @@ fn io_error_to_error(io: io::IoError) -> ParserError {\n pub type EncodeResult = io::IoResult<()>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-fn escape_str(s: &str) -> ~str {\n+fn escape_str(s: &str) -> StrBuf {\n     let mut escaped = StrBuf::from_str(\"\\\"\");\n     for c in s.chars() {\n         match c {\n@@ -351,15 +352,15 @@ fn escape_str(s: &str) -> ~str {\n         }\n     };\n     escaped.push_char('\"');\n-    escaped.into_owned()\n+    escaped\n }\n \n-fn spaces(n: uint) -> ~str {\n+fn spaces(n: uint) -> StrBuf {\n     let mut ss = StrBuf::new();\n     for _ in range(0, n) {\n         ss.push_str(\" \");\n     }\n-    return ss.into_owned();\n+    return ss\n }\n \n /// A structure for implementing serialization to JSON.\n@@ -387,9 +388,12 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json str\n-    pub fn str_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~str  {\n+    pub fn str_encode<T:Encodable<Encoder<'a>,\n+                        io::IoError>>(\n+                      to_encode_object: &T)\n+                      -> StrBuf {\n         let buff = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8(buff.as_slice()).unwrap().to_owned()\n+        str::from_utf8(buff.as_slice()).unwrap().to_strbuf()\n     }\n }\n \n@@ -826,15 +830,15 @@ impl Json {\n     }\n \n     /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> ~str {\n+    pub fn to_pretty_str(&self) -> StrBuf {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8(s.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(s.unwrap().as_slice()).unwrap().to_strbuf()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &~str) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &StrBuf) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find(key),\n             _ => None\n@@ -844,7 +848,7 @@ impl Json {\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&~str]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&StrBuf]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -858,7 +862,7 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &~str) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &StrBuf) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n                 match map.find(key) {\n@@ -973,7 +977,7 @@ pub enum JsonEvent {\n     ListEnd,\n     BooleanValue(bool),\n     NumberValue(f64),\n-    StringValue(~str),\n+    StringValue(StrBuf),\n     NullValue,\n     Error(ParserError),\n }\n@@ -1091,7 +1095,7 @@ impl Stack {\n     }\n \n     // Used by Parser to insert Key elements at the top of the stack.\n-    fn push_key(&mut self, key: ~str) {\n+    fn push_key(&mut self, key: StrBuf) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n         for c in key.as_bytes().iter() {\n             self.str_buffer.push(*c);\n@@ -1378,7 +1382,7 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(n)\n     }\n \n-    fn parse_str(&mut self) -> Result<~str, ParserError> {\n+    fn parse_str(&mut self) -> Result<StrBuf, ParserError> {\n         let mut escape = false;\n         let mut res = StrBuf::new();\n \n@@ -1462,7 +1466,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 match self.ch {\n                     Some('\"') => {\n                         self.bump();\n-                        return Ok(res.into_owned());\n+                        return Ok(res);\n                     },\n                     Some(c) => res.push_char(c),\n                     None => unreachable!()\n@@ -1738,7 +1742,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(NumberValue(n)) => { Ok(Number(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n-                let mut temp = \"\".to_owned();\n+                let mut temp = StrBuf::new();\n                 swap(s, &mut temp);\n                 Ok(String(temp))\n             }\n@@ -1780,7 +1784,7 @@ impl<T: Iterator<char>> Builder<T> {\n                 _ => {}\n             }\n             let key = match self.parser.stack().top() {\n-                Some(Key(k)) => { k.into_owned() }\n+                Some(Key(k)) => { k.to_strbuf() }\n                 _ => { fail!(\"invalid state\"); }\n             };\n             match self.build_value() {\n@@ -1801,10 +1805,10 @@ pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n         Err(e) => return Err(io_error_to_error(e))\n     };\n     let s = match str::from_utf8(contents.as_slice()) {\n-        Some(s) => s.to_owned(),\n+        Some(s) => s.to_strbuf(),\n         None => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n-    let mut builder = Builder::new(s.chars());\n+    let mut builder = Builder::new(s.as_slice().chars());\n     builder.build()\n }\n \n@@ -1838,13 +1842,17 @@ macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n             Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_owned(), format!(\"{}\", other)))\n+            other => Err(ExpectedError(\"Null\".to_strbuf(),\n+                                       format_strbuf!(\"{}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n         match $e {\n             $t(v) => Ok(v),\n-            other => Err(ExpectedError(stringify!($t).to_owned(), format!(\"{}\", other)))\n+            other => {\n+                Err(ExpectedError(stringify!($t).to_strbuf(),\n+                                  format_strbuf!(\"{}\", other)))\n+            }\n         }\n     })\n )\n@@ -1881,9 +1889,12 @@ impl ::Decoder<DecoderError> for Decoder {\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec..\n-                Ok(FromStr::from_str(s).unwrap())\n+                Ok(FromStr::from_str(s.as_slice()).unwrap())\n             },\n-            value => Err(ExpectedError(\"Number\".to_owned(), format!(\"{}\", value)))\n+            value => {\n+                Err(ExpectedError(\"Number\".to_strbuf(),\n+                                  format_strbuf!(\"{}\", value)))\n+            }\n         }\n     }\n \n@@ -1892,17 +1903,18 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n         {\n-            let mut it = s.chars();\n+            let mut it = s.as_slice().chars();\n             match (it.next(), it.next()) {\n                 // exactly one character\n                 (Some(c), None) => return Ok(c),\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_owned(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_strbuf(),\n+                          format_strbuf!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<~str> {\n+    fn read_str(&mut self) -> DecodeResult<StrBuf> {\n         debug!(\"read_str\");\n         Ok(try!(expect!(self.pop(), String)))\n     }\n@@ -1922,25 +1934,41 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n-                let n = match o.pop(&\"variant\".to_owned()) {\n+                let n = match o.pop(&\"variant\".to_strbuf()) {\n                     Some(String(s)) => s,\n-                    Some(val) => return Err(ExpectedError(\"String\".to_owned(), format!(\"{}\", val))),\n-                    None => return Err(MissingFieldError(\"variant\".to_owned()))\n+                    Some(val) => {\n+                        return Err(ExpectedError(\"String\".to_strbuf(),\n+                                                 format_strbuf!(\"{}\", val)))\n+                    }\n+                    None => {\n+                        return Err(MissingFieldError(\"variant\".to_strbuf()))\n+                    }\n                 };\n-                match o.pop(&\"fields\".to_owned()) {\n+                match o.pop(&\"fields\".to_strbuf()) {\n                     Some(List(l)) => {\n                         for field in l.move_iter().rev() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    Some(val) => return Err(ExpectedError(\"List\".to_owned(), format!(\"{}\", val))),\n-                    None => return Err(MissingFieldError(\"fields\".to_owned()))\n+                    Some(val) => {\n+                        return Err(ExpectedError(\"List\".to_strbuf(),\n+                                                 format_strbuf!(\"{}\", val)))\n+                    }\n+                    None => {\n+                        return Err(MissingFieldError(\"fields\".to_strbuf()))\n+                    }\n                 }\n                 n\n             }\n-            json => return Err(ExpectedError(\"String or Object\".to_owned(), format!(\"{}\", json)))\n+            json => {\n+                return Err(ExpectedError(\"String or Object\".to_strbuf(),\n+                                         format_strbuf!(\"{}\", json)))\n+            }\n         };\n-        let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n+        let idx = match names.iter()\n+                             .position(|n| {\n+                                 str::eq_slice(*n, name.as_slice())\n+                             }) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -1990,8 +2018,8 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n-        let value = match obj.pop(&name.to_owned()) {\n-            None => return Err(MissingFieldError(name.to_owned())),\n+        let value = match obj.pop(&name.to_strbuf()) {\n+            None => return Err(MissingFieldError(name.to_strbuf())),\n             Some(json) => {\n                 self.stack.push(json);\n                 try!(f(self))\n@@ -2199,12 +2227,8 @@ impl ToJson for bool {\n     fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n-impl ToJson for ~str {\n-    fn to_json(&self) -> Json { String((*self).clone()) }\n-}\n-\n impl ToJson for StrBuf {\n-    fn to_json(&self) -> Json { String((*self).as_slice().into_owned()) }\n+    fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n@@ -2235,7 +2259,7 @@ impl<A:ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for TreeMap<~str, A> {\n+impl<A:ToJson> ToJson for TreeMap<StrBuf, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2245,7 +2269,7 @@ impl<A:ToJson> ToJson for TreeMap<~str, A> {\n     }\n }\n \n-impl<A:ToJson> ToJson for HashMap<~str, A> {\n+impl<A:ToJson> ToJson for HashMap<StrBuf, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2291,22 +2315,22 @@ mod tests {\n     #[deriving(Eq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n-        Frog(~str, int)\n+        Frog(StrBuf, int)\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: Vec<~str>,\n+        c: Vec<StrBuf>,\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }\n \n-    fn mk_object(items: &[(~str, Json)]) -> Json {\n+    fn mk_object(items: &[(StrBuf, Json)]) -> Json {\n         let mut d = box TreeMap::new();\n \n         for item in items.iter() {\n@@ -2320,67 +2344,67 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_str(), \"null\".to_owned());\n-        assert_eq!(Null.to_pretty_str(), \"null\".to_owned());\n+        assert_eq!(Null.to_str().into_strbuf(), \"null\".to_strbuf());\n+        assert_eq!(Null.to_pretty_str().into_strbuf(), \"null\".to_strbuf());\n     }\n \n \n     #[test]\n     fn test_write_number() {\n-        assert_eq!(Number(3.0).to_str(), \"3\".to_owned());\n-        assert_eq!(Number(3.0).to_pretty_str(), \"3\".to_owned());\n+        assert_eq!(Number(3.0).to_str().into_strbuf(), \"3\".to_strbuf());\n+        assert_eq!(Number(3.0).to_pretty_str().into_strbuf(), \"3\".to_strbuf());\n \n-        assert_eq!(Number(3.1).to_str(), \"3.1\".to_owned());\n-        assert_eq!(Number(3.1).to_pretty_str(), \"3.1\".to_owned());\n+        assert_eq!(Number(3.1).to_str().into_strbuf(), \"3.1\".to_strbuf());\n+        assert_eq!(Number(3.1).to_pretty_str().into_strbuf(), \"3.1\".to_strbuf());\n \n-        assert_eq!(Number(-1.5).to_str(), \"-1.5\".to_owned());\n-        assert_eq!(Number(-1.5).to_pretty_str(), \"-1.5\".to_owned());\n+        assert_eq!(Number(-1.5).to_str().into_strbuf(), \"-1.5\".to_strbuf());\n+        assert_eq!(Number(-1.5).to_pretty_str().into_strbuf(), \"-1.5\".to_strbuf());\n \n-        assert_eq!(Number(0.5).to_str(), \"0.5\".to_owned());\n-        assert_eq!(Number(0.5).to_pretty_str(), \"0.5\".to_owned());\n+        assert_eq!(Number(0.5).to_str().into_strbuf(), \"0.5\".to_strbuf());\n+        assert_eq!(Number(0.5).to_pretty_str().into_strbuf(), \"0.5\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_owned()).to_str(), \"\\\"\\\"\".to_owned());\n-        assert_eq!(String(\"\".to_owned()).to_pretty_str(), \"\\\"\\\"\".to_owned());\n+        assert_eq!(String(\"\".to_strbuf()).to_str().into_strbuf(), \"\\\"\\\"\".to_strbuf());\n+        assert_eq!(String(\"\".to_strbuf()).to_pretty_str().into_strbuf(), \"\\\"\\\"\".to_strbuf());\n \n-        assert_eq!(String(\"foo\".to_owned()).to_str(), \"\\\"foo\\\"\".to_owned());\n-        assert_eq!(String(\"foo\".to_owned()).to_pretty_str(), \"\\\"foo\\\"\".to_owned());\n+        assert_eq!(String(\"foo\".to_strbuf()).to_str().into_strbuf(), \"\\\"foo\\\"\".to_strbuf());\n+        assert_eq!(String(\"foo\".to_strbuf()).to_pretty_str().into_strbuf(), \"\\\"foo\\\"\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_str(), \"true\".to_owned());\n-        assert_eq!(Boolean(true).to_pretty_str(), \"true\".to_owned());\n+        assert_eq!(Boolean(true).to_str().into_strbuf(), \"true\".to_strbuf());\n+        assert_eq!(Boolean(true).to_pretty_str().into_strbuf(), \"true\".to_strbuf());\n \n-        assert_eq!(Boolean(false).to_str(), \"false\".to_owned());\n-        assert_eq!(Boolean(false).to_pretty_str(), \"false\".to_owned());\n+        assert_eq!(Boolean(false).to_str().into_strbuf(), \"false\".to_strbuf());\n+        assert_eq!(Boolean(false).to_pretty_str().into_strbuf(), \"false\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(vec![]).to_str(), \"[]\".to_owned());\n-        assert_eq!(List(vec![]).to_pretty_str(), \"[]\".to_owned());\n+        assert_eq!(List(vec![]).to_str().into_strbuf(), \"[]\".to_strbuf());\n+        assert_eq!(List(vec![]).to_pretty_str().into_strbuf(), \"[]\".to_strbuf());\n \n-        assert_eq!(List(vec![Boolean(true)]).to_str(), \"[true]\".to_owned());\n+        assert_eq!(List(vec![Boolean(true)]).to_str().into_strbuf(), \"[true]\".to_strbuf());\n         assert_eq!(\n-            List(vec![Boolean(true)]).to_pretty_str(),\n+            List(vec![Boolean(true)]).to_pretty_str().into_strbuf(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n-            ]\".to_owned()\n+            ]\".to_strbuf()\n         );\n \n         let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_strbuf()), Number(3.5)])]);\n \n-        assert_eq!(long_test_list.to_str(),\n-            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_owned());\n+        assert_eq!(long_test_list.to_str().into_strbuf(),\n+            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_strbuf());\n         assert_eq!(\n-            long_test_list.to_pretty_str(),\n+            long_test_list.to_pretty_str().into_strbuf(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2389,45 +2413,47 @@ mod tests {\n                     \\\"foo\\\\nbar\\\",\\n    \\\n                     3.5\\n  \\\n                 ]\\n\\\n-            ]\".to_owned()\n+            ]\".to_strbuf()\n         );\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object([]).to_str(), \"{}\".to_owned());\n-        assert_eq!(mk_object([]).to_pretty_str(), \"{}\".to_owned());\n+        assert_eq!(mk_object([]).to_str().into_strbuf(), \"{}\".to_strbuf());\n+        assert_eq!(mk_object([]).to_pretty_str().into_strbuf(), \"{}\".to_strbuf());\n \n         assert_eq!(\n-            mk_object([(\"a\".to_owned(), Boolean(true))]).to_str(),\n-            \"{\\\"a\\\":true}\".to_owned()\n+            mk_object([\n+                (\"a\".to_strbuf(), Boolean(true))\n+            ]).to_str().into_strbuf(),\n+            \"{\\\"a\\\":true}\".to_strbuf()\n         );\n         assert_eq!(\n-            mk_object([(\"a\".to_owned(), Boolean(true))]).to_pretty_str(),\n+            mk_object([(\"a\".to_strbuf(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n-            }\".to_owned()\n+            }\".to_strbuf()\n         );\n \n         let complex_obj = mk_object([\n-                (\"b\".to_owned(), List(vec![\n-                    mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n-                    mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n+                (\"b\".to_strbuf(), List(vec![\n+                    mk_object([(\"c\".to_strbuf(), String(\"\\x0c\\r\".to_strbuf()))]),\n+                    mk_object([(\"d\".to_strbuf(), String(\"\".to_strbuf()))])\n                 ]))\n             ]);\n \n         assert_eq!(\n-            complex_obj.to_str(),\n+            complex_obj.to_str().into_strbuf(),\n             \"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n                     {\\\"d\\\":\\\"\\\"}\\\n                 ]\\\n-            }\".to_owned()\n+            }\".to_strbuf()\n         );\n         assert_eq!(\n-            complex_obj.to_pretty_str(),\n+            complex_obj.to_pretty_str().into_strbuf(),\n             \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n@@ -2438,30 +2464,31 @@ mod tests {\n                         \\\"d\\\": \\\"\\\"\\n    \\\n                     }\\n  \\\n                 ]\\n\\\n-            }\".to_owned()\n+            }\".to_strbuf()\n         );\n \n         let a = mk_object([\n-            (\"a\".to_owned(), Boolean(true)),\n-            (\"b\".to_owned(), List(vec![\n-                mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n-                mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n+            (\"a\".to_strbuf(), Boolean(true)),\n+            (\"b\".to_strbuf(), List(vec![\n+                mk_object([(\"c\".to_strbuf(), String(\"\\x0c\\r\".to_strbuf()))]),\n+                mk_object([(\"d\".to_strbuf(), String(\"\".to_strbuf()))])\n             ]))\n         ]);\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n         assert_eq!(a.clone(), from_str(a.to_str()).unwrap());\n-        assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n+        assert_eq!(a.clone(),\n+                   from_str(a.to_pretty_str().as_slice()).unwrap());\n     }\n \n-    fn with_str_writer(f: |&mut io::Writer|) -> ~str {\n+    fn with_str_writer(f: |&mut io::Writer|) -> StrBuf {\n         use std::io::MemWriter;\n         use std::str;\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(m.unwrap().as_slice()).unwrap().to_strbuf()\n     }\n \n     #[test]\n@@ -2472,23 +2499,23 @@ mod tests {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_owned()\n+            \"\\\"Dog\\\"\".to_strbuf()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_owned()\n+            \"\\\"Dog\\\"\".to_strbuf()\n         );\n \n-        let animal = Frog(\"Henry\".to_owned(), 349);\n+        let animal = Frog(\"Henry\".to_strbuf(), 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_owned()\n+            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_strbuf()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n@@ -2500,41 +2527,41 @@ mod tests {\n                 \\\"Frog\\\",\\n  \\\n                 \\\"Henry\\\",\\n  \\\n                 349\\n\\\n-            ]\".to_owned()\n+            ]\".to_strbuf()\n         );\n     }\n \n     #[test]\n     fn test_write_some() {\n-        let value = Some(\"jodhpurs\".to_owned());\n+        let value = Some(\"jodhpurs\".to_strbuf());\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_owned());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_strbuf());\n \n-        let value = Some(\"jodhpurs\".to_owned());\n+        let value = Some(\"jodhpurs\".to_strbuf());\n         let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_owned());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_none() {\n-        let value: Option<~str> = None;\n+        let value: Option<StrBuf> = None;\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_owned());\n+        assert_eq!(s, \"null\".to_strbuf());\n \n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_owned());\n+        assert_eq!(s, \"null\".to_strbuf());\n     }\n \n     #[test]\n@@ -2635,16 +2662,16 @@ mod tests {\n         assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n         assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n \n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_owned())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_owned())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_strbuf())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_strbuf())));\n     }\n \n     #[test]\n@@ -2665,8 +2692,8 @@ mod tests {\n             assert_eq!(v.as_slice(), o);\n \n             let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(v, o.to_owned());\n+            let v: StrBuf = Decodable::decode(&mut decoder).unwrap();\n+            assert_eq!(v, o.to_strbuf());\n         }\n     }\n \n@@ -2735,39 +2762,39 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_owned(), Number(3.0))]));\n+                  mk_object([(\"a\".to_strbuf(), Number(3.0))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Null),\n-                      (\"b\".to_owned(), Boolean(true))]));\n+                      (\"a\".to_strbuf(), Null),\n+                      (\"b\".to_strbuf(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Null),\n-                      (\"b\".to_owned(), Boolean(true))]));\n+                      (\"a\".to_strbuf(), Null),\n+                      (\"b\".to_strbuf(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(vec![Boolean(true)]))\n+                      (\"a\".to_strbuf(), Number(1.0)),\n+                      (\"b\".to_strbuf(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n-                      \"{\".to_owned() +\n-                          \"\\\"a\\\": 1.0, \" +\n-                          \"\\\"b\\\": [\" +\n-                              \"true,\" +\n-                              \"\\\"foo\\\\nbar\\\", \" +\n-                              \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n-                          \"]\" +\n-                      \"}\").unwrap(),\n+                      \"{\\\n+                          \\\"a\\\": 1.0, \\\n+                          \\\"b\\\": [\\\n+                              true,\\\n+                              \\\"foo\\\\nbar\\\", \\\n+                              { \\\"c\\\": {\\\"d\\\": null} } \\\n+                          ]\\\n+                      }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(vec![\n+                      (\"a\".to_strbuf(), Number(1.0)),\n+                      (\"b\".to_strbuf(), List(vec![\n                           Boolean(true),\n-                          String(\"foo\\nbar\".to_owned()),\n+                          String(\"foo\\nbar\".to_strbuf()),\n                           mk_object([\n-                              (\"c\".to_owned(), mk_object([(\"d\".to_owned(), Null)]))\n+                              (\"c\".to_strbuf(), mk_object([(\"d\".to_strbuf(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -2779,14 +2806,14 @@ mod tests {\n             \\\"inner\\\": [\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n-        }\".to_owned();\n+        }\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(\n             v,\n             Outer {\n                 inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_owned(), \"xyz\".to_owned()] }\n+                    Inner { a: (), b: 2, c: vec![\"abc\".to_strbuf(), \"xyz\".to_strbuf()] }\n                 ]\n             }\n         );\n@@ -2795,12 +2822,12 @@ mod tests {\n     #[test]\n     fn test_decode_option() {\n         let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<StrBuf> = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, None);\n \n         let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_owned()));\n+        let value: Option<StrBuf> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(value, Some(\"jodhpurs\".to_strbuf()));\n     }\n \n     #[test]\n@@ -2812,18 +2839,18 @@ mod tests {\n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_owned(), 349));\n+        assert_eq!(value, Frog(\"Henry\".to_strbuf(), 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n-                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\".to_owned();\n+                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder).unwrap();\n+        let mut map: TreeMap<StrBuf, Animal> = Decodable::decode(&mut decoder).unwrap();\n \n-        assert_eq!(map.pop(&\"a\".to_owned()), Some(Dog));\n-        assert_eq!(map.pop(&\"b\".to_owned()), Some(Frog(\"Henry\".to_owned(), 349)));\n+        assert_eq!(map.pop(&\"a\".to_strbuf()), Some(Dog));\n+        assert_eq!(map.pop(&\"b\".to_strbuf()), Some(Frog(\"Henry\".to_strbuf(), 349)));\n     }\n \n     #[test]\n@@ -2836,13 +2863,13 @@ mod tests {\n     struct DecodeStruct {\n         x: f64,\n         y: bool,\n-        z: ~str,\n+        z: StrBuf,\n         w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {\n         A(f64),\n-        B(~str)\n+        B(StrBuf)\n     }\n     fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n                                                       expected: DecoderError) {\n@@ -2862,51 +2889,51 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_owned(), \"[]\".to_owned()));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_strbuf(), \"[]\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_owned(), \"true\".to_owned()));\n+                                  ExpectedError(\"Number\".to_strbuf(), \"true\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_owned(), \"[]\".to_owned()));\n+                                  ExpectedError(\"Boolean\".to_strbuf(), \"[]\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_owned(), \"{}\".to_owned()));\n+                                  ExpectedError(\"String\".to_strbuf(), \"{}\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"List\".to_owned(), \"null\".to_owned()));\n+                                  ExpectedError(\"List\".to_strbuf(), \"null\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_owned()));\n+                                  MissingFieldError(\"w\".to_strbuf()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_owned()));\n+                                MissingFieldError(\"variant\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_owned(), \"1\".to_owned()));\n+                                ExpectedError(\"String\".to_strbuf(), \"1\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_owned()));\n+                                MissingFieldError(\"fields\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"List\".to_owned(), \"null\".to_owned()));\n+                                ExpectedError(\"List\".to_strbuf(), \"null\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_owned()));\n+                                UnknownVariantError(\"C\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&\"dog\".to_owned());\n+        let found_str = json_value.find(&\"dog\".to_strbuf());\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&\"dog\".to_owned(),\n-                                             &\"cat\".to_owned(), &\"mouse\".to_owned()]);\n+        let found_str = json_value.find_path(&[&\"dog\".to_strbuf(),\n+                                             &\"cat\".to_strbuf(), &\"mouse\".to_strbuf()]);\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&\"mouse\".to_owned()).and_then(|j| j.as_string());\n+        let found_str = json_value.search(&\"mouse\".to_strbuf()).and_then(|j| j.as_string());\n         assert!(found_str.is_some());\n         assert!(found_str.unwrap() == \"cheese\");\n     }\n@@ -3069,7 +3096,7 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n             ~[\n                 (ObjectStart,             ~[]),\n-                  (StringValue(\"bar\".to_owned()),   ~[Key(\"foo\")]),\n+                  (StringValue(\"bar\".to_strbuf()),   ~[Key(\"foo\")]),\n                   (ListStart,             ~[Key(\"array\")]),\n                     (NumberValue(0.0),    ~[Key(\"array\"), Index(0)]),\n                     (NumberValue(1.0),    ~[Key(\"array\"), Index(1)]),\n@@ -3158,7 +3185,7 @@ mod tests {\n                   (NumberValue(1.0),            ~[Key(\"a\")]),\n                   (ListStart,                   ~[Key(\"b\")]),\n                     (BooleanValue(true),        ~[Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_owned()),  ~[Key(\"b\"), Index(1)]),\n+                    (StringValue(\"foo\\nbar\".to_strbuf()),  ~[Key(\"b\"), Index(1)]),\n                     (ObjectStart,               ~[Key(\"b\"), Index(2)]),\n                       (ObjectStart,             ~[Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             ~[Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n@@ -3291,7 +3318,7 @@ mod tests {\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n-        stack.push_key(\"foo\".to_owned());\n+        stack.push_key(\"foo\".to_strbuf());\n \n         assert!(stack.len() == 2);\n         assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n@@ -3303,7 +3330,7 @@ mod tests {\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n-        stack.push_key(\"bar\".to_owned());\n+        stack.push_key(\"bar\".to_strbuf());\n \n         assert!(stack.len() == 3);\n         assert!(stack.is_equal_to([Index(1), Key(\"foo\"), Key(\"bar\")]));\n@@ -3366,20 +3393,21 @@ mod tests {\n         });\n     }\n \n-    fn big_json() -> ~str {\n-        let mut src = \"[\\n\".to_owned();\n+    fn big_json() -> StrBuf {\n+        let mut src = \"[\\n\".to_strbuf();\n         for _ in range(0, 500) {\n-            src = src + r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": [1,2,3]},\"#;\n+            src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n+                            [1,2,3]},\"#);\n         }\n-        src = src + \"{}]\";\n+        src.push_str(\"{}]\");\n         return src;\n     }\n \n     #[bench]\n     fn bench_streaming_large(b: &mut Bencher) {\n         let src = big_json();\n         b.iter( || {\n-            let mut parser = Parser::new(src.chars());\n+            let mut parser = Parser::new(src.as_slice().chars());\n             loop {\n                 match parser.next() {\n                     None => return,\n@@ -3391,6 +3419,6 @@ mod tests {\n     #[bench]\n     fn bench_large(b: &mut Bencher) {\n         let src = big_json();\n-        b.iter( || { let _ = from_str(src); });\n+        b.iter( || { let _ = from_str(src.as_slice()); });\n     }\n }"}, {"sha": "3189676ec1e24552d619b7e774248eadddb92835", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -108,7 +108,7 @@ pub trait Decoder<E> {\n     fn read_f64(&mut self) -> Result<f64, E>;\n     fn read_f32(&mut self) -> Result<f32, E>;\n     fn read_char(&mut self) -> Result<char, E>;\n-    fn read_str(&mut self) -> Result<~str, E>;\n+    fn read_str(&mut self) -> Result<StrBuf, E>;\n \n     // Compound types:\n     fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n@@ -301,18 +301,6 @@ impl<'a, E, S:Encoder<E>> Encodable<S, E> for &'a str {\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for ~str {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for ~str {\n-    fn decode(d: &mut D) -> Result<~str, E> {\n-        d.read_str()\n-    }\n-}\n-\n impl<E, S:Encoder<E>> Encodable<S, E> for StrBuf {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(self.as_slice())\n@@ -321,7 +309,7 @@ impl<E, S:Encoder<E>> Encodable<S, E> for StrBuf {\n \n impl<E, D:Decoder<E>> Decodable<D, E> for StrBuf {\n     fn decode(d: &mut D) -> Result<StrBuf, E> {\n-        Ok(StrBuf::from_str(try!(d.read_str())))\n+        Ok(StrBuf::from_str(try!(d.read_str()).as_slice()))\n     }\n }\n "}, {"sha": "e7f892d77ceaaef7542d451a01fb3ddeeedd41a9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -106,7 +106,7 @@ impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n \n impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n     fn decode(d: &mut D) -> Result<Ident, E> {\n-        Ok(str_to_ident(try!(d.read_str())))\n+        Ok(str_to_ident(try!(d.read_str()).as_slice()))\n     }\n }\n "}, {"sha": "8758f109042f049b57bd885695604427d27bb1af", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -606,7 +606,8 @@ impl<'a> Equiv<&'a str> for InternedString {\n \n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n-        Ok(get_name(get_ident_interner().intern(try!(d.read_str()))))\n+        Ok(get_name(get_ident_interner().intern(\n+                    try!(d.read_str()).as_slice())))\n     }\n }\n "}, {"sha": "ebdef9f73ae2cbe2beac43ab6309b7329f50b7b9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -1067,8 +1067,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = box TreeMap::new();\n-        map.insert(\"value\".to_owned(), json::Number(self.value));\n-        map.insert(\"noise\".to_owned(), json::Number(self.noise));\n+        map.insert(\"value\".to_strbuf(), json::Number(self.value));\n+        map.insert(\"noise\".to_strbuf(), json::Number(self.noise));\n         json::Object(map)\n     }\n }\n@@ -1105,7 +1105,7 @@ impl MetricMap {\n         // FIXME(pcwalton): Yuck.\n         let mut new_map = TreeMap::new();\n         for (ref key, ref value) in map.iter() {\n-            new_map.insert(key.to_owned(), (*value).clone());\n+            new_map.insert(key.to_strbuf(), (*value).clone());\n         }\n \n         new_map.to_json().to_pretty_writer(&mut file)"}, {"sha": "1ea9ea174ca085de8cdc7c0f22ec26dc6367defb", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -189,7 +189,7 @@ pub fn tzset() {\n \n /// Holds a calendar date and time broken down into its components (year, month, day, and so on),\n /// also called a broken-down time value.\n-#[deriving(Clone, Eq, Encodable, Decodable, Show)]\n+#[deriving(Clone, Eq, Show)]\n pub struct Tm {\n     /// Seconds after the minute \u2013 [0, 60]\n     pub tm_sec: i32,"}, {"sha": "d2032b9d49281a7436149776718c389cae4e563b", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -500,7 +500,7 @@ impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n     /// Decode a UUID from a string\n     fn decode(d: &mut T) -> Result<Uuid, E> {\n-        Ok(from_str(try!(d.read_str())).unwrap())\n+        Ok(from_str(try!(d.read_str()).as_slice()).unwrap())\n     }\n }\n "}, {"sha": "ec68a46b22c86361a716fb84d2525361637a0702", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -192,7 +192,7 @@ impl Database {\n         // FIXME(pcwalton): Yuck.\n         let mut new_db_cache = TreeMap::new();\n         for (ref k, ref v) in self.db_cache.iter() {\n-            new_db_cache.insert((*k).to_owned(), (*v).to_owned());\n+            new_db_cache.insert((*k).to_strbuf(), (*v).to_strbuf());\n         }\n \n         new_db_cache.to_json().to_pretty_writer(&mut f)\n@@ -515,10 +515,13 @@ fn test() {\n         let pth = pth.clone();\n \n         let contents = File::open(&pth).read_to_end().unwrap();\n-        let file_content = from_utf8(contents.as_slice()).unwrap().to_owned();\n+        let file_content = from_utf8(contents.as_slice()).unwrap()\n+                                                         .to_strbuf();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n+        prep.declare_input(\"file\",\n+                           pth.as_str().unwrap(),\n+                           file_content.as_slice());\n         prep.exec(proc(_exe) {\n             let out = make_path(\"foo.o\".to_strbuf());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n@@ -528,7 +531,7 @@ fn test() {\n             // Could run sub-rules inside here.\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            out.as_str().unwrap().to_owned()\n+            out.as_str().unwrap().to_strbuf()\n         })\n     });\n "}, {"sha": "6aa5f6b09ecdefb9e426df4a73c2a176236de548", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bcef85e402a32cf44b740f128e5f9bbd21c0a0/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=28bcef85e402a32cf44b740f128e5f9bbd21c0a0", "patch": "@@ -23,7 +23,7 @@ enum object {\n \n fn lookup(table: Box<json::Object>, key: StrBuf, default: StrBuf) -> StrBuf\n {\n-    match table.find(&key.to_owned()) {\n+    match table.find(&key.to_strbuf()) {\n         option::Some(&json::String(ref s)) => {\n             (*s).to_strbuf()\n         }"}]}