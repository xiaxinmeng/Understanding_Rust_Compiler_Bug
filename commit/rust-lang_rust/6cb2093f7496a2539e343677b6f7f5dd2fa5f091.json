{"sha": "6cb2093f7496a2539e343677b6f7f5dd2fa5f091", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYjIwOTNmNzQ5NmEyNTM5ZTM0MzY3N2I2ZjdmNWRkMmZhNWYwOTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-28T22:54:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:47Z"}, "message": "std: Update Duration from upstream\n\nFrom rust-chrono 4f34003e03e259bd5cbda0cb4d35325861307cc6", "tree": {"sha": "4f559bb3d4a02f63b4f2365543bbfd0a3203791b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f559bb3d4a02f63b4f2365543bbfd0a3203791b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb2093f7496a2539e343677b6f7f5dd2fa5f091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb2093f7496a2539e343677b6f7f5dd2fa5f091", "html_url": "https://github.com/rust-lang/rust/commit/6cb2093f7496a2539e343677b6f7f5dd2fa5f091", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb2093f7496a2539e343677b6f7f5dd2fa5f091/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f75a9197a5b535f9804901bfefbaffe373d689", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f75a9197a5b535f9804901bfefbaffe373d689", "html_url": "https://github.com/rust-lang/rust/commit/18f75a9197a5b535f9804901bfefbaffe373d689"}], "stats": {"total": 428, "additions": 328, "deletions": 100}, "files": [{"sha": "41a0271fff2b8518f57b9b01269840b217203917", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6cb2093f7496a2539e343677b6f7f5dd2fa5f091/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb2093f7496a2539e343677b6f7f5dd2fa5f091/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=6cb2093f7496a2539e343677b6f7f5dd2fa5f091", "patch": "@@ -22,7 +22,6 @@ use time::Duration;\n use io::{IoResult, IoError};\n use kinds::Send;\n use boxed::Box;\n-use num::{CheckedMul, CheckedAdd};\n use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n \n /// A synchronous timer object\n@@ -71,31 +70,16 @@ pub struct Timer {\n \n struct TimerCallback { tx: Sender<()> }\n \n-#[allow(missing_doc)]\n-trait DurationExtension {\n-    fn in_ms(&self) -> u64;\n-}\n-\n-impl DurationExtension for Duration {\n-    fn in_ms(&self) -> u64 {\n-        if self.ndays() < 0 { fail!(\"negative duration\") }\n-        let nanos = self.nnanoseconds() as u64;\n-        let secs = self.nseconds() as u64;\n-        let days = self.ndays() as u64;\n-        let nanos_in_ms = nanos / 1000;\n-        let secs_in_ms = secs.checked_mul(&1000).expect(\"overflow\");\n-        let ms_per_day = 24 * 60 * 60 * 1000; // hours/day * min/hour * sec/min * ms/sec\n-        let days_in_ms = days.checked_mul(&ms_per_day).expect(\"overflow\");\n-        let result = nanos_in_ms;\n-        let result = result.checked_add(&secs_in_ms).expect(\"overflow\");\n-        let result = result.checked_add(&(days_in_ms as u64)).expect(\"overflow\");\n-        return result;\n-    }\n+fn in_ms(d: Duration) -> u64 {\n+    // FIXME: Do we really want to fail on negative duration?\n+    let ms = d.num_milliseconds();\n+    if ms < 0 { fail!(\"negative duration\") }\n+    return ms as u64;\n }\n \n /// Sleep the current task for the specified duration.\n pub fn sleep(duration: Duration) {\n-    sleep_ms(duration.in_ms())\n+    sleep_ms(in_ms(duration))\n }\n \n /// Sleep the current task for `msecs` milliseconds.\n@@ -121,7 +105,7 @@ impl Timer {\n     /// Note that this function will cause any other receivers for this timer to\n     /// be invalidated (the other end will be closed).\n     pub fn sleep(&mut self, duration: Duration) {\n-        self.obj.sleep(duration.in_ms());\n+        self.obj.sleep(in_ms(duration));\n     }\n \n     /// Blocks the current task for `msecs` milliseconds.\n@@ -145,7 +129,7 @@ impl Timer {\n     /// fail.\n     pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n         let (tx, rx) = channel();\n-        self.obj.oneshot(duration.in_ms(), box TimerCallback { tx: tx });\n+        self.obj.oneshot(in_ms(duration), box TimerCallback { tx: tx });\n         return rx\n     }\n \n@@ -204,7 +188,7 @@ impl Timer {\n     /// fail.\n     pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n         let (tx, rx) = channel();\n-        self.obj.period(duration.in_ms(), box TimerCallback { tx: tx });\n+        self.obj.period(in_ms(duration), box TimerCallback { tx: tx });\n         return rx\n     }\n "}, {"sha": "e51296e5b9bccf4134f43a665be68626a4219471", "filename": "src/libstd/time.rs", "status": "modified", "additions": 319, "deletions": 75, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/6cb2093f7496a2539e343677b6f7f5dd2fa5f091/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb2093f7496a2539e343677b6f7f5dd2fa5f091/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=6cb2093f7496a2539e343677b6f7f5dd2fa5f091", "patch": "@@ -11,123 +11,279 @@\n //! Temporal quantification\n \n #![experimental]\n-#![allow(missing_doc)] // FIXME\n \n-use {fmt, num, i32};\n+use {fmt, i32};\n+use ops::{Add, Sub, Mul, Div, Neg};\n use option::{Option, Some, None};\n+use num;\n+use num::{CheckedAdd, CheckedMul, ToPrimitive};\n use result::{Result, Ok, Err};\n-use ops::{Neg, Add, Sub, Mul, Div};\n-use num::{CheckedAdd, ToPrimitive};\n \n-pub static MIN_DAYS: i32 = i32::MIN;\n-pub static MAX_DAYS: i32 = i32::MAX;\n \n+/// `Duration`'s `days` component should have no more than this value.\n+static MIN_DAYS: i32 = i32::MIN;\n+/// `Duration`'s `days` component should have no less than this value.\n+static MAX_DAYS: i32 = i32::MAX;\n+\n+/// The number of nanoseconds in seconds.\n static NANOS_PER_SEC: i32 = 1_000_000_000;\n+/// The number of (non-leap) seconds in days.\n static SECS_PER_DAY: i32 = 86400;\n \n-macro_rules! earlyexit(\n+macro_rules! try_opt(\n     ($e:expr) => (match $e { Some(v) => v, None => return None })\n )\n \n-/// The representation of a span of time.\n-///\n-/// This type has nanosecond precision, and conforms to the ISO 8601\n-/// standard for Date interchange.\n+/// ISO 8601 time duration with nanosecond precision.\n+/// This also allows for the negative duration; see individual methods for details.\n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n pub struct Duration {\n     days: i32,\n     secs: u32,\n     nanos: u32,\n }\n \n+/// The minimum possible `Duration`.\n+pub static MIN: Duration = Duration { days: MIN_DAYS, secs: 0, nanos: 0 };\n+/// The maximum possible `Duration`.\n+pub static MAX: Duration = Duration { days: MAX_DAYS, secs: SECS_PER_DAY as u32 - 1,\n+                                      nanos: NANOS_PER_SEC as u32 - 1 };\n+\n impl Duration {\n-    /// Create a new `Duration`.\n-    pub fn new(days: i32, secs: i32, nanos: i32) -> Option<Duration> {\n+    /// Makes a new `Duration` with given number of days, seconds and nanoseconds.\n+    ///\n+    /// Fails when the duration is out of bounds.\n+    #[inline]\n+    pub fn new(days: i32, secs: i32, nanos: i32) -> Duration {\n+        Duration::new_opt(days, secs, nanos).expect(\"Duration::new out of bounds\")\n+    }\n+\n+    /// Makes a new `Duration` with given number of days, seconds and nanoseconds.\n+    ///\n+    /// Returns `None` when the duration is out of bounds.\n+    pub fn new_opt(days: i32, secs: i32, nanos: i32) -> Option<Duration> {\n         let (secs_, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n-        let secs = earlyexit!(secs.checked_add(&secs_));\n+        let secs = try_opt!(secs.checked_add(&secs_));\n         let (days_, secs) = div_mod_floor(secs, SECS_PER_DAY);\n-        let days = earlyexit!(days.checked_add(&days_).and_then(|v| v.to_i32()));\n+        let days = try_opt!(days.checked_add(&days_).and_then(|v| v.to_i32()));\n         Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n     }\n \n-    /// Create a new `Duration` from an integer number of weeks.\n+    /// Makes a new `Duration` with zero seconds.\n+    #[inline]\n+    pub fn zero() -> Duration {\n+        Duration { days: 0, secs: 0, nanos: 0 }\n+    }\n+\n+    /// Makes a new `Duration` with given number of weeks.\n+    /// Equivalent to `Duration::new(weeks * 7, 0, 0)` with overflow checks.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn weeks(weeks: i32) -> Duration {\n-        Duration::days(weeks * 7)\n+        let days = weeks.checked_mul(&7).expect(\"Duration::weeks out of bounds\");\n+        Duration::days(days)\n     }\n \n-    /// Create a new `Duration` from an integer number of days.\n+    /// Makes a new `Duration` with given number of days.\n+    /// Equivalent to `Duration::new(days, 0, 0)`.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn days(days: i32) -> Duration {\n         let days = days.to_i32().expect(\"Duration::days out of bounds\");\n         Duration { days: days, secs: 0, nanos: 0 }\n     }\n \n-    /// Create a new `Duration` from an integer number of hours.\n+    /// Makes a new `Duration` with given number of hours.\n+    /// Equivalent to `Duration::new(0, hours * 3600, 0)` with overflow checks.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn hours(hours: i32) -> Duration {\n         let (days, hours) = div_mod_floor(hours, (SECS_PER_DAY / 3600));\n         let secs = hours * 3600;\n         Duration { secs: secs as u32, ..Duration::days(days) }\n     }\n \n-    /// Create a new `Duration` from an integer number of minutes.\n+    /// Makes a new `Duration` with given number of minutes.\n+    /// Equivalent to `Duration::new(0, mins * 60, 0)` with overflow checks.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn minutes(mins: i32) -> Duration {\n         let (days, mins) = div_mod_floor(mins, (SECS_PER_DAY / 60));\n         let secs = mins * 60;\n         Duration { secs: secs as u32, ..Duration::days(days) }\n     }\n \n-    /// Create a new `Duration` from an integer number of seconds.\n+    /// Makes a new `Duration` with given number of seconds.\n+    /// Equivalent to `Duration::new(0, secs, 0)`.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn seconds(secs: i32) -> Duration {\n         let (days, secs) = div_mod_floor(secs, SECS_PER_DAY);\n         Duration { secs: secs as u32, ..Duration::days(days) }\n     }\n \n-    /// Create a new `Duration` from an integer number of milliseconds.\n+    /// Makes a new `Duration` with given number of milliseconds.\n+    /// Equivalent to `Duration::new(0, 0, millis * 1_000_000)` with overflow checks.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn milliseconds(millis: i32) -> Duration {\n         let (secs, millis) = div_mod_floor(millis, (NANOS_PER_SEC / 1_000_000));\n         let nanos = millis * 1_000_000;\n         Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n     }\n \n-    /// Create a new `Duration` from an integer number of microseconds.\n+    /// Makes a new `Duration` with given number of microseconds.\n+    /// Equivalent to `Duration::new(0, 0, micros * 1_000)` with overflow checks.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn microseconds(micros: i32) -> Duration {\n         let (secs, micros) = div_mod_floor(micros, (NANOS_PER_SEC / 1_000));\n         let nanos = micros * 1_000;\n         Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n     }\n \n-    /// Create a new `Duration` from an integer number of nanoseconds.\n+    /// Makes a new `Duration` with given number of nanoseconds.\n+    /// Equivalent to `Duration::new(0, 0, nanos)`.\n+    ///\n+    /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn nanoseconds(nanos: i32) -> Duration {\n         let (secs, nanos) = div_mod_floor(nanos, NANOS_PER_SEC);\n         Duration { nanos: nanos as u32, ..Duration::seconds(secs) }\n     }\n \n-    /// Return the number of whole days in the `Duration`.\n+    /// Returns a tuple of the number of days, (non-leap) seconds and nanoseconds in the duration.\n+    /// Note that the number of seconds and nanoseconds are always positive,\n+    /// so that for example `-Duration::seconds(3)` has -1 days and 86,397 seconds.\n     #[inline]\n-    pub fn ndays(&self) -> i32 {\n-        self.days as i32\n+    pub fn to_tuple(&self) -> (i32, u32, u32) {\n+        (self.days, self.secs, self.nanos)\n     }\n \n-    /// Return the fractional number of days in the `Duration` as seconds.\n+    /// Same as `to_tuple` but returns a tuple compatible to `to_negated_tuple`.\n     #[inline]\n-    pub fn nseconds(&self) -> u32 {\n-        self.secs as u32\n+    fn to_tuple_64(&self) -> (i64, u32, u32) {\n+        (self.days as i64, self.secs, self.nanos)\n+    }\n+\n+    /// Negates the duration and returns a tuple like `to_tuple`.\n+    /// This does not overflow and thus is internally used for several methods.\n+    fn to_negated_tuple_64(&self) -> (i64, u32, u32) {\n+        let mut days = -(self.days as i64);\n+        let mut secs = -(self.secs as i32);\n+        let mut nanos = -(self.nanos as i32);\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        if secs < 0 {\n+            secs += SECS_PER_DAY;\n+            days -= 1;\n+        }\n+        (days, secs as u32, nanos as u32)\n     }\n \n-    /// Return the fractional number of seconds in the `Duration` as nanoseconds.\n+    /// Returns the total number of whole weeks in the duration.\n     #[inline]\n-    pub fn nnanoseconds(&self) -> u32 {\n-        self.nanos as u32\n+    pub fn num_weeks(&self) -> i32 {\n+        self.num_days() / 7\n+    }\n+\n+    /// Returns the total number of whole days in the duration.\n+    pub fn num_days(&self) -> i32 {\n+        if self.days < 0 {\n+            let negated = -*self;\n+            -negated.days\n+        } else {\n+            self.days\n+        }\n+    }\n+\n+    /// Returns the total number of whole hours in the duration.\n+    #[inline]\n+    pub fn num_hours(&self) -> i64 {\n+        self.num_seconds() / 3600\n+    }\n+\n+    /// Returns the total number of whole minutes in the duration.\n+    #[inline]\n+    pub fn num_minutes(&self) -> i64 {\n+        self.num_seconds() / 60\n+    }\n+\n+    /// Returns the total number of (non-leap) whole seconds in the duration.\n+    pub fn num_seconds(&self) -> i64 {\n+        // cannot overflow, 2^32 * 86400 < 2^64\n+        fn secs((days, secs, _): (i64, u32, u32)) -> i64 {\n+            days as i64 * SECS_PER_DAY as i64 + secs as i64\n+        }\n+        if self.days < 0 {-secs(self.to_negated_tuple_64())} else {secs(self.to_tuple_64())}\n+    }\n+\n+    /// Returns the total number of whole milliseconds in the duration.\n+    pub fn num_milliseconds(&self) -> i64 {\n+        // cannot overflow, 2^32 * 86400 * 1000 < 2^64\n+        fn millis((days, secs, nanos): (i64, u32, u32)) -> i64 {\n+            static MILLIS_PER_SEC: i64 = 1_000;\n+            static NANOS_PER_MILLI: i64 = 1_000_000;\n+            (days as i64 * MILLIS_PER_SEC * SECS_PER_DAY as i64 +\n+             secs as i64 * MILLIS_PER_SEC +\n+             nanos as i64 / NANOS_PER_MILLI)\n+        }\n+        if self.days < 0 {-millis(self.to_negated_tuple_64())} else {millis(self.to_tuple_64())}\n+    }\n+\n+    /// Returns the total number of whole microseconds in the duration,\n+    /// or `None` on the overflow (exceeding 2^63 microseconds in either directions).\n+    pub fn num_microseconds(&self) -> Option<i64> {\n+        fn micros((days, secs, nanos): (i64, u32, u32)) -> Option<i64> {\n+            static MICROS_PER_SEC: i64 = 1_000_000;\n+            static MICROS_PER_DAY: i64 = MICROS_PER_SEC * SECS_PER_DAY as i64;\n+            static NANOS_PER_MICRO: i64 = 1_000;\n+            let nmicros = try_opt!((days as i64).checked_mul(&MICROS_PER_DAY));\n+            let nmicros = try_opt!(nmicros.checked_add(&(secs as i64 * MICROS_PER_SEC)));\n+            let nmicros = try_opt!(nmicros.checked_add(&(nanos as i64 / NANOS_PER_MICRO as i64)));\n+            Some(nmicros)\n+        }\n+        if self.days < 0 {\n+            // the final negation won't overflow since we start with positive numbers.\n+            micros(self.to_negated_tuple_64()).map(|micros| -micros)\n+        } else {\n+            micros(self.to_tuple_64())\n+        }\n+    }\n+\n+    /// Returns the total number of whole nanoseconds in the duration,\n+    /// or `None` on the overflow (exceeding 2^63 nanoseconds in either directions).\n+    pub fn num_nanoseconds(&self) -> Option<i64> {\n+        fn nanos((days, secs, nanos): (i64, u32, u32)) -> Option<i64> {\n+            static NANOS_PER_DAY: i64 = NANOS_PER_SEC as i64 * SECS_PER_DAY as i64;\n+            let nnanos = try_opt!((days as i64).checked_mul(&NANOS_PER_DAY));\n+            let nnanos = try_opt!(nnanos.checked_add(&(secs as i64 * NANOS_PER_SEC as i64)));\n+            let nnanos = try_opt!(nnanos.checked_add(&(nanos as i64)));\n+            Some(nnanos)\n+        }\n+        if self.days < 0 {\n+            // the final negation won't overflow since we start with positive numbers.\n+            nanos(self.to_negated_tuple_64()).map(|micros| -micros)\n+        } else {\n+            nanos(self.to_tuple_64())\n+        }\n     }\n }\n \n+impl num::Bounded for Duration {\n+    #[inline] fn min_value() -> Duration { MIN }\n+    #[inline] fn max_value() -> Duration { MAX }\n+}\n+\n impl num::Zero for Duration {\n     #[inline]\n     fn zero() -> Duration {\n@@ -141,20 +297,10 @@ impl num::Zero for Duration {\n }\n \n impl Neg<Duration> for Duration {\n+    #[inline]\n     fn neg(&self) -> Duration {\n-        // FIXME overflow (e.g. `-Duration::days(i32::MIN as i32)`)\n-        let mut days = -(self.days as i32);\n-        let mut secs = -(self.secs as i32);\n-        let mut nanos = -(self.nanos as i32);\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        if secs < 0 {\n-            secs += SECS_PER_DAY;\n-            days -= 1;\n-        }\n-        Duration { days: days as i32, secs: secs as u32, nanos: nanos as u32 }\n+        let (days, secs, nanos) = self.to_negated_tuple_64();\n+        Duration { days: days as i32, secs: secs, nanos: nanos } // FIXME can overflow\n     }\n }\n \n@@ -177,7 +323,7 @@ impl Add<Duration,Duration> for Duration {\n \n impl num::CheckedAdd for Duration {\n     fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut days = earlyexit!(self.days.checked_add(&rhs.days));\n+        let mut days = try_opt!(self.days.checked_add(&rhs.days));\n         let mut secs = self.secs + rhs.secs;\n         let mut nanos = self.nanos + rhs.nanos;\n         if nanos >= NANOS_PER_SEC as u32 {\n@@ -186,7 +332,7 @@ impl num::CheckedAdd for Duration {\n         }\n         if secs >= SECS_PER_DAY as u32 {\n             secs -= SECS_PER_DAY as u32;\n-            days = earlyexit!(days.checked_add(&1));\n+            days = try_opt!(days.checked_add(&1));\n         }\n         Some(Duration { days: days, secs: secs, nanos: nanos })\n     }\n@@ -211,7 +357,7 @@ impl Sub<Duration,Duration> for Duration {\n \n impl num::CheckedSub for Duration {\n     fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut days = earlyexit!(self.days.checked_sub(&rhs.days));\n+        let mut days = try_opt!(self.days.checked_sub(&rhs.days));\n         let mut secs = self.secs as i32 - rhs.secs as i32;\n         let mut nanos = self.nanos as i32 - rhs.nanos as i32;\n         if nanos < 0 {\n@@ -220,7 +366,7 @@ impl num::CheckedSub for Duration {\n         }\n         if secs < 0 {\n             secs += SECS_PER_DAY;\n-            days = earlyexit!(days.checked_sub(&1));\n+            days = try_opt!(days.checked_sub(&1));\n         }\n         Some(Duration { days: days, secs: secs as u32, nanos: nanos as u32 })\n     }\n@@ -256,8 +402,8 @@ impl Mul<i32,Duration> for Duration {\n impl Div<i32,Duration> for Duration {\n     fn div(&self, rhs: &i32) -> Duration {\n         let (rhs, days, secs, nanos) = if *rhs < 0 {\n-            let negated = -*self;\n-            (-*rhs as i64, negated.days as i64, negated.secs as i64, negated.nanos as i64)\n+            let (days, secs, nanos) = self.to_negated_tuple_64();\n+            (-(*rhs as i64), days, secs as i64, nanos as i64)\n         } else {\n             (*rhs as i64, self.days as i64, self.secs as i64, self.nanos as i64)\n         };\n@@ -276,7 +422,7 @@ impl fmt::Show for Duration {\n         let hasdate = self.days != 0;\n         let hastime = (self.secs != 0 || self.nanos != 0) || !hasdate;\n \n-        try!('P'.fmt(f));\n+        try!(write!(f, \"P\"));\n         if hasdate {\n             // technically speaking the negative part is not the valid ISO 8601,\n             // but we need to print it anyway.\n@@ -286,11 +432,11 @@ impl fmt::Show for Duration {\n             if self.nanos == 0 {\n                 try!(write!(f, \"T{}S\", self.secs));\n             } else if self.nanos % 1_000_000 == 0 {\n-                try!(write!(f, \"T{},{:03}S\", self.secs, self.nanos / 1_000_000));\n+                try!(write!(f, \"T{}.{:03}S\", self.secs, self.nanos / 1_000_000));\n             } else if self.nanos % 1_000 == 0 {\n-                try!(write!(f, \"T{},{:06}S\", self.secs, self.nanos / 1_000));\n+                try!(write!(f, \"T{}.{:06}S\", self.secs, self.nanos / 1_000));\n             } else {\n-                try!(write!(f, \"T{},{:09}S\", self.secs, self.nanos));\n+                try!(write!(f, \"T{}.{:09}S\", self.secs, self.nanos));\n             }\n         }\n         Ok(())\n@@ -354,20 +500,15 @@ fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n     (this / other, this % other)\n }\n \n-\n #[cfg(test)]\n mod tests {\n-    use option::Some;\n-    use super::{Duration, MIN_DAYS, MAX_DAYS};\n-    use i32;\n-    use num::{CheckedAdd, CheckedSub, Zero};\n-    use to_string::ToString;\n-\n-    fn zero() -> Duration { Zero::zero() }\n+    use super::{Duration, MIN_DAYS, MAX_DAYS, MIN, MAX};\n+    use std::{i32, i64};\n \n     #[test]\n     fn test_duration() {\n-        assert!(zero() != Duration::seconds(1));\n+        assert_eq!(Duration::zero(), Duration::zero());\n+        assert!(Duration::zero() != Duration::seconds(1));\n         assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n         assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n                    Duration::days(1) + Duration::seconds(3));\n@@ -380,6 +521,105 @@ mod tests {\n                    Duration::days(-4) + Duration::seconds(86400-70));\n     }\n \n+    #[test]\n+    fn test_duration_num_days() {\n+        assert_eq!(Duration::zero().num_days(), 0);\n+        assert_eq!(Duration::days(1).num_days(), 1);\n+        assert_eq!(Duration::days(-1).num_days(), -1);\n+        assert_eq!(Duration::seconds(86399).num_days(), 0);\n+        assert_eq!(Duration::seconds(86401).num_days(), 1);\n+        assert_eq!(Duration::seconds(-86399).num_days(), 0);\n+        assert_eq!(Duration::seconds(-86401).num_days(), -1);\n+        assert_eq!(Duration::new(1, 2, 3_004_005).num_days(), 1);\n+        assert_eq!(Duration::new(-1, -2, -3_004_005).num_days(), -1);\n+        assert_eq!(Duration::days(i32::MAX).num_days(), i32::MAX);\n+        assert_eq!(Duration::days(i32::MIN).num_days(), i32::MIN);\n+        assert_eq!(MAX.num_days(), MAX_DAYS);\n+        assert_eq!(MIN.num_days(), MIN_DAYS);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_seconds() {\n+        assert_eq!(Duration::zero().num_seconds(), 0);\n+        assert_eq!(Duration::seconds(1).num_seconds(), 1);\n+        assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n+        assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n+        assert_eq!(Duration::milliseconds(1001).num_seconds(), 1);\n+        assert_eq!(Duration::milliseconds(-999).num_seconds(), 0);\n+        assert_eq!(Duration::milliseconds(-1001).num_seconds(), -1);\n+        assert_eq!(Duration::new(1, 2, 3_004_005).num_seconds(), 86402);\n+        assert_eq!(Duration::new(-1, -2, -3_004_005).num_seconds(), -86402);\n+        assert_eq!(Duration::seconds(i32::MAX).num_seconds(), i32::MAX as i64);\n+        assert_eq!(Duration::seconds(i32::MIN).num_seconds(), i32::MIN as i64);\n+        assert_eq!(MAX.num_seconds(), (MAX_DAYS as i64 + 1) * 86400 - 1);\n+        assert_eq!(MIN.num_seconds(), MIN_DAYS as i64 * 86400);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_milliseconds() {\n+        assert_eq!(Duration::zero().num_milliseconds(), 0);\n+        assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n+        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n+        assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n+        assert_eq!(Duration::microseconds(1001).num_milliseconds(), 1);\n+        assert_eq!(Duration::microseconds(-999).num_milliseconds(), 0);\n+        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), -1);\n+        assert_eq!(Duration::new(1, 2, 3_004_005).num_milliseconds(), 86402_003);\n+        assert_eq!(Duration::new(-1, -2, -3_004_005).num_milliseconds(), -86402_003);\n+        assert_eq!(Duration::milliseconds(i32::MAX).num_milliseconds(), i32::MAX as i64);\n+        assert_eq!(Duration::milliseconds(i32::MIN).num_milliseconds(), i32::MIN as i64);\n+        assert_eq!(MAX.num_milliseconds(), (MAX_DAYS as i64 + 1) * 86400_000 - 1);\n+        assert_eq!(MIN.num_milliseconds(), MIN_DAYS as i64 * 86400_000);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_microseconds() {\n+        assert_eq!(Duration::zero().num_microseconds(), Some(0));\n+        assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n+        assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n+        assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n+        assert_eq!(Duration::nanoseconds(1001).num_microseconds(), Some(1));\n+        assert_eq!(Duration::nanoseconds(-999).num_microseconds(), Some(0));\n+        assert_eq!(Duration::nanoseconds(-1001).num_microseconds(), Some(-1));\n+        assert_eq!(Duration::new(1, 2, 3_004_005).num_microseconds(), Some(86402_003_004));\n+        assert_eq!(Duration::new(-1, -2, -3_004_005).num_microseconds(), Some(-86402_003_004));\n+        assert_eq!(Duration::microseconds(i32::MAX).num_microseconds(), Some(i32::MAX as i64));\n+        assert_eq!(Duration::microseconds(i32::MIN).num_microseconds(), Some(i32::MIN as i64));\n+        assert_eq!(MAX.num_microseconds(), None);\n+        assert_eq!(MIN.num_microseconds(), None);\n+\n+        // overflow checks\n+        static MICROS_PER_DAY: i64 = 86400_000_000;\n+        assert_eq!(Duration::days((i64::MAX / MICROS_PER_DAY) as i32).num_microseconds(),\n+                   Some(i64::MAX / MICROS_PER_DAY * MICROS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MIN / MICROS_PER_DAY) as i32).num_microseconds(),\n+                   Some(i64::MIN / MICROS_PER_DAY * MICROS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MAX / MICROS_PER_DAY + 1) as i32).num_microseconds(), None);\n+        assert_eq!(Duration::days((i64::MIN / MICROS_PER_DAY - 1) as i32).num_microseconds(), None);\n+    }\n+\n+    #[test]\n+    fn test_duration_num_nanoseconds() {\n+        assert_eq!(Duration::zero().num_nanoseconds(), Some(0));\n+        assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n+        assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n+        assert_eq!(Duration::new(1, 2, 3_004_005).num_nanoseconds(), Some(86402_003_004_005));\n+        assert_eq!(Duration::new(-1, -2, -3_004_005).num_nanoseconds(), Some(-86402_003_004_005));\n+        assert_eq!(Duration::nanoseconds(i32::MAX).num_nanoseconds(), Some(i32::MAX as i64));\n+        assert_eq!(Duration::nanoseconds(i32::MIN).num_nanoseconds(), Some(i32::MIN as i64));\n+        assert_eq!(MAX.num_nanoseconds(), None);\n+        assert_eq!(MIN.num_nanoseconds(), None);\n+\n+        // overflow checks\n+        static NANOS_PER_DAY: i64 = 86400_000_000_000;\n+        assert_eq!(Duration::days((i64::MAX / NANOS_PER_DAY) as i32).num_nanoseconds(),\n+                   Some(i64::MAX / NANOS_PER_DAY * NANOS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MIN / NANOS_PER_DAY) as i32).num_nanoseconds(),\n+                   Some(i64::MIN / NANOS_PER_DAY * NANOS_PER_DAY));\n+        assert_eq!(Duration::days((i64::MAX / NANOS_PER_DAY + 1) as i32).num_nanoseconds(), None);\n+        assert_eq!(Duration::days((i64::MIN / NANOS_PER_DAY - 1) as i32).num_nanoseconds(), None);\n+    }\n+\n     #[test]\n     fn test_duration_checked_ops() {\n         assert_eq!(Duration::days(MAX_DAYS).checked_add(&Duration::seconds(86399)),\n@@ -393,9 +633,9 @@ mod tests {\n \n     #[test]\n     fn test_duration_mul() {\n-        assert_eq!(zero() * i32::MAX, zero());\n-        assert_eq!(zero() * i32::MIN, zero());\n-        assert_eq!(Duration::nanoseconds(1) * 0, zero());\n+        assert_eq!(Duration::zero() * i32::MAX, Duration::zero());\n+        assert_eq!(Duration::zero() * i32::MIN, Duration::zero());\n+        assert_eq!(Duration::nanoseconds(1) * 0, Duration::zero());\n         assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n         assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n         assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n@@ -408,8 +648,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_div() {\n-        assert_eq!(zero() / i32::MAX, zero());\n-        assert_eq!(zero() / i32::MIN, zero());\n+        assert_eq!(Duration::zero() / i32::MAX, Duration::zero());\n+        assert_eq!(Duration::zero() / i32::MIN, Duration::zero());\n         assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n         assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n         assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n@@ -418,14 +658,18 @@ mod tests {\n \n     #[test]\n     fn test_duration_fmt() {\n-        assert_eq!(zero().to_string(), \"PT0S\".to_string());\n+        assert_eq!(Duration::zero().to_string(), \"PT0S\".to_string());\n         assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n         assert_eq!(Duration::days(-42).to_string(), \"P-42D\".to_string());\n         assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());\n-        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0,042S\".to_string());\n-        assert_eq!(Duration::microseconds(42).to_string(), \"PT0,000042S\".to_string());\n-        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0,000000042S\".to_string());\n+        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0.042S\".to_string());\n+        assert_eq!(Duration::microseconds(42).to_string(), \"PT0.000042S\".to_string());\n+        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0.000000042S\".to_string());\n         assert_eq!((Duration::days(7) + Duration::milliseconds(6543)).to_string(),\n-                   \"P7DT6,543S\".to_string());\n+                   \"P7DT6.543S\".to_string());\n+\n+        // the format specifier should have no effect on `Duration`\n+        assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n+                   \"P1DT2.345S\".to_string());\n     }\n }"}]}