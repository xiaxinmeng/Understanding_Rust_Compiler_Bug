{"sha": "764b8615e9149431d8790e3c07cb663642fe393d", "node_id": "C_kwDOAAsO6NoAKDc2NGI4NjE1ZTkxNDk0MzFkODc5MGUzYzA3Y2I2NjM2NDJmZTM5M2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-28T01:37:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-28T01:37:09Z"}, "message": "Auto merge of #97433 - GuillaumeGomez:rm-refcell-context, r=notriddle\n\nPass Context as a &mut to allow to remove RefCell fields\n\nFixes #90323.\n\nr? `@notriddle`", "tree": {"sha": "e6e5ce4208e295cc755c022ffc9b961e1637b6e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6e5ce4208e295cc755c022ffc9b961e1637b6e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/764b8615e9149431d8790e3c07cb663642fe393d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/764b8615e9149431d8790e3c07cb663642fe393d", "html_url": "https://github.com/rust-lang/rust/commit/764b8615e9149431d8790e3c07cb663642fe393d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/764b8615e9149431d8790e3c07cb663642fe393d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2aae8020c71fec7ab5ba59c20fe0c127a06e0a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/2aae8020c71fec7ab5ba59c20fe0c127a06e0a64", "html_url": "https://github.com/rust-lang/rust/commit/2aae8020c71fec7ab5ba59c20fe0c127a06e0a64"}, {"sha": "6ab8edb931c6d8959db162570a370a19aac9552d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab8edb931c6d8959db162570a370a19aac9552d", "html_url": "https://github.com/rust-lang/rust/commit/6ab8edb931c6d8959db162570a370a19aac9552d"}], "stats": {"total": 239, "additions": 128, "deletions": 111}, "files": [{"sha": "c5dbf8aa754e98416f18345d69562df7dfa1ac24", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=764b8615e9149431d8790e3c07cb663642fe393d", "patch": "@@ -55,9 +55,9 @@ pub(crate) struct Context<'tcx> {\n     pub(super) render_redirect_pages: bool,\n     /// Tracks section IDs for `Deref` targets so they match in both the main\n     /// body and the sidebar.\n-    pub(super) deref_id_map: RefCell<FxHashMap<DefId, String>>,\n+    pub(super) deref_id_map: FxHashMap<DefId, String>,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n-    pub(super) id_map: RefCell<IdMap>,\n+    pub(super) id_map: IdMap,\n     /// Shared mutable state.\n     ///\n     /// Issue for improving the situation: [#82381][]\n@@ -72,7 +72,7 @@ pub(crate) struct Context<'tcx> {\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Context<'_>, 144);\n+rustc_data_structures::static_assert_size!(Context<'_>, 128);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n pub(crate) struct SharedContext<'tcx> {\n@@ -155,9 +155,8 @@ impl<'tcx> Context<'tcx> {\n         self.shared.tcx.sess\n     }\n \n-    pub(super) fn derive_id(&self, id: String) -> String {\n-        let mut map = self.id_map.borrow_mut();\n-        map.derive(id)\n+    pub(super) fn derive_id(&mut self, id: String) -> String {\n+        self.id_map.derive(id)\n     }\n \n     /// String representation of how to get back to the root path of the 'doc/'\n@@ -166,7 +165,7 @@ impl<'tcx> Context<'tcx> {\n         \"../\".repeat(self.current.len())\n     }\n \n-    fn render_item(&self, it: &clean::Item, is_module: bool) -> String {\n+    fn render_item(&mut self, it: &clean::Item, is_module: bool) -> String {\n         let mut title = String::new();\n         if !is_module {\n             title.push_str(it.name.unwrap().as_str());\n@@ -203,23 +202,26 @@ impl<'tcx> Context<'tcx> {\n         };\n \n         if !self.render_redirect_pages {\n+            let clone_shared = Rc::clone(&self.shared);\n             let page = layout::Page {\n                 css_class: tyname_s,\n                 root_path: &self.root_path(),\n-                static_root_path: self.shared.static_root_path.as_deref(),\n+                static_root_path: clone_shared.static_root_path.as_deref(),\n                 title: &title,\n                 description: &desc,\n                 keywords: &keywords,\n-                resource_suffix: &self.shared.resource_suffix,\n+                resource_suffix: &clone_shared.resource_suffix,\n                 extra_scripts: &[],\n                 static_extra_scripts: &[],\n             };\n+            let mut page_buffer = Buffer::html();\n+            print_item(self, it, &mut page_buffer, &page);\n             layout::render(\n-                &self.shared.layout,\n+                &clone_shared.layout,\n                 &page,\n                 |buf: &mut _| print_sidebar(self, it, buf),\n-                |buf: &mut _| print_item(self, it, buf, &page),\n-                &self.shared.style_files,\n+                move |buf: &mut Buffer| buf.push_buffer(page_buffer),\n+                &clone_shared.style_files,\n             )\n         } else {\n             if let Some(&(ref names, ty)) = self.cache().paths.get(&it.item_id.expect_def_id()) {\n@@ -512,8 +514,8 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             current: Vec::new(),\n             dst,\n             render_redirect_pages: false,\n-            id_map: RefCell::new(id_map),\n-            deref_id_map: RefCell::new(FxHashMap::default()),\n+            id_map,\n+            deref_id_map: FxHashMap::default(),\n             shared: Rc::new(scx),\n             include_sources,\n         };\n@@ -528,7 +530,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n             // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n             Rc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-            write_shared(&cx, &krate, index, &md_opts)?;\n+            write_shared(&mut cx, &krate, index, &md_opts)?;\n             Rc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n         }\n \n@@ -540,8 +542,8 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             current: self.current.clone(),\n             dst: self.dst.clone(),\n             render_redirect_pages: self.render_redirect_pages,\n-            deref_id_map: RefCell::new(FxHashMap::default()),\n-            id_map: RefCell::new(IdMap::new()),\n+            deref_id_map: FxHashMap::default(),\n+            id_map: IdMap::new(),\n             shared: Rc::clone(&self.shared),\n             include_sources: self.include_sources,\n         }\n@@ -557,31 +559,32 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         if !root_path.ends_with('/') {\n             root_path.push('/');\n         }\n+        let shared = Rc::clone(&self.shared);\n         let mut page = layout::Page {\n             title: \"List of all items in this crate\",\n             css_class: \"mod\",\n             root_path: \"../\",\n-            static_root_path: self.shared.static_root_path.as_deref(),\n+            static_root_path: shared.static_root_path.as_deref(),\n             description: \"List of all items in this crate\",\n             keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.shared.resource_suffix,\n+            resource_suffix: &shared.resource_suffix,\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if self.shared.cache.crate_version.is_some() {\n+        let sidebar = if shared.cache.crate_version.is_some() {\n             format!(\"<h2 class=\\\"location\\\">Crate {}</h2>\", crate_name)\n         } else {\n             String::new()\n         };\n-        let all = self.shared.all.replace(AllTypes::new());\n+        let all = shared.all.replace(AllTypes::new());\n         let v = layout::render(\n-            &self.shared.layout,\n+            &shared.layout,\n             &page,\n             sidebar,\n             |buf: &mut Buffer| all.print(buf),\n-            &self.shared.style_files,\n+            &shared.style_files,\n         );\n-        self.shared.fs.write(final_file, v)?;\n+        shared.fs.write(final_file, v)?;\n \n         // Generating settings page.\n         page.title = \"Rustdoc settings\";\n@@ -590,7 +593,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n         let sidebar = \"<h2 class=\\\"location\\\">Settings</h2><div class=\\\"sidebar-elems\\\"></div>\";\n         let v = layout::render(\n-            &self.shared.layout,\n+            &shared.layout,\n             &page,\n             sidebar,\n             |buf: &mut Buffer| {\n@@ -613,33 +616,36 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                     suffix = page.resource_suffix,\n                 )\n             },\n-            &self.shared.style_files,\n+            &shared.style_files,\n         );\n-        self.shared.fs.write(settings_file, v)?;\n+        shared.fs.write(settings_file, v)?;\n \n-        if self.shared.layout.scrape_examples_extension {\n+        if shared.layout.scrape_examples_extension {\n             page.title = \"About scraped examples\";\n             page.description = \"How the scraped examples feature works in Rustdoc\";\n             let v = layout::render(\n-                &self.shared.layout,\n+                &shared.layout,\n                 &page,\n                 \"\",\n-                scrape_examples_help(&*self.shared),\n-                &self.shared.style_files,\n+                scrape_examples_help(&*shared),\n+                &shared.style_files,\n             );\n-            self.shared.fs.write(scrape_examples_help_file, v)?;\n+            shared.fs.write(scrape_examples_help_file, v)?;\n         }\n \n-        if let Some(ref redirections) = self.shared.redirections {\n+        if let Some(ref redirections) = shared.redirections {\n             if !redirections.borrow().is_empty() {\n                 let redirect_map_path =\n                     self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n                 let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n-                self.shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n-                self.shared.fs.write(redirect_map_path, paths)?;\n+                shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n+                shared.fs.write(redirect_map_path, paths)?;\n             }\n         }\n \n+        // No need for it anymore.\n+        drop(shared);\n+\n         // Flush pending errors.\n         Rc::get_mut(&mut self.shared).unwrap().fs.close();\n         let nb_errors =\n@@ -662,7 +668,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         if !self.render_redirect_pages {\n             self.render_redirect_pages = item.is_stripped();\n         }\n-        let scx = &self.shared;\n         let item_name = item.name.unwrap();\n         self.dst.push(&*item_name.as_str());\n         self.current.push(item_name);\n@@ -674,7 +679,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         if !buf.is_empty() {\n             self.shared.ensure_dir(&self.dst)?;\n             let joint_dst = self.dst.join(\"index.html\");\n-            scx.fs.write(joint_dst, buf)?;\n+            self.shared.fs.write(joint_dst, buf)?;\n         }\n \n         // Render sidebar-items.js used throughout this module.\n@@ -684,7 +689,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             let items = self.build_sidebar_items(module);\n             let js_dst = self.dst.join(&format!(\"sidebar-items{}.js\", self.shared.resource_suffix));\n             let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n-            scx.fs.write(js_dst, v)?;\n+            self.shared.fs.write(js_dst, v)?;\n         }\n         Ok(())\n     }"}, {"sha": "eefb2c2358fbd60721eaa5c93ce0a76389163788", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=764b8615e9149431d8790e3c07cb663642fe393d", "patch": "@@ -42,6 +42,7 @@ use std::fmt;\n use std::fs;\n use std::iter::Peekable;\n use std::path::PathBuf;\n+use std::rc::Rc;\n use std::str;\n use std::string::ToString;\n \n@@ -364,7 +365,7 @@ fn scrape_examples_help(shared: &SharedContext<'_>) -> String {\n \n fn document(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     item: &clean::Item,\n     parent: Option<&clean::Item>,\n     heading_offset: HeadingOffset,\n@@ -383,19 +384,18 @@ fn document(\n /// Render md_text as markdown.\n fn render_markdown(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     md_text: &str,\n     links: Vec<RenderedLink>,\n     heading_offset: HeadingOffset,\n ) {\n-    let mut ids = cx.id_map.borrow_mut();\n     write!(\n         w,\n         \"<div class=\\\"docblock\\\">{}</div>\",\n         Markdown {\n             content: md_text,\n             links: &links,\n-            ids: &mut ids,\n+            ids: &mut cx.id_map,\n             error_codes: cx.shared.codes,\n             edition: cx.shared.edition(),\n             playground: &cx.shared.playground,\n@@ -410,7 +410,7 @@ fn render_markdown(\n fn document_short(\n     w: &mut Buffer,\n     item: &clean::Item,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     link: AssocItemLink<'_>,\n     parent: &clean::Item,\n     show_def_docs: bool,\n@@ -439,7 +439,7 @@ fn document_short(\n fn document_full_collapsible(\n     w: &mut Buffer,\n     item: &clean::Item,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     heading_offset: HeadingOffset,\n ) {\n     document_full_inner(w, item, cx, true, heading_offset);\n@@ -448,7 +448,7 @@ fn document_full_collapsible(\n fn document_full(\n     w: &mut Buffer,\n     item: &clean::Item,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     heading_offset: HeadingOffset,\n ) {\n     document_full_inner(w, item, cx, false, heading_offset);\n@@ -457,7 +457,7 @@ fn document_full(\n fn document_full_inner(\n     w: &mut Buffer,\n     item: &clean::Item,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     is_collapsible: bool,\n     heading_offset: HeadingOffset,\n ) {\n@@ -493,7 +493,7 @@ fn document_full_inner(\n /// * Required features (through the `doc_cfg` feature)\n fn document_item_info(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     item: &clean::Item,\n     parent: Option<&clean::Item>,\n ) {\n@@ -522,7 +522,7 @@ fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<Strin\n /// the item's documentation.\n fn short_item_info(\n     item: &clean::Item,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     parent: Option<&clean::Item>,\n ) -> Vec<String> {\n     let mut extra_info = vec![];\n@@ -550,10 +550,9 @@ fn short_item_info(\n \n         if let Some(note) = note {\n             let note = note.as_str();\n-            let mut ids = cx.id_map.borrow_mut();\n             let html = MarkdownHtml(\n                 note,\n-                &mut ids,\n+                &mut cx.id_map,\n                 error_codes,\n                 cx.shared.edition(),\n                 &cx.shared.playground,\n@@ -601,7 +600,7 @@ fn short_item_info(\n // Render the list of items inside one of the sections \"Trait Implementations\",\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n fn render_impls(\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     w: &mut Buffer,\n     impls: &[&&Impl],\n     containing_item: &clean::Item,\n@@ -994,7 +993,7 @@ impl<'a> AssocItemLink<'a> {\n \n fn render_assoc_items(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n@@ -1006,14 +1005,15 @@ fn render_assoc_items(\n \n fn render_assoc_items_inner(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n     derefs: &mut FxHashSet<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n-    let cache = cx.cache();\n+    let shared = Rc::clone(&cx.shared);\n+    let cache = &shared.cache;\n     let Some(v) = cache.impls.get(&it) else { return };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n@@ -1032,7 +1032,7 @@ fn render_assoc_items_inner(\n                 let id =\n                     cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n                 if let Some(def_id) = type_.def_id(cx.cache()) {\n-                    cx.deref_id_map.borrow_mut().insert(def_id, id.clone());\n+                    cx.deref_id_map.insert(def_id, id.clone());\n                 }\n                 write!(\n                     tmp_buf,\n@@ -1138,7 +1138,7 @@ fn render_assoc_items_inner(\n \n fn render_deref_methods(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n@@ -1285,7 +1285,7 @@ struct ImplRenderingParameters {\n \n fn render_impl(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     i: &Impl,\n     parent: &clean::Item,\n     link: AssocItemLink<'_>,\n@@ -1294,7 +1294,8 @@ fn render_impl(\n     aliases: &[String],\n     rendering_params: ImplRenderingParameters,\n ) {\n-    let cache = cx.cache();\n+    let shared = Rc::clone(&cx.shared);\n+    let cache = &shared.cache;\n     let traits = &cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n     let mut close_tags = String::new();\n@@ -1307,7 +1308,7 @@ fn render_impl(\n     fn doc_impl_item(\n         boring: &mut Buffer,\n         interesting: &mut Buffer,\n-        cx: &Context<'_>,\n+        cx: &mut Context<'_>,\n         item: &clean::Item,\n         parent: &clean::Item,\n         containing_item: &clean::Item,\n@@ -1520,7 +1521,7 @@ fn render_impl(\n     fn render_default_items(\n         boring: &mut Buffer,\n         interesting: &mut Buffer,\n-        cx: &Context<'_>,\n+        cx: &mut Context<'_>,\n         t: &clean::Trait,\n         i: &clean::Impl,\n         parent: &clean::Item,\n@@ -1599,14 +1600,13 @@ fn render_impl(\n         }\n \n         if let Some(ref dox) = i.impl_item.collapsed_doc_value() {\n-            let mut ids = cx.id_map.borrow_mut();\n             write!(\n                 w,\n                 \"<div class=\\\"docblock\\\">{}</div>\",\n                 Markdown {\n                     content: &*dox,\n                     links: &i.impl_item.links(cx),\n-                    ids: &mut ids,\n+                    ids: &mut cx.id_map,\n                     error_codes: cx.shared.codes,\n                     edition: cx.shared.edition(),\n                     playground: &cx.shared.playground,\n@@ -1664,7 +1664,7 @@ fn render_rightside(\n \n pub(crate) fn render_impl_summary(\n     w: &mut Buffer,\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     i: &Impl,\n     parent: &clean::Item,\n     containing_item: &clean::Item,\n@@ -2092,10 +2092,8 @@ fn sidebar_deref_methods(\n                 })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n-                let map;\n                 let id = if let Some(target_def_id) = real_target.def_id(c) {\n-                    map = cx.deref_id_map.borrow();\n-                    map.get(&target_def_id).expect(\"Deref section without derived id\")\n+                    cx.deref_id_map.get(&target_def_id).expect(\"Deref section without derived id\")\n                 } else {\n                     \"deref-methods\"\n                 };\n@@ -2641,14 +2639,14 @@ const MAX_FULL_EXAMPLES: usize = 5;\n const NUM_VISIBLE_LINES: usize = 10;\n \n /// Generates the HTML for example call locations generated via the --scrape-examples flag.\n-fn render_call_locations(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item) {\n+fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item) {\n     let tcx = cx.tcx();\n     let def_id = item.item_id.expect_def_id();\n     let key = tcx.def_path_hash(def_id);\n     let Some(call_locations) = cx.shared.call_locations.get(&key) else { return };\n \n     // Generate a unique ID so users can link to this section for a given method\n-    let id = cx.id_map.borrow_mut().derive(\"scraped-examples\");\n+    let id = cx.id_map.derive(\"scraped-examples\");\n     write!(\n         w,\n         \"<div class=\\\"docblock scraped-example-list\\\">\\"}, {"sha": "dcf36b5e865b9d070be9fdd5f1b038963ec08f41", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=764b8615e9149431d8790e3c07cb663642fe393d", "patch": "@@ -2,6 +2,7 @@ use clean::AttributesExt;\n \n use std::cmp::Ordering;\n use std::fmt;\n+use std::rc::Rc;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n@@ -60,7 +61,12 @@ struct ItemVars<'a> {\n     src_href: Option<&'a str>,\n }\n \n-pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, page: &Page<'_>) {\n+pub(super) fn print_item(\n+    cx: &mut Context<'_>,\n+    item: &clean::Item,\n+    buf: &mut Buffer,\n+    page: &Page<'_>,\n+) {\n     debug_assert!(!item.is_stripped());\n     let typ = match *item.kind {\n         clean::ModuleItem(_) => {\n@@ -187,7 +193,7 @@ fn toggle_close(w: &mut Buffer) {\n     w.write_str(\"</details>\");\n }\n \n-fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n+fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n     document(w, cx, item, None, HeadingOffset::H2);\n \n     let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n@@ -344,22 +350,22 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 let add = if stab.is_some() { \" \" } else { \"\" };\n \n                 w.write_str(ITEM_TABLE_ROW_OPEN);\n+                let id = match import.kind {\n+                    clean::ImportKind::Simple(s) => {\n+                        format!(\" id=\\\"{}\\\"\", cx.derive_id(format!(\"reexport.{}\", s)))\n+                    }\n+                    clean::ImportKind::Glob => String::new(),\n+                };\n                 write!(\n                     w,\n                     \"<div class=\\\"item-left {stab}{add}import-item\\\"{id}>\\\n                          <code>{vis}{imp}</code>\\\n                      </div>\\\n                      <div class=\\\"item-right docblock-short\\\">{stab_tags}</div>\",\n                     stab = stab.unwrap_or_default(),\n-                    add = add,\n                     vis = myitem.visibility.print_with_space(myitem.item_id, cx),\n                     imp = import.print(cx),\n                     stab_tags = stab_tags.unwrap_or_default(),\n-                    id = match import.kind {\n-                        clean::ImportKind::Simple(s) =>\n-                            format!(\" id=\\\"{}\\\"\", cx.derive_id(format!(\"reexport.{}\", s))),\n-                        clean::ImportKind::Glob => String::new(),\n-                    },\n                 );\n                 w.write_str(ITEM_TABLE_ROW_CLOSE);\n             }\n@@ -464,7 +470,7 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n     tags\n }\n \n-fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n+fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header = it.fn_header(cx.tcx()).expect(\"printing a function which isn't a function\");\n     let constness = print_constness_with_space(&header.constness, it.const_stability(cx.tcx()));\n     let unsafety = header.unsafety.print_with_space();\n@@ -507,7 +513,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n-fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Trait) {\n     let bounds = bounds(&t.bounds, false, cx);\n     let required_types = t.items.iter().filter(|m| m.is_ty_associated_type()).collect::<Vec<_>>();\n     let provided_types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n@@ -674,7 +680,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         )\n     }\n \n-    fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n+    fn trait_item(w: &mut Buffer, cx: &mut Context<'_>, m: &clean::Item, t: &clean::Item) {\n         let name = m.name.unwrap();\n         info!(\"Documenting {} on {:?}\", name, t.name);\n         let item_type = m.type_();\n@@ -791,14 +797,15 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All);\n \n-    let cache = cx.cache();\n+    let cloned_shared = Rc::clone(&cx.shared);\n+    let cache = &cloned_shared.cache;\n     let mut extern_crates = FxHashSet::default();\n     if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n         for implementor in implementors {\n-            if let Some(did) = implementor.inner_impl().for_.without_borrowed_ref().def_id(cx.cache()) &&\n+            if let Some(did) = implementor.inner_impl().for_.without_borrowed_ref().def_id(cache) &&\n                 !did.is_local() {\n                 extern_crates.insert(did.krate);\n             }\n@@ -996,7 +1003,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     );\n }\n \n-fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n+fn item_trait_alias(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"trait-alias\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n@@ -1020,7 +1027,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n-fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n+fn item_opaque_ty(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"opaque\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n@@ -1044,7 +1051,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n-fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n+fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n@@ -1073,7 +1080,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n     document_type_layout(w, cx, def_id);\n }\n \n-fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n+fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Union) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"union\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n@@ -1135,7 +1142,7 @@ fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]\n     }\n }\n \n-fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n+fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     let count_variants = e.variants().count();\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"enum\", |w| {\n@@ -1283,7 +1290,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n     document_type_layout(w, cx, def_id);\n }\n \n-fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n+fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Macro) {\n     wrap_into_docblock(w, |w| {\n         highlight::render_with_highlighting(\n             &t.source,\n@@ -1300,7 +1307,7 @@ fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Mac\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n-fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n+fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n     wrap_into_docblock(w, |w| {\n         let name = it.name.expect(\"proc-macros always have names\");\n         match m.kind {\n@@ -1332,12 +1339,12 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None, HeadingOffset::H2);\n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n-fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n+fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"const\", |w| {\n             render_attributes_in_code(w, it);\n@@ -1377,7 +1384,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n-fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n+fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Struct) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"struct\", |w| {\n             render_attributes_in_code(w, it);\n@@ -1430,7 +1437,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     document_type_layout(w, cx, def_id);\n }\n \n-fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n+fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Static) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"static\", |w| {\n             render_attributes_in_code(w, it);\n@@ -1447,7 +1454,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n     wrap_into_docblock(w, |w| {\n         wrap_item(w, \"foreigntype\", |w| {\n             w.write_str(\"extern {\\n\");\n@@ -1466,7 +1473,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n }\n \n-fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n+fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None, HeadingOffset::H2)\n }\n \n@@ -1579,7 +1586,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cx: &Context<'_>) -> O\n }\n \n fn render_implementor(\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     implementor: &Impl,\n     trait_: &clean::Item,\n     w: &mut Buffer,"}, {"sha": "325d3a3143426c9539452b35d0dd3f563c8ccc65", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=764b8615e9149431d8790e3c07cb663642fe393d", "patch": "@@ -5,6 +5,7 @@ use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::lazy::SyncLazy as Lazy;\n use std::path::{Component, Path, PathBuf};\n+use std::rc::Rc;\n \n use itertools::Itertools;\n use rustc_data_structures::flock;\n@@ -135,7 +136,7 @@ impl Context<'_> {\n }\n \n pub(super) fn write_shared(\n-    cx: &Context<'_>,\n+    cx: &mut Context<'_>,\n     krate: &Crate,\n     search_index: String,\n     options: &RenderOptions,\n@@ -462,15 +463,16 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n             crate::markdown::render(&index_page, md_opts, cx.shared.edition())\n                 .map_err(|e| Error::new(e, &index_page))?;\n         } else {\n+            let shared = Rc::clone(&cx.shared);\n             let dst = cx.dst.join(\"index.html\");\n             let page = layout::Page {\n                 title: \"Index of crates\",\n                 css_class: \"mod\",\n                 root_path: \"./\",\n-                static_root_path: cx.shared.static_root_path.as_deref(),\n+                static_root_path: shared.static_root_path.as_deref(),\n                 description: \"List of crates\",\n                 keywords: BASIC_KEYWORDS,\n-                resource_suffix: &cx.shared.resource_suffix,\n+                resource_suffix: &shared.resource_suffix,\n                 extra_scripts: &[],\n                 static_extra_scripts: &[],\n             };\n@@ -490,8 +492,8 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n                     })\n                     .collect::<String>()\n             );\n-            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.style_files);\n-            cx.shared.fs.write(dst, v)?;\n+            let v = layout::render(&shared.layout, &page, \"\", content, &shared.style_files);\n+            shared.fs.write(dst, v)?;\n         }\n     }\n "}, {"sha": "524c90e1f4d644f62e6d37454595150462c96e89", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/764b8615e9149431d8790e3c07cb663642fe393d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=764b8615e9149431d8790e3c07cb663642fe393d", "patch": "@@ -6,15 +6,18 @@ use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::{Context, BASIC_KEYWORDS};\n use crate::visit::DocVisitor;\n+\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n+\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n+use std::rc::Rc;\n \n pub(crate) fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error> {\n     info!(\"emitting source files\");\n@@ -174,15 +177,16 @@ impl SourceCollector<'_, '_> {\n         // Remove the utf-8 BOM if any\n         let contents = contents.strip_prefix('\\u{feff}').unwrap_or(&contents);\n \n+        let shared = Rc::clone(&self.cx.shared);\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n-        clean_path(&self.cx.shared.src_root, &p, false, |component| {\n+        clean_path(&shared.src_root, &p, false, |component| {\n             cur.push(component);\n             root_path.push_str(\"../\");\n         });\n \n-        self.cx.shared.ensure_dir(&cur)?;\n+        shared.ensure_dir(&cur)?;\n \n         let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n         let mut fname = src_fname.clone();\n@@ -195,32 +199,33 @@ impl SourceCollector<'_, '_> {\n             title: &title,\n             css_class: \"source\",\n             root_path: &root_path,\n-            static_root_path: self.cx.shared.static_root_path.as_deref(),\n+            static_root_path: shared.static_root_path.as_deref(),\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.cx.shared.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", self.cx.shared.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", self.cx.shared.resource_suffix)],\n+            resource_suffix: &shared.resource_suffix,\n+            extra_scripts: &[&format!(\"source-files{}\", shared.resource_suffix)],\n+            static_extra_scripts: &[&format!(\"source-script{}\", shared.resource_suffix)],\n         };\n         let v = layout::render(\n-            &self.cx.shared.layout,\n+            &shared.layout,\n             &page,\n             \"\",\n             |buf: &mut _| {\n+                let cx = &mut self.cx;\n                 print_src(\n                     buf,\n                     contents,\n-                    self.cx.shared.edition(),\n+                    cx.shared.edition(),\n                     file_span,\n-                    self.cx,\n+                    cx,\n                     &root_path,\n                     None,\n                     SourceContext::Standalone,\n                 )\n             },\n-            &self.cx.shared.style_files,\n+            &shared.style_files,\n         );\n-        self.cx.shared.fs.write(cur, v)?;\n+        shared.fs.write(cur, v)?;\n         self.emitted_local_sources.insert(p);\n         Ok(())\n     }"}]}