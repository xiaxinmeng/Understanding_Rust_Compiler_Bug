{"sha": "1420272ddc174996c532e14623d9f897ba5e7a9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MjAyNzJkZGMxNzQ5OTZjNTMyZTE0NjIzZDlmODk3YmE1ZTdhOWQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-10T09:16:06Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-22T23:40:06Z"}, "message": "std::rand: full exponential & normal distributions\n\nComplete the implementation of Exp and Normal started by Exp1 and\nStandardNormal by creating types implementing Sample & IndependentSample\nwith the appropriate parameters.", "tree": {"sha": "72a67aac740469f6dd3a32d90cabd241bb57de7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72a67aac740469f6dd3a32d90cabd241bb57de7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1420272ddc174996c532e14623d9f897ba5e7a9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1420272ddc174996c532e14623d9f897ba5e7a9d", "html_url": "https://github.com/rust-lang/rust/commit/1420272ddc174996c532e14623d9f897ba5e7a9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1420272ddc174996c532e14623d9f897ba5e7a9d/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aaef138ff4d717ab723ac024c94c92539b4daa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aaef138ff4d717ab723ac024c94c92539b4daa7", "html_url": "https://github.com/rust-lang/rust/commit/5aaef138ff4d717ab723ac024c94c92539b4daa7"}], "stats": {"total": 136, "additions": 116, "deletions": 20}, "files": [{"sha": "6b23bff4c45702cc376b3b83cfa4323071206c75", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 116, "deletions": 20, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/1420272ddc174996c532e14623d9f897ba5e7a9d/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1420272ddc174996c532e14623d9f897ba5e7a9d/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=1420272ddc174996c532e14623d9f897ba5e7a9d", "patch": "@@ -94,17 +94,6 @@ fn ziggurat<R:Rng>(rng: &mut R,\n ///\n /// Note that this has to be unwrapped before use as an `f64` (using either\n /// `*` or `cast::transmute` is safe).\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::rand::distributions::StandardNormal;\n-///\n-/// fn main() {\n-///     let normal = 2.0 + (*rand::random::<StandardNormal>()) * 3.0;\n-///     println!(\"{} is from a N(2, 9) distribution\", normal)\n-/// }\n-/// ```\n pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n@@ -142,23 +131,52 @@ impl Rand for StandardNormal {\n     }\n }\n \n-/// A wrapper around an `f64` to generate Exp(1) random numbers. Dividing by\n-/// the desired rate `lambda` will give Exp(lambda) distributed random\n-/// numbers.\n-///\n-/// Note that this has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n+/// The `N(mean, std_dev**2)` distribution, i.e. samples from a normal\n+/// distribution with mean `mean` and standard deviation `std_dev`.\n ///\n /// # Example\n ///\n /// ```\n-/// use std::rand::distributions::Exp1;\n+/// use std::rand;\n+/// use std::rand::distributions::{Normal, IndependentSample};\n ///\n /// fn main() {\n-///     let exp2 = (*rand::random::<Exp1>()) * 0.5;\n-///     println!(\"{} is from a Exp(2) distribution\", exp2);\n+///     let normal = Normal::new(2.0, 3.0);\n+///     let v = normal.ind_sample(rand::task_rng());\n+///     println!(\"{} is from a N(2, 9) distribution\", v)\n /// }\n /// ```\n+pub struct Normal {\n+    priv mean: f64,\n+    priv std_dev: f64\n+}\n+\n+impl Normal {\n+    /// Construct a new `Normal` distribution with the given mean and\n+    /// standard deviation. Fails if `std_dev < 0`.\n+    pub fn new(mean: f64, std_dev: f64) -> Normal {\n+        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n+        Normal {\n+            mean: mean,\n+            std_dev: std_dev\n+        }\n+    }\n+}\n+impl Sample<f64> for Normal {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Normal {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        self.mean + self.std_dev * (*rng.gen::<StandardNormal>())\n+    }\n+}\n+\n+/// A wrapper around an `f64` to generate Exp(1) random numbers. Dividing by\n+/// the desired rate `lambda` will give Exp(lambda) distributed random\n+/// numbers.\n+///\n+/// Note that this has to be unwrapped before use as an `f64` (using either\n+/// `*` or `cast::transmute` is safe).\n pub struct Exp1(f64);\n \n // This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n@@ -181,10 +199,53 @@ impl Rand for Exp1 {\n     }\n }\n \n+/// The `Exp(lambda)` distribution; i.e. samples from the exponential\n+/// distribution with rate parameter `lambda`.\n+///\n+/// This distribution has density function: `f(x) = lambda *\n+/// exp(-lambda * x)` for `x > 0`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::rand;\n+/// use std::rand::distributions::{Exp, IndependentSample};\n+///\n+/// fn main() {\n+///     let exp = Exp::new(2.0);\n+///     let v = exp.ind_sample(rand::task_rng());\n+///     println!(\"{} is from a Exp(2) distribution\", v);\n+/// }\n+/// ```\n+pub struct Exp {\n+    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n+    priv lambda_inverse: f64\n+}\n+\n+impl Exp {\n+    /// Construct a new `Exp` with the given shape parameter\n+    /// `lambda`. Fails if `lambda <= 0`.\n+    pub fn new(lambda: f64) -> Exp {\n+        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n+        Exp { lambda_inverse: 1.0 / lambda }\n+    }\n+}\n+\n+impl Sample<f64> for Exp {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Exp {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        (*rng.gen::<Exp1>()) * self.lambda_inverse\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use rand::*;\n     use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n \n     struct ConstRand(uint);\n     impl Rand for ConstRand {\n@@ -200,4 +261,39 @@ mod tests {\n         assert_eq!(*rand_sample.sample(task_rng()), 0);\n         assert_eq!(*rand_sample.ind_sample(task_rng()), 0);\n     }\n+\n+    #[test]\n+    fn test_normal() {\n+        let mut norm = Normal::new(10.0, 10.0);\n+        let rng = task_rng();\n+        for _ in range(0, 1000) {\n+            norm.sample(rng);\n+            norm.ind_sample(rng);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_normal_invalid_sd() {\n+        Normal::new(10.0, -1.0);\n+    }\n+\n+    #[test]\n+    fn test_exp() {\n+        let mut exp = Exp::new(10.0);\n+        let rng = task_rng();\n+        for _ in range(0, 1000) {\n+            assert!(exp.sample(rng) >= 0.0);\n+            assert!(exp.ind_sample(rng) >= 0.0);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_zero() {\n+        Exp::new(0.0);\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_neg() {\n+        Exp::new(-10.0);\n+    }\n }"}]}