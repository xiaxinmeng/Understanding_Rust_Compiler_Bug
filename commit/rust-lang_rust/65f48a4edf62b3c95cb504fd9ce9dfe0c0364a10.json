{"sha": "65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZjQ4YTRlZGY2MmIzYzk1Y2I1MDRmZDljZTlkZmUwYzAzNjRhMTA=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-03T10:45:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-03T10:45:42Z"}, "message": "Rollup merge of #48283 - QuietMisdreavus:rustdoc-readme, r=@GuillaumeGomez\n\nadd readme for librustdoc\n\nIn the same vein as the other compiler-library readmes, here's one for rustdoc! It's mainly a \"how does rustdoc even\" blog-post-style writeup, but i wanted to have something in-repo so people could get a sense of what bits did what.", "tree": {"sha": "b1bac02cddca5ba6e95be6286555397836bd3e0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1bac02cddca5ba6e95be6286555397836bd3e0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJamnzWCRBK7hj4Ov3rIwAAdHIIAAVSFQhrf3hRF3dhr/t5KvFC\nZHdJWkZeLuI/mHQLfPAaghUHKLv0rcRl8urvwkqvOkYJXNnfCxoRa1c+WdzQf2ZY\nzrKeIgJ2RgzyGZWEwsMoR6Buc0HLzFFJsh0XzzHAgSAt01Dr5L5ikfAmiHH15wyS\nzcKwO2N3+GK3S+mQFkxnhkRqO6Pld6rbE52sM5gn08Owoy9j540SQe6wqLRczwbM\n89/3DEpQk8rfapHkpzOls5/hFM3ep+7K/8+G2gO3HE8ZQPd+ziPLw4w6QKYkrW8t\nZFWTNAt+xOCx18zFlNhvQm2htNFb1sv9AQB3Z0WipfYEdKw6Sz5/rEycIqIu0Ho=\n=Iu/R\n-----END PGP SIGNATURE-----\n", "payload": "tree b1bac02cddca5ba6e95be6286555397836bd3e0d\nparent c9b86a91786ca54e898b54f30a6e11546b8e8026\nparent 8d893c1e9e136302a1640035b29e23023f87866e\nauthor kennytm <kennytm@gmail.com> 1520073942 +0800\ncommitter GitHub <noreply@github.com> 1520073942 +0800\n\nRollup merge of #48283 - QuietMisdreavus:rustdoc-readme, r=@GuillaumeGomez\n\nadd readme for librustdoc\n\nIn the same vein as the other compiler-library readmes, here's one for rustdoc! It's mainly a \"how does rustdoc even\" blog-post-style writeup, but i wanted to have something in-repo so people could get a sense of what bits did what.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10", "html_url": "https://github.com/rust-lang/rust/commit/65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b86a91786ca54e898b54f30a6e11546b8e8026", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b86a91786ca54e898b54f30a6e11546b8e8026", "html_url": "https://github.com/rust-lang/rust/commit/c9b86a91786ca54e898b54f30a6e11546b8e8026"}, {"sha": "8d893c1e9e136302a1640035b29e23023f87866e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d893c1e9e136302a1640035b29e23023f87866e", "html_url": "https://github.com/rust-lang/rust/commit/8d893c1e9e136302a1640035b29e23023f87866e"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "b0a5ae3718df3f87685f3ed3c65dcf8b8709f553", "filename": "src/librustdoc/README.md", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10/src%2Flibrustdoc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10/src%2Flibrustdoc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FREADME.md?ref=65f48a4edf62b3c95cb504fd9ce9dfe0c0364a10", "patch": "@@ -0,0 +1,172 @@\n+# The walking tour of rustdoc\n+\n+Rustdoc is implemented entirely within the crate `librustdoc`. After partially compiling a crate to\n+get its AST (technically the HIR map) from rustc, librustdoc performs two major steps past that to\n+render a set of documentation:\n+\n+* \"Clean\" the AST into a form that's more suited to creating documentation (and slightly more\n+  resistant to churn in the compiler).\n+* Use this cleaned AST to render a crate's documentation, one page at a time.\n+\n+Naturally, there's more than just this, and those descriptions simplify out lots of details, but\n+that's the high-level overview.\n+\n+(Side note: this is a library crate! The `rustdoc` binary is crated using the project in\n+`src/tools/rustdoc`. Note that literally all that does is call the `main()` that's in this crate's\n+`lib.rs`, though.)\n+\n+## Cheat sheet\n+\n+* Use `x.py build --stage 1 src/libstd src/tools/rustdoc` to make a useable rustdoc you can run on\n+  other projects.\n+  * Add `src/libtest` to be able to use `rustdoc --test`.\n+  * If you've used `rustup toolchain link local /path/to/build/$TARGET/stage1` previously, then\n+    after the previous build command, `cargo +local doc` will Just Work.\n+* Use `x.py doc --stage 1 src/libstd` to use this rustdoc to generate the standard library docs.\n+  * The completed docs will be available in `build/$TARGET/doc/std`, though the bundle is meant to\n+    be used as though you would copy out the `doc` folder to a web server, since that's where the\n+    CSS/JS and landing page are.\n+* Most of the HTML printing code is in `html/format.rs` and `html/render.rs`. It's in a bunch of\n+  `fmt::Display` implementations and supplementary functions.\n+* The types that got `Display` impls above are defined in `clean/mod.rs`, right next to the custom\n+  `Clean` trait used to process them out of the rustc HIR.\n+* The bits specific to using rustdoc as a test harness are in `test.rs`.\n+* The Markdown renderer is loaded up in `html/markdown.rs`, including functions for extracting\n+  doctests from a given block of Markdown.\n+* The tests on rustdoc *output* are located in `src/test/rustdoc`, where they're handled by the test\n+  runner of rustbuild and the supplementary script `src/etc/htmldocck.py`.\n+* Tests on search index generation are located in `src/test/rustdoc-js`, as a series of JavaScript\n+  files that encode queries on the standard library search index and expected results.\n+\n+## From crate to clean\n+\n+In `core.rs` are two central items: the `DocContext` struct, and the `run_core` function. The latter\n+is where rustdoc calls out to rustc to compile a crate to the point where rustdoc can take over. The\n+former is a state container used when crawling through a crate to gather its documentation.\n+\n+The main process of crate crawling is done in `clean/mod.rs` through several implementations of the\n+`Clean` trait defined within. This is a conversion trait, which defines one method:\n+\n+```rust\n+pub trait Clean<T> {\n+    fn clean(&self, cx: &DocContext) -> T;\n+}\n+```\n+\n+`clean/mod.rs` also defines the types for the \"cleaned\" AST used later on to render documentation\n+pages. Each usually accompanies an implementation of `Clean` that takes some AST or HIR type from\n+rustc and converts it into the appropriate \"cleaned\" type. \"Big\" items like modules or associated\n+items may have some extra processing in its `Clean` implementation, but for the most part these\n+impls are straightforward conversions. The \"entry point\" to this module is the `impl Clean<Crate>\n+for visit_ast::RustdocVisitor`, which is called by `run_core` above.\n+\n+You see, I actually lied a little earlier: There's another AST transformation that happens before\n+the events in `clean/mod.rs`.  In `visit_ast.rs` is the type `RustdocVisitor`, which *actually*\n+crawls a `hir::Crate` to get the first intermediate representation, defined in `doctree.rs`. This\n+pass is mainly to get a few intermediate wrappers around the HIR types and to process visibility\n+and inlining. This is where `#[doc(inline)]`, `#[doc(no_inline)]`, and `#[doc(hidden)]` are\n+processed, as well as the logic for whether a `pub use` should get the full page or a \"Reexport\"\n+line in the module page.\n+\n+The other major thing that happens in `clean/mod.rs` is the collection of doc comments and\n+`#[doc=\"\"]` attributes into a separate field of the Attributes struct, present on anything that gets\n+hand-written documentation. This makes it easier to collect this documentation later in the process.\n+\n+The primary output of this process is a clean::Crate with a tree of Items which describe the\n+publicly-documentable items in the target crate.\n+\n+### Hot potato\n+\n+Before moving on to the next major step, a few important \"passes\" occur over the documentation.\n+These do things like combine the separate \"attributes\" into a single string and strip leading\n+whitespace to make the document easier on the markdown parser, or drop items that are not public or\n+deliberately hidden with `#[doc(hidden)]`. These are all implemented in the `passes/` directory, one\n+file per pass. By default, all of these passes are run on a crate, but the ones regarding dropping\n+private/hidden items can be bypassed by passing `--document-private-items` to rustdoc.\n+\n+(Strictly speaking, you can fine-tune the passes run and even add your own, but [we're trying to\n+deprecate that][44136]. If you need finer-grain control over these passes, please let us know!)\n+\n+[44136]: https://github.com/rust-lang/rust/issues/44136\n+\n+## From clean to crate\n+\n+This is where the \"second phase\" in rustdoc begins. This phase primarily lives in the `html/`\n+folder, and it all starts with `run()` in `html/render.rs`. This code is responsible for setting up\n+the `Context`, `SharedContext`, and `Cache` which are used during rendering, copying out the static\n+files which live in every rendered set of documentation (things like the fonts, CSS, and JavaScript\n+that live in `html/static/`), creating the search index, and printing out the source code rendering,\n+before beginning the process of rendering all the documentation for the crate.\n+\n+Several functions implemented directly on `Context` take the `clean::Crate` and set up some state\n+between rendering items or recursing on a module's child items. From here the \"page rendering\"\n+begins, via an enormous `write!()` call in `html/layout.rs`. The parts that actually generate HTML\n+from the items and documentation occurs within a series of `std::fmt::Display` implementations and\n+functions that pass around a `&mut std::fmt::Formatter`. The top-level implementation that writes\n+out the page body is the `impl<'a> fmt::Display for Item<'a>` in `html/render.rs`, which switches\n+out to one of several `item_*` functions based on the kind of `Item` being rendered.\n+\n+Depending on what kind of rendering code you're looking for, you'll probably find it either in\n+`html/render.rs` for major items like \"what sections should I print for a struct page\" or\n+`html/format.rs` for smaller component pieces like \"how should I print a where clause as part of\n+some other item\".\n+\n+Whenever rustdoc comes across an item that should print hand-written documentation alongside, it\n+calls out to `html/markdown.rs` which interfaces with the Markdown parser. This is exposed as a\n+series of types that wrap a string of Markdown, and implement `fmt::Display` to emit HTML text. It\n+takes special care to enable certain features like footnotes and tables and add syntax highlighting\n+to Rust code blocks (via `html/highlight.rs`) before running the Markdown parser. There's also a\n+function in here (`find_testable_code`) that specifically scans for Rust code blocks so the\n+test-runner code can find all the doctests in the crate.\n+\n+### From soup to nuts\n+\n+(alternate title: [\"An unbroken thread that stretches from those first `Cell`s to us\"][video])\n+\n+[video]: https://www.youtube.com/watch?v=hOLAGYmUQV0\n+\n+It's important to note that the AST cleaning can ask the compiler for information (crucially,\n+`DocContext` contains a `TyCtxt`), but page rendering cannot. The `clean::Crate` created within\n+`run_core` is passed outside the compiler context before being handed to `html::render::run`. This\n+means that a lot of the \"supplementary data\" that isn't immediately available inside an item's\n+definition, like which trait is the `Deref` trait used by the language, needs to be collected during\n+cleaning, stored in the `DocContext`, and passed along to the `SharedContext` during HTML rendering.\n+This manifests as a bunch of shared state, context variables, and `RefCell`s.\n+\n+Also of note is that some items that come from \"asking the compiler\" don't go directly into the\n+`DocContext` - for example, when loading items from a foreign crate, rustdoc will ask about trait\n+implementations and generate new `Item`s for the impls based on that information. This goes directly\n+into the returned `Crate` rather than roundabout through the `DocContext`. This way, these\n+implementations can be collected alongside the others, right before rendering the HTML.\n+\n+## Other tricks up its sleeve\n+\n+All this describes the process for generating HTML documentation from a Rust crate, but there are\n+couple other major modes that rustdoc runs in. It can also be run on a standalone Markdown file, or\n+it can run doctests on Rust code or standalone Markdown files. For the former, it shortcuts straight\n+to `html/markdown.rs`, optionally including a mode which inserts a Table of Contents to the output\n+HTML.\n+\n+For the latter, rustdoc runs a similar partial-compilation to get relevant documentation in\n+`test.rs`, but instead of going through the full clean and render process, it runs a much simpler\n+crate walk to grab *just* the hand-written documentation. Combined with the aforementioned\n+\"`find_testable_code`\" in `html/markdown.rs`, it builds up a collection of tests to run before\n+handing them off to the libtest test runner. One notable location in `test.rs` is the function\n+`make_test`, which is where hand-written doctests get transformed into something that can be\n+executed.\n+\n+## Dotting i's and crossing t's\n+\n+So that's rustdoc's code in a nutshell, but there's more things in the repo that deal with it. Since\n+we have the full `compiletest` suite at hand, there's a set of tests in `src/test/rustdoc` that make\n+sure the final HTML is what we expect in various situations. These tests also use a supplementary\n+script, `src/etc/htmldocck.py`, that allows it to look through the final HTML using XPath notation\n+to get a precise look at the output. The full description of all the commands available to rustdoc\n+tests is in `htmldocck.py`.\n+\n+In addition, there are separate tests for the search index and rustdoc's ability to query it. The\n+files in `src/test/rustdoc-js` each contain a different search query and the expected results,\n+broken out by search tab. These files are processed by a script in `src/tools/rustdoc-js` and the\n+Node.js runtime. These tests don't have as thorough of a writeup, but a broad example that features\n+results in all tabs can be found in `basic.js`. The basic idea is that you match a given `QUERY`\n+with a set of `EXPECTED` results, complete with the full item path of each item."}]}