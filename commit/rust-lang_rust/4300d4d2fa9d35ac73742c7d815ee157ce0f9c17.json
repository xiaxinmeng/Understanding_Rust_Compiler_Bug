{"sha": "4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMDBkNGQyZmE5ZDM1YWM3Mzc0MmM3ZDgxNWVlMTU3Y2UwZjljMTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-05T19:11:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-05T19:11:04Z"}, "message": "Merge remote-tracking branch 'mozilla/incoming' into issue-5910-dyna-freeze\n\nConflicts:\n\tsrc/libcore/core.rc\n\tsrc/libcore/hashmap.rs\n\tsrc/libcore/num/f32.rs\n\tsrc/libcore/num/f64.rs\n\tsrc/libcore/num/float.rs\n\tsrc/libcore/num/int-template.rs\n\tsrc/libcore/num/num.rs\n\tsrc/libcore/num/strconv.rs\n\tsrc/libcore/num/uint-template.rs\n\tsrc/libcore/ops.rs\n\tsrc/libcore/os.rs\n\tsrc/libcore/prelude.rs\n\tsrc/libcore/rt/mod.rs\n\tsrc/libcore/unstable/lang.rs\n\tsrc/librustc/driver/session.rs\n\tsrc/librustc/middle/astencode.rs\n\tsrc/librustc/middle/borrowck/check_loans.rs\n\tsrc/librustc/middle/borrowck/gather_loans.rs\n\tsrc/librustc/middle/borrowck/loan.rs\n\tsrc/librustc/middle/borrowck/preserve.rs\n\tsrc/librustc/middle/liveness.rs\n\tsrc/librustc/middle/mem_categorization.rs\n\tsrc/librustc/middle/region.rs\n\tsrc/librustc/middle/trans/base.rs\n\tsrc/librustc/middle/trans/inline.rs\n\tsrc/librustc/middle/trans/reachable.rs\n\tsrc/librustc/middle/typeck/check/_match.rs\n\tsrc/librustc/middle/typeck/check/regionck.rs\n\tsrc/librustc/util/ppaux.rs\n\tsrc/libstd/arena.rs\n\tsrc/libstd/ebml.rs\n\tsrc/libstd/json.rs\n\tsrc/libstd/serialize.rs\n\tsrc/libstd/std.rc\n\tsrc/libsyntax/ast_map.rs\n\tsrc/libsyntax/parse/parser.rs\n\tsrc/test/compile-fail/borrowck-uniq-via-box.rs\n\tsrc/test/compile-fail/regions-infer-borrow-scope-within-loop.rs\n\tsrc/test/run-pass/borrowck-nested-calls.rs", "tree": {"sha": "9e5db5a04493a573f280b2c8863d0eaf0ca47c0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e5db5a04493a573f280b2c8863d0eaf0ca47c0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "html_url": "https://github.com/rust-lang/rust/commit/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cb273ed4efb6724b1c713c3ac35d14e52999fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb273ed4efb6724b1c713c3ac35d14e52999fb1", "html_url": "https://github.com/rust-lang/rust/commit/6cb273ed4efb6724b1c713c3ac35d14e52999fb1"}, {"sha": "063851ffa1b8388a0b70446c0209af16264e8181", "url": "https://api.github.com/repos/rust-lang/rust/commits/063851ffa1b8388a0b70446c0209af16264e8181", "html_url": "https://github.com/rust-lang/rust/commit/063851ffa1b8388a0b70446c0209af16264e8181"}], "stats": {"total": 12627, "additions": 7067, "deletions": 5560}, "files": [{"sha": "52370e4a509b0f3a3c642a560fb036aac0262687", "filename": ".gitattributes", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,9 @@\n+[attr]rust text eol=lf whitespace=tab-in-indent,trailing-space,tabwidth=4\n+\n+* text=auto\n+*.cpp rust\n+*.h rust\n+*.rs rust\n+src/rt/msvc/* -whitespace\n+src/rt/vg/* -whitespace\n+src/rt/linenoise/* -whitespace"}, {"sha": "ffbfadaa3391bc3f500c3fffcd9ba95c59693f05", "filename": "COPYRIGHT", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -367,4 +367,3 @@ their own copyright notices and license terms:\n   has chosen for the collective work, enumerated at the top\n   of this file. The only difference is the retention of\n   copyright itself, held by the contributor.\n-"}, {"sha": "d531b9879a9a8b4f0b11eedad688e85b70a87efb", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -241,7 +241,7 @@ $(foreach target,$(CFG_TARGET_TRIPLES),\\\n \n CORELIB_CRATE := $(S)src/libcore/core.rc\n CORELIB_INPUTS := $(wildcard $(addprefix $(S)src/libcore/,        \\\n-                                           core.rc *.rs */*.rs */*/*rs))\n+                                           core.rc *.rs */*.rs */*/*rs */*/*/*rs))\n \n ######################################################################\n # Standard library variables"}, {"sha": "fb2bbb45e7c83508fc4e8d287c17c990cf5f15a1", "filename": "RELEASES.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -250,7 +250,7 @@ Version 0.3  (July 2012)\n       * Slices and fixed-size, interior-allocated vectors\n       * #!-comments for lang versioning, shell execution\n       * Destructors and iface implementation for classes;\n-      \ttype-parameterized classes and class methods\n+        type-parameterized classes and class methods\n       * 'const' type kind for types that can be used to implement\n         shared-memory concurrency patterns\n \n@@ -261,7 +261,7 @@ Version 0.3  (July 2012)\n                  'crust', 'native' (now 'extern'), 'cont' (now 'again')\n \n       * Constructs: do-while loops ('do' repurposed), fn binding,\n-      \t            resources (replaced by destructors)\n+                    resources (replaced by destructors)\n \n    * Compiler reorganization\n       * Syntax-layer of compiler split into separate crate\n@@ -276,7 +276,7 @@ Version 0.3  (July 2012)\n       * Extensive work on libuv interface\n       * Much vector code moved to libraries\n       * Syntax extensions: #line, #col, #file, #mod, #stringify,\n-      \t#include, #include_str, #include_bin\n+        #include, #include_str, #include_bin\n \n    * Tool improvements\n       * Cargo automatically resolves dependencies"}, {"sha": "c3bb28a9e85e949420fd542a1b6ea04693f86e1f", "filename": "doc/README", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FREADME?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1,6 +1,6 @@\n The markdown docs are only generated by make when node is installed (use\n-`make doc`). If you don't have node installed you can generate them yourself. \n-Unfortunately there's no real standard for markdown and all the tools work \n+`make doc`). If you don't have node installed you can generate them yourself.\n+Unfortunately there's no real standard for markdown and all the tools work\n differently. pandoc is one that seems to work well.\n \n To generate an html version of a doc do something like:\n@@ -10,4 +10,4 @@ The syntax for pandoc flavored markdown can be found at:\n http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown\n \n A nice quick reference (for non-pandoc markdown) is at:\n-http://kramdown.rubyforge.org/quickref.html\n\\ No newline at end of file\n+http://kramdown.rubyforge.org/quickref.html"}, {"sha": "ac7125be424d4fcc76835610568a07515c31d121", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1467,8 +1467,8 @@ A complete list of the built-in language items follows:\n   : Elements can be subtracted.\n `mul`\n   : Elements can be multiplied.\n-`quot`\n-  : Elements have a quotient operation.\n+`div`\n+  : Elements have a division operation.\n `rem`\n   : Elements have a remainder operation.\n `neg`\n@@ -1857,7 +1857,7 @@ The default meaning of the operators on standard types is given here.\n     Calls the `mul` method on the `core::ops::Mul` trait.\n `/`\n   : Quotient.\n-    Calls the `quot` method on the `core::ops::Quot` trait.\n+    Calls the `div` method on the `core::ops::Div` trait.\n `%`\n   : Remainder.\n     Calls the `rem` method on the `core::ops::Rem` trait.\n@@ -2393,7 +2393,7 @@ variables in the arm's block, and control enters the block.\n An example of an `match` expression:\n \n \n-~~~~ {.xfail-test}\n+~~~~\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n \n@@ -3351,4 +3351,3 @@ Additional specific influences can be seen from the following languages:\n * The typeclass system of Haskell.\n * The lexical identifier rule of Python.\n * The block syntax of Ruby.\n-"}, {"sha": "b806df5dd20b55114e44c041c5f2cd670c409f24", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -150,11 +150,7 @@ wrapping `malloc` and `free`:\n \n ~~~~\n use core::libc::{c_void, size_t, malloc, free};\n-\n-#[abi = \"rust-intrinsic\"]\n-extern \"rust-intrinsic\" mod rusti {\n-    fn init<T>() -> T;\n-}\n+use core::unstable::intrinsics;\n \n // a wrapper around the handle returned by the foreign code\n pub struct Unique<T> {\n@@ -166,7 +162,8 @@ pub impl<'self, T: Owned> Unique<T> {\n         unsafe {\n             let ptr = malloc(core::sys::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n-            *ptr = value;\n+            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n+            intrinsics::move_val_init(&mut *ptr, value);\n             Unique{ptr: ptr}\n         }\n     }\n@@ -186,7 +183,7 @@ pub impl<'self, T: Owned> Unique<T> {\n impl<T: Owned> Drop for Unique<T> {\n     fn finalize(&self) {\n         unsafe {\n-            let mut x = rusti::init(); // dummy value to swap in\n+            let mut x = intrinsics::init(); // dummy value to swap in\n             x <-> *self.ptr; // moving the object out is needed to call the destructor\n             free(self.ptr as *c_void)\n         }"}, {"sha": "63fa7e06bae77ecf27233db0727c48a317bac981", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -402,4 +402,3 @@ tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n states, invoking `trace_macros!(true)` will automatically print those\n intermediate states out, and passing the flag `--pretty expanded` as a\n command-line argument to the compiler will show the result of expansion.\n-"}, {"sha": "053d9e6d98813d037a4ec6ed847677a9c0bee182", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -511,4 +511,3 @@ The parent task first calls `DuplexStream` to create a pair of bidirectional\n endpoints. It then uses `task::spawn` to create the child task, which captures\n one end of the communication channel.  As a result, both parent and child can\n send and receive data to and from the other.\n-"}, {"sha": "90ae41affc9b9b13d95651e8665fc4eb9f465607", "filename": "doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1006,9 +1006,9 @@ let mut d = @mut 5; // mutable variable, mutable box\n d = @mut 15;\n ~~~~\n \n-A mutable variable and an immutable variable can refer to the same box, given \n-that their types are compatible. Mutability of a box is a property of its type, \n-however, so for example a mutable handle to an immutable box cannot be \n+A mutable variable and an immutable variable can refer to the same box, given\n+that their types are compatible. Mutability of a box is a property of its type,\n+however, so for example a mutable handle to an immutable box cannot be\n assigned a reference to a mutable box.\n \n ~~~~\n@@ -1041,7 +1041,7 @@ let y = x.clone(); // y is a newly allocated box\n let z = x; // no new memory allocated, x can no longer be used\n ~~~~\n \n-Since in owned boxes mutability is a property of the owner, not the \n+Since in owned boxes mutability is a property of the owner, not the\n box, mutable boxes may become immutable when they are moved, and vice-versa.\n \n ~~~~"}, {"sha": "aa44097a337e94852ab6c3f5583a33ef258e8af2", "filename": "doc/version_info.html.template", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Fversion_info.html.template", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/doc%2Fversion_info.html.template", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fversion_info.html.template?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -7,4 +7,3 @@\n   </center>\n \n </div>\n-"}, {"sha": "660793b1c347ec1ea910e28480260dca52e5fd61", "filename": "mk/clean.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -48,7 +48,7 @@ clean-misc:\n \t$(Q)rm -f $(RUSTLLVM_LIB_OBJS) $(RUSTLLVM_OBJS_OBJS) $(RUSTLLVM_DEF)\n \t$(Q)rm -Rf $(DOCS)\n \t$(Q)rm -Rf $(GENERATED)\n-\t$(Q)rm -f tmp/*.log tmp/*.rc tmp/*.rs tmp/*.ok\n+\t$(Q)rm -f tmp/*\n \t$(Q)rm -Rf rust-stage0-*.tar.bz2 $(PKG_NAME)-*.tar.gz dist\n \t$(Q)rm -Rf $(foreach ext, \\\n                  html aux cp fn ky log pdf pg toc tp vr cps, \\"}, {"sha": "f49c75d6acb010405a9dde6e9013b5e9dbc8a086", "filename": "mk/docs.mk", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -16,15 +16,8 @@ DOCS :=\n \n \n ######################################################################\n-# Pandoc (reference-manual related)\n+# Docs, from pandoc, rustdoc (which runs pandoc), and node\n ######################################################################\n-ifeq ($(CFG_PANDOC),)\n-  $(info cfg: no pandoc found, omitting doc/rust.pdf)\n-else\n-\n-  ifeq ($(CFG_NODE),)\n-    $(info cfg: no node found, omitting doc/tutorial.html)\n-  else\n \n doc/rust.css: rust.css\n \t@$(call E, cp: $@)\n@@ -34,6 +27,18 @@ doc/manual.css: manual.css\n \t@$(call E, cp: $@)\n \t$(Q)cp -a $< $@ 2> /dev/null\n \n+ifeq ($(CFG_PANDOC),)\n+  $(info cfg: no pandoc found, omitting docs)\n+  NO_DOCS = 1\n+endif\n+\n+ifeq ($(CFG_NODE),)\n+  $(info cfg: no node found, omitting docs)\n+  NO_DOCS = 1\n+endif\n+\n+ifneq ($(NO_DOCS),1)\n+\n DOCS += doc/rust.html\n doc/rust.html: rust.md doc/version_info.html doc/rust.css doc/manual.css\n \t@$(call E, pandoc: $@)\n@@ -47,19 +52,8 @@ doc/rust.html: rust.md doc/version_info.html doc/rust.css doc/manual.css\n          --css=manual.css \\\n \t     --include-before-body=doc/version_info.html \\\n          --output=$@\n-  endif\n \n-  ifeq ($(CFG_PDFLATEX),)\n-    $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n-  else\n-    ifeq ($(CFG_XETEX),)\n-      $(info cfg: no xetex found, disabling doc/rust.pdf)\n-    else\n-      ifeq ($(CFG_LUATEX),)\n-        $(info cfg: lacking luatex, disabling pdflatex)\n-      else\n-\n-DOCS += doc/rust.pdf\n+DOCS += doc/rust.tex\n doc/rust.tex: rust.md doc/version.md\n \t@$(call E, pandoc: $@)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js $< | \\\n@@ -70,17 +64,6 @@ doc/rust.tex: rust.md doc/version.md\n          --from=markdown --to=latex \\\n          --output=$@\n \n-doc/rust.pdf: doc/rust.tex\n-\t@$(call E, pdflatex: $@)\n-\t$(Q)$(CFG_PDFLATEX) \\\n-        -interaction=batchmode \\\n-        -output-directory=doc \\\n-        $<\n-\n-      endif\n-    endif\n-  endif\n-\n DOCS += doc/rustpkg.html\n doc/rustpkg.html: rustpkg.md doc/version_info.html doc/rust.css doc/manual.css\n \t@$(call E, pandoc: $@)\n@@ -95,13 +78,6 @@ doc/rustpkg.html: rustpkg.md doc/version_info.html doc/rust.css doc/manual.css\n \t     --include-before-body=doc/version_info.html \\\n          --output=$@\n \n-######################################################################\n-# Node (tutorial related)\n-######################################################################\n-  ifeq ($(CFG_NODE),)\n-    $(info cfg: no node found, omitting doc/tutorial.html)\n-  else\n-\n DOCS += doc/tutorial.html\n doc/tutorial.html: tutorial.md doc/version_info.html doc/rust.css\n \t@$(call E, pandoc: $@)\n@@ -153,9 +129,29 @@ doc/tutorial-tasks.html: tutorial-tasks.md doc/version_info.html doc/rust.css\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+  ifeq ($(CFG_PDFLATEX),)\n+    $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n+  else\n+    ifeq ($(CFG_XETEX),)\n+      $(info cfg: no xetex found, disabling doc/rust.pdf)\n+    else\n+      ifeq ($(CFG_LUATEX),)\n+        $(info cfg: lacking luatex, disabling pdflatex)\n+      else\n+\n+DOCS += doc/rust.pdf\n+doc/rust.pdf: doc/rust.tex\n+\t@$(call E, pdflatex: $@)\n+\t$(Q)$(CFG_PDFLATEX) \\\n+        -interaction=batchmode \\\n+        -output-directory=doc \\\n+        $<\n+\n+      endif\n+    endif\n   endif\n-endif\n \n+endif # No pandoc / node\n \n ######################################################################\n # LLnextgen (grammar analysis from refman)"}, {"sha": "0c00a7e1d6469b5020d4a71697a9669ac8a0efe3", "filename": "mk/host.mk", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -29,7 +29,9 @@ $$(HBIN$(2)_H_$(4))/rustc$$(X_$(4)): \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUSTLLVM_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)) \\\n \t$$(HCORELIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HSTDLIB_DEFAULT$(2)_H_$(4))\n+\t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n+\t| $$(HBIN$(2)_H_$(4))/\n+\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n@@ -39,7 +41,9 @@ $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)): \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUSTLLVM_$(4)) \\\n \t$$(HCORELIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HSTDLIB_DEFAULT$(2)_H_$(4))\n+\t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n+\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTC_GLOB_$(4)) \\\n@@ -51,21 +55,24 @@ $$(HLIB$(2)_H_$(4))/$(CFG_LIBSYNTAX_$(4)): \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUSTLLVM_$(4)) \\\n \t$$(HCORELIB_DEFAULT$(2)_H_$(4)) \\\n-\t$$(HSTDLIB_DEFAULT$(2)_H_$(4))\n+\t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBSYNTAX_GLOB_$(4)) \\\n \t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBSYNTAX_DSYM_GLOB_$(4))) \\\n \t        $$(HLIB$(2)_H_$(4))\n \n $$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)): \\\n-\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_RUNTIME_$(4))\n+\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(HLIB$(2)_H_$(4))/$(CFG_CORELIB_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_CORELIB_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4))\n+\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n # Subtle: We do not let the shell expand $(CORELIB_DSYM_GLOB) directly rather\n@@ -82,7 +89,8 @@ $$(HLIB$(2)_H_$(4))/$(CFG_CORELIB_$(4)): \\\n $$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)): \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_STDLIB_$(4)) \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_CORELIB_$(4)) \\\n-\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4))\n+\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(STDLIB_GLOB_$(4)) \\\n@@ -91,30 +99,40 @@ $$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)): \\\n \n $$(HLIB$(2)_H_$(4))/libcore.rlib: \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/libcore.rlib \\\n-\t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4))\n+\t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(HLIB$(2)_H_$(4))/libstd.rlib: \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/libstd.rlib \\\n \t$$(HLIB$(2)_H_$(4))/libcore.rlib \\\n-\t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4))\n+\t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(HLIB$(2)_H_$(4))/librustc.rlib: \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/librustc.rlib \\\n \t$$(HLIB$(2)_H_$(4))/libcore.rlib \\\n \t$$(HLIB$(2)_H_$(4))/libstd.rlib \\\n-\t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4))\n+\t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(HLIB$(2)_H_$(4))/$(CFG_RUSTLLVM_$(4)): \\\n-\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_RUSTLLVM_$(4))\n+\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_RUSTLLVM_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n+$$(HBIN$(2)_H_$(4))/:\n+\tmkdir -p $$@\n+\n+$$(HLIB$(2)_H_$(4))/:\n+\tmkdir -p $$@\n+\n endef\n \n $(foreach t,$(CFG_HOST_TRIPLES),\t\t\t\t\t\\"}, {"sha": "e03b7c152478fd86a89ddc5da5f7b3859cd7907d", "filename": "mk/platform.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -11,7 +11,7 @@\n \n # Create variables HOST_<triple> containing the host part\n # of each target triple.  For example, the triple i686-darwin-macos\n-# would create a variable HOST_i686-darwin-macos with the value \n+# would create a variable HOST_i686-darwin-macos with the value\n # i386.\n define DEF_HOST_VAR\n   HOST_$(1) = $(subst i686,i386,$(word 1,$(subst -, ,$(1))))\n@@ -276,8 +276,8 @@ CFG_GCCISH_CFLAGS_i686-pc-mingw32 := -Wall -Werror -g -march=i686\n CFG_GCCISH_CXXFLAGS_i686-pc-mingw32 := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_i686-pc-mingw32 := -shared -fPIC -g\n CFG_GCCISH_DEF_FLAG_i686-pc-mingw32 :=\n-CFG_GCCISH_PRE_LIB_FLAGS_i686-pc-mingw32 := \n-CFG_GCCISH_POST_LIB_FLAGS_i686-pc-mingw32 := \n+CFG_GCCISH_PRE_LIB_FLAGS_i686-pc-mingw32 :=\n+CFG_GCCISH_POST_LIB_FLAGS_i686-pc-mingw32 :=\n CFG_DEF_SUFFIX_i686-pc-mingw32 := .mingw32.def\n CFG_INSTALL_NAME_i686-pc-mingw32 =\n CFG_LIBUV_LINK_FLAGS_i686-pc-mingw32 := -lWs2_32 -lpsapi -liphlpapi"}, {"sha": "30dda2fb276c9dd9a8c2939726e850d2ca7ef82c", "filename": "mk/rt.mk", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1,27 +1,27 @@\n # This is a procedure to define the targets for building\n-# the runtime.  \n+# the runtime.\n #\n # Argument 1 is the target triple.\n #\n # This is not really the right place to explain this, but\n # for those of you who are not Makefile gurus, let me briefly\n-# cover the $ expansion system in use here, because it \n+# cover the $ expansion system in use here, because it\n # confused me for a while!  The variable DEF_RUNTIME_TARGETS\n # will be defined once and then expanded with different\n # values substituted for $(1) each time it is called.\n-# That resulting text is then eval'd. \n+# That resulting text is then eval'd.\n #\n # For most variables, you could use a single $ sign.  The result\n # is that the substitution would occur when the CALL occurs,\n # I believe.  The problem is that the automatic variables $< and $@\n # need to be expanded-per-rule.  Therefore, for those variables at\n-# least, you need $$< and $$@ in the variable text.  This way, after \n+# least, you need $$< and $$@ in the variable text.  This way, after\n # the CALL substitution occurs, you will have $< and $@.  This text\n # will then be evaluated, and all will work as you like.\n #\n # Reader beware, this explanantion could be wrong, but it seems to\n-# fit the experimental data (i.e., I was able to get the system \n-# working under these assumptions). \n+# fit the experimental data (i.e., I was able to get the system\n+# working under these assumptions).\n \n # Hack for passing flags into LIBUV, see below.\n LIBUV_FLAGS_i386 = -m32 -fPIC\n@@ -163,14 +163,16 @@ endif\n ifdef CFG_WINDOWSY_$(1)\n $$(LIBUV_LIB_$(1)): $$(LIBUV_DEPS)\n \t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n+\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS)\" \\\n+\t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS)\" \\\n \t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/libuv\" \\\n \t\tOS=mingw \\\n \t\tV=$$(VERBOSE)\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n $$(LIBUV_LIB_$(1)): $$(LIBUV_DEPS)\n \t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n-\t\tCFLAGS=\"$$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n-\t\tLDFLAGS=\"$$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n+\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n@@ -181,8 +183,8 @@ $$(LIBUV_LIB_$(1)): $$(LIBUV_DEPS)\n else\n $$(LIBUV_LIB_$(1)): $$(LIBUV_DEPS)\n \t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n-\t\tCFLAGS=\"$$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n-\t\tLDFLAGS=\"$$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n+\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\"}, {"sha": "ac1b3e86ac918285ee35e5723253883dd5447fea", "filename": "mk/stage0.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -7,16 +7,16 @@ $(HBIN0_H_$(CFG_BUILD_TRIPLE))/rustc$(X_$(CFG_BUILD_TRIPLE)):\t\t\\\n \t\t$(S)src/etc/get-snapshot.py $(MKFILE_DEPS)\n \t@$(call E, fetch: $@)\n #   Note: the variable \"SNAPSHOT_FILE\" is generally not set, and so\n-#   we generally only pass one argument to this script.  \n+#   we generally only pass one argument to this script.\n ifdef CFG_ENABLE_LOCAL_RUST\n \t$(Q)$(S)src/etc/local_stage0.sh $(CFG_BUILD_TRIPLE) $(CFG_LOCAL_RUST_ROOT)\n-else \n+else\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/get-snapshot.py $(CFG_BUILD_TRIPLE) $(SNAPSHOT_FILE)\n ifdef CFG_ENABLE_PAX_FLAGS\n \t@$(call E, apply PaX flags: $@)\n \t@\"$(CFG_PAXCTL)\" -cm \"$@\"\n endif\n-endif \n+endif\n \t$(Q)touch $@\n \n # Host libs will be extracted by the above rule"}, {"sha": "2223531c3ec5efb2d59d7b6a52723e37d0520866", "filename": "mk/target.mk", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,54 +18,62 @@\n define TARGET_STAGE_N\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a: \\\n-\t\trt/$(2)/arch/$$(HOST_$(2))/libmorestack.a\n+\t\trt/$(2)/arch/$$(HOST_$(2))/libmorestack.a \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME_$(2)): \\\n-\t\trt/$(2)/$(CFG_RUNTIME_$(2))\n+\t\trt/$(2)/$(CFG_RUNTIME_$(2)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_CORELIB_$(2)): \\\n \t\t$$(CORELIB_CRATE) $$(CORELIB_INPUTS) \\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)): \\\n \t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n \t        $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_CORELIB_$(2)) \\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)): \\\n                 $$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\\\n \t\t$$(TCORELIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n-\t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))\n+\t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) $(BORROWCK) -o $$@ $$< && touch $$@\n \n # Only build the compiler for host triples\n ifneq ($$(findstring $(2),$$(CFG_HOST_TRIPLES)),)\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(3)): \\\n-\t\trustllvm/$(2)/$(CFG_RUSTLLVM_$(3))\n+\t\trustllvm/$(2)/$(CFG_RUSTLLVM_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(3)):\t\t\\\n \t\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS)\t\t\\\n                 $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)) \\\n-                $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(3))\n+                $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n \n $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(3)):\t\t\t\\\n-\t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(3))\n+\t\t$$(DRIVER_CRATE)\t\t\t\t\\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(3)) \\\n+\t\t| $$(TBIN$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) --cfg rustc -o $$@ $$<\n ifdef CFG_ENABLE_PAX_FLAGS\n@@ -75,6 +83,12 @@ endif\n \n endif\n \n+$$(TBIN$(1)_T_$(2)_H_$(3))/:\n+\tmkdir -p $$@\n+\n+$$(TLIB$(1)_T_$(2)_H_$(3))/:\n+\tmkdir -p $$@\n+\n endef\n \n # In principle, each host can build each target:"}, {"sha": "175e33c66541172422d2de86f05d23cec0c6ecbc", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -179,9 +179,9 @@ tidy:\n \t\t$(Q)find $(S)src/etc -name '*.py' \\\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n \t\t$(Q)echo $(ALL_CS) \\\n-\t  \t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n+\t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n \t\t$(Q)echo $(ALL_HS) \\\n-\t  \t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n+\t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n \n endif\n \n@@ -709,4 +709,3 @@ endef\n \n $(foreach host,$(CFG_HOST_TRIPLES),\t\t\t\\\n  $(eval $(call DEF_CHECK_FAST_FOR_H,$(host))))\n-"}, {"sha": "b6d690f83076fa4d47bdb174debecb5b1c23bb6d", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -223,10 +223,3 @@ pub fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n     let testfile = testfile.to_str();\n     test::DynTestFn(|| runtest::run(config, testfile))\n }\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "6492be53d34814a5867ae6f83fc40134e6e16714", "filename": "src/etc/check-links.pl", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fcheck-links.pl", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fcheck-links.pl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-links.pl?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -9,18 +9,17 @@\n my $i = 0;\n foreach $line (@lines) {\n     $i++;\n-    if ($line =~ m/id=\"([^\"]+)\"/) { \n+    if ($line =~ m/id=\"([^\"]+)\"/) {\n         $anchors->{$1} = $i;\n     }\n }\n \n $i = 0;\n foreach $line (@lines) {\n     $i++;\n-    while ($line =~ m/href=\"#([^\"]+)\"/g) { \n+    while ($line =~ m/href=\"#([^\"]+)\"/g) {\n         if (! exists($anchors->{$1})) {\n             print \"$file:$i: $1 referenced\\n\";\n         }\n     }\n }\n-"}, {"sha": "e394f1916088f081c36505288f8b30f500b08307", "filename": "src/etc/gedit/readme.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fgedit%2Freadme.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fgedit%2Freadme.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Freadme.txt?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -8,4 +8,3 @@ Instructions for Ubuntu Linux 12.04+\n 2) Copy the included \"share\" folder into \"~/.local/\"\n \n 3) Open a shell in \"~/.local/share/\" and run \"update-mime-database mime\"\n-"}, {"sha": "a413d0a90622284026065e090064d52156703e49", "filename": "src/etc/gedit/share/gtksourceview-3.0/language-specs/rust.lang", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -123,11 +123,11 @@\n \t\t<keyword>mode_t</keyword>\n \t\t<keyword>ssize_t</keyword>\n     </context>\n-    \n+\n     <context id=\"self\" style-ref=\"identifier\">\n \t\t<keyword>self</keyword>\n     </context>\n-    \n+\n     <context id=\"constants\" style-ref=\"constant\">\n \t\t<keyword>true</keyword>\n \t\t<keyword>false</keyword>\n@@ -261,4 +261,3 @@\n   </definitions>\n \n </language>\n-"}, {"sha": "d75cffe960073cf91aba56f504021d5c30e76323", "filename": "src/etc/gedit/share/mime/packages/rust.xml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -2,6 +2,6 @@\n   <mime-type type=\"text/x-rust\">\n     <comment>Rust Source</comment>\n     <glob pattern=\"*.rs\"/>\n-    <glob pattern=\"*.rc\"/>    \n+    <glob pattern=\"*.rc\"/>\n   </mime-type>\n </mime-info>"}, {"sha": "1a3a446533572d421959c7d3ec84b08ec91697cc", "filename": "src/etc/indenter", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Findenter", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Findenter", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Findenter?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -14,4 +14,3 @@ while (<>) {\n         $indent -= 1;\n     }\n }\n-"}, {"sha": "7cecf83716160fedf800485d855598b655a861e7", "filename": "src/etc/latest-unix-snaps.py", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flatest-unix-snaps.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flatest-unix-snaps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flatest-unix-snaps.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -52,5 +52,3 @@ def download_new_file (date, rev, platform, hsh):\n for ff in newestSet[\"files\"]:\n    download_new_file (newestSet[\"date\"], newestSet[\"rev\"],\n                       ff[\"platform\"], ff[\"hash\"])\n-\n-"}, {"sha": "e341f495eebb9fe608e16223ddda9cf4f3a5dcef", "filename": "src/etc/libc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flibc.c", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flibc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flibc.c?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -243,4 +243,3 @@ int main() {\n   extra_consts();\n   printf(\"}\\n\");\n }\n-"}, {"sha": "1e0c541cd8927850bee96a62a7a0a689f09e2561", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -96,4 +96,3 @@ def check_license(name, contents):\n         return True\n \n     return False\n-"}, {"sha": "8d2fd887e3ff706321642fd943032551e91ba27a", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1,13 +1,13 @@\n #!/bin/sh\n \n-TARG_DIR=$1 \n+TARG_DIR=$1\n PREFIX=$2\n \n BINDIR=bin\n LIBDIR=lib\n \n OS=`uname -s`\n-case $OS in \n+case $OS in\n     (\"Linux\"|\"FreeBSD\")\n \tBIN_SUF=\n \tLIB_SUF=.so"}, {"sha": "3b5f66c41173056e0c9e8cb98e4e3e256683e8d9", "filename": "src/etc/mirror-all-snapshots.py", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fmirror-all-snapshots.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fmirror-all-snapshots.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmirror-all-snapshots.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -33,6 +33,3 @@\n             print(\"got download with ok hash\")\n         else:\n             raise Exception(\"bad hash on download\")\n-\n-\n-"}, {"sha": "a2d27591cad939f189b96e0561a771494509b83f", "filename": "src/etc/monodebug.pl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fmonodebug.pl", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fmonodebug.pl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmonodebug.pl?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -77,4 +77,3 @@\n     }\n     print \"\\n\";\n }\n-"}, {"sha": "7bd4175fbf0db9e0d0ac9009137ee188fc06e7fc", "filename": "src/etc/sugarise-doc-comments.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -80,4 +80,3 @@ def sugarise_file(path):\n for (dirpath, dirnames, filenames) in os.walk('.'):\n     for name in fnmatch.filter(filenames, '*.r[sc]'):\n         sugarise_file(os.path.join(dirpath, name))\n-"}, {"sha": "06fcb5cb9458652c0e55fc8cbbdc474d7cfa23b3", "filename": "src/etc/tidy.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -81,4 +81,3 @@ def do_license_check(name, contents):\n \n \n sys.exit(err)\n-"}, {"sha": "afb3d16848085a18d008d0e02a359a8c341b5623", "filename": "src/etc/unicode.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -235,6 +235,10 @@ def emit_decomp_module(f, canon, compat):\n rf = open(r, \"w\")\n \n (canon_decomp, compat_decomp, gencats) = load_unicode_data(\"UnicodeData.txt\")\n+\n+# Explain that the source code was generated by this script.\n+rf.write('// The following code was generated by \"src/etc/unicode.py\"\\n\\n')\n+\n emit_property_module(rf, \"general_category\", gencats)\n \n #emit_decomp_module(rf, canon_decomp, compat_decomp)"}, {"sha": "def1c5a53c1fde79dc5645064c39aacc2091d4b1", "filename": "src/etc/x86.supp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -366,7 +366,7 @@\n    ...\n }\n \n-{  \n+{\n    llvm-user-new-leak\n    Memcheck:Leak\n    fun:_Znwj\n@@ -401,7 +401,7 @@\n    Helgrind:Race\n    fun:_ZN15lock_and_signal27lock_held_by_current_threadEv\n    ...\n-}  \n+}\n \n {\n    lock_and_signal-probably-threadsafe-access-outside-of-lock2"}, {"sha": "c8f873037d8cc581c2f7413c8453b606896a5956", "filename": "src/etc/ziggurat_tables.py", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fziggurat_tables.py", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Fetc%2Fziggurat_tables.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fziggurat_tables.py?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,121 @@\n+#!/usr/bin/env python\n+# xfail-license\n+\n+# This creates the tables used for distributions implemented using the\n+# ziggurat algorithm in `core::rand::distributions;`. They are\n+# (basically) the tables as used in the ZIGNOR variant (Doornik 2005).\n+# They are changed rarely, so the generated file should be checked in\n+# to git.\n+#\n+# It creates 3 tables: X as in the paper, F which is f(x_i), and\n+# F_DIFF which is f(x_i) - f(x_{i-1}). The latter two are just cached\n+# values which is not done in that paper (but is done in other\n+# variants). Note that the adZigR table is unnecessary because of\n+# algebra.\n+#\n+# It is designed to be compatible with Python 2 and 3.\n+\n+from math import exp, sqrt, log, floor\n+import random\n+\n+# The order should match the return value of `tables`\n+TABLE_NAMES = ['X', 'F', 'F_DIFF']\n+\n+# The actual length of the table is 1 more, to stop\n+# index-out-of-bounds errors. This should match the bitwise operation\n+# to find `i` in `zigurrat` in `libstd/rand/mod.rs`. Also the *_R and\n+# *_V constants below depend on this value.\n+TABLE_LEN = 256\n+\n+# equivalent to `zigNorInit` in Doornik2005, but generalised to any\n+# distribution. r = dR, v = dV, f = probability density function,\n+# f_inv = inverse of f\n+def tables(r, v, f, f_inv):\n+    # compute the x_i\n+    xvec = [0]*(TABLE_LEN+1)\n+\n+    xvec[0] = v / f(r)\n+    xvec[1] = r\n+\n+    for i in range(2, TABLE_LEN):\n+        last = xvec[i-1]\n+        xvec[i] = f_inv(v / last + f(last))\n+\n+    # cache the f's\n+    fvec = [0]*(TABLE_LEN+1)\n+    fdiff = [0]*(TABLE_LEN+1)\n+    for i in range(TABLE_LEN+1):\n+        fvec[i] = f(xvec[i])\n+        if i > 0:\n+            fdiff[i] = fvec[i] - fvec[i-1]\n+\n+    return xvec, fvec, fdiff\n+\n+# Distributions\n+# N(0, 1)\n+def norm_f(x):\n+    return exp(-x*x/2.0)\n+def norm_f_inv(y):\n+    return sqrt(-2.0*log(y))\n+\n+NORM_R = 3.6541528853610088\n+NORM_V = 0.00492867323399\n+\n+NORM = tables(NORM_R, NORM_V,\n+              norm_f, norm_f_inv)\n+\n+# Exp(1)\n+def exp_f(x):\n+    return exp(-x)\n+def exp_f_inv(y):\n+    return -log(y)\n+\n+EXP_R = 7.69711747013104972\n+EXP_V = 0.0039496598225815571993\n+\n+EXP = tables(EXP_R, EXP_V,\n+             exp_f, exp_f_inv)\n+\n+\n+# Output the tables/constants/types\n+\n+def render_static(name, type, value):\n+    # no space or\n+    return 'pub static %s: %s =%s;\\n' % (name, type, value)\n+\n+# static `name`: [`type`, .. `len(values)`] =\n+#     [values[0], ..., values[3],\n+#      values[4], ..., values[7],\n+#      ... ];\n+def render_table(name, values):\n+    rows = []\n+    # 4 values on each row\n+    for i in range(0, len(values), 4):\n+        row = values[i:i+4]\n+        rows.append(', '.join('%.18f' % f for f in row))\n+\n+    rendered = '\\n    [%s]' % ',\\n     '.join(rows)\n+    return render_static(name, '[f64, .. %d]' % len(values), rendered)\n+\n+\n+with open('ziggurat_tables.rs', 'w') as f:\n+    f.write('''// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tables for distributions which are sampled using the ziggurat\n+// algorithm. Autogenerated by `ziggurat_tables.py`.\n+\n+pub type ZigTable = &\\'static [f64, .. %d];\n+'''  % (TABLE_LEN + 1))\n+    for name, tables, r in [('NORM', NORM, NORM_R),\n+                            ('EXP', EXP, EXP_R)]:\n+        f.write(render_static('ZIG_%s_R' % name, 'f64', ' %.18f' % r))\n+        for (tabname, table) in zip(TABLE_NAMES, tables):\n+            f.write(render_table('ZIG_%s_%s' % (name, tabname), table))"}, {"sha": "1b4b81dca267c0e2773f128a65449193049d1c0a", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -108,8 +108,6 @@ mod tests {\n \n     #[test]\n     fn test_bool_from_str() {\n-        use from_str::FromStr;\n-\n         do all_values |v| {\n             assert!(Some(v) == FromStr::from_str(to_str(v)))\n         }"}, {"sha": "96e1c3bd1249be9d62439bad645b6794b653dde8", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -19,35 +19,11 @@ pub mod rusti {\n     pub extern \"rust-intrinsic\" {\n         fn forget<T>(+x: T);\n \n-        #[cfg(stage0)]\n-        fn reinterpret_cast<T, U>(&&e: T) -> U;\n-\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        #[cfg(stage3)]\n         fn transmute<T,U>(e: T) -> U;\n     }\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n-    rusti::reinterpret_cast(*src)\n-}\n-\n-/// Unsafely copies and casts the value at `src` to U, even if the value is\n-/// noncopyable. The two types must have the same length.\n-#[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    rusti::reinterpret_cast(*src)\n-}\n-\n-#[inline(always)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = unstable::intrinsics::init();\n     {\n@@ -88,17 +64,6 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *     assert!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n #[inline(always)]\n-#[cfg(stage0)]\n-pub unsafe fn transmute<L, G>(thing: L) -> G {\n-    let newthing: G = reinterpret_cast(&thing);\n-    forget(thing);\n-    newthing\n-}\n-\n-#[inline(always)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     rusti::transmute(thing)\n }\n@@ -159,15 +124,6 @@ mod tests {\n     use cast::{bump_box_refcount, transmute};\n \n     #[test]\n-    #[cfg(stage0)]\n-    fn test_reinterpret_cast() {\n-        assert!(1u == unsafe { ::cast::reinterpret_cast(&1) });\n-    }\n-\n-    #[test]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     fn test_transmute_copy() {\n         assert!(1u == unsafe { ::cast::transmute_copy(&1) });\n     }"}, {"sha": "7868b463807f6048aaa5b15ff1cb4f7bb768d7a7", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,6 +10,7 @@\n \n //! Utilities for manipulating the char type\n \n+#[cfg(notest)]\n use cmp::Ord;\n use option::{None, Option, Some};\n use str;"}, {"sha": "435b1cb7f34c32786bb8c98cbcb8677e461e1e62", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -258,4 +258,3 @@ pub mod rustrt {\n         pub unsafe fn rust_get_task() -> *c_void;\n     }\n }\n-"}, {"sha": "1240fe03dd54de78d3094c29c833c90904283e14", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -192,4 +192,27 @@ mod test {\n \n         assert!(trapped);\n     }\n+\n+    // Issue #6009\n+    mod m {\n+        condition! {\n+            sadness: int -> int;\n+        }\n+\n+        mod n {\n+            use super::sadness;\n+\n+            #[test]\n+            fn test_conditions_are_public() {\n+                let mut trapped = false;\n+                do sadness::cond.trap(|_| {\n+                    trapped = true;\n+                    0\n+                }).in {\n+                    sadness::cond.raise(0);\n+                }\n+                assert!(trapped);\n+            }\n+        }\n+    }\n }"}, {"sha": "9672bf887caff1d76533defb44694c987b275fc0", "filename": "src/libcore/core.rc", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -63,7 +63,6 @@ they contained the following prologue:\n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_mutable_fields)];\n-#[allow(deprecated_drop)];\n \n // Make core testable by not duplicating lang items. See #2912\n #[cfg(test)] extern mod realcore(name = \"core\", vers = \"0.7-pre\");\n@@ -75,7 +74,7 @@ they contained the following prologue:\n \n pub use kinds::{Const, Copy, Owned, Durable};\n pub use ops::{Drop};\n-pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n+pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Shl, Shr, Index};\n \n@@ -109,6 +108,7 @@ pub use num::{Bitwise, BitCount, Bounded};\n pub use num::{Primitive, Int, Float};\n \n pub use ptr::Ptr;\n+pub use from_str::FromStr;\n pub use to_str::ToStr;\n pub use clone::Clone;\n \n@@ -122,6 +122,9 @@ pub mod linkhack {\n     }\n }\n \n+// Internal macros\n+mod macros;\n+\n /* The Prelude. */\n \n pub mod prelude;\n@@ -261,12 +264,3 @@ mod core {\n     pub use sys;\n     pub use pipes;\n }\n-\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "33b7e81ee85fb90ba0925657b0aaf3a00c32904f", "filename": "src/libcore/either.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -263,13 +263,3 @@ fn test_partition_empty() {\n     assert_eq!(vec::len(lefts), 0u);\n     assert_eq!(vec::len(rights), 0u);\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "9b01c1dad06e934e51a8b1bdff20d9cfb62dcaca", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -678,7 +678,7 @@ pub impl <T:Hash + Eq> HashSet<T> {\n     }\n }\n \n-#[test]\n+#[cfg(test)]\n mod test_map {\n     use container::{Container, Map, Set};\n     use option::{None, Some};\n@@ -854,7 +854,7 @@ mod test_map {\n     }\n }\n \n-#[test]\n+#[cfg(test)]\n mod test_set {\n     use super::*;\n     use container::{Container, Map, Set};"}, {"sha": "460fd60d4c56b4faacfac6b3ac2a27e6e60fc150", "filename": "src/libcore/io.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1954,13 +1954,3 @@ mod tests {\n         }\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "8fc2db6d6f19a9289b281bd4d630347c98ad7777", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -41,6 +41,9 @@ much easier to implement.\n \n */\n \n+use cmp::Ord;\n+use option::{Option, Some, None};\n+\n pub trait Times {\n     fn times(&self, it: &fn() -> bool);\n }\n@@ -104,6 +107,78 @@ pub fn all<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n     true\n }\n \n+/**\n+ * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * let xs = ~[1u, 2, 3, 4, 5, 6];\n+ * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n+ * ~~~~\n+ */\n+#[inline(always)]\n+pub fn find<T>(predicate: &fn(&T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+    for iter |x| {\n+        if predicate(&x) {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+/**\n+ * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.each(f)).unwrap(), &15);\n+ * ~~~~\n+ */\n+#[inline]\n+pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x > *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+ * assert_eq!(max(|f| xs.each(f)).unwrap(), &-5);\n+ * ~~~~\n+ */\n+#[inline]\n+pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+    let mut result = None;\n+    for iter |x| {\n+        match result {\n+            Some(ref mut y) => {\n+                if x < *y {\n+                    *y = x;\n+                }\n+            }\n+            None => result = Some(x)\n+        }\n+    }\n+    result\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -128,4 +203,22 @@ mod tests {\n         assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n         assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n     }\n+\n+    #[test]\n+    fn test_find() {\n+        let xs = ~[1u, 2, 3, 4, 5, 6];\n+        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n+    }\n+\n+    #[test]\n+    fn test_max() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(max(|f| xs.each(f)).unwrap(), &15);\n+    }\n+\n+    #[test]\n+    fn test_min() {\n+        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n+        assert_eq!(min(|f| xs.each(f)).unwrap(), &-5);\n+    }\n }"}, {"sha": "5e95485b2736086e8b0ec00a8fd869bc37766930", "filename": "src/libcore/iterator.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiterator.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -29,7 +29,7 @@ pub trait Iterator<A> {\n ///\n /// In the future these will be default methods instead of a utility trait.\n pub trait IteratorUtil<A> {\n-    fn chain(self, other: Self) -> ChainIterator<Self>;\n+    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<Self, U>;\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<Self, U>;\n     // FIXME: #5898: should be called map\n     fn transform<'r, B>(self, f: &'r fn(A) -> B) -> MapIterator<'r, A, B, Self>;\n@@ -50,7 +50,7 @@ pub trait IteratorUtil<A> {\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline(always)]\n-    fn chain(self, other: T) -> ChainIterator<T> {\n+    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<T, U> {\n         ChainIterator{a: self, b: other, flag: false}\n     }\n \n@@ -115,13 +115,13 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n }\n \n-pub struct ChainIterator<T> {\n+pub struct ChainIterator<T, U> {\n     priv a: T,\n-    priv b: T,\n+    priv b: U,\n     priv flag: bool\n }\n \n-impl<A, T: Iterator<A>> Iterator<A> for ChainIterator<T> {\n+impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -385,7 +385,7 @@ mod tests {\n     #[test]\n     fn test_iterator_chain() {\n         let xs = [0u, 1, 2, 3, 4, 5];\n-        let ys = [30, 40, 50, 60];\n+        let ys = [30u, 40, 50, 60];\n         let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n         let mut it = xs.iter().chain(ys.iter());\n         let mut i = 0;\n@@ -394,6 +394,15 @@ mod tests {\n             i += 1;\n         }\n         assert_eq!(i, expected.len());\n+\n+        let ys = Counter::new(30u, 10).take(4);\n+        let mut it = xs.iter().transform(|&x| x).chain(ys);\n+        let mut i = 0;\n+        for it.advance |x: uint| {\n+            assert_eq!(x, expected[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]"}, {"sha": "6fb4572913d2e7cc6c5f752a32deb0ae295c8490", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 233, "deletions": 15, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -104,6 +104,7 @@ pub use libc::funcs::posix88::unistd::*;\n \n pub use libc::funcs::posix01::stat_::*;\n pub use libc::funcs::posix01::unistd::*;\n+pub use libc::funcs::posix01::glob::*;\n pub use libc::funcs::posix08::unistd::*;\n \n pub use libc::funcs::bsd44::*;\n@@ -210,7 +211,21 @@ pub mod types {\n     #[cfg(target_os = \"android\")]\n     pub mod os {\n         pub mod common {\n-            pub mod posix01 {}\n+            pub mod posix01 {\n+                use libc::types::common::c95::{c_void};\n+                use libc::types::os::arch::c95::{c_char, size_t};\n+                pub struct glob_t {\n+                    gl_pathc: size_t,\n+                    gl_pathv: **c_char,\n+                    gl_offs:  size_t,\n+\n+                    __unused1: *c_void,\n+                    __unused2: *c_void,\n+                    __unused3: *c_void,\n+                    __unused4: *c_void,\n+                    __unused5: *c_void,\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86\")]\n@@ -368,7 +383,25 @@ pub mod types {\n     #[cfg(target_os = \"freebsd\")]\n     pub mod os {\n         pub mod common {\n-            pub mod posix01 {}\n+            pub mod posix01 {\n+                use libc::types::common::c95::{c_void};\n+                use libc::types::os::arch::c95::{c_char, c_int, size_t};\n+                pub struct glob_t {\n+                    gl_pathc:  size_t,\n+                    __unused1: size_t,\n+                    gl_offs:   size_t,\n+                    __unused2: c_int,\n+                    gl_pathv:  **c_char,\n+\n+                    __unused3: *c_void,\n+\n+                    __unused4: *c_void,\n+                    __unused5: *c_void,\n+                    __unused6: *c_void,\n+                    __unused7: *c_void,\n+                    __unused8: *c_void,\n+                }\n+            }\n         }\n \n         #[cfg(target_arch = \"x86_64\")]\n@@ -548,12 +581,16 @@ pub mod types {\n \n                 pub type LPWSTR = *mut WCHAR;\n                 pub type LPSTR = *mut CHAR;\n+                pub type LPTSTR = *mut CHAR;\n \n                 // Not really, but opaque to us.\n                 pub type LPSECURITY_ATTRIBUTES = LPVOID;\n \n                 pub type LPVOID = *mut c_void;\n+                pub type LPBYTE = *mut BYTE;\n                 pub type LPWORD = *mut WORD;\n+                pub type LPDWORD = *mut DWORD;\n+                pub type LPHANDLE = *mut HANDLE;\n \n                 pub type LRESULT = LONG_PTR;\n                 pub type PBOOL = *mut BOOL;\n@@ -562,6 +599,36 @@ pub mod types {\n \n                 pub type time64_t = i64;\n                 pub type int64 = i64;\n+\n+                pub struct STARTUPINFO {\n+                    cb: DWORD,\n+                    lpReserved: LPTSTR,\n+                    lpDesktop: LPTSTR,\n+                    lpTitle: LPTSTR,\n+                    dwX: DWORD,\n+                    dwY: DWORD,\n+                    dwXSize: DWORD,\n+                    dwYSize: DWORD,\n+                    dwXCountChars: DWORD,\n+                    dwYCountCharts: DWORD,\n+                    dwFillAttribute: DWORD,\n+                    dwFlags: DWORD,\n+                    wShowWindow: WORD,\n+                    cbReserved2: WORD,\n+                    lpReserved2: LPBYTE,\n+                    hStdInput: HANDLE,\n+                    hStdOutput: HANDLE,\n+                    hStdError: HANDLE\n+                }\n+                pub type LPSTARTUPINFO = *mut STARTUPINFO;\n+\n+                pub struct PROCESS_INFORMATION {\n+                    hProcess: HANDLE,\n+                    hThread: HANDLE,\n+                    dwProcessId: DWORD,\n+                    dwThreadId: DWORD\n+                }\n+                pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n             }\n         }\n     }\n@@ -570,6 +637,23 @@ pub mod types {\n     pub mod os {\n         pub mod common {\n             pub mod posix01 {\n+                use libc::types::common::c95::{c_void};\n+                use libc::types::os::arch::c95::{c_char, c_int, size_t};\n+                pub struct glob_t {\n+                    gl_pathc:  size_t,\n+                    __unused1: c_int,\n+                    gl_offs:   size_t,\n+                    __unused2: c_int,\n+                    gl_pathv:  **c_char,\n+\n+                    __unused3: *c_void,\n+\n+                    __unused4: *c_void,\n+                    __unused5: *c_void,\n+                    __unused6: *c_void,\n+                    __unused7: *c_void,\n+                    __unused8: *c_void,\n+                }\n             }\n         }\n \n@@ -797,13 +881,62 @@ pub mod consts {\n         pub mod bsd44 {\n         }\n         pub mod extra {\n+            use libc::types::os::arch::extra::{DWORD, BOOL};\n+\n+            pub static TRUE : BOOL = 1;\n+            pub static FALSE : BOOL = 0;\n+\n             pub static O_TEXT : int = 16384;\n             pub static O_BINARY : int = 32768;\n             pub static O_NOINHERIT: int = 128;\n \n             pub static ERROR_SUCCESS : int = 0;\n             pub static ERROR_INSUFFICIENT_BUFFER : int = 122;\n             pub static INVALID_HANDLE_VALUE: int = -1;\n+\n+            pub static DELETE : DWORD = 0x00010000;\n+            pub static READ_CONTROL : DWORD = 0x00020000;\n+            pub static SYNCHRONIZE : DWORD = 0x00100000;\n+            pub static WRITE_DAC : DWORD = 0x00040000;\n+            pub static WRITE_OWNER : DWORD = 0x00080000;\n+\n+            pub static PROCESS_CREATE_PROCESS : DWORD = 0x0080;\n+            pub static PROCESS_CREATE_THREAD : DWORD = 0x0002;\n+            pub static PROCESS_DUP_HANDLE : DWORD = 0x0040;\n+            pub static PROCESS_QUERY_INFORMATION : DWORD = 0x0400;\n+            pub static PROCESS_QUERY_LIMITED_INFORMATION : DWORD = 0x1000;\n+            pub static PROCESS_SET_INFORMATION : DWORD = 0x0200;\n+            pub static PROCESS_SET_QUOTA : DWORD = 0x0100;\n+            pub static PROCESS_SUSPEND_RESUME : DWORD = 0x0800;\n+            pub static PROCESS_TERMINATE : DWORD = 0x0001;\n+            pub static PROCESS_VM_OPERATION : DWORD = 0x0008;\n+            pub static PROCESS_VM_READ : DWORD = 0x0010;\n+            pub static PROCESS_VM_WRITE : DWORD = 0x0020;\n+\n+            pub static STARTF_FORCEONFEEDBACK : DWORD = 0x00000040;\n+            pub static STARTF_FORCEOFFFEEDBACK : DWORD = 0x00000080;\n+            pub static STARTF_PREVENTPINNING : DWORD = 0x00002000;\n+            pub static STARTF_RUNFULLSCREEN : DWORD = 0x00000020;\n+            pub static STARTF_TITLEISAPPID : DWORD = 0x00001000;\n+            pub static STARTF_TITLEISLINKNAME : DWORD = 0x00000800;\n+            pub static STARTF_USECOUNTCHARS : DWORD = 0x00000008;\n+            pub static STARTF_USEFILLATTRIBUTE : DWORD = 0x00000010;\n+            pub static STARTF_USEHOTKEY : DWORD = 0x00000200;\n+            pub static STARTF_USEPOSITION : DWORD = 0x00000004;\n+            pub static STARTF_USESHOWWINDOW : DWORD = 0x00000001;\n+            pub static STARTF_USESIZE : DWORD = 0x00000002;\n+            pub static STARTF_USESTDHANDLES : DWORD = 0x00000100;\n+\n+            pub static WAIT_ABANDONED : DWORD = 0x00000080;\n+            pub static WAIT_OBJECT_0 : DWORD = 0x00000000;\n+            pub static WAIT_TIMEOUT : DWORD = 0x00000102;\n+            pub static WAIT_FAILED : DWORD = -1;\n+\n+            pub static DUPLICATE_CLOSE_SOURCE : DWORD = 0x00000001;\n+            pub static DUPLICATE_SAME_ACCESS : DWORD = 0x00000002;\n+\n+            pub static INFINITE : DWORD = -1;\n+            pub static STILL_ACTIVE : DWORD = 259;\n         }\n     }\n \n@@ -876,6 +1009,18 @@ pub mod consts {\n         }\n         pub mod posix01 {\n             pub static SIGTRAP : int = 5;\n+\n+            pub static GLOB_ERR      : int = 1 << 0;\n+            pub static GLOB_MARK     : int = 1 << 1;\n+            pub static GLOB_NOSORT   : int = 1 << 2;\n+            pub static GLOB_DOOFFS   : int = 1 << 3;\n+            pub static GLOB_NOCHECK  : int = 1 << 4;\n+            pub static GLOB_APPEND   : int = 1 << 5;\n+            pub static GLOB_NOESCAPE : int = 1 << 6;\n+\n+            pub static GLOB_NOSPACE  : int = 1;\n+            pub static GLOB_ABORTED  : int = 2;\n+            pub static GLOB_NOMATCH  : int = 3;\n         }\n         pub mod posix08 {\n         }\n@@ -955,6 +1100,18 @@ pub mod consts {\n         }\n         pub mod posix01 {\n             pub static SIGTRAP : int = 5;\n+\n+            pub static GLOB_APPEND   : int = 0x0001;\n+            pub static GLOB_DOOFFS   : int = 0x0002;\n+            pub static GLOB_ERR      : int = 0x0004;\n+            pub static GLOB_MARK     : int = 0x0008;\n+            pub static GLOB_NOCHECK  : int = 0x0010;\n+            pub static GLOB_NOSORT   : int = 0x0020;\n+            pub static GLOB_NOESCAPE : int = 0x2000;\n+\n+            pub static GLOB_NOSPACE  : int = -1;\n+            pub static GLOB_ABORTED  : int = -2;\n+            pub static GLOB_NOMATCH  : int = -3;\n         }\n         pub mod posix08 {\n         }\n@@ -1035,6 +1192,18 @@ pub mod consts {\n         }\n         pub mod posix01 {\n             pub static SIGTRAP : int = 5;\n+\n+            pub static GLOB_APPEND   : int = 0x0001;\n+            pub static GLOB_DOOFFS   : int = 0x0002;\n+            pub static GLOB_ERR      : int = 0x0004;\n+            pub static GLOB_MARK     : int = 0x0008;\n+            pub static GLOB_NOCHECK  : int = 0x0010;\n+            pub static GLOB_NOSORT   : int = 0x0020;\n+            pub static GLOB_NOESCAPE : int = 0x2000;\n+\n+            pub static GLOB_NOSPACE  : int = -1;\n+            pub static GLOB_ABORTED  : int = -2;\n+            pub static GLOB_NOMATCH  : int = -3;\n         }\n         pub mod posix08 {\n         }\n@@ -1605,6 +1774,21 @@ pub mod funcs {\n                                -> pid_t;\n             }\n         }\n+\n+        #[nolink]\n+        #[abi = \"cdecl\"]\n+        pub mod glob {\n+            use libc::types::common::c95::{c_void};\n+            use libc::types::os::arch::c95::{c_char, c_int};\n+            use libc::types::os::common::posix01::{glob_t};\n+\n+            pub extern {\n+                unsafe fn glob(pattern: *c_char, flags: c_int,\n+                               errfunc: *c_void, // XXX callback\n+                               pglob: *mut glob_t);\n+                unsafe fn globfree(pglob: *mut glob_t);\n+            }\n+        }\n     }\n \n     #[cfg(target_os = \"win32\")]\n@@ -1614,6 +1798,9 @@ pub mod funcs {\n \n         pub mod unistd {\n         }\n+\n+        pub mod glob {\n+        }\n     }\n \n \n@@ -1646,12 +1833,24 @@ pub mod funcs {\n \n             unsafe fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n                                sizep: *mut size_t) -> c_int;\n+\n+            unsafe fn getdtablesize() -> c_int;\n         }\n     }\n \n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n+    pub mod bsd44 {\n+        use libc::types::os::arch::c95::{c_int};\n+\n+        #[abi = \"cdecl\"]\n+        pub extern {\n+            unsafe fn getdtablesize() -> c_int;\n+        }\n+    }\n+\n+\n     #[cfg(target_os = \"win32\")]\n     pub mod bsd44 {\n     }\n@@ -1685,9 +1884,11 @@ pub mod funcs {\n         pub mod kernel32 {\n             use libc::types::os::arch::c95::{c_uint};\n             use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n-            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPTCH};\n-            use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES};\n-            use libc::types::os::arch::extra::{HANDLE};\n+            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPCTSTR,\n+                                               LPTSTR, LPTCH, LPDWORD, LPVOID};\n+            use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, LPSTARTUPINFO,\n+                                               LPPROCESS_INFORMATION};\n+            use libc::types::os::arch::extra::{HANDLE, LPHANDLE};\n \n             #[abi = \"stdcall\"]\n             pub extern \"stdcall\" {\n@@ -1724,29 +1925,46 @@ pub mod funcs {\n                                        findFileData: HANDLE)\n                     -> BOOL;\n                 unsafe fn FindClose(findFile: HANDLE) -> BOOL;\n+                unsafe fn DuplicateHandle(hSourceProcessHandle: HANDLE,\n+                                          hSourceHandle: HANDLE,\n+                                          hTargetProcessHandle: HANDLE,\n+                                          lpTargetHandle: LPHANDLE,\n+                                          dwDesiredAccess: DWORD,\n+                                          bInheritHandle: BOOL,\n+                                          dwOptions: DWORD) -> BOOL;\n                 unsafe fn CloseHandle(hObject: HANDLE) -> BOOL;\n+                unsafe fn OpenProcess(dwDesiredAccess: DWORD,\n+                                      bInheritHandle: BOOL,\n+                                      dwProcessId: DWORD) -> HANDLE;\n+                unsafe fn GetCurrentProcess() -> HANDLE;\n+                unsafe fn CreateProcessA(lpApplicationName: LPCTSTR,\n+                                         lpCommandLine: LPTSTR,\n+                                         lpProcessAttributes: LPSECURITY_ATTRIBUTES,\n+                                         lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                                         bInheritHandles: BOOL,\n+                                         dwCreationFlags: DWORD,\n+                                         lpEnvironment: LPVOID,\n+                                         lpCurrentDirectory: LPCTSTR,\n+                                         lpStartupInfo: LPSTARTUPINFO,\n+                                         lpProcessInformation: LPPROCESS_INFORMATION) -> BOOL;\n+                unsafe fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n                 unsafe fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint) -> BOOL;\n+                unsafe fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;\n             }\n         }\n \n         pub mod msvcrt {\n-            use libc::types::os::arch::c95::c_int;\n+            use libc::types::os::arch::c95::{c_int, c_long};\n \n             #[abi = \"cdecl\"]\n             #[nolink]\n             pub extern {\n                 #[link_name = \"_commit\"]\n                 unsafe fn commit(fd: c_int) -> c_int;\n+\n+                #[link_name = \"_get_osfhandle\"]\n+                unsafe fn get_osfhandle(fd: c_int) -> c_long;\n             }\n         }\n     }\n }\n-\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "afe8338f2ce6a4dbd7ff5b744694719d60307f26", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -59,4 +59,3 @@ pub fn log_type<T>(level: u32, object: &T) {\n         rustrt::rust_log_str(level, transmute(vec::raw::to_ptr(bytes)), len);\n     }\n }\n-"}, {"sha": "b19a753b71577110590d9b29d76993080905a018", "filename": "src/libcore/macros.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_escape];\n+\n+// Some basic logging\n+macro_rules! rtdebug_ (\n+    ($( $arg:expr),+) => ( {\n+        dumb_println(fmt!( $($arg),+ ));\n+\n+        fn dumb_println(s: &str) {\n+            use io::WriterUtil;\n+            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+            dbg.write_str(s);\n+            dbg.write_str(\"\\n\");\n+        }\n+\n+    } )\n+)\n+\n+// An alternate version with no output, for turning off logging\n+macro_rules! rtdebug (\n+    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n+)\n+\n+macro_rules! abort(\n+    ($( $msg:expr),+) => ( {\n+        rtdebug!($($msg),+);\n+\n+        unsafe { ::libc::abort(); }\n+    } )\n+)"}, {"sha": "8a0a88235d20cacde4fc45539b38e390b108f4ae", "filename": "src/libcore/num/cmath.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -267,14 +267,3 @@ pub mod c_double_targ_consts {\n }\n \n */\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//\n-"}, {"sha": "416ec2069b5216e4327d6091f6108cfa99937eeb", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,7 +10,6 @@\n \n //! Operations and constants for `f32`\n \n-use from_str;\n use num::{Zero, One, strconv};\n use prelude::*;\n \n@@ -123,7 +122,7 @@ pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n #[inline(always)]\n-pub fn quot(x: f32, y: f32) -> f32 { return x / y; }\n+pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n #[inline(always)]\n pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n@@ -278,11 +277,13 @@ impl Mul<f32,f32> for f32 {\n     #[inline(always)]\n     fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n+\n #[cfg(notest)]\n-impl Quot<f32,f32> for f32 {\n+impl Div<f32,f32> for f32 {\n     #[inline(always)]\n-    fn quot(&self, other: &f32) -> f32 { *self / *other }\n+    fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n+\n #[cfg(notest)]\n impl Rem<f32,f32> for f32 {\n     #[inline(always)]\n@@ -791,7 +792,7 @@ pub fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n                              strconv::ExpNone, false, false)\n }\n \n-impl from_str::FromStr for f32 {\n+impl FromStr for f32 {\n     #[inline(always)]\n     fn from_str(val: &str) -> Option<f32> { from_str(val) }\n }\n@@ -979,13 +980,3 @@ mod tests {\n         assert_eq!(Primitive::bytes::<f32>(), sys::size_of::<f32>());\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "6e09ca61a7d4ccc2eea96d9d86429be00eb01e3a", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,7 +10,6 @@\n \n //! Operations and constants for `f64`\n \n-use from_str;\n use libc::c_int;\n use num::{Zero, One, strconv};\n use prelude::*;\n@@ -149,7 +148,7 @@ pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n #[inline(always)]\n-pub fn quot(x: f64, y: f64) -> f64 { return x / y; }\n+pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n #[inline(always)]\n pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n@@ -297,9 +296,8 @@ impl Mul<f64,f64> for f64 {\n     fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n #[cfg(notest)]\n-impl Quot<f64,f64> for f64 {\n-    #[inline(always)]\n-    fn quot(&self, other: &f64) -> f64 { *self / *other }\n+impl Div<f64,f64> for f64 {\n+    fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n #[cfg(notest)]\n impl Rem<f64,f64> for f64 {\n@@ -837,7 +835,7 @@ pub fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n                              strconv::ExpNone, false, false)\n }\n \n-impl from_str::FromStr for f64 {\n+impl FromStr for f64 {\n     #[inline(always)]\n     fn from_str(val: &str) -> Option<f64> { from_str(val) }\n }\n@@ -1030,13 +1028,3 @@ mod tests {\n         assert_eq!(Primitive::bytes::<f64>(), sys::size_of::<f64>());\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "da9d03f6a7bc363b11b0140d82003ba3bf2e9282", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -20,12 +20,11 @@\n \n // PORT this must match in width according to architecture\n \n-use from_str;\n use libc::c_int;\n use num::{Zero, One, strconv};\n use prelude::*;\n \n-pub use f64::{add, sub, mul, quot, rem, lt, le, eq, ne, ge, gt};\n+pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n@@ -289,7 +288,7 @@ pub fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n                              strconv::ExpNone, false, false)\n }\n \n-impl from_str::FromStr for float {\n+impl FromStr for float {\n     #[inline(always)]\n     fn from_str(val: &str) -> Option<float> { from_str(val) }\n }\n@@ -691,11 +690,13 @@ impl Mul<float,float> for float {\n     #[inline(always)]\n     fn mul(&self, other: &float) -> float { *self * *other }\n }\n+\n #[cfg(notest)]\n-impl Quot<float,float> for float {\n+impl Div<float,float> for float {\n     #[inline(always)]\n-    fn quot(&self, other: &float) -> float { *self / *other }\n+    fn div(&self, other: &float) -> float { *self / *other }\n }\n+\n #[cfg(notest)]\n impl Rem<float,float> for float {\n     #[inline(always)]\n@@ -1132,13 +1133,3 @@ mod tests {\n         assert_eq!(to_str_digits(-infinity, 10u), ~\"-inf\");\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "95c187a7be22e60ce546a9fe56820803da7851d5", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 59, "deletions": 60, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,7 +10,6 @@\n \n use T = self::inst::T;\n \n-use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;\n@@ -30,7 +29,7 @@ pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub fn quot(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n \n ///\n /// Returns the remainder of y / x.\n@@ -202,10 +201,10 @@ impl Mul<T,T> for T {\n }\n \n #[cfg(notest)]\n-impl Quot<T,T> for T {\n+impl Div<T,T> for T {\n     ///\n-    /// Returns the integer quotient, truncated towards 0. As this behaviour reflects\n-    /// the underlying machine implementation it is more efficient than `Natural::div`.\n+    /// Integer division, truncated towards 0. As this behaviour reflects the underlying\n+    /// machine implementation it is more efficient than `Integer::div_floor`.\n     ///\n     /// # Examples\n     ///\n@@ -222,7 +221,7 @@ impl Quot<T,T> for T {\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn quot(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n \n #[cfg(notest)]\n@@ -297,51 +296,51 @@ impl Integer for T {\n     /// # Examples\n     ///\n     /// ~~~\n-    /// assert!(( 8).div( 3) ==  2);\n-    /// assert!(( 8).div(-3) == -3);\n-    /// assert!((-8).div( 3) == -3);\n-    /// assert!((-8).div(-3) ==  2);\n+    /// assert!(( 8).div_floor( 3) ==  2);\n+    /// assert!(( 8).div_floor(-3) == -3);\n+    /// assert!((-8).div_floor( 3) == -3);\n+    /// assert!((-8).div_floor(-3) ==  2);\n     ///\n-    /// assert!(( 1).div( 2) ==  0);\n-    /// assert!(( 1).div(-2) == -1);\n-    /// assert!((-1).div( 2) == -1);\n-    /// assert!((-1).div(-2) ==  0);\n+    /// assert!(( 1).div_floor( 2) ==  0);\n+    /// assert!(( 1).div_floor(-2) == -1);\n+    /// assert!((-1).div_floor( 2) == -1);\n+    /// assert!((-1).div_floor(-2) ==  0);\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn div(&self, other: &T) -> T {\n+    fn div_floor(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match self.quot_rem(other) {\n-            (q, r) if (r > 0 && *other < 0)\n-                   || (r < 0 && *other > 0) => q - 1,\n-            (q, _)                          => q,\n+        match self.div_rem(other) {\n+            (d, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => d - 1,\n+            (d, _)                          => d,\n         }\n     }\n \n     ///\n     /// Integer modulo, satisfying:\n     ///\n     /// ~~~\n-    /// assert!(n.div(d) * d + n.modulo(d) == n)\n+    /// assert!(n.div_floor(d) * d + n.mod_floor(d) == n)\n     /// ~~~\n     ///\n     /// # Examples\n     ///\n     /// ~~~\n-    /// assert!(( 8).modulo( 3) ==  2);\n-    /// assert!(( 8).modulo(-3) == -1);\n-    /// assert!((-8).modulo( 3) ==  1);\n-    /// assert!((-8).modulo(-3) == -2);\n+    /// assert!(( 8).mod_floor( 3) ==  2);\n+    /// assert!(( 8).mod_floor(-3) == -1);\n+    /// assert!((-8).mod_floor( 3) ==  1);\n+    /// assert!((-8).mod_floor(-3) == -2);\n     ///\n-    /// assert!(( 1).modulo( 2) ==  1);\n-    /// assert!(( 1).modulo(-2) == -1);\n-    /// assert!((-1).modulo( 2) ==  1);\n-    /// assert!((-1).modulo(-2) == -1);\n+    /// assert!(( 1).mod_floor( 2) ==  1);\n+    /// assert!(( 1).mod_floor(-2) == -1);\n+    /// assert!((-1).mod_floor( 2) ==  1);\n+    /// assert!((-1).mod_floor(-2) == -1);\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn modulo(&self, other: &T) -> T {\n+    fn mod_floor(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match *self % *other {\n@@ -351,21 +350,21 @@ impl Integer for T {\n         }\n     }\n \n-    /// Calculates `div` and `modulo` simultaneously\n+    /// Calculates `div_floor` and `mod_floor` simultaneously\n     #[inline(always)]\n-    fn div_mod(&self, other: &T) -> (T,T) {\n+    fn div_mod_floor(&self, other: &T) -> (T,T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match self.quot_rem(other) {\n-            (q, r) if (r > 0 && *other < 0)\n-                   || (r < 0 && *other > 0) => (q - 1, r + *other),\n-            (q, r)                          => (q, r),\n+        match self.div_rem(other) {\n+            (d, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => (d - 1, r + *other),\n+            (d, r)                          => (d, r),\n         }\n     }\n \n-    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: &T) -> (T,T) {\n+    fn div_rem(&self, other: &T) -> (T,T) {\n         (*self / *other, *self % *other)\n     }\n \n@@ -589,42 +588,42 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_quot_rem() {\n-        fn test_nd_qr(nd: (T,T), qr: (T,T)) {\n+    fn test_div_rem() {\n+        fn test_nd_dr(nd: (T,T), qr: (T,T)) {\n             let (n,d) = nd;\n-            let separate_quot_rem = (n / d, n % d);\n-            let combined_quot_rem = n.quot_rem(&d);\n+            let separate_div_rem = (n / d, n % d);\n+            let combined_div_rem = n.div_rem(&d);\n \n-            assert_eq!(separate_quot_rem, qr);\n-            assert_eq!(combined_quot_rem, qr);\n+            assert_eq!(separate_div_rem, qr);\n+            assert_eq!(combined_div_rem, qr);\n \n-            test_division_rule(nd, separate_quot_rem);\n-            test_division_rule(nd, combined_quot_rem);\n+            test_division_rule(nd, separate_div_rem);\n+            test_division_rule(nd, combined_div_rem);\n         }\n \n-        test_nd_qr(( 8,  3), ( 2,  2));\n-        test_nd_qr(( 8, -3), (-2,  2));\n-        test_nd_qr((-8,  3), (-2, -2));\n-        test_nd_qr((-8, -3), ( 2, -2));\n+        test_nd_dr(( 8,  3), ( 2,  2));\n+        test_nd_dr(( 8, -3), (-2,  2));\n+        test_nd_dr((-8,  3), (-2, -2));\n+        test_nd_dr((-8, -3), ( 2, -2));\n \n-        test_nd_qr(( 1,  2), ( 0,  1));\n-        test_nd_qr(( 1, -2), ( 0,  1));\n-        test_nd_qr((-1,  2), ( 0, -1));\n-        test_nd_qr((-1, -2), ( 0, -1));\n+        test_nd_dr(( 1,  2), ( 0,  1));\n+        test_nd_dr(( 1, -2), ( 0,  1));\n+        test_nd_dr((-1,  2), ( 0, -1));\n+        test_nd_dr((-1, -2), ( 0, -1));\n     }\n \n     #[test]\n-    fn test_div_mod() {\n+    fn test_div_mod_floor() {\n         fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n             let (n,d) = nd;\n-            let separate_div_mod = (n.div(&d), n.modulo(&d));\n-            let combined_div_mod = n.div_mod(&d);\n+            let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n+            let combined_div_mod_floor = n.div_mod_floor(&d);\n \n-            assert_eq!(separate_div_mod, dm);\n-            assert_eq!(combined_div_mod, dm);\n+            assert_eq!(separate_div_mod_floor, dm);\n+            assert_eq!(combined_div_mod_floor, dm);\n \n-            test_division_rule(nd, separate_div_mod);\n-            test_division_rule(nd, combined_div_mod);\n+            test_division_rule(nd, separate_div_mod_floor);\n+            test_division_rule(nd, combined_div_mod_floor);\n         }\n \n         test_nd_dm(( 8,  3), ( 2,  2));"}, {"sha": "1a59a069df7e899c75b6b47a79a9a57e569dde01", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,7 +10,7 @@\n \n //! An interface for numeric types\n use cmp::{Eq, Ord};\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use kinds::Copy;\n@@ -25,7 +25,7 @@ pub trait Num: Eq + Zero + One\n              + Add<Self,Self>\n              + Sub<Self,Self>\n              + Mul<Self,Self>\n-             + Quot<Self,Self>\n+             + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n pub trait IntConvertible {\n@@ -69,12 +69,13 @@ pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n \n pub trait Integer: Num\n                  + Orderable\n-                 + Quot<Self,Self>\n+                 + Div<Self,Self>\n                  + Rem<Self,Self> {\n-    fn div(&self, other: &Self) -> Self;\n-    fn modulo(&self, other: &Self) -> Self;\n-    fn div_mod(&self, other: &Self) -> (Self,Self);\n-    fn quot_rem(&self, other: &Self) -> (Self,Self);\n+    fn div_rem(&self, other: &Self) -> (Self,Self);\n+\n+    fn div_floor(&self, other: &Self) -> Self;\n+    fn mod_floor(&self, other: &Self) -> Self;\n+    fn div_mod_floor(&self, other: &Self) -> (Self,Self);\n \n     fn gcd(&self, other: &Self) -> Self;\n     fn lcm(&self, other: &Self) -> Self;\n@@ -95,7 +96,7 @@ pub trait Round {\n pub trait Fractional: Num\n                     + Orderable\n                     + Round\n-                    + Quot<Self,Self> {\n+                    + Div<Self,Self> {\n     fn recip(&self) -> Self;\n }\n \n@@ -219,7 +220,7 @@ pub trait Primitive: Num\n                    + Add<Self,Self>\n                    + Sub<Self,Self>\n                    + Mul<Self,Self>\n-                   + Quot<Self,Self>\n+                   + Div<Self,Self>\n                    + Rem<Self,Self> {\n     // FIXME (#5527): These should be associated constants\n     fn bits() -> uint;\n@@ -364,7 +365,7 @@ pub trait FromStrRadix {\n /// - If code written to use this function doesn't care about it, it's\n ///   probably assuming that `x^0` always equals `1`.\n ///\n-pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n+pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -384,18 +385,19 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n     total\n }\n \n+/// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),  cast(12));\n     assert_eq!(ten.sub(&two),  cast(8));\n     assert_eq!(ten.mul(&two),  cast(20));\n-    assert_eq!(ten.quot(&two), cast(5));\n+    assert_eq!(ten.div(&two), cast(5));\n     assert_eq!(ten.rem(&two),  cast(0));\n \n     assert_eq!(ten.add(&two),  ten + two);\n     assert_eq!(ten.sub(&two),  ten - two);\n     assert_eq!(ten.mul(&two),  ten * two);\n-    assert_eq!(ten.quot(&two), ten / two);\n+    assert_eq!(ten.div(&two), ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n "}, {"sha": "c16a29f8295e77d1d5d5c6bef20ececad2fa8284", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::cmp::{Ord, Eq};\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use char;\n use str;\n@@ -58,7 +58,7 @@ fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n }\n \n #[inline(always)]\n-fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Quot<T,T>>(num: &T) -> bool {\n+fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n@@ -171,7 +171,7 @@ static nan_buf:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                                  Quot<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+                                  Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n     if (radix as int) < 2 {\n@@ -379,7 +379,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  */\n #[inline(always)]\n pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                            Quot<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+                            Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = to_str_bytes_common(num, radix,\n@@ -432,7 +432,7 @@ priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Fails if `radix` > 18 and `special == true` due to conflict\n  *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n  */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -629,7 +629,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,"}, {"sha": "6d0f1fe1fc72b9bfed2db771f6973bd3ee7bd8e6", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -11,7 +11,6 @@\n use T = self::inst::T;\n use T_SIGNED = self::inst::T_SIGNED;\n \n-use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::{Zero, One, strconv};\n use prelude::*;\n@@ -31,7 +30,7 @@ pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub fn quot(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n #[inline(always)]\n pub fn rem(x: T, y: T) -> T { x % y }\n \n@@ -167,9 +166,9 @@ impl Mul<T,T> for T {\n }\n \n #[cfg(notest)]\n-impl Quot<T,T> for T {\n+impl Div<T,T> for T {\n     #[inline(always)]\n-    fn quot(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n \n #[cfg(notest)]\n@@ -187,23 +186,23 @@ impl Neg<T> for T {\n impl Unsigned for T {}\n \n impl Integer for T {\n-    /// Unsigned integer division. Returns the same result as `quot` (`/`).\n+    /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn div(&self, other: &T) -> T { *self / *other }\n+    fn div_rem(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n+    }\n \n-    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+    /// Unsigned integer division. Returns the same result as `div` (`/`).\n     #[inline(always)]\n-    fn modulo(&self, other: &T) -> T { *self / *other }\n+    fn div_floor(&self, other: &T) -> T { *self / *other }\n \n-    /// Calculates `div` and `modulo` simultaneously\n+    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n     #[inline(always)]\n-    fn div_mod(&self, other: &T) -> (T,T) {\n-        (*self / *other, *self % *other)\n-    }\n+    fn mod_floor(&self, other: &T) -> T { *self / *other }\n \n-    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    /// Calculates `div_floor` and `modulo_floor` simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: &T) -> (T,T) {\n+    fn div_mod_floor(&self, other: &T) -> (T,T) {\n         (*self / *other, *self % *other)\n     }\n "}, {"sha": "47ff45be68726a5bc5ab73950102438fe4c1106f", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -30,9 +30,9 @@ pub trait Mul<RHS,Result> {\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n-#[lang=\"quot\"]\n-pub trait Quot<RHS,Result> {\n-    fn quot(&self, rhs: &RHS) -> Result;\n+#[lang=\"div\"]\n+pub trait Div<RHS,Result> {\n+    fn div(&self, rhs: &RHS) -> Result;\n }\n \n #[lang=\"rem\"]"}, {"sha": "b7c51147fba78c8422664bcf7c6c1ad6bc90299a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -461,11 +461,3 @@ fn test_get_or_zero() {\n     let no_stuff: Option<int> = None;\n     assert!(no_stuff.get_or_zero() == 0);\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "42c77a687e5fd131255ef081054c616b684c3cc8", "filename": "src/libcore/os.rs", "status": "modified", "additions": 153, "deletions": 2, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -38,6 +38,7 @@ use ptr;\n use str;\n use task;\n use uint;\n+use unstable::finally::Finally;\n use vec;\n \n pub use libc::fclose;\n@@ -372,8 +373,9 @@ pub fn pipe() -> Pipe {\n         // inheritance has to be handled in a different way that I do not\n         // fully understand. Here we explicitly make the pipe non-inheritable,\n         // which means to pass it to a subprocess they need to be duplicated\n-        // first, as in rust_run_program.\n-        let mut fds = Pipe {in: 0 as c_int, out: 0 as c_int};\n+        // first, as in core::run.\n+        let mut fds = Pipe {in: 0 as c_int,\n+                    out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as ::libc::c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n         assert!((res == 0 as c_int));\n@@ -770,6 +772,28 @@ pub fn list_dir_path(p: &Path) -> ~[~Path] {\n     list_dir(p).map(|f| ~p.push(*f))\n }\n \n+/// Removes a directory at the specified path, after removing\n+/// all its contents. Use carefully!\n+pub fn remove_dir_recursive(p: &Path) -> bool {\n+    let mut error_happened = false;\n+    for walk_dir(p) |inner| {\n+        if !error_happened {\n+            if path_is_dir(inner) {\n+                if !remove_dir_recursive(inner) {\n+                    error_happened = true;\n+                }\n+            }\n+            else {\n+                if !remove_file(inner) {\n+                    error_happened = true;\n+                }\n+            }\n+        }\n+    };\n+    // Directory should now be empty\n+    !error_happened && remove_dir(p)\n+}\n+\n /// Removes a directory at the specified path\n pub fn remove_dir(p: &Path) -> bool {\n    return rmdir(p);\n@@ -817,6 +841,36 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n+/// Changes the current working directory to the specified\n+/// path while acquiring a global lock, then calls `action`.\n+/// If the change is successful, releases the lock and restores the\n+/// CWD to what it was before, returning true.\n+/// Returns false if the directory doesn't exist or if the directory change\n+/// is otherwise unsuccessful.\n+pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n+    use unstable::global::global_data_clone_create;\n+    use unstable::{Exclusive, exclusive};\n+\n+    fn key(_: Exclusive<()>) { }\n+\n+    let result = unsafe {\n+        global_data_clone_create(key, || {\n+            ~exclusive(())\n+        })\n+    };\n+\n+    do result.with_imm() |_| {\n+        let old_dir = os::getcwd();\n+        if change_dir(p) {\n+            action();\n+            change_dir(&old_dir)\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}\n+\n /// Copies a file from one location to another\n pub fn copy_file(from: &Path, to: &Path) -> bool {\n     return do_copy_file(from, to);\n@@ -845,6 +899,10 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             if istream as uint == 0u {\n                 return false;\n             }\n+            // Preserve permissions\n+            let from_mode = from.get_mode().expect(\"copy_file: couldn't get permissions \\\n+                                                    for source file\");\n+\n             let ostream = do as_c_charp(to.to_str()) |top| {\n                 do as_c_charp(\"w+b\") |modebuf| {\n                     libc::fopen(top, modebuf)\n@@ -876,6 +934,15 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             }\n             fclose(istream);\n             fclose(ostream);\n+\n+            // Give the new file the old file's permissions\n+            unsafe {\n+                if do str::as_c_str(to.to_str()) |to_buf| {\n+                    libc::chmod(to_buf, from_mode as mode_t)\n+                } != 0 {\n+                    return false; // should be a condition...\n+                }\n+            }\n             return ok;\n         }\n     }\n@@ -1152,6 +1219,88 @@ pub fn set_args(new_args: ~[~str]) {\n     }\n }\n \n+// FIXME #6100 we should really use an internal implementation of this - using\n+// the POSIX glob functions isn't portable to windows, probably has slight\n+// inconsistencies even where it is implemented, and makes extending\n+// functionality a lot more difficult\n+// FIXME #6101 also provide a non-allocating version - each_glob or so?\n+/// Returns a vector of Path objects that match the given glob pattern\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+pub fn glob(pattern: &str) -> ~[Path] {\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"android\")]\n+    fn default_glob_t () -> libc::glob_t {\n+        libc::glob_t {\n+            gl_pathc: 0,\n+            gl_pathv: ptr::null(),\n+            gl_offs: 0,\n+            __unused1: ptr::null(),\n+            __unused2: ptr::null(),\n+            __unused3: ptr::null(),\n+            __unused4: ptr::null(),\n+            __unused5: ptr::null(),\n+        }\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    fn default_glob_t () -> libc::glob_t {\n+        libc::glob_t {\n+            gl_pathc: 0,\n+            __unused1: 0,\n+            gl_offs: 0,\n+            __unused2: 0,\n+            gl_pathv: ptr::null(),\n+            __unused3: ptr::null(),\n+            __unused4: ptr::null(),\n+            __unused5: ptr::null(),\n+            __unused6: ptr::null(),\n+            __unused7: ptr::null(),\n+            __unused8: ptr::null(),\n+        }\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    fn default_glob_t () -> libc::glob_t {\n+        libc::glob_t {\n+            gl_pathc: 0,\n+            __unused1: 0,\n+            gl_offs: 0,\n+            __unused2: 0,\n+            gl_pathv: ptr::null(),\n+            __unused3: ptr::null(),\n+            __unused4: ptr::null(),\n+            __unused5: ptr::null(),\n+            __unused6: ptr::null(),\n+            __unused7: ptr::null(),\n+            __unused8: ptr::null(),\n+        }\n+    }\n+\n+    let mut g = default_glob_t();\n+    do str::as_c_str(pattern) |c_pattern| {\n+        unsafe { libc::glob(c_pattern, 0, ptr::null(), &mut g) }\n+    };\n+    do(|| {\n+        let paths = unsafe {\n+            vec::raw::from_buf_raw(g.gl_pathv, g.gl_pathc as uint)\n+        };\n+        do paths.map |&c_str| {\n+            Path(unsafe { str::raw::from_c_str(c_str) })\n+        }\n+    }).finally {\n+        unsafe { libc::globfree(&mut g) };\n+    }\n+}\n+\n+/// Returns a vector of Path objects that match the given glob pattern\n+#[cfg(target_os = \"win32\")]\n+pub fn glob(pattern: &str) -> ~[Path] {\n+    fail!(~\"glob() is unimplemented on Windows\")\n+}\n+\n #[cfg(target_os = \"macos\")]\n extern {\n     // These functions are in crt_externs.h.\n@@ -1480,13 +1629,15 @@ mod tests {\n                       == buf.len() as size_t))\n           }\n           assert!((libc::fclose(ostream) == (0u as c_int)));\n+          let in_mode = in.get_mode();\n           let rs = os::copy_file(&in, &out);\n           if (!os::path_exists(&in)) {\n             fail!(fmt!(\"%s doesn't exist\", in.to_str()));\n           }\n           assert!((rs));\n           let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n           assert!((rslt == 0));\n+          assert!(out.get_mode() == in_mode);\n           assert!((remove_file(&in)));\n           assert!((remove_file(&out)));\n         }"}, {"sha": "599591e2f6d7afb07e03f83fafcb607607ab8b9c", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -31,4 +31,3 @@ impl<T:Ord> Ord for ~T {\n     #[inline(always)]\n     fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }\n-"}, {"sha": "19674900f908e07d55f74b733f3f3ea11e9a44d4", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -86,7 +86,9 @@ use cast::{forget, transmute, transmute_copy};\n use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n+use ops::Drop;\n use option::{None, Option, Some};\n+use unstable::finally::Finally;\n use unstable::intrinsics;\n use ptr;\n use task;\n@@ -301,7 +303,7 @@ struct BufferResource<T> {\n }\n \n #[unsafe_destructor]\n-impl<T> ::ops::Drop for BufferResource<T> {\n+impl<T> Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n             let b = move_it!(self.buffer);\n@@ -395,26 +397,22 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n \n-    #[unsafe_destructor]\n-    struct DropState<'self> {\n-        p: &'self PacketHeader,\n-\n-        drop {\n-            unsafe {\n-                if task::failing() {\n-                    self.p.state = Terminated;\n-                    let old_task = swap_task(&mut self.p.blocked_task,\n-                                             ptr::null());\n-                    if !old_task.is_null() {\n-                        rustrt::rust_task_deref(old_task);\n-                    }\n+    do (|| {\n+        try_recv_(p)\n+    }).finally {\n+        unsafe {\n+            if task::failing() {\n+                p.header.state = Terminated;\n+                let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n+                if !old_task.is_null() {\n+                    rustrt::rust_task_deref(old_task);\n                 }\n             }\n         }\n-    };\n-\n-    let _drop_state = DropState { p: &p.header };\n+    }\n+}\n \n+fn try_recv_<T:Owned>(p: &Packet<T>) -> Option<T> {\n     // optimistic path\n     match p.header.state {\n       Full => {\n@@ -451,7 +449,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n                                        Blocked);\n         match old_state {\n           Empty => {\n-            debug!(\"no data available on %?, going to sleep.\", p_);\n+            debug!(\"no data available on %?, going to sleep.\", p);\n             if count == 0 {\n                 wait_event(this);\n             }\n@@ -641,7 +639,7 @@ pub struct SendPacketBuffered<T, Tbuffer> {\n }\n \n #[unsafe_destructor]\n-impl<T:Owned,Tbuffer:Owned> ::ops::Drop for SendPacketBuffered<T,Tbuffer> {\n+impl<T:Owned,Tbuffer:Owned> Drop for SendPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n         //if self.p != none {\n         //    debug!(\"drop send %?\", option::get(self.p));\n@@ -710,7 +708,7 @@ pub struct RecvPacketBuffered<T, Tbuffer> {\n }\n \n #[unsafe_destructor]\n-impl<T:Owned,Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n+impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n         //if self.p != none {\n         //    debug!(\"drop recv %?\", option::get(self.p));"}, {"sha": "42401ae5a1fcdab61d70220f1032cfd9723ffc39", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -14,7 +14,7 @@\n \n pub use either::{Either, Left, Right};\n pub use kinds::{Const, Copy, Owned, Durable};\n-pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n+pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop};\n pub use ops::{Shl, Shr, Index};\n@@ -28,7 +28,7 @@ pub use io::{print, println};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use old_iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n@@ -48,6 +48,7 @@ pub use path::WindowsPath;\n pub use ptr::Ptr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n pub use str::{StrSlice, OwnedStr};\n+pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};"}, {"sha": "80f69f067eb543fe9445f12eaa2011a0b0516bf9", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -16,6 +16,9 @@ and so can be used to generate any type that implements `Rand`. Type inference\n means that often a simple call to `rand::random()` or `rng.gen()` will\n suffice, but sometimes an annotation is required, e.g. `rand::random::<float>()`.\n \n+See the `distributions` submodule for sampling random numbers from\n+distributions like normal and exponential.\n+\n # Examples\n ~~~\n use core::rand::RngUtil;\n@@ -47,6 +50,9 @@ use util;\n use vec;\n use libc::size_t;\n \n+#[path=\"rand/distributions.rs\"]\n+pub mod distributions;\n+\n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n     fn rand<R: Rng>(rng: &R) -> Self;\n@@ -1067,12 +1073,3 @@ mod tests {\n         }\n     }\n }\n-\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "a644f60db69fb1c6b9ee3a2d2d1ba1c046d88de6", "filename": "src/libcore/rand/distributions.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand%2Fdistributions.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Sampling from random distributions\n+\n+// Some implementations use the Ziggurat method\n+// https://en.wikipedia.org/wiki/Ziggurat_algorithm\n+//\n+// The version used here is ZIGNOR [Doornik 2005, \"An Improved\n+// Ziggurat Method to Generate Normal Random Samples\"] which is slower\n+// (about double, it generates an extra random number) than the\n+// canonical version [Marsaglia & Tsang 2000, \"The Ziggurat Method for\n+// Generating Random Variables\"], but more robust. If one wanted, one\n+// could implement VIZIGNOR the ZIGNOR paper for more speed.\n+\n+use prelude::*;\n+use rand::{Rng,Rand};\n+\n+mod ziggurat_tables;\n+\n+// inlining should mean there is no performance penalty for this\n+#[inline(always)]\n+fn ziggurat<R:Rng>(rng: &R,\n+                   center_u: bool,\n+                   X: ziggurat_tables::ZigTable,\n+                   F: ziggurat_tables::ZigTable,\n+                   F_DIFF: ziggurat_tables::ZigTable,\n+                   pdf: &'static fn(f64) -> f64, // probability density function\n+                   zero_case: &'static fn(&R, f64) -> f64) -> f64 {\n+    loop {\n+        let u = if center_u {2.0 * rng.gen() - 1.0} else {rng.gen()};\n+        let i: uint = rng.gen::<uint>() & 0xff;\n+        let x = u * X[i];\n+\n+        let test_x = if center_u {f64::abs(x)} else {x};\n+\n+        // algebraically equivalent to |u| < X[i+1]/X[i] (or u < X[i+1]/X[i])\n+        if test_x < X[i + 1] {\n+            return x;\n+        }\n+        if i == 0 {\n+            return zero_case(rng, u);\n+        }\n+        // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n+        if F[i+1] + F_DIFF[i+1] * rng.gen() < pdf(x) {\n+            return x;\n+        }\n+    }\n+}\n+\n+/// A wrapper around an `f64` to generate N(0, 1) random numbers (a.k.a.  a\n+/// standard normal, or Gaussian). Multiplying the generated values by the\n+/// desired standard deviation `sigma` then adding the desired mean `mu` will\n+/// give N(mu, sigma^2) distributed random numbers.\n+///\n+/// Note that this has to be unwrapped before use as an `f64` (using either\n+/// `*` or `cast::transmute` is safe).\n+///\n+/// # Example\n+///\n+/// ~~~\n+/// use core::rand::distributions::StandardNormal;\n+///\n+/// fn main() {\n+///     let normal = 2.0 + (*rand::random::<StandardNormal>()) * 3.0;\n+///     println(fmt!(\"%f is from a N(2, 9) distribution\", normal))\n+/// }\n+/// ~~~\n+pub struct StandardNormal(f64);\n+\n+impl Rand for StandardNormal {\n+    fn rand<R:Rng>(rng: &R) -> StandardNormal {\n+        #[inline(always)]\n+        fn pdf(x: f64) -> f64 {\n+            f64::exp((-x*x/2.0) as f64) as f64\n+        }\n+        #[inline(always)]\n+        fn zero_case<R:Rng>(rng: &R, u: f64) -> f64 {\n+            // compute a random number in the tail by hand\n+\n+            // strange initial conditions, because the loop is not\n+            // do-while, so the condition should be true on the first\n+            // run, they get overwritten anyway (0 < 1, so these are\n+            // good).\n+            let mut x = 1.0, y = 0.0;\n+\n+            // XXX infinities?\n+            while -2.0*y < x * x {\n+                x = f64::ln(rng.gen()) / ziggurat_tables::ZIG_NORM_R;\n+                y = f64::ln(rng.gen());\n+            }\n+            if u < 0.0 {x-ziggurat_tables::ZIG_NORM_R} else {ziggurat_tables::ZIG_NORM_R-x}\n+        }\n+\n+        StandardNormal(ziggurat(\n+            rng,\n+            true, // this is symmetric\n+            &ziggurat_tables::ZIG_NORM_X,\n+            &ziggurat_tables::ZIG_NORM_F, &ziggurat_tables::ZIG_NORM_F_DIFF,\n+            pdf, zero_case))\n+    }\n+}\n+\n+/// A wrapper around an `f64` to generate Exp(1) random numbers. Dividing by\n+/// the desired rate `lambda` will give Exp(lambda) distributed random\n+/// numbers.\n+///\n+/// Note that this has to be unwrapped before use as an `f64` (using either\n+/// `*` or `cast::transmute` is safe).\n+///\n+/// # Example\n+///\n+/// ~~~\n+/// use core::rand::distributions::Exp1;\n+///\n+/// fn main() {\n+///     let exp2 = (*rand::random::<Exp1>()) * 0.5;\n+///     println(fmt!(\"%f is from a Exp(2) distribution\", exp2));\n+/// }\n+/// ~~~\n+pub struct Exp1(f64);\n+\n+// This could be done via `-f64::ln(rng.gen::<f64>())` but that is slower.\n+impl Rand for Exp1 {\n+    #[inline]\n+    fn rand<R:Rng>(rng: &R) -> Exp1 {\n+        #[inline(always)]\n+        fn pdf(x: f64) -> f64 {\n+            f64::exp(-x)\n+        }\n+        #[inline(always)]\n+        fn zero_case<R:Rng>(rng: &R, _u: f64) -> f64 {\n+            ziggurat_tables::ZIG_EXP_R - f64::ln(rng.gen())\n+        }\n+\n+        Exp1(ziggurat(rng, false,\n+                      &ziggurat_tables::ZIG_EXP_X,\n+                      &ziggurat_tables::ZIG_EXP_F, &ziggurat_tables::ZIG_EXP_F_DIFF,\n+                      pdf, zero_case))\n+    }\n+}"}, {"sha": "aca2457cac42c282dc10355e1ba38e827a7da40f", "filename": "src/libcore/rand/ziggurat_tables.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frand%2Fziggurat_tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frand%2Fziggurat_tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand%2Fziggurat_tables.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tables for distributions which are sampled using the ziggurat\n+// algorithm. Autogenerated by `ziggurat_tables.py`.\n+\n+pub type ZigTable = &'static [f64, .. 257];\n+pub static ZIG_NORM_R: f64 = 3.654152885361008796;\n+pub static ZIG_NORM_X: [f64, .. 257] =\n+    [3.910757959537090045, 3.654152885361008796, 3.449278298560964462, 3.320244733839166074,\n+     3.224575052047029100, 3.147889289517149969, 3.083526132001233044, 3.027837791768635434,\n+     2.978603279880844834, 2.934366867207854224, 2.894121053612348060, 2.857138730872132548,\n+     2.822877396825325125, 2.790921174000785765, 2.760944005278822555, 2.732685359042827056,\n+     2.705933656121858100, 2.680514643284522158, 2.656283037575502437, 2.633116393630324570,\n+     2.610910518487548515, 2.589575986706995181, 2.569035452680536569, 2.549221550323460761,\n+     2.530075232158516929, 2.511544441625342294, 2.493583041269680667, 2.476149939669143318,\n+     2.459208374333311298, 2.442725318198956774, 2.426670984935725972, 2.411018413899685520,\n+     2.395743119780480601, 2.380822795170626005, 2.366237056715818632, 2.351967227377659952,\n+     2.337996148795031370, 2.324308018869623016, 2.310888250599850036, 2.297723348901329565,\n+     2.284800802722946056, 2.272108990226823888, 2.259637095172217780, 2.247375032945807760,\n+     2.235313384928327984, 2.223443340090905718, 2.211756642882544366, 2.200245546609647995,\n+     2.188902771624720689, 2.177721467738641614, 2.166695180352645966, 2.155817819875063268,\n+     2.145083634046203613, 2.134487182844320152, 2.124023315687815661, 2.113687150684933957,\n+     2.103474055713146829, 2.093379631137050279, 2.083399693996551783, 2.073530263516978778,\n+     2.063767547809956415, 2.054107931648864849, 2.044547965215732788, 2.035084353727808715,\n+     2.025713947862032960, 2.016433734904371722, 2.007240830558684852, 1.998132471356564244,\n+     1.989106007615571325, 1.980158896898598364, 1.971288697931769640, 1.962493064942461896,\n+     1.953769742382734043, 1.945116560006753925, 1.936531428273758904, 1.928012334050718257,\n+     1.919557336591228847, 1.911164563769282232, 1.902832208548446369, 1.894558525668710081,\n+     1.886341828534776388, 1.878180486290977669, 1.870072921069236838, 1.862017605397632281,\n+     1.854013059758148119, 1.846057850283119750, 1.838150586580728607, 1.830289919680666566,\n+     1.822474540091783224, 1.814703175964167636, 1.806974591348693426, 1.799287584547580199,\n+     1.791640986550010028, 1.784033659547276329, 1.776464495522344977, 1.768932414909077933,\n+     1.761436365316706665, 1.753975320315455111, 1.746548278279492994, 1.739154261283669012,\n+     1.731792314050707216, 1.724461502945775715, 1.717160915015540690, 1.709889657069006086,\n+     1.702646854797613907, 1.695431651932238548, 1.688243209434858727, 1.681080704722823338,\n+     1.673943330923760353, 1.666830296159286684, 1.659740822855789499, 1.652674147080648526,\n+     1.645629517902360339, 1.638606196773111146, 1.631603456932422036, 1.624620582830568427,\n+     1.617656869570534228, 1.610711622367333673, 1.603784156023583041, 1.596873794420261339,\n+     1.589979870021648534, 1.583101723393471438, 1.576238702733332886, 1.569390163412534456,\n+     1.562555467528439657, 1.555733983466554893, 1.548925085471535512, 1.542128153226347553,\n+     1.535342571438843118, 1.528567729435024614, 1.521803020758293101, 1.515047842773992404,\n+     1.508301596278571965, 1.501563685112706548, 1.494833515777718391, 1.488110497054654369,\n+     1.481394039625375747, 1.474683555695025516, 1.467978458615230908, 1.461278162507407830,\n+     1.454582081885523293, 1.447889631277669675, 1.441200224845798017, 1.434513276002946425,\n+     1.427828197027290358, 1.421144398672323117, 1.414461289772464658, 1.407778276843371534,\n+     1.401094763676202559, 1.394410150925071257, 1.387723835686884621, 1.381035211072741964,\n+     1.374343665770030531, 1.367648583594317957, 1.360949343030101844, 1.354245316759430606,\n+     1.347535871177359290, 1.340820365893152122, 1.334098153216083604, 1.327368577624624679,\n+     1.320630975217730096, 1.313884673146868964, 1.307128989027353860, 1.300363230327433728,\n+     1.293586693733517645, 1.286798664489786415, 1.279998415710333237, 1.273185207661843732,\n+     1.266358287014688333, 1.259516886060144225, 1.252660221891297887, 1.245787495544997903,\n+     1.238897891102027415, 1.231990574742445110, 1.225064693752808020, 1.218119375481726552,\n+     1.211153726239911244, 1.204166830140560140, 1.197157747875585931, 1.190125515422801650,\n+     1.183069142678760732, 1.175987612011489825, 1.168879876726833800, 1.161744859441574240,\n+     1.154581450355851802, 1.147388505416733873, 1.140164844363995789, 1.132909248648336975,\n+     1.125620459211294389, 1.118297174115062909, 1.110938046009249502, 1.103541679420268151,\n+     1.096106627847603487, 1.088631390649514197, 1.081114409698889389, 1.073554065787871714,\n+     1.065948674757506653, 1.058296483326006454, 1.050595664586207123, 1.042844313139370538,\n+     1.035040439828605274, 1.027181966030751292, 1.019266717460529215, 1.011292417434978441,\n+     1.003256679539591412, 0.995156999629943084, 0.986990747093846266, 0.978755155288937750,\n+     0.970447311058864615, 0.962064143217605250, 0.953602409875572654, 0.945058684462571130,\n+     0.936429340280896860, 0.927710533396234771, 0.918898183643734989, 0.909987953490768997,\n+     0.900975224455174528, 0.891855070726792376, 0.882622229578910122, 0.873271068082494550,\n+     0.863795545546826915, 0.854189171001560554, 0.844444954902423661, 0.834555354079518752,\n+     0.824512208745288633, 0.814306670128064347, 0.803929116982664893, 0.793369058833152785,\n+     0.782615023299588763, 0.771654424216739354, 0.760473406422083165, 0.749056662009581653,\n+     0.737387211425838629, 0.725446140901303549, 0.713212285182022732, 0.700661841097584448,\n+     0.687767892786257717, 0.674499822827436479, 0.660822574234205984, 0.646695714884388928,\n+     0.632072236375024632, 0.616896989996235545, 0.601104617743940417, 0.584616766093722262,\n+     0.567338257040473026, 0.549151702313026790, 0.529909720646495108, 0.509423329585933393,\n+     0.487443966121754335, 0.463634336771763245, 0.437518402186662658, 0.408389134588000746,\n+     0.375121332850465727, 0.335737519180459465, 0.286174591747260509, 0.215241895913273806,\n+     0.000000000000000000];\n+pub static ZIG_NORM_F: [f64, .. 257] =\n+    [0.000477467764586655, 0.001260285930498598, 0.002609072746106363, 0.004037972593371872,\n+     0.005522403299264754, 0.007050875471392110, 0.008616582769422917, 0.010214971439731100,\n+     0.011842757857943104, 0.013497450601780807, 0.015177088307982072, 0.016880083152595839,\n+     0.018605121275783350, 0.020351096230109354, 0.022117062707379922, 0.023902203305873237,\n+     0.025705804008632656, 0.027527235669693315, 0.029365939758230111, 0.031221417192023690,\n+     0.033093219458688698, 0.034980941461833073, 0.036884215688691151, 0.038802707404656918,\n+     0.040736110656078753, 0.042684144916619378, 0.044646552251446536, 0.046623094902089664,\n+     0.048613553216035145, 0.050617723861121788, 0.052635418276973649, 0.054666461325077916,\n+     0.056710690106399467, 0.058767952921137984, 0.060838108349751806, 0.062921024437977854,\n+     0.065016577971470438, 0.067124653828023989, 0.069245144397250269, 0.071377949059141965,\n+     0.073522973714240991, 0.075680130359194964, 0.077849336702372207, 0.080030515814947509,\n+     0.082223595813495684, 0.084428509570654661, 0.086645194450867782, 0.088873592068594229,\n+     0.091113648066700734, 0.093365311913026619, 0.095628536713353335, 0.097903279039215627,\n+     0.100189498769172020, 0.102487158942306270, 0.104796225622867056, 0.107116667775072880,\n+     0.109448457147210021, 0.111791568164245583, 0.114145977828255210, 0.116511665626037014,\n+     0.118888613443345698, 0.121276805485235437, 0.123676228202051403, 0.126086870220650349,\n+     0.128508722280473636, 0.130941777174128166, 0.133386029692162844, 0.135841476571757352,\n+     0.138308116449064322, 0.140785949814968309, 0.143274978974047118, 0.145775208006537926,\n+     0.148286642733128721, 0.150809290682410169, 0.153343161060837674, 0.155888264725064563,\n+     0.158444614156520225, 0.161012223438117663, 0.163591108232982951, 0.166181285765110071,\n+     0.168782774801850333, 0.171395595638155623, 0.174019770082499359, 0.176655321444406654,\n+     0.179302274523530397, 0.181960655600216487, 0.184630492427504539, 0.187311814224516926,\n+     0.190004651671193070, 0.192709036904328807, 0.195425003514885592, 0.198152586546538112,\n+     0.200891822495431333, 0.203642749311121501, 0.206405406398679298, 0.209179834621935651,\n+     0.211966076307852941, 0.214764175252008499, 0.217574176725178370, 0.220396127481011589,\n+     0.223230075764789593, 0.226076071323264877, 0.228934165415577484, 0.231804410825248525,\n+     0.234686861873252689, 0.237581574432173676, 0.240488605941449107, 0.243408015423711988,\n+     0.246339863502238771, 0.249284212419516704, 0.252241126056943765, 0.255210669955677150,\n+     0.258192911338648023, 0.261187919133763713, 0.264195763998317568, 0.267216518344631837,\n+     0.270250256366959984, 0.273297054069675804, 0.276356989296781264, 0.279430141762765316,\n+     0.282516593084849388, 0.285616426816658109, 0.288729728483353931, 0.291856585618280984,\n+     0.294997087801162572, 0.298151326697901342, 0.301319396102034120, 0.304501391977896274,\n+     0.307697412505553769, 0.310907558127563710, 0.314131931597630143, 0.317370638031222396,\n+     0.320623784958230129, 0.323891482377732021, 0.327173842814958593, 0.330470981380537099,\n+     0.333783015832108509, 0.337110066638412809, 0.340452257045945450, 0.343809713148291340,\n+     0.347182563958251478, 0.350570941482881204, 0.353974980801569250, 0.357394820147290515,\n+     0.360830600991175754, 0.364282468130549597, 0.367750569780596226, 0.371235057669821344,\n+     0.374736087139491414, 0.378253817247238111, 0.381788410875031348, 0.385340034841733958,\n+     0.388908860020464597, 0.392495061461010764, 0.396098818517547080, 0.399720314981931668,\n+     0.403359739222868885, 0.407017284331247953, 0.410693148271983222, 0.414387534042706784,\n+     0.418100649839684591, 0.421832709231353298, 0.425583931339900579, 0.429354541031341519,\n+     0.433144769114574058, 0.436954852549929273, 0.440785034667769915, 0.444635565397727750,\n+     0.448506701509214067, 0.452398706863882505, 0.456311852680773566, 0.460246417814923481,\n+     0.464202689050278838, 0.468180961407822172, 0.472181538469883255, 0.476204732721683788,\n+     0.480250865911249714, 0.484320269428911598, 0.488413284707712059, 0.492530263646148658,\n+     0.496671569054796314, 0.500837575128482149, 0.505028667945828791, 0.509245245998136142,\n+     0.513487720749743026, 0.517756517232200619, 0.522052074674794864, 0.526374847174186700,\n+     0.530725304406193921, 0.535103932383019565, 0.539511234259544614, 0.543947731192649941,\n+     0.548413963257921133, 0.552910490428519918, 0.557437893621486324, 0.561996775817277916,\n+     0.566587763258951771, 0.571211506738074970, 0.575868682975210544, 0.580559996103683473,\n+     0.585286179266300333, 0.590047996335791969, 0.594846243770991268, 0.599681752622167719,\n+     0.604555390700549533, 0.609468064928895381, 0.614420723892076803, 0.619414360609039205,\n+     0.624450015550274240, 0.629528779928128279, 0.634651799290960050, 0.639820277456438991,\n+     0.645035480824251883, 0.650298743114294586, 0.655611470583224665, 0.660975147780241357,\n+     0.666391343912380640, 0.671861719900766374, 0.677388036222513090, 0.682972161648791376,\n+     0.688616083008527058, 0.694321916130032579, 0.700091918140490099, 0.705928501336797409,\n+     0.711834248882358467, 0.717811932634901395, 0.723864533472881599, 0.729995264565802437,\n+     0.736207598131266683, 0.742505296344636245, 0.748892447223726720, 0.755373506511754500,\n+     0.761953346841546475, 0.768637315803334831, 0.775431304986138326, 0.782341832659861902,\n+     0.789376143571198563, 0.796542330428254619, 0.803849483176389490, 0.811307874318219935,\n+     0.818929191609414797, 0.826726833952094231, 0.834716292992930375, 0.842915653118441077,\n+     0.851346258465123684, 0.860033621203008636, 0.869008688043793165, 0.878309655816146839,\n+     0.887984660763399880, 0.898095921906304051, 0.908726440060562912, 0.919991505048360247,\n+     0.932060075968990209, 0.945198953453078028, 0.959879091812415930, 0.977101701282731328,\n+     1.000000000000000000];\n+pub static ZIG_NORM_F_DIFF: [f64, .. 257] =\n+    [0.000000000000000000, 0.000782818165911943, 0.001348786815607765, 0.001428899847265509,\n+     0.001484430705892882, 0.001528472172127356, 0.001565707298030807, 0.001598388670308183,\n+     0.001627786418212004, 0.001654692743837703, 0.001679637706201265, 0.001702994844613767,\n+     0.001725038123187510, 0.001745974954326004, 0.001765966477270568, 0.001785140598493315,\n+     0.001803600702759419, 0.001821431661060659, 0.001838704088536796, 0.001855477433793579,\n+     0.001871802266665008, 0.001887722003144375, 0.001903274226858077, 0.001918491715965767,\n+     0.001933403251421835, 0.001948034260540625, 0.001962407334827158, 0.001976542650643127,\n+     0.001990458313945481, 0.002004170645086643, 0.002017694415851860, 0.002031043048104267,\n+     0.002044228781321551, 0.002057262814738517, 0.002070155428613822, 0.002082916088226049,\n+     0.002095553533492583, 0.002108075856553551, 0.002120490569226280, 0.002132804661891696,\n+     0.002145024655099026, 0.002157156644953973, 0.002169206343177243, 0.002181179112575302,\n+     0.002193079998548175, 0.002204913757158977, 0.002216684880213121, 0.002228397617726446,\n+     0.002240055998106505, 0.002251663846325885, 0.002263224800326716, 0.002274742325862292,\n+     0.002286219729956393, 0.002297660173134250, 0.002309066680560787, 0.002320442152205823,\n+     0.002331789372137141, 0.002343111017035562, 0.002354409664009627, 0.002365687797781804,\n+     0.002376947817308683, 0.002388192041889739, 0.002399422716815966, 0.002410642018598946,\n+     0.002421852059823287, 0.002433054893654529, 0.002444252518034679, 0.002455446879594508,\n+     0.002466639877306970, 0.002477833365903986, 0.002489029159078809, 0.002500229032490808,\n+     0.002511434726590794, 0.002522647949281448, 0.002533870378427505, 0.002545103664226889,\n+     0.002556349431455662, 0.002567609281597438, 0.002578884794865288, 0.002590177532127119,\n+     0.002601489036740262, 0.002612820836305291, 0.002624174444343735, 0.002635551361907296,\n+     0.002646953079123743, 0.002658381076686089, 0.002669836827288052, 0.002681321797012387,\n+     0.002692837446676144, 0.002704385233135737, 0.002715966610556786, 0.002727583031652520,\n+     0.002739235948893221, 0.002750926815690169, 0.002762657087557796, 0.002774428223256353,\n+     0.002786241685917290, 0.002798098944155558, 0.002810001473169871, 0.002821950755833219,\n+     0.002833948283778004, 0.002845995558475284, 0.002858094092312607, 0.002870245409671041,\n+     0.002882451048004164, 0.002894712558920987, 0.002907031509275432, 0.002919409482262880,\n+     0.002931848078526783, 0.002944348917277934, 0.002956913637427061, 0.002969543898733384,\n+     0.002982241382970874, 0.002995007795115689, 0.003007844864553855, 0.003020754346314269,\n+     0.003033738022328147, 0.003046797702715820, 0.003059935227105459, 0.003073152465984053,\n+     0.003086451322084072, 0.003099833731808721, 0.003113301666695822, 0.003126857134927052,\n+     0.003140502182881588, 0.003154238896738770, 0.003168069404132778, 0.003181995875862154,\n+     0.003196020527657495, 0.003210145622009941, 0.003224373470066433, 0.003238706433592253,\n+     0.003253146927007733, 0.003267697419501892, 0.003282360437226572, 0.003297138565578506,\n+     0.003312034451571411, 0.003327050806304299, 0.003342190407532641, 0.003357456102345890,\n+     0.003372850809960137, 0.003388377524629727, 0.003404039318688046, 0.003419839345721265,\n+     0.003435780843885239, 0.003451867139373843, 0.003468101650046629, 0.003484487889225119,\n+     0.003501029469670069, 0.003517730107746697, 0.003534593627793237, 0.003551623966702611,\n+     0.003568825178730639, 0.003586201440546166, 0.003603757056536316, 0.003621496464384588,\n+     0.003639424240937217, 0.003657545108379068, 0.003675863940735269, 0.003694385770723563,\n+     0.003713115796977806, 0.003732059391668707, 0.003751222108547281, 0.003770609691440940,\n+     0.003790228083232539, 0.003810083435355216, 0.003830182117840641, 0.003850530729957835,\n+     0.003871136111486317, 0.003892005354668437, 0.003913145816891062, 0.003934565134149914,\n+     0.003956271235355358, 0.003978272357543333, 0.004000577062061084, 0.004023194251800533,\n+     0.004046133189565926, 0.004069403517661885, 0.004093015278800460, 0.004116978938436600,\n+     0.004141305408647655, 0.004166006073685835, 0.004191092817346642, 0.004216578052307351,\n+     0.004242474751606884, 0.004268796482457593, 0.004295557442594244, 0.004322772499391836,\n+     0.004350457232007221, 0.004378627976825644, 0.004407301876525049, 0.004436496933105327,\n+     0.004466232065271192, 0.004496527170598785, 0.004527403192966406, 0.004558882195791591,\n+     0.004590987441673855, 0.004623743479123199, 0.004657176237135574, 0.004691313128472929,\n+     0.004726183162616859, 0.004761817069491636, 0.004798247435199299, 0.004835508851176451,\n+     0.004873638078381815, 0.004912674228345848, 0.004952658963181422, 0.004993636716962402,\n+     0.005035654941235035, 0.005078764377854039, 0.005123019362831771, 0.005168478165478940,\n+     0.005215203367812893, 0.005263262290042703, 0.005312727468930079, 0.005363677197016692,\n+     0.005416196132139284, 0.005470375988385734, 0.005526316321746716, 0.005584125426278286,\n+     0.005643921359735682, 0.005705833121505521, 0.005770002010457520, 0.005836583196307310,\n+     0.005905747545561058, 0.005977683752542928, 0.006052600837980204, 0.006130731092920838,\n+     0.006212333565464245, 0.006297698213369562, 0.006387150879090475, 0.006481059288027780,\n+     0.006579840329791975, 0.006683968961788356, 0.006793989182803495, 0.006910527673723577,\n+     0.007034310911336661, 0.007166186857056056, 0.007307152748134871, 0.007458391141830445,\n+     0.007621317291194862, 0.007797642342679434, 0.007989459040836144, 0.008199360125510702,\n+     0.008430605346682607, 0.008687362737884952, 0.008975066840784529, 0.009300967772353674,\n+     0.009675004947253041, 0.010111261142904171, 0.010630518154258861, 0.011265064987797335,\n+     0.012068570920629962, 0.013138877484087819, 0.014680138359337902, 0.017222609470315398,\n+     0.022898298717268672];\n+pub static ZIG_EXP_R: f64 = 7.697117470131050077;\n+pub static ZIG_EXP_X: [f64, .. 257] =\n+    [8.697117470131052741, 7.697117470131050077, 6.941033629377212577, 6.478378493832569696,\n+     6.144164665772472667, 5.882144315795399869, 5.666410167454033697, 5.482890627526062488,\n+     5.323090505754398016, 5.181487281301500047, 5.054288489981304089, 4.938777085901250530,\n+     4.832939741025112035, 4.735242996601741083, 4.644491885420085175, 4.559737061707351380,\n+     4.480211746528421912, 4.405287693473573185, 4.334443680317273007, 4.267242480277365857,\n+     4.203313713735184365, 4.142340865664051464, 4.084051310408297830, 4.028208544647936762,\n+     3.974606066673788796, 3.923062500135489739, 3.873417670399509127, 3.825529418522336744,\n+     3.779270992411667862, 3.734528894039797375, 3.691201090237418825, 3.649195515760853770,\n+     3.608428813128909507, 3.568825265648337020, 3.530315889129343354, 3.492837654774059608,\n+     3.456332821132760191, 3.420748357251119920, 3.386035442460300970, 3.352149030900109405,\n+     3.319047470970748037, 3.286692171599068679, 3.255047308570449882, 3.224079565286264160,\n+     3.193757903212240290, 3.164053358025972873, 3.134938858084440394, 3.106389062339824481,\n+     3.078380215254090224, 3.050890016615455114, 3.023897504455676621, 2.997382949516130601,\n+     2.971327759921089662, 2.945714394895045718, 2.920526286512740821, 2.895747768600141825,\n+     2.871364012015536371, 2.847360965635188812, 2.823725302450035279, 2.800444370250737780,\n+     2.777506146439756574, 2.754899196562344610, 2.732612636194700073, 2.710636095867928752,\n+     2.688959688741803689, 2.667573980773266573, 2.646469963151809157, 2.625639026797788489,\n+     2.605072938740835564, 2.584763820214140750, 2.564704126316905253, 2.544886627111869970,\n+     2.525304390037828028, 2.505950763528594027, 2.486819361740209455, 2.467904050297364815,\n+     2.449198932978249754, 2.430698339264419694, 2.412396812688870629, 2.394289099921457886,\n+     2.376370140536140596, 2.358635057409337321, 2.341079147703034380, 2.323697874390196372,\n+     2.306486858283579799, 2.289441870532269441, 2.272558825553154804, 2.255833774367219213,\n+     2.239262898312909034, 2.222842503111036816, 2.206569013257663858, 2.190438966723220027,\n+     2.174449009937774679, 2.158595893043885994, 2.142876465399842001, 2.127287671317368289,\n+     2.111826546019042183, 2.096490211801715020, 2.081275874393225145, 2.066180819490575526,\n+     2.051202409468584786, 2.036338080248769611, 2.021585338318926173, 2.006941757894518563,\n+     1.992404978213576650, 1.977972700957360441, 1.963642687789548313, 1.949412758007184943,\n+     1.935280786297051359, 1.921244700591528076, 1.907302480018387536, 1.893452152939308242,\n+     1.879691795072211180, 1.866019527692827973, 1.852433515911175554, 1.838931967018879954,\n+     1.825513128903519799, 1.812175288526390649, 1.798916770460290859, 1.785735935484126014,\n+     1.772631179231305643, 1.759600930889074766, 1.746643651946074405, 1.733757834985571566,\n+     1.720942002521935299, 1.708194705878057773, 1.695514524101537912, 1.682900062917553896,\n+     1.670349953716452118, 1.657862852574172763, 1.645437439303723659, 1.633072416535991334,\n+     1.620766508828257901, 1.608518461798858379, 1.596327041286483395, 1.584191032532688892,\n+     1.572109239386229707, 1.560080483527888084, 1.548103603714513499, 1.536177455041032092,\n+     1.524300908219226258, 1.512472848872117082, 1.500692176842816750, 1.488957805516746058,\n+     1.477268661156133867, 1.465623682245745352, 1.454021818848793446, 1.442462031972012504,\n+     1.430943292938879674, 1.419464582769983219, 1.408024891569535697, 1.396623217917042137,\n+     1.385258568263121992, 1.373929956328490576, 1.362636402505086775, 1.351376933258335189,\n+     1.340150580529504643, 1.328956381137116560, 1.317793376176324749, 1.306660610415174117,\n+     1.295557131686601027, 1.284481990275012642, 1.273434238296241139, 1.262412929069615330,\n+     1.251417116480852521, 1.240445854334406572, 1.229498195693849105, 1.218573192208790124,\n+     1.207669893426761121, 1.196787346088403092, 1.185924593404202199, 1.175080674310911677,\n+     1.164254622705678921, 1.153445466655774743, 1.142652227581672841, 1.131873919411078511,\n+     1.121109547701330200, 1.110358108727411031, 1.099618588532597308, 1.088889961938546813,\n+     1.078171191511372307, 1.067461226479967662, 1.056759001602551429, 1.046063435977044209,\n+     1.035373431790528542, 1.024687873002617211, 1.014005623957096480, 1.003325527915696735,\n+     0.992646405507275897, 0.981967053085062602, 0.971286240983903260, 0.960602711668666509,\n+     0.949915177764075969, 0.939222319955262286, 0.928522784747210395, 0.917815182070044311,\n+     0.907098082715690257, 0.896370015589889935, 0.885629464761751528, 0.874874866291025066,\n+     0.864104604811004484, 0.853317009842373353, 0.842510351810368485, 0.831682837734273206,\n+     0.820832606554411814, 0.809957724057418282, 0.799056177355487174, 0.788125868869492430,\n+     0.777164609759129710, 0.766170112735434672, 0.755139984181982249, 0.744071715500508102,\n+     0.732962673584365398, 0.721810090308756203, 0.710611050909655040, 0.699362481103231959,\n+     0.688061132773747808, 0.676703568029522584, 0.665286141392677943, 0.653804979847664947,\n+     0.642255960424536365, 0.630634684933490286, 0.618936451394876075, 0.607156221620300030,\n+     0.595288584291502887, 0.583327712748769489, 0.571267316532588332, 0.559100585511540626,\n+     0.546820125163310577, 0.534417881237165604, 0.521885051592135052, 0.509211982443654398,\n+     0.496388045518671162, 0.483401491653461857, 0.470239275082169006, 0.456886840931420235,\n+     0.443327866073552401, 0.429543940225410703, 0.415514169600356364, 0.401214678896277765,\n+     0.386617977941119573, 0.371692145329917234, 0.356399760258393816, 0.340696481064849122,\n+     0.324529117016909452, 0.307832954674932158, 0.290527955491230394, 0.272513185478464703,\n+     0.253658363385912022, 0.233790483059674731, 0.212671510630966620, 0.189958689622431842,\n+     0.165127622564187282, 0.137304980940012589, 0.104838507565818778, 0.063852163815001570,\n+     0.000000000000000000];\n+pub static ZIG_EXP_F: [f64, .. 257] =\n+    [0.000167066692307963, 0.000454134353841497, 0.000967269282327174, 0.001536299780301573,\n+     0.002145967743718907, 0.002788798793574076, 0.003460264777836904, 0.004157295120833797,\n+     0.004877655983542396, 0.005619642207205489, 0.006381905937319183, 0.007163353183634991,\n+     0.007963077438017043, 0.008780314985808977, 0.009614413642502212, 0.010464810181029981,\n+     0.011331013597834600, 0.012212592426255378, 0.013109164931254991, 0.014020391403181943,\n+     0.014945968011691148, 0.015885621839973156, 0.016839106826039941, 0.017806200410911355,\n+     0.018786700744696024, 0.019780424338009740, 0.020787204072578114, 0.021806887504283581,\n+     0.022839335406385240, 0.023884420511558174, 0.024942026419731787, 0.026012046645134221,\n+     0.027094383780955803, 0.028188948763978646, 0.029295660224637411, 0.030414443910466622,\n+     0.031545232172893622, 0.032687963508959555, 0.033842582150874358, 0.035009037697397431,\n+     0.036187284781931443, 0.037377282772959382, 0.038578995503074871, 0.039792391023374139,\n+     0.041017441380414840, 0.042254122413316254, 0.043502413568888197, 0.044762297732943289,\n+     0.046033761076175184, 0.047316792913181561, 0.048611385573379504, 0.049917534282706379,\n+     0.051235237055126281, 0.052564494593071685, 0.053905310196046080, 0.055257689676697030,\n+     0.056621641283742870, 0.057997175631200659, 0.059384305633420280, 0.060783046445479660,\n+     0.062193415408541036, 0.063615431999807376, 0.065049117786753805, 0.066494496385339816,\n+     0.067951593421936643, 0.069420436498728783, 0.070901055162371843, 0.072393480875708752,\n+     0.073897746992364746, 0.075413888734058410, 0.076941943170480517, 0.078481949201606435,\n+     0.080033947542319905, 0.081597980709237419, 0.083174093009632397, 0.084762330532368146,\n+     0.086362741140756927, 0.087975374467270231, 0.089600281910032886, 0.091237516631040197,\n+     0.092887133556043569, 0.094549189376055873, 0.096223742550432825, 0.097910853311492213,\n+     0.099610583670637132, 0.101322997425953631, 0.103048160171257702, 0.104786139306570145,\n+     0.106537004050001632, 0.108300825451033755, 0.110077676405185357, 0.111867631670056283,\n+     0.113670767882744286, 0.115487163578633506, 0.117316899211555525, 0.119160057175327641,\n+     0.121016721826674792, 0.122886979509545108, 0.124770918580830933, 0.126668629437510671,\n+     0.128580204545228199, 0.130505738468330773, 0.132445327901387494, 0.134399071702213602,\n+     0.136367070926428829, 0.138349428863580176, 0.140346251074862399, 0.142357645432472146,\n+     0.144383722160634720, 0.146424593878344889, 0.148480375643866735, 0.150551185001039839,\n+     0.152637142027442801, 0.154738369384468027, 0.156854992369365148, 0.158987138969314129,\n+     0.161134939917591952, 0.163298528751901734, 0.165478041874935922, 0.167673618617250081,\n+     0.169885401302527550, 0.172113535315319977, 0.174358169171353411, 0.176619454590494829,\n+     0.178897546572478278, 0.181192603475496261, 0.183504787097767436, 0.185834262762197083,\n+     0.188181199404254262, 0.190545769663195363, 0.192928149976771296, 0.195328520679563189,\n+     0.197747066105098818, 0.200183974691911210, 0.202639439093708962, 0.205113656293837654,\n+     0.207606827724221982, 0.210119159388988230, 0.212650861992978224, 0.215202151075378628,\n+     0.217773247148700472, 0.220364375843359439, 0.222975768058120111, 0.225607660116683956,\n+     0.228260293930716618, 0.230933917169627356, 0.233628783437433291, 0.236345152457059560,\n+     0.239083290262449094, 0.241843469398877131, 0.244625969131892024, 0.247431075665327543,\n+     0.250259082368862240, 0.253110290015629402, 0.255985007030415324, 0.258883549749016173,\n+     0.261806242689362922, 0.264753418835062149, 0.267725419932044739, 0.270722596799059967,\n+     0.273745309652802915, 0.276793928448517301, 0.279868833236972869, 0.282970414538780746,\n+     0.286099073737076826, 0.289255223489677693, 0.292439288161892630, 0.295651704281261252,\n+     0.298892921015581847, 0.302163400675693528, 0.305463619244590256, 0.308794066934560185,\n+     0.312155248774179606, 0.315547685227128949, 0.318971912844957239, 0.322428484956089223,\n+     0.325917972393556354, 0.329440964264136438, 0.332998068761809096, 0.336589914028677717,\n+     0.340217149066780189, 0.343880444704502575, 0.347580494621637148, 0.351318016437483449,\n+     0.355093752866787626, 0.358908472948750001, 0.362762973354817997, 0.366658079781514379,\n+     0.370594648435146223, 0.374573567615902381, 0.378595759409581067, 0.382662181496010056,\n+     0.386773829084137932, 0.390931736984797384, 0.395136981833290435, 0.399390684475231350,\n+     0.403694012530530555, 0.408048183152032673, 0.412454465997161457, 0.416914186433003209,\n+     0.421428728997616908, 0.425999541143034677, 0.430628137288459167, 0.435316103215636907,\n+     0.440065100842354173, 0.444876873414548846, 0.449753251162755330, 0.454696157474615836,\n+     0.459707615642138023, 0.464789756250426511, 0.469944825283960310, 0.475175193037377708,\n+     0.480483363930454543, 0.485871987341885248, 0.491343869594032867, 0.496901987241549881,\n+     0.502549501841348056, 0.508289776410643213, 0.514126393814748894, 0.520063177368233931,\n+     0.526104213983620062, 0.532253880263043655, 0.538516872002862246, 0.544898237672440056,\n+     0.551403416540641733, 0.558038282262587892, 0.564809192912400615, 0.571723048664826150,\n+     0.578787358602845359, 0.586010318477268366, 0.593400901691733762, 0.600968966365232560,\n+     0.608725382079622346, 0.616682180915207878, 0.624852738703666200, 0.633251994214366398,\n+     0.641896716427266423, 0.650805833414571433, 0.660000841079000145, 0.669506316731925177,\n+     0.679350572264765806, 0.689566496117078431, 0.700192655082788606, 0.711274760805076456,\n+     0.722867659593572465, 0.735038092431424039, 0.747868621985195658, 0.761463388849896838,\n+     0.775956852040116218, 0.791527636972496285, 0.808421651523009044, 0.826993296643051101,\n+     0.847785500623990496, 0.871704332381204705, 0.900469929925747703, 0.938143680862176477,\n+     1.000000000000000000];\n+pub static ZIG_EXP_F_DIFF: [f64, .. 257] =\n+    [0.000000000000000000, 0.000287067661533533, 0.000513134928485678, 0.000569030497974398,\n+     0.000609667963417335, 0.000642831049855169, 0.000671465984262828, 0.000697030342996893,\n+     0.000720360862708599, 0.000741986223663093, 0.000762263730113694, 0.000781447246315807,\n+     0.000799724254382053, 0.000817237547791934, 0.000834098656693235, 0.000850396538527769,\n+     0.000866203416804620, 0.000881578828420777, 0.000896572504999613, 0.000911226471926952,\n+     0.000925576608509206, 0.000939653828282008, 0.000953484986066785, 0.000967093584871414,\n+     0.000980500333784669, 0.000993723593313716, 0.001006779734568374, 0.001019683431705467,\n+     0.001032447902101660, 0.001045085105172934, 0.001057605908173612, 0.001070020225402434,\n+     0.001082337135821582, 0.001094564983022843, 0.001106711460658764, 0.001118783685829211,\n+     0.001130788262427001, 0.001142731336065933, 0.001154618641914802, 0.001166455546523074,\n+     0.001178247084534012, 0.001189997991027938, 0.001201712730115490, 0.001213395520299268,\n+     0.001225050357040701, 0.001236681032901414, 0.001248291155571943, 0.001259884164055092,\n+     0.001271463343231895, 0.001283031837006378, 0.001294592660197942, 0.001306148709326875,\n+     0.001317702772419903, 0.001329257537945404, 0.001340815602974395, 0.001352379480650950,\n+     0.001363951607045839, 0.001375534347457789, 0.001387130002219621, 0.001398740812059381,\n+     0.001410368963061376, 0.001422016591266340, 0.001433685786946429, 0.001445378598586011,\n+     0.001457097036596827, 0.001468843076792140, 0.001480618663643060, 0.001492425713336909,\n+     0.001504266116655995, 0.001516141741693663, 0.001528054436422108, 0.001540006031125918,\n+     0.001551998340713470, 0.001564033166917514, 0.001576112300394977, 0.001588237522735750,\n+     0.001600410608388780, 0.001612633326513305, 0.001624907442762655, 0.001637234721007311,\n+     0.001649616925003372, 0.001662055820012304, 0.001674553174376953, 0.001687110761059388,\n+     0.001699730359144919, 0.001712413755316500, 0.001725162745304071, 0.001737979135312442,\n+     0.001750864743431488, 0.001763821401032123, 0.001776850954151601, 0.001789955264870927,\n+     0.001803136212688003, 0.001816395695889220, 0.001829735632922019, 0.001843157963772116,\n+     0.001856664651347151, 0.001870257682870316, 0.001883939071285826, 0.001897710856679738,\n+     0.001911575107717528, 0.001925533923102574, 0.001939589433056721, 0.001953743800826108,\n+     0.001967999224215228, 0.001982357937151347, 0.001996822211282223, 0.002011394357609747,\n+     0.002026076728162574, 0.002040871717710169, 0.002055781765521847, 0.002070809357173103,\n+     0.002085957026402963, 0.002101227357025226, 0.002116622984897121, 0.002132146599948981,\n+     0.002147800948277823, 0.002163588834309782, 0.002179513123034188, 0.002195576742314159,\n+     0.002211782685277469, 0.002228134012792427, 0.002244633856033434, 0.002261285419141418,\n+     0.002278091981983449, 0.002295056903017983, 0.002312183622271174, 0.002329475664429648,\n+     0.002346936642057179, 0.002364570258941101, 0.002382380313575932, 0.002400370702791893,\n+     0.002418545425535629, 0.002436908586812392, 0.002455464401797752, 0.002474217200128692,\n+     0.002493171430384328, 0.002512331664766249, 0.002531702603989994, 0.002551289082400404,\n+     0.002571096073321844, 0.002591128694658967, 0.002611392214760672, 0.002631892058563845,\n+     0.002652633814032662, 0.002673623238910738, 0.002694866267805934, 0.002716369019626269,\n+     0.002738137805389534, 0.002760179136428037, 0.002782499733014893, 0.002805106533435520,\n+     0.002828006703534697, 0.002851207646767162, 0.002874717014785921, 0.002898542718600849,\n+     0.002922692940346749, 0.002947176145699226, 0.002972001096982591, 0.002997176867015228,\n+     0.003022712853742948, 0.003048618795714386, 0.003074904788455568, 0.003101581301807876,\n+     0.003128659198296080, 0.003156149752600867, 0.003184064672214937, 0.003212416119368622,\n+     0.003241216734320596, 0.003270479660111680, 0.003300218568896729, 0.003330447689969929,\n+     0.003361181839619420, 0.003392436452949343, 0.003424227617828290, 0.003456572111131984,\n+     0.003489487437467131, 0.003522991870580083, 0.003557104497672658, 0.003591845266868621,\n+     0.003627235038102472, 0.003663295637722386, 0.003700049917134574, 0.003737521815846301,\n+     0.003775736429304177, 0.003814720081962375, 0.003854500406067995, 0.003895106426696382,\n+     0.003936568653631844, 0.003978919180756157, 0.004022191793678687, 0.004066422086428989,\n+     0.004111647588127876, 0.004157907900659452, 0.004205244848493050, 0.004253702641940915,\n+     0.004303328055299205, 0.004354170621502118, 0.004406282845128784, 0.004459720435841752,\n+     0.004514542564613699, 0.004570812145417769, 0.004628596145424491, 0.004687965927177740,\n+     0.004748997626717266, 0.004811772572194672, 0.004876377748206484, 0.004942906311860507,\n+     0.005011458167522187, 0.005082140608288488, 0.005155069033533799, 0.005230367753417398,\n+     0.005308170893076836, 0.005388623411430704, 0.005471882252147620, 0.005558117647517014,\n+     0.005647514599798176, 0.005740274569295156, 0.005836617404105682, 0.005936783553485037,\n+     0.006041036615386131, 0.006149666279423593, 0.006262991739818591, 0.006381365669577810,\n+     0.006505178868201678, 0.006634865721946159, 0.006770910649812723, 0.006913855752425535,\n+     0.007064309938019209, 0.007222959874423007, 0.007390583214465396, 0.007568064673498798,\n+     0.007756415714389786, 0.007956798835585532, 0.008170557788458321, 0.008399255510700199,\n+     0.008644722212900025, 0.008909116987305010, 0.009195007664428712, 0.009505475652925033,\n+     0.009844255532840629, 0.010215923852312625, 0.010626158965710175, 0.011082105722287849,\n+     0.011592898788496009, 0.012170432837851575, 0.012830529553771619, 0.013594766864701180,\n+     0.014493463190219380, 0.015570784932380066, 0.016894014550512759, 0.018571645120042057,\n+     0.020792203980939394, 0.023918831757214210, 0.028765597544542998, 0.037673750936428774,\n+     0.061856319137823523];"}, {"sha": "3d5259932592861d489ccf1bf6dc101a34e09819", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -564,7 +564,7 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n     }\n }\n \n-#[test]\n+#[cfg(test)]\n struct P {a: int, b: float}\n \n #[test]"}, {"sha": "9c1e566f218f6aca93d67b6401f7cf0dd54d10ea", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -207,4 +207,3 @@ pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }\n-"}, {"sha": "7e891f1718e2111016751c745a67275906d0b212", "filename": "src/libcore/rt/io/comm_adapters.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -56,4 +56,3 @@ impl<W: Writer> WriterChan<W> {\n impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n     fn send(&self, _x: ~[u8]) { fail!() }\n }\n-"}, {"sha": "cff224a80bee283cd2730af0a8ae5ada5ba0e9d1", "filename": "src/libcore/rt/io/extensions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "previous_filename": "src/libcore/rt/io/util.rs"}, {"sha": "85dc180452ffc71fd541e85b27bcf3a38f7b24d2", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -9,13 +9,9 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::misc::PathLike;\n+use super::support::PathLike;\n use super::{Reader, Writer, Seek, Close};\n-use super::{IoError, SeekStyle};\n-\n-/// Open a file with the default FileMode and FileAccess\n-/// # XXX are there sane defaults here?\n-pub fn open_file<P: PathLike>(_path: &P) -> FileStream { fail!() }\n+use super::SeekStyle;\n \n /// # XXX\n /// * Ugh, this is ridiculous. What is the best way to represent these options?\n@@ -46,7 +42,7 @@ impl FileStream {\n     pub fn open<P: PathLike>(_path: &P,\n                              _mode: FileMode,\n                              _access: FileAccess\n-                            ) -> Result<FileStream, IoError> {\n+                            ) -> Option<FileStream> {\n         fail!()\n     }\n }"}, {"sha": "06e1466831df0e21b8f81b3abebe4b1baa6111c5", "filename": "src/libcore/rt/io/mem.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmem.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::*;\n use super::*;\n-\n+use cmp::min;\n \n /// Writes to an owned, growable byte vector\n pub struct MemWriter {\n@@ -29,13 +29,15 @@ impl MemWriter {\n }\n \n impl Writer for MemWriter {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        self.buf.push_all(buf)\n+    }\n \n     fn flush(&mut self) { /* no-op */ }\n }\n \n impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 { self.buf.len() as u64 }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n@@ -77,13 +79,27 @@ impl MemReader {\n }\n \n impl Reader for MemReader {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        { if self.eof() { return None; } }\n+\n+        let write_len = min(buf.len(), self.buf.len() - self.pos);\n+        {\n+            let input = self.buf.slice(self.pos, self.pos + write_len);\n+            let output = vec::mut_slice(buf, 0, write_len);\n+            assert!(input.len() == output.len());\n+            vec::bytes::copy_memory(output, input, write_len);\n+        }\n+        self.pos += write_len;\n+        assert!(self.pos <= self.buf.len());\n \n-    fn eof(&mut self) -> bool { fail!() }\n+        return Some(write_len);\n+    }\n+\n+    fn eof(&mut self) -> bool { self.pos == self.buf.len() }\n }\n \n impl Seek for MemReader {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 { self.pos as u64 }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n@@ -163,4 +179,43 @@ impl<'self> Seek for BufReader<'self> {\n     fn tell(&self) -> u64 { fail!() }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n-}\n\\ No newline at end of file\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::*;\n+\n+    #[test]\n+    fn test_mem_writer() {\n+        let mut writer = MemWriter::new();\n+        assert!(writer.tell() == 0);\n+        writer.write([0]);\n+        assert!(writer.tell() == 1);\n+        writer.write([1, 2, 3]);\n+        writer.write([4, 5, 6, 7]);\n+        assert!(writer.tell() == 8);\n+        assert!(writer.inner() == ~[0, 1, 2, 3, 4, 5 , 6, 7]);\n+    }\n+\n+    #[test]\n+    fn test_mem_reader() {\n+        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut buf = [];\n+        assert!(reader.read(buf) == Some(0));\n+        assert!(reader.tell() == 0);\n+        let mut buf = [0];\n+        assert!(reader.read(buf) == Some(1));\n+        assert!(reader.tell() == 1);\n+        assert!(buf == [0]);\n+        let mut buf = [0, ..4];\n+        assert!(reader.read(buf) == Some(4));\n+        assert!(reader.tell() == 5);\n+        assert!(buf == [1, 2, 3, 4]);\n+        assert!(reader.read(buf) == Some(3));\n+        assert!(buf.slice(0, 3) == [5, 6, 7]);\n+        assert!(reader.eof());\n+        assert!(reader.read(buf) == None);\n+        assert!(reader.eof());\n+    }\n+}"}, {"sha": "97b3ee3e30ef65a50ee7abd3e374af5b3fa42aea", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 218, "deletions": 28, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -11,7 +11,13 @@\n /*! Synchronous I/O\n \n This module defines the Rust interface for synchronous I/O.\n-It supports file access,\n+It models byte-oriented input and output with the Reader and Writer traits.\n+Types that implement both `Reader` and `Writer` and called 'streams',\n+and automatically implement trait `Stream`.\n+Implementations are provided for common I/O streams like\n+file, TCP, UDP, Unix domain sockets.\n+Readers and Writers may be composed to add capabilities like string\n+parsing, encoding, and compression.\n \n This will likely live in core::io, not core::rt::io.\n \n@@ -27,44 +33,177 @@ Some examples of obvious things you might want to do\n \n * Read a complete file to a string, (converting newlines?)\n \n-    let contents = open(\"message.txt\").read_to_str(); // read_to_str??\n+    let contents = File::open(\"message.txt\").read_to_str(); // read_to_str??\n \n * Write a line to a file\n \n-    let file = FileStream::open(\"message.txt\", Create, Write);\n+    let file = File::open(\"message.txt\", Create, Write);\n     file.write_line(\"hello, file!\");\n \n * Iterate over the lines of a file\n \n+    do File::open(\"message.txt\").each_line |line| {\n+        println(line)\n+    }\n+\n * Pull the lines of a file into a vector of strings\n \n+    let lines = File::open(\"message.txt\").line_iter().to_vec();\n+\n+* Make an simple HTTP request\n+\n+    let socket = TcpStream::open(\"localhost:8080\");\n+    socket.write_line(\"GET / HTTP/1.0\");\n+    socket.write_line(\"\");\n+    let response = socket.read_to_end();\n+\n * Connect based on URL? Requires thinking about where the URL type lives\n   and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n   yields a `TcpStream`.\n \n-    connect(\"tcp://localhost:8080\").write_line(\"HTTP 1.0 GET /\");\n+    connect(\"tcp://localhost:8080\");\n \n # Terms\n \n-* reader\n-* writer\n-* stream\n-* Blocking vs. non-blocking\n-* synchrony and asynchrony\n-\n-I tend to call this implementation non-blocking, because performing I/O\n-doesn't block the progress of other tasks. Is that how we want to present\n-it, 'synchronous but non-blocking'?\n+* Reader - An I/O source, reads bytes into a buffer\n+* Writer - An I/O sink, writes bytes from a buffer\n+* Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n+  and are collectively referred to a `streams`.\n+* Decorator - A Reader or Writer that composes with others to add additional capabilities\n+  such as encoding or decoding\n+\n+# Blocking and synchrony\n+\n+When discussing I/O you often hear the terms 'synchronous' and\n+'asynchronous', along with 'blocking' and 'non-blocking' compared and\n+contrasted. A synchronous I/O interface performs each I/O operation to\n+completion before proceeding to the next. Synchronous interfaces are\n+usually used in imperative style as a sequence of commands. An\n+asynchronous interface allows multiple I/O requests to be issued\n+simultaneously, without waiting for each to complete before proceeding\n+to the next.\n+\n+Asynchronous interfaces are used to achieve 'non-blocking' I/O. In\n+traditional single-threaded systems, performing a synchronous I/O\n+operation means that the program stops all activity (it 'blocks')\n+until the I/O is complete. Blocking is bad for performance when\n+there are other computations that could be done.\n+\n+Asynchronous interfaces are most often associated with the callback\n+(continuation-passing) style popularised by node.js. Such systems rely\n+on all computations being run inside an event loop which maintains a\n+list of all pending I/O events; when one completes the registered\n+callback is run and the code that made the I/O request continiues.\n+Such interfaces achieve non-blocking at the expense of being more\n+difficult to reason about.\n+\n+Rust's I/O interface is synchronous - easy to read - and non-blocking by default.\n+\n+Remember that Rust tasks are 'green threads', lightweight threads that\n+are multiplexed onto a single operating system thread. If that system\n+thread blocks then no other task may proceed. Rust tasks are\n+relatively cheap to create, so as long as other tasks are free to\n+execute then non-blocking code may be written by simply creating a new\n+task.\n+\n+When discussing blocking in regards to Rust's I/O model, we are\n+concerned with whether performing I/O blocks other Rust tasks from\n+proceeding. In other words, when a task calls `read`, it must then\n+wait (or 'sleep', or 'block') until the call to `read` is complete.\n+During this time, other tasks may or may not be executed, depending on\n+how `read` is implemented.\n+\n+\n+Rust's default I/O implementation is non-blocking; by cooperating\n+directly with the task scheduler it arranges to never block progress\n+of *other* tasks. Under the hood, Rust uses asynchronous I/O via a\n+per-scheduler (and hence per-thread) event loop. Synchronous I/O\n+requests are implemented by descheduling the running task and\n+performing an asynchronous request; the task is only resumed once the\n+asynchronous request completes.\n+\n+For blocking (but possibly more efficient) implementations, look\n+in the `io::native` module.\n \n # Error Handling\n \n+I/O is an area where nearly every operation can result in unexpected\n+errors. It should allow errors to be handled efficiently.\n+It needs to be convenient to use I/O when you don't care\n+about dealing with specific errors.\n+\n+Rust's I/O employs a combination of techniques to reduce boilerplate\n+while still providing feedback about errors. The basic strategy:\n+\n+* Errors are fatal by default, resulting in task failure\n+* Errors raise the `io_error` conditon which provides an opportunity to inspect\n+  an IoError object containing details.\n+* Return values must have a sensible null or zero value which is returned\n+  if a condition is handled successfully. This may be an `Option`, an empty\n+  vector, or other designated error value.\n+* Common traits are implemented for `Option`, e.g. `impl<R: Reader> Reader for Option<R>`,\n+  so that nullable values do not have to be 'unwrapped' before use.\n+\n+These features combine in the API to allow for expressions like\n+`File::new(\"diary.txt\").write_line(\"met a girl\")` without having to\n+worry about whether \"diary.txt\" exists or whether the write\n+succeeds. As written, if either `new` or `write_line` encounters\n+an error the task will fail.\n+\n+If you wanted to handle the error though you might write\n+\n+    let mut error = None;\n+    do io_error::cond(|e: IoError| {\n+        error = Some(e);\n+    }).in {\n+        File::new(\"diary.txt\").write_line(\"met a girl\");\n+    }\n+\n+    if error.is_some() {\n+        println(\"failed to write my diary\");\n+    }\n+\n+XXX: Need better condition handling syntax\n+\n+In this case the condition handler will have the opportunity to\n+inspect the IoError raised by either the call to `new` or the call to\n+`write_line`, but then execution will continue.\n+\n+So what actually happens if `new` encounters an error? To understand\n+that it's important to know that what `new` returns is not a `File`\n+but an `Option<File>`.  If the file does not open, and the condition\n+is handled, then `new` will simply return `None`. Because there is an\n+implementation of `Writer` (the trait required ultimately required for\n+types to implement `write_line`) there is no need to inspect or unwrap\n+the `Option<File>` and we simply call `write_line` on it.  If `new`\n+returned a `None` then the followup call to `write_line` will also\n+raise an error.\n+\n+## Concerns about this strategy\n+\n+This structure will encourage a programming style that is prone\n+to errors similar to null pointer dereferences.\n+In particular code written to ignore errors and expect conditions to be unhandled\n+will start passing around null or zero objects when wrapped in a condition handler.\n+\n+* XXX: How should we use condition handlers that return values?\n+\n+\n+# Issues withi/o scheduler affinity, work stealing, task pinning\n+\n # Resource management\n \n * `close` vs. RAII\n \n-# Paths and URLs\n+# Paths, URLs and overloaded constructors\n+\n+\n+\n+# Scope\n \n-# std\n+In scope for core\n+\n+* Url?\n \n Some I/O things don't belong in core\n \n@@ -73,7 +212,12 @@ Some I/O things don't belong in core\n     - http\n   - flate\n \n-# XXX\n+Out of scope\n+\n+* Async I/O. We'll probably want it eventually\n+\n+\n+# XXX Questions and issues\n \n * Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n   Overloading would be nice.\n@@ -83,6 +227,7 @@ Some I/O things don't belong in core\n * fsync\n * relationship with filesystem querying, Directory, File types etc.\n * Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n+* Can Port and Chan be implementations of a generic Reader<T>/Writer<T>?\n * Trait for things that are both readers and writers, Stream?\n * How to handle newline conversion\n * String conversion\n@@ -92,6 +237,7 @@ Some I/O things don't belong in core\n * Do we need `close` at all? dtors might be good enough\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n+* Using conditions is a big unknown since we don't have much experience with them\n \n */\n \n@@ -104,43 +250,51 @@ pub use self::stdio::stderr;\n pub use self::stdio::print;\n pub use self::stdio::println;\n \n-pub use self::file::open_file;\n pub use self::file::FileStream;\n-pub use self::net::Listener;\n pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n // Some extension traits that all Readers and Writers get.\n-pub use self::util::ReaderUtil;\n-pub use self::util::ReaderByteConversions;\n-pub use self::util::WriterByteConversions;\n+pub use self::extensions::ReaderUtil;\n+pub use self::extensions::ReaderByteConversions;\n+pub use self::extensions::WriterByteConversions;\n \n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n-#[path = \"net/mod.rs\"]\n-pub mod net;\n+pub mod net {\n+    pub mod tcp;\n+    pub mod udp;\n+    pub mod ip;\n+    #[cfg(unix)]\n+    pub mod unix;\n+    pub mod http;\n+}\n \n /// Readers and Writers for memory buffers and strings.\n pub mod mem;\n \n /// Non-blocking access to stdin, stdout, stderr\n pub mod stdio;\n \n+/// Implementations for Option\n+#[cfg(not(stage0))] // Requires condition! fixes\n+mod option;\n+\n /// Basic stream compression. XXX: Belongs with other flate code\n pub mod flate;\n \n /// Interop between byte streams and pipes. Not sure where it belongs\n pub mod comm_adapters;\n \n /// Extension traits\n-mod util;\n+mod extensions;\n \n /// Non-I/O things needed by the I/O module\n-mod misc;\n+mod support;\n \n /// Thread-blocking implementations\n pub mod native {\n@@ -170,12 +324,14 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n+#[deriving(Eq)]\n pub enum IoErrorKind {\n     FileNotFound,\n     FilePermission,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError\n+    OtherIoError,\n+    PreviousIoError\n }\n \n // XXX: Can't put doc comments on macros\n@@ -208,9 +364,9 @@ pub trait Reader {\n     ///         println(reader.read_line());\n     ///     }\n     ///\n-    /// # XXX\n+    /// # Failue\n     ///\n-    /// What does this return if the Reader is in an error state?\n+    /// Returns `true` on failure.\n     fn eof(&mut self) -> bool;\n }\n \n@@ -250,9 +406,30 @@ pub enum SeekStyle {\n /// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n     fn tell(&self) -> u64;\n+\n+    /// Seek to an offset in a stream\n+    ///\n+    /// A successful seek clears the EOF indicator.\n+    ///\n+    /// # XXX\n+    ///\n+    /// * What is the behavior when seeking past the end of a stream?\n     fn seek(&mut self, pos: i64, style: SeekStyle);\n }\n \n+/// A listener is a value that listens for connections\n+pub trait Listener<S> {\n+    /// Wait for and accept an incoming connection\n+    ///\n+    /// Returns `None` on timeout.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises `io_error` condition. If the condition is handled,\n+    /// then `accept` returns `None`.\n+    fn accept(&mut self) -> Option<S>;\n+}\n+\n /// Common trait for decorator types.\n ///\n /// Provides accessors to get the inner, 'decorated' values. The I/O library\n@@ -278,3 +455,16 @@ pub trait Decorator<T> {\n     /// Take a mutable reference to the decorated value\n     fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n }\n+\n+pub fn standard_error(kind: IoErrorKind) -> IoError {\n+    match kind {\n+        PreviousIoError => {\n+            IoError {\n+                kind: PreviousIoError,\n+                desc: \"Failing due to a previous I/O error\",\n+                detail: None\n+            }\n+        }\n+        _ => fail!()\n+    }\n+}"}, {"sha": "df1dfe4d38ad1b1eb7d028475ca521dde9e5bd88", "filename": "src/libcore/rt/io/net/ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -12,4 +12,3 @@ pub enum IpAddr {\n     Ipv4(u8, u8, u8, u8, u16),\n     Ipv6\n }\n-"}, {"sha": "c95b4344fe75d4ffe9531b12b8973278da77649b", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::*;\n use super::super::*;\n use super::ip::IpAddr;\n \n pub struct TcpStream;\n \n impl TcpStream {\n-    pub fn connect(_addr: IpAddr) -> Result<TcpStream, IoError> {\n+    pub fn connect(_addr: IpAddr) -> Option<TcpStream> {\n         fail!()\n     }\n }\n@@ -40,11 +39,36 @@ impl Close for TcpStream {\n pub struct TcpListener;\n \n impl TcpListener {\n-    pub fn new(_addr: IpAddr) -> TcpListener {\n+    pub fn bind(_addr: IpAddr) -> Option<TcpListener> {\n         fail!()\n     }\n }\n \n impl Listener<TcpStream> for TcpListener {\n     fn accept(&mut self) -> Option<TcpStream> { fail!() }\n }\n+\n+#[cfg(test)]\n+mod test {\n+\n+    #[test] #[ignore]\n+    fn smoke_test() {\n+        /*do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawn_immediately {\n+                let listener = TcpListener::bind(addr);\n+                do listener.accept() {\n+                    let mut buf = [0];\n+                    listener.read(buf);\n+                    assert!(buf[0] == 99);\n+                }\n+            }\n+\n+            do spawn_immediately {\n+                let stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }*/\n+    }\n+}"}, {"sha": "1f1254a7029f0f9e50e91ee5ed2660ea8b7a1eb2", "filename": "src/libcore/rt/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::*;\n use super::super::*;\n use super::ip::IpAddr;\n \n pub struct UdpStream;\n \n impl UdpStream {\n-    pub fn connect(_addr: IpAddr) -> Result<UdpStream, IoError> {\n+    pub fn connect(_addr: IpAddr) -> Option<UdpStream> {\n         fail!()\n     }\n }\n@@ -40,12 +39,11 @@ impl Close for UdpStream {\n pub struct UdpListener;\n \n impl UdpListener {\n-    pub fn new(_addr: IpAddr) -> UdpListener {\n+    pub fn bind(_addr: IpAddr) -> Option<UdpListener> {\n         fail!()\n     }\n }\n \n impl Listener<UdpStream> for UdpListener {\n     fn accept(&mut self) -> Option<UdpStream> { fail!() }\n }\n-"}, {"sha": "f449a857467ccf103fbe4c1d7cff7c16b0aa1de4", "filename": "src/libcore/rt/io/net/unix.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::*;\n use super::super::*;\n-use super::super::misc::PathLike;\n+use super::super::support::PathLike;\n \n pub struct UnixStream;\n \n impl UnixStream {\n-    pub fn connect<P: PathLike>(_path: &P) -> Result<UnixStream, IoError> {\n+    pub fn connect<P: PathLike>(_path: &P) -> Option<UnixStream> {\n         fail!()\n     }\n }\n@@ -40,12 +39,11 @@ impl Close for UnixStream {\n pub struct UnixListener;\n \n impl UnixListener {\n-    pub fn new<P: PathLike>(_path: &P) -> UnixListener {\n+    pub fn bind<P: PathLike>(_path: &P) -> Option<UnixListener> {\n         fail!()\n     }\n }\n \n impl Listener<UnixStream> for UnixListener {\n     fn accept(&mut self) -> Option<UnixStream> { fail!() }\n }\n-"}, {"sha": "95f8711cb5bd555bd893a3ce7874054fb7b4e1bc", "filename": "src/libcore/rt/io/option.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of I/O traits for the Option type\n+//!\n+//! I/O constructors return option types to allow errors to be handled.\n+//! These implementations allow e.g. `Option<FileStream>` to be used\n+//! as a `Reader` without unwrapping the option first.\n+//!\n+//! # XXX Seek and Close\n+\n+use option::*;\n+use super::{Reader, Writer, Listener};\n+use super::{standard_error, PreviousIoError, io_error, IoError};\n+\n+fn prev_io_error() -> IoError {\n+    standard_error(PreviousIoError)\n+}\n+\n+impl<W: Writer> Writer for Option<W> {\n+    fn write(&mut self, buf: &[u8]) {\n+        match *self {\n+            Some(ref mut writer) => writer.write(buf),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+\n+    fn flush(&mut self) {\n+        match *self {\n+            Some(ref mut writer) => writer.flush(),\n+            None => io_error::cond.raise(prev_io_error())\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Reader for Option<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match *self {\n+            Some(ref mut reader) => reader.read(buf),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        match *self {\n+            Some(ref mut reader) => reader.eof(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                true\n+            }\n+        }\n+    }\n+}\n+\n+impl<L: Listener<S>, S> Listener<S> for Option<L> {\n+    fn accept(&mut self) -> Option<S> {\n+        match *self {\n+            Some(ref mut listener) => listener.accept(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::*;\n+    use super::super::mem::*;\n+    use rt::test::*;\n+    use super::super::{PreviousIoError, io_error};\n+\n+    #[test]\n+    fn test_option_writer() {\n+        do run_in_newsched_task {\n+            let mut writer: Option<MemWriter> = Some(MemWriter::new());\n+            writer.write([0, 1, 2]);\n+            writer.flush();\n+            assert!(writer.unwrap().inner() == ~[0, 1, 2]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_writer_error() {\n+        do run_in_newsched_task {\n+            let mut writer: Option<MemWriter> = None;\n+\n+            let mut called = false;\n+            do io_error::cond.trap(|err| {\n+                assert!(err.kind == PreviousIoError);\n+                called = true;\n+            }).in {\n+                writer.write([0, 0, 0]);\n+            }\n+            assert!(called);\n+\n+            let mut called = false;\n+            do io_error::cond.trap(|err| {\n+                assert!(err.kind == PreviousIoError);\n+                called = true;\n+            }).in {\n+                writer.flush();\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader() {\n+        do run_in_newsched_task {\n+            let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n+            let mut buf = [0, 0];\n+            reader.read(buf);\n+            assert!(buf == [0, 1]);\n+            assert!(!reader.eof());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader_error() {\n+        let mut reader: Option<MemReader> = None;\n+        let mut buf = [];\n+\n+        let mut called = false;\n+        do io_error::cond.trap(|err| {\n+            assert!(err.kind == PreviousIoError);\n+            called = true;\n+        }).in {\n+            reader.read(buf);\n+        }\n+        assert!(called);\n+\n+        let mut called = false;\n+        do io_error::cond.trap(|err| {\n+            assert!(err.kind == PreviousIoError);\n+            called = true;\n+        }).in {\n+            assert!(reader.eof());\n+        }\n+        assert!(called);\n+    }\n+}"}, {"sha": "7bace5d6df2ccfdba1cfe7538ab05cbed10da6cb", "filename": "src/libcore/rt/io/support.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fio%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fsupport.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "previous_filename": "src/libcore/rt/io/misc.rs"}, {"sha": "6bf228a1b2201596aa256497cc9d86752d3b7209", "filename": "src/libcore/rt/local_heap.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_heap.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The local, garbage collected heap\n+\n+use libc::{c_void, uintptr_t, size_t};\n+use ops::Drop;\n+\n+type MemoryRegion = c_void;\n+type BoxedRegion = c_void;\n+\n+pub type OpaqueBox = c_void;\n+pub type TypeDesc = c_void;\n+\n+pub struct LocalHeap {\n+    memory_region: *MemoryRegion,\n+    boxed_region: *BoxedRegion\n+}\n+\n+impl LocalHeap {\n+    pub fn new() -> LocalHeap {\n+        unsafe {\n+            // Don't need synchronization for the single-threaded local heap\n+            let synchronized = false as uintptr_t;\n+            // XXX: These usually come from the environment\n+            let detailed_leaks = false as uintptr_t;\n+            let poison_on_free = false as uintptr_t;\n+            let region = rust_new_memory_region(synchronized, detailed_leaks, poison_on_free);\n+            assert!(region.is_not_null());\n+            let boxed = rust_new_boxed_region(region, poison_on_free);\n+            assert!(boxed.is_not_null());\n+            LocalHeap {\n+                memory_region: region,\n+                boxed_region: boxed\n+            }\n+        }\n+    }\n+\n+    pub fn alloc(&mut self, td: *TypeDesc, size: uint) -> *OpaqueBox {\n+        unsafe {\n+            return rust_boxed_region_malloc(self.boxed_region, td, size as size_t);\n+        }\n+    }\n+\n+    pub fn free(&mut self, box: *OpaqueBox) {\n+        unsafe {\n+            return rust_boxed_region_free(self.boxed_region, box);\n+        }\n+    }\n+}\n+\n+impl Drop for LocalHeap {\n+    fn finalize(&self) {\n+        unsafe {\n+            rust_delete_boxed_region(self.boxed_region);\n+            rust_delete_memory_region(self.memory_region);\n+        }\n+    }\n+}\n+\n+extern {\n+    fn rust_new_memory_region(synchronized: uintptr_t,\n+                               detailed_leaks: uintptr_t,\n+                               poison_on_free: uintptr_t) -> *MemoryRegion;\n+    fn rust_delete_memory_region(region: *MemoryRegion);\n+    fn rust_new_boxed_region(region: *MemoryRegion,\n+                             poison_on_free: uintptr_t) -> *BoxedRegion;\n+    fn rust_delete_boxed_region(region: *BoxedRegion);\n+    fn rust_boxed_region_malloc(region: *BoxedRegion,\n+                                td: *TypeDesc,\n+                                size: size_t) -> *OpaqueBox;\n+    fn rust_boxed_region_free(region: *BoxedRegion, box: *OpaqueBox);\n+}"}, {"sha": "a03bc6c409f8b4092283ab442450896aa9fbccdf", "filename": "src/libcore/rt/local_services.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Language-level runtime services that should reasonably expected\n+//! to be available 'everywhere'. Local heaps, GC, unwinding,\n+//! local storage, and logging. Even a 'freestanding' Rust would likely want\n+//! to implement this.\n+\n+//! Local services may exist in at least three different contexts:\n+//! when running as a task, when running in the scheduler's context,\n+//! or when running outside of a scheduler but with local services\n+//! (freestanding rust with local services?).\n+\n+use prelude::*;\n+use libc::{c_void, uintptr_t};\n+use cast::transmute;\n+use super::sched::local_sched;\n+use super::local_heap::LocalHeap;\n+\n+pub struct LocalServices {\n+    heap: LocalHeap,\n+    gc: GarbageCollector,\n+    storage: LocalStorage,\n+    logger: Logger,\n+    unwinder: Option<Unwinder>,\n+    destroyed: bool\n+}\n+\n+pub struct GarbageCollector;\n+pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n+pub struct Logger;\n+\n+pub struct Unwinder {\n+    unwinding: bool,\n+}\n+\n+impl LocalServices {\n+    pub fn new() -> LocalServices {\n+        LocalServices {\n+            heap: LocalHeap::new(),\n+            gc: GarbageCollector,\n+            storage: LocalStorage(ptr::null(), None),\n+            logger: Logger,\n+            unwinder: Some(Unwinder { unwinding: false }),\n+            destroyed: false\n+        }\n+    }\n+\n+    pub fn without_unwinding() -> LocalServices {\n+        LocalServices {\n+            heap: LocalHeap::new(),\n+            gc: GarbageCollector,\n+            storage: LocalStorage(ptr::null(), None),\n+            logger: Logger,\n+            unwinder: None,\n+            destroyed: false\n+        }\n+    }\n+\n+    pub fn run(&mut self, f: &fn()) {\n+        // This is just an assertion that `run` was called unsafely\n+        // and this instance of LocalServices is still accessible.\n+        do borrow_local_services |sched| {\n+            assert!(ptr::ref_eq(sched, self));\n+        }\n+\n+        match self.unwinder {\n+            Some(ref mut unwinder) => {\n+                // If there's an unwinder then set up the catch block\n+                unwinder.try(f);\n+            }\n+            None => {\n+                // Otherwise, just run the body\n+                f()\n+            }\n+        }\n+        self.destroy();\n+    }\n+\n+    /// Must be called manually before finalization to clean up\n+    /// thread-local resources. Some of the routines here expect\n+    /// LocalServices to be available recursively so this must be\n+    /// called unsafely, without removing LocalServices from\n+    /// thread-local-storage.\n+    fn destroy(&mut self) {\n+        // This is just an assertion that `destroy` was called unsafely\n+        // and this instance of LocalServices is still accessible.\n+        do borrow_local_services |sched| {\n+            assert!(ptr::ref_eq(sched, self));\n+        }\n+        match self.storage {\n+            LocalStorage(ptr, Some(ref dtor)) => {\n+                (*dtor)(ptr)\n+            }\n+            _ => ()\n+        }\n+        self.destroyed = true;\n+    }\n+}\n+\n+impl Drop for LocalServices {\n+    fn finalize(&self) { assert!(self.destroyed) }\n+}\n+\n+// Just a sanity check to make sure we are catching a Rust-thrown exception\n+static UNWIND_TOKEN: uintptr_t = 839147;\n+\n+impl Unwinder {\n+    pub fn try(&mut self, f: &fn()) {\n+        use sys::Closure;\n+\n+        unsafe {\n+            let closure: Closure = transmute(f);\n+            let code = transmute(closure.code);\n+            let env = transmute(closure.env);\n+\n+            let token = rust_try(try_fn, code, env);\n+            assert!(token == 0 || token == UNWIND_TOKEN);\n+        }\n+\n+        extern fn try_fn(code: *c_void, env: *c_void) {\n+            unsafe {\n+                let closure: Closure = Closure {\n+                    code: transmute(code),\n+                    env: transmute(env),\n+                };\n+                let closure: &fn() = transmute(closure);\n+                closure();\n+            }\n+        }\n+\n+        extern {\n+            #[rust_stack]\n+            fn rust_try(f: *u8, code: *c_void, data: *c_void) -> uintptr_t;\n+        }\n+    }\n+\n+    pub fn begin_unwind(&mut self) -> ! {\n+        self.unwinding = true;\n+        unsafe {\n+            rust_begin_unwind(UNWIND_TOKEN);\n+            return transmute(());\n+        }\n+        extern {\n+            fn rust_begin_unwind(token: uintptr_t);\n+        }\n+    }\n+}\n+\n+/// Borrow a pointer to the installed local services.\n+/// Fails (likely aborting the process) if local services are not available.\n+pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n+    do local_sched::borrow |sched| {\n+        match sched.current_task {\n+            Some(~ref mut task) => {\n+                f(&mut task.local_services)\n+            }\n+            None => {\n+                fail!(~\"no local services for schedulers yet\")\n+            }\n+        }\n+    }\n+}\n+\n+pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n+    use cast::transmute_mut_region;\n+\n+    match local_sched::unsafe_borrow().current_task {\n+        Some(~ref mut task) => {\n+            transmute_mut_region(&mut task.local_services)\n+        }\n+        None => {\n+            fail!(~\"no local services for schedulers yet\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rt::test::*;\n+\n+    #[test]\n+    fn local_heap() {\n+        do run_in_newsched_task() {\n+            let a = @5;\n+            let b = a;\n+            assert!(*a == 5);\n+            assert!(*b == 5);\n+        }\n+    }\n+\n+    #[test]\n+    fn tls() {\n+        use task::local_data::*;\n+        do run_in_newsched_task() {\n+            unsafe {\n+                fn key(_x: @~str) { }\n+                local_data_set(key, @~\"data\");\n+                assert!(*local_data_get(key).get() == ~\"data\");\n+                fn key2(_x: @~str) { }\n+                local_data_set(key2, @~\"data\");\n+                assert!(*local_data_get(key2).get() == ~\"data\");\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn unwind() {\n+        do run_in_newsched_task() {\n+            let result = spawntask_try(||());\n+            assert!(result.is_ok());\n+            let result = spawntask_try(|| fail!());\n+            assert!(result.is_err());\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "a072fccd33d6c696a91bf2771452a2f7f8cb8ca7", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -8,30 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! The Rust runtime, including the scheduler and I/O interface */\n+\n #[doc(hidden)];\n \n use libc::c_char;\n \n-// Some basic logging\n-macro_rules! rtdebug_ (\n-    ($( $arg:expr),+) => ( {\n-        dumb_println(fmt!( $($arg),+ ));\n-\n-        fn dumb_println(s: &str) {\n-            use io::WriterUtil;\n-            let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n-            dbg.write_str(s);\n-            dbg.write_str(\"\\n\");\n-        }\n-\n-    } )\n-)\n-\n-// An alternate version with no output, for turning off logging\n-macro_rules! rtdebug (\n-    ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n-)\n-\n #[path = \"sched/mod.rs\"]\n mod sched;\n mod rtio;\n@@ -48,6 +30,12 @@ mod stack;\n mod context;\n mod thread;\n pub mod env;\n+pub mod local_services;\n+mod local_heap;\n+\n+/// Tools for testing the runtime\n+#[cfg(test)]\n+pub mod test;\n \n pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n     use self::sched::{Scheduler, Task};\n@@ -72,7 +60,7 @@ pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n /// Different runtime services are available depending on context.\n #[deriving(Eq)]\n pub enum RuntimeContext {\n-    // Only default services, e.g. exchange heap\n+    // Only the exchange heap is available\n     GlobalContext,\n     // The scheduler may be accessed\n     SchedulerContext,\n@@ -139,24 +127,3 @@ fn test_context() {\n         sched.run();\n     }\n }\n-\n-// For setting up tests of the new scheduler\n-#[cfg(test)]\n-pub fn run_in_newsched_task(f: ~fn()) {\n-    use cell::Cell;\n-    use unstable::run_in_bare_thread;\n-    use self::sched::Task;\n-    use self::uvio::UvEventLoop;\n-\n-    let f = Cell(Cell(f));\n-\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let f = f.take();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            (f.take())();\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n-    }\n-}"}, {"sha": "a7e02f30e0167bf5246b39dcdb89432d02182736", "filename": "src/libcore/rt/sched/local_sched.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -143,4 +143,3 @@ fn borrow_smoke_test() {\n     }\n     let _scheduler = take();\n }\n-"}, {"sha": "663fe3e62d0106f7a93a003981300d2536bfdf47", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -16,6 +16,7 @@ use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n+use super::local_services::LocalServices;\n use cell::Cell;\n \n #[cfg(test)] use super::uvio::UvEventLoop;\n@@ -38,7 +39,7 @@ pub struct Scheduler {\n     /// Always valid when a task is executing, otherwise not\n     priv saved_context: Context,\n     /// The currently executing task\n-    priv current_task: Option<~Task>,\n+    current_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>\n@@ -147,7 +148,7 @@ pub impl Scheduler {\n             }\n         }\n \n-        // Control never reaches here\n+        abort!(\"control reached end of task\");\n     }\n \n     fn schedule_new_task(~self, task: ~Task) {\n@@ -324,17 +325,26 @@ pub struct Task {\n     /// These are always valid when the task is not running, unless\n     /// the task is dead\n     priv saved_context: Context,\n+    /// The heap, GC, unwinding, local storage, logging\n+    local_services: LocalServices\n }\n \n pub impl Task {\n     fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+        Task::with_local(stack_pool, LocalServices::new(), start)\n+    }\n+\n+    fn with_local(stack_pool: &mut StackPool,\n+                  local_services: LocalServices,\n+                  start: ~fn()) -> Task {\n         let start = Task::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n         return Task {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n+            local_services: local_services\n         };\n     }\n \n@@ -347,9 +357,12 @@ pub impl Task {\n             unsafe {\n                 let sched = local_sched::unsafe_borrow();\n                 sched.run_cleanup_job();\n-            }\n \n-            start();\n+                let sched = local_sched::unsafe_borrow();\n+                let task = sched.current_task.get_mut_ref();\n+                // FIXME #6141: shouldn't neet to put `start()` in another closure\n+                task.local_services.run(||start());\n+            }\n \n             let sched = local_sched::take();\n             sched.terminate_current_task();"}, {"sha": "63db705408800a26e4aa48a308e9f775a168de93", "filename": "src/libcore/rt/test.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::Cell;\n+use result::{Result, Ok, Err};\n+use super::io::net::ip::{IpAddr, Ipv4};\n+use rt::local_services::LocalServices;\n+\n+/// Creates a new scheduler in a new thread and runs a task in it,\n+/// then waits for the scheduler to exit. Failure of the task\n+/// will abort the process.\n+pub fn run_in_newsched_task(f: ~fn()) {\n+    use unstable::run_in_bare_thread;\n+    use super::sched::Task;\n+    use super::uvio::UvEventLoop;\n+\n+    let f = Cell(f);\n+\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~Task::with_local(&mut sched.stack_pool,\n+                                     LocalServices::without_unwinding(),\n+                                     f.take());\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}\n+\n+/// Test tasks will abort on failure instead of unwinding\n+pub fn spawntask(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+    do sched.switch_running_tasks_and_then(task) |task| {\n+        let task = Cell(task);\n+        let sched = local_sched::take();\n+        sched.schedule_new_task(task.take());\n+    }\n+}\n+\n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_immediately(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+    do sched.switch_running_tasks_and_then(task) |task| {\n+        let task = Cell(task);\n+        do local_sched::borrow |sched| {\n+            sched.task_queue.push_front(task.take());\n+        }\n+    }\n+}\n+\n+/// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n+pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n+    use cell::Cell;\n+    use super::sched::*;\n+    use task;\n+    use unstable::finally::Finally;\n+\n+    // Our status variables will be filled in from the scheduler context\n+    let mut failed = false;\n+    let failed_ptr: *mut bool = &mut failed;\n+\n+    // Switch to the scheduler\n+    let f = Cell(Cell(f));\n+    let mut sched = local_sched::take();\n+    do sched.deschedule_running_task_and_then() |old_task| {\n+        let old_task = Cell(old_task);\n+        let f = f.take();\n+        let mut sched = local_sched::take();\n+        let new_task = ~do Task::new(&mut sched.stack_pool) {\n+            do (|| {\n+                (f.take())()\n+            }).finally {\n+                // Check for failure then resume the parent task\n+                unsafe { *failed_ptr = task::failing(); }\n+                let sched = local_sched::take();\n+                do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n+                    let new_task = Cell(new_task);\n+                    do local_sched::borrow |sched| {\n+                        sched.task_queue.push_front(new_task.take());\n+                    }\n+                }\n+            }\n+        };\n+\n+        sched.resume_task_immediately(new_task);\n+    }\n+\n+    if !failed { Ok(()) } else { Err(()) }\n+}\n+\n+/// Get a port number, starting at 9600, for use in tests\n+pub fn next_test_port() -> u16 {\n+    unsafe {\n+        return rust_dbg_next_port() as u16;\n+    }\n+    extern {\n+        fn rust_dbg_next_port() -> ::libc::uintptr_t;\n+    }\n+}\n+\n+/// Get a unique localhost:port pair starting at 9600\n+pub fn next_test_ip4() -> IpAddr {\n+    Ipv4(127, 0, 0, 1, next_test_port())\n+}"}, {"sha": "013a28abf2813ecf961a42d3f99b1a3cb23791e6", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -301,7 +301,8 @@ struct WatcherData {\n     write_cb: Option<ConnectionCallback>,\n     connect_cb: Option<ConnectionCallback>,\n     close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>\n+    alloc_cb: Option<AllocCallback>,\n+    buf: Option<Buf>\n }\n \n pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n@@ -311,7 +312,8 @@ pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n             write_cb: None,\n             connect_cb: None,\n             close_cb: None,\n-            alloc_cb: None\n+            alloc_cb: None,\n+            buf: None\n         };\n         let data = transmute::<~WatcherData, *c_void>(data);\n         uvll::set_data_for_uv_handle(watcher.native_handle(), data);"}, {"sha": "04b9008b0677018ce4d67d6271e176f9cbb6cc87", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 16, "deletions": 48, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -19,12 +19,10 @@ use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCa\n             vec_to_uv_buf, vec_from_uv_buf};\n use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n \n-#[cfg(test)]\n-use unstable::run_in_bare_thread;\n-#[cfg(test)]\n-use super::super::thread::Thread;\n-#[cfg(test)]\n-use cell::Cell;\n+#[cfg(test)] use cell::Cell;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::super::thread::Thread;\n+#[cfg(test)] use super::super::test::*;\n \n fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n     match addr {\n@@ -109,21 +107,25 @@ pub impl StreamWatcher {\n \n         let req = WriteRequest::new();\n         let buf = vec_to_uv_buf(msg);\n-        // XXX: Allocation\n-        let bufs = ~[buf];\n+        assert!(data.buf.is_none());\n+        data.buf = Some(buf);\n+        let bufs = [buf];\n         unsafe {\n             assert!(0 == uvll::write(req.native_handle(),\n                                           self.native_handle(),\n-                                          &bufs, write_cb));\n+                                          bufs, write_cb));\n         }\n-        // XXX: Freeing immediately after write. Is this ok?\n-        let _v = vec_from_uv_buf(buf);\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n-            let cb = get_watcher_data(&mut stream_watcher).write_cb.swap_unwrap();\n+            let cb = {\n+                let data = get_watcher_data(&mut stream_watcher);\n+                let _vec = vec_from_uv_buf(data.buf.swap_unwrap());\n+                let cb = data.write_cb.swap_unwrap();\n+                cb\n+            };\n             let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n             cb(stream_watcher, status);\n         }\n@@ -361,7 +363,7 @@ fn connect_close() {\n         let mut loop_ = Loop::new();\n         let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n         // Connect to a port where nobody is listening\n-        let addr = Ipv4(127, 0, 0, 1, 2923);\n+        let addr = next_test_ip4();\n         do tcp_watcher.connect(addr) |stream_watcher, status| {\n             rtdebug!(\"tcp_watcher.connect!\");\n             assert!(status.is_some());\n@@ -373,47 +375,13 @@ fn connect_close() {\n     }\n }\n \n-#[test]\n-#[ignore(reason = \"need a server to connect to\")]\n-fn connect_read() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = Ipv4(127, 0, 0, 1, 2924);\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            let mut stream_watcher = stream_watcher;\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            assert!(status.is_none());\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do stream_watcher.read_start(alloc)\n-                |stream_watcher, _nread, buf, status| {\n-\n-                let buf = vec_from_uv_buf(buf);\n-                rtdebug!(\"read cb!\");\n-                if status.is_none() {\n-                    let _bytes = buf.unwrap();\n-                    rtdebug!(\"%s\", bytes.slice(0, nread as uint).to_str());\n-                } else {\n-                    rtdebug!(\"status after read: %s\", status.get().to_str());\n-                    rtdebug!(\"closing\");\n-                    stream_watcher.close(||());\n-                }\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n #[test]\n fn listen() {\n     do run_in_bare_thread() {\n         static MAX: int = 10;\n         let mut loop_ = Loop::new();\n         let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = Ipv4(127, 0, 0, 1, 2925);\n+        let addr = next_test_ip4();\n         server_tcp_watcher.bind(addr);\n         let loop_ = loop_;\n         rtdebug!(\"listening\");"}, {"sha": "ab8aea2b63c4f321c19ba331337dd0d5a4cc7370", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -19,10 +19,9 @@ use cell::{Cell, empty_cell};\n use cast::transmute;\n use super::sched::{Scheduler, local_sched};\n \n-#[cfg(test)] use super::io::net::ip::Ipv4;\n-#[cfg(test)] use super::sched::Task;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use uint;\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -319,38 +318,22 @@ impl Stream for UvStream {\n }\n \n #[test]\n-#[ignore(reason = \"ffi struct issues\")]\n fn test_simple_io_no_connect() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let addr = Ipv4(127, 0, 0, 1, 2926);\n-            let maybe_chan = io.connect(addr);\n-            assert!(maybe_chan.is_none());\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n+    do run_in_newsched_task {\n+        let io = unsafe { local_sched::unsafe_borrow_io() };\n+        let addr = next_test_ip4();\n+        let maybe_chan = io.connect(addr);\n+        assert!(maybe_chan.is_none());\n     }\n }\n \n #[test]\n-#[ignore(reason = \"ffi struct issues\")]\n fn test_simple_tcp_server_and_client() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let addr = Ipv4(127, 0, 0, 1, 2929);\n-\n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe {\n-                let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n-        };\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n \n-        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+        // Start the server first so it's listening when we connect\n+        do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n                 let mut listener = io.bind(addr).unwrap();\n@@ -365,32 +348,25 @@ fn test_simple_tcp_server_and_client() {\n                 stream.close();\n                 listener.close();\n             }\n-        };\n+        }\n \n-        // Start the server first so it listens before the client connects\n-        sched.task_queue.push_back(server_task);\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = io.connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n+        }\n     }\n }\n \n #[test] #[ignore(reason = \"busted\")]\n fn test_read_and_block() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let addr = Ipv4(127, 0, 0, 1, 2930);\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n-        };\n-\n-        let server_task = ~do Task::new(&mut sched.stack_pool) {\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut listener = io.bind(addr).unwrap();\n             let mut stream = listener.listen().unwrap();\n@@ -426,36 +402,58 @@ fn test_read_and_block() {\n \n             stream.close();\n             listener.close();\n-        };\n+        }\n+\n+        do spawntask_immediately {\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n+        }\n \n-        // Start the server first so it listens before the client connects\n-        sched.task_queue.push_back(server_task);\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n     }\n }\n \n-#[test] #[ignore(reason = \"needs server\")]\n+#[test]\n fn test_read_read_read() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let addr = Ipv4(127, 0, 0, 1, 2931);\n+    do run_in_newsched_task {\n+        let addr = next_test_ip4();\n+        static MAX: uint = 500000;\n \n-        let client_task = ~do Task::new(&mut sched.stack_pool) {\n+        do spawntask_immediately {\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut listener = io.bind(addr).unwrap();\n+                let mut stream = listener.listen().unwrap();\n+                let mut buf = [1, .. 2048];\n+                let mut total_bytes_written = 0;\n+                while total_bytes_written < MAX {\n+                    stream.write(buf);\n+                    total_bytes_written += buf.len();\n+                }\n+                stream.close();\n+                listener.close();\n+            }\n+        }\n+\n+        do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             let mut buf = [0, .. 2048];\n             let mut total_bytes_read = 0;\n-            while total_bytes_read < 500000000 {\n+            while total_bytes_read < MAX {\n                 let nread = stream.read(buf).unwrap();\n                 rtdebug!(\"read %u bytes\", nread as uint);\n                 total_bytes_read += nread;\n+                for uint::range(0, nread) |i| {\n+                    assert!(buf[i] == 1);\n+                }\n             }\n-            rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n+            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n             stream.close();\n-        };\n-\n-        sched.task_queue.push_back(client_task);\n-        sched.run();\n+        }\n     }\n }"}, {"sha": "3eb7f8006b9eaee7a295b2d7e3944a6a86cb8f3b", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -219,9 +219,9 @@ pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n     return rust_uv_accept(server as *c_void, client as *c_void);\n }\n \n-pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: *~[uv_buf_t], cb: *u8) -> c_int {\n-    let buf_ptr = vec::raw::to_ptr(*buf_in);\n-    let buf_cnt = vec::len(*buf_in) as i32;\n+pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = vec::len(buf_in) as i32;\n     return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n }\n pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {"}, {"sha": "7e73b3a3f80be398244e4629b711538416c5f3b7", "filename": "src/libcore/run.rs", "status": "modified", "additions": 346, "deletions": 67, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -22,31 +22,6 @@ use str;\n use task;\n use vec;\n \n-pub mod rustrt {\n-    use libc::{c_int, c_void};\n-    use libc;\n-    use run;\n-\n-    #[abi = \"cdecl\"]\n-    pub extern {\n-        unsafe fn rust_run_program(argv: **libc::c_char,\n-                                   envp: *c_void,\n-                                   dir: *libc::c_char,\n-                                   in_fd: c_int,\n-                                   out_fd: c_int,\n-                                   err_fd: c_int) -> run::RunProgramResult;\n-        unsafe fn rust_process_wait(pid: c_int) -> c_int;\n-    }\n-}\n-\n-pub struct RunProgramResult {\n-    // the process id of the program, or -1 if in case of errors\n-    pid: pid_t,\n-    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n-    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n-    handle: *(),\n-}\n-\n /// A value representing a child process\n pub struct Program {\n     priv pid: pid_t,\n@@ -191,21 +166,262 @@ pub fn spawn_process(prog: &str, args: &[~str],\n     return res.pid;\n }\n \n+struct RunProgramResult {\n+    // the process id of the program (this should never be negative)\n+    pid: pid_t,\n+    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n+    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n+    handle: *(),\n+}\n+\n+#[cfg(windows)]\n fn spawn_process_internal(prog: &str, args: &[~str],\n                           env: &Option<~[(~str,~str)]>,\n                           dir: &Option<~str>,\n                           in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n+\n+    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use libc::consts::os::extra::{\n+        TRUE, FALSE,\n+        STARTF_USESTDHANDLES,\n+        INVALID_HANDLE_VALUE,\n+        DUPLICATE_SAME_ACCESS\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        GetCurrentProcess,\n+        DuplicateHandle,\n+        CloseHandle,\n+        CreateProcessA\n+    };\n+    use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n     unsafe {\n-        do with_argv(prog, args) |argv| {\n-            do with_envp(env) |envp| {\n-                do with_dirp(dir) |dirp| {\n-                    rustrt::rust_run_program(argv, envp, dirp, in_fd, out_fd, err_fd)\n+\n+        let mut si = zeroed_startupinfo();\n+        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n+\n+        let cur_proc = GetCurrentProcess();\n+\n+        let orig_std_in = get_osfhandle(if in_fd > 0 { in_fd } else { 0 }) as HANDLE;\n+        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(fmt!(\"failure in get_osfhandle: %s\", os::last_os_error()));\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(fmt!(\"failure in DuplicateHandle: %s\", os::last_os_error()));\n+        }\n+\n+        let orig_std_out = get_osfhandle(if out_fd > 0 { out_fd } else { 1 }) as HANDLE;\n+        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(fmt!(\"failure in get_osfhandle: %s\", os::last_os_error()));\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(fmt!(\"failure in DuplicateHandle: %s\", os::last_os_error()));\n+        }\n+\n+        let orig_std_err = get_osfhandle(if err_fd > 0 { err_fd } else { 2 }) as HANDLE;\n+        if orig_std_err as HANDLE == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(fmt!(\"failure in get_osfhandle: %s\", os::last_os_error()));\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(fmt!(\"failure in DuplicateHandle: %s\", os::last_os_error()));\n+        }\n+\n+        let cmd = make_command_line(prog, args);\n+        let mut pi = zeroed_process_information();\n+        let mut create_err = None;\n+\n+        do with_envp(env) |envp| {\n+            do with_dirp(dir) |dirp| {\n+                do str::as_c_str(cmd) |cmdp| {\n+                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n+                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n+                                                 0, envp, dirp, &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(os::last_os_error());\n+                    }\n                 }\n             }\n         }\n+\n+        CloseHandle(si.hStdInput);\n+        CloseHandle(si.hStdOutput);\n+        CloseHandle(si.hStdError);\n+\n+        for create_err.each |msg| {\n+            fail!(fmt!(\"failure in CreateProcess: %s\", *msg));\n+        }\n+\n+        // We close the thread handle because we don't care about keeping the thread id valid,\n+        // and we aren't keeping the thread handle around to be able to close it later. We don't\n+        // close the process handle however because we want the process id to stay valid at least\n+        // until the calling code closes the process handle.\n+        CloseHandle(pi.hThread);\n+\n+        RunProgramResult {\n+            pid: pi.dwProcessId as pid_t,\n+            handle: pi.hProcess as *()\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::mut_null(),\n+        lpDesktop: ptr::mut_null(),\n+        lpTitle: ptr::mut_null(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::mut_null(),\n+        hStdInput: ptr::mut_null(),\n+        hStdOutput: ptr::mut_null(),\n+        hStdError: ptr::mut_null()\n     }\n }\n \n+#[cfg(windows)]\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::mut_null(),\n+        hThread: ptr::mut_null(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+// FIXME: this is only pub so it can be tested (see issue #4536)\n+#[cfg(windows)]\n+pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+\n+    let mut cmd = ~\"\";\n+    append_arg(&mut cmd, prog);\n+    for args.each |arg| {\n+        cmd.push_char(' ');\n+        append_arg(&mut cmd, *arg);\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut ~str, arg: &str) {\n+        let quote = arg.any(|c| c == ' ' || c == '\\t');\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+        for uint::range(0, arg.len()) |i| {\n+            append_char_at(cmd, arg, i);\n+        }\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n+        match arg[i] as char {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push_char('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push_char(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n+        while i < s.len() && s[i] as char == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] as char == '\"';\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn spawn_process_internal(prog: &str, args: &[~str],\n+                          env: &Option<~[(~str,~str)]>,\n+                          dir: &Option<~str>,\n+                          in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n+\n+    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use libc::funcs::bsd44::getdtablesize;\n+\n+    mod rustrt {\n+        use libc::c_void;\n+\n+        #[abi = \"cdecl\"]\n+        pub extern {\n+            unsafe fn rust_unset_sigprocmask();\n+            unsafe fn rust_set_environ(envp: *c_void);\n+        }\n+    }\n+\n+    unsafe {\n+\n+        let pid = fork();\n+        if pid < 0 {\n+            fail!(fmt!(\"failure in fork: %s\", os::last_os_error()));\n+        } else if pid > 0 {\n+            return RunProgramResult {pid: pid, handle: ptr::null()};\n+        }\n+\n+        rustrt::rust_unset_sigprocmask();\n+\n+        if in_fd > 0 && dup2(in_fd, 0) == -1 {\n+            fail!(fmt!(\"failure in dup2(in_fd, 0): %s\", os::last_os_error()));\n+        }\n+        if out_fd > 0 && dup2(out_fd, 1) == -1 {\n+            fail!(fmt!(\"failure in dup2(out_fd, 1): %s\", os::last_os_error()));\n+        }\n+        if err_fd > 0 && dup2(err_fd, 2) == -1 {\n+            fail!(fmt!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error()));\n+        }\n+        // close all other fds\n+        for int::range_rev(getdtablesize() as int - 1, 2) |fd| {\n+            close(fd as c_int);\n+        }\n+\n+        for dir.each |dir| {\n+            do str::as_c_str(*dir) |dirp| {\n+                if chdir(dirp) == -1 {\n+                    fail!(fmt!(\"failure in chdir: %s\", os::last_os_error()));\n+                }\n+            }\n+        }\n+\n+        do with_envp(env) |envp| {\n+            if !envp.is_null() {\n+                rustrt::rust_set_environ(envp);\n+            }\n+            do with_argv(prog, args) |argv| {\n+                execvp(*argv, argv);\n+                // execvp only returns if an error occurred\n+                fail!(fmt!(\"failure in execvp: %s\", os::last_os_error()));\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n@@ -246,7 +462,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n \n #[cfg(windows)]\n fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: &fn(*c_void) -> T) -> T {\n+                cb: &fn(*mut c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -264,11 +480,12 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n             blk += ~[0_u8];\n             vec::as_imm_buf(blk, |p, _len| cb(::cast::transmute(p)))\n           }\n-          _ => cb(ptr::null())\n+          _ => cb(ptr::mut_null())\n         }\n     }\n }\n \n+#[cfg(windows)]\n fn with_dirp<T>(d: &Option<~str>,\n                 cb: &fn(*libc::c_char) -> T) -> T {\n     match *d {\n@@ -312,8 +529,6 @@ priv fn free_handle(_handle: *()) {\n pub fn run_program(prog: &str, args: &[~str]) -> int {\n     let res = spawn_process_internal(prog, args, &None, &None,\n                                      0i32, 0i32, 0i32);\n-    if res.pid == -1 as pid_t { fail!(); }\n-\n     let code = waitpid(res.pid);\n     free_handle(res.handle);\n     return code;\n@@ -345,7 +560,6 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n                                pipe_err.out);\n \n     unsafe {\n-        if res.pid == -1 as pid_t { fail!(); }\n         libc::close(pipe_input.in);\n         libc::close(pipe_output.out);\n         libc::close(pipe_err.out);\n@@ -398,13 +612,6 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n     os::close(pipe_in.in);\n     os::close(pipe_out.out);\n     os::close(pipe_err.out);\n-    if res.pid == -1i32 {\n-        os::close(pipe_in.out);\n-        os::close(pipe_out.in);\n-        os::close(pipe_err.in);\n-        fail!();\n-    }\n-\n     os::close(pipe_in.out);\n \n     // Spawn two entire schedulers to read both stdout and sterr\n@@ -485,11 +692,46 @@ pub fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        let status = unsafe { rustrt::rust_process_wait(pid) };\n-        if status < 0 {\n-            fail!(fmt!(\"failure in rust_process_wait: %s\", os::last_os_error()));\n+\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_FAILED\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject\n+        };\n+\n+        unsafe {\n+\n+            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+            if proc.is_null() {\n+                fail!(fmt!(\"failure in OpenProcess: %s\", os::last_os_error()));\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(proc, &mut status) == FALSE {\n+                    CloseHandle(proc);\n+                    fail!(fmt!(\"failure in GetExitCodeProcess: %s\", os::last_os_error()));\n+                }\n+                if status != STILL_ACTIVE {\n+                    CloseHandle(proc);\n+                    return status as int;\n+                }\n+                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n+                    CloseHandle(proc);\n+                    fail!(fmt!(\"failure in WaitForSingleObject: %s\", os::last_os_error()));\n+                }\n+            }\n         }\n-        return status as int;\n     }\n \n     #[cfg(unix)]\n@@ -539,10 +781,30 @@ mod tests {\n     use libc;\n     use option::None;\n     use os;\n-    use path::Path;\n     use run::{readclose, writeclose};\n     use run;\n \n+    #[test]\n+    #[cfg(windows)]\n+    fn test_make_command_line() {\n+        assert_eq!(\n+            run::make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n+            ~\"prog aaa bbb ccc\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"echo\", [~\"a b c\"]),\n+            ~\"echo \\\"a b c\\\"\"\n+        );\n+    }\n+\n     // Regression test for memory leaks\n     #[test]\n     fn test_leaks() {\n@@ -607,43 +869,60 @@ mod tests {\n         p.destroy(); // ...and nor should this (and nor should the destructor)\n     }\n \n-    #[cfg(unix)] // there is no way to sleep on windows from inside libcore...\n     fn test_destroy_actually_kills(force: bool) {\n-        let path = Path(fmt!(\"test/core-run-test-destroy-actually-kills-%?.tmp\", force));\n \n-        os::remove_file(&path);\n+        #[cfg(unix)]\n+        static BLOCK_COMMAND: &'static str = \"cat\";\n \n-        let cmd = fmt!(\"sleep 5 && echo MurderDeathKill > %s\", path.to_str());\n-        let mut p = run::start_program(\"sh\", [~\"-c\", cmd]);\n+        #[cfg(windows)]\n+        static BLOCK_COMMAND: &'static str = \"cmd\";\n \n-        p.destroy(); // destroy the program before it has a chance to echo its message\n+        #[cfg(unix)]\n+        fn process_exists(pid: libc::pid_t) -> bool {\n+            run::program_output(\"ps\", [~\"-p\", pid.to_str()]).out.contains(pid.to_str())\n+        }\n \n-        unsafe {\n-            // wait to ensure the program is really destroyed and not just waiting itself\n-            libc::sleep(10);\n+        #[cfg(windows)]\n+        fn process_exists(pid: libc::pid_t) -> bool {\n+\n+            use libc::types::os::arch::extra::DWORD;\n+            use libc::funcs::extra::kernel32::{CloseHandle, GetExitCodeProcess, OpenProcess};\n+            use libc::consts::os::extra::{FALSE, PROCESS_QUERY_INFORMATION, STILL_ACTIVE };\n+\n+            unsafe {\n+                let proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+                if proc.is_null() {\n+                    return false;\n+                }\n+                // proc will be non-null if the process is alive, or if it died recently\n+                let mut status = 0;\n+                GetExitCodeProcess(proc, &mut status);\n+                CloseHandle(proc);\n+                return status == STILL_ACTIVE;\n+            }\n         }\n \n-        // the program should not have had chance to echo its message\n-        assert!(!path.exists());\n+        // this program will stay alive indefinitely trying to read from stdin\n+        let mut p = run::start_program(BLOCK_COMMAND, []);\n+\n+        assert!(process_exists(p.get_id()));\n+\n+        if force {\n+            p.force_destroy();\n+        } else {\n+            p.destroy();\n+        }\n+\n+        assert!(!process_exists(p.get_id()));\n     }\n \n     #[test]\n-    #[cfg(unix)]\n     fn test_unforced_destroy_actually_kills() {\n         test_destroy_actually_kills(false);\n     }\n \n     #[test]\n-    #[cfg(unix)]\n     fn test_forced_destroy_actually_kills() {\n         test_destroy_actually_kills(true);\n     }\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "987d4064ab9f6bdb0d42ce4d0f78a17c4abd8cfa", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -93,10 +93,6 @@ pub mod rustrt {\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n-        #[cfg(stage0)]\n-        pub fn frame_address(f: &once fn(x: *u8));\n-        #[cfg(not(stage0))]\n         pub fn frame_address(+f: &once fn(x: *u8));\n     }\n }\n-"}, {"sha": "a41c99b266b11b8381f3fa9f454d568df8ad8ec4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 132, "deletions": 15, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -77,6 +77,7 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n }\n \n /// Copy a slice into a new unique str\n+#[inline(always)]\n pub fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_owned(s, 0, len(s)) }\n }\n@@ -240,38 +241,132 @@ pub fn append(lhs: ~str, rhs: &str) -> ~str {\n \n /// Concatenate a vector of strings\n pub fn concat(v: &[~str]) -> ~str {\n-    let mut s: ~str = ~\"\";\n-    for vec::each(v) |ss| {\n-        push_str(&mut s, *ss);\n+    if v.is_empty() { return ~\"\"; }\n+\n+    let mut len = 0;\n+    for v.each |ss| {\n+        len += ss.len();\n+    }\n+    let mut s = ~\"\";\n+\n+    reserve(&mut s, len);\n+\n+    unsafe {\n+        do as_buf(s) |buf, _len| {\n+            let mut buf = ::cast::transmute_mut_unsafe(buf);\n+            for v.each |ss| {\n+                do as_buf(*ss) |ssbuf, sslen| {\n+                    let sslen = sslen - 1;\n+                    ptr::copy_memory(buf, ssbuf, sslen);\n+                    buf = buf.offset(sslen);\n+                }\n+            }\n+        }\n+        raw::set_len(&mut s, len);\n     }\n     s\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n pub fn connect(v: &[~str], sep: &str) -> ~str {\n+    if v.is_empty() { return ~\"\"; }\n+\n+    // concat is faster\n+    if sep.is_empty() { return concat(v); }\n+\n+    // this is wrong without the guarantee that v is non-empty\n+    let mut len = sep.len() * (v.len() - 1);\n+    for v.each |ss| {\n+        len += ss.len();\n+    }\n     let mut s = ~\"\", first = true;\n-    for vec::each(v) |ss| {\n-        if first { first = false; } else { push_str(&mut s, sep); }\n-        push_str(&mut s, *ss);\n+\n+    reserve(&mut s, len);\n+\n+    unsafe {\n+        do as_buf(s) |buf, _len| {\n+            do as_buf(sep) |sepbuf, seplen| {\n+                let seplen = seplen - 1;\n+                let mut buf = ::cast::transmute_mut_unsafe(buf);\n+                for v.each |ss| {\n+                    do as_buf(*ss) |ssbuf, sslen| {\n+                        let sslen = sslen - 1;\n+                        if first {\n+                            first = false;\n+                        } else {\n+                            ptr::copy_memory(buf, sepbuf, seplen);\n+                            buf = buf.offset(seplen);\n+                        }\n+                        ptr::copy_memory(buf, ssbuf, sslen);\n+                        buf = buf.offset(sslen);\n+                    }\n+                }\n+            }\n+        }\n+        raw::set_len(&mut s, len);\n     }\n     s\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n pub fn connect_slices(v: &[&str], sep: &str) -> ~str {\n+    if v.is_empty() { return ~\"\"; }\n+\n+    // this is wrong without the guarantee that v is non-empty\n+    let mut len = sep.len() * (v.len() - 1);\n+    for v.each |ss| {\n+        len += ss.len();\n+    }\n     let mut s = ~\"\", first = true;\n-    for vec::each(v) |ss| {\n-        if first { first = false; } else { push_str(&mut s, sep); }\n-        push_str(&mut s, *ss);\n+\n+    reserve(&mut s, len);\n+\n+    unsafe {\n+        do as_buf(s) |buf, _len| {\n+            do as_buf(sep) |sepbuf, seplen| {\n+                let seplen = seplen - 1;\n+                let mut buf = ::cast::transmute_mut_unsafe(buf);\n+                for vec::each(v) |ss| {\n+                    do as_buf(*ss) |ssbuf, sslen| {\n+                        let sslen = sslen - 1;\n+                        if first {\n+                            first = false;\n+                        } else if seplen > 0 {\n+                            ptr::copy_memory(buf, sepbuf, seplen);\n+                            buf = buf.offset(seplen);\n+                        }\n+                        ptr::copy_memory(buf, ssbuf, sslen);\n+                        buf = buf.offset(sslen);\n+                    }\n+                }\n+            }\n+        }\n+        raw::set_len(&mut s, len);\n     }\n     s\n }\n \n /// Given a string, make a new string with repeated copies of it\n pub fn repeat(ss: &str, nn: uint) -> ~str {\n-    let mut acc = ~\"\";\n-    for nn.times { acc += ss; }\n-    acc\n+    do as_buf(ss) |buf, len| {\n+        let mut ret = ~\"\";\n+        // ignore the NULL terminator\n+        let len = len - 1;\n+        reserve(&mut ret, nn * len);\n+\n+        unsafe {\n+            do as_buf(ret) |rbuf, _len| {\n+                let mut rbuf = ::cast::transmute_mut_unsafe(rbuf);\n+\n+                for nn.times {\n+                    ptr::copy_memory(rbuf, buf, len);\n+                    rbuf = rbuf.offset(len);\n+                }\n+            }\n+            raw::set_len(&mut ret, nn * len);\n+        }\n+        ret\n+    }\n }\n \n /*\n@@ -820,6 +915,7 @@ Section: Comparing strings\n /// Bytewise slice equality\n #[cfg(notest)]\n #[lang=\"str_eq\"]\n+#[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n@@ -836,6 +932,7 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n }\n \n #[cfg(test)]\n+#[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n@@ -854,15 +951,18 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n /// Bytewise string equality\n #[cfg(notest)]\n #[lang=\"uniq_str_eq\"]\n+#[inline]\n pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n #[cfg(test)]\n+#[inline]\n pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n+#[inline]\n fn cmp(a: &str, b: &str) -> Ordering {\n     let low = uint::min(a.len(), b.len());\n \n@@ -879,20 +979,24 @@ fn cmp(a: &str, b: &str) -> Ordering {\n \n #[cfg(notest)]\n impl<'self> TotalOrd for &'self str {\n+    #[inline]\n     fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl TotalOrd for ~str {\n+    #[inline]\n     fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n }\n \n #[cfg(notest)]\n impl TotalOrd for @str {\n+    #[inline]\n     fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n }\n \n /// Bytewise slice less than\n+#[inline]\n fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let end = uint::min(a_len, b_len);\n@@ -909,16 +1013,19 @@ fn lt(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise less than or equal\n+#[inline]\n pub fn le(a: &str, b: &str) -> bool {\n     !lt(b, a)\n }\n \n /// Bytewise greater than or equal\n+#[inline]\n fn ge(a: &str, b: &str) -> bool {\n     !lt(a, b)\n }\n \n /// Bytewise greater than\n+#[inline]\n fn gt(a: &str, b: &str) -> bool {\n     !le(a, b)\n }\n@@ -1595,6 +1702,7 @@ Section: String properties\n */\n \n /// Returns true if the string has length 0\n+#[inline(always)]\n pub fn is_empty(s: &str) -> bool { len(s) == 0u }\n \n /**\n@@ -1616,11 +1724,13 @@ fn is_alphanumeric(s: &str) -> bool {\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n+#[inline(always)]\n pub fn len(s: &str) -> uint {\n     do as_buf(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n+#[inline(always)]\n pub fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n@@ -1752,7 +1862,8 @@ pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     return len;\n }\n \n-/// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n+/// Counts the number of bytes taken by the first `n` chars in `s`\n+/// starting from `start`.\n pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n     assert!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n@@ -1988,6 +2099,7 @@ static tag_six_b: uint = 252u;\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n+#[inline]\n pub fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n@@ -2023,6 +2135,7 @@ pub fn as_bytes_slice<'a>(s: &'a str) -> &'a [u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n+#[inline]\n pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n@@ -2099,6 +2212,7 @@ pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n+#[inline(always)]\n pub fn reserve(s: &mut ~str, n: uint) {\n     unsafe {\n         let v: *mut ~[u8] = cast::transmute(s);\n@@ -2126,6 +2240,7 @@ pub fn reserve(s: &mut ~str, n: uint) {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n+#[inline(always)]\n pub fn reserve_at_least(s: &mut ~str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n@@ -2314,6 +2429,7 @@ pub mod raw {\n     }\n \n     /// Sets the length of the string and adds the null terminator\n+    #[inline]\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n         let v: **mut vec::raw::VecRepr = cast::transmute(v);\n         let repr: *mut vec::raw::VecRepr = *v;\n@@ -2483,7 +2599,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n     /// Returns the size in bytes not counting the null terminator\n-    #[inline]\n+    #[inline(always)]\n     fn len(&self) -> uint { len(*self) }\n     /// Returns the number of characters that a string holds\n     #[inline]\n@@ -2593,10 +2709,11 @@ pub trait OwnedStr {\n }\n \n impl OwnedStr for ~str {\n+    #[inline]\n     fn push_str(&mut self, v: &str) {\n         push_str(self, v);\n     }\n-\n+    #[inline]\n     fn push_char(&mut self, c: char) {\n         push_char(self, c);\n     }"}, {"sha": "73f556518fa66416077a00a633116a07ee8f8c57", "filename": "src/libcore/str/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fascii.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Operations on ASCII strings and characters.\n+\n use to_str::{ToStr,ToStrConsume};\n use str;\n use cast;"}, {"sha": "4eca7ebbb371ed9efd9f0cff4cb1d4a5f2aedf3b", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,6 +10,7 @@\n \n //! Misc low level stuff\n \n+use option::{Some, None};\n use cast;\n use cmp::{Eq, Ord};\n use gc;\n@@ -199,36 +200,33 @@ impl FailWithCause for &'static str {\n     }\n }\n \n-// NOTE: remove function after snapshot\n-#[cfg(stage0)]\n-pub fn begin_unwind(msg: ~str, file: ~str, line: uint) -> ! {\n-    do str::as_buf(msg) |msg_buf, _msg_len| {\n-        do str::as_buf(file) |file_buf, _file_len| {\n+// FIXME #4427: Temporary until rt::rt_fail_ goes away\n+pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+    use rt::{context, OldTaskContext};\n+    use rt::local_services::unsafe_borrow_local_services;\n+\n+    match context() {\n+        OldTaskContext => {\n             unsafe {\n-                let msg_buf = cast::transmute(msg_buf);\n-                let file_buf = cast::transmute(file_buf);\n-                begin_unwind_(msg_buf, file_buf, line as libc::size_t)\n+                gc::cleanup_stack_for_failure();\n+                rustrt::rust_upcall_fail(msg, file, line);\n+                cast::transmute(())\n+            }\n+        }\n+        _ => {\n+            // XXX: Need to print the failure message\n+            gc::cleanup_stack_for_failure();\n+            unsafe {\n+                let local_services = unsafe_borrow_local_services();\n+                match local_services.unwinder {\n+                    Some(ref mut unwinder) => unwinder.begin_unwind(),\n+                    None => abort!(\"failure without unwinder. aborting process\")\n+                }\n             }\n         }\n     }\n }\n \n-// FIXME #4427: Temporary until rt::rt_fail_ goes away\n-pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    unsafe {\n-        gc::cleanup_stack_for_failure();\n-        rustrt::rust_upcall_fail(msg, file, line);\n-        cast::transmute(())\n-    }\n-}\n-\n-// NOTE: remove function after snapshot\n-#[cfg(stage0)]\n-pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n-    let (msg, file) = (msg.to_owned(), file.to_owned());\n-    begin_unwind(~\"assertion failed: \" + msg, file, line)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use cast;\n@@ -343,11 +341,3 @@ mod tests {\n     #[should_fail]\n     fn fail_owned() { FailWithCause::fail_with(~\"cause\", file!(), line!())  }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "dff5908c047962e788acdc20a9f744e17c95dab4", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -27,8 +27,7 @@ magic.\n */\n \n use prelude::*;\n-use task::local_data_priv::{local_get, local_pop, local_modify, local_set};\n-use task::rt;\n+use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handle};\n \n /**\n  * Indexes a task-local data slot. The function's code pointer is used for\n@@ -53,7 +52,7 @@ pub type LocalDataKey<'self,T> = &'self fn(v: @T);\n pub unsafe fn local_data_pop<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_pop(rt::rust_get_task(), key)\n+    local_pop(Handle::new(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n@@ -62,7 +61,7 @@ pub unsafe fn local_data_pop<T:Durable>(\n pub unsafe fn local_data_get<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get(rt::rust_get_task(), key)\n+    local_get(Handle::new(), key)\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n@@ -71,7 +70,7 @@ pub unsafe fn local_data_get<T:Durable>(\n pub unsafe fn local_data_set<T:Durable>(\n     key: LocalDataKey<T>, data: @T) {\n \n-    local_set(rt::rust_get_task(), key, data)\n+    local_set(Handle::new(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n@@ -81,7 +80,7 @@ pub unsafe fn local_data_modify<T:Durable>(\n     key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n-    local_modify(rt::rust_get_task(), key, modify_fn)\n+    local_modify(Handle::new(), key, modify_fn)\n }\n \n #[test]"}, {"sha": "10a40887e57928cfe17e27db382c9c42fe920838", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,15 +18,39 @@ use task::rt;\n use task::local_data::LocalDataKey;\n \n use super::rt::rust_task;\n+use rt::local_services::LocalStorage;\n+\n+pub enum Handle {\n+    OldHandle(*rust_task),\n+    NewHandle(*mut LocalStorage)\n+}\n+\n+impl Handle {\n+    pub fn new() -> Handle {\n+        use rt::{context, OldTaskContext};\n+        use rt::local_services::unsafe_borrow_local_services;\n+        unsafe {\n+            match context() {\n+                OldTaskContext => {\n+                    OldHandle(rt::rust_get_task())\n+                }\n+                _ => {\n+                    let local_services = unsafe_borrow_local_services();\n+                    NewHandle(&mut local_services.storage)\n+                }\n+            }\n+        }\n+    }\n+}\n \n pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }\n \n impl Eq for @LocalData {\n     fn eq(&self, other: &@LocalData) -> bool {\n         unsafe {\n-            let ptr_a: (uint, uint) = cast::transmute(*self);\n-            let ptr_b: (uint, uint) = cast::transmute(*other);\n+            let ptr_a: &(uint, uint) = cast::transmute(self);\n+            let ptr_b: &(uint, uint) = cast::transmute(other);\n             return ptr_a == ptr_b;\n         }\n     }\n@@ -39,7 +63,7 @@ type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n \n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n+fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n         assert!(!map_ptr.is_null());\n         // Get and keep the single reference that was created at the\n@@ -50,8 +74,19 @@ extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_local_map(handle: Handle) -> TaskLocalMap {\n+    match handle {\n+        OldHandle(task) => get_task_local_map(task),\n+        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n+    }\n+}\n+\n unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n+    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n+        cleanup_task_local_map(map_ptr);\n+    }\n+\n     // Relies on the runtime initialising the pointer to null.\n     // Note: The map's box lives in TLS invisibly referenced once. Each time\n     // we retrieve it for get/set, we make another reference, which get/set\n@@ -60,7 +95,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     if map_ptr.is_null() {\n         let map: TaskLocalMap = @mut ~[];\n         rt::rust_set_task_local_data(task, cast::transmute(map));\n-        rt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n+        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n         // Also need to reference it an extra time to keep it for now.\n         let nonmut = cast::transmute::<TaskLocalMap,\n                                        @~[Option<TaskLocalElement>]>(map);\n@@ -75,6 +110,27 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n+unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> TaskLocalMap {\n+    match &mut *local {\n+        &LocalStorage(map_ptr, Some(_)) => {\n+            assert!(map_ptr.is_not_null());\n+            let map = cast::transmute(map_ptr);\n+            let nonmut = cast::transmute::<TaskLocalMap,\n+            @~[Option<TaskLocalElement>]>(map);\n+            cast::bump_box_refcount(nonmut);\n+            return map;\n+        }\n+        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+            assert!((*map_ptr).is_null());\n+            let map: TaskLocalMap = @mut ~[];\n+            *map_ptr = cast::transmute(map);\n+            let at_exit_fn: ~fn(*libc::c_void) = |p|cleanup_task_local_map(p);\n+            *at_exit = Some(at_exit_fn);\n+            return map;\n+        }\n+    }\n+}\n+\n unsafe fn key_to_key_value<T:Durable>(key: LocalDataKey<T>) -> *libc::c_void {\n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n     // Use reintepret_cast -- transmute would leak (forget) the closure.\n@@ -102,10 +158,10 @@ unsafe fn local_data_lookup<T:Durable>(\n }\n \n unsafe fn local_get_helper<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>,\n+    handle: Handle, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n-    let map = get_task_local_map(task);\n+    let map = get_local_map(handle);\n     // Interpreturn our findings from the map\n     do local_data_lookup(map, key).map |result| {\n         // A reference count magically appears on 'data' out of thin air. It\n@@ -124,31 +180,31 @@ unsafe fn local_get_helper<T:Durable>(\n \n \n pub unsafe fn local_pop<T:Durable>(\n-    task: *rust_task,\n+    handle: Handle,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get_helper(task, key, true)\n+    local_get_helper(handle, key, true)\n }\n \n pub unsafe fn local_get<T:Durable>(\n-    task: *rust_task,\n+    handle: Handle,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n-    local_get_helper(task, key, false)\n+    local_get_helper(handle, key, false)\n }\n \n pub unsafe fn local_set<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>, data: @T) {\n+    handle: Handle, key: LocalDataKey<T>, data: @T) {\n \n-    let map = get_task_local_map(task);\n+    let map = get_local_map(handle);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n     // We keep the data in two forms: one as an unsafe pointer, so we can get\n     // it back by casting; another in an existential box, so the reference we\n     // own on it can be dropped when the box is destroyed. The unsafe pointer\n     // does not have a reference associated with it, so it may become invalid\n     // when the box is destroyed.\n-    let data_ptr = cast::transmute(data);\n+    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n     let data_box = @data as @LocalData;\n     // Construct new entry to store in the map.\n     let new_entry = Some((keyval, data_ptr, data_box));\n@@ -170,12 +226,12 @@ pub unsafe fn local_set<T:Durable>(\n }\n \n pub unsafe fn local_modify<T:Durable>(\n-    task: *rust_task, key: LocalDataKey<T>,\n+    handle: Handle, key: LocalDataKey<T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(task, key));\n+    let newdata = modify_fn(local_pop(handle, key));\n     if newdata.is_some() {\n-        local_set(task, key, newdata.unwrap());\n+        local_set(handle, key, newdata.unwrap());\n     }\n }"}, {"sha": "fd695c16ea7cb9359408062a19a8bf7c4c3e70c4", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 49, "deletions": 61, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -39,9 +39,10 @@ use result::Result;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use prelude::*;\n use result;\n-use task::rt::{task_id, sched_id, rust_task};\n+use task::rt::{task_id, sched_id};\n use util;\n use util::replace;\n+use unstable::finally::Finally;\n \n #[cfg(test)] use comm::SharedChan;\n \n@@ -558,8 +559,31 @@ pub fn yield() {\n pub fn failing() -> bool {\n     //! True if the running task has failed\n \n-    unsafe {\n-        rt::rust_task_is_unwinding(rt::rust_get_task())\n+    use rt::{context, OldTaskContext};\n+    use rt::local_services::borrow_local_services;\n+\n+    match context() {\n+        OldTaskContext => {\n+            unsafe {\n+                rt::rust_task_is_unwinding(rt::rust_get_task())\n+            }\n+        }\n+        _ => {\n+            let mut unwinding = false;\n+            do borrow_local_services |local| {\n+                unwinding = match local.unwinder {\n+                    Some(unwinder) => {\n+                        unwinder.unwinding\n+                    }\n+                    None => {\n+                        // Because there is no unwinder we can't be unwinding.\n+                        // (The process will abort on failure)\n+                        false\n+                    }\n+                }\n+            }\n+            return unwinding;\n+        }\n     }\n }\n \n@@ -591,76 +615,40 @@ pub fn get_scheduler() -> Scheduler {\n  * ~~~\n  */\n pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n-    struct AllowFailure {\n-        t: *rust_task,\n-        drop {\n-            unsafe {\n-                rt::rust_task_allow_kill(self.t);\n-            }\n-        }\n-    }\n-\n-    fn AllowFailure(t: *rust_task) -> AllowFailure{\n-        AllowFailure {\n-            t: t\n-        }\n-    }\n-\n     let t = rt::rust_get_task();\n-    let _allow_failure = AllowFailure(t);\n-    rt::rust_task_inhibit_kill(t);\n-    f()\n+    do (|| {\n+        rt::rust_task_inhibit_kill(t);\n+        f()\n+    }).finally {\n+        rt::rust_task_allow_kill(t);\n+    }\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n-    struct DisallowFailure {\n-        t: *rust_task,\n-        drop {\n-            unsafe {\n-                rt::rust_task_inhibit_kill(self.t);\n-            }\n-        }\n-    }\n-\n-    fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n-        DisallowFailure {\n-            t: t\n-        }\n-    }\n-\n     let t = rt::rust_get_task();\n-    let _allow_failure = DisallowFailure(t);\n-    rt::rust_task_allow_kill(t);\n-    f()\n+    do (|| {\n+        rt::rust_task_allow_kill(t);\n+        f()\n+    }).finally {\n+        rt::rust_task_inhibit_kill(t);\n+    }\n }\n \n /**\n  * A stronger version of unkillable that also inhibits scheduling operations.\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    struct DeferInterrupts {\n-        t: *rust_task,\n-        drop {\n-            unsafe {\n-                rt::rust_task_allow_yield(self.t);\n-                rt::rust_task_allow_kill(self.t);\n-            }\n-        }\n-    }\n-\n-    fn DeferInterrupts(t: *rust_task) -> DeferInterrupts {\n-        DeferInterrupts {\n-            t: t\n-        }\n-    }\n-\n     let t = rt::rust_get_task();\n-    let _interrupts = DeferInterrupts(t);\n-    rt::rust_task_inhibit_kill(t);\n-    rt::rust_task_inhibit_yield(t);\n-    f()\n+    do (|| {\n+        rt::rust_task_inhibit_kill(t);\n+        rt::rust_task_inhibit_yield(t);\n+        f()\n+    }).finally {\n+        rt::rust_task_allow_yield(t);\n+        rt::rust_task_allow_kill(t);\n+    }\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -832,7 +820,7 @@ fn test_run_basic() {\n     po.recv();\n }\n \n-#[test]\n+#[cfg(test)]\n struct Wrapper {\n     mut f: Option<Chan<()>>\n }\n@@ -1229,7 +1217,7 @@ fn test_spawn_thread_on_demand() {\n \n #[test]\n fn test_simple_newsched_spawn() {\n-    use rt::run_in_newsched_task;\n+    use rt::test::run_in_newsched_task;\n \n     do run_in_newsched_task {\n         spawn(||())"}, {"sha": "267250b3642a03706879e1428c37ea6d4d58a384", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -80,7 +80,7 @@ use prelude::*;\n use unstable;\n use ptr;\n use hashmap::HashSet;\n-use task::local_data_priv::{local_get, local_set};\n+use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n use task::rt;\n use task::{Failure, ManualThreads, PlatformThread, SchedOpts, SingleThreaded};\n@@ -451,7 +451,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         /*##################################################################*\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n-        let spawner_group = match local_get(spawner, taskgroup_key!()) {\n+        let spawner_group = match local_get(OldHandle(spawner), taskgroup_key!()) {\n             None => {\n                 // Main task, doing first spawn ever. Lazily initialise here.\n                 let mut members = new_taskset();\n@@ -463,7 +463,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Main task/group has no ancestors, no notifier, etc.\n                 let group =\n                     @TCB(spawner, tasks, AncestorList(None), true, None);\n-                local_set(spawner, taskgroup_key!(), group);\n+                local_set(OldHandle(spawner), taskgroup_key!(), group);\n                 group\n             }\n             Some(group) => group\n@@ -627,7 +627,7 @@ fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n                 let group = @TCB(child, child_arc, ancestors,\n                                  is_main, notifier);\n                 unsafe {\n-                    local_set(child, taskgroup_key!(), group);\n+                    local_set(OldHandle(child), taskgroup_key!(), group);\n                 }\n \n                 // Run the child's body."}, {"sha": "9e4da7ab48868a96ea998477597f479fccb3d42b", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -419,8 +419,7 @@ impl<A> IterBytes for *const A {\n     }\n }\n \n-\n-trait ToBytes {\n+pub trait ToBytes {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8];\n }\n "}, {"sha": "d6e2c5eee6aca8400bd324f4f1cf25e271f97864", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,6 +10,8 @@\n \n #[doc(hidden)]; // FIXME #3538\n \n+// The following code was generated by \"src/etc/unicode.py\"\n+\n pub mod general_category {\n \n     fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n@@ -2640,4 +2642,3 @@ pub mod derived_property {\n         bsearch_range_table(c, XID_Start_table)\n     }\n }\n-"}, {"sha": "57ed579e88ddab785234de6f82dc3785c5b14a3f", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -81,4 +81,3 @@ extern {\n     #[rust_stack]\n     fn rust_get_exchange_count_ptr() -> *mut int;\n }\n-"}, {"sha": "258da9ff38310082b8ce410b121903445d6bc8b3", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -688,11 +688,3 @@ mod test {\n         let _s = fmt!(\"%s\", s);\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "65cfc6ec1fe05e0db2d3bcd1148885583ab21ee3", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -46,10 +46,6 @@ pub extern \"rust-intrinsic\" {\n \n     pub fn forget<T>(_: T) -> ();\n \n-    // XXX: intrinsic uses legacy modes\n-    #[cfg(stage0)]\n-    fn reinterpret_cast<T,U>(&&src: T) -> U;\n-\n     pub fn needs_drop<T>() -> bool;\n \n     // XXX: intrinsic uses legacy modes and has reference to TyDesc"}, {"sha": "deff06d46f6c92c4346820bcde42bb90a60c0c4c", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,9 +18,11 @@ use str;\n use sys;\n use unstable::exchange_alloc;\n use cast::transmute;\n-use task::rt::rust_get_task;\n+use rt::{context, OldTaskContext};\n+use rt::local_services::borrow_local_services;\n use option::{Option, Some, None};\n use io;\n+use task::rt::rust_get_task;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -249,21 +251,36 @@ pub unsafe fn exchange_free(ptr: *c_char) {\n }\n \n #[lang=\"malloc\"]\n-#[inline(always)]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    let result = rustrt::rust_upcall_malloc_noswitch(td, size);\n-    debug_mem(\"local_malloc: \", result);\n-    return result;\n+    match context() {\n+        OldTaskContext => {\n+            return rustrt::rust_upcall_malloc_noswitch(td, size);\n+        }\n+        _ => {\n+            let mut alloc = ::ptr::null();\n+            do borrow_local_services |srv| {\n+                alloc = srv.heap.alloc(td as *c_void, size as uint) as *c_char;\n+            }\n+            return alloc;\n+        }\n+    }\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[lang=\"free\"]\n-#[inline(always)]\n pub unsafe fn local_free(ptr: *c_char) {\n-    debug_mem(\"local_free: \", ptr);\n-    rustrt::rust_upcall_free_noswitch(ptr);\n+    match context() {\n+        OldTaskContext => {\n+            rustrt::rust_upcall_free_noswitch(ptr);\n+        }\n+        _ => {\n+            do borrow_local_services |srv| {\n+                srv.heap.free(ptr as *c_void);\n+            }\n+        }\n+    }\n }\n \n #[cfg(stage0)]\n@@ -444,11 +461,3 @@ pub fn start(main: *u8, argc: int, argv: **c_char,\n                       crate_map: *c_void) -> c_int;\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "6edbdcb51b0cba2f5ee4d4dea1e5f21b0abd1e57", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -205,4 +205,3 @@ fn test_select_stream_and_oneshot() {\n     chan.send(());\n     waitport.recv();\n }\n-"}, {"sha": "ced3c300a359abf2f50e71c1421dcdea4114f6fd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -134,9 +134,9 @@ pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n }\n \n /**\n- * Creates and initializes an immutable vector.\n+ * Creates and initializes an owned vector.\n  *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * Creates an owned vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> ~[T] {\n@@ -156,9 +156,9 @@ pub fn from_fn<T>(n_elts: uint, op: old_iter::InitOp<T>) -> ~[T] {\n }\n \n /**\n- * Creates and initializes an immutable vector.\n+ * Creates and initializes an owned vector.\n  *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * Creates an owned vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {"}, {"sha": "7c93d867f5040869f3ee5d91fcf8621fe55fb560", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -693,10 +693,3 @@ pub fn main() {\n \n     error!(\"Fuzzer done\");\n }\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "e722e1a33c62b087bd0f54c66557925c8555883f", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -57,6 +57,13 @@ pub static n_tydesc_fields: uint = 8u;\n pub static fn_field_code: uint = 0u;\n pub static fn_field_box: uint = 1u;\n \n+// The three fields of a trait object/trait instance: vtable, box, and type\n+// description.\n+pub static trt_field_vtable: uint = 0u;\n+pub static trt_field_box: uint = 1u;\n+// This field is only present in unique trait objects, so it comes last.\n+pub static trt_field_tydesc: uint = 2u;\n+\n pub static vec_elt_fill: uint = 0u;\n \n pub static vec_elt_alloc: uint = 1u;\n@@ -77,12 +84,3 @@ pub fn bzero_glue_name() -> ~str { return ~\"rust_bzero_glue\"; }\n pub fn yield_glue_name() -> ~str { return ~\"rust_yield_glue\"; }\n \n pub fn no_op_type_glue_name() -> ~str { return ~\"rust_no_op_type_glue\"; }\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "dfe5751f21b8304ab1cc45dfa64b95815d752ce1", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -72,14 +72,3 @@ pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n         cc_args: ~[~\"-marm\"]\n     };\n }\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "de6469e81807d679975e06531ee05069541b66d9", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 105, "deletions": 86, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -747,6 +747,79 @@ pub fn link_binary(sess: Session,\n                    obj_filename: &Path,\n                    out_filename: &Path,\n                    lm: LinkMeta) {\n+    // In the future, FreeBSD will use clang as default compiler.\n+    // It would be flexible to use cc (system's default C compiler)\n+    // instead of hard-coded gcc.\n+    // For win32, there is no cc command,\n+    // so we add a condition to make it use gcc.\n+    let cc_prog: ~str = match sess.opts.linker {\n+        Some(copy linker) => linker,\n+        None => {\n+            if sess.targ_cfg.os == session::os_android {\n+                match &sess.opts.android_cross_path {\n+                    &Some(copy path) => {\n+                        fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n+                    }\n+                    &None => {\n+                        sess.fatal(~\"need Android NDK path for linking \\\n+                                     (--android-cross-path)\")\n+                    }\n+                }\n+            } else if sess.targ_cfg.os == session::os_win32 {\n+                ~\"gcc\"\n+            } else {\n+                ~\"cc\"\n+            }\n+        }\n+    };\n+    // The invocations of cc share some flags across platforms\n+\n+\n+    let output = if *sess.building_library {\n+        let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n+        debug!(\"link_meta.name:  %s\", lm.name);\n+        debug!(\"long_libname: %s\", long_libname);\n+        debug!(\"out_filename: %s\", out_filename.to_str());\n+        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n+\n+        out_filename.dir_path().push(long_libname)\n+    } else {\n+        /*bad*/copy *out_filename\n+    };\n+\n+    debug!(\"output: %s\", output.to_str());\n+    let mut cc_args = link_args(sess, obj_filename, out_filename, lm);\n+    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n+    // We run 'cc' here\n+    let prog = run::program_output(cc_prog, cc_args);\n+    if 0 != prog.status {\n+        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n+                      cc_prog, prog.status));\n+        sess.note(fmt!(\"%s arguments: %s\",\n+                       cc_prog, str::connect(cc_args, ~\" \")));\n+        sess.note(prog.err + prog.out);\n+        sess.abort_if_errors();\n+    }\n+\n+    // Clean up on Darwin\n+    if sess.targ_cfg.os == session::os_macos {\n+        run::run_program(~\"dsymutil\", ~[output.to_str()]);\n+    }\n+\n+    // Remove the temporary object file if we aren't saving temps\n+    if !sess.opts.save_temps {\n+        if ! os::remove_file(obj_filename) {\n+            sess.warn(fmt!(\"failed to delete object file `%s`\",\n+                           obj_filename.to_str()));\n+        }\n+    }\n+}\n+\n+pub fn link_args(sess: Session,\n+                 obj_filename: &Path,\n+                 out_filename: &Path,\n+                 lm:LinkMeta) -> ~[~str] {\n+\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::config, stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n@@ -757,48 +830,23 @@ pub fn link_binary(sess: Session,\n         }\n     }\n \n+\n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        debug!(\"link_meta.name:  %s\", lm.name);\n-        debug!(\"long_libname: %s\", long_libname);\n-        debug!(\"out_filename: %s\", out_filename.to_str());\n-        debug!(\"dirname(out_filename): %s\", out_filename.dir_path().to_str());\n-\n         out_filename.dir_path().push(long_libname)\n     } else {\n         /*bad*/copy *out_filename\n     };\n \n-    debug!(\"output: %s\", output.to_str());\n-\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let stage: ~str = ~\"-L\" + sess.filesearch.get_target_lib_path().to_str();\n \n-    // In the future, FreeBSD will use clang as default compiler.\n-    // It would be flexible to use cc (system's default C compiler)\n-    // instead of hard-coded gcc.\n-    // For win32, there is no cc command,\n-    // so we add a condition to make it use gcc.\n-    let cc_prog: ~str = if sess.targ_cfg.os == session::os_android {\n-        match &sess.opts.android_cross_path {\n-            &Some(copy path) => {\n-                fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n-            }\n-            &None => {\n-                sess.fatal(~\"need Android NDK path for linking \\\n-                             (--android-cross-path)\")\n-            }\n-        }\n-    } else if sess.targ_cfg.os == session::os_win32 { ~\"gcc\" }\n-    else { ~\"cc\" };\n-    // The invocations of cc share some flags across platforms\n+    let mut args = vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n \n-    let mut cc_args =\n-        vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n-    cc_args.push(~\"-o\");\n-    cc_args.push(output.to_str());\n-    cc_args.push(obj_filename.to_str());\n+    args.push(~\"-o\");\n+    args.push(output.to_str());\n+    args.push(obj_filename.to_str());\n \n     let lib_cmd;\n     let os = sess.targ_cfg.os;\n@@ -813,23 +861,23 @@ pub fn link_binary(sess: Session,\n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each |cratepath| {\n         if cratepath.filetype() == Some(~\".rlib\") {\n-            cc_args.push(cratepath.to_str());\n+            args.push(cratepath.to_str());\n             loop;\n         }\n         let dir = cratepath.dirname();\n-        if dir != ~\"\" { cc_args.push(~\"-L\" + dir); }\n+        if dir != ~\"\" { args.push(~\"-L\" + dir); }\n         let libarg = unlib(sess.targ_cfg, cratepath.filestem().get());\n-        cc_args.push(~\"-l\" + libarg);\n+        args.push(~\"-l\" + libarg);\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { cc_args.push(/*bad*/copy *arg); }\n+    for ula.each |arg| { args.push(/*bad*/copy *arg); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n         do vec::consume(link_args) |_, link_arg| {\n-            cc_args.push(link_arg);\n+            args.push(link_arg);\n         }\n     }\n \n@@ -842,99 +890,70 @@ pub fn link_binary(sess: Session,\n     // forces to make sure that library can be found at runtime.\n \n     for sess.opts.addl_lib_search_paths.each |path| {\n-        cc_args.push(~\"-L\" + path.to_str());\n+        args.push(~\"-L\" + path.to_str());\n     }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each |l| { cc_args.push(~\"-l\" + *l); }\n+    for used_libs.each |l| { args.push(~\"-l\" + *l); }\n \n     if *sess.building_library {\n-        cc_args.push(lib_cmd);\n+        args.push(lib_cmd);\n \n         // On mac we need to tell the linker to let this library\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n-            cc_args.push(~\"-Wl,-install_name,@rpath/\"\n+            args.push(~\"-Wl,-install_name,@rpath/\"\n                       + output.filename().get());\n         }\n     }\n \n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n-        cc_args.push_all(~[~\"-lrt\", ~\"-ldl\"]);\n+        args.push_all(~[~\"-lrt\", ~\"-ldl\"]);\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n-        cc_args.push(~\"-lm\");\n+        args.push(~\"-lm\");\n     }\n     else if sess.targ_cfg.os == session::os_android {\n-        cc_args.push_all(~[~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\",\n+        args.push_all(~[~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\",\n                            ~\"-lgnustl_shared\"]);\n-        cc_args.push(~\"-lm\");\n+        args.push(~\"-lm\");\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {\n-        cc_args.push_all(~[~\"-pthread\", ~\"-lrt\",\n-                                ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n-                                ~\"-L/usr/local/lib/gcc46\",\n-                                ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n-                                ~\"-Wl,-z,origin\",\n-                                ~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n-                                ~\"-Wl,-rpath,/usr/local/lib/gcc44\"]);\n+        args.push_all(~[~\"-pthread\", ~\"-lrt\",\n+                        ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n+                        ~\"-L/usr/local/lib/gcc46\",\n+                        ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n+                        ~\"-Wl,-z,origin\",\n+                        ~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n+                        ~\"-Wl,-rpath,/usr/local/lib/gcc44\"]);\n     }\n \n     // OS X 10.6 introduced 'compact unwind info', which is produced by the\n     // linker from the dwarf unwind info. Unfortunately, it does not seem to\n     // understand how to unwind our __morestack frame, so we have to turn it\n     // off. This has impacted some other projects like GHC.\n     if sess.targ_cfg.os == session::os_macos {\n-        cc_args.push(~\"-Wl,-no_compact_unwind\");\n+        args.push(~\"-Wl,-no_compact_unwind\");\n     }\n \n     // Stack growth requires statically linking a __morestack function\n-    cc_args.push(~\"-lmorestack\");\n+    args.push(~\"-lmorestack\");\n \n     // Always want the runtime linked in\n-    cc_args.push(~\"-lrustrt\");\n+    args.push(~\"-lrustrt\");\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // extern libraries might live, based on the addl_lib_search_paths\n-    cc_args.push_all(rpath::get_rpath_flags(sess, &output));\n+    args.push_all(rpath::get_rpath_flags(sess, &output));\n \n-    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n-    // We run 'cc' here\n-    let prog = run::program_output(cc_prog, cc_args);\n-    if 0 != prog.status {\n-        sess.err(fmt!(\"linking with `%s` failed with code %d\",\n-                      cc_prog, prog.status));\n-        sess.note(fmt!(\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, ~\" \")));\n-        sess.note(prog.err + prog.out);\n-        sess.abort_if_errors();\n-    }\n+    // Finally add all the linker arguments provided on the command line\n+    args.push_all(sess.opts.linker_args);\n \n-    // Clean up on Darwin\n-    if sess.targ_cfg.os == session::os_macos {\n-        run::run_program(~\"dsymutil\", ~[output.to_str()]);\n-    }\n-\n-    // Remove the temporary object file if we aren't saving temps\n-    if !sess.opts.save_temps {\n-        if ! os::remove_file(obj_filename) {\n-            sess.warn(fmt!(\"failed to delete object file `%s`\",\n-                           obj_filename.to_str()));\n-        }\n-    }\n+    return args;\n }\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "b15306a56b0b9dcac5a7cb738a04faf0294bd54a", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -72,14 +72,3 @@ pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n         cc_args: ~[]\n     };\n }\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "fceff55abf8d49775835a1a0daa65669f9b7f51a", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -40,7 +40,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n     // where rustrt is and we know every rust program needs it\n     let libs = vec::append_one(libs, get_sysroot_absolute_rt_lib(sess));\n \n-    let rpaths = get_rpaths(os, &sysroot, output, libs,\n+    let rpaths = get_rpaths(os, sysroot, output, libs,\n                             sess.opts.target_triple);\n     rpaths_to_flags(rpaths)\n }"}, {"sha": "8fcc5234e8b51ab897d5f83c6c2ee24681ec48ea", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -59,12 +59,3 @@ pub fn declare_upcalls(targ_cfg: @session::config,\n             nothrow(dv(~\"reset_stack_limit\", ~[]))\n     }\n }\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "759f5f63c9ec232c04fafa15b1fda1f3561b1753", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -55,13 +55,3 @@ pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n         cc_args: ~[~\"-m32\"]\n     };\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "ed6f1d285147e5f8213057a9d9ace2b7c7a1ea5f", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -63,13 +63,3 @@ pub fn get_target_strs(target_os: session::os) -> target_strs::t {\n         cc_args: ~[~\"-m64\"]\n     };\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "5e8dab0f772870431dd86cf2f232da64697d7b83", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 72, "deletions": 63, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -234,7 +234,6 @@ pub fn compile_rest(sess: Session,\n     let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n         middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-\n     let outputs = outputs.get();\n \n     let (llmod, link_meta) = {\n@@ -306,6 +305,11 @@ pub fn compile_rest(sess: Session,\n \n     };\n \n+    if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n+        io::println(str::connect(link::link_args(sess,\n+            &outputs.obj_filename, &outputs.out_filename, link_meta), \" \"));\n+    }\n+\n     // NB: Android hack\n     if sess.targ_cfg.arch == abi::Arm &&\n             (sess.opts.output_type == link::output_type_object ||\n@@ -596,7 +600,7 @@ pub fn build_session_options(binary: @~str,\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n     let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n-    let sysroot_opt = sysroot_opt.map(|m| Path(*m));\n+    let sysroot_opt = sysroot_opt.map(|m| @Path(*m));\n     let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n     let target_feature_opt = getopts::opt_maybe_str(matches, ~\"target-feature\");\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n@@ -637,13 +641,21 @@ pub fn build_session_options(binary: @~str,\n         Some(s) => s\n     };\n \n-    let addl_lib_search_paths =\n-        getopts::opt_strs(matches, ~\"L\")\n-        .map(|s| Path(*s));\n+    let addl_lib_search_paths = getopts::opt_strs(matches, ~\"L\").map(|s| Path(*s));\n+    let linker = getopts::opt_maybe_str(matches, ~\"linker\");\n+    let linker_args = getopts::opt_strs(matches, ~\"link-args\").flat_map( |a| {\n+        let mut args = ~[];\n+        for str::each_split_char(*a, ' ') |arg| {\n+            args.push(str::from_slice(arg));\n+        }\n+        args\n+    });\n+\n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, ~\"cfg\"), demitter);\n     let test = opt_present(matches, ~\"test\");\n     let android_cross_path = getopts::opt_maybe_str(\n         matches, ~\"android-cross-path\");\n+\n     let sopts = @session::options {\n         crate_type: crate_type,\n         is_static: static,\n@@ -656,6 +668,8 @@ pub fn build_session_options(binary: @~str,\n         jit: jit,\n         output_type: output_type,\n         addl_lib_search_paths: addl_lib_search_paths,\n+        linker: linker,\n+        linker_args: linker_args,\n         maybe_sysroot: sysroot_opt,\n         target_triple: target,\n         target_feature: target_feature,\n@@ -729,62 +743,65 @@ pub fn parse_pretty(sess: Session, name: &str) -> pp_mode {\n // rustc command line options\n pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n  ~[\n-  optflag(~\"\",  ~\"bin\", ~\"Compile an executable crate (default)\"),\n-  optflag(~\"c\", ~\"\",    ~\"Compile and assemble, but do not link\"),\n-  optmulti(~\"\", ~\"cfg\", ~\"Configure the compilation\n-                          environment\", ~\"SPEC\"),\n-  optflag(~\"\",  ~\"emit-llvm\",\n-                        ~\"Produce an LLVM bitcode file\"),\n-  optflag(~\"h\", ~\"help\",~\"Display this message\"),\n-  optmulti(~\"L\", ~\"\",   ~\"Add a directory to the library search path\",\n-                              ~\"PATH\"),\n-  optflag(~\"\",  ~\"lib\", ~\"Compile a library crate\"),\n-  optflag(~\"\",  ~\"ls\",  ~\"List the symbols defined by a library crate\"),\n-  optflag(~\"\", ~\"no-trans\",\n-                        ~\"Run all passes except translation; no output\"),\n-  optflag(~\"O\", ~\"\",    ~\"Equivalent to --opt-level=2\"),\n-  optopt(~\"o\", ~\"\",     ~\"Write output to <filename>\", ~\"FILENAME\"),\n-  optopt(~\"\", ~\"opt-level\",\n-                        ~\"Optimize with possible levels 0-3\", ~\"LEVEL\"),\n-  optopt( ~\"\",  ~\"out-dir\",\n-                        ~\"Write output to compiler-chosen filename\n-                          in <dir>\", ~\"DIR\"),\n-  optflag(~\"\", ~\"parse-only\",\n-                        ~\"Parse only; do not compile, assemble, or link\"),\n-  optflagopt(~\"\", ~\"pretty\",\n-                        ~\"Pretty-print the input instead of compiling;\n+  optflag(\"\",  \"bin\", \"Compile an executable crate (default)\"),\n+  optflag(\"c\", \"\",    \"Compile and assemble, but do not link\"),\n+  optmulti(\"\", \"cfg\", \"Configure the compilation\n+                          environment\", \"SPEC\"),\n+  optflag(\"\",  \"emit-llvm\",\n+                        \"Produce an LLVM bitcode file\"),\n+  optflag(\"h\", \"help\",\"Display this message\"),\n+  optmulti(\"L\", \"\",   \"Add a directory to the library search path\",\n+                              \"PATH\"),\n+  optflag(\"\",  \"lib\", \"Compile a library crate\"),\n+  optopt(\"\", \"linker\", \"Program to use for linking instead of the default.\", \"LINKER\"),\n+  optmulti(\"\",  \"link-args\", \"FLAGS is a space-separated list of flags\n+                            passed to the linker\", \"FLAGS\"),\n+  optflag(\"\",  \"ls\",  \"List the symbols defined by a library crate\"),\n+  optflag(\"\", \"no-trans\",\n+                        \"Run all passes except translation; no output\"),\n+  optflag(\"O\", \"\",    \"Equivalent to --opt-level=2\"),\n+  optopt(\"o\", \"\",     \"Write output to <filename>\", \"FILENAME\"),\n+  optopt(\"\", \"opt-level\",\n+                        \"Optimize with possible levels 0-3\", \"LEVEL\"),\n+  optopt( \"\",  \"out-dir\",\n+                        \"Write output to compiler-chosen filename\n+                          in <dir>\", \"DIR\"),\n+  optflag(\"\", \"parse-only\",\n+                        \"Parse only; do not compile, assemble, or link\"),\n+  optflagopt(\"\", \"pretty\",\n+                        \"Pretty-print the input instead of compiling;\n                           valid types are: normal (un-annotated source),\n                           expanded (crates expanded),\n                           typed (crates expanded, with type annotations),\n                           or identified (fully parenthesized,\n-                          AST nodes and blocks with IDs)\", ~\"TYPE\"),\n-  optflag(~\"S\", ~\"\",    ~\"Compile only; do not assemble or link\"),\n-  optflag(~\"\", ~\"save-temps\",\n-                        ~\"Write intermediate files (.bc, .opt.bc, .o)\n+                          AST nodes and blocks with IDs)\", \"TYPE\"),\n+  optflag(\"S\", \"\",    \"Compile only; do not assemble or link\"),\n+  optflag(\"\", \"save-temps\",\n+                        \"Write intermediate files (.bc, .opt.bc, .o)\n                           in addition to normal output\"),\n-  optopt(~\"\", ~\"sysroot\",\n-                        ~\"Override the system root\", ~\"PATH\"),\n-  optflag(~\"\", ~\"test\", ~\"Build a test harness\"),\n-  optopt(~\"\", ~\"target\",\n-                        ~\"Target triple cpu-manufacturer-kernel[-os]\n+  optopt(\"\", \"sysroot\",\n+                        \"Override the system root\", \"PATH\"),\n+  optflag(\"\", \"test\", \"Build a test harness\"),\n+  optopt(\"\", \"target\",\n+                        \"Target triple cpu-manufacturer-kernel[-os]\n                           to compile for (see chapter 3.4 of http://www.sourceware.org/autobook/\n-                          for detail)\", ~\"TRIPLE\"),\n-  optopt(~\"\", ~\"target-feature\",\n-                        ~\"Target specific attributes (llc -mattr=help\n-                          for detail)\", ~\"FEATURE\"),\n-  optopt(~\"\", ~\"android-cross-path\",\n-         ~\"The path to the Android NDK\", \"PATH\"),\n-  optmulti(~\"W\", ~\"warn\",\n-                        ~\"Set lint warnings\", ~\"OPT\"),\n-  optmulti(~\"A\", ~\"allow\",\n-                        ~\"Set lint allowed\", ~\"OPT\"),\n-  optmulti(~\"D\", ~\"deny\",\n-                        ~\"Set lint denied\", ~\"OPT\"),\n-  optmulti(~\"F\", ~\"forbid\",\n-                        ~\"Set lint forbidden\", ~\"OPT\"),\n-  optmulti(~\"Z\", ~\"\",   ~\"Set internal debugging options\", \"FLAG\"),\n-  optflag( ~\"v\", ~\"version\",\n-                        ~\"Print version info and exit\"),\n+                          for detail)\", \"TRIPLE\"),\n+  optopt(\"\", \"target-feature\",\n+                        \"Target specific attributes (llc -mattr=help\n+                          for detail)\", \"FEATURE\"),\n+  optopt(\"\", \"android-cross-path\",\n+         \"The path to the Android NDK\", \"PATH\"),\n+  optmulti(\"W\", \"warn\",\n+                        \"Set lint warnings\", \"OPT\"),\n+  optmulti(\"A\", \"allow\",\n+                        \"Set lint allowed\", \"OPT\"),\n+  optmulti(\"D\", \"deny\",\n+                        \"Set lint denied\", \"OPT\"),\n+  optmulti(\"F\", \"forbid\",\n+                        \"Set lint forbidden\", \"OPT\"),\n+  optmulti(\"Z\", \"\",   \"Set internal debugging options\", \"FLAG\"),\n+  optflag( \"v\", \"version\",\n+                        \"Print version info and exit\"),\n  ]\n }\n \n@@ -928,11 +945,3 @@ mod test {\n         assert!((vec::len(test_items) == 1u));\n     }\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "3b9bbbb9f1c5d6f243b3d989d04cb7647592f3a2", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -63,6 +63,7 @@ pub static jit: uint = 1 << 19;\n pub static debug_info: uint = 1 << 20;\n pub static extra_debug_info: uint = 1 << 21;\n pub static static: uint = 1 << 22;\n+pub static print_link_args: uint = 1 << 23;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n@@ -90,6 +91,7 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"no-opt\", ~\"do not optimize, even if -O is passed\", no_opt),\n      (~\"no-monomorphic-collapse\", ~\"do not collapse template instantiations\",\n       no_monomorphic_collapse),\n+     (~\"print-link-args\", ~\"Print the arguments passed to the linker\", print_link_args),\n      (~\"gc\", ~\"Garbage collect shared data (experimental)\", gc),\n      (~\"jit\", ~\"Execute using JIT (experimental)\", jit),\n      (~\"extra-debug-info\", ~\"Extra debugging info (experimental)\",\n@@ -122,7 +124,9 @@ pub struct options {\n     jit: bool,\n     output_type: back::link::output_type,\n     addl_lib_search_paths: ~[Path],\n-    maybe_sysroot: Option<Path>,\n+    linker: Option<~str>,\n+    linker_args: ~[~str],\n+    maybe_sysroot: Option<@Path>,\n     target_triple: ~str,\n     target_feature: ~str,\n     // User-specified cfg meta items. The compiler itself will add additional\n@@ -172,20 +176,16 @@ pub struct Session_ {\n pub type Session = @Session_;\n \n pub impl Session_ {\n-    fn span_fatal(@self, sp: span, msg: ~str) -> ! {\n-        debug!(\"span_fatal invoked: %s\", msg);\n+    fn span_fatal(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    fn fatal(@self, msg: ~str) -> ! {\n-        debug!(\"fatal invoked: %s\", msg);\n+    fn fatal(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    fn span_err(@self, sp: span, msg: ~str) {\n-        debug!(\"span_err invoked: %s\", msg);\n+    fn span_err(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    fn err(@self, msg: ~str) {\n-        debug!(\"err invoked: %s\", msg);\n+    fn err(@self, msg: &str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n     fn has_errors(@self) -> bool {\n@@ -194,35 +194,31 @@ pub impl Session_ {\n     fn abort_if_errors(@self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    fn span_warn(@self, sp: span, msg: ~str) {\n-        debug!(\"span_warn invoked: %s\", msg);\n+    fn span_warn(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    fn warn(@self, msg: ~str) {\n-        debug!(\"warn invoked: %s\", msg);\n+    fn warn(@self, msg: &str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    fn span_note(@self, sp: span, msg: ~str) {\n-        debug!(\"span_note invoked: %s\", msg);\n+    fn span_note(@self, sp: span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    fn note(@self, msg: ~str) {\n-        debug!(\"note invoked: %s\", msg);\n+    fn note(@self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    fn span_bug(@self, sp: span, msg: ~str) -> ! {\n+    fn span_bug(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    fn bug(@self, msg: ~str) -> ! {\n+    fn bug(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    fn span_unimpl(@self, sp: span, msg: ~str) -> ! {\n+    fn span_unimpl(@self, sp: span, msg: &str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    fn unimpl(@self, msg: ~str) -> ! {\n+    fn unimpl(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(@self, level: lint::level, sp: span, msg: ~str) {\n+    fn span_lint_level(@self, level: lint::level, sp: span, msg: &str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -235,7 +231,7 @@ pub impl Session_ {\n                  expr_id: ast::node_id,\n                  item_id: ast::node_id,\n                  span: span,\n-                 msg: ~str) {\n+                 msg: &str) {\n         let level = lint::get_lint_settings_level(\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);\n@@ -307,6 +303,8 @@ pub fn basic_options() -> @options {\n         jit: false,\n         output_type: link::output_type_exe,\n         addl_lib_search_paths: ~[],\n+        linker: None,\n+        linker_args: ~[],\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n         target_feature: ~\"\",\n@@ -434,10 +432,3 @@ mod test {\n         assert!(building_library(lib_crate, crate, true));\n     }\n }\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "2246dd9d2f0aa6d0688ae6d9c336c2ed708689be", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -194,11 +194,3 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n         })\n     })\n }\n-\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "0646afa1262833ac839f7acbfd4f3a11685b8af0", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -142,7 +142,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n     debug!(\"current path: %s\",\n            ast_util::path_name_i(copy cx.path, cx.sess.parse_sess.interner));\n \n-    if is_test_fn(i) || is_bench_fn(i) {\n+    if is_test_fn(cx, i) || is_bench_fn(i) {\n         match i.node {\n           ast::item_fn(_, purity, _, _, _) if purity == ast::unsafe_fn => {\n             let sess = cx.sess;\n@@ -170,7 +170,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n     return res;\n }\n \n-fn is_test_fn(i: @ast::item) -> bool {\n+fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = !attr::find_attrs_by_name(i.attrs,\n                                                   ~\"test\").is_empty();\n \n@@ -189,6 +189,13 @@ fn is_test_fn(i: @ast::item) -> bool {\n         }\n     }\n \n+    if has_test_attr && !has_test_signature(i) {\n+        let sess = cx.sess;\n+        sess.span_err(\n+            i.span,\n+            ~\"functions used as tests must have signature fn() -> ().\"\n+        );\n+    }\n     return has_test_attr && has_test_signature(i);\n }\n \n@@ -457,11 +464,3 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     );\n     e\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "fbb3380554d9e2ba6e5f2d8025ef77e456640a46", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -2196,13 +2196,3 @@ pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n         }\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "d2b71447f47782e9544e20a13f3f34d56e53d663", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -100,7 +100,6 @@ pub static tag_mod_impl_trait: uint = 0x47u;\n   different tags.\n  */\n pub static tag_item_impl_method: uint = 0x48u;\n-pub static tag_item_dtor: uint = 0x49u;\n pub static tag_item_trait_method_self_ty: uint = 0x4b;\n pub static tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n@@ -170,4 +169,3 @@ pub struct LinkMeta {\n     vers: @str,\n     extras_hash: @str\n }\n-"}, {"sha": "da7a2c15f30be8b6a4cb34e5b8be1394f7204dd9", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -328,11 +328,3 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     }\n     return @mut cnum_map;\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "375989b0ebe61c055d3714c95b385089a04e947c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -230,13 +230,6 @@ pub fn get_impl_method(cstore: @mut cstore::CStore,\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n-/* If def names a class with a dtor, return it. Otherwise, return none. */\n-pub fn struct_dtor(cstore: @mut cstore::CStore, def: ast::def_id)\n-    -> Option<ast::def_id> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::struct_dtor(cdata, def.node)\n-}\n-\n pub fn get_item_visibility(cstore: @mut cstore::CStore,\n                            def_id: ast::def_id)\n                         -> ast::visibility {\n@@ -250,11 +243,3 @@ pub fn get_link_args_for_crate(cstore: @mut cstore::CStore,\n     let cdata = cstore::get_crate_data(cstore, crate_num);\n     decoder::get_link_args_for_crate(cdata)\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "21815a9ed4718175bb44a3a373ca1a48872344d0", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -161,11 +161,3 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[~str] {\n \n     sorted.map(|ch| /*bad*/copy *ch.hash)\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "1e6bb397068446f4d12f5bc9a8899ca0ca41efe9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -274,7 +274,8 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n     reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        Decodable::decode(&reader::Decoder(*doc))\n+        let mut decoder = reader::Decoder(*doc);\n+        Decodable::decode(&mut decoder)\n     })\n }\n \n@@ -445,22 +446,6 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     found.get()\n }\n \n-pub fn struct_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n-    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n-    let mut found = None;\n-    let cls_items = match maybe_find_item(id, items) {\n-            Some(it) => it,\n-            None     => fail!(fmt!(\"struct_dtor: class id not found \\\n-              when looking up dtor for %d\", id))\n-    };\n-    for reader::tagged_docs(cls_items, tag_item_dtor) |doc| {\n-         let doc1 = reader::get_doc(doc, tag_def_id);\n-         let did = reader::with_doc_data(doc1, |d| parse_def_id(d));\n-         found = Some(translate_def_id(cdata, did));\n-    };\n-    found\n-}\n-\n pub fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n@@ -1192,11 +1177,3 @@ pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n     }\n     result\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "c337317314f66a97d2499fb5a3a7505e7af25180", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 142, "deletions": 144, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -43,7 +43,7 @@ use writer = std::ebml::writer;\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n-                                   ebml_w: &writer::Encoder,\n+                                   ebml_w: &mut writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n@@ -91,47 +91,54 @@ pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n-fn encode_name(ecx: @EncodeContext, ebml_w: &writer::Encoder, name: ident) {\n+fn encode_name(ecx: @EncodeContext,\n+               ebml_w: &mut writer::Encoder,\n+               name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+fn encode_impl_type_basename(ecx: @EncodeContext,\n+                             ebml_w: &mut writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          *ecx.tcx.sess.str_of(name));\n }\n \n-pub fn encode_def_id(ebml_w: &writer::Encoder, id: def_id) {\n+pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+fn encode_region_param(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n     for opt_rp.each |rp| {\n-        do ebml_w.wr_tag(tag_region_param) {\n-            rp.encode(ebml_w);\n-        }\n+        ebml_w.start_tag(tag_region_param);\n+        rp.encode(ebml_w);\n+        ebml_w.end_tag();\n     }\n }\n \n-fn encode_mutability(ebml_w: &writer::Encoder, mt: struct_mutability) {\n-    do ebml_w.wr_tag(tag_struct_mut) {\n-        let val = match mt {\n-          struct_immutable => 'a',\n-          struct_mutable => 'm'\n-        };\n-        ebml_w.writer.write(&[val as u8]);\n-    }\n+fn encode_mutability(ebml_w: &mut writer::Encoder, mt: struct_mutability) {\n+    ebml_w.start_tag(tag_struct_mut);\n+    let val = match mt {\n+      struct_immutable => 'a',\n+      struct_mutable => 'm'\n+    };\n+    ebml_w.writer.write(&[val as u8]);\n+    ebml_w.end_tag();\n }\n \n struct entry<T> {\n     val: T,\n     pos: uint\n }\n \n-fn add_to_index(ecx: @EncodeContext, ebml_w: &writer::Encoder, path: &[ident],\n-                index: &mut ~[entry<~str>], name: ident) {\n+fn add_to_index(ecx: @EncodeContext,\n+                ebml_w: &mut writer::Encoder,\n+                path: &[ident],\n+                index: &mut ~[entry<~str>],\n+                name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n     full_path.push(name);\n@@ -143,11 +150,10 @@ fn add_to_index(ecx: @EncodeContext, ebml_w: &writer::Encoder, path: &[ident],\n         });\n }\n \n-fn encode_trait_ref(ebml_w: &writer::Encoder,\n+fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n                     ecx: @EncodeContext,\n                     trait_ref: &ty::TraitRef,\n-                    tag: uint)\n-{\n+                    tag: uint) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -161,15 +167,17 @@ fn encode_trait_ref(ebml_w: &writer::Encoder,\n }\n \n // Item info table encoding\n-fn encode_family(ebml_w: &writer::Encoder, c: char) {\n+fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n-pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n+pub fn def_to_str(did: def_id) -> ~str {\n+    fmt!(\"%d:%d\", did.crate, did.node)\n+}\n \n-fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n+fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n                              ecx: @EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n                              tag: uint) {\n@@ -186,7 +194,7 @@ fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n+fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n@@ -195,14 +203,15 @@ fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n                               tag_items_data_item_ty_param_bounds);\n }\n \n-\n-fn encode_variant_id(ebml_w: &writer::Encoder, vid: def_id) {\n+fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n+pub fn write_type(ecx: @EncodeContext,\n+                  ebml_w: &mut writer::Encoder,\n+                  typ: ty::t) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -212,7 +221,8 @@ pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+pub fn write_vstore(ecx: @EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -223,16 +233,17 @@ pub fn write_vstore(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n+fn encode_type(ecx: @EncodeContext,\n+               ebml_w: &mut writer::Encoder,\n+               typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n fn encode_transformed_self_ty(ecx: @EncodeContext,\n-                              ebml_w: &writer::Encoder,\n-                              opt_typ: Option<ty::t>)\n-{\n+                              ebml_w: &mut writer::Encoder,\n+                              opt_typ: Option<ty::t>) {\n     for opt_typ.each |&typ| {\n         ebml_w.start_tag(tag_item_method_transformed_self_ty);\n         write_type(ecx, ebml_w, typ);\n@@ -241,9 +252,8 @@ fn encode_transformed_self_ty(ecx: @EncodeContext,\n }\n \n fn encode_method_fty(ecx: @EncodeContext,\n-                     ebml_w: &writer::Encoder,\n-                     typ: &ty::BareFnTy)\n-{\n+                     ebml_w: &mut writer::Encoder,\n+                     typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n     let ty_str_ctxt = @tyencode::ctxt {\n@@ -257,7 +267,9 @@ fn encode_method_fty(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n+fn encode_symbol(ecx: @EncodeContext,\n+                 ebml_w: &mut writer::Encoder,\n+                 id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n@@ -272,28 +284,32 @@ fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+fn encode_discriminant(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(*ecx.discrim_symbols.get_copy(&id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+fn encode_disr_val(_: @EncodeContext,\n+                   ebml_w: &mut writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: &writer::Encoder, id: def_id) {\n+fn encode_parent_item(ebml_w: &mut writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                            id: node_id, variants: &[variant],\n+fn encode_enum_variant_info(ecx: @EncodeContext,\n+                            ebml_w: &mut writer::Encoder,\n+                            id: node_id,\n+                            variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n                             generics: &ast::Generics) {\n@@ -333,9 +349,12 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     }\n }\n \n-fn encode_path(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-               path: &[ast_map::path_elt], name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+fn encode_path(ecx: @EncodeContext,\n+               ebml_w: &mut writer::Encoder,\n+               path: &[ast_map::path_elt],\n+               name: ast_map::path_elt) {\n+    fn encode_path_elt(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -345,17 +364,20 @@ fn encode_path(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n         ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n     }\n \n-    do ebml_w.wr_tag(tag_path) {\n-        ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-        for path.each |pe| {\n-            encode_path_elt(ecx, ebml_w, *pe);\n-        }\n-        encode_path_elt(ecx, ebml_w, name);\n+    ebml_w.start_tag(tag_path);\n+    ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n+    for path.each |pe| {\n+        encode_path_elt(ecx, ebml_w, *pe);\n     }\n+    encode_path_elt(ecx, ebml_w, name);\n+    ebml_w.end_tag();\n }\n \n-fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                       md: &_mod, id: node_id, path: &[ast_map::path_elt],\n+fn encode_info_for_mod(ecx: @EncodeContext,\n+                       ebml_w: &mut writer::Encoder,\n+                       md: &_mod,\n+                       id: node_id,\n+                       path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -412,7 +434,7 @@ fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: &writer::Encoder,\n+fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n                               visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n@@ -421,7 +443,7 @@ fn encode_struct_field_family(ebml_w: &writer::Encoder,\n     });\n }\n \n-fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n+fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n     ebml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         public => 'y',\n@@ -432,7 +454,7 @@ fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: &mut writer::Encoder, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -476,17 +498,19 @@ fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n     }\n }\n \n-fn encode_method_sort(ebml_w: &writer::Encoder, sort: char) {\n+fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                         path: &[ast_map::path_elt],\n-                         fields: &[@struct_field],\n-                         global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n+fn encode_info_for_struct(ecx: @EncodeContext,\n+                          ebml_w: &mut writer::Encoder,\n+                          path: &[ast_map::path_elt],\n+                          fields: &[@struct_field],\n+                          global_index: @mut ~[entry<int>])\n+                          -> ~[entry<int>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let index = @mut ~[];\n@@ -522,7 +546,7 @@ fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n \n // This is for encoding info for ctors and dtors\n fn encode_info_for_ctor(ecx: @EncodeContext,\n-                        ebml_w: &writer::Encoder,\n+                        ebml_w: &mut writer::Encoder,\n                         id: node_id,\n                         ident: ident,\n                         path: &[ast_map::path_elt],\n@@ -551,7 +575,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n }\n \n fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n-                               ebml_w: &writer::Encoder,\n+                               ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n                                ctor_id: node_id,\n@@ -573,9 +597,8 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n }\n \n fn encode_method_ty_fields(ecx: @EncodeContext,\n-                           ebml_w: &writer::Encoder,\n-                           method_ty: &ty::method)\n-{\n+                           ebml_w: &mut writer::Encoder,\n+                           method_ty: &ty::method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ecx, ebml_w, method_ty.ident);\n     encode_ty_type_param_defs(ebml_w, ecx,\n@@ -588,7 +611,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n }\n \n fn encode_info_for_method(ecx: @EncodeContext,\n-                          ebml_w: &writer::Encoder,\n+                          ebml_w: &mut writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n                           parent_id: node_id,\n@@ -658,11 +681,11 @@ fn should_inline(attrs: &[attribute]) -> bool {\n     }\n }\n \n-\n-fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                        item: @item, index: @mut ~[entry<int>],\n+fn encode_info_for_item(ecx: @EncodeContext,\n+                        ebml_w: &mut writer::Encoder,\n+                        item: @item,\n+                        index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n-\n     let tcx = ecx.tcx;\n     let must_write =\n         match item.node {\n@@ -737,19 +760,21 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n       }\n       item_enum(ref enum_definition, ref generics) => {\n         add_to_index();\n-        do ebml_w.wr_tag(tag_items_data_item) {\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-            encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-            encode_name(ecx, ebml_w, item.ident);\n-            for (*enum_definition).variants.each |v| {\n-                encode_variant_id(ebml_w, local_def(v.node.id));\n-            }\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n-            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-            encode_region_param(ecx, ebml_w, item);\n+\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 't');\n+        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n+        for (*enum_definition).variants.each |v| {\n+            encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ecx, ebml_w, item);\n+        ebml_w.end_tag();\n+\n         encode_enum_variant_info(ecx,\n                                  ebml_w,\n                                  item.id,\n@@ -765,26 +790,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n            class itself */\n         let idx = encode_info_for_struct(ecx, ebml_w, path,\n                                          struct_def.fields, index);\n-        /* Encode the dtor */\n-        for struct_def.dtor.each |dtor| {\n-            index.push(entry {val: dtor.node.id, pos: ebml_w.writer.tell()});\n-          encode_info_for_ctor(ecx,\n-                               ebml_w,\n-                               dtor.node.id,\n-                               ecx.tcx.sess.ident_of(\n-                                   *ecx.tcx.sess.str_of(item.ident) +\n-                                   ~\"_dtor\"),\n-                               path,\n-                               if generics.ty_params.len() > 0u {\n-                                   Some(ii_dtor(copy *dtor,\n-                                                item.ident,\n-                                                copy *generics,\n-                                                local_def(item.id))) }\n-                               else {\n-                                   None\n-                               },\n-                               generics);\n-        }\n \n         /* Index the class*/\n         add_to_index();\n@@ -816,13 +821,6 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n-        /* Encode the dtor */\n-        /* Encode id for dtor */\n-        for struct_def.dtor.each |dtor| {\n-            do ebml_w.wr_tag(tag_item_dtor) {\n-                encode_def_id(ebml_w, local_def(dtor.node.id));\n-            }\n-        };\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n@@ -988,7 +986,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n }\n \n fn encode_info_for_foreign_item(ecx: @EncodeContext,\n-                                ebml_w: &writer::Encoder,\n+                                ebml_w: &mut writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path,\n@@ -1021,8 +1019,10 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n-                         crate: &crate) -> ~[entry<int>] {\n+fn encode_info_for_items(ecx: @EncodeContext,\n+                         ebml_w: &mut writer::Encoder,\n+                         crate: &crate)\n+                         -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n@@ -1037,8 +1037,8 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                 visit::visit_item(i, cx, v);\n                 match ecx.tcx.items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n-                        encode_info_for_item(ecx, &ebml_w, i,\n-                                             index, *pt);\n+                        let mut ebml_w = copy ebml_w;\n+                        encode_info_for_item(ecx, &mut ebml_w, i, index, *pt);\n                     }\n                     _ => fail!(~\"bad item\")\n                 }\n@@ -1050,8 +1050,12 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                 visit::visit_foreign_item(ni, cx, v);\n                 match ecx.tcx.items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n-                        encode_info_for_foreign_item(ecx, &ebml_w, ni,\n-                                                     index, /*bad*/copy *pt,\n+                        let mut ebml_w = copy ebml_w;\n+                        encode_info_for_foreign_item(ecx,\n+                                                     &mut ebml_w,\n+                                                     ni,\n+                                                     index,\n+                                                     /*bad*/copy *pt,\n                                                      abi);\n                     }\n                     // case for separate item and foreign-item tables\n@@ -1084,7 +1088,8 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: &writer::Encoder, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: &mut writer::Encoder,\n+                   buckets: ~[@~[entry<T>]],\n                    write_fn: &fn(@io::Writer, &T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -1112,14 +1117,16 @@ fn encode_index<T>(ebml_w: &writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @io::Writer, s: ~str) { writer.write_str(s); }\n+fn write_str(writer: @io::Writer, s: ~str) {\n+    writer.write_str(s);\n+}\n \n fn write_int(writer: @io::Writer, &n: &int) {\n     assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n+fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -1156,7 +1163,7 @@ fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: &writer::Encoder, attrs: &[attribute]) {\n+fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1221,7 +1228,7 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n }\n \n fn encode_crate_deps(ecx: @EncodeContext,\n-                     ebml_w: &writer::Encoder,\n+                     ebml_w: &mut writer::Encoder,\n                      cstore: @mut cstore::CStore) {\n     fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n                      -> ~[decoder::crate_dep] {\n@@ -1262,7 +1269,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n+fn encode_lang_items(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for ecx.tcx.lang_items.each_item |def_id, i| {\n@@ -1286,8 +1293,7 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_link_args(ecx: @EncodeContext,\n-                    ebml_w: &writer::Encoder) {\n+fn encode_link_args(ecx: @EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n@@ -1300,7 +1306,8 @@ fn encode_link_args(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n+fn encode_crate_dep(ecx: @EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1315,7 +1322,7 @@ fn encode_crate_dep(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: &writer::Encoder, hash: &str) {\n+fn encode_hash(ebml_w: &mut writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1360,38 +1367,38 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         type_abbrevs: @mut HashMap::new()\n      };\n \n-    let ebml_w = writer::Encoder(wr as @io::Writer);\n+    let mut ebml_w = writer::Encoder(wr as @io::Writer);\n \n-    encode_hash(&ebml_w, ecx.link_meta.extras_hash);\n+    encode_hash(&mut ebml_w, ecx.link_meta.extras_hash);\n \n     let mut i = wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n-    encode_attributes(&ebml_w, crate_attrs);\n+    encode_attributes(&mut ebml_w, crate_attrs);\n     ecx.stats.attr_bytes = wr.pos - i;\n \n     i = wr.pos;\n-    encode_crate_deps(ecx, &ebml_w, ecx.cstore);\n+    encode_crate_deps(ecx, &mut ebml_w, ecx.cstore);\n     ecx.stats.dep_bytes = wr.pos - i;\n \n     // Encode the language items.\n     i = wr.pos;\n-    encode_lang_items(ecx, &ebml_w);\n+    encode_lang_items(ecx, &mut ebml_w);\n     ecx.stats.lang_item_bytes = wr.pos - i;\n \n     // Encode the link args.\n     i = wr.pos;\n-    encode_link_args(ecx, &ebml_w);\n+    encode_link_args(ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = wr.pos;\n-    let items_index = encode_info_for_items(ecx, &ebml_w, crate);\n+    let items_index = encode_info_for_items(ecx, &mut ebml_w, crate);\n     ecx.stats.item_bytes = wr.pos - i;\n \n     i = wr.pos;\n     let items_buckets = create_index(items_index);\n-    encode_index(&ebml_w, items_buckets, write_int);\n+    encode_index(&mut ebml_w, items_buckets, write_int);\n     ecx.stats.index_bytes = wr.pos - i;\n     ebml_w.end_tag();\n \n@@ -1447,12 +1454,3 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         tyencode::enc_ty(wr, cx, t);\n     }\n }\n-\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "7547f7f763af003635aa22c3b102a5d76e187f8e", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -20,41 +20,48 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n }\n \n pub trait FileSearch {\n-    fn sysroot(&self) -> Path;\n-    fn lib_search_paths(&self) -> ~[Path];\n+    fn sysroot(&self) -> @Path;\n+    fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool);\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n \n-pub fn mk_filesearch(maybe_sysroot: &Option<Path>,\n+pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                      target_triple: &str,\n                      addl_lib_search_paths: ~[Path])\n                   -> @FileSearch {\n     struct FileSearchImpl {\n-        sysroot: Path,\n+        sysroot: @Path,\n         addl_lib_search_paths: ~[Path],\n         target_triple: ~str\n     }\n     impl FileSearch for FileSearchImpl {\n-        fn sysroot(&self) -> Path { /*bad*/copy self.sysroot }\n-        fn lib_search_paths(&self) -> ~[Path] {\n-            let mut paths = /*bad*/copy self.addl_lib_search_paths;\n-\n-            paths.push(\n-                make_target_lib_path(&self.sysroot,\n-                                     self.target_triple));\n-            match get_rustpkg_lib_path_nearest() {\n-              result::Ok(ref p) => paths.push((/*bad*/copy *p)),\n-              result::Err(_) => ()\n+        fn sysroot(&self) -> @Path { self.sysroot }\n+        fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) {\n+            debug!(\"filesearch: searching additional lib search paths\");\n+            // a little weird\n+            self.addl_lib_search_paths.each(f);\n+\n+            debug!(\"filesearch: searching target lib path\");\n+            if !f(&make_target_lib_path(self.sysroot,\n+                                        self.target_triple)) {\n+                return;\n             }\n-            match get_rustpkg_lib_path() {\n-              result::Ok(ref p) => paths.push((/*bad*/copy *p)),\n-              result::Err(_) => ()\n-            }\n-            paths\n+            debug!(\"filesearch: searching rustpkg lib path nearest\");\n+            if match get_rustpkg_lib_path_nearest() {\n+                    result::Ok(ref p) => f(p),\n+                    result::Err(_) => true\n+                } {\n+                    return;\n+                }\n+           debug!(\"filesearch: searching rustpkg lib path\");\n+           match get_rustpkg_lib_path() {\n+              result::Ok(ref p) => f(p),\n+              result::Err(_) => true\n+           };\n         }\n         fn get_target_lib_path(&self) -> Path {\n-            make_target_lib_path(&self.sysroot, self.target_triple)\n+            make_target_lib_path(self.sysroot, self.target_triple)\n         }\n         fn get_target_lib_file_path(&self, file: &Path) -> Path {\n             self.get_target_lib_path().push_rel(file)\n@@ -72,7 +79,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<Path>,\n \n pub fn search<T:Copy>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n-    for filesearch.lib_search_paths().each |lib_search_path| {\n+    for filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n         for os::list_dir_path(lib_search_path).each |path| {\n             debug!(\"testing %s\", path.to_str());\n@@ -108,10 +115,10 @@ fn get_or_default_sysroot() -> Path {\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: &Option<Path>) -> Path {\n+fn get_sysroot(maybe_sysroot: &Option<@Path>) -> @Path {\n     match *maybe_sysroot {\n-      option::Some(ref sr) => (/*bad*/copy *sr),\n-      option::None => get_or_default_sysroot()\n+      option::Some(sr) => sr,\n+      option::None => @get_or_default_sysroot()\n     }\n }\n "}, {"sha": "193f6fc8f0a3ba616e6cdd11caa0f3a2ee3f5adf", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -196,7 +196,7 @@ fn get_metadata_section(os: os,\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = unsafe { str::raw::from_c_str(name_buf) };\n-            debug!(\"get_matadata_section: name %s\", name);\n+            debug!(\"get_metadata_section: name %s\", name);\n             if name == read_meta_section_name(os) {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;"}, {"sha": "24007380feec1b42ace8ec8bb7630bface2f513c", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,4 +18,3 @@ pub mod cstore;\n pub mod csearch;\n pub mod loader;\n pub mod filesearch;\n-"}, {"sha": "02acafbd980993b6511e6ebb56f6a10ffd06217b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -570,13 +570,3 @@ fn parse_bounds(st: @mut PState, conv: conv_did) -> @~[ty::param_bound] {\n     }\n     @bounds\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "c44a8e74130fdecc966d7b305b7b7419c5e4ac75", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -418,13 +418,3 @@ pub fn enc_type_param_def(w: @io::Writer, cx: @ctxt, v: &ty::TypeParameterDef) {\n     w.write_char('|');\n     enc_bounds(w, cx, v.bounds);\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "f3eac7995e8a1444dca0258a2c5f999c04d588c0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 239, "deletions": 233, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -76,7 +76,7 @@ trait tr_intern {\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: @e::EncodeContext,\n-                           ebml_w: &writer::Encoder,\n+                           ebml_w: &mut writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n@@ -86,11 +86,12 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n            ebml_w.writer.tell());\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n-    do ebml_w.wr_tag(c::tag_ast as uint) {\n-        id_range.encode(ebml_w);\n-        encode_ast(ebml_w, simplify_ast(&ii));\n-        encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n-    }\n+\n+    ebml_w.start_tag(c::tag_ast as uint);\n+    id_range.encode(ebml_w);\n+    encode_ast(ebml_w, simplify_ast(&ii));\n+    encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n+    ebml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n@@ -114,8 +115,8 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = &reader::Decoder(ast_doc);\n-        let from_id_range = Decodable::decode(ast_dsr);\n+        let mut ast_dsr = reader::Decoder(ast_doc);\n+        let from_id_range = Decodable::decode(&mut ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = @ExtendedDecodeContext {\n             dcx: dcx,\n@@ -232,22 +233,21 @@ impl tr for span {\n }\n \n trait def_id_encoder_helpers {\n-    fn emit_def_id(&self, did: ast::def_id);\n+    fn emit_def_id(&mut self, did: ast::def_id);\n }\n \n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n-    fn emit_def_id(&self, did: ast::def_id) {\n+    fn emit_def_id(&mut self, did: ast::def_id) {\n         did.encode(self)\n     }\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n+    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n-\n-    fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n         let did: ast::def_id = Decodable::decode(self);\n         did.tr(xcx)\n     }\n@@ -268,10 +268,10 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: &writer::Encoder, item: ast::inlined_item) {\n-    do ebml_w.wr_tag(c::tag_tree as uint) {\n-        item.encode(ebml_w)\n-    }\n+fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n+    ebml_w.start_tag(c::tag_tree as uint);\n+    item.encode(ebml_w);\n+    ebml_w.end_tag();\n }\n \n // Produces a simplified copy of the AST which does not include things\n@@ -322,22 +322,13 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n-        let dtor_body = fld.fold_block(&dtor.node.body);\n-        ast::ii_dtor(\n-            codemap::spanned {\n-                node: ast::struct_dtor_ { body: dtor_body,\n-                                          .. /*bad*/copy (*dtor).node },\n-                .. (/*bad*/copy *dtor) },\n-            nm, /*bad*/copy *tps, parent_id)\n-      }\n     }\n }\n \n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n-    let d = &reader::Decoder(chi_doc);\n-    Decodable::decode(d)\n+    let mut d = reader::Decoder(chi_doc);\n+    Decodable::decode(&mut d)\n }\n \n fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n@@ -358,36 +349,19 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n       ast::ii_foreign(i) => {\n         ast::ii_foreign(fld.fold_foreign_item(i))\n       }\n-      ast::ii_dtor(ref dtor, nm, ref generics, parent_id) => {\n-        let dtor_body = fld.fold_block(&dtor.node.body);\n-        let dtor_attrs = fld.fold_attributes(/*bad*/copy (*dtor).node.attrs);\n-        let new_generics = fold::fold_generics(generics, fld);\n-        let dtor_id = fld.new_id((*dtor).node.id);\n-        let new_parent = xcx.tr_def_id(parent_id);\n-        let new_self = fld.new_id((*dtor).node.self_id);\n-        ast::ii_dtor(\n-            codemap::spanned {\n-                node: ast::struct_dtor_ { id: dtor_id,\n-                                          attrs: dtor_attrs,\n-                                          self_id: new_self,\n-                                          body: dtor_body },\n-                .. (/*bad*/copy *dtor)\n-            },\n-            nm, new_generics, new_parent)\n-      }\n      }\n }\n \n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: &writer::Encoder, def: ast::def) {\n+fn encode_def(ebml_w: &mut writer::Encoder, def: ast::def) {\n     def.encode(ebml_w)\n }\n \n fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n-    let dsr = &reader::Decoder(doc);\n-    let def: ast::def = Decodable::decode(dsr);\n+    let mut dsr = reader::Decoder(doc);\n+    let def: ast::def = Decodable::decode(&mut dsr);\n     def.tr(xcx)\n }\n \n@@ -488,18 +462,18 @@ impl tr for ty::bound_region {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: &writer::Encoder, fv: @freevar_entry) {\n+fn encode_freevar_entry(ebml_w: &mut writer::Encoder, fv: @freevar_entry) {\n     (*fv).encode(ebml_w)\n }\n \n trait ebml_decoder_helper {\n-    fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n-                         -> freevar_entry;\n+    fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                          -> freevar_entry;\n }\n \n impl ebml_decoder_helper for reader::Decoder {\n-    fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n-                         -> freevar_entry {\n+    fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                          -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self);\n         fv.tr(xcx)\n     }\n@@ -518,13 +492,13 @@ impl tr for freevar_entry {\n // Encoding and decoding of CaptureVar information\n \n trait capture_var_helper {\n-    fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n-                       -> moves::CaptureVar;\n+    fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n+                        -> moves::CaptureVar;\n }\n \n impl capture_var_helper for reader::Decoder {\n-    fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n-                       -> moves::CaptureVar {\n+    fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n+                        -> moves::CaptureVar {\n         let cvar: moves::CaptureVar = Decodable::decode(self);\n         cvar.tr(xcx)\n     }\n@@ -544,48 +518,50 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of method_map_entry\n \n trait read_method_map_entry_helper {\n-    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-                            -> method_map_entry;\n+    fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                             -> method_map_entry;\n }\n \n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: &writer::Encoder,\n-                              mme: method_map_entry) {\n-    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n-        do ebml_w.emit_struct_field(\"self_arg\", 0u) {\n+                           ebml_w: &mut writer::Encoder,\n+                           mme: method_map_entry) {\n+    do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n+        do ebml_w.emit_struct_field(\"self_arg\", 0u) |ebml_w| {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n-        do ebml_w.emit_struct_field(\"explicit_self\", 2u) {\n+        do ebml_w.emit_struct_field(\"explicit_self\", 2u) |ebml_w| {\n             mme.explicit_self.encode(ebml_w);\n         }\n-        do ebml_w.emit_struct_field(\"origin\", 1u) {\n+        do ebml_w.emit_struct_field(\"origin\", 1u) |ebml_w| {\n             mme.origin.encode(ebml_w);\n         }\n-        do ebml_w.emit_struct_field(\"self_mode\", 3) {\n+        do ebml_w.emit_struct_field(\"self_mode\", 3) |ebml_w| {\n             mme.self_mode.encode(ebml_w);\n         }\n     }\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n-    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n-        -> method_map_entry {\n-        do self.read_struct(\"method_map_entry\", 3) {\n+    fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n+                             -> method_map_entry {\n+        do self.read_struct(\"method_map_entry\", 3) |this| {\n             method_map_entry {\n-                self_arg: self.read_struct_field(\"self_arg\", 0u, || {\n-                    self.read_arg(xcx)\n+                self_arg: this.read_struct_field(\"self_arg\", 0, |this| {\n+                    this.read_arg(xcx)\n                 }),\n-                explicit_self: self.read_struct_field(\"explicit_self\", 2, || {\n-                    let self_type: ast::self_ty_ = Decodable::decode(self);\n+                explicit_self: this.read_struct_field(\"explicit_self\",\n+                                                      2,\n+                                                      |this| {\n+                    let self_type: ast::self_ty_ = Decodable::decode(this);\n                     self_type\n                 }),\n-                origin: self.read_struct_field(\"origin\", 1u, || {\n+                origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: method_origin =\n-                        Decodable::decode(self);\n+                        Decodable::decode(this);\n                     method_origin.tr(xcx)\n                 }),\n-                self_mode: self.read_struct_field(\"self_mode\", 3, || {\n-                    let self_mode: ty::SelfMode = Decodable::decode(self);\n+                self_mode: this.read_struct_field(\"self_mode\", 3, |this| {\n+                    let self_mode: ty::SelfMode = Decodable::decode(this);\n                     self_mode\n                 }),\n             }\n@@ -624,88 +600,88 @@ impl tr for method_origin {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::EncodeContext,\n-                     ebml_w: &writer::Encoder,\n+                     ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n+    do ebml_w.emit_from_vec(*dr) |ebml_w, vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::EncodeContext,\n-                        ebml_w: &writer::Encoder,\n+                        ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    do ebml_w.emit_enum(~\"vtable_origin\") {\n+    do ebml_w.emit_enum(~\"vtable_origin\") |ebml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n-                do ebml_w.emit_enum_variant_arg(0u) {\n+            do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) |ebml_w| {\n+                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n                     ebml_w.emit_def_id(def_id)\n                 }\n-                do ebml_w.emit_enum_variant_arg(1u) {\n+                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n                     ebml_w.emit_tys(ecx, /*bad*/copy *tys);\n                 }\n-                do ebml_w.emit_enum_variant_arg(2u) {\n+                do ebml_w.emit_enum_variant_arg(2u) |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n                 }\n             }\n           }\n           typeck::vtable_param(pn, bn) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_param\", 1u, 2u) {\n-                do ebml_w.emit_enum_variant_arg(0u) {\n+            do ebml_w.emit_enum_variant(~\"vtable_param\", 1u, 2u) |ebml_w| {\n+                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n                     ebml_w.emit_uint(pn);\n                 }\n-                do ebml_w.emit_enum_variant_arg(1u) {\n+                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n                     ebml_w.emit_uint(bn);\n                 }\n             }\n           }\n         }\n     }\n-\n }\n \n trait vtable_decoder_helpers {\n-    fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n+    fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res;\n-    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n-        -> typeck::vtable_origin;\n+    fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n+                          -> typeck::vtable_origin;\n }\n \n impl vtable_decoder_helpers for reader::Decoder {\n-    fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n+    fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n+        @self.read_to_vec(|this| this.read_vtable_origin(xcx))\n     }\n \n-    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n+    fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n-        do self.read_enum(\"vtable_origin\") {\n-            do self.read_enum_variant([\"vtable_static\", \"vtable_param\"]) |i| {\n+        do self.read_enum(\"vtable_origin\") |this| {\n+            do this.read_enum_variant([\"vtable_static\", \"vtable_param\"])\n+                    |this, i| {\n                 match i {\n                   0 => {\n                     typeck::vtable_static(\n-                        do self.read_enum_variant_arg(0u) {\n-                            self.read_def_id(xcx)\n+                        do this.read_enum_variant_arg(0u) |this| {\n+                            this.read_def_id(xcx)\n                         },\n-                        do self.read_enum_variant_arg(1u) {\n-                            self.read_tys(xcx)\n+                        do this.read_enum_variant_arg(1u) |this| {\n+                            this.read_tys(xcx)\n                         },\n-                        do self.read_enum_variant_arg(2u) {\n-                            self.read_vtable_res(xcx)\n+                        do this.read_enum_variant_arg(2u) |this| {\n+                            this.read_vtable_res(xcx)\n                         }\n                     )\n                   }\n                   1 => {\n                     typeck::vtable_param(\n-                        do self.read_enum_variant_arg(0u) {\n-                            self.read_uint()\n+                        do this.read_enum_variant_arg(0u) |this| {\n+                            this.read_uint()\n                         },\n-                        do self.read_enum_variant_arg(1u) {\n-                            self.read_uint()\n+                        do this.read_enum_variant_arg(1u) |this| {\n+                            this.read_uint()\n                         }\n                     )\n                   }\n@@ -736,148 +712,154 @@ impl get_ty_str_ctxt for e::EncodeContext {\n }\n \n trait ebml_writer_helpers {\n-    fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg);\n-    fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t);\n-    fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore);\n-    fn emit_tys(&self, ecx: @e::EncodeContext, tys: &[ty::t]);\n-    fn emit_type_param_def(&self,\n+    fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg);\n+    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t);\n+    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore);\n+    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]);\n+    fn emit_type_param_def(&mut self,\n                            ecx: @e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n-    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+    fn emit_tpbt(&mut self,\n+                 ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty);\n }\n \n impl ebml_writer_helpers for writer::Encoder {\n-    fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t) {\n-        do self.emit_opaque {\n-            e::write_type(ecx, self, ty)\n+    fn emit_ty(&mut self, ecx: @e::EncodeContext, ty: ty::t) {\n+        do self.emit_opaque |this| {\n+            e::write_type(ecx, this, ty)\n         }\n     }\n \n-    fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n-        do self.emit_opaque {\n-            e::write_vstore(ecx, self, vstore)\n+    fn emit_vstore(&mut self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n+        do self.emit_opaque |this| {\n+            e::write_vstore(ecx, this, vstore)\n         }\n     }\n \n-    fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg) {\n-        do self.emit_opaque {\n-            tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);\n+    fn emit_arg(&mut self, ecx: @e::EncodeContext, arg: ty::arg) {\n+        do self.emit_opaque |this| {\n+            tyencode::enc_arg(this.writer, ecx.ty_str_ctxt(), arg);\n         }\n     }\n \n-    fn emit_tys(&self, ecx: @e::EncodeContext, tys: &[ty::t]) {\n-        do self.emit_from_vec(tys) |ty| {\n-            self.emit_ty(ecx, *ty)\n+    fn emit_tys(&mut self, ecx: @e::EncodeContext, tys: &[ty::t]) {\n+        do self.emit_from_vec(tys) |this, ty| {\n+            this.emit_ty(ecx, *ty)\n         }\n     }\n \n-    fn emit_type_param_def(&self,\n+    fn emit_type_param_def(&mut self,\n                            ecx: @e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n-        do self.emit_opaque {\n-            tyencode::enc_type_param_def(self.writer, ecx.ty_str_ctxt(),\n+        do self.emit_opaque |this| {\n+            tyencode::enc_type_param_def(this.writer,\n+                                         ecx.ty_str_ctxt(),\n                                          type_param_def)\n         }\n     }\n \n-    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+    fn emit_tpbt(&mut self,\n+                 ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n-            do self.emit_struct_field(\"generics\", 0) {\n-                do self.emit_struct(\"Generics\", 2) {\n-                    do self.emit_struct_field(\"type_param_defs\", 0) {\n-                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n-                            |type_param_def|\n-                        {\n-                            self.emit_type_param_def(ecx, type_param_def);\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n+            do this.emit_struct_field(~\"generics\", 0) |this| {\n+                do this.emit_struct(\"Generics\", 2) |this| {\n+                    do this.emit_struct_field(~\"type_param_defs\", 0) |this| {\n+                        do this.emit_from_vec(*tpbt.generics.type_param_defs)\n+                                |this, type_param_def| {\n+                            this.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n-                    do self.emit_struct_field(\"region_param\", 1) {\n-                        tpbt.generics.region_param.encode(self);\n+                    do this.emit_struct_field(~\"region_param\", 1) |this| {\n+                        tpbt.generics.region_param.encode(this);\n                     }\n                 }\n             }\n-            do self.emit_struct_field(\"ty\", 1) {\n-                self.emit_ty(ecx, tpbt.ty);\n+            do this.emit_struct_field(~\"ty\", 1) |this| {\n+                this.emit_ty(ecx, tpbt.ty);\n             }\n         }\n     }\n }\n \n trait write_tag_and_id {\n-    fn tag(&self, tag_id: c::astencode_tag, f: &fn());\n-    fn id(&self, id: ast::node_id);\n+    fn tag(&mut self, tag_id: c::astencode_tag, f: &fn(&mut Self));\n+    fn id(&mut self, id: ast::node_id);\n }\n \n impl write_tag_and_id for writer::Encoder {\n-    fn tag(&self, tag_id: c::astencode_tag, f: &fn()) {\n-        do self.wr_tag(tag_id as uint) { f() }\n+    fn tag(&mut self,\n+           tag_id: c::astencode_tag,\n+           f: &fn(&mut writer::Encoder)) {\n+        self.start_tag(tag_id as uint);\n+        f(self);\n+        self.end_tag();\n     }\n \n-    fn id(&self, id: ast::node_id) {\n+    fn id(&mut self, id: ast::node_id) {\n         self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n     }\n }\n \n fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n                              maps: Maps,\n-                             ebml_w: &writer::Encoder,\n+                             ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n-    do ebml_w.wr_tag(c::tag_table as uint) {\n-        let ebml_w = copy *ebml_w;\n-        ast_util::visit_ids_for_inlined_item(\n-            ii,\n-            |id: ast::node_id| {\n-                // Note: this will cause a copy of ebml_w, which is bad as\n-                // it has mut fields.  But I believe it's harmless since\n-                // we generate balanced EBML.\n-                /*let ebml_w = copy ebml_w;*/\n-                encode_side_tables_for_id(ecx, maps, &ebml_w, id)\n-            });\n-    }\n+    ebml_w.start_tag(c::tag_table as uint);\n+    let new_ebml_w = copy *ebml_w;\n+    ast_util::visit_ids_for_inlined_item(\n+        ii,\n+        |id: ast::node_id| {\n+            // Note: this will cause a copy of ebml_w, which is bad as\n+            // it is mutable. But I believe it's harmless since we generate\n+            // balanced EBML.\n+            let mut new_ebml_w = copy new_ebml_w;\n+            encode_side_tables_for_id(ecx, maps, &mut new_ebml_w, id)\n+        });\n+    ebml_w.end_tag();\n }\n \n fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n                              maps: Maps,\n-                             ebml_w: &writer::Encoder,\n+                             ebml_w: &mut writer::Encoder,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id %d\", id);\n \n     for tcx.def_map.find(&id).each |def| {\n-        do ebml_w.tag(c::tag_table_def) {\n+        do ebml_w.tag(c::tag_table_def) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 (*def).encode(ebml_w)\n             }\n         }\n     }\n \n     for tcx.node_types.find(&(id as uint)).each |&ty| {\n-        do ebml_w.tag(c::tag_table_node_type) {\n+        do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 ebml_w.emit_ty(ecx, *ty);\n             }\n         }\n     }\n \n     for tcx.node_type_substs.find(&id).each |tys| {\n-        do ebml_w.tag(c::tag_table_node_type_subst) {\n+        do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 ebml_w.emit_tys(ecx, **tys)\n             }\n         }\n     }\n \n     for tcx.freevars.find(&id).each |&fv| {\n-        do ebml_w.tag(c::tag_table_freevars) {\n+        do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(**fv) |fv_entry| {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n                     encode_freevar_entry(ebml_w, *fv_entry)\n                 }\n             }\n@@ -886,61 +868,61 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n \n     let lid = ast::def_id { crate: ast::local_crate, node: id };\n     for tcx.tcache.find(&lid).each |&tpbt| {\n-        do ebml_w.tag(c::tag_table_tcache) {\n+        do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 ebml_w.emit_tpbt(ecx, *tpbt);\n             }\n         }\n     }\n \n     for tcx.ty_param_defs.find(&id).each |&type_param_def| {\n-        do ebml_w.tag(c::tag_table_param_defs) {\n+        do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 ebml_w.emit_type_param_def(ecx, type_param_def)\n             }\n         }\n     }\n \n     for maps.method_map.find(&id).each |&mme| {\n-        do ebml_w.tag(c::tag_table_method_map) {\n+        do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 encode_method_map_entry(ecx, ebml_w, *mme)\n             }\n         }\n     }\n \n     for maps.vtable_map.find(&id).each |&dr| {\n-        do ebml_w.tag(c::tag_table_vtable_map) {\n+        do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 encode_vtable_res(ecx, ebml_w, *dr);\n             }\n         }\n     }\n \n     for tcx.adjustments.find(&id).each |adj| {\n-        do ebml_w.tag(c::tag_table_adjustments) {\n+        do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n                 (**adj).encode(ebml_w)\n             }\n         }\n     }\n \n     if maps.moves_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_moves_map) {\n+        do ebml_w.tag(c::tag_table_moves_map) |ebml_w| {\n             ebml_w.id(id);\n         }\n     }\n \n     for maps.capture_map.find(&id).each |&cap_vars| {\n-        do ebml_w.tag(c::tag_table_capture_map) {\n+        do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n             ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec(*cap_vars) |cap_var| {\n+            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n                     cap_var.encode(ebml_w);\n                 }\n             }\n@@ -961,40 +943,49 @@ impl doc_decoder_helpers for ebml::Doc {\n }\n \n trait ebml_decoder_decoder_helpers {\n-    fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg;\n-    fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n-    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext) -> ty::TypeParameterDef;\n-    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n+    fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg;\n+    fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n+    fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n+                           -> ty::TypeParameterDef;\n+    fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n-    fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n+    fn convert_def_id(&mut self,\n+                      xcx: @ExtendedDecodeContext,\n                       source: DefIdSource,\n-                      did: ast::def_id) -> ast::def_id;\n+                      did: ast::def_id)\n+                      -> ast::def_id;\n }\n \n impl ebml_decoder_decoder_helpers for reader::Decoder {\n-    fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg {\n-        do self.read_opaque |doc| {\n+    fn read_arg(&mut self, xcx: @ExtendedDecodeContext) -> ty::arg {\n+        do self.read_opaque |this, doc| {\n             tydecode::parse_arg_data(\n-                doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a))\n+                doc.data,\n+                xcx.dcx.cdata.cnum,\n+                doc.start,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a))\n         }\n     }\n \n-    fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t {\n+    fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        return do self.read_opaque |doc| {\n-\n+        return do self.read_opaque |this, doc| {\n             let ty = tydecode::parse_ty_data(\n-                doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a));\n+                doc.data,\n+                xcx.dcx.cdata.cnum,\n+                doc.start,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a));\n \n             debug!(\"read_ty(%s) = %s\",\n-                   type_string(doc), ty_to_str(xcx.dcx.tcx, ty));\n+                   type_string(doc),\n+                   ty_to_str(xcx.dcx.tcx, ty));\n \n             ty\n         };\n@@ -1008,43 +999,57 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n-        self.read_to_vec(|| self.read_ty(xcx) )\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n+        self.read_to_vec(|this| this.read_ty(xcx) )\n     }\n \n-    fn read_type_param_def(&self, xcx: @ExtendedDecodeContext) -> ty::TypeParameterDef {\n-        do self.read_opaque |doc| {\n+    fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n+                           -> ty::TypeParameterDef {\n+        do self.read_opaque |this, doc| {\n             tydecode::parse_type_param_def_data(\n-                doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a))\n+                doc.data,\n+                doc.start,\n+                xcx.dcx.cdata.cnum,\n+                xcx.dcx.tcx,\n+                |s, a| this.convert_def_id(xcx, s, a))\n         }\n     }\n \n-    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n-        -> ty::ty_param_bounds_and_ty\n-    {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n+    fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n+                                   -> ty::ty_param_bounds_and_ty {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n             ty::ty_param_bounds_and_ty {\n-                generics: do self.read_struct(\"Generics\", 2) {\n-                    ty::Generics {\n-                        type_param_defs: self.read_struct_field(\"type_param_defs\", 0, || {\n-                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n-                        }),\n-                        region_param: self.read_struct_field(~\"region_param\", 1, || {\n-                            Decodable::decode(self)\n-                        })\n+                generics: do this.read_struct_field(\"generics\", 0) |this| {\n+                    do this.read_struct(\"Generics\", 2) |this| {\n+                        ty::Generics {\n+                            type_param_defs:\n+                                this.read_struct_field(\"type_param_defs\",\n+                                                       0,\n+                                                       |this| {\n+                                    @this.read_to_vec(|this|\n+                                        this.read_type_param_def(xcx))\n+                            }),\n+                            region_param:\n+                                this.read_struct_field(\"region_param\",\n+                                                       1,\n+                                                       |this| {\n+                                    Decodable::decode(this)\n+                                })\n+                        }\n                     }\n                 },\n-                ty: self.read_struct_field(\"ty\", 1, || {\n-                    self.read_ty(xcx)\n+                ty: this.read_struct_field(\"ty\", 1, |this| {\n+                    this.read_ty(xcx)\n                 })\n             }\n         }\n     }\n \n-    fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n+    fn convert_def_id(&mut self,\n+                      xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n-                      did: ast::def_id) -> ast::def_id {\n+                      did: ast::def_id)\n+                      -> ast::def_id {\n         /*!\n          *\n          * Converts a def-id that appears in a type.  The correct\n@@ -1084,7 +1089,8 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n             dcx.maps.moves_map.insert(id);\n         } else {\n             let val_doc = entry_doc.get(c::tag_table_val as uint);\n-            let val_dsr = &reader::Decoder(val_doc);\n+            let mut val_dsr = reader::Decoder(val_doc);\n+            let val_dsr = &mut val_dsr;\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -1097,7 +1103,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 let tys = val_dsr.read_tys(xcx);\n                 dcx.tcx.node_type_substs.insert(id, tys);\n             } else if tag == (c::tag_table_freevars as uint) {\n-                let fv_info = @val_dsr.read_to_vec(|| {\n+                let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n                     @val_dsr.read_freevar_entry(xcx)\n                 });\n                 dcx.tcx.freevars.insert(id, fv_info);\n@@ -1123,7 +1129,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 let cvars =\n                     at_vec::from_owned(\n                         val_dsr.read_to_vec(\n-                            || val_dsr.read_capture_var(xcx)));\n+                            |val_dsr| val_dsr.read_capture_var(xcx)));\n                 dcx.maps.capture_map.insert(id, cvars);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n@@ -1139,17 +1145,17 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &writer::Encoder, item: @ast::item) {\n-    do ebml_w.wr_tag(c::tag_tree as uint) {\n-        (*item).encode(ebml_w)\n-    }\n+fn encode_item_ast(ebml_w: &mut writer::Encoder, item: @ast::item) {\n+    ebml_w.start_tag(c::tag_tree as uint);\n+    (*item).encode(ebml_w);\n+    ebml_w.end_tag();\n }\n \n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n-    let d = &reader::Decoder(chi_doc);\n-    @Decodable::decode(d)\n+    let mut d = reader::Decoder(chi_doc);\n+    @Decodable::decode(&mut d)\n }\n \n #[cfg(test)]\n@@ -1190,8 +1196,8 @@ fn roundtrip(in_item: Option<@ast::item>) {\n \n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = writer::Encoder(wr);\n-        encode_item_ast(&ebml_w, in_item);\n+        let mut ebml_w = writer::Encoder(wr);\n+        encode_item_ast(&mut ebml_w, in_item);\n     };\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);"}, {"sha": "b9a3f4bd6fcbbcff9d805ddae3a1e885ba06388f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -618,8 +618,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                          visitor: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     match *fk {\n         visit::fk_item_fn(*) |\n-        visit::fk_method(*) |\n-        visit::fk_dtor(*) => {\n+        visit::fk_method(*) => {\n             // Don't process nested items.\n             return;\n         }\n@@ -761,4 +760,3 @@ fn check_loans_in_block<'a>(blk: &ast::blk,\n     visit::visit_block(blk, self, vt);\n     self.check_for_conflicting_loans(blk.node.id);\n }\n-"}, {"sha": "922af0cadec6c696e999779f3c5ca91b3c008508", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -110,8 +110,7 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n     match fk {\n         // Do not visit items here, the outer loop in borrowck/mod\n         // will visit them for us in turn.\n-        &visit::fk_item_fn(*) | &visit::fk_method(*) |\n-        &visit::fk_dtor(*) => {\n+        &visit::fk_item_fn(*) | &visit::fk_method(*) => {\n             return;\n         }\n "}, {"sha": "c9a4de3830719d89a59494c4890a551f95b169c2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -118,8 +118,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n         }\n \n         &visit::fk_item_fn(*) |\n-        &visit::fk_method(*) |\n-        &visit::fk_dtor(*) => {\n+        &visit::fk_method(*) => {\n             debug!(\"borrowck_fn(id=%?)\", id);\n \n             // Check the body of fn items.\n@@ -469,11 +468,11 @@ pub impl BorrowckCtxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn span_err(&self, s: span, m: ~str) {\n+    fn span_err(&self, s: span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(&self, s: span, m: ~str) {\n+    fn span_note(&self, s: span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }\n "}, {"sha": "9e6d90532373a5aeb5deb36f841720696d4a9ac6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -92,13 +92,13 @@ pub fn check_expr(sess: Session,\n           expr_unary(deref, _) => { }\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) => {\n             sess.span_err(e.span,\n-                          ~\"disallowed operator in constant expression\");\n+                          \"disallowed operator in constant expression\");\n             return;\n           }\n           expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n           expr_binary(_, _, _) | expr_unary(_, _) => {\n             if method_map.contains_key(&e.id) {\n-                sess.span_err(e.span, ~\"user-defined operators are not \\\n+                sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }\n           }\n@@ -118,8 +118,8 @@ pub fn check_expr(sess: Session,\n             // a path in trans::callee that only works in block contexts.\n             if pth.types.len() != 0 {\n                 sess.span_err(\n-                    e.span, ~\"paths in constants may only refer to \\\n-                              items without type parameters\");\n+                    e.span, \"paths in constants may only refer to \\\n+                             items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n               Some(&def_const(_)) |\n@@ -131,11 +131,11 @@ pub fn check_expr(sess: Session,\n                 debug!(\"(checking const) found bad def: %?\", def);\n                 sess.span_err(\n                     e.span,\n-                    fmt!(\"paths in constants may only refer to \\\n-                          constants or functions\"));\n+                    \"paths in constants may only refer to \\\n+                     constants or functions\");\n               }\n               None => {\n-                sess.span_bug(e.span, ~\"unbound path in const?!\");\n+                sess.span_bug(e.span, \"unbound path in const?!\");\n               }\n             }\n           }\n@@ -146,8 +146,8 @@ pub fn check_expr(sess: Session,\n                 _ => {\n                     sess.span_err(\n                         e.span,\n-                        ~\"function calls in constants are limited to \\\n-                          struct and enum constructors\");\n+                        \"function calls in constants are limited to \\\n+                         struct and enum constructors\");\n                 }\n             }\n           }\n@@ -163,12 +163,12 @@ pub fn check_expr(sess: Session,\n           expr_addr_of(*) => {\n                 sess.span_err(\n                     e.span,\n-                    ~\"borrowed pointers in constants may only refer to \\\n-                      immutable values\");\n+                    \"borrowed pointers in constants may only refer to \\\n+                     immutable values\");\n           }\n           _ => {\n             sess.span_err(e.span,\n-                          ~\"constant contains unimplemented expression type\");\n+                          \"constant contains unimplemented expression type\");\n             return;\n           }\n         }\n@@ -178,14 +178,14 @@ pub fn check_expr(sess: Session,\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n-                sess.span_err(e.span, ~\"literal out of range for its type\");\n+                sess.span_err(e.span, \"literal out of range for its type\");\n             }\n         }\n       }\n       expr_lit(@codemap::spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n-            sess.span_err(e.span, ~\"literal out of range for its type\");\n+            sess.span_err(e.span, \"literal out of range for its type\");\n         }\n       }\n       _ => ()\n@@ -224,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n \n     fn visit_item(it: @item, env: env, v: visit::vt<env>) {\n         if env.idstack.contains(&(it.id)) {\n-            env.sess.span_fatal(env.root_it.span, ~\"recursive constant\");\n+            env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n         visit::visit_item(it, env, v);\n@@ -253,11 +253,3 @@ pub fn check_item_recursion(sess: Session,\n         visit::visit_expr(e, env, v);\n     }\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "e3b816fceb8bb49540b66e6e89288fd172c62ec3", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -54,17 +54,17 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, ~\"`break` outside of loop\");\n+                    tcx.sess.span_err(e.span, \"`break` outside of loop\");\n                 }\n               }\n               expr_again(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, ~\"`again` outside of loop\");\n+                    tcx.sess.span_err(e.span, \"`again` outside of loop\");\n                 }\n               }\n               expr_ret(oe) => {\n                 if !cx.can_ret {\n-                    tcx.sess.span_err(e.span, ~\"`return` in block function\");\n+                    tcx.sess.span_err(e.span, \"`return` in block function\");\n                 }\n                 visit::visit_expr_opt(oe, cx, v);\n               }"}, {"sha": "a50895aa013b5a22ff676bbe34358ab4a3c0e927", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -94,7 +94,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, s: (), v: visit::vt<()>) {\n        }\n        let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n        if arms.is_empty() {\n-           cx.tcx.sess.span_err(ex.span, ~\"non-exhaustive patterns\");\n+           cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n            check_exhaustive(cx, ex.span, arms);\n        }\n@@ -111,7 +111,7 @@ pub fn check_arms(cx: @MatchCheckCtxt, arms: &[arm]) {\n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n               not_useful => {\n-                cx.tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n+                cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n               }\n               _ => ()\n             }\n@@ -685,7 +685,7 @@ pub fn check_local(cx: @MatchCheckCtxt,\n     visit::visit_local(loc, s, v);\n     if is_refutable(cx, loc.node.pat) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n-                          ~\"refutable pattern in local binding\");\n+                             \"refutable pattern in local binding\");\n     }\n \n     // Check legality of move bindings.\n@@ -708,7 +708,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n     for decl.inputs.each |input| {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n-                              ~\"refutable pattern in function argument\");\n+                                 \"refutable pattern in function argument\");\n         }\n     }\n }\n@@ -780,24 +780,24 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n         if sub.is_some() {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move with sub-bindings\");\n+                \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move into a pattern guard\");\n+                \"cannot bind by-move into a pattern guard\");\n         } else if by_ref_span.is_some() {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move and by-ref \\\n-                  in the same pattern\");\n+                \"cannot bind by-move and by-ref \\\n+                 in the same pattern\");\n             tcx.sess.span_note(\n                 by_ref_span.get(),\n-                ~\"by-ref binding occurs here\");\n+                \"by-ref binding occurs here\");\n         } else if is_lvalue {\n             tcx.sess.span_err(\n                 p.span,\n-                ~\"cannot bind by-move when \\\n-                  matching an lvalue\");\n+                \"cannot bind by-move when \\\n+                 matching an lvalue\");\n         }\n     };\n \n@@ -837,9 +837,9 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                         {\n                             cx.tcx.sess.span_err(\n                                 pat.span,\n-                                ~\"by-move pattern \\\n-                                  bindings may not occur \\\n-                                  behind @ or & bindings\");\n+                                \"by-move pattern \\\n+                                 bindings may not occur \\\n+                                 behind @ or & bindings\");\n                         }\n \n                         match sub {\n@@ -862,11 +862,3 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n         (vt.visit_pat)(*pat, false, vt);\n     }\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "7c1933d67853a95515bf9c30850240c5cf942185", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -277,7 +277,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_float(a + b)),\n               subtract => Ok(const_float(a - b)),\n               mul => Ok(const_float(a * b)),\n-              quot => Ok(const_float(a / b)),\n+              div => Ok(const_float(a / b)),\n               rem => Ok(const_float(a % b)),\n               eq => fromb(a == b),\n               lt => fromb(a < b),\n@@ -293,8 +293,8 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_int(a + b)),\n               subtract => Ok(const_int(a - b)),\n               mul => Ok(const_int(a * b)),\n-              quot if b == 0 => Err(~\"attempted quotient with a divisor of zero\"),\n-              quot => Ok(const_int(a / b)),\n+              div if b == 0 => Err(~\"attempted to divide by zero\"),\n+              div => Ok(const_int(a / b)),\n               rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n               rem => Ok(const_int(a % b)),\n               and | bitand => Ok(const_int(a & b)),\n@@ -315,8 +315,8 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_uint(a + b)),\n               subtract => Ok(const_uint(a - b)),\n               mul => Ok(const_uint(a * b)),\n-              quot if b == 0 => Err(~\"attempted quotient with a divisor of zero\"),\n-              quot => Ok(const_uint(a / b)),\n+              div if b == 0 => Err(~\"attempted to divide by zero\"),\n+              div => Ok(const_uint(a / b)),\n               rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n               rem => Ok(const_uint(a % b)),\n               and | bitand => Ok(const_uint(a & b)),\n@@ -482,12 +482,3 @@ pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n pub fn lit_eq(a: @lit, b: @lit) -> bool {\n     compare_const_vals(&lit_to_const(a), &lit_to_const(b)) == 0\n }\n-\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "419b75a2ad9d88673fcd519d45ca925bf204ba44", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -119,11 +119,3 @@ pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n pub fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n     return vec::len(*get_freevars(tcx, fid)) != 0u;\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "57c3e7c3b9a05d36da36794c732fde0b92e0d5b6", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -93,21 +93,21 @@ fn check_struct_safe_for_destructor(cx: Context,\n         });\n         if !ty::type_is_owned(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n-                                 ~\"cannot implement a destructor on a struct \\\n-                                   that is not Owned\");\n+                                 \"cannot implement a destructor on a struct \\\n+                                  that is not Owned\");\n             cx.tcx.sess.span_note(span,\n-                                  ~\"use \\\"#[unsafe_destructor]\\\" on the \\\n-                                    implementation to force the compiler to \\\n-                                    allow this\");\n+                                  \"use \\\"#[unsafe_destructor]\\\" on the \\\n+                                   implementation to force the compiler to \\\n+                                   allow this\");\n         }\n     } else {\n         cx.tcx.sess.span_err(span,\n-                             ~\"cannot implement a destructor on a struct \\\n-                               with type parameters\");\n+                             \"cannot implement a destructor on a struct \\\n+                              with type parameters\");\n         cx.tcx.sess.span_note(span,\n-                              ~\"use \\\"#[unsafe_destructor]\\\" on the \\\n-                                implementation to force the compiler to \\\n-                                allow this\");\n+                              \"use \\\"#[unsafe_destructor]\\\" on the \\\n+                               implementation to force the compiler to \\\n+                               allow this\");\n     }\n }\n \n@@ -139,27 +139,16 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n                                 }\n                                 _ => {\n                                     cx.tcx.sess.span_bug(self_type.span,\n-                                                         ~\"the self type for \\\n-                                                           the Drop trait \\\n-                                                           impl is not a \\\n-                                                           path\");\n+                                                         \"the self type for \\\n+                                                          the Drop trait \\\n+                                                          impl is not a \\\n+                                                          path\");\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n-            item_struct(struct_def, _) => {\n-                match struct_def.dtor {\n-                    None => {}\n-                    Some(ref dtor) => {\n-                        let struct_did = def_id { crate: 0, node: item.id };\n-                        check_struct_safe_for_destructor(cx,\n-                                                         dtor.span,\n-                                                         struct_did);\n-                    }\n-                }\n-            }\n             _ => {}\n         }\n     }\n@@ -200,7 +189,7 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n         cx.tcx.sess.span_err(\n             fv.span,\n-            ~\"attempted dynamic environment capture\");\n+            \"attempted dynamic environment capture\");\n     }\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n@@ -412,7 +401,7 @@ fn check_imm_free_var(cx: Context, def: def, sp: span) {\n             if is_mutbl {\n                 cx.tcx.sess.span_err(\n                     sp,\n-                    ~\"mutable variables cannot be implicitly captured\");\n+                    \"mutable variables cannot be implicitly captured\");\n             }\n         }\n         def_arg(*) => { /* ok */ }\n@@ -454,12 +443,12 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     if !ty::type_is_durable(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(*) => {\n-            tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n-                                    pointers; use `'static` bound\");\n+            tcx.sess.span_err(sp, \"value may contain borrowed \\\n+                                   pointers; use `'static` bound\");\n           }\n           _ => {\n-            tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n-                                    pointers\");\n+            tcx.sess.span_err(sp, \"value may contain borrowed \\\n+                                   pointers\");\n           }\n         }\n         false\n@@ -584,19 +573,9 @@ pub fn check_kind_bounds_of_cast(cx: Context, source: @expr, target: @expr) {\n             if !ty::type_is_owned(cx.tcx, source_ty) {\n                 cx.tcx.sess.span_err(\n                     target.span,\n-                    ~\"uniquely-owned trait objects must be sendable\");\n+                    \"uniquely-owned trait objects must be sendable\");\n             }\n         }\n         _ => {} // Nothing to do.\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "001218ea0cf62c4c21c72d9ef88766a86b71c4ce", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -41,7 +41,7 @@ pub enum LangItem {\n     AddTraitLangItem,           // 5\n     SubTraitLangItem,           // 6\n     MulTraitLangItem,           // 7\n-    QuotTraitLangItem,          // 8\n+    DivTraitLangItem,           // 8\n     RemTraitLangItem,           // 9\n     NegTraitLangItem,           // 10\n     NotTraitLangItem,           // 11\n@@ -107,7 +107,7 @@ pub impl LanguageItems {\n             5  => \"add\",\n             6  => \"sub\",\n             7  => \"mul\",\n-            8  => \"quot\",\n+            8  => \"div\",\n             9  => \"rem\",\n             10 => \"neg\",\n             11 => \"not\",\n@@ -172,8 +172,8 @@ pub impl LanguageItems {\n     pub fn mul_trait(&const self) -> def_id {\n         self.items[MulTraitLangItem as uint].get()\n     }\n-    pub fn quot_trait(&const self) -> def_id {\n-        self.items[QuotTraitLangItem as uint].get()\n+    pub fn div_trait(&const self) -> def_id {\n+        self.items[DivTraitLangItem as uint].get()\n     }\n     pub fn rem_trait(&const self) -> def_id {\n         self.items[RemTraitLangItem as uint].get()\n@@ -281,7 +281,7 @@ fn LanguageItemCollector(crate: @crate,\n     item_refs.insert(@~\"add\", AddTraitLangItem as uint);\n     item_refs.insert(@~\"sub\", SubTraitLangItem as uint);\n     item_refs.insert(@~\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@~\"quot\", QuotTraitLangItem as uint);\n+    item_refs.insert(@~\"div\", DivTraitLangItem as uint);\n     item_refs.insert(@~\"rem\", RemTraitLangItem as uint);\n     item_refs.insert(@~\"neg\", NegTraitLangItem as uint);\n     item_refs.insert(@~\"not\", NotTraitLangItem as uint);\n@@ -442,4 +442,3 @@ pub fn collect_language_items(crate: @crate,\n     let LanguageItemCollector { items, _ } = collector;\n     items\n }\n-"}, {"sha": "b0d6d477c0c87bd5943c838069a95ab8ed601164", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 15, "deletions": 54, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -57,7 +57,6 @@ pub enum lint {\n     type_limits,\n     default_methods,\n     deprecated_mutable_fields,\n-    deprecated_drop,\n     unused_unsafe,\n \n     managed_heap_memory,\n@@ -210,13 +209,6 @@ pub fn get_lint_dict() -> LintDict {\n             default: deny\n         }),\n \n-        (~\"deprecated_drop\",\n-         LintSpec {\n-            lint: deprecated_drop,\n-            desc: \"deprecated \\\"drop\\\" notation for the destructor\",\n-            default: deny\n-        }),\n-\n         (~\"unused_unsafe\",\n          LintSpec {\n             lint: unused_unsafe,\n@@ -346,14 +338,14 @@ pub impl Context {\n                           _ => {\n                             self.sess.span_err(\n                                 meta.span,\n-                                ~\"malformed lint attribute\");\n+                                \"malformed lint attribute\");\n                           }\n                         }\n                     }\n                   }\n                   _  => {\n                     self.sess.span_err(meta.span,\n-                                       ~\"malformed lint attribute\");\n+                                       \"malformed lint attribute\");\n                   }\n                 }\n             }\n@@ -463,7 +455,6 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n     check_item_deprecated_mutable_fields(cx, i);\n-    check_item_deprecated_drop(cx, i);\n     check_item_unused_unsafe(cx, i);\n     check_item_unused_mut(cx, i);\n }\n@@ -494,8 +485,8 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n                                 cx.sess.span_lint(\n                                     while_true, e.id, it.id,\n                                     e.span,\n-                                    ~\"denote infinite loops \\\n-                                      with loop { ... }\");\n+                                    \"denote infinite loops \\\n+                                     with loop { ... }\");\n                             }\n                             _ => ()\n                         }\n@@ -612,7 +603,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n                     && !check_limits(cx, *binop, l, r) {\n                     cx.sess.span_lint(\n                         type_limits, e.id, it.id, e.span,\n-                        ~\"comparison is useless due to type limits\");\n+                        \"comparison is useless due to type limits\");\n                 }\n             }\n             _ => ()\n@@ -639,7 +630,7 @@ fn check_item_default_methods(cx: ty::ctxt, item: @ast::item) {\n                             item.id,\n                             item.id,\n                             item.span,\n-                            ~\"default methods are experimental\");\n+                            \"default methods are experimental\");\n                     }\n                 }\n             }\n@@ -658,7 +649,7 @@ fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n                                           item.id,\n                                           item.id,\n                                           field.span,\n-                                          ~\"mutable fields are deprecated\");\n+                                          \"mutable fields are deprecated\");\n                     }\n                     ast::named_field(*) | ast::unnamed_field => {}\n                 }\n@@ -668,26 +659,6 @@ fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n-fn check_item_deprecated_drop(cx: ty::ctxt, item: @ast::item) {\n-    match item.node {\n-        ast::item_struct(struct_def, _) => {\n-            match struct_def.dtor {\n-                None => {}\n-                Some(ref dtor) => {\n-                    cx.sess.span_lint(deprecated_drop,\n-                                      item.id,\n-                                      item.id,\n-                                      dtor.span,\n-                                      ~\"`drop` notation for destructors is \\\n-                                        deprecated; implement the `Drop` \\\n-                                        trait instead\");\n-                }\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n@@ -701,14 +672,14 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,\n                         ty.span,\n-                        ~\"found rust type `int` in foreign module, while \\\n+                        \"found rust type `int` in foreign module, while \\\n                          libc::c_int or libc::c_long should be used\");\n                   }\n                   ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,\n                         ty.span,\n-                        ~\"found rust type `uint` in foreign module, while \\\n+                        \"found rust type `uint` in foreign module, while \\\n                          libc::c_uint or libc::c_ulong should be used\");\n                   }\n                   _ => ()\n@@ -824,7 +795,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n                         cx.sess.span_lint(\n                             path_statement, id, it.id,\n                             s.span,\n-                            ~\"path statement with no effect\");\n+                            \"path statement with no effect\");\n                     }\n                     _ => ()\n                 }\n@@ -864,8 +835,8 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n         if !is_camel_case(cx, ident) {\n             cx.sess.span_lint(\n                 non_camel_case_types, expr_id, item_id, span,\n-                ~\"type, variant, or trait should have \\\n-                  a camel case identifier\");\n+                \"type, variant, or trait should have \\\n+                 a camel case identifier\");\n         }\n     }\n \n@@ -892,7 +863,7 @@ fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n                 if !cx.used_unsafe.contains(&blk.node.id) {\n                     cx.sess.span_lint(unused_unsafe, blk.node.id, it.id,\n                                       blk.span,\n-                                      ~\"unnecessary `unsafe` block\");\n+                                      \"unnecessary `unsafe` block\");\n                 }\n             }\n             _ => ()\n@@ -917,9 +888,9 @@ fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n         }\n         if !used {\n             let msg = if bindings == 1 {\n-                ~\"variable does not need to be mutable\"\n+                \"variable does not need to be mutable\"\n             } else {\n-                ~\"variables do not need to be mutable\"\n+                \"variables do not need to be mutable\"\n             };\n             tcx.sess.span_lint(unused_mut, p.id, it.id, p.span, msg);\n         }\n@@ -975,13 +946,3 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n \n     tcx.sess.abort_if_errors();\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0bd73a15d507cf710d2f683cf7a8c15f0f2b732b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -116,7 +116,7 @@ use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{expr_to_str, block_to_str};\n-use syntax::visit::{fk_anon, fk_dtor, fk_fn_block, fk_item_fn, fk_method};\n+use syntax::visit::{fk_anon, fk_fn_block, fk_item_fn, fk_method};\n use syntax::visit::{vt};\n use syntax::{visit, ast_util};\n \n@@ -331,7 +331,7 @@ pub impl IrMaps {\n         match self.capture_info_map.find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n-            self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n+            self.tcx.sess.span_bug(expr.span, \"no registered caps\");\n           }\n         }\n     }\n@@ -389,9 +389,6 @@ fn visit_fn(fk: &visit::fn_kind,\n                 sty_static => {}\n             }\n         }\n-        fk_dtor(_, _, self_id, _) => {\n-            fn_maps.add_variable(Arg(self_id, special_idents::self_));\n-        }\n         fk_item_fn(*) | fk_anon(*) | fk_fn_block(*) => {}\n     }\n \n@@ -639,7 +636,7 @@ pub impl Liveness {\n           }\n           None => {\n             self.tcx.sess.span_bug(\n-                span, ~\"Not present in def map\")\n+                span, \"Not present in def map\")\n           }\n         }\n     }\n@@ -756,8 +753,8 @@ pub impl Liveness {\n                       // to find with one\n                 match self.tcx.def_map.find(&id) {\n                     Some(&def_label(loop_id)) => loop_id,\n-                    _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n-                                                    doesn't refer to a loop\")\n+                    _ => self.tcx.sess.span_bug(sp, \"Label on break/loop \\\n+                                                     doesn't refer to a loop\")\n                 },\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n@@ -948,7 +945,7 @@ pub impl Liveness {\n           }\n \n           stmt_mac(*) => {\n-            self.tcx.sess.span_bug(stmt.span, ~\"unexpanded macro\");\n+            self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n           }\n         }\n     }\n@@ -1118,7 +1115,7 @@ pub impl Liveness {\n               match self.break_ln.find(&sc) {\n                   Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n-                                ~\"Break to unknown label\")\n+                                                 \"Break to unknown label\")\n               }\n           }\n \n@@ -1132,7 +1129,7 @@ pub impl Liveness {\n               match self.cont_ln.find(&sc) {\n                   Some(&b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n-                                ~\"Loop to unknown label\")\n+                                                 \"Loop to unknown label\")\n               }\n           }\n \n@@ -1258,7 +1255,7 @@ pub impl Liveness {\n           }\n \n           expr_mac(*) => {\n-            self.tcx.sess.span_bug(expr.span, ~\"unexpanded macro\");\n+            self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n     }\n@@ -1570,10 +1567,10 @@ pub impl Liveness {\n             } else if ty::type_is_bot(t_ret) {\n                 // for bot return types, not ok.  Function should fail.\n                 self.tcx.sess.span_err(\n-                    sp, ~\"some control paths may return\");\n+                    sp, \"some control paths may return\");\n             } else {\n                 self.tcx.sess.span_err(\n-                    sp, ~\"not all control paths return a value\");\n+                    sp, \"not all control paths return a value\");\n             }\n         }\n     }\n@@ -1654,10 +1651,10 @@ pub impl Liveness {\n               None => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    ~\"re-assignment of immutable variable\");\n+                    \"re-assignment of immutable variable\");\n                 self.tcx.sess.span_note(\n                     orig_span,\n-                    ~\"prior assignment occurs here\");\n+                    \"prior assignment occurs here\");\n               }\n             }\n           }"}, {"sha": "dde4c044792881f455a5cd22399fce08eb491b94", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -847,7 +847,7 @@ pub impl mem_categorization_ctxt {\n                 _ => {\n                     self.tcx.sess.span_bug(\n                         pat.span,\n-                        ~\"enum pattern didn't resolve to enum or struct\");\n+                        \"enum pattern didn't resolve to enum or struct\");\n                 }\n             }\n           }"}, {"sha": "040ff30f9e63fce79a02b153213cc3e03ad11e45", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -450,7 +450,7 @@ pub impl VisitContext {\n                     MoveInWhole => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            fmt!(\"Component mode can never be MoveInWhole\"));\n+                            \"Component mode can never be MoveInWhole\");\n                     }\n                 }\n             }\n@@ -673,7 +673,7 @@ pub impl VisitContext {\n             expr_mac(*) => {\n                 self.tcx.sess.span_bug(\n                     expr.span,\n-                    ~\"macro expression remains after expansion\");\n+                    \"macro expression remains after expansion\");\n             }\n         }\n     }"}, {"sha": "b87adb75bc37a2be6fceab1d5634b05209d62f6c", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -86,4 +86,3 @@ pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[node_id] {\n     pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;\n }\n-"}, {"sha": "ce0f124da74c9e977af8a885ec9ce60957059d62", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -99,8 +99,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                                          parental_privacy == Public)\n                                          == Private {\n             tcx.sess.span_err(span,\n-                ~\"can only dereference enums \\\n-                  with a single, public variant\");\n+                \"can only dereference enums \\\n+                 with a single, public variant\");\n         }\n     };\n \n@@ -121,8 +121,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                                             tcx.sess.parse_sess.interner)));\n             }\n             None => {\n-                tcx.sess.span_bug(span, ~\"method not found in \\\n-                                          AST map?!\");\n+                tcx.sess.span_bug(span, \"method not found in \\\n+                                         AST map?!\");\n             }\n         }\n     };\n@@ -140,8 +140,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                 // Look up the enclosing impl.\n                 if container_id.crate != local_crate {\n                     tcx.sess.span_bug(span,\n-                                      ~\"local method isn't in local \\\n-                                        impl?!\");\n+                                      \"local method isn't in local \\\n+                                       impl?!\");\n                 }\n \n                 match tcx.items.find(&container_id.node) {\n@@ -155,10 +155,10 @@ pub fn check_crate(tcx: ty::ctxt,\n                         }\n                     }\n                     Some(_) => {\n-                        tcx.sess.span_bug(span, ~\"impl wasn't an item?!\");\n+                        tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n                     }\n                     None => {\n-                        tcx.sess.span_bug(span, ~\"impl wasn't in AST map?!\");\n+                        tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n                     }\n                 }\n             }\n@@ -185,8 +185,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                                             tcx.sess.parse_sess.interner)));\n             }\n             None => {\n-                tcx.sess.span_bug(span, ~\"method not found in \\\n-                                          AST map?!\");\n+                tcx.sess.span_bug(span, \"method not found in \\\n+                                         AST map?!\");\n             }\n         }\n     };\n@@ -219,7 +219,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                                    .interner)));\n                 }\n                 None => {\n-                    tcx.sess.span_bug(span, ~\"item not found in AST map?!\");\n+                    tcx.sess.span_bug(span, \"item not found in AST map?!\");\n                 }\n             }\n         };\n@@ -333,10 +333,10 @@ pub fn check_crate(tcx: ty::ctxt,\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n                                     if method_num >= (*methods).len() {\n-                                        tcx.sess.span_bug(span, ~\"method \\\n-                                                                  number \\\n-                                                                  out of \\\n-                                                                  range?!\");\n+                                        tcx.sess.span_bug(span, \"method \\\n+                                                                 number \\\n+                                                                 out of \\\n+                                                                 range?!\");\n                                     }\n                                     match (*methods)[method_num] {\n                                         provided(method)\n@@ -363,20 +363,20 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                 }\n                                 _ => {\n-                                    tcx.sess.span_bug(span, ~\"trait wasn't \\\n-                                                              actually a \\\n-                                                              trait?!\");\n+                                    tcx.sess.span_bug(span, \"trait wasn't \\\n+                                                             actually a \\\n+                                                             trait?!\");\n                                 }\n                             }\n                         }\n                         Some(_) => {\n-                            tcx.sess.span_bug(span, ~\"trait wasn't an \\\n-                                                      item?!\");\n+                            tcx.sess.span_bug(span, \"trait wasn't an \\\n+                                                     item?!\");\n                         }\n                         None => {\n-                            tcx.sess.span_bug(span, ~\"trait item wasn't \\\n-                                                      found in the AST \\\n-                                                      map?!\");\n+                            tcx.sess.span_bug(span, \"trait item wasn't \\\n+                                                     found in the AST \\\n+                                                     map?!\");\n                         }\n                     }\n                 } else {\n@@ -465,8 +465,8 @@ pub fn check_crate(tcx: ty::ctxt,\n                             match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n-                                                      ~\"method call not in \\\n-                                                        method map\");\n+                                                      \"method call not in \\\n+                                                       method map\");\n                                 }\n                                 Some(ref entry) => {\n                                     debug!(\"(privacy checking) checking \\\n@@ -512,18 +512,18 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                     _ => {\n                                         tcx.sess.span_bug(expr.span,\n-                                                          ~\"resolve didn't \\\n-                                                            map enum struct \\\n-                                                            constructor to a \\\n-                                                            variant def\");\n+                                                          \"resolve didn't \\\n+                                                           map enum struct \\\n+                                                           constructor to a \\\n+                                                           variant def\");\n                                     }\n                                 }\n                             }\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(expr.span, ~\"struct expr \\\n-                                                           didn't have \\\n-                                                           struct type?!\");\n+                            tcx.sess.span_bug(expr.span, \"struct expr \\\n+                                                          didn't have \\\n+                                                          struct type?!\");\n                         }\n                     }\n                 }\n@@ -579,18 +579,18 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                     _ => {\n                                         tcx.sess.span_bug(pattern.span,\n-                                                          ~\"resolve didn't \\\n-                                                            map enum struct \\\n-                                                            pattern to a \\\n-                                                            variant def\");\n+                                                          \"resolve didn't \\\n+                                                           map enum struct \\\n+                                                           pattern to a \\\n+                                                           variant def\");\n                                     }\n                                 }\n                             }\n                         }\n                         _ => {\n                             tcx.sess.span_bug(pattern.span,\n-                                              ~\"struct pattern didn't have \\\n-                                                struct type?!\");\n+                                              \"struct pattern didn't have \\\n+                                               struct type?!\");\n                         }\n                     }\n                 }\n@@ -603,4 +603,3 @@ pub fn check_crate(tcx: ty::ctxt,\n     });\n     visit::visit_crate(crate, method_map, visitor);\n }\n-"}, {"sha": "5834ae1d780552052e1af675b188c2bad99af020", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -334,7 +334,7 @@ pub impl RegionMaps {\n pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n     match cx.parent {\n       None => {\n-        cx.sess.span_bug(span, ~\"crate should not be parent here\");\n+        cx.sess.span_bug(span, \"crate should not be parent here\");\n       }\n       Some(parent_id) => {\n         parent_id\n@@ -464,8 +464,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n     // or it continues with the inherited scope (closures).\n     let body_cx = match *fk {\n         visit::fk_item_fn(*) |\n-        visit::fk_method(*) |\n-        visit::fk_dtor(*) => {\n+        visit::fk_method(*) => {\n             Context {parent: None, var_parent: None, ..cx}\n         }\n         visit::fk_anon(*) |\n@@ -980,4 +979,3 @@ pub fn determine_rp_in_crate(sess: Session,\n     // return final set\n     return cx.region_paramd_items;\n }\n-"}, {"sha": "911e265e6163caa71cf43a347e0bf70076184134", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -33,7 +33,7 @@ use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-use syntax::ast::{def_upvar, def_use, def_variant, quot, eq};\n+use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n use syntax::ast::{expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n@@ -47,7 +47,7 @@ use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n-use syntax::ast::{struct_dtor, struct_field, struct_variant_kind};\n+use syntax::ast::{struct_field, struct_variant_kind};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, TyParam, ty_path};\n@@ -3512,7 +3512,6 @@ pub impl Resolver {\n                 self.resolve_struct(item.id,\n                                     generics,\n                                     struct_def.fields,\n-                                    &struct_def.dtor,\n                                     visitor);\n             }\n \n@@ -3770,7 +3769,6 @@ pub impl Resolver {\n                       id: node_id,\n                       generics: &Generics,\n                       fields: &[@struct_field],\n-                      optional_destructor: &Option<struct_dtor>,\n                       visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3784,23 +3782,6 @@ pub impl Resolver {\n             for fields.each |field| {\n                 self.resolve_type(field.node.ty, visitor);\n             }\n-\n-            // Resolve the destructor, if applicable.\n-            match *optional_destructor {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(ref destructor) => {\n-                    self.resolve_function(NormalRibKind,\n-                                          None,\n-                                          NoTypeParameters,\n-                                          &destructor.node.body,\n-                                          HasSelfBinding\n-                                            ((*destructor).node.self_id,\n-                                             true),\n-                                          visitor);\n-                }\n-            }\n         }\n     }\n \n@@ -4899,9 +4880,9 @@ pub impl Resolver {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.mul_trait());\n             }\n-            expr_binary(quot, _, _) | expr_assign_op(quot, _, _) => {\n+            expr_binary(div, _, _) | expr_assign_op(div, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.quot_trait());\n+                                              self.lang_items.div_trait());\n             }\n             expr_binary(rem, _, _) | expr_assign_op(rem, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,"}, {"sha": "2773710ca98fc13dc6e9de31b1c716db1bf06387", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -33,7 +33,7 @@ use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-use syntax::ast::{def_upvar, def_use, def_variant, quot, eq};\n+use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n use syntax::ast::{expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n@@ -47,7 +47,7 @@ use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n-use syntax::ast::{struct_dtor, struct_field, struct_variant_kind};\n+use syntax::ast::{struct_field, struct_variant_kind};\n use syntax::ast::{sty_static, subtract, trait_ref, tuple_variant_kind, Ty};\n use syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n use syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, TyParam, ty_path};\n@@ -971,7 +971,7 @@ pub impl Resolver {\n                 module_.children.insert(name, child);\n                 return (child, new_parent);\n             }\n-            Some(&child) => {\n+            Some(child) => {\n                 // Enforce the duplicate checking mode:\n                 //\n                 // * If we're requesting duplicate module checking, check that\n@@ -1033,7 +1033,7 @@ pub impl Resolver {\n                                   *self.session.str_of(name)));\n                     }\n                 }\n-                return (child, new_parent);\n+                return (*child, new_parent);\n             }\n         }\n     }\n@@ -1864,7 +1864,7 @@ pub impl Resolver {\n                        *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n-                    Some(&resolution) => {\n+                    Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n                         resolution.outstanding_references += 1;\n@@ -2395,7 +2395,7 @@ pub impl Resolver {\n                         (*ident, new_import_resolution);\n                 }\n                 None => { /* continue ... */ }\n-                Some(&dest_import_resolution) => {\n+                Some(dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n@@ -2433,8 +2433,8 @@ pub impl Resolver {\n                     module_.import_resolutions.insert\n                         (*ident, dest_import_resolution);\n                 }\n-                Some(&existing_import_resolution) => {\n-                    dest_import_resolution = existing_import_resolution;\n+                Some(existing_import_resolution) => {\n+                    dest_import_resolution = *existing_import_resolution;\n                 }\n             }\n \n@@ -3512,7 +3512,6 @@ pub impl Resolver {\n                 self.resolve_struct(item.id,\n                                     generics,\n                                     struct_def.fields,\n-                                    &struct_def.dtor,\n                                     visitor);\n             }\n \n@@ -3770,7 +3769,6 @@ pub impl Resolver {\n                       id: node_id,\n                       generics: &Generics,\n                       fields: &[@struct_field],\n-                      optional_destructor: &Option<struct_dtor>,\n                       visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3784,23 +3782,6 @@ pub impl Resolver {\n             for fields.each |field| {\n                 self.resolve_type(field.node.ty, visitor);\n             }\n-\n-            // Resolve the destructor, if applicable.\n-            match *optional_destructor {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(ref destructor) => {\n-                    self.resolve_function(NormalRibKind,\n-                                          None,\n-                                          NoTypeParameters,\n-                                          &destructor.node.body,\n-                                          HasSelfBinding\n-                                            ((*destructor).node.self_id,\n-                                             true),\n-                                          visitor);\n-                }\n-            }\n         }\n     }\n \n@@ -4901,9 +4882,9 @@ pub impl Resolver {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.mul_trait());\n             }\n-            expr_binary(quot, _, _) | expr_assign_op(quot, _, _) => {\n+            expr_binary(div, _, _) | expr_assign_op(div, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.quot_trait());\n+                                              self.lang_items.div_trait());\n             }\n             expr_binary(rem, _, _) | expr_assign_op(rem, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n@@ -5267,7 +5248,7 @@ pub impl Resolver {\n \n         debug!(\"Import resolutions:\");\n         for module_.import_resolutions.each |name, import_resolution| {\n-            let value_repr;\n+            let mut value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }\n                 Some(_) => {\n@@ -5276,7 +5257,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            let type_repr;\n+            let mut type_repr;\n             match import_resolution.target_for_namespace(TypeNS) {\n                 None => { type_repr = ~\"\"; }\n                 Some(_) => {"}, {"sha": "bf64134704a4ca2af9eea66d301d0cff8a932bd4", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -186,4 +186,3 @@ impl Subst for ty::ty_param_bounds_and_ty {\n         }\n     }\n }\n-"}, {"sha": "d074a2f796f4656604ebdc711aeb54b13d449ae1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -557,8 +557,7 @@ pub fn enter_opt<'r>(bcx: block,\n                             struct_id = found_struct_id;\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(p.span, ~\"expected enum \\\n-                                                        variant def\");\n+                            tcx.sess.span_bug(p.span, \"expected enum variant def\");\n                         }\n                     }\n \n@@ -1882,11 +1881,3 @@ pub fn bind_irrefutable_pat(bcx: block,\n     }\n     return bcx;\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "0ee2a2c4cb1496a1a8e4eacfd7bc493e66f78a1d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -409,8 +409,8 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(ref cases) => cases[discr as uint].fields.len() - 1,\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, _ } => {\n-            if discr == nndiscr { nonnull.fields.len() } else { 0 }\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, nullfields: ref nullfields, _ } => {\n+            if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n     }\n }"}, {"sha": "90dd9103011d51373caff47ec26dba310eb1df0c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 148, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -777,10 +777,10 @@ pub fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-pub fn fail_if_zero(cx: block, span: span, quotrem: ast::binop,\n+pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> block {\n-    let text = if quotrem == ast::quot {\n-        @~\"attempted quotient with a divisor of zero\"\n+    let text = if divrem == ast::div {\n+        @~\"attempted to divide by zero\"\n     } else {\n         @~\"attempted remainder with a divisor of zero\"\n     };\n@@ -1099,10 +1099,11 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n     }\n \n     let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-      Some(&local_mem(v)) => v,\n-      _ => { bcx.tcx().sess.span_bug(local.span,\n-                        ~\"init_local: Someone forgot to document why it's\\\n-                         safe to assume local.node.init must be local_mem!\");\n+        Some(&local_mem(v)) => v,\n+        _ => {\n+            bcx.tcx().sess.span_bug(local.span,\n+                                    \"init_local: Someone forgot to document why it's\\\n+                                     safe to assume local.node.init must be local_mem!\");\n         }\n     };\n \n@@ -2045,6 +2046,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     let repr = adt::represent_type(ccx, tup_ty);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), 0);\n \n     for fields.eachi |i, field| {\n         let lldestptr = adt::trans_field_ptr(bcx,\n@@ -2067,56 +2069,8 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     finish_fn(fcx, lltop);\n }\n \n-pub fn trans_struct_dtor(ccx: @CrateContext,\n-                         path: path,\n-                         body: &ast::blk,\n-                         dtor_id: ast::node_id,\n-                         psubsts: Option<@param_substs>,\n-                         hash_id: Option<mono_id>,\n-                         parent_id: ast::def_id)\n-                      -> ValueRef {\n-  let tcx = ccx.tcx;\n-  /* Look up the parent class's def_id */\n-  let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n-  /* Substitute in the class type if necessary */\n-  for psubsts.each |ss| {\n-    class_ty = ty::subst_tps(tcx, ss.tys, ss.self_ty, class_ty);\n-  }\n-\n-  /* The dtor takes a (null) output pointer, and a self argument,\n-     and returns () */\n-  let lldty = type_of_dtor(ccx, class_ty);\n-\n-  // XXX: Bad copies.\n-  let s = get_dtor_symbol(ccx, copy path, dtor_id, psubsts);\n-\n-  /* Register the dtor as a function. It has external linkage */\n-  let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n-  lib::llvm::SetLinkage(lldecl, lib::llvm::ExternalLinkage);\n-\n-  /* If we're monomorphizing, register the monomorphized decl\n-     for the dtor */\n-  for hash_id.each |h_id| {\n-    ccx.monomorphized.insert(*h_id, lldecl);\n-  }\n-  /* Translate the dtor body */\n-  let decl = ast_util::dtor_dec();\n-  trans_fn(ccx,\n-           path,\n-           &decl,\n-           body,\n-           lldecl,\n-           impl_self(class_ty),\n-           psubsts,\n-           dtor_id,\n-           None,\n-           []);\n-  lldecl\n-}\n-\n pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n-                      id: ast::node_id,\n-                      path: @ast_map::path, vi: @~[ty::VariantInfo],\n+                      id: ast::node_id, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n     for vec::each(enum_definition.variants) |variant| {\n         let disr_val = vi[*i].disr_val;\n@@ -2132,8 +2086,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n                 // Nothing to do.\n             }\n             ast::struct_variant_kind(struct_def) => {\n-                trans_struct_def(ccx, struct_def, path,\n-                                 variant.node.id);\n+                trans_struct_def(ccx, struct_def);\n             }\n         }\n     }\n@@ -2192,8 +2145,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, enum_definition, item.id,\n-                           path, vi, &mut i);\n+            trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n@@ -2202,22 +2154,14 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         if !generics.is_type_parameterized() {\n-            trans_struct_def(ccx, struct_def, path, item.id);\n+            trans_struct_def(ccx, struct_def);\n         }\n       }\n       _ => {/* fall through */ }\n     }\n }\n \n-pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n-                        path: @ast_map::path,\n-                        id: ast::node_id) {\n-    // Translate the destructor.\n-    for struct_def.dtor.each |dtor| {\n-        trans_struct_dtor(ccx, /*bad*/copy *path, &dtor.node.body,\n-                         dtor.node.id, None, None, local_def(id));\n-    };\n-\n+pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -2451,63 +2395,20 @@ pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n     vec::append(/*bad*/copy *base, ~[path_name(i.ident)])\n }\n \n-/* If there's already a symbol for the dtor with <id> and substs <substs>,\n-   return it; otherwise, create one and register it, returning it as well */\n-pub fn get_dtor_symbol(ccx: @CrateContext,\n-                       path: path,\n-                       id: ast::node_id,\n-                       substs: Option<@param_substs>)\n-                    -> ~str {\n-    let t = ty::node_id_to_type(ccx.tcx, id);\n-    match ccx.item_symbols.find(&id) {\n-        Some(s) => {\n-            return /*bad*/copy *s;\n-        }\n-        None => { }\n-    }\n-\n-    return if substs.is_none() {\n-        let s = mangle_exported_name(\n-            ccx,\n-            vec::append(path, ~[path_name((ccx.names)(~\"dtor\"))]),\n-            t);\n-        // XXX: Bad copy, use `@str`?\n-        ccx.item_symbols.insert(id, copy s);\n-        s\n-    } else {\n-        // Monomorphizing, so just make a symbol, don't add\n-        // this to item_symbols\n-        match substs {\n-            Some(ss) => {\n-                let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, ss.self_ty, t);\n-                mangle_exported_name(\n-                    ccx,\n-                    vec::append(path,\n-                                ~[path_name((ccx.names)(~\"dtor\"))]),\n-                    mono_ty)\n-            }\n-            None => {\n-                ccx.sess.bug(fmt!(\"get_dtor_symbol: not monomorphizing and \\\n-                                   couldn't find a symbol for dtor %?\", path));\n-            }\n-        }\n-    };\n-}\n-\n pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n     match ccx.item_vals.find(&id) {\n       Some(&v) => v,\n       None => {\n         let mut exprt = false;\n-        let val = match ccx.tcx.items.get_copy(&id) {\n+        let val = match tcx.items.get_copy(&id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(/*bad*/copy *pth,\n                                       ~[path_name(i.ident)]);\n             match i.node {\n               ast::item_const(_, expr) => {\n-                let typ = ty::node_id_to_type(ccx.tcx, i.id);\n+                let typ = ty::node_id_to_type(tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n                 // We need the translated value here, because for enums the\n                 // LLVM type is not fully determined by the Rust type.\n@@ -2566,7 +2467,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                                 ni.attrs)\n                 }\n                 ast::foreign_item_const(*) => {\n-                    let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n+                    let typ = ty::node_id_to_type(tcx, ni.id);\n                     let ident = ccx.sess.parse_sess.interner.get(ni.ident);\n                     let g = do str::as_c_str(*ident) |buf| {\n                         unsafe {\n@@ -2579,28 +2480,6 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                 }\n             }\n           }\n-          ast_map::node_dtor(_, dt, parent_id, pt) => {\n-            /*\n-                Don't just call register_fn, since we don't want to add\n-                the implicit self argument automatically (we want to make sure\n-                it has the right type)\n-            */\n-            // Want parent_id and not id, because id is the dtor's type\n-            let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n-            // This code shouldn't be reached if the class is generic\n-            assert!(!ty::type_has_params(class_ty));\n-            let lldty = T_fn(~[\n-                    T_ptr(T_i8()),\n-                    T_ptr(type_of(ccx, class_ty))\n-                ],\n-                T_nil());\n-            let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n-\n-            /* Make the declaration for the dtor */\n-            let llfn = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n-            lib::llvm::SetLinkage(llfn, lib::llvm::ExternalLinkage);\n-            llfn\n-          }\n \n           ast_map::node_variant(ref v, enm, pth) => {\n             let llfn;\n@@ -2629,7 +2508,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             // Only register the constructor if this is a tuple-like struct.\n             match struct_def.ctor_id {\n                 None => {\n-                    ccx.tcx.sess.bug(~\"attempt to register a constructor of \\\n+                    tcx.sess.bug(~\"attempt to register a constructor of \\\n                                        a non-tuple-like struct\")\n                 }\n                 Some(ctor_id) => {\n@@ -3267,12 +3146,3 @@ pub fn trans_crate(sess: session::Session,\n         return (llmod, link_meta);\n     }\n }\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "c3dc4f1e8eb2bdcf3ea7301299e698710f0a92c3", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1086,13 +1086,3 @@ pub fn AtomicRMW(cx: block, op: AtomicBinOp,\n         llvm::LLVMBuildAtomicRMW(B(cx), op, dst, src, order)\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "d49e8e0969a1f9978faf2b1dd4a5815ac0366f9c", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -190,4 +190,3 @@ pub impl FnType {\n         Store(bcx, llretval, llretptr);\n     }\n }\n-"}, {"sha": "87322393ab9831a05acaf45b894a7569aab3ef76", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -351,9 +351,7 @@ pub fn trans_method_call(in_cx: block,\n                                               origin)\n                 }\n                 None => {\n-                    cx.tcx().sess.span_bug(call_ex.span,\n-                                           ~\"method call expr wasn't in \\\n-                                             method map\")\n+                    cx.tcx().sess.span_bug(call_ex.span, \"method call expr wasn't in method map\")\n                 }\n             }\n         },\n@@ -795,4 +793,3 @@ pub fn trans_arg_expr(bcx: block,\n     debug!(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n     return rslt(bcx, val);\n }\n-"}, {"sha": "5742463174f65eeaebe04577d4281ccc7be1fd2c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -599,4 +599,3 @@ pub fn make_opaque_cbox_free_glue(\n         }\n     }\n }\n-"}, {"sha": "442b5d25c8ba2e5f37dbf26bdd916470d1fec5f7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1545,13 +1545,3 @@ pub fn filename_and_line_num_from_span(bcx: block,\n pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "48c5a96c8e7b228a3db28c2b856ef0ec1d5585ba", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -58,8 +58,7 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,\n-                             ~\"floating point literal doesn't have the right \\\n-                               type\");\n+                             \"floating point literal doesn't have the right type\");\n           }\n         }\n       }\n@@ -271,7 +270,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 if is_float { llvm::LLVMConstFMul(te1, te2) }\n                 else        { llvm::LLVMConstMul(te1, te2) }\n               }\n-              ast::quot   => {\n+              ast::div    => {\n                 if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n                 else if signed { llvm::LLVMConstSDiv(te1, te2) }\n                 else           { llvm::LLVMConstUDiv(te1, te2) }\n@@ -282,7 +281,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 else           { llvm::LLVMConstURem(te1, te2) }\n               }\n               ast::and    |\n-              ast::or     => cx.sess.span_unimpl(e.span, ~\"binop logic\"),\n+              ast::or     => cx.sess.span_unimpl(e.span, \"binop logic\"),\n               ast::bitxor => llvm::LLVMConstXor(te1, te2),\n               ast::bitand => llvm::LLVMConstAnd(te1, te2),\n               ast::bitor  => llvm::LLVMConstOr(te1, te2),\n@@ -296,7 +295,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               ast::le     |\n               ast::ne     |\n               ast::ge     |\n-              ast::gt     => cx.sess.span_unimpl(e.span, ~\"binop comparator\")\n+              ast::gt     => cx.sess.span_unimpl(e.span, \"binop comparator\")\n             }\n           }\n           ast::expr_unary(u, e) => {\n@@ -345,8 +344,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n                   _ => cx.sess.span_bug(index.span,\n-                                        ~\"index is not an integer-constant \\\n-                                          expression\")\n+                                        \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n                   ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n@@ -364,12 +362,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                                                unit_sz))\n                       },\n                       _ => cx.sess.span_bug(base.span,\n-                                            ~\"index-expr base must be \\\n-                                              fixed-size or slice\")\n+                                            \"index-expr base must be fixed-size or slice\")\n                   },\n                   _ =>  cx.sess.span_bug(base.span,\n-                                         ~\"index-expr base must be \\\n-                                           a vector or string type\")\n+                                         \"index-expr base must be a vector or string type\")\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -381,7 +377,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                   // FIXME #3170: report this earlier on in the const-eval\n                   // pass. Reporting here is a bit late.\n                   cx.sess.span_err(e.span,\n-                                   ~\"const index-expr is out of bounds\");\n+                                   \"const index-expr is out of bounds\");\n               }\n               const_get_elt(cx, arr, [iv as c_uint])\n           }\n@@ -455,8 +451,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                       match fs.find(|f| field_ty.ident == f.node.ident) {\n                           Some(ref f) => const_expr(cx, (*f).node.expr),\n                           None => {\n-                              cx.tcx.sess.span_bug(\n-                                  e.span, ~\"missing struct field\");\n+                              cx.tcx.sess.span_bug(e.span, \"missing struct field\");\n                           }\n                       }\n                   });\n@@ -472,8 +467,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               ast::expr_lit(ref lit) => {\n                 match lit.node {\n                   ast::lit_str(*) => { const_expr(cx, sub) }\n-                  _ => { cx.sess.span_bug(e.span,\n-                                          ~\"bad const-slice lit\") }\n+                  _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n               ast::expr_vec(ref es, ast::m_imm) => {\n@@ -488,8 +482,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 let p = const_ptrcast(cx, gv, llunitty);\n                 C_struct(~[p, sz])\n               }\n-              _ => cx.sess.span_bug(e.span,\n-                                    ~\"bad const-slice expr\")\n+              _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n           ast::expr_path(pth) => {\n@@ -521,8 +514,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                     C_null(llty)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(e.span, ~\"expected a const, fn, \\\n-                                               struct, or variant def\")\n+                    cx.sess.span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n                 }\n             }\n           }\n@@ -543,13 +535,12 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                       adt::trans_const(cx, repr, vinfo.disr_val,\n                                        args.map(|a| const_expr(cx, *a)))\n                   }\n-                  _ => cx.sess.span_bug(e.span, ~\"expected a struct or \\\n-                                                  variant def\")\n+                  _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n           ast::expr_paren(e) => { return const_expr(cx, e); }\n           _ => cx.sess.span_bug(e.span,\n-                ~\"bad constant expression type in consts::const_expr\")\n+                  \"bad constant expression type in consts::const_expr\")\n         };\n     }\n }"}, {"sha": "f1192488bddb01334311fbb637f6c33777c2ad4e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -392,4 +392,3 @@ pub fn trans_fail_bounds_check(bcx: block, sp: span,\n     Unreachable(bcx);\n     return bcx;\n }\n-"}, {"sha": "c19650e3b684868a74a3b95869d10952fbd1dfcd", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -696,8 +696,8 @@ pub impl Datum {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n             (None, _) => {\n-                bcx.ccx().sess.span_bug(\n-                    expr.span, ~\"Cannot deref this expression\");\n+                bcx.ccx().sess.span_bug(expr.span,\n+                                        \"Cannot deref this expression\");\n             }\n         }\n     }\n@@ -817,4 +817,3 @@ pub impl DatumBlock {\n         self.datum.to_str(self.ccx())\n     }\n }\n-"}, {"sha": "1e5680aff38174af137db12f23f586c93b063996", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -756,7 +756,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n             }\n         },\n         ty::ty_enum(_did, ref _substs) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for enum NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for enum NYI\")\n         }\n         ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n             let boxed = create_ty(cx, mt.ty, span);\n@@ -782,18 +782,18 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n             create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_rptr(ref _region, ref _mt) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for rptr NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for rptr NYI\")\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = do barefnty.sig.inputs.map |a| { a.ty };\n             let output = barefnty.sig.output;\n             create_fn_ty(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for closure NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for closure NYI\")\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for trait NYI\")\n+            cx.sess.span_bug(span, \"debuginfo for trait NYI\")\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n@@ -860,14 +860,12 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n     let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n       option::Some(&local_mem(v)) => v,\n       option::Some(_) => {\n-        bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                something weird\");\n+        bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\");\n       }\n       option::None => {\n         match bcx.fcx.lllocals.get_copy(&local.node.pat.id) {\n           local_imm(v) => v,\n-          _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                                                     something weird\")\n+          _ => bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\")\n         }\n       }\n     };\n@@ -966,8 +964,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n           ast::item_fn(ref decl, _, _, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n-          _ => fcx.ccx.sess.span_bug(item.span, ~\"create_function: item \\\n-                                                  bound to non-function\")\n+          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n         }\n       }\n       ast_map::node_method(method, _, _) => {\n@@ -979,15 +976,10 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n             ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n-                                     ~\"create_function: \\\n-                                       expected an expr_fn_block here\")\n+                  \"create_function: expected an expr_fn_block here\")\n         }\n       }\n-      ast_map::node_dtor(_, _, did, _) => {\n-        ((dbg_cx.names)(~\"dtor\"), ast_util::dtor_ty(), did.node)\n-      }\n-      _ => fcx.ccx.sess.bug(~\"create_function: unexpected \\\n-                              sort of node\")\n+      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n \n     debug!(\"%?\", ident);"}, {"sha": "6f1dbd8c2fec46c50541b6172680328fc62a7612", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -693,7 +693,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                 }\n                 _ => {\n                     bcx.tcx().sess.span_bug(expr.span,\n-                                            ~\"expr_cast of non-trait\");\n+                                            \"expr_cast of non-trait\");\n                 }\n             }\n         }\n@@ -703,8 +703,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                fmt!(\"trans_rvalue_dps_unadjusted reached \\\n-                      fall-through case: %?\",\n+                fmt!(\"trans_rvalue_dps_unadjusted reached fall-through case: %?\",\n                      expr.node));\n         }\n     }\n@@ -1165,7 +1164,7 @@ fn trans_rec_or_struct(bcx: block,\n                 }\n                 None => {\n                     tcx.sess.span_bug(field.span,\n-                                      ~\"Couldn't find field in struct type\")\n+                                      \"Couldn't find field in struct type\")\n                 }\n             }\n         };\n@@ -1397,7 +1396,7 @@ fn trans_eager_binop(bcx: block,\n         if is_float { FMul(bcx, lhs, rhs) }\n         else { Mul(bcx, lhs, rhs) }\n       }\n-      ast::quot => {\n+      ast::div => {\n         if is_float {\n             FDiv(bcx, lhs, rhs)\n         } else {\n@@ -1440,15 +1439,15 @@ fn trans_eager_binop(bcx: block,\n         } else {\n             if !ty::type_is_scalar(rhs_t) {\n                 bcx.tcx().sess.span_bug(binop_expr.span,\n-                                        ~\"non-scalar comparison\");\n+                                        \"non-scalar comparison\");\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n             ZExt(bcx, cmpr.val, T_i8())\n         }\n       }\n       _ => {\n-        bcx.tcx().sess.span_bug(binop_expr.span, ~\"unexpected binop\");\n+        bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n       }\n     };\n "}, {"sha": "21e29b9ad825963df29f59cc956b442080db2e6e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1080,7 +1080,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?\n-            ccx.sess.span_bug(item.span, ~\"unknown intrinsic\");\n+            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n     build_return(bcx);"}, {"sha": "a35c40b852005d50d33943b7a93e186da140da81", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -394,10 +394,15 @@ pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n \n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n-    let mut bcx = bcx;\n-    let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n-    let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n-    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n+    let bcx = do with_scope(bcx, None, ~\"visitor cleanup\") |bcx| {\n+        let mut bcx = bcx;\n+        let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n+        let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n+        bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n+        // The visitor is a boxed object and needs to be dropped\n+        add_clean(bcx, v, object_ty);\n+        bcx\n+    };\n     build_return(bcx);\n }\n \n@@ -443,11 +448,8 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         // Call the dtor if there is one\n         match ty::ty_dtor(bcx.tcx(), did) {\n             ty::NoDtor => bcx,\n-            ty::LegacyDtor(ref dt_id) => {\n-                trans_struct_drop(bcx, t, v, *dt_id, did, substs, false)\n-            }\n             ty::TraitDtor(ref dt_id) => {\n-                trans_struct_drop(bcx, t, v, *dt_id, did, substs, true)\n+                trans_struct_drop(bcx, t, v, *dt_id, did, substs)\n             }\n         }\n       }\n@@ -461,8 +463,7 @@ pub fn trans_struct_drop(bcx: block,\n                          v0: ValueRef,\n                          dtor_did: ast::def_id,\n                          class_did: ast::def_id,\n-                         substs: &ty::substs,\n-                         take_ref: bool)\n+                         substs: &ty::substs)\n                       -> block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n@@ -484,15 +485,10 @@ pub fn trans_struct_drop(bcx: block,\n         // (self)\n         assert!((params.len() == 2));\n \n-        // If we need to take a reference to the class (because it's using\n-        // the Drop trait), do so now.\n-        let llval;\n-        if take_ref {\n-            llval = alloca(bcx, val_ty(v0));\n-            Store(bcx, v0, llval);\n-        } else {\n-            llval = v0;\n-        }\n+        // Take a reference to the class (because it's using the Drop trait),\n+        // do so now.\n+        let llval = alloca(bcx, val_ty(v0));\n+        Store(bcx, v0, llval);\n \n         let self_arg = PointerCast(bcx, llval, params[1]);\n         let args = ~[C_null(T_ptr(T_i8())), self_arg];\n@@ -534,10 +530,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         let tcx = bcx.tcx();\n         match ty::ty_dtor(tcx, did) {\n           ty::TraitDtor(dtor) => {\n-            trans_struct_drop(bcx, t, v0, dtor, did, substs, true)\n-          }\n-          ty::LegacyDtor(dtor) => {\n-            trans_struct_drop(bcx, t, v0, dtor, did, substs, false)\n+            trans_struct_drop(bcx, t, v0, dtor, did, substs)\n           }\n           ty::NoDtor => {\n             // No dtor? Just the default case\n@@ -549,12 +542,12 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n-        let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n+        let llbox = Load(bcx, GEPi(bcx, v0, [0u, abi::trt_field_box]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n       ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n-        let lluniquevalue = GEPi(bcx, v0, [0, 1]);\n-        let lltydesc = Load(bcx, GEPi(bcx, v0, [0, 2]));\n+        let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n+        let lltydesc = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_tydesc]));\n         call_tydesc_glue_full(bcx, lluniquevalue, lltydesc,\n                               abi::tydesc_field_free_glue, None);\n         bcx\n@@ -613,13 +606,13 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n-        let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n+        let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx\n       }\n       ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n-        let llval = GEPi(bcx, v, [0, 1]);\n-        let lltydesc = Load(bcx, GEPi(bcx, v, [0, 2]));\n+        let llval = GEPi(bcx, v, [0, abi::trt_field_box]);\n+        let lltydesc = Load(bcx, GEPi(bcx, v, [0, abi::trt_field_tydesc]));\n         call_tydesc_glue_full(bcx, llval, lltydesc,\n                               abi::tydesc_field_take_glue, None);\n         bcx"}, {"sha": "e5c6244879d3226b02859137e519b20de2a9b2f6", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 61, "deletions": 66, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -60,75 +60,70 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n             ccx.stats.n_inlines += 1;\n             if translate { trans_item(ccx, item); }\n             local_def(item.id)\n-          }\n-          csearch::found(ast::ii_foreign(item)) => {\n-            ccx.external.insert(fn_id, Some(item.id));\n-            local_def(item.id)\n-          }\n-          csearch::found_parent(parent_id, ast::ii_item(item)) => {\n-            ccx.external.insert(parent_id, Some(item.id));\n-            let mut my_id = 0;\n-            match item.node {\n-              ast::item_enum(_, _) => {\n-                let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n-                let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n-                for vec::each2(*vs_here, *vs_there) |here, there| {\n-                    if there.id == fn_id { my_id = here.id.node; }\n-                    ccx.external.insert(there.id, Some(here.id.node));\n-                }\n+        }\n+        csearch::found(ast::ii_foreign(item)) => {\n+          ccx.external.insert(fn_id, Some(item.id));\n+          local_def(item.id)\n+        }\n+        csearch::found_parent(parent_id, ast::ii_item(item)) => {\n+          ccx.external.insert(parent_id, Some(item.id));\n+          let mut my_id = 0;\n+          match item.node {\n+            ast::item_enum(_, _) => {\n+              let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n+              let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n+              for vec::each2(*vs_here, *vs_there) |here, there| {\n+                  if there.id == fn_id { my_id = here.id.node; }\n+                  ccx.external.insert(there.id, Some(here.id.node));\n               }\n-              _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n-                    non-enum parent\")\n             }\n-            if translate { trans_item(ccx, item); }\n-            local_def(my_id)\n-          }\n-          csearch::found_parent(_, _) => {\n-              ccx.sess.bug(~\"maybe_get_item_ast returned a found_parent \\\n-               with a non-item parent\");\n+            _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n+                  non-enum parent\")\n           }\n-          csearch::found(ast::ii_method(impl_did, mth)) => {\n-            ccx.stats.n_inlines += 1;\n-            ccx.external.insert(fn_id, Some(mth.id));\n-            let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n-            let num_type_params =\n-                impl_tpt.generics.type_param_defs.len() +\n-                mth.generics.ty_params.len();\n-            if translate && num_type_params == 0 {\n-                let llfn = get_item_val(ccx, mth.id);\n-                let path = vec::append(\n-                    ty::item_path(ccx.tcx, impl_did),\n-                    ~[path_name(mth.ident)]);\n-                let self_kind = match mth.self_ty.node {\n-                    ast::sty_static => no_self,\n-                    _ => {\n-                        let self_ty = ty::node_id_to_type(ccx.tcx,\n-                                                          mth.self_id);\n-                        debug!(\"calling inline trans_fn with self_ty %s\",\n-                               ty_to_str(ccx.tcx, self_ty));\n-                        match mth.self_ty.node {\n-                            ast::sty_value => impl_owned_self(self_ty),\n-                            _ => impl_self(self_ty),\n-                        }\n-                    }\n-                };\n-                trans_fn(ccx,\n-                         path,\n-                         &mth.decl,\n-                         &mth.body,\n-                         llfn,\n-                         self_kind,\n-                         None,\n-                         mth.id,\n-                         Some(impl_did),\n-                         []);\n-            }\n-            local_def(mth.id)\n-          }\n-          csearch::found(ast::ii_dtor(ref dtor, _, _, _)) => {\n-              ccx.external.insert(fn_id, Some((*dtor).node.id));\n-              local_def((*dtor).node.id)\n+          if translate { trans_item(ccx, item); }\n+          local_def(my_id)\n+        }\n+        csearch::found_parent(_, _) => {\n+            ccx.sess.bug(~\"maybe_get_item_ast returned a found_parent \\\n+             with a non-item parent\");\n+        }\n+        csearch::found(ast::ii_method(impl_did, mth)) => {\n+          ccx.stats.n_inlines += 1;\n+          ccx.external.insert(fn_id, Some(mth.id));\n+          let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n+          let num_type_params =\n+              impl_tpt.generics.type_param_defs.len() +\n+              mth.generics.ty_params.len();\n+          if translate && num_type_params == 0 {\n+              let llfn = get_item_val(ccx, mth.id);\n+              let path = vec::append(\n+                  ty::item_path(ccx.tcx, impl_did),\n+                  ~[path_name(mth.ident)]);\n+              let self_kind = match mth.self_ty.node {\n+                  ast::sty_static => no_self,\n+                  _ => {\n+                      let self_ty = ty::node_id_to_type(ccx.tcx,\n+                                                        mth.self_id);\n+                      debug!(\"calling inline trans_fn with self_ty %s\",\n+                             ty_to_str(ccx.tcx, self_ty));\n+                      match mth.self_ty.node {\n+                          ast::sty_value => impl_owned_self(self_ty),\n+                          _ => impl_self(self_ty),\n+                      }\n+                  }\n+              };\n+              trans_fn(ccx,\n+                       path,\n+                       &mth.decl,\n+                       &mth.body,\n+                       llfn,\n+                       self_kind,\n+                       None,\n+                       mth.id,\n+                       Some(impl_did),\n+                       []);\n           }\n+          local_def(mth.id)\n+        }\n     };\n }\n-"}, {"sha": "ff9faa24376d902700bcab599598d0451203ec59", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -153,4 +153,3 @@ pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n         _ => cx.sess.bug(~\"static_size_of_enum called on non-enum\")\n     }\n }\n-"}, {"sha": "43cc66c55686714e70a83392b86eb7ee388c1077", "filename": "src/librustc/middle/trans/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -51,4 +51,3 @@ macro_rules! trace(\n         }\n     )\n )\n-"}, {"sha": "934a995b588419706e880453941e74c4f3df420c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -642,14 +642,15 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n            val_str(bcx.ccx().tn, llpair));\n     let llvtable = Load(bcx,\n                       PointerCast(bcx,\n-                                  GEPi(bcx, llpair, [0u, 0u]),\n+                                  GEPi(bcx, llpair,\n+                                       [0u, abi::trt_field_vtable]),\n                                   T_ptr(T_ptr(T_vtable()))));\n \n     // Load the box from the @Trait pair and GEP over the box header if\n     // necessary:\n     let mut llself;\n     debug!(\"(translating trait callee) loading second index from pair\");\n-    let llbox = Load(bcx, GEPi(bcx, llpair, [0u, 1u]));\n+    let llbox = Load(bcx, GEPi(bcx, llpair, [0u, abi::trt_field_box]));\n \n     // Munge `llself` appropriately for the type of `self` in the method.\n     let self_mode;\n@@ -850,27 +851,30 @@ pub fn trans_trait_cast(bcx: block,\n \n     match store {\n         ty::RegionTraitStore(_) | ty::BoxTraitStore => {\n-            let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n-            // Just store the pointer into the pair.\n+            let mut llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n+            // Just store the pointer into the pair. (Region/borrowed\n+            // and boxed trait objects are represented as pairs, and\n+            // have no type descriptor field.)\n             llboxdest = PointerCast(bcx,\n                                     llboxdest,\n                                     T_ptr(type_of(bcx.ccx(), v_ty)));\n             bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n         }\n         ty::UniqTraitStore => {\n-            // Translate the uniquely-owned value into the second element of\n-            // the triple. (The first element is the vtable.)\n-            let mut llvaldest = GEPi(bcx, lldest, [0, 1]);\n+            // Translate the uniquely-owned value in the\n+            // triple. (Unique trait objects are represented as\n+            // triples.)\n+            let mut llvaldest = GEPi(bcx, lldest, [0, abi::trt_field_box]);\n             llvaldest = PointerCast(bcx,\n                                     llvaldest,\n                                     T_ptr(type_of(bcx.ccx(), v_ty)));\n             bcx = expr::trans_into(bcx, val, SaveIn(llvaldest));\n \n-            // Get the type descriptor of the wrapped value and store it into\n-            // the third element of the triple as well.\n+            // Get the type descriptor of the wrapped value and store\n+            // it in the triple as well.\n             let tydesc = get_tydesc(bcx.ccx(), v_ty);\n             glue::lazily_emit_all_tydesc_glue(bcx.ccx(), tydesc);\n-            let lltydescdest = GEPi(bcx, lldest, [0, 2]);\n+            let lltydescdest = GEPi(bcx, lldest, [0, abi::trt_field_tydesc]);\n             Store(bcx, tydesc.tydesc, lltydescdest);\n         }\n     }\n@@ -880,7 +884,7 @@ pub fn trans_trait_cast(bcx: block,\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n     Store(bcx, vtable, PointerCast(bcx,\n-                                   GEPi(bcx, lldest, [0u, 0u]),\n+                                   GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n                                    T_ptr(val_ty(vtable))));\n \n     bcx"}, {"sha": "6e25064186941a5b13219b0691f451330ec09964", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -13,7 +13,7 @@ use driver::session;\n use lib::llvm::ValueRef;\n use middle::trans::base::{get_insn_ctxt};\n use middle::trans::base::{set_inline_hint_if_appr, set_inline_hint};\n-use middle::trans::base::{trans_enum_variant, trans_struct_dtor};\n+use middle::trans::base::{trans_enum_variant};\n use middle::trans::base::{trans_fn, decl_internal_cdecl_fn};\n use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n@@ -35,7 +35,6 @@ use syntax::ast_map;\n use syntax::ast_map::path_name;\n use syntax::ast_util::local_def;\n use syntax::opt_vec;\n-use syntax::parse::token::special_idents;\n use syntax::abi::AbiSet;\n \n pub fn monomorphic_fn(ccx: @CrateContext,\n@@ -118,8 +117,6 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // Foreign externs don't have to be monomorphized.\n         return (get_item_val(ccx, fn_id.node), true);\n       }\n-      ast_map::node_dtor(_, dtor, _, pt) =>\n-          (pt, special_idents::dtor, dtor.span),\n       ast_map::node_trait_method(@ast::provided(m), _, pt) => {\n         (pt, m.ident, m.span)\n       }\n@@ -168,7 +165,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     // causing an infinite expansion.\n     if depth > 30 {\n         ccx.sess.span_fatal(\n-            span, ~\"overly deep expansion of inlined function\");\n+            span, \"overly deep expansion of inlined function\");\n     }\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n@@ -248,16 +245,6 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         meth::trans_method(ccx, pt, mth, psubsts, None, d, impl_did);\n         d\n       }\n-      ast_map::node_dtor(_, dtor, _, pt) => {\n-        let parent_id = match ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n-                                              dtor.node.self_id)) {\n-                Some(did) => did,\n-                None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n-                                                            dtor\")\n-        };\n-        trans_struct_dtor(ccx, /*bad*/copy *pt, &dtor.node.body,\n-          dtor.node.id, psubsts, Some(hash_id), parent_id)\n-      }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy mth.attrs, d);"}, {"sha": "4d5a7a72a8d5ca7ddb668b619a6c9e4e4bfe5528", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -134,22 +134,11 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n             }\n         }\n       }\n-      item_struct(ref struct_def, ref generics) => {\n+      item_struct(ref struct_def, _) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n             let cx = &mut *cx; // NOTE reborrow @mut\n             cx.rmap.insert(ctor_id);\n         }\n-        for struct_def.dtor.each |dtor| {\n-            {\n-                let cx = &mut *cx; // NOTE reborrow @mut\n-                cx.rmap.insert(dtor.node.id);\n-            }\n-            if generics.ty_params.len() > 0u ||\n-                attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n-            {\n-                traverse_inline_body(cx, &dtor.node.body);\n-            }\n-        }\n       }\n       item_ty(t, _) => {\n         traverse_ty(t, cx,\n@@ -193,11 +182,13 @@ fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(&d) => {\n-                  traverse_def_id(cx, def_id_of_def(d));\n+                    traverse_def_id(cx, def_id_of_def(d));\n                 }\n-                None      => cx.tcx.sess.span_bug(e.span, fmt!(\"Unbound node \\\n-                  id %? while traversing %s\", e.id,\n-                  expr_to_str(e, cx.tcx.sess.intr())))\n+                None => cx.tcx.sess.span_bug(\n+                    e.span,\n+                    fmt!(\"Unbound node id %? while traversing %s\",\n+                         e.id,\n+                         expr_to_str(e, cx.tcx.sess.intr())))\n             }\n           }\n           expr_field(_, _, _) => {\n@@ -254,9 +245,6 @@ fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n             visit_item: |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n                 match i.node {\n-                    item_struct(sdef, _) if sdef.dtor.is_some() => {\n-                        traverse_public_item(cx, i);\n-                    }\n                     item_impl(*) => {\n                         traverse_public_item(cx, i);\n                     }\n@@ -266,4 +254,3 @@ fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n             ..*visit::default_visitor()\n         }));\n }\n-"}, {"sha": "9e1f10467e34652d09cf26fc08a5137dd132b72d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -405,4 +405,3 @@ pub fn ast_purity_constant(purity: ast::purity) -> uint {\n         ast::extern_fn => 3u\n     }\n }\n-"}, {"sha": "6ff9e1cfc57175466a2af747b4ea3e06aa086ce8", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -74,4 +74,3 @@ pub fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n     add_u16(&mut *dest, vec::len(src) as u16);\n     *dest += src;\n }\n-"}, {"sha": "e8075c1f2ad1dbc380782c095f90b36c25e7ee2d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -469,7 +469,7 @@ pub fn write_content(bcx: block,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(content_expr.span,\n-                                    ~\"Unexpected evec content\");\n+                                    \"Unexpected evec content\");\n         }\n     }\n }\n@@ -503,7 +503,7 @@ pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n             ty::eval_repeat_count(bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n-                                     ~\"Unexpected evec content\")\n+                                     \"Unexpected evec content\")\n     }\n }\n \n@@ -594,13 +594,3 @@ pub fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n     let dataptr = get_dataptr(bcx, body_ptr);\n     return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "94ef33e45bbe9d6df3efc67a69395b3b74e7e0ca", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -157,9 +157,6 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n       }\n-      ast_map::node_dtor(_, ref dtor, _, _) => {\n-        handle_body(cx, &dtor.node.body);\n-      }\n       ast_map::node_struct_ctor(*) => {\n         // Similarly to node_variant, this monomorphized function just uses\n         // the representations of all of its type parameters.\n@@ -391,4 +388,3 @@ pub fn handle_body(cx: Context, body: &blk) {\n     });\n     (v.visit_block)(body, cx, v);\n }\n-"}, {"sha": "03704afdb861f8b32770c001314bc83cb4c4d675", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 140, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -33,7 +33,7 @@ use core::to_bytes;\n use core::hashmap::{HashMap, HashSet};\n use std::smallintmap::SmallIntMap;\n use syntax::ast::*;\n-use syntax::ast_util::{is_local, local_def};\n+use syntax::ast_util::is_local;\n use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::span;\n@@ -1257,16 +1257,6 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n-// Converts s to its machine type equivalent\n-pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n-    match get(t).sty {\n-      ty_int(ast::ty_i) => ty_int(cfg.int_type),\n-      ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n-      ty_float(ast::ty_f) => ty_float(cfg.float_type),\n-      ref s => (/*bad*/copy *s)\n-    }\n-}\n-\n pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1829,15 +1819,6 @@ pub impl TypeContents {\n         if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_VEC}\n     }\n \n-    fn is_safe_for_default_mode(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nondefault_mode(cx))\n-    }\n-\n-    fn nondefault_mode(cx: ctxt) -> TypeContents {\n-        let tc = TypeContents::nonimplicitly_copyable(cx);\n-        tc + TC_BIG + TC_OWNED_VEC // disregard cx.vecs_implicitly_copyable\n-    }\n-\n     fn needs_drop(&self, cx: ctxt) -> bool {\n         let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n         self.intersects(tc)\n@@ -1897,9 +1878,6 @@ static TC_MUTABLE: TypeContents =          TypeContents{bits:0b000010000000};\n /// Mutable content, whether owned or by ref\n static TC_ONCE_CLOSURE: TypeContents =     TypeContents{bits:0b000100000000};\n \n-/// Something we estimate to be \"big\"\n-static TC_BIG: TypeContents =              TypeContents{bits:0b001000000000};\n-\n /// An enum with no variants.\n static TC_EMPTY_ENUM: TypeContents =       TypeContents{bits:0b010000000000};\n \n@@ -2120,10 +2098,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n         };\n \n-        if type_size(cx, ty) > 4 {\n-            result = result + TC_BIG;\n-        }\n-\n         cache.insert(ty_id, result);\n         return result;\n     }\n@@ -2199,68 +2173,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         debug!(\"result = %s\", r.to_str());\n         return r;\n     }\n-\n-    /// gives a rough estimate of how much space it takes to represent\n-    /// an instance of `ty`.  Used for the mode transition.\n-    fn type_size(cx: ctxt, ty: t) -> uint {\n-        match get(ty).sty {\n-          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n-          ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n-          ty_evec(_, vstore_box) | ty_estr(vstore_box) => {\n-            1\n-          }\n-\n-          ty_evec(_, vstore_slice(_)) |\n-          ty_estr(vstore_slice(_)) |\n-          ty_bare_fn(*) |\n-          ty_closure(*) => {\n-            2\n-          }\n-\n-          ty_evec(t, vstore_fixed(n)) => {\n-            type_size(cx, t.ty) * n\n-          }\n-\n-          ty_estr(vstore_fixed(n)) => {\n-            n\n-          }\n-\n-          ty_struct(did, ref substs) => {\n-            let flds = struct_fields(cx, did, substs);\n-            flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n-          }\n-\n-          ty_tup(ref tys) => {\n-            tys.foldl(0, |s, t| *s + type_size(cx, *t))\n-          }\n-\n-          ty_enum(did, ref substs) => {\n-            let variants = substd_enum_variants(cx, did, substs);\n-            variants.foldl( // find max size of any variant\n-                0,\n-                |m, v| uint::max(\n-                    *m,\n-                    // find size of this variant:\n-                    v.args.foldl(0, |s, a| *s + type_size(cx, *a))))\n-          }\n-\n-          ty_param(_) | ty_self(_) => {\n-            1\n-          }\n-\n-          ty_infer(_) => {\n-            cx.sess.bug(~\"Asked to compute kind of a type variable\");\n-          }\n-          ty_type => 1,\n-          ty_opaque_closure_ptr(_) => 1,\n-          ty_opaque_box => 1,\n-          ty_unboxed_vec(_) => 10,\n-          ty_err => {\n-            cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n-          }\n-        }\n-    }\n }\n \n pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n@@ -2520,12 +2432,15 @@ pub fn type_is_enum(ty: t) -> bool {\n // constructors\n pub fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     match get(ty).sty {\n-      ty_enum(did, _) => {\n-        let variants = enum_variants(cx, did);\n-        let some_n_ary = vec::any(*variants, |v| vec::len(v.args) > 0u);\n-        return !some_n_ary;\n-      }\n-      _ => return false\n+        ty_enum(did, _) => {\n+            let variants = enum_variants(cx, did);\n+            if variants.len() == 0 {\n+                false\n+            } else {\n+                variants.all(|v| v.args.len() == 0)\n+            }\n+        }\n+        _ => false\n     }\n }\n \n@@ -3294,7 +3209,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_mac(*) => {\n             tcx.sess.span_bug(\n                 expr.span,\n-                ~\"macro expression remains after expansion\");\n+                \"macro expression remains after expansion\");\n         }\n     }\n }\n@@ -3761,7 +3676,6 @@ pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n \n pub enum DtorKind {\n     NoDtor,\n-    LegacyDtor(def_id),\n     TraitDtor(def_id)\n }\n \n@@ -3781,28 +3695,8 @@ pub impl DtorKind {\n    Otherwise return none. */\n pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     match cx.destructor_for_type.find(&struct_id) {\n-        Some(&method_def_id) => return TraitDtor(method_def_id),\n-        None => {}  // Continue.\n-    }\n-\n-    if is_local(struct_id) {\n-       match cx.items.find(&struct_id.node) {\n-           Some(&ast_map::node_item(@ast::item {\n-               node: ast::item_struct(@ast::struct_def { dtor: Some(ref dtor),\n-                                                         _ },\n-                                      _),\n-               _\n-           }, _)) =>\n-               LegacyDtor(local_def((*dtor).node.id)),\n-           _ =>\n-               NoDtor\n-       }\n-    }\n-    else {\n-      match csearch::struct_dtor(cx.sess.cstore, struct_id) {\n+        Some(&method_def_id) => TraitDtor(method_def_id),\n         None => NoDtor,\n-        Some(did) => LegacyDtor(did),\n-      }\n     }\n }\n \n@@ -3852,11 +3746,6 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n                             ast_map::path_name((*variant).node.name))\n           }\n \n-          ast_map::node_dtor(_, _, _, path) => {\n-            vec::append_one(/*bad*/copy *path, ast_map::path_name(\n-                syntax::parse::token::special_idents::literally_dtor))\n-          }\n-\n           ast_map::node_struct_ctor(_, item, path) => {\n             vec::append_one(/*bad*/copy *path, ast_map::path_name(item.ident))\n           }\n@@ -4167,7 +4056,7 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ast::add => opcat_add,\n           ast::subtract => opcat_sub,\n           ast::mul => opcat_mult,\n-          ast::quot => opcat_mult,\n+          ast::div => opcat_mult,\n           ast::rem => opcat_mult,\n           ast::and => opcat_logic,\n           ast::or => opcat_logic,\n@@ -4300,27 +4189,27 @@ pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n         const_eval::const_uint(count) => return count as uint,\n         const_eval::const_float(count) => {\n             tcx.sess.span_err(count_expr.span,\n-                              ~\"expected signed or unsigned integer for \\\n-                                repeat count but found float\");\n+                              \"expected signed or unsigned integer for \\\n+                               repeat count but found float\");\n             return count as uint;\n         }\n         const_eval::const_str(_) => {\n             tcx.sess.span_err(count_expr.span,\n-                              ~\"expected signed or unsigned integer for \\\n-                                repeat count but found string\");\n+                              \"expected signed or unsigned integer for \\\n+                               repeat count but found string\");\n             return 0;\n         }\n         const_eval::const_bool(_) => {\n             tcx.sess.span_err(count_expr.span,\n-                              ~\"expected signed or unsigned integer for \\\n-                                repeat count but found boolean\");\n+                              \"expected signed or unsigned integer for \\\n+                               repeat count but found boolean\");\n             return 0;\n         }\n       },\n       Err(*) => {\n         tcx.sess.span_err(count_expr.span,\n-                          ~\"expected constant integer for repeat count \\\n-                            but found variable\");\n+                          \"expected constant integer for repeat count \\\n+                           but found variable\");\n         return 0;\n       }\n     }\n@@ -4428,11 +4317,3 @@ pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n     (trait_ref,\n      mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore, ast::m_imm))\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "7ef77646f5203a95d1267e469bd3dbde9e9a4dce", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -291,10 +291,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                             ty::vstore_fixed(*) => {\n                                 tcx.sess.span_err(\n                                     path.span,\n-                                    ~\"@trait, ~trait or &trait \\\n-                                      are the only supported \\\n-                                      forms of casting-to-\\\n-                                      trait\");\n+                                    \"@trait, ~trait or &trait are the only supported \\\n+                                     forms of casting-to-trait\");\n                                 ty::BoxTraitStore\n                             }\n                         };\n@@ -321,15 +319,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n             if path.types.len() > 0u {\n                 tcx.sess.span_err(\n                     path.span,\n-                    ~\"type parameters are not allowed on this type\");\n+                    \"type parameters are not allowed on this type\");\n             }\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n             if path.rp.is_some() {\n                 tcx.sess.span_err(\n                     path.span,\n-                    ~\"region parameters are not allowed on this type\");\n+                    \"region parameters are not allowed on this type\");\n             }\n         }\n     }\n@@ -339,9 +337,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     match tcx.ast_ty_to_ty_cache.find(&ast_ty.id) {\n       Some(&ty::atttce_resolved(ty)) => return ty,\n       Some(&ty::atttce_unresolved) => {\n-        tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n-                                          insert an enum in the cycle, \\\n-                                          if this is desired\");\n+        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type; \\\n+                                          insert an enum in the cycle, if this is desired\");\n       }\n       None => { /* go on */ }\n     }\n@@ -359,11 +356,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                    |tmt| ty::mk_uniq(tcx, tmt))\n       }\n       ast::ty_vec(ref mt) => {\n-        tcx.sess.span_err(ast_ty.span,\n-                          ~\"bare `[]` is not a type\");\n+        tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n-        ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt),\n-                    ty::vstore_uniq)\n+        ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), ty::vstore_uniq)\n       }\n       ast::ty_ptr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n@@ -434,7 +429,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n               }\n               ast::ty_str => {\n                 tcx.sess.span_err(ast_ty.span,\n-                                  ~\"bare `str` is not a type\");\n+                                  \"bare `str` is not a type\");\n                 // return /something/ so they can at least get more errors\n                 ty::mk_estr(tcx, ty::vstore_uniq)\n               }\n@@ -454,7 +449,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n           }\n           _ => {\n             tcx.sess.span_fatal(ast_ty.span,\n-                                ~\"found type name used as a variable\");\n+                                \"found type name used as a variable\");\n           }\n         }\n       }\n@@ -470,7 +465,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n                             ty::vstore_fixed(i as uint)),\n               _ => {\n                 tcx.sess.span_fatal(\n-                    ast_ty.span, ~\"expected constant expr for vector length\");\n+                    ast_ty.span, \"expected constant expr for vector length\");\n               }\n             }\n           }\n@@ -489,11 +484,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         // routine.\n         self.tcx().sess.span_bug(\n             ast_ty.span,\n-            ~\"found `ty_infer` in unexpected place\");\n+            \"found `ty_infer` in unexpected place\");\n       }\n       ast::ty_mac(_) => {\n         tcx.sess.span_bug(ast_ty.span,\n-                          ~\"found `ty_mac` in unexpected place\");\n+                          \"found `ty_mac` in unexpected place\");\n       }\n     };\n "}, {"sha": "40c5df7b7683229b00474670040a7b53e330c6e8", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 165, "deletions": 121, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -114,36 +114,52 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n         ty::ty_enum(_, ref expected_substs) => {\n             // Lookup the enum and variant def ids:\n             let v_def = lookup_def(pcx.fcx, pat.span, pat.id);\n-            let (enm, var) = ast_util::variant_def_ids(v_def);\n-\n-            // Assign the pattern the type of the *enum*, not the variant.\n-            let enum_tpt = ty::lookup_item_type(tcx, enm);\n-            instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n-\n-            // check that the type of the value being matched is a subtype\n-            // of the type of the pattern:\n-            let pat_ty = fcx.node_ty(pat.id);\n-            demand::subtype(fcx, pat.span, expected, pat_ty);\n-\n-            // Get the expected types of the arguments.\n-            arg_types = {\n-                let vinfo =\n-                    ty::enum_variant_with_id(tcx, enm, var);\n-                let var_tpt = ty::lookup_item_type(tcx, var);\n-                vinfo.args.map(|t| {\n-                    if var_tpt.generics.type_param_defs.len() ==\n-                        expected_substs.tps.len()\n-                    {\n-                        ty::subst(tcx, expected_substs, *t)\n-                    }\n-                    else {\n-                        *t // In this case, an error was already signaled\n-                           // anyway\n-                    }\n-                })\n-            };\n-\n-            kind_name = \"variant\";\n+            match ast_util::variant_def_ids(v_def) {\n+                Some((enm, var)) => {\n+                    // Assign the pattern the type of the *enum*, not the variant.\n+                    let enum_tpt = ty::lookup_item_type(tcx, enm);\n+                    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n+\n+                    // check that the type of the value being matched is a subtype\n+                    // of the type of the pattern:\n+                    let pat_ty = fcx.node_ty(pat.id);\n+                    demand::subtype(fcx, pat.span, expected, pat_ty);\n+\n+                    // Get the expected types of the arguments.\n+                    arg_types = {\n+                        let vinfo =\n+                            ty::enum_variant_with_id(tcx, enm, var);\n+                        let var_tpt = ty::lookup_item_type(tcx, var);\n+                        vinfo.args.map(|t| {\n+                            if var_tpt.generics.type_param_defs.len() ==\n+                                expected_substs.tps.len()\n+                            {\n+                                ty::subst(tcx, expected_substs, *t)\n+                            }\n+                            else {\n+                                *t // In this case, an error was already signaled\n+                                    // anyway\n+                            }\n+                        })\n+                    };\n+\n+                    kind_name = \"variant\";\n+                }\n+                None => {\n+                    let resolved_expected =\n+                        fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+                    fcx.infcx().type_error_message_str(pat.span,\n+                                                       |actual| {\n+                        fmt!(\"mismatched types: expected `%s` but found %s\",\n+                             resolved_expected, actual)},\n+                             ~\"a structure pattern\",\n+                             None);\n+                    fcx.write_error(pat.id);\n+                    kind_name = \"[error]\";\n+                    arg_types = (copy subpats).get_or_default(~[]).map(|_|\n+                                                                       ty::mk_err());\n+                }\n+            }\n         }\n         ty::ty_struct(struct_def_id, ref expected_substs) => {\n             // Lookup the struct ctor def id\n@@ -173,11 +189,18 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n             kind_name = \"structure\";\n         }\n         _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                fmt!(\"mismatched types: expected `%s` but found enum or \\\n-                      structure\",\n-                     fcx.infcx().ty_to_str(expected)));\n+            let resolved_expected =\n+                fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+            fcx.infcx().type_error_message_str(pat.span,\n+                                               |actual| {\n+                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                         resolved_expected, actual)},\n+                    ~\"an enum or structure pattern\",\n+                    None);\n+            fcx.write_error(pat.id);\n+            kind_name = \"[error]\";\n+            arg_types = (copy subpats).get_or_default(~[]).map(|_|\n+                                                               ty::mk_err());\n         }\n     }\n \n@@ -195,8 +218,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = fmt!(\"this pattern has %u field%s, but the corresponding \\\n-                          %s has %u field%s\",\n+            let s = fmt!(\"this pattern has %u field%s, but the corresponding %s has %u field%s\",\n                          subpats_len,\n                          if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n                          kind_name,\n@@ -214,13 +236,12 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n             }\n         }\n     } else if subpats_len > 0 {\n-        tcx.sess.span_err\n-            (pat.span, fmt!(\"this pattern has %u field%s, but the \\\n-                             corresponding %s has no fields\",\n-                            subpats_len,\n-                            if subpats_len == 1u { ~\"\" }\n-                            else { ~\"s\" },\n-                            kind_name));\n+        tcx.sess.span_err(pat.span,\n+                          fmt!(\"this pattern has %u field%s, but the corresponding %s has no \\\n+                                fields\",\n+                               subpats_len,\n+                               if subpats_len == 1u { \"\" } else { \"s\" },\n+                               kind_name));\n         error_happened = true;\n     }\n \n@@ -310,20 +331,19 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n         Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n-                              fmt!(\"mismatched types: expected `%s` but \\\n-                                    found `%s`\",\n+                              fmt!(\"mismatched types: expected `%s` but found `%s`\",\n                                    fcx.infcx().ty_to_str(expected),\n                                    name));\n         }\n         _ => {\n-            tcx.sess.span_bug(span, ~\"resolve didn't write in class\");\n+            tcx.sess.span_bug(span, \"resolve didn't write in class\");\n         }\n     }\n \n     // Forbid pattern-matching structs with destructors.\n     if ty::has_dtor(tcx, class_id) {\n-        tcx.sess.span_err(span, ~\"deconstructing struct not allowed in \\\n-                                  pattern (it has a destructor)\");\n+        tcx.sess.span_err(span, \"deconstructing struct not allowed in pattern \\\n+                                 (it has a destructor)\");\n     }\n \n     check_struct_pat_fields(pcx, span, path, fields, class_fields, class_id,\n@@ -361,7 +381,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                    name));\n         }\n         _ => {\n-            tcx.sess.span_bug(span, ~\"resolve didn't write in variant\");\n+            tcx.sess.span_bug(span, \"resolve didn't write in variant\");\n         }\n     }\n }\n@@ -395,10 +415,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n-            tcx.sess.span_err(pat.span, ~\"non-numeric type used in range\");\n+            tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n         } else if !valid_range_bounds(fcx.ccx, begin, end) {\n-            tcx.sess.span_err(begin.span, ~\"lower range bound must be less \\\n-                                           than upper\");\n+            tcx.sess.span_err(begin.span, \"lower range bound must be less than upper\");\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n@@ -467,9 +486,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n             _ => {\n                 tcx.sess.span_err(pat.span,\n-                                    fmt!(\"mismatched types: expected `%s` \\\n-                                          but found struct\",\n-                                         fcx.infcx().ty_to_str(expected)));\n+                                  fmt!(\"mismatched types: expected `%s` but found struct\",\n+                                       fcx.infcx().ty_to_str(expected)));\n                 error_happened = true;\n             }\n         }\n@@ -484,74 +502,44 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_tup(ref elts) => {\n         let s = structure_of(fcx, pat.span, expected);\n-        let ex_elts = match s {\n-          ty::ty_tup(ref elts) => elts,\n-          _ => {\n-            tcx.sess.span_fatal\n-                (pat.span,\n-                 fmt!(\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.infcx().ty_to_str(expected)));\n-          }\n-        };\n         let e_count = elts.len();\n-        if e_count != ex_elts.len() {\n-            tcx.sess.span_fatal\n-                (pat.span, fmt!(\"mismatched types: expected a tuple \\\n-                      with %u fields, found one with %u \\\n-                      fields\", ex_elts.len(), e_count));\n-        }\n-        let mut i = 0u;\n-        for elts.each |elt| {\n-            check_pat(pcx, *elt, ex_elts[i]);\n-            i += 1u;\n+        match s {\n+            ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n+                for elts.eachi |i, elt| {\n+                    check_pat(pcx, *elt, ex_elts[i]);\n+                }\n+                fcx.write_ty(pat.id, expected);\n+            }\n+            _ => {\n+                for elts.each |elt| {\n+                    check_pat(pcx, *elt, ty::mk_err());\n+                }\n+                let actual = ty::mk_tup(tcx, elts.map(|pat_var| {\n+                    fcx.node_ty(pat_var.id)\n+                }));\n+                // use terr_tuple_size if both types are tuples\n+                let type_error = match s {\n+                    ty::ty_tup(ref ex_elts) =>\n+                        ty::terr_tuple_size(ty::expected_found{expected: ex_elts.len(),\n+                                                           found: e_count}),\n+                    _ => ty::terr_mismatch\n+                };\n+                fcx.infcx().report_mismatched_types(pat.span,\n+                                                    expected,\n+                                                    actual,\n+                                                    &type_error);\n+                fcx.write_error(pat.id);\n+            }\n         }\n-\n-        fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_box(inner) => {\n-        match structure_of(fcx, pat.span, expected) {\n-          ty::ty_box(e_inner) => {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected `\" +\n-                fcx.infcx().ty_to_str(expected) +\n-                ~\"` found box\");\n-          }\n-        }\n+          check_pointer_pat(pcx, Managed, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_uniq(inner) => {\n-        match structure_of(fcx, pat.span, expected) {\n-          ty::ty_uniq(e_inner) => {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected `\" +\n-                fcx.infcx().ty_to_str(expected) +\n-                ~\"` found uniq\");\n-          }\n-        }\n+          check_pointer_pat(pcx, Owned, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_region(inner) => {\n-        match structure_of(fcx, pat.span, expected) {\n-          ty::ty_rptr(_, e_inner) => {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected `\" +\n-                fcx.infcx().ty_to_str(expected) +\n-                ~\"` found borrowed pointer\");\n-          }\n-        }\n+          check_pointer_pat(pcx, Borrowed, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         let default_region_var =\n@@ -575,11 +563,25 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             (mt, default_region_var)\n           },\n           _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                fmt!(\"mismatched type: expected `%s` but found vector\",\n-                     fcx.infcx().ty_to_str(expected))\n-            );\n+              for before.each |&elt| {\n+                  check_pat(pcx, elt, ty::mk_err());\n+              }\n+              for slice.each |&elt| {\n+                  check_pat(pcx, elt, ty::mk_err());\n+              }\n+              for after.each |&elt| {\n+                  check_pat(pcx, elt, ty::mk_err());\n+              }\n+              let resolved_expected =\n+                  fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+              fcx.infcx().type_error_message_str(pat.span,\n+                  |actual| {\n+                      fmt!(\"mismatched types: expected `%s` but found %s\",\n+                           resolved_expected, actual)},\n+                                                 ~\"a vector pattern\",\n+                                                 None);\n+              fcx.write_error(pat.id);\n+              return;\n           }\n         };\n         for before.each |elt| {\n@@ -603,3 +605,45 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     }\n }\n \n+// Helper function to check @, ~ and & patterns\n+pub fn check_pointer_pat(pcx: &pat_ctxt,\n+                         pointer_kind: PointerKind,\n+                         inner: @ast::pat,\n+                         pat_id: ast::node_id,\n+                         span: span,\n+                         expected: ty::t) {\n+    let fcx = pcx.fcx;\n+    let check_inner: &fn(ty::mt) = |e_inner| {\n+        check_pat(pcx, inner, e_inner.ty);\n+        fcx.write_ty(pat_id, expected);\n+    };\n+    match structure_of(fcx, span, expected) {\n+        ty::ty_box(e_inner) if pointer_kind == Managed => {\n+            check_inner(e_inner);\n+        }\n+        ty::ty_uniq(e_inner) if pointer_kind == Owned => {\n+            check_inner(e_inner);\n+        }\n+        ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n+            check_inner(e_inner);\n+        }\n+        _ => {\n+            check_pat(pcx, inner, ty::mk_err());\n+            let resolved_expected =\n+                fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+            fcx.infcx().type_error_message_str(span, |actual| {\n+                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                         resolved_expected, actual)},\n+                                               fmt!(\"%s pattern\", match pointer_kind {\n+                                                   Managed => \"an @-box\",\n+                                                   Owned => \"a ~-box\",\n+                                                   Borrowed => \"an &-pointer\"\n+                                               }),\n+                    None);\n+            fcx.write_error(pat_id);\n+          }\n+    }\n+}\n+\n+#[deriving(Eq)]\n+enum PointerKind { Managed, Owned, Borrowed }"}, {"sha": "3fa551e4b057a15905ec2eb9ca7a3ac013e29805", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -66,5 +66,3 @@ pub fn coerce(fcx: @mut FnCtxt,\n       }\n     }\n }\n-\n-"}, {"sha": "08398f9880a402cb902a85bf283ff6ce88ce6d1a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -876,7 +876,7 @@ pub impl<'self> LookupContext<'self> {\n         if relevant_candidates.len() > 1 {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                ~\"multiple applicable methods in scope\");\n+                \"multiple applicable methods in scope\");\n             for uint::range(0, relevant_candidates.len()) |idx| {\n                 self.report_candidate(idx, &relevant_candidates[idx].origin);\n             }\n@@ -987,12 +987,12 @@ pub impl<'self> LookupContext<'self> {\n             } else if num_method_tps == 0u {\n                 tcx.sess.span_err(\n                     self.expr.span,\n-                    ~\"this method does not take type parameters\");\n+                    \"this method does not take type parameters\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else if num_supplied_tps != num_method_tps {\n                 tcx.sess.span_err(\n                     self.expr.span,\n-                    ~\"incorrect number of type \\\n+                    \"incorrect number of type \\\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n@@ -1085,14 +1085,14 @@ pub impl<'self> LookupContext<'self> {\n         if ty::type_has_self(method_fty) {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                ~\"cannot call a method whose type contains a \\\n-                  self-type through a boxed trait\");\n+                \"cannot call a method whose type contains a \\\n+                 self-type through a boxed trait\");\n         }\n \n         if candidate.method_ty.generics.has_type_params() {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n-                ~\"cannot call a generic method through a boxed trait\");\n+                \"cannot call a generic method through a boxed trait\");\n         }\n     }\n \n@@ -1112,7 +1112,7 @@ pub impl<'self> LookupContext<'self> {\n \n         if bad {\n             self.tcx().sess.span_err(self.expr.span,\n-                                     ~\"explicit call to destructor\");\n+                                     \"explicit call to destructor\");\n         }\n     }\n "}, {"sha": "5357d092a9077563cc5d852adb4aae26b8ca616e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 76, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -542,45 +542,20 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         let (id, sp) = *p;\n         let orig_sp = field_names.find(&id).map_consume(|x| *x);\n         match orig_sp {\n-          Some(orig_sp) => {\n-            tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n-                                   name %s in record type declaration\",\n-                                        *tcx.sess.str_of(id)));\n-            tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n-                                          this field occurred here\");\n-            break;\n-          }\n-          None => {\n-            field_names.insert(id, sp);\n-          }\n+            Some(orig_sp) => {\n+                tcx.sess.span_err(sp, fmt!(\"Duplicate field name %s in record type declaration\",\n+                                           *tcx.sess.str_of(id)));\n+                tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n+                break;\n+            }\n+            None => {\n+                field_names.insert(id, sp);\n+            }\n         }\n     }\n }\n \n-pub fn check_struct(ccx: @mut CrateCtxt,\n-                    struct_def: @ast::struct_def,\n-                    id: ast::node_id,\n-                    span: span) {\n-    let tcx = ccx.tcx;\n-    let self_ty = ty::node_id_to_type(tcx, id);\n-\n-    for struct_def.dtor.each |dtor| {\n-        let class_t = SelfInfo {\n-            self_ty: self_ty,\n-            self_id: dtor.node.self_id,\n-            span: dtor.span,\n-        };\n-        // typecheck the dtor\n-        let dtor_dec = ast_util::dtor_dec();\n-        check_bare_fn(\n-            ccx,\n-            &dtor_dec,\n-            &dtor.node.body,\n-            dtor.node.id,\n-            Some(class_t)\n-        );\n-    };\n-\n+pub fn check_struct(ccx: @mut CrateCtxt, id: ast::node_id, span: span) {\n     // Check that the class is instantiable\n     check_instantiable(ccx.tcx, span, id);\n }\n@@ -623,8 +598,8 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n             }\n         }\n       }\n-      ast::item_struct(struct_def, _) => {\n-        check_struct(ccx, struct_def, it.id, it.span);\n+      ast::item_struct(*) => {\n+        check_struct(ccx, it.id, it.span);\n       }\n       ast::item_ty(t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n@@ -1272,8 +1247,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n                                 ty::ty_err => (),\n                                 _ => {\n-                                    fcx.ccx.tcx.sess.span_bug(arg.span,\n-                                                              ~\"no ref\");\n+                                    fcx.ccx.tcx.sess.span_bug(arg.span, \"no ref\");\n                                 }\n                             }\n                         }\n@@ -1588,8 +1562,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             match ty::get(lhs_resolved_t).sty {\n                 ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n                     tcx.sess.span_note(\n-                        ex.span, ~\"did you forget the `do` keyword \\\n-                                   for the call?\");\n+                        ex.span, \"did you forget the `do` keyword for the call?\");\n                 }\n                 _ => ()\n             }\n@@ -1880,9 +1853,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 tcx.sess.span_err(span,\n                                   fmt!(\"missing field%s: %s\",\n                                        if missing_fields.len() == 1 {\n-                                           ~\"\"\n+                                           \"\"\n                                        } else {\n-                                           ~\"s\"\n+                                           \"s\"\n                                        },\n                                        str::connect(missing_fields, ~\", \")));\n              }\n@@ -1930,7 +1903,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 _ => {\n                     tcx.sess.span_bug(span,\n-                                      ~\"resolve didn't map this to a class\");\n+                                      \"resolve didn't map this to a class\");\n                 }\n             }\n         } else {\n@@ -2016,7 +1989,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 _ => {\n                     tcx.sess.span_bug(span,\n-                                      ~\"resolve didn't map this to an enum\");\n+                                      \"resolve didn't map this to an enum\");\n                 }\n             }\n         } else {\n@@ -2226,7 +2199,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n           }\n           _ =>\n-            tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n+            tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\")\n         };\n         fcx.write_ty(ev.id, typ);\n         fcx.write_ty(id, typ);\n@@ -2309,21 +2282,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 ty::ty_enum(*) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n-                                        ~\"can only dereference enums \\\n-                                          with a single variant which has a \\\n-                                          single argument\");\n+                                        \"can only dereference enums with a single variant which \\\n+                                         has a single argument\");\n                                 }\n                                 ty::ty_struct(*) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n-                                        ~\"can only dereference structs with \\\n-                                          one anonymous field\");\n+                                        \"can only dereference structs with one anonymous field\");\n                                 }\n                                 _ => {\n                                     fcx.type_error_message(expr.span,\n                                         |actual| {\n-                                            fmt!(\"type %s cannot be \\\n-                                                  dereferenced\", actual)\n+                                            fmt!(\"type %s cannot be dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n                             }\n@@ -2417,7 +2387,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             result::Err(_) => {\n                 tcx.sess.span_err(\n                     expr.span,\n-                    ~\"`return;` in function returning non-nil\");\n+                    \"`return;` in function returning non-nil\");\n             }\n           },\n           Some(e) => {\n@@ -2781,8 +2751,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                           variant_id, *fields);\n             }\n             _ => {\n-                tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n-                                               not name a structure type\");\n+                tcx.sess.span_bug(path.span,\n+                                  \"structure constructor does not name a structure type\");\n             }\n         }\n       }\n@@ -2985,7 +2955,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n                   }\n                   _ => false\n                 } {\n-                fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n+                fcx.ccx.tcx.sess.span_warn(s.span, \"unreachable statement\");\n                 warned = true;\n             }\n             if ty::type_is_bot(s_ty) {\n@@ -3006,7 +2976,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n             },\n           Some(e) => {\n             if any_bot && !warned {\n-                fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n+                fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n             }\n             check_expr_with_opt_hint(fcx, e, expected);\n               let ety = fcx.expr_ty(e);\n@@ -3097,8 +3067,8 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                     *disr_val = val as int;\n                   }\n                   Ok(_) => {\n-                    ccx.tcx.sess.span_err(e.span, ~\"expected signed integer \\\n-                                                    constant\");\n+                    ccx.tcx.sess.span_err(e.span, \"expected signed integer \\\n+                                                   constant\");\n                   }\n                   Err(ref err) => {\n                     ccx.tcx.sess.span_err(e.span,\n@@ -3109,7 +3079,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n             }\n             if vec::contains(*disr_vals, &*disr_val) {\n                 ccx.tcx.sess.span_err(v.span,\n-                                      ~\"discriminator value already exists\");\n+                                      \"discriminator value already exists\");\n             }\n             disr_vals.push(*disr_val);\n             let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n@@ -3166,9 +3136,9 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n           _ => false\n         }\n     }) {\n-        ccx.tcx.sess.span_err(sp, ~\"illegal recursive enum type; \\\n-                                 wrap the inner value in a box to \\\n-                                 make it representable\");\n+        ccx.tcx.sess.span_err(sp,\n+                              \"illegal recursive enum type; \\\n+                               wrap the inner value in a box to make it representable\");\n     }\n \n     // Check that it is possible to instantiate this enum:\n@@ -3229,26 +3199,25 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_ty(_) |\n       ast::def_prim_ty(_) |\n       ast::def_ty_param(*)=> {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found type\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type\");\n       }\n       ast::def_mod(*) | ast::def_foreign_mod(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found module\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found module\");\n       }\n       ast::def_use(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found use\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found use\");\n       }\n       ast::def_region(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found region\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found region\");\n       }\n       ast::def_typaram_binder(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found type \\\n-                                          parameter\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type parameter\");\n       }\n       ast::def_label(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found label\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found label\");\n       }\n       ast::def_self_ty(*) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, ~\"expected value but found self ty\");\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n     }\n }\n@@ -3276,7 +3245,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         match tpt.generics.region_param {\n           None => { // ...but the type is not lifetime parameterized!\n             fcx.ccx.tcx.sess.span_err\n-                (span, ~\"this item is not region-parameterized\");\n+                (span, \"this item is not region-parameterized\");\n             None\n           }\n           Some(_) => { // ...and the type is lifetime parameterized, ok.\n@@ -3295,15 +3264,15 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_param_count == 0 {\n         fcx.ccx.tcx.sess.span_err\n-            (span, ~\"this item does not take type parameters\");\n+            (span, \"this item does not take type parameters\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len > ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n-            (span, ~\"too many type parameters provided for this item\");\n+            (span, \"too many type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else if ty_substs_len < ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n-            (span, ~\"not enough type parameters provided for this item\");\n+            (span, \"not enough type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n         pth.types.map(|aty| fcx.to_ty(*aty))"}, {"sha": "36606ab7d8990c351c466edbbf9f96775691aa90", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -613,17 +613,17 @@ fn constrain_free_variables(rcx: @mut Rcx,\n           result::Err(_) => {\n             tcx.sess.span_err(\n                 freevar.span,\n-                ~\"captured variable does not outlive the enclosing closure\");\n+                \"captured variable does not outlive the enclosing closure\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"captured variable is valid for \",\n+                \"captured variable is valid for \",\n                 en_region,\n-                ~\"\");\n+                \"\");\n             note_and_explain_region(\n                 tcx,\n-                ~\"closure is valid for \",\n+                \"closure is valid for \",\n                 region,\n-                ~\"\");\n+                \"\");\n           }\n         }\n     }"}, {"sha": "b5bd5a48e9d783f9154391610320f0250cc2712d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -417,7 +417,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                     if !is_early {\n                         vcx.tcx().sess.span_err(\n                             location_info.span,\n-                            ~\"multiple applicable methods in scope\");\n+                            \"multiple applicable methods in scope\");\n                     }\n                     return Some(/*bad*/copy found[0]);\n                 }\n@@ -669,5 +669,3 @@ pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::blk) {\n         .. *visit::default_visitor()\n     }));\n }\n-\n-"}, {"sha": "82ef09a83bee9c3e10901e72a320a547a6eb21d3", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -76,10 +76,8 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         }\n         _ => {\n             inference_context.tcx.sess.span_fatal(span,\n-                                                  ~\"the type of this value \\\n-                                                    must be known in order \\\n-                                                    to determine the base \\\n-                                                    type\");\n+                                                  \"the type of this value must be known in order \\\n+                                                   to determine the base type\");\n         }\n     }\n \n@@ -257,9 +255,8 @@ pub impl CoherenceChecker {\n                 None => {\n                     let session = self.crate_context.tcx.sess;\n                     session.span_err(item.span,\n-                                     ~\"no base type found for inherent \\\n-                                       implementation; implement a \\\n-                                       trait or new type instead\");\n+                                     \"no base type found for inherent implementation; \\\n+                                      implement a trait or new type instead\");\n                 }\n                 Some(_) => {\n                     // Nothing to do.\n@@ -481,11 +478,9 @@ pub impl CoherenceChecker {\n                     if self.polytypes_unify(polytype_a, polytype_b) {\n                         let session = self.crate_context.tcx.sess;\n                         session.span_err(self.span_of_impl(implementation_b),\n-                                         ~\"conflicting implementations for a \\\n-                                           trait\");\n+                                         \"conflicting implementations for a trait\");\n                         session.span_note(self.span_of_impl(implementation_a),\n-                                          ~\"note conflicting implementation \\\n-                                            here\");\n+                                          \"note conflicting implementation here\");\n                     }\n                 }\n             }\n@@ -668,11 +663,9 @@ pub impl CoherenceChecker {\n                             // This is an error.\n                             let session = self.crate_context.tcx.sess;\n                             session.span_err(item.span,\n-                                             ~\"cannot associate methods with \\\n-                                               a type outside the crate the \\\n-                                               type is defined in; define \\\n-                                               and implement a trait or new \\\n-                                               type instead\");\n+                                             \"cannot associate methods with a type outside the \\\n+                                              crate the type is defined in; define and implement \\\n+                                              a trait or new type instead\");\n                         }\n                     }\n                     item_impl(_, Some(trait_ref), _, _) => {\n@@ -691,10 +684,8 @@ pub impl CoherenceChecker {\n                             if trait_def_id.crate != local_crate {\n                                 let session = self.crate_context.tcx.sess;\n                                 session.span_err(item.span,\n-                                                 ~\"cannot provide an \\\n-                                                   extension implementation \\\n-                                                   for a trait not defined \\\n-                                                   in this crate\");\n+                                                 \"cannot provide an extension implementation \\\n+                                                  for a trait not defined in this crate\");\n                             }\n                         }\n \n@@ -766,7 +757,7 @@ pub impl CoherenceChecker {\n                             None => {\n                                 self.crate_context.tcx.sess.span_bug(\n                                     original_type.span,\n-                                    ~\"resolve didn't resolve this type?!\");\n+                                    \"resolve didn't resolve this type?!\");\n                             }\n                             Some(&node_item(item, _)) => {\n                                 match item.node {\n@@ -850,8 +841,7 @@ pub impl CoherenceChecker {\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n-                                                     ~\"can't convert a \\\n-                                                       non-impl to an impl\");\n+                                                     \"can't convert a non-impl to an impl\");\n             }\n         }\n     }\n@@ -863,9 +853,8 @@ pub impl CoherenceChecker {\n                 return item.span;\n             }\n             _ => {\n-                self.crate_context.tcx.sess.bug(~\"span_of_impl() called on \\\n-                                                  something that wasn't an \\\n-                                                  impl!\");\n+                self.crate_context.tcx.sess.bug(\"span_of_impl() called on something that \\\n+                                                 wasn't an impl!\");\n             }\n         }\n     }\n@@ -1046,17 +1035,16 @@ pub impl CoherenceChecker {\n                         match tcx.items.find(&impl_info.did.node) {\n                             Some(&ast_map::node_item(@ref item, _)) => {\n                                 tcx.sess.span_err((*item).span,\n-                                                  ~\"the Drop trait may only \\\n-                                                    be implemented on \\\n-                                                    structures\");\n+                                                  \"the Drop trait may only be implemented on \\\n+                                                   structures\");\n                             }\n                             _ => {\n-                                tcx.sess.bug(~\"didn't find impl in ast map\");\n+                                tcx.sess.bug(\"didn't find impl in ast map\");\n                             }\n                         }\n                     } else {\n-                        tcx.sess.bug(~\"found external impl of Drop trait on \\\n-                                       something other than a struct\");\n+                        tcx.sess.bug(\"found external impl of Drop trait on \\\n+                                      something other than a struct\");\n                     }\n                 }\n             }\n@@ -1132,4 +1120,3 @@ pub fn check_coherence(crate_context: @mut CrateCtxt, crate: @crate) {\n     let coherence_checker = @CoherenceChecker(crate_context);\n     coherence_checker.check_coherence(crate);\n }\n-"}, {"sha": "22850c16f943652722aefbd13f6b44568542f779", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -49,7 +49,6 @@ use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n-use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::print::pprust::{path_to_str, self_ty_to_str};\n@@ -152,7 +151,7 @@ impl AstConv for CrateCtxt {\n \n     fn ty_infer(&self, span: span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n-                               ~\"found `ty_infer` in unexpected place\");\n+                               \"found `ty_infer` in unexpected place\");\n     }\n }\n \n@@ -417,8 +416,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         if ty_trait_refs.any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n-            tcx.sess.span_err(sp, ~\"Duplicate supertrait in trait \\\n-                                     declaration\");\n+            tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n             break;\n         } else {\n             ty_trait_refs.push(trait_ref);\n@@ -897,30 +895,6 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                       id: ast::node_id) {\n     let tcx = ccx.tcx;\n \n-    for struct_def.dtor.each |dtor| {\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-\n-        // Write the dtor type\n-        let t_dtor = ty::mk_bare_fn(\n-            tcx,\n-            astconv::ty_of_bare_fn(\n-                ccx,\n-                &type_rscope(region_parameterization),\n-                ast::impure_fn,\n-                AbiSet::Rust(),\n-                &opt_vec::Empty,\n-                &ast_util::dtor_dec()));\n-        write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n-        tcx.tcache.insert(local_def(dtor.node.id),\n-                          ty_param_bounds_and_ty {\n-                              generics: ty::Generics {\n-                                  type_param_defs: tpt.generics.type_param_defs,\n-                                  region_param: rp\n-                              },\n-                              ty: t_dtor});\n-    };\n-\n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);"}, {"sha": "362104e98b0bddc6a7efea36221f8c44afd72aba", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -480,6 +480,8 @@ pub fn super_tys<C:Combine>(\n             unify_float_variable(self, !self.a_is_expected(), v_id, v)\n         }\n \n+      (ty::ty_nil, _) |\n+      (ty::ty_bool, _) |\n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n       (ty::ty_float(_), _) => {\n@@ -490,16 +492,6 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_nil, _) |\n-      (ty::ty_bool, _) => {\n-        let cfg = tcx.sess.targ_cfg;\n-        if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_sorts(expected_found(self, a, b)))\n-        }\n-      }\n-\n       (ty::ty_param(ref a_p), ty::ty_param(ref b_p)) if a_p.idx == b_p.idx => {\n         Ok(a)\n       }\n@@ -643,4 +635,3 @@ pub fn super_trait_refs<C:Combine>(\n         })\n     }\n }\n-"}, {"sha": "c195454b5327635d9414cfaa9de76580a0e7396e", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -315,4 +315,3 @@ impl Combine for Glb {\n         super_trait_refs(self, a, b)\n     }\n }\n-"}, {"sha": "306f124be3c8f8f7d53747f22779b9f1d0a775fe", "filename": "src/librustc/middle/typeck/infer/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,4 +18,3 @@ macro_rules! if_ok(\n         }\n     )\n )\n-"}, {"sha": "2e784b11c357ba7ee427612f04bd0e96449e3cb8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -728,25 +728,32 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n-                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n-        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n-        // Don't report an error if actual type is ty_err.\n-        if ty::type_is_error(actual_ty) {\n-            return;\n-        }\n+    fn type_error_message_str(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n+                          actual_ty: ~str, err: Option<&ty::type_err>) {\n         let error_str = err.map_default(~\"\", |t_err|\n                          fmt!(\" (%s)\",\n                               ty::type_err_to_str(self.tcx, *t_err)));\n         self.tcx.sess.span_err(sp,\n-           fmt!(\"%s%s\", mk_msg(self.ty_to_str(actual_ty)),\n-                error_str));\n+           fmt!(\"%s%s\", mk_msg(actual_ty), error_str));\n         for err.each |err| {\n             ty::note_and_explain_type_err(self.tcx, *err)\n         }\n     }\n \n+    fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n+                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n+        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+\n+        // Don't report an error if actual type is ty_err.\n+        if ty::type_is_error(actual_ty) {\n+            return;\n+        }\n+\n+        self.type_error_message_str(sp, mk_msg, self.ty_to_str(actual_ty),\n+                                    err);\n+    }\n+\n     fn report_mismatched_types(@mut self, sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n         let resolved_expected =\n@@ -793,4 +800,4 @@ pub fn fold_regions_in_sig(\n     do ty::fold_sig(fn_sig) |t| {\n         ty::fold_regions(tcx, t, fldr)\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a3b5369d22a34a15ac0b99e2cd3ae26b3e7d228e", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1584,19 +1584,19 @@ pub impl RegionVarBindings {\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"first, the lifetime cannot outlive \",\n+                        \"first, the lifetime cannot outlive \",\n                         upper_bound.region,\n-                        ~\"...\");\n+                        \"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound.span,\n                         fmt!(\"...due to the following expression\"));\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"but, the lifetime must be valid for \",\n+                        \"but, the lifetime must be valid for \",\n                         lower_bound.region,\n-                        ~\"...\");\n+                        \"...\");\n \n                     self.tcx.sess.span_note(\n                         lower_bound.span,\n@@ -1793,4 +1793,3 @@ fn iterate_until_fixed_point(\n     }\n     debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n }\n-"}, {"sha": "2b88825c49a69df4bae463be4937c8c193dcb76b", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -278,4 +278,3 @@ pub impl ResolveState {\n         }\n     }\n }\n-"}, {"sha": "48d7765f88ec95cee7335e50dca24260964b6fd7", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -269,4 +269,3 @@ impl Combine for Sub {\n         super_trait_refs(self, a, b)\n     }\n }\n-"}, {"sha": "3bcff92346566b766c675a43f790ccd69dd23913", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -264,5 +264,3 @@ impl SimplyUnifiable for ast::float_ty {\n         return ty::terr_float_mismatch(err);\n     }\n }\n-\n-"}, {"sha": "0012eb700302a3af49683b6765d92bcae6fb3bbc", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -214,7 +214,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     match tcx.def_map.find(&id) {\n       Some(&x) => x,\n       _ => {\n-        tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n+        tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n       }\n     }\n }\n@@ -301,8 +301,7 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 main_span,\n-                                ~\"main function is not allowed \\\n-                                  to have type parameters\");\n+                                \"main function is not allowed to have type parameters\");\n                             return;\n                         }\n                         _ => ()\n@@ -343,8 +342,7 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 start_span,\n-                                ~\"start function is not allowed to have type \\\n-                                parameters\");\n+                                \"start function is not allowed to have type parameters\");\n                             return;\n                         }\n                         _ => ()\n@@ -426,12 +424,3 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "f8a19eaf374cb081504ffa74eddb352eef9e1ece", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -20,7 +20,6 @@\n #[allow(non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];\n #[deny(deprecated_pattern)];\n-#[deny(deprecated_mode)];\n \n extern mod std(vers = \"0.7-pre\");\n extern mod syntax(vers = \"0.7-pre\");\n@@ -362,11 +361,3 @@ pub fn main() {\n         run_compiler(&args, demitter);\n     }\n }\n-\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "b4a479fc5970f7d46c44e56d08e8d26819276a54", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -112,13 +112,3 @@ pub fn pluralize(n: uint, s: ~str) -> ~str {\n \n // A set of node IDs (used to keep track of which node IDs are for statements)\n pub type stmt_set = @mut HashSet<ast::node_id>;\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "59a0a1ba3d611ed1238f9a9a75e2bba89c0c9c1b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -755,11 +755,3 @@ impl Repr for ast_map::path_elt {\n         }\n     }\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End"}, {"sha": "5560f21af61db3ba5d71bb7d46eb7afd4dfde2be", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -112,4 +112,3 @@ fn should_record_fn_paths() {\n         assert!(doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"]);\n     }\n }\n-"}, {"sha": "def32bdfd44d6c535027b04f7bd704954ac40b1e", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -332,13 +332,7 @@ fn fold_struct(\n /// what I actually want\n fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n     let node = match copy item.node {\n-        ast::item_struct(def, tys) => {\n-            let def = @ast::struct_def {\n-                dtor: None, // Remove the drop { } block\n-                .. copy *def\n-            };\n-            ast::item_struct(def, tys)\n-        }\n+        ast::item_struct(def, tys) => ast::item_struct(def, tys),\n         _ => fail!(~\"not a struct\")\n     };\n \n@@ -440,13 +434,6 @@ mod test {\n             \"struct S {\"));\n     }\n \n-    #[test]\n-    fn should_not_serialize_struct_drop_blocks() {\n-        // All we care about are the fields\n-        let doc = mk_doc(~\"struct S { field: (), drop { } }\");\n-        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n-    }\n-\n     #[test]\n     fn should_not_serialize_struct_attrs() {\n         // All we care about are the fields"}, {"sha": "5b19a3bd660424b3b2ba66396a1d7c1a321521a5", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,5 +18,13 @@ condition! {\n }\n \n condition! {\n-    nonexistent_package: (super::PkgId, ~str) -> super::Path;\n+    nonexistent_package: (super::PkgId, ~str) -> ();\n+}\n+\n+condition! {\n+    copy_failed: (super::Path, super::Path) -> ();\n+}\n+\n+condition! {\n+    missing_pkg_files: (super::PkgId) -> ();\n }"}, {"sha": "348d828bded2f2a9fced3179ddc5197cc24864f3", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -13,6 +13,9 @@\n use core::hashmap::HashMap;\n \n pub struct Ctx {\n+    // Sysroot -- if this is None, uses rustc filesearch's\n+    // idea of the default\n+    sysroot_opt: Option<@Path>,\n     // I'm not sure what this is for\n     json: bool,\n     // Cache of hashes of things already installed"}, {"sha": "d21fdcda7f76f779a23f29f225a17397ea00ec6f", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 120, "deletions": 16, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -12,6 +12,7 @@\n \n use util::PkgId;\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+use core::os::mkdir_recursive;\n \n #[deriving(Eq)]\n pub enum OutputType { Main, Lib, Bench, Test }\n@@ -23,16 +24,12 @@ pub fn rust_path() -> ~[Path] {\n     ~[Path(\".\")]\n }\n \n-static u_rwx: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n+pub static u_rwx: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n \n /// Creates a directory that is readable, writeable,\n /// and executable by the user. Returns true iff creation\n /// succeeded.\n-pub fn make_dir_rwx(p: &Path) -> bool {\n-    use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-\n-    os::make_dir(p, u_rwx)\n-}\n+pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n \n /// Replace all occurrences of '-' in the stem part of path with '_'\n /// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n@@ -70,34 +67,137 @@ pub fn pkgid_src_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n     result.push(pkgid.path.to_str())\n }\n \n+/// Figure out what the executable name for <pkgid> in <workspace>'s build\n+/// directory is, and if the file exists, return it.\n+pub fn built_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+    let mut result = workspace.push(\"build\");\n+    result = result.push_rel(&pkgid.path);\n+    // should use a target-specific subdirectory\n+    result = mk_output_path(Main, fmt!(\"%s-%s\", pkgid.path.to_str(), pkgid.version.to_str()),\n+                                       result);\n+    debug!(\"built_executable_in_workspace: checking whether %s exists\",\n+           result.to_str());\n+    if os::path_exists(&result) {\n+        Some(result)\n+    }\n+    else {\n+        None\n+    }\n+}\n+\n+/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// directory is, and if the file exists, return it.\n+pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+    let mut result = workspace.push(\"build\");\n+    result = result.push_rel(&pkgid.path);\n+    // should use a target-specific subdirectory\n+    result = mk_output_path(Lib, pkgid.path.to_str(), result);\n+    debug!(\"built_library_in_workspace: checking whether %s exists\",\n+           result.to_str());\n+\n+    // We don't know what the hash is, so we have to search through the directory\n+    // contents\n+    let dir_contents = os::list_dir(&result.pop());\n+    debug!(\"dir has %? entries\", dir_contents.len());\n+\n+    // n.b. This code assumes the pkgid's path only has one element\n+    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, pkgid.path.to_str());\n+    let lib_filetype = fmt!(\"%s%s\", pkgid.version.to_str(), os::consts::DLL_SUFFIX);\n+\n+    debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n+\n+    let mut result_filename = None;\n+    for dir_contents.each |&p| {\n+        let mut which = 0;\n+        let mut hash = None;\n+        // Find a filename that matches the pattern: (lib_prefix)-hash-(version)(lib_suffix)\n+        // and remember what the hash was\n+        for p.each_split_char('-') |piece| {\n+            debug!(\"a piece = %s\", piece);\n+            if which == 0 && piece != lib_prefix {\n+                break;\n+            }\n+            else if which == 0 {\n+                which += 1;\n+            }\n+            else if which == 1 {\n+                hash = Some(piece.to_owned());\n+                which += 1;\n+            }\n+            else if which == 2 && piece != lib_filetype {\n+                hash = None;\n+                break;\n+            }\n+            else if which == 2 {\n+                break;\n+            }\n+            else {\n+                // something went wrong\n+                hash = None;\n+                break;\n+            }\n+        }\n+        if hash.is_some() {\n+            result_filename = Some(p);\n+            break;\n+        }\n+    }\n+\n+    // Return the filename that matches, which we now know exists\n+    // (if result_filename != None)\n+    debug!(\"result_filename = %?\", result_filename);\n+    match result_filename {\n+        None => None,\n+        Some(result_filename) => {\n+            let result_filename = result.with_filename(result_filename);\n+            debug!(\"result_filename = %s\", result_filename.to_str());\n+            Some(result_filename)\n+        }\n+    }\n+}\n+\n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n+/// As a side effect, creates the bin-dir if it doesn't exist\n pub fn target_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n-    let result = workspace.push(\"bin\");\n-    // should use a target-specific subdirectory\n-    mk_output_path(Main, pkgid.path.to_str(), result)\n+    target_file_in_workspace(pkgid, workspace, Main)\n }\n \n \n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n+/// As a side effect, creates the bin-dir if it doesn't exist\n pub fn target_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n-    let result = workspace.push(\"lib\");\n-    mk_output_path(Lib, pkgid.path.to_str(), result)\n+    target_file_in_workspace(pkgid, workspace, Lib)\n }\n \n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n-    let result = workspace.push(\"build\");\n-    mk_output_path(Test, pkgid.path.to_str(), result)\n+    target_file_in_workspace(pkgid, workspace, Test)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n-    let result = workspace.push(\"build\");\n-    mk_output_path(Bench, pkgid.path.to_str(), result)\n+    target_file_in_workspace(pkgid, workspace, Bench)\n+}\n+\n+fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n+                            what: OutputType) -> Path {\n+    use conditions::bad_path::cond;\n+\n+    let (subdir, create_dir) = match what {\n+        Main => (\"bin\", true), Lib => (\"lib\", true), Test | Bench => (\"build\", false)\n+    };\n+    let result = workspace.push(subdir);\n+    if create_dir {\n+        if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n+            cond.raise((result, fmt!(\"I couldn't create the %s dir\", subdir)));\n+        }\n+    }\n+    mk_output_path(what, pkgid.path.to_str(), result)\n+\n }\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n@@ -123,7 +223,11 @@ pub fn mk_output_path(what: OutputType, short_name: ~str, dir: Path) -> Path {\n     match what {\n         Lib => dir.push(os::dll_filename(short_name)),\n         _ => dir.push(fmt!(\"%s%s%s\", short_name,\n-                           if what == Test { ~\"test\" } else { ~\"\" },\n+                           match what {\n+                               Test => \"test\",\n+                               Bench => \"bench\",\n+                               _     => \"\"\n+                           }\n                            os::EXE_SUFFIX))\n     }\n }"}, {"sha": "dd5806ba01568a5e2bf48e60890a4de0ee1ad908", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 97, "deletions": 62, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -34,6 +34,8 @@ use syntax::{ast, diagnostic};\n use util::*;\n use path_util::normalize;\n use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace};\n+use path_util::{built_executable_in_workspace, built_library_in_workspace};\n+use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use workspace::pkg_parent_workspaces;\n use rustc::driver::session::{lib_crate, bin_crate, crate_type};\n use context::Ctx;\n@@ -188,49 +190,7 @@ impl Ctx {\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n                 for pkg_parent_workspaces(pkgid) |workspace| {\n-                    let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n-                    let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n-                    debug!(\"Destination dir = %s\", build_dir.to_str());\n-\n-                    // Create the package source\n-                    let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, &pkgid);\n-                    debug!(\"Package src = %?\", src);\n-\n-                    // Is there custom build logic? If so, use it\n-                    let pkg_src_dir = src_dir;\n-                    let mut custom = false;\n-                    debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n-                    let cfgs = match src.package_script_option(&pkg_src_dir) {\n-                        Some(package_script_path) => {\n-                            let pscript = PkgScript::parse(package_script_path,\n-                                                           workspace,\n-                                                           pkgid);\n-                            // Limited right now -- we're only running the post_build\n-                            // hook and probably fail otherwise\n-                            // also post_build should be called pre_build\n-                            let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n-                            debug!(\"Command return code = %?\", hook_result);\n-                            if hook_result != 0 {\n-                                fail!(fmt!(\"Error running custom build command\"))\n-                            }\n-                            custom = true;\n-                            // otherwise, the package script succeeded\n-                            cfgs\n-                        }\n-                        None => {\n-                            debug!(\"No package script, continuing\");\n-                            ~[]\n-                        }\n-                    };\n-\n-                    // If there was a package script, it should have finished\n-                    // the build already. Otherwise...\n-                    if !custom {\n-                        // Find crates inside the workspace\n-                        src.find_crates();\n-                        // Build it!\n-                        src.build(&build_dir, cfgs);\n-                    }\n+                    self.build(workspace, pkgid);\n                 }\n             }\n             ~\"clean\" => {\n@@ -304,6 +264,53 @@ impl Ctx {\n         fail!(~\"`do` not yet implemented\");\n     }\n \n+    fn build(&self, workspace: &Path, pkgid: PkgId) {\n+        let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n+        let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n+        debug!(\"Destination dir = %s\", build_dir.to_str());\n+\n+        // Create the package source\n+        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, &pkgid);\n+        debug!(\"Package src = %?\", src);\n+\n+        // Is there custom build logic? If so, use it\n+        let pkg_src_dir = src_dir;\n+        let mut custom = false;\n+        debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n+        let cfgs = match src.package_script_option(&pkg_src_dir) {\n+            Some(package_script_path) => {\n+                let pscript = PkgScript::parse(package_script_path,\n+                                               workspace,\n+                                               pkgid);\n+                // Limited right now -- we're only running the post_build\n+                // hook and probably fail otherwise\n+                // also post_build should be called pre_build\n+                let (cfgs, hook_result) = pscript.run_custom(~\"post_build\");\n+                debug!(\"Command return code = %?\", hook_result);\n+                if hook_result != 0 {\n+                    fail!(fmt!(\"Error running custom build command\"))\n+                }\n+                custom = true;\n+                // otherwise, the package script succeeded\n+                cfgs\n+            }\n+            None => {\n+                debug!(\"No package script, continuing\");\n+                ~[]\n+            }\n+        };\n+\n+        // If there was a package script, it should have finished\n+        // the build already. Otherwise...\n+        if !custom {\n+            // Find crates inside the workspace\n+            src.find_crates();\n+            // Build it!\n+            src.build(&build_dir, cfgs, self.sysroot_opt);\n+        }\n+\n+    }\n+\n     fn clean(&self, workspace: &Path, id: PkgId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n@@ -325,9 +332,31 @@ impl Ctx {\n         fail!(~\"info not yet implemented\");\n     }\n \n-    fn install(&self, _workspace: &Path, _id: PkgId)  {\n-        // stub\n-        fail!(~\"install not yet implemented\");\n+    fn install(&self, workspace: &Path, id: PkgId)  {\n+        use conditions::copy_failed::cond;\n+\n+        // Should use RUST_PATH in the future.\n+        // Also should use workcache to not build if not necessary.\n+        self.build(workspace, id);\n+\n+        // Now copy stuff into the install dirs\n+        let maybe_executable = built_executable_in_workspace(id, workspace);\n+        let maybe_library = built_library_in_workspace(id, workspace);\n+        let target_exec = target_executable_in_workspace(id, workspace);\n+        let target_lib = target_library_in_workspace(id, workspace);\n+\n+        for maybe_executable.each |exec| {\n+            debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n+            if !os::copy_file(exec, &target_exec) {\n+                cond.raise((*exec, target_exec));\n+            }\n+        }\n+        for maybe_library.each |lib| {\n+            debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n+            if !os::copy_file(lib, &target_lib) {\n+                cond.raise((*lib, target_lib));\n+            }\n+        }\n     }\n \n     fn fetch(&self, _dir: &Path, _url: ~str, _target: Option<~str>)  {\n@@ -477,6 +506,7 @@ pub fn main() {\n     }\n \n     Ctx {\n+        sysroot_opt: None, // Currently, only tests override this\n         json: json,\n         dep_cache: @mut HashMap::new()\n     }.run(cmd, args);\n@@ -610,7 +640,7 @@ impl PkgSrc {\n \n \n     fn check_dir(&self) -> Path {\n-        use conditions::bad_path::cond;\n+        use conditions::nonexistent_package::cond;\n \n         debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(),\n                self.root.to_str());\n@@ -619,13 +649,15 @@ impl PkgSrc {\n \n         debug!(\"Checking dir: %s\", dir.to_str());\n \n+        // tjc: Rather than erroring out, need to try downloading the\n+        // contents of the path to a local directory (#5679)\n         if !os::path_exists(&dir) {\n-            return cond.raise((dir, ~\"missing package dir\"));\n+            cond.raise((self.id, ~\"missing package dir\"));\n         }\n \n         if !os::path_is_dir(&dir) {\n-            return cond.raise((dir, ~\"supplied path for package dir is a \\\n-                                      non-directory\"));\n+            cond.raise((self.id, ~\"supplied path for package dir is a \\\n+                                   non-directory\"));\n         }\n \n         dir\n@@ -680,6 +712,7 @@ impl PkgSrc {\n     /// is no custom build logic\n     fn find_crates(&mut self) {\n         use PkgSrc::push_crate;\n+        use conditions::missing_pkg_files::cond;\n \n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n@@ -704,7 +737,7 @@ impl PkgSrc {\n             util::note(~\"Couldn't infer any crates to build.\\n\\\n                          Try naming a crate `main.rs`, `lib.rs`, \\\n                          `test.rs`, or `bench.rs`.\");\n-            fail!(~\"Failed to infer crates to build\");\n+            cond.raise(self.id);\n         }\n \n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n@@ -714,18 +747,20 @@ impl PkgSrc {\n                self.benchs.len())\n     }\n \n-    fn build_crates(&self, dst_dir: &Path,\n-                           src_dir: &Path,\n-                           crates: &[Crate],\n-                           cfgs: ~[~str],\n-                           test: bool, crate_type: crate_type) {\n+    fn build_crates(&self,\n+                    maybe_sysroot: Option<@Path>,\n+                    dst_dir: &Path,\n+                    src_dir: &Path,\n+                    crates: &[Crate],\n+                    cfgs: ~[~str],\n+                    test: bool, crate_type: crate_type) {\n \n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n \n-            let result = util::compile_crate(None, self.id, path,\n+            let result = util::compile_crate(maybe_sysroot, self.id, path,\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,\n@@ -739,15 +774,15 @@ impl PkgSrc {\n         }\n     }\n \n-    fn build(&self, dst_dir: &Path, cfgs: ~[~str]) {\n+    fn build(&self, dst_dir: &Path, cfgs: ~[~str], maybe_sysroot: Option<@Path>) {\n         let dir = self.check_dir();\n         debug!(\"Building libs\");\n-        self.build_crates(dst_dir, &dir, self.libs, cfgs, false, lib_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.libs, cfgs, false, lib_crate);\n         debug!(\"Building mains\");\n-        self.build_crates(dst_dir, &dir, self.mains, cfgs, false, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.mains, cfgs, false, bin_crate);\n         debug!(\"Building tests\");\n-        self.build_crates(dst_dir, &dir, self.tests, cfgs, true, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.tests, cfgs, true, bin_crate);\n         debug!(\"Building benches\");\n-        self.build_crates(dst_dir, &dir, self.benchs, cfgs, true, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, true, bin_crate);\n     }\n }"}, {"sha": "486e2959e9ed76208947046d94e97d28d5421fbc", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 95, "deletions": 23, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -17,10 +17,12 @@ use std::tempfile::mkdtemp;\n use util::{PkgId, default_version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n-               make_dir_rwx};\n+               make_dir_rwx, u_rwx};\n+use core::os::mkdir_recursive;\n \n-fn fake_ctxt() -> Ctx {\n+fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n     Ctx {\n+        sysroot_opt: sysroot_opt,\n         json: false,\n         dep_cache: @mut HashMap::new()\n     }\n@@ -33,69 +35,139 @@ fn fake_pkg() -> PkgId {\n     }\n }\n \n-fn mk_temp_workspace() -> Path {\n-    mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\")\n+fn remote_pkg() -> PkgId {\n+    PkgId {\n+        path: Path(~\"github.com/catamorphism/test-pkg\"),\n+        version: default_version()\n+    }\n+}\n+\n+fn writeFile(file_path: &Path, contents: ~str) {\n+    let out: @io::Writer =\n+        result::get(&io::file_writer(file_path,\n+                                     ~[io::Create, io::Truncate]));\n+    out.write_line(contents);\n+}\n+\n+fn mk_temp_workspace(short_name: &Path) -> Path {\n+    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+    let package_dir = workspace.push(~\"src\").push_rel(short_name);\n+    assert!(mkdir_recursive(&package_dir, u_rwx));\n+    // Create main, lib, test, and bench files\n+    writeFile(&package_dir.push(~\"main.rs\"),\n+              ~\"fn main() { let _x = (); }\");\n+    writeFile(&package_dir.push(~\"lib.rs\"),\n+              ~\"pub fn f() { let _x = (); }\");\n+    writeFile(&package_dir.push(~\"test.rs\"),\n+              ~\"#[test] pub fn f() { (); }\");\n+    writeFile(&package_dir.push(~\"bench.rs\"),\n+              ~\"#[bench] pub fn f() { (); }\");\n+    workspace\n }\n \n fn is_rwx(p: &Path) -> bool {\n     use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n     match p.get_mode() {\n         None => return false,\n-        Some(m) => {\n+        Some(m) =>\n             ((m & S_IRUSR as uint) == S_IRUSR as uint\n             && (m & S_IWUSR as uint) == S_IWUSR as uint\n             && (m & S_IXUSR as uint) == S_IXUSR as uint)\n-        }\n     }\n }\n \n+#[cfg(test)]\n+fn test_sysroot() -> Path {\n+    // Totally gross hack but it's just for test cases.\n+    // Infer the sysroot from the exe name and tack \"stage2\"\n+    // onto it. (Did I mention it was a gross hack?)\n+    let self_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n+    self_path.pop().push(\"stage2\")\n+}\n+\n #[test]\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n     let dir = temp.push(~\"quux\");\n-    let _ = os::remove_dir(&dir);\n+    assert!(!os::path_exists(&dir) ||\n+            os::remove_dir_recursive(&dir));\n+    debug!(\"Trying to make %s\", dir.to_str());\n     assert!(make_dir_rwx(&dir));\n     assert!(os::path_is_dir(&dir));\n     assert!(is_rwx(&dir));\n-    assert!(os::remove_dir(&dir));\n+    assert!(os::remove_dir_recursive(&dir));\n }\n \n #[test]\n-#[ignore(reason = \"install not yet implemented\")]\n fn test_install_valid() {\n-    let ctxt = fake_ctxt();\n+    let sysroot = test_sysroot();\n+    debug!(\"sysroot = %s\", sysroot.to_str());\n+    let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace();\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, temp_pkg_id);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(temp_pkg_id, &temp_workspace);\n+    debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let lib = target_library_in_workspace(temp_pkg_id, &temp_workspace);\n+    debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(temp_pkg_id, &temp_workspace)));\n-    assert!(!os::path_exists(&target_bench_in_workspace(temp_pkg_id, &temp_workspace)));\n+    let bench = target_bench_in_workspace(temp_pkg_id, &temp_workspace);\n+    debug!(\"bench = %s\", bench.to_str());\n+    assert!(!os::path_exists(&bench));\n }\n \n #[test]\n-#[ignore(reason = \"install not yet implemented\")]\n fn test_install_invalid() {\n     use conditions::nonexistent_package::cond;\n+    use cond1 = conditions::missing_pkg_files::cond;\n \n-    let ctxt = fake_ctxt();\n+    let ctxt = fake_ctxt(None);\n     let pkgid = fake_pkg();\n-    let temp_workspace = mk_temp_workspace();\n-    let expected_path = Path(~\"quux\");\n-    let substituted: Path = do cond.trap(|_| {\n-        expected_path\n+    let temp_workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+    let mut error_occurred = false;\n+    let mut error1_occurred = false;\n+    do cond1.trap(|_| {\n+        error1_occurred = true;\n     }).in {\n-        ctxt.install(&temp_workspace, pkgid);\n-        // ok\n-        fail!(~\"test_install_invalid failed, should have raised a condition\");\n-    };\n-    assert!(substituted == expected_path);\n+        do cond.trap(|_| {\n+            error_occurred = true;\n+        }).in {\n+            ctxt.install(&temp_workspace, pkgid);\n+        }\n+    }\n+    assert!(error_occurred && error1_occurred);\n }\n+\n+#[test]\n+#[ignore(reason = \"install from URL-fragment not yet implemented\")]\n+fn test_install_url() {\n+    let sysroot = test_sysroot();\n+    debug!(\"sysroot = %s\", sysroot.to_str());\n+    let ctxt = fake_ctxt(Some(@sysroot));\n+    let temp_pkg_id = remote_pkg();\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n+    // should have test, bench, lib, and main\n+    ctxt.install(&temp_workspace, temp_pkg_id);\n+    // Check that all files exist\n+    let exec = target_executable_in_workspace(temp_pkg_id, &temp_workspace);\n+    debug!(\"exec = %s\", exec.to_str());\n+    assert!(os::path_exists(&exec));\n+    assert!(is_rwx(&exec));\n+    let lib = target_library_in_workspace(temp_pkg_id, &temp_workspace);\n+    debug!(\"lib = %s\", lib.to_str());\n+    assert!(os::path_exists(&lib));\n+    assert!(is_rwx(&lib));\n+    // And that the test and bench executables aren't installed\n+    assert!(!os::path_exists(&target_test_in_workspace(temp_pkg_id, &temp_workspace)));\n+    let bench = target_bench_in_workspace(temp_pkg_id, &temp_workspace);\n+    debug!(\"bench = %s\", bench.to_str());\n+    assert!(!os::path_exists(&bench));\n+}\n\\ No newline at end of file"}, {"sha": "baeaef1e3c791b278cce3dc9e6abd0caed613d3b", "filename": "src/librustpkg/testsuite/pass/commands.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -32,4 +32,3 @@ Commands that should succeed:\n 15. `rustpkg test foo` runs tests and prints their output, if foo contains #[test]s.\n \n 16. If foo is installed, `rustpkg uninstall foo; rustpkg list` doesn't include foo in the list\n-"}, {"sha": "62785c06db31ab1dcd5af6e101a02a2af4c6aeab", "filename": "src/librustpkg/testsuite/pass/src/deeply/nested/path/foo/src/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fsrc%2Fmain.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -15,4 +15,3 @@ The test runner should check that, after `rustpkg install deeply/nested/path/foo\n */\n \n fn main() {}\n-"}, {"sha": "0762fa4ad7fd3d1829e6179711ce9e6aa2264bdf", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -435,7 +435,7 @@ pub fn add_pkg(pkg: &Pkg) -> bool {\n }\n \n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_input(sysroot: Option<Path>,\n+pub fn compile_input(sysroot: Option<@Path>,\n                      pkg_id: PkgId,\n                      in_file: &Path,\n                      out_dir: &Path,\n@@ -474,9 +474,12 @@ pub fn compile_input(sysroot: Option<Path>,\n            out_file.to_str());\n     debug!(\"flags: %s\", str::connect(flags, ~\" \"));\n     debug!(\"cfgs: %s\", str::connect(cfgs, ~\" \"));\n+    debug!(\"compile_input's sysroot = %?\", sysroot);\n \n     let matches = getopts(~[~\"-Z\", ~\"time-passes\"]\n                           + if building_library { ~[~\"--lib\"] }\n+                            else if test { ~[~\"--test\"] }\n+                            // bench?\n                             else { ~[] }\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n@@ -540,9 +543,13 @@ pub fn compile_crate_from_input(input: driver::input,\n             let (crate, _) = driver::compile_upto(sess, cfg, &input,\n                                                   driver::cu_parse, Some(outputs));\n \n+            debug!(\"About to inject link_meta info...\");\n             // Inject the inferred link_meta info if it's not already there\n             // (assumes that name and vers are the only linkage metas)\n             let mut crate_to_use = crate;\n+\n+            debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n+\n             if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n                 crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n                                                   // change PkgId to have a <shortname> field?\n@@ -552,7 +559,6 @@ pub fn compile_crate_from_input(input: driver::input,\n                                                     mk_string_lit(@pkg_id.version.to_str())))])))]);\n             }\n \n-\n             driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate_to_use));\n             crate_to_use\n         }\n@@ -582,7 +588,7 @@ fn add_attrs(c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n \n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(sysroot: Option<Path>, pkg_id: PkgId,\n+pub fn compile_crate(sysroot: Option<@Path>, pkg_id: PkgId,\n                      crate: &Path, dir: &Path,\n                      flags: ~[~str], cfgs: ~[~str], opt: bool,\n                      test: bool, crate_type: crate_type) -> bool {"}, {"sha": "b9a09323f81d068c9f3fa13ce188a5b1a0382742", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 58, "deletions": 49, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -32,11 +32,10 @@\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n \n-use list;\n-use list::{List, Cons, Nil};\n+use list::{MutList, MutCons, MutNil};\n \n use core::at_vec;\n-use core::cast::transmute;\n+use core::cast::{transmute, transmute_mut_region};\n use core::cast;\n use core::libc::size_t;\n use core::ptr;\n@@ -74,26 +73,28 @@ static tydesc_drop_glue_index: size_t = 3 as size_t;\n // will always stay at 0.\n struct Chunk {\n     data: @[u8],\n-    mut fill: uint,\n+    fill: uint,\n     is_pod: bool,\n }\n \n pub struct Arena {\n-    // The head is seperated out from the list as a unbenchmarked\n+    // The head is separated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n-    priv mut head: Chunk,\n-    priv mut pod_head: Chunk,\n-    priv mut chunks: @List<Chunk>,\n+    priv head: Chunk,\n+    priv pod_head: Chunk,\n+    priv chunks: @mut MutList<Chunk>,\n }\n \n #[unsafe_destructor]\n impl Drop for Arena {\n     fn finalize(&self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            for list::each(self.chunks) |chunk| {\n-                if !chunk.is_pod { destroy_chunk(chunk); }\n+            for self.chunks.each |chunk| {\n+                if !chunk.is_pod {\n+                    destroy_chunk(chunk);\n+                }\n             }\n         }\n     }\n@@ -113,7 +114,7 @@ pub fn arena_with_size(initial_size: uint) -> Arena {\n     Arena {\n         head: chunk(initial_size, false),\n         pod_head: chunk(initial_size, true),\n-        chunks: @Nil,\n+        chunks: @mut MutNil,\n     }\n }\n \n@@ -170,38 +171,39 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n \n pub impl Arena {\n     // Functions for the POD part of the arena\n-    priv fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n+    priv fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @Cons(copy self.pod_head, self.chunks);\n+        self.chunks = @mut MutCons(copy self.pod_head, self.chunks);\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n \n         return self.alloc_pod_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n-        let head = &mut self.pod_head;\n+    priv fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n+        unsafe {\n+            // XXX: Borrow check\n+            let head = transmute_mut_region(&mut self.pod_head);\n \n-        let start = round_up_to(head.fill, align);\n-        let end = start + n_bytes;\n-        if end > at_vec::capacity(head.data) {\n-            return self.alloc_pod_grow(n_bytes, align);\n-        }\n-        head.fill = end;\n+            let start = round_up_to(head.fill, align);\n+            let end = start + n_bytes;\n+            if end > at_vec::capacity(head.data) {\n+                return self.alloc_pod_grow(n_bytes, align);\n+            }\n+            head.fill = end;\n \n-        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n-        //       start, n_bytes, align, head.fill);\n+            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //       start, n_bytes, align, head.fill);\n \n-        unsafe {\n             ptr::offset(vec::raw::to_ptr(head.data), start)\n         }\n     }\n \n     #[inline(always)]\n-    priv fn alloc_pod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    priv fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -212,41 +214,43 @@ pub impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    priv fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    priv fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n+                             -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @Cons(copy self.head, self.chunks);\n+        self.chunks = @mut MutCons(copy self.head, self.chunks);\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n \n         return self.alloc_nonpod_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n-        let head = &mut self.head;\n-\n-        let tydesc_start = head.fill;\n-        let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n-        let start = round_up_to(after_tydesc, align);\n-        let end = start + n_bytes;\n-        if end > at_vec::capacity(head.data) {\n-            return self.alloc_nonpod_grow(n_bytes, align);\n-        }\n-        head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n+    priv fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n+                               -> (*u8, *u8) {\n+        unsafe {\n+            let head = transmute_mut_region(&mut self.head);\n+\n+            let tydesc_start = head.fill;\n+            let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n+            let start = round_up_to(after_tydesc, align);\n+            let end = start + n_bytes;\n+            if end > at_vec::capacity(head.data) {\n+                return self.alloc_nonpod_grow(n_bytes, align);\n+            }\n+            head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n \n-        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n-        //       start, n_bytes, align, head.fill);\n+            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //       start, n_bytes, align, head.fill);\n \n-        unsafe {\n             let buf = vec::raw::to_ptr(head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }\n \n     #[inline(always)]\n-    priv fn alloc_nonpod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    priv fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -268,20 +272,23 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    fn alloc<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n+            // XXX: Borrow check\n+            let this = transmute_mut_region(self);\n             if !rusti::needs_drop::<T>() {\n-                self.alloc_pod(op)\n-            } else {\n-                self.alloc_nonpod(op)\n+                return this.alloc_pod(op);\n             }\n+            // XXX: Borrow check\n+            let this = transmute_mut_region(self);\n+            this.alloc_nonpod(op)\n         }\n     }\n }\n \n #[test]\n fn test_arena_destructors() {\n-    let arena = Arena();\n+    let mut arena = Arena();\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n@@ -292,9 +299,11 @@ fn test_arena_destructors() {\n     }\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test]\n+#[should_fail]\n+#[ignore(cfg(windows))]\n fn test_arena_destructors_fail() {\n-    let arena = Arena();\n+    let mut arena = Arena();\n     // Put some stuff in the arena.\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it"}, {"sha": "ceb67fcabfa5b619f9da484db367df21ee11f071", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1507,13 +1507,3 @@ mod tests {\n         }\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "ea3793c13748358caabd93b41649447029430553", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -64,7 +64,7 @@ fn test_fuzzy_eq_eps() {\n     assert!(!(&1.5f).fuzzy_eq_eps(&0.9, &0.5));\n }\n \n-#[test]\n+#[cfg(test)]\n mod test_complex{\n     use cmp::*;\n "}, {"sha": "4b2d2a60a68ef5d275d2b1aa237fa4b081cce9a3", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -76,11 +76,3 @@ fn test_breakpoint_should_not_abort_process_when_not_under_gdb() {\n     // the process under normal circumstances\n     breakpoint();\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "65e71869a1f0f39d293df3cda775690f7914ade2", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -231,7 +231,7 @@ mod tests {\n         assert!(*deq.get(3) == d);\n     }\n \n-    #[test]\n+    #[cfg(test)]\n     fn test_parameterized<T:Copy + Eq + Durable>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n         assert!(deq.len() == 0);"}, {"sha": "864a49a14294fb1096d1a8f7e8abcdad50f85b54", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 318, "deletions": 149, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -36,13 +36,27 @@ pub struct TaggedDoc {\n }\n \n pub enum EbmlEncoderTag {\n-    EsUint, EsU64, EsU32, EsU16, EsU8,\n-    EsInt, EsI64, EsI32, EsI16, EsI8,\n-    EsBool,\n-    EsStr,\n-    EsF64, EsF32, EsFloat,\n-    EsEnum, EsEnumVid, EsEnumBody,\n-    EsVec, EsVecLen, EsVecElt,\n+    EsUint,     // 0\n+    EsU64,      // 1\n+    EsU32,      // 2\n+    EsU16,      // 3\n+    EsU8,       // 4\n+    EsInt,      // 5\n+    EsI64,      // 6\n+    EsI32,      // 7\n+    EsI16,      // 8\n+    EsI8,       // 9\n+    EsBool,     // 10\n+    EsStr,      // 11\n+    EsF64,      // 12\n+    EsF32,      // 13\n+    EsFloat,    // 14\n+    EsEnum,     // 15\n+    EsEnumVid,  // 16\n+    EsEnumBody, // 17\n+    EsVec,      // 18\n+    EsVecLen,   // 19\n+    EsVecElt,   // 20\n \n     EsOpaque,\n \n@@ -249,18 +263,20 @@ pub mod reader {\n     pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n-\n     pub struct Decoder {\n-        priv mut parent: Doc,\n-        priv mut pos: uint,\n+        priv parent: Doc,\n+        priv pos: uint,\n     }\n \n     pub fn Decoder(d: Doc) -> Decoder {\n-        Decoder { parent: d, pos: d.start }\n+        Decoder {\n+            parent: d,\n+            pos: d.start\n+        }\n     }\n \n     priv impl Decoder {\n-        fn _check_label(&self, lbl: &str) {\n+        fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n                     doc_at(self.parent.data, self.pos);\n@@ -269,14 +285,15 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = doc_as_str(r_doc);\n                     if lbl != str {\n-                        fail!(fmt!(\"Expected label %s but found %s\", lbl,\n-                            str));\n+                        fail!(fmt!(\"Expected label %s but found %s\",\n+                                   lbl,\n+                                   str));\n                     }\n                 }\n             }\n         }\n \n-        fn next_doc(&self, exp_tag: EbmlEncoderTag) -> Doc {\n+        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n             debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n             if self.pos >= self.parent.end {\n                 fail!(~\"no more documents in current node!\");\n@@ -298,7 +315,7 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(&self, d: Doc, f: &fn() -> T) -> T {\n+        fn push_doc<T>(&mut self, d: Doc, f: &fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n@@ -309,161 +326,262 @@ pub mod reader {\n             r\n         }\n \n-        fn _next_uint(&self, exp_tag: EbmlEncoderTag) -> uint {\n+        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n             debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n             r as uint\n         }\n     }\n \n     pub impl Decoder {\n-        fn read_opaque<R>(&self, op: &fn(Doc) -> R) -> R {\n-            do self.push_doc(self.next_doc(EsOpaque)) {\n-                op(copy self.parent)\n-            }\n+        fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R) -> R {\n+            let doc = self.next_doc(EsOpaque);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = doc.start;\n+\n+            let result = op(self, doc);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n         }\n     }\n \n     impl serialize::Decoder for Decoder {\n-        fn read_nil(&self) -> () { () }\n+        fn read_nil(&mut self) -> () { () }\n \n-        fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-        fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-        fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-        fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-        fn read_uint(&self) -> uint {\n+        fn read_u64(&mut self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+        fn read_u32(&mut self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+        fn read_u16(&mut self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+        fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+        fn read_uint(&mut self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n             if v > (::core::uint::max_value as u64) {\n                 fail!(fmt!(\"uint %? too large for this architecture\", v));\n             }\n             v as uint\n         }\n \n-        fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n-        fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n-        fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n-        fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n-        fn read_int(&self) -> int {\n+        fn read_i64(&mut self) -> i64 {\n+            doc_as_u64(self.next_doc(EsI64)) as i64\n+        }\n+        fn read_i32(&mut self) -> i32 {\n+            doc_as_u32(self.next_doc(EsI32)) as i32\n+        }\n+        fn read_i16(&mut self) -> i16 {\n+            doc_as_u16(self.next_doc(EsI16)) as i16\n+        }\n+        fn read_i8 (&mut self) -> i8 {\n+            doc_as_u8(self.next_doc(EsI8 )) as i8\n+        }\n+        fn read_int(&mut self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n             if v > (int::max_value as i64) || v < (int::min_value as i64) {\n                 fail!(fmt!(\"int %? out of range for this architecture\", v));\n             }\n             v as int\n         }\n \n-        fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool))\n-                                         as bool }\n+        fn read_bool(&mut self) -> bool {\n+            doc_as_u8(self.next_doc(EsBool)) as bool\n+        }\n \n-        fn read_f64(&self) -> f64 { fail!(~\"read_f64()\"); }\n-        fn read_f32(&self) -> f32 { fail!(~\"read_f32()\"); }\n-        fn read_float(&self) -> float { fail!(~\"read_float()\"); }\n-        fn read_char(&self) -> char { fail!(~\"read_char()\"); }\n-        fn read_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+        fn read_f64(&mut self) -> f64 { fail!(~\"read_f64()\"); }\n+        fn read_f32(&mut self) -> f32 { fail!(~\"read_f32()\"); }\n+        fn read_float(&mut self) -> float { fail!(~\"read_float()\"); }\n+        fn read_char(&mut self) -> char { fail!(~\"read_char()\"); }\n+        fn read_str(&mut self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n \n         // Compound types:\n-        fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n+        fn read_enum<T>(&mut self,\n+                        name: &str,\n+                        f: &fn(&mut Decoder) -> T)\n+                        -> T {\n             debug!(\"read_enum(%s)\", name);\n             self._check_label(name);\n-            self.push_doc(self.next_doc(EsEnum), f)\n+\n+            let doc = self.next_doc(EsEnum);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n         }\n \n-        fn read_enum_variant<T>(&self, _names: &[&str], f: &fn(uint) -> T) -> T {\n+        fn read_enum_variant<T>(&mut self,\n+                                _: &[&str],\n+                                f: &fn(&mut Decoder, uint) -> T)\n+                                -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n             debug!(\"  idx=%u\", idx);\n-            do self.push_doc(self.next_doc(EsEnumBody)) {\n-                f(idx)\n-            }\n+\n+            let doc = self.next_doc(EsEnumBody);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self, idx);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n         }\n \n-        fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        fn read_enum_variant_arg<T>(&mut self,\n+                                    idx: uint,\n+                                    f: &fn(&mut Decoder) -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-            f()\n+            f(self)\n         }\n \n-        fn read_enum_struct_variant<T>(&self, _names: &[&str], f: &fn(uint) -> T) -> T {\n+        fn read_enum_struct_variant<T>(&mut self,\n+                                       _: &[&str],\n+                                       f: &fn(&mut Decoder, uint) -> T)\n+                                       -> T {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n             debug!(\"  idx=%u\", idx);\n-            do self.push_doc(self.next_doc(EsEnumBody)) {\n-                f(idx)\n-            }\n+\n+            let doc = self.next_doc(EsEnumBody);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self, idx);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n         }\n \n-        fn read_enum_struct_variant_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        fn read_enum_struct_variant_field<T>(&mut self,\n+                                             name: &str,\n+                                             idx: uint,\n+                                             f: &fn(&mut Decoder) -> T)\n+                                             -> T {\n             debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n-            f()\n+            f(self)\n         }\n \n-        fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n+        fn read_struct<T>(&mut self,\n+                          name: &str,\n+                          _: uint,\n+                          f: &fn(&mut Decoder) -> T)\n+                          -> T {\n             debug!(\"read_struct(name=%s)\", name);\n-            f()\n+            f(self)\n         }\n \n-        fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        fn read_struct_field<T>(&mut self,\n+                                name: &str,\n+                                idx: uint,\n+                                f: &fn(&mut Decoder) -> T)\n+                                -> T {\n             debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n             self._check_label(name);\n-            f()\n+            f(self)\n         }\n \n-        fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n+        fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n-        fn read_tuple_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+                             -> T {\n             debug!(\"read_tuple_arg(idx=%u)\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T>(&self, name: &str, f: &fn(uint) -> T) -> T {\n+        fn read_tuple_struct<T>(&mut self,\n+                                name: &str,\n+                                f: &fn(&mut Decoder, uint) -> T)\n+                                -> T {\n             debug!(\"read_tuple_struct(name=%?)\", name);\n             self.read_tuple(f)\n         }\n \n-        fn read_tuple_struct_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        fn read_tuple_struct_arg<T>(&mut self,\n+                                    idx: uint,\n+                                    f: &fn(&mut Decoder) -> T)\n+                                    -> T {\n             debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n+        fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n             debug!(\"read_option()\");\n-            do self.read_enum(\"Option\") || {\n-                do self.read_enum_variant([\"None\", \"Some\"]) |idx| {\n+            do self.read_enum(\"Option\") |this| {\n+                do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n                     match idx {\n-                        0 => f(false),\n-                        1 => f(true),\n+                        0 => f(this, false),\n+                        1 => f(this, true),\n                         _ => fail!(),\n                     }\n                 }\n             }\n         }\n \n-        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+        fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_seq()\");\n-            do self.push_doc(self.next_doc(EsVec)) {\n-                let len = self._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n-                f(len)\n-            }\n+            let doc = self.next_doc(EsVec);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let len = self._next_uint(EsVecLen);\n+            debug!(\"  len=%u\", len);\n+            let result = f(self, len);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n         }\n \n-        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+                           -> T {\n             debug!(\"read_seq_elt(idx=%u)\", idx);\n-            self.push_doc(self.next_doc(EsVecElt), f)\n+            let doc = self.next_doc(EsVecElt);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n         }\n \n-        fn read_map<T>(&self, _f: &fn(uint) -> T) -> T {\n+        fn read_map<T>(&mut self, _: &fn(&mut Decoder, uint) -> T) -> T {\n             debug!(\"read_map()\");\n             fail!(~\"read_map is unimplemented\");\n         }\n \n-        fn read_map_elt_key<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n+        fn read_map_elt_key<T>(&mut self,\n+                               idx: uint,\n+                               _: &fn(&mut Decoder) -> T)\n+                               -> T {\n             debug!(\"read_map_elt_key(idx=%u)\", idx);\n             fail!(~\"read_map_elt_val is unimplemented\");\n         }\n \n-        fn read_map_elt_val<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n+        fn read_map_elt_val<T>(&mut self,\n+                               idx: uint,\n+                               _: &fn(&mut Decoder) -> T)\n+                               -> T {\n             debug!(\"read_map_elt_val(idx=%u)\", idx);\n             fail!(~\"read_map_elt_val is unimplemented\");\n         }\n@@ -513,7 +631,7 @@ pub mod writer {\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n     pub impl Encoder {\n-        fn start_tag(&self, tag_id: uint) {\n+        fn start_tag(&mut self, tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n \n             // Write the enum ID:\n@@ -525,7 +643,7 @@ pub mod writer {\n             self.writer.write(zeroes);\n         }\n \n-        fn end_tag(&self) {\n+        fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop();\n             let cur_pos = self.writer.tell();\n             self.writer.seek(last_size_pos as int, io::SeekSet);\n@@ -536,72 +654,72 @@ pub mod writer {\n             debug!(\"End tag (size = %u)\", size);\n         }\n \n-        fn wr_tag(&self, tag_id: uint, blk: &fn()) {\n+        fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n         }\n \n-        fn wr_tagged_bytes(&self, tag_id: uint, b: &[u8]) {\n+        fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n             write_vuint(self.writer, vec::len(b));\n             self.writer.write(b);\n         }\n \n-        fn wr_tagged_u64(&self, tag_id: uint, v: u64) {\n+        fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n             do io::u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u32(&self, tag_id: uint, v: u32) {\n+        fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u16(&self, tag_id: uint, v: u16) {\n+        fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_u8(&self, tag_id: uint, v: u8) {\n+        fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n             self.wr_tagged_bytes(tag_id, &[v]);\n         }\n \n-        fn wr_tagged_i64(&self, tag_id: uint, v: i64) {\n+        fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n             do io::u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i32(&self, tag_id: uint, v: i32) {\n+        fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n             do io::u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i16(&self, tag_id: uint, v: i16) {\n+        fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n             do io::u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n-        fn wr_tagged_i8(&self, tag_id: uint, v: i8) {\n+        fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n             self.wr_tagged_bytes(tag_id, &[v as u8]);\n         }\n \n-        fn wr_tagged_str(&self, tag_id: uint, v: &str) {\n+        fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n             str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n         }\n \n-        fn wr_bytes(&self, b: &[u8]) {\n+        fn wr_bytes(&mut self, b: &[u8]) {\n             debug!(\"Write %u bytes\", vec::len(b));\n             self.writer.write(b);\n         }\n \n-        fn wr_str(&self, s: &str) {\n+        fn wr_str(&mut self, s: &str) {\n             debug!(\"Write str: %?\", s);\n             self.writer.write(str::to_bytes(s));\n         }\n@@ -612,16 +730,16 @@ pub mod writer {\n \n     // Set to true to generate more debugging in EBML code.\n     // Totally lame approach.\n-    static debug: bool = false;\n+    static debug: bool = true;\n \n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n+        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n             assert!(v <= 0xFFFF_FFFF_u); // FIXME(#6130) assert warns on 32-bit\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n \n-        fn _emit_label(&self, label: &str) {\n+        fn _emit_label(&mut self, label: &str) {\n             // There are various strings that we have access to, such as\n             // the name of a record field, which do not actually appear in\n             // the encoded EBML (normally).  This is just for\n@@ -633,118 +751,169 @@ pub mod writer {\n     }\n \n     pub impl Encoder {\n-        fn emit_opaque(&self, f: &fn()) {\n-            do self.wr_tag(EsOpaque as uint) {\n-                f()\n-            }\n+        fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsOpaque as uint);\n+            f(self);\n+            self.end_tag();\n         }\n     }\n \n     impl ::serialize::Encoder for Encoder {\n-        fn emit_nil(&self) {}\n+        fn emit_nil(&mut self) {}\n \n-        fn emit_uint(&self, v: uint) {\n+        fn emit_uint(&mut self, v: uint) {\n             self.wr_tagged_u64(EsUint as uint, v as u64);\n         }\n-        fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-        fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-        fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-        fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n+        fn emit_u64(&mut self, v: u64) {\n+            self.wr_tagged_u64(EsU64 as uint, v);\n+        }\n+        fn emit_u32(&mut self, v: u32) {\n+            self.wr_tagged_u32(EsU32 as uint, v);\n+        }\n+        fn emit_u16(&mut self, v: u16) {\n+            self.wr_tagged_u16(EsU16 as uint, v);\n+        }\n+        fn emit_u8(&mut self, v: u8) {\n+            self.wr_tagged_u8(EsU8 as uint, v);\n+        }\n \n-        fn emit_int(&self, v: int) {\n+        fn emit_int(&mut self, v: int) {\n             self.wr_tagged_i64(EsInt as uint, v as i64);\n         }\n-        fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-        fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-        fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-        fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n+        fn emit_i64(&mut self, v: i64) {\n+            self.wr_tagged_i64(EsI64 as uint, v);\n+        }\n+        fn emit_i32(&mut self, v: i32) {\n+            self.wr_tagged_i32(EsI32 as uint, v);\n+        }\n+        fn emit_i16(&mut self, v: i16) {\n+            self.wr_tagged_i16(EsI16 as uint, v);\n+        }\n+        fn emit_i8(&mut self, v: i8) {\n+            self.wr_tagged_i8(EsI8 as uint, v);\n+        }\n \n-        fn emit_bool(&self, v: bool) {\n+        fn emit_bool(&mut self, v: bool) {\n             self.wr_tagged_u8(EsBool as uint, v as u8)\n         }\n \n         // FIXME (#2742): implement these\n-        fn emit_f64(&self, _v: f64) {\n+        fn emit_f64(&mut self, _v: f64) {\n             fail!(~\"Unimplemented: serializing an f64\");\n         }\n-        fn emit_f32(&self, _v: f32) {\n+        fn emit_f32(&mut self, _v: f32) {\n             fail!(~\"Unimplemented: serializing an f32\");\n         }\n-        fn emit_float(&self, _v: float) {\n+        fn emit_float(&mut self, _v: float) {\n             fail!(~\"Unimplemented: serializing a float\");\n         }\n \n-        fn emit_char(&self, _v: char) {\n+        fn emit_char(&mut self, _v: char) {\n             fail!(~\"Unimplemented: serializing a char\");\n         }\n \n-        fn emit_str(&self, v: &str) {\n+        fn emit_str(&mut self, v: &str) {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&self, name: &str, f: &fn()) {\n+        fn emit_enum(&mut self, name: &str, f: &fn(&mut Encoder)) {\n             self._emit_label(name);\n-            self.wr_tag(EsEnum as uint, f)\n+            self.start_tag(EsEnum as uint);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n-                             f: &fn()) {\n+        fn emit_enum_variant(&mut self,\n+                             _: &str,\n+                             v_id: uint,\n+                             _: uint,\n+                             f: &fn(&mut Encoder)) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n-            self.wr_tag(EsEnumBody as uint, f)\n+            self.start_tag(EsEnumBody as uint);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: &fn(&mut Encoder)) {\n+            f(self)\n+        }\n \n-        fn emit_enum_struct_variant(&self, v_name: &str, v_id: uint, cnt: uint, f: &fn()) {\n+        fn emit_enum_struct_variant(&mut self,\n+                                    v_name: &str,\n+                                    v_id: uint,\n+                                    cnt: uint,\n+                                    f: &fn(&mut Encoder)) {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field(&self, _f_name: &str, idx: uint, f: &fn()) {\n+        fn emit_enum_struct_variant_field(&mut self,\n+                                          _: &str,\n+                                          idx: uint,\n+                                          f: &fn(&mut Encoder)) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n-        fn emit_struct_field(&self, name: &str, _idx: uint, f: &fn()) {\n+        fn emit_struct(&mut self, _: &str, _len: uint, f: &fn(&mut Encoder)) {\n+            f(self)\n+        }\n+\n+        fn emit_struct_field(&mut self,\n+                             name: &str,\n+                             _: uint,\n+                             f: &fn(&mut Encoder)) {\n             self._emit_label(name);\n-            f()\n+            f(self)\n         }\n \n-        fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-        fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+        fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+            self.emit_seq_elt(idx, f)\n+        }\n \n-        fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-        fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+        fn emit_tuple_struct(&mut self,\n+                             _: &str,\n+                             len: uint,\n+                             f: &fn(&mut Encoder)) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+            self.emit_seq_elt(idx, f)\n+        }\n \n-        fn emit_option(&self, f: &fn()) {\n+        fn emit_option(&mut self, f: &fn(&mut Encoder)) {\n             self.emit_enum(\"Option\", f);\n         }\n-        fn emit_option_none(&self) {\n-            self.emit_enum_variant(\"None\", 0, 0, || ())\n+        fn emit_option_none(&mut self) {\n+            self.emit_enum_variant(\"None\", 0, 0, |_| ())\n         }\n-        fn emit_option_some(&self, f: &fn()) {\n+        fn emit_option_some(&mut self, f: &fn(&mut Encoder)) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&self, len: uint, f: &fn()) {\n-            do self.wr_tag(EsVec as uint) {\n-                self._emit_tagged_uint(EsVecLen, len);\n-                f()\n-            }\n+        fn emit_seq(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsVec as uint);\n+            self._emit_tagged_uint(EsVecLen, len);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n-            self.wr_tag(EsVecElt as uint, f)\n+        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+            self.start_tag(EsVecElt as uint);\n+            f(self);\n+            self.end_tag();\n         }\n \n-        fn emit_map(&self, _len: uint, _f: &fn()) {\n+        fn emit_map(&mut self, _len: uint, _f: &fn(&mut Encoder)) {\n             fail!(~\"emit_map is unimplemented\");\n         }\n \n-        fn emit_map_elt_key(&self, _idx: uint, _f: &fn()) {\n+        fn emit_map_elt_key(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n             fail!(~\"emit_map_elt_key is unimplemented\");\n         }\n \n-        fn emit_map_elt_val(&self, _idx: uint, _f: &fn()) {\n+        fn emit_map_elt_val(&mut self, _idx: uint, _f: &fn(&mut Encoder)) {\n             fail!(~\"emit_map_elt_val is unimplemented\");\n         }\n     }\n@@ -768,12 +937,12 @@ mod tests {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == %?\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = writer::Encoder(wr);\n-                v.encode(&ebml_w)\n+                let mut ebml_w = writer::Encoder(wr);\n+                v.encode(&mut ebml_w)\n             };\n             let ebml_doc = reader::Doc(@bytes);\n-            let deser = reader::Decoder(ebml_doc);\n-            let v1 = serialize::Decodable::decode(&deser);\n+            let mut deser = reader::Decoder(ebml_doc);\n+            let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == %?\", v1);\n             assert!(v == v1);\n         }"}, {"sha": "88de53f360519a3f291b7e34801f783ba640225e", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -439,19 +439,23 @@ pub mod flatteners {\n     */\n \n     pub fn deserialize_buffer<D: Decoder + FromReader,\n-                              T: Decodable<D>>(buf: &[u8]) -> T {\n+                              T: Decodable<D>>(\n+                              buf: &[u8])\n+                              -> T {\n         let buf = vec::from_slice(buf);\n         let buf_reader = @BufReader::new(buf);\n         let reader = buf_reader as @Reader;\n-        let deser: D = FromReader::from_reader(reader);\n-        Decodable::decode(&deser)\n+        let mut deser: D = FromReader::from_reader(reader);\n+        Decodable::decode(&mut deser)\n     }\n \n     pub fn serialize_value<D: Encoder + FromWriter,\n-                           T: Encodable<D>>(val: &T) -> ~[u8] {\n+                           T: Encodable<D>>(\n+                           val: &T)\n+                           -> ~[u8] {\n         do io::with_bytes_writer |writer| {\n-            let ser = FromWriter::from_writer(writer);\n-            val.encode(&ser);\n+            let mut ser = FromWriter::from_writer(writer);\n+            val.encode(&mut ser);\n         }\n     }\n \n@@ -649,6 +653,7 @@ mod test {\n     }\n \n     #[test]\n+    #[ignore(reason = \"FIXME #6211 failing on linux snapshot machine\")]\n     fn test_serializing_pipes() {\n         let (port, chan) = serial::pipe_stream();\n "}, {"sha": "c03042fe9c2bfc63d1b0818996e3f4d8c87b78db", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1374,11 +1374,3 @@ Options:\n         assert!(usage == expected)\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "3960a07dfce7bb6f3c2ea9f51f0503a79413b985", "filename": "src/libstd/json.rs", "status": "modified", "additions": 333, "deletions": 197, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -72,44 +72,50 @@ pub struct Encoder {\n }\n \n pub fn Encoder(wr: @io::Writer) -> Encoder {\n-    Encoder { wr: wr }\n+    Encoder {\n+        wr: wr\n+    }\n }\n \n impl serialize::Encoder for Encoder {\n-    fn emit_nil(&self) { self.wr.write_str(\"null\") }\n+    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n \n-    fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n-    fn emit_u64(&self, v: u64) { self.emit_float(v as float); }\n-    fn emit_u32(&self, v: u32) { self.emit_float(v as float); }\n-    fn emit_u16(&self, v: u16) { self.emit_float(v as float); }\n-    fn emit_u8(&self, v: u8)   { self.emit_float(v as float); }\n+    fn emit_uint(&mut self, v: uint) { self.emit_float(v as float); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_float(v as float); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_float(v as float); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_float(v as float); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_float(v as float); }\n \n-    fn emit_int(&self, v: int) { self.emit_float(v as float); }\n-    fn emit_i64(&self, v: i64) { self.emit_float(v as float); }\n-    fn emit_i32(&self, v: i32) { self.emit_float(v as float); }\n-    fn emit_i16(&self, v: i16) { self.emit_float(v as float); }\n-    fn emit_i8(&self, v: i8)   { self.emit_float(v as float); }\n+    fn emit_int(&mut self, v: int) { self.emit_float(v as float); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_float(v as float); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_float(v as float); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_float(v as float); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_float(v as float); }\n \n-    fn emit_bool(&self, v: bool) {\n+    fn emit_bool(&mut self, v: bool) {\n         if v {\n             self.wr.write_str(\"true\");\n         } else {\n             self.wr.write_str(\"false\");\n         }\n     }\n \n-    fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n-    fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n-    fn emit_float(&self, v: float) {\n+    fn emit_f64(&mut self, v: f64) { self.emit_float(v as float); }\n+    fn emit_f32(&mut self, v: f32) { self.emit_float(v as float); }\n+    fn emit_float(&mut self, v: float) {\n         self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n-    fn emit_char(&self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)) }\n+    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)) }\n \n-    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n+    fn emit_enum(&mut self, _name: &str, f: &fn(&mut Encoder)) { f(self) }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _id: uint,\n+                         cnt: uint,\n+                         f: &fn(&mut Encoder)) {\n         // enums are encoded as strings or vectors:\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n@@ -120,71 +126,97 @@ impl serialize::Encoder for Encoder {\n             self.wr.write_char('[');\n             self.wr.write_str(escape_str(name));\n             self.wr.write_char(',');\n-            f();\n+            f(self);\n             self.wr.write_char(']');\n         }\n     }\n \n-    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-        if idx != 0 {self.wr.write_char(',');}\n-        f();\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        if idx != 0 {\n+            self.wr.write_char(',');\n+        }\n+        f(self);\n     }\n \n-    fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_struct_variant(&mut self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: &fn(&mut Encoder)) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&self, _field: &str, idx: uint, f: &fn()) {\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: &fn(&mut Encoder)) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n+    fn emit_struct(&mut self, _: &str, _: uint, f: &fn(&mut Encoder)) {\n         self.wr.write_char('{');\n-        f();\n+        f(self);\n         self.wr.write_char('}');\n     }\n-    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n+\n+    fn emit_struct_field(&mut self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: &fn(&mut Encoder)) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n-        f();\n+        f(self);\n     }\n \n-    fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n-    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple_struct(&mut self,\n+                         _name: &str,\n+                         len: uint,\n+                         f: &fn(&mut Encoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n-    fn emit_option(&self, f: &fn()) { f(); }\n-    fn emit_option_none(&self) { self.emit_nil(); }\n-    fn emit_option_some(&self, f: &fn()) { f(); }\n+    fn emit_option(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+    fn emit_option_none(&mut self) { self.emit_nil(); }\n+    fn emit_option_some(&mut self, f: &fn(&mut Encoder)) { f(self); }\n \n-    fn emit_seq(&self, _len: uint, f: &fn()) {\n+    fn emit_seq(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n         self.wr.write_char('[');\n-        f();\n+        f(self);\n         self.wr.write_char(']');\n     }\n \n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        f()\n+    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        if idx != 0 {\n+            self.wr.write_char(',');\n+        }\n+        f(self)\n     }\n \n-    fn emit_map(&self, _len: uint, f: &fn()) {\n+    fn emit_map(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n         self.wr.write_char('{');\n-        f();\n+        f(self);\n         self.wr.write_char('}');\n     }\n \n-    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n         if idx != 0 { self.wr.write_char(','); }\n-        f()\n+        f(self)\n     }\n \n-    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n         self.wr.write_char(':');\n-        f()\n+        f(self)\n     }\n }\n \n@@ -194,44 +226,53 @@ pub struct PrettyEncoder {\n }\n \n pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n-    PrettyEncoder { wr: wr, indent: 0 }\n+    PrettyEncoder {\n+        wr: wr,\n+        indent: 0,\n+    }\n }\n \n impl serialize::Encoder for PrettyEncoder {\n-    fn emit_nil(&self) { self.wr.write_str(\"null\") }\n+    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n \n-    fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n-    fn emit_u64(&self, v: u64) { self.emit_float(v as float); }\n-    fn emit_u32(&self, v: u32) { self.emit_float(v as float); }\n-    fn emit_u16(&self, v: u16) { self.emit_float(v as float); }\n-    fn emit_u8(&self, v: u8)   { self.emit_float(v as float); }\n+    fn emit_uint(&mut self, v: uint) { self.emit_float(v as float); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_float(v as float); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_float(v as float); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_float(v as float); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_float(v as float); }\n \n-    fn emit_int(&self, v: int) { self.emit_float(v as float); }\n-    fn emit_i64(&self, v: i64) { self.emit_float(v as float); }\n-    fn emit_i32(&self, v: i32) { self.emit_float(v as float); }\n-    fn emit_i16(&self, v: i16) { self.emit_float(v as float); }\n-    fn emit_i8(&self, v: i8)   { self.emit_float(v as float); }\n+    fn emit_int(&mut self, v: int) { self.emit_float(v as float); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_float(v as float); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_float(v as float); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_float(v as float); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_float(v as float); }\n \n-    fn emit_bool(&self, v: bool) {\n+    fn emit_bool(&mut self, v: bool) {\n         if v {\n             self.wr.write_str(\"true\");\n         } else {\n             self.wr.write_str(\"false\");\n         }\n     }\n \n-    fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n-    fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n-    fn emit_float(&self, v: float) {\n+    fn emit_f64(&mut self, v: f64) { self.emit_float(v as float); }\n+    fn emit_f32(&mut self, v: f32) { self.emit_float(v as float); }\n+    fn emit_float(&mut self, v: float) {\n         self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n-    fn emit_char(&self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n+    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)); }\n \n-    fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n+    fn emit_enum(&mut self, _name: &str, f: &fn(&mut PrettyEncoder)) {\n+        f(self)\n+    }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _: uint,\n+                         cnt: uint,\n+                         f: &fn(&mut PrettyEncoder)) {\n         if cnt == 0 {\n             self.wr.write_str(escape_str(name));\n         } else {\n@@ -241,45 +282,61 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_str(spaces(self.indent));\n             self.wr.write_str(escape_str(name));\n             self.wr.write_str(\",\\n\");\n-            f();\n+            f(self);\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n             self.wr.write_char(']');\n         }\n     }\n \n-    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n+    fn emit_enum_variant_arg(&mut self,\n+                             idx: uint,\n+                             f: &fn(&mut PrettyEncoder)) {\n         if idx != 0 {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        f()\n+        f(self)\n     }\n \n-    fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+    fn emit_enum_struct_variant(&mut self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: &fn(&mut PrettyEncoder)) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_enum_struct_variant_field(&self, _field: &str, idx: uint, f: &fn()) {\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: &fn(&mut PrettyEncoder)) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n-    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n+    fn emit_struct(&mut self,\n+                   _: &str,\n+                   len: uint,\n+                   f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n             self.wr.write_str(\"{}\");\n         } else {\n             self.wr.write_char('{');\n             self.indent += 2;\n-            f();\n+            f(self);\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n             self.wr.write_char('}');\n         }\n     }\n-    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n+\n+    fn emit_struct_field(&mut self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -288,73 +345,88 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(spaces(self.indent));\n         self.wr.write_str(escape_str(name));\n         self.wr.write_str(\": \");\n-        f();\n+        f(self);\n     }\n \n-    fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n-    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n-    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+    fn emit_tuple_struct(&mut self,\n+                         _: &str,\n+                         len: uint,\n+                         f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&mut self,\n+                             idx: uint,\n+                             f: &fn(&mut PrettyEncoder)) {\n+        self.emit_seq_elt(idx, f)\n+    }\n \n-    fn emit_option(&self, f: &fn()) { f(); }\n-    fn emit_option_none(&self) { self.emit_nil(); }\n-    fn emit_option_some(&self, f: &fn()) { f(); }\n+    fn emit_option(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+    fn emit_option_none(&mut self) { self.emit_nil(); }\n+    fn emit_option_some(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n \n-    fn emit_seq(&self, len: uint, f: &fn()) {\n+    fn emit_seq(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n             self.wr.write_str(\"[]\");\n         } else {\n             self.wr.write_char('[');\n             self.indent += 2;\n-            f();\n+            f(self);\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n             self.wr.write_char(']');\n         }\n     }\n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n+\n+    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        f()\n+        f(self)\n     }\n \n-    fn emit_map(&self, len: uint, f: &fn()) {\n+    fn emit_map(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n             self.wr.write_str(\"{}\");\n         } else {\n             self.wr.write_char('{');\n             self.indent += 2;\n-            f();\n+            f(self);\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n             self.wr.write_char('}');\n         }\n     }\n-    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n+\n+    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        f();\n+        f(self);\n     }\n \n-    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut PrettyEncoder)) {\n         self.wr.write_str(\": \");\n-        f();\n+        f(self);\n     }\n }\n \n impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n-    fn encode(&self, e: &E) {\n+    fn encode(&self, e: &mut E) {\n         match *self {\n             Number(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n@@ -368,7 +440,8 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n /// Encodes a json value into a io::writer\n pub fn to_writer(wr: @io::Writer, json: &Json) {\n-    json.encode(&Encoder(wr))\n+    let mut encoder = Encoder(wr);\n+    json.encode(&mut encoder)\n }\n \n /// Encodes a json value into a string\n@@ -378,7 +451,8 @@ pub fn to_str(json: &Json) -> ~str {\n \n /// Encodes a json value into a io::writer\n pub fn to_pretty_writer(wr: @io::Writer, json: &Json) {\n-    json.encode(&PrettyEncoder(wr))\n+    let mut encoder = PrettyEncoder(wr);\n+    json.encode(&mut encoder)\n }\n \n /// Encodes a json value into a string\n@@ -769,69 +843,74 @@ pub struct Decoder {\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n-    Decoder { stack: ~[json] }\n+    Decoder {\n+        stack: ~[json]\n+    }\n }\n \n impl serialize::Decoder for Decoder {\n-    fn read_nil(&self) -> () {\n+    fn read_nil(&mut self) -> () {\n         debug!(\"read_nil\");\n         match self.stack.pop() {\n             Null => (),\n             value => fail!(fmt!(\"not a null: %?\", value))\n         }\n     }\n \n-    fn read_u64(&self)  -> u64  { self.read_float() as u64 }\n-    fn read_u32(&self)  -> u32  { self.read_float() as u32 }\n-    fn read_u16(&self)  -> u16  { self.read_float() as u16 }\n-    fn read_u8 (&self)  -> u8   { self.read_float() as u8 }\n-    fn read_uint(&self) -> uint { self.read_float() as uint }\n+    fn read_u64(&mut self)  -> u64  { self.read_float() as u64 }\n+    fn read_u32(&mut self)  -> u32  { self.read_float() as u32 }\n+    fn read_u16(&mut self)  -> u16  { self.read_float() as u16 }\n+    fn read_u8 (&mut self)  -> u8   { self.read_float() as u8 }\n+    fn read_uint(&mut self) -> uint { self.read_float() as uint }\n \n-    fn read_i64(&self) -> i64 { self.read_float() as i64 }\n-    fn read_i32(&self) -> i32 { self.read_float() as i32 }\n-    fn read_i16(&self) -> i16 { self.read_float() as i16 }\n-    fn read_i8 (&self) -> i8  { self.read_float() as i8 }\n-    fn read_int(&self) -> int { self.read_float() as int }\n+    fn read_i64(&mut self) -> i64 { self.read_float() as i64 }\n+    fn read_i32(&mut self) -> i32 { self.read_float() as i32 }\n+    fn read_i16(&mut self) -> i16 { self.read_float() as i16 }\n+    fn read_i8 (&mut self) -> i8  { self.read_float() as i8 }\n+    fn read_int(&mut self) -> int { self.read_float() as int }\n \n-    fn read_bool(&self) -> bool {\n+    fn read_bool(&mut self) -> bool {\n         debug!(\"read_bool\");\n         match self.stack.pop() {\n             Boolean(b) => b,\n             value => fail!(fmt!(\"not a boolean: %?\", value))\n         }\n     }\n \n-    fn read_f64(&self) -> f64 { self.read_float() as f64 }\n-    fn read_f32(&self) -> f32 { self.read_float() as f32 }\n-    fn read_float(&self) -> float {\n+    fn read_f64(&mut self) -> f64 { self.read_float() as f64 }\n+    fn read_f32(&mut self) -> f32 { self.read_float() as f32 }\n+    fn read_float(&mut self) -> float {\n         debug!(\"read_float\");\n         match self.stack.pop() {\n             Number(f) => f,\n             value => fail!(fmt!(\"not a number: %?\", value))\n         }\n     }\n \n-    fn read_char(&self) -> char {\n+    fn read_char(&mut self) -> char {\n         let mut v = ~[];\n         for str::each_char(self.read_str()) |c| { v.push(c) }\n         if v.len() != 1 { fail!(~\"string must have one character\") }\n         v[0]\n     }\n \n-    fn read_str(&self) -> ~str {\n+    fn read_str(&mut self) -> ~str {\n         debug!(\"read_str\");\n         match self.stack.pop() {\n             String(s) => s,\n             json => fail!(fmt!(\"not a string: %?\", json))\n         }\n     }\n \n-    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n+    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n-        f()\n+        f(self)\n     }\n \n-    fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n+    fn read_enum_variant<T>(&mut self,\n+                            names: &[&str],\n+                            f: &fn(&mut Decoder, uint) -> T)\n+                            -> T {\n         debug!(\"read_enum_variant(names=%?)\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n@@ -850,33 +929,51 @@ impl serialize::Decoder for Decoder {\n             Some(idx) => idx,\n             None => fail!(fmt!(\"Unknown variant name: %?\", name)),\n         };\n-        f(idx)\n+        f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+    fn read_enum_variant_arg<T>(&mut self,\n+                                idx: uint,\n+                                f: &fn(&mut Decoder) -> T)\n+                                -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        f()\n+        f(self)\n     }\n \n-    fn read_enum_struct_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n+    fn read_enum_struct_variant<T>(&mut self,\n+                                   names: &[&str],\n+                                   f: &fn(&mut Decoder, uint) -> T)\n+                                   -> T {\n         debug!(\"read_enum_struct_variant(names=%?)\", names);\n         self.read_enum_variant(names, f)\n     }\n \n \n-    fn read_enum_struct_variant_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+    fn read_enum_struct_variant_field<T>(&mut self,\n+                                         name: &str,\n+                                         idx: uint,\n+                                         f: &fn(&mut Decoder) -> T)\n+                                         -> T {\n         debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n-    fn read_struct<T>(&self, name: &str, len: uint, f: &fn() -> T) -> T {\n+    fn read_struct<T>(&mut self,\n+                      name: &str,\n+                      len: uint,\n+                      f: &fn(&mut Decoder) -> T)\n+                      -> T {\n         debug!(\"read_struct(name=%s, len=%u)\", name, len);\n-        let value = f();\n+        let value = f(self);\n         self.stack.pop();\n         value\n     }\n \n-    fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+    fn read_struct_field<T>(&mut self,\n+                            name: &str,\n+                            idx: uint,\n+                            f: &fn(&mut Decoder) -> T)\n+                            -> T {\n         debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n@@ -885,7 +982,7 @@ impl serialize::Decoder for Decoder {\n                     None => fail!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n                         self.stack.push(json);\n-                        f()\n+                        f(self)\n                     }\n                 };\n                 self.stack.push(Object(obj));\n@@ -895,34 +992,43 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n+    fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n         debug!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n-    fn read_tuple_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+    fn read_tuple_arg<T>(&mut self,\n+                         idx: uint,\n+                         f: &fn(&mut Decoder) -> T)\n+                         -> T {\n         debug!(\"read_tuple_arg(idx=%u)\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n-    fn read_tuple_struct<T>(&self, name: &str, f: &fn(uint) -> T) -> T {\n+    fn read_tuple_struct<T>(&mut self,\n+                            name: &str,\n+                            f: &fn(&mut Decoder, uint) -> T)\n+                            -> T {\n         debug!(\"read_tuple_struct(name=%?)\", name);\n         self.read_tuple(f)\n     }\n \n-    fn read_tuple_struct_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+    fn read_tuple_struct_arg<T>(&mut self,\n+                                idx: uint,\n+                                f: &fn(&mut Decoder) -> T)\n+                                -> T {\n         debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n+    fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n         match self.stack.pop() {\n-            Null => f(false),\n-            value => { self.stack.push(value); f(true) }\n+            Null => f(self, false),\n+            value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+    fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n         debug!(\"read_seq()\");\n         let len = match self.stack.pop() {\n             List(list) => {\n@@ -934,15 +1040,15 @@ impl serialize::Decoder for Decoder {\n             }\n             _ => fail!(~\"not a list\"),\n         };\n-        f(len)\n+        f(self, len)\n     }\n \n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n         debug!(\"read_seq_elt(idx=%u)\", idx);\n-        f()\n+        f(self)\n     }\n \n-    fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n+    fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n         debug!(\"read_map()\");\n         let len = match self.stack.pop() {\n             Object(obj) => {\n@@ -956,17 +1062,21 @@ impl serialize::Decoder for Decoder {\n             }\n             json => fail!(fmt!(\"not an object: %?\", json)),\n         };\n-        f(len)\n+        f(self, len)\n     }\n \n-    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+    fn read_map_elt_key<T>(&mut self,\n+                           idx: uint,\n+                           f: &fn(&mut Decoder) -> T)\n+                           -> T {\n         debug!(\"read_map_elt_key(idx=%u)\", idx);\n-        f()\n+        f(self)\n     }\n \n-    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+                           -> T {\n         debug!(\"read_map_elt_val(idx=%u)\", idx);\n-        f()\n+        f(self)\n     }\n }\n \n@@ -1404,31 +1514,31 @@ mod tests {\n         let animal = Dog;\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = Encoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = Encoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = PrettyEncoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = PrettyEncoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = Encoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = Encoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\"\n         );\n         assert_eq!(\n             do io::with_str_writer |wr| {\n-                let encoder = PrettyEncoder(wr);\n-                animal.encode(&encoder);\n+                let mut encoder = PrettyEncoder(wr);\n+                animal.encode(&mut encoder);\n             },\n             ~\"\\\n             [\\n  \\\n@@ -1443,15 +1553,15 @@ mod tests {\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n         let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = Encoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = do io::with_str_writer |wr| {\n-            let encoder = PrettyEncoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = PrettyEncoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n     }\n@@ -1460,14 +1570,14 @@ mod tests {\n     fn test_write_none() {\n         let value: Option<~str> = None;\n         let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = Encoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"null\");\n \n         let s = do io::with_str_writer |wr| {\n-            let encoder = Encoder(wr);\n-            value.encode(&encoder);\n+            let mut encoder = Encoder(wr);\n+            value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"null\");\n     }\n@@ -1515,13 +1625,16 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let v: () = Decodable::decode(&Decoder(from_str(~\"null\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let v: bool = Decodable::decode(&Decoder(from_str(~\"true\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"true\").unwrap());\n+        let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let v: bool = Decodable::decode(&Decoder(from_str(~\"false\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"false\").unwrap());\n+        let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n \n@@ -1555,25 +1668,32 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let v: float = Decodable::decode(&Decoder(from_str(~\"3\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"3\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"3.1\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"3.1\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"-1.2\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"-1.2\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e5\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4e5\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e15\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4e15\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15f);\n \n-        let v: float = Decodable::decode(&Decoder(from_str(~\"0.4e-01\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"0.4e-01\").unwrap());\n+        let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01f);\n     }\n \n@@ -1600,31 +1720,40 @@ mod tests {\n \n     #[test]\n     fn test_decode_str() {\n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"foo\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"foo\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let v: ~str = Decodable::decode(&Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n \n@@ -1656,23 +1785,28 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let v: ~[()] = Decodable::decode(&Decoder(from_str(~\"[]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[]\").unwrap());\n+        let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let v: ~[()] = Decodable::decode(&Decoder(from_str(~\"[null]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[null]\").unwrap());\n+        let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-\n-        let v: ~[bool] = Decodable::decode(&Decoder(from_str(~\"[true]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let v: ~[bool] = Decodable::decode(&Decoder(from_str(~\"[true]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let v: ~[int] = Decodable::decode(&Decoder(from_str(~\"[3, 1]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[3, 1]\").unwrap());\n+        let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let v: ~[~[uint]] = Decodable::decode(&Decoder(from_str(~\"[[3], [1, 2]]\").unwrap()));\n+        let mut decoder = Decoder(from_str(~\"[[3], [1, 2]]\").unwrap());\n+        let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n \n@@ -1774,7 +1908,8 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let v: Outer = Decodable::decode(&Decoder(from_str(s).unwrap()));\n+        let mut decoder = Decoder(from_str(s).unwrap());\n+        let v: Outer = Decodable::decode(&mut decoder);\n         assert_eq!(\n             v,\n             Outer {\n@@ -1787,31 +1922,32 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let decoder = Decoder(from_str(~\"null\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n-        let value: Animal = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n+        let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n-        let decoder = Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n-        let value: Animal = Decodable::decode(&decoder);\n+        let mut decoder =\n+            Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n+        let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n-        let decoder = Decoder(from_str(s).unwrap());\n-        let mut map: HashMap<~str, Animal> = Decodable::decode(&decoder);\n+        let mut decoder = Decoder(from_str(s).unwrap());\n+        let mut map: HashMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n         assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));"}, {"sha": "8d15508b26e05d53380af17369b470a329dd1406", "filename": "src/libstd/list.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -16,6 +16,12 @@ pub enum List<T> {\n     Nil,\n }\n \n+#[deriving(Eq)]\n+pub enum MutList<T> {\n+    MutCons(T, @mut MutList<T>),\n+    MutNil,\n+}\n+\n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n@@ -147,6 +153,25 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     }\n }\n \n+impl<T> MutList<T> {\n+    /// Iterate over a mutable list\n+    pub fn each(@mut self, f: &fn(&mut T) -> bool) {\n+        let mut cur = self;\n+        loop {\n+            let borrowed = &mut *cur;\n+            cur = match *borrowed {\n+                MutCons(ref mut hd, tl) => {\n+                    if !f(hd) {\n+                        return;\n+                    }\n+                    tl\n+                }\n+                MutNil => break\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use list::*;\n@@ -242,11 +267,3 @@ mod tests {\n             == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "53eb6c5561b682b6c4eb6685d8c69419442247a4", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -11,8 +11,6 @@\n //! High-level interface to libuv's TCP functionality\n // FIXME #4425: Need FFI fixes\n \n-#[allow(deprecated_mode)];\n-\n use future;\n use future_spawn = future::spawn;\n use ip = net_ip;"}, {"sha": "ba3fd69e344c29f6ad56489144da25fae907299c", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -10,18 +10,12 @@\n \n //! Types/fns concerning URLs (see RFC 3986)\n \n-#[allow(deprecated_mode)];\n-\n use core::cmp::Eq;\n-use core::from_str::FromStr;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n use core::hashmap::HashMap;\n use core::str;\n-use core::to_bytes::IterBytes;\n use core::to_bytes;\n-use core::to_str::ToStr;\n-use core::to_str;\n use core::uint;\n \n #[deriving(Clone, Eq)]\n@@ -703,13 +697,13 @@ pub fn to_str(url: &Url) -> ~str {\n     fmt!(\"%s:%s%s%s%s\", url.scheme, authority, url.path, query, fragment)\n }\n \n-impl to_str::ToStr for Url {\n+impl ToStr for Url {\n     pub fn to_str(&self) -> ~str {\n         to_str(self)\n     }\n }\n \n-impl to_bytes::IterBytes for Url {\n+impl IterBytes for Url {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_str().iter_bytes(lsb0, f)\n     }"}, {"sha": "cd347098e25117def232970e899076ef70532c20", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -21,7 +21,6 @@ A BigInt is a combination of BigUint and Sign.\n \n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix};\n-use core::*;\n \n /**\n A BigDigit is a BigUint's composing element.\n@@ -80,6 +79,7 @@ A big unsigned integer type.\n A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n (a + b * BigDigit::base + c * BigDigit::base^2).\n */\n+#[deriving(Clone)]\n pub struct BigUint {\n     priv data: ~[BigDigit]\n }\n@@ -140,7 +140,7 @@ impl ToStr for BigUint {\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n-impl from_str::FromStr for BigUint {\n+impl FromStr for BigUint {\n     #[inline(always)]\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n@@ -293,18 +293,18 @@ impl Mul<BigUint, BigUint> for BigUint {\n     }\n }\n \n-impl Quot<BigUint, BigUint> for BigUint {\n+impl Div<BigUint, BigUint> for BigUint {\n     #[inline(always)]\n-    fn quot(&self, other: &BigUint) -> BigUint {\n-        let (q, _) = self.quot_rem(other);\n+    fn div(&self, other: &BigUint) -> BigUint {\n+        let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n     #[inline(always)]\n     fn rem(&self, other: &BigUint) -> BigUint {\n-        let (_, r) = self.quot_rem(other);\n+        let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n@@ -316,19 +316,24 @@ impl Neg<BigUint> for BigUint {\n \n impl Integer for BigUint {\n     #[inline(always)]\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.div_mod(other);\n+    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        self.div_mod_floor(other)\n+    }\n+\n+    #[inline(always)]\n+    fn div_floor(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n     #[inline(always)]\n-    fn modulo(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.div_mod(other);\n+    fn mod_floor(&self, other: &BigUint) -> BigUint {\n+        let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n     #[inline(always)]\n-    fn div_mod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n@@ -346,11 +351,11 @@ impl Integer for BigUint {\n             shift += 1;\n         }\n         assert!(shift < BigDigit::bits);\n-        let (d, m) = div_mod_inner(self << shift, other << shift);\n+        let (d, m) = div_mod_floor_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n         #[inline(always)]\n-        fn div_mod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+        fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut m = a;\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n@@ -409,11 +414,6 @@ impl Integer for BigUint {\n         }\n     }\n \n-    #[inline(always)]\n-    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.div_mod(other)\n-    }\n-\n     /**\n      * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n      *\n@@ -485,7 +485,7 @@ impl ToStrRadix for BigUint {\n             let mut result = ~[];\n             let mut m      = n;\n             while m > divider {\n-                let (d, m0) = m.div_mod(&divider);\n+                let (d, m0) = m.div_mod_floor(&divider);\n                 result += [m0.to_uint() as BigDigit];\n                 m = d;\n             }\n@@ -680,7 +680,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n }\n \n /// A Sign is a BigInt's composing element.\n-#[deriving(Eq)]\n+#[deriving(Eq, Clone)]\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n@@ -726,6 +726,7 @@ impl Neg<Sign> for Sign {\n }\n \n /// A big signed integer type.\n+#[deriving(Clone)]\n pub struct BigInt {\n     priv sign: Sign,\n     priv data: BigUint\n@@ -783,7 +784,7 @@ impl ToStr for BigInt {\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n-impl from_str::FromStr for BigInt {\n+impl FromStr for BigInt {\n     #[inline(always)]\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n@@ -825,8 +826,8 @@ impl Signed for BigInt {\n     #[inline(always)]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n-            Plus | Zero => copy *self,\n-            Minus => BigInt::from_biguint(Plus, copy self.data)\n+            Plus | Zero => self.clone(),\n+            Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n \n@@ -850,8 +851,8 @@ impl Add<BigInt, BigInt> for BigInt {\n     #[inline(always)]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)      => copy *other,\n-            (_,    Zero)   => copy *self,\n+            (Zero, _)      => other.clone(),\n+            (_,    Zero)   => self.clone(),\n             (Plus, Plus)   => BigInt::from_biguint(Plus,\n                                                    self.data + other.data),\n             (Plus, Minus)  => self - (-*other),\n@@ -866,7 +867,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n-            (_,    Zero) => copy *self,\n+            (_,    Zero) => self.clone(),\n             (Plus, Plus) => match self.data.cmp(&other.data) {\n                 Less    => BigInt::from_biguint(Minus, other.data - self.data),\n                 Greater => BigInt::from_biguint(Plus, self.data - other.data),\n@@ -894,46 +895,61 @@ impl Mul<BigInt, BigInt> for BigInt {\n     }\n }\n \n-impl Quot<BigInt, BigInt> for BigInt {\n+impl Div<BigInt, BigInt> for BigInt {\n     #[inline(always)]\n-    fn quot(&self, other: &BigInt) -> BigInt {\n-        let (q, _) = self.quot_rem(other);\n+    fn div(&self, other: &BigInt) -> BigInt {\n+        let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n     #[inline(always)]\n     fn rem(&self, other: &BigInt) -> BigInt {\n-        let (_, r) = self.quot_rem(other);\n+        let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n     #[inline(always)]\n     fn neg(&self) -> BigInt {\n-        BigInt::from_biguint(self.sign.neg(), copy self.data)\n+        BigInt::from_biguint(self.sign.neg(), self.data.clone())\n     }\n }\n \n impl Integer for BigInt {\n     #[inline(always)]\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.div_mod(other);\n+    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // r.sign == self.sign\n+        let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n+        let d = BigInt::from_biguint(Plus, d_ui);\n+        let r = BigInt::from_biguint(Plus, r_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail!(),\n+            (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n+            (Plus, Minus) | (Zero, Minus) => (-d,  r),\n+            (Minus, Plus)                 => (-d, -r),\n+            (Minus, Minus)                => ( d, -r)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn div_floor(&self, other: &BigInt) -> BigInt {\n+        let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n     #[inline(always)]\n-    fn modulo(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.div_mod(other);\n+    fn mod_floor(&self, other: &BigInt) -> BigInt {\n+        let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n     #[inline(always)]\n-    fn div_mod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n+        let (d_ui, m_ui) = self.data.div_rem(&other.data);\n         let d = BigInt::from_biguint(Plus, d_ui),\n             m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n@@ -953,21 +969,6 @@ impl Integer for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n-    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // r.sign == self.sign\n-        let (q_ui, r_ui) = self.data.div_mod(&other.data);\n-        let q = BigInt::from_biguint(Plus, q_ui);\n-        let r = BigInt::from_biguint(Plus, r_ui);\n-        match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n-            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n-            (Minus, Plus)                 => (-q, -r),\n-            (Minus, Minus)                => ( q, -r)\n-        }\n-    }\n-\n     /**\n      * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n      *\n@@ -1100,11 +1101,9 @@ pub impl BigInt {\n \n #[cfg(test)]\n mod biguint_tests {\n-\n-    use core::*;\n+    use super::*;\n     use core::num::{IntConvertible, Zero, One, FromStrRadix};\n     use core::cmp::{Less, Equal, Greater};\n-    use super::{BigUint, BigDigit};\n \n     #[test]\n     fn test_from_slice() {\n@@ -1347,7 +1346,7 @@ mod biguint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static quot_rem_quadruples: &'static [(&'static [BigDigit],\n+    static div_rem_quadruples: &'static [(&'static [BigDigit],\n                                            &'static [BigDigit],\n                                            &'static [BigDigit],\n                                            &'static [BigDigit])]\n@@ -1371,7 +1370,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1384,29 +1383,29 @@ mod biguint_tests {\n     }\n \n     #[test]\n-    fn test_quot_rem() {\n+    fn test_div_rem() {\n         for mul_triples.each |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n             if !a.is_zero() {\n-                assert!(c.quot_rem(&a) == (copy b, Zero::zero()));\n+                assert!(c.div_rem(&a) == (b.clone(), Zero::zero()));\n             }\n             if !b.is_zero() {\n-                assert!(c.quot_rem(&b) == (copy a, Zero::zero()));\n+                assert!(c.div_rem(&b) == (a.clone(), Zero::zero()));\n             }\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if !b.is_zero() { assert!(a.quot_rem(&b) == (c, d)); }\n+            if !b.is_zero() { assert!(a.div_rem(&b) == (c, d)); }\n         }\n     }\n \n@@ -1557,8 +1556,7 @@ mod biguint_tests {\n \n #[cfg(test)]\n mod bigint_tests {\n-    use super::{BigInt, BigUint, BigDigit, Sign, Minus, Zero, Plus};\n-    use core::*;\n+    use super::*;\n     use core::cmp::{Less, Equal, Greater};\n     use core::num::{IntConvertible, Zero, One, FromStrRadix};\n \n@@ -1750,10 +1748,10 @@ mod bigint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static quot_rem_quadruples: &'static [(&'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit])]\n+    static div_rem_quadruples: &'static [(&'static [BigDigit],\n+                                          &'static [BigDigit],\n+                                          &'static [BigDigit],\n+                                          &'static [BigDigit])]\n         = &[\n             (&[ 1],        &[ 2], &[],               &[1]),\n             (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n@@ -1777,7 +1775,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1790,9 +1788,9 @@ mod bigint_tests {\n     }\n \n     #[test]\n-    fn test_div_mod() {\n+    fn test_div_mod_floor() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n-            let (d, m) = a.div_mod(b);\n+            let (d, m) = a.div_mod_floor(b);\n             if !m.is_zero() {\n                 assert!(m.sign == b.sign);\n             }\n@@ -1826,7 +1824,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1841,9 +1839,9 @@ mod bigint_tests {\n \n \n     #[test]\n-    fn test_quot_rem() {\n+    fn test_div_rem() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n-            let (q, r) = a.quot_rem(b);\n+            let (q, r) = a.div_rem(b);\n             if !r.is_zero() {\n                 assert!(r.sign == a.sign);\n             }\n@@ -1869,7 +1867,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1959,4 +1957,3 @@ mod bigint_tests {\n         assert!(-Zero::zero::<BigInt>() == Zero::zero::<BigInt>());\n     }\n }\n-"}, {"sha": "41d2b4a101cd5acb4c4f3087c71494c485a7120d", "filename": "src/libstd/num/complex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -102,9 +102,9 @@ impl<T: Copy + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Copy + Num> Quot<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n-    fn quot(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         let norm_sqr = other.norm_sqr();\n         Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n                      (self.im*other.re - self.re*other.im) / norm_sqr)\n@@ -275,7 +275,7 @@ mod test {\n             }\n         }\n         #[test]\n-        fn test_quot() {\n+        fn test_div() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n             for all_consts.each |&c| {\n                 if c != Zero::zero() {"}, {"sha": "9b92b7241b99007839e9049442eeb06a5383110c", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -143,9 +143,9 @@ impl<T: Copy + Num + Ord>\n \n // (a/b) / (c/d) = (a*d)/(b*c)\n impl<T: Copy + Num + Ord>\n-    Quot<Ratio<T>,Ratio<T>> for Ratio<T> {\n+    Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n-    fn quot(&self, rhs: &Ratio<T>) -> Ratio<T> {\n+    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n         Ratio::new(self.numer * rhs.denom, self.denom * rhs.numer)\n     }\n }\n@@ -395,7 +395,7 @@ mod test {\n         }\n \n         #[test]\n-        fn test_quot() {\n+        fn test_div() {\n             assert_eq!(_1 / _1_2, _2);\n             assert_eq!(_3_2 / _1_2, _1 + _2);\n             assert_eq!(_1 / _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n@@ -424,7 +424,7 @@ mod test {\n         }\n         #[test]\n         #[should_fail]\n-        fn test_quot_0() {\n+        fn test_div_0() {\n             let _a =  _1 / _0;\n         }\n     }"}, {"sha": "a5d2604b6f6db5b6c5f3126e2af263fda3bd019b", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 330, "deletions": 251, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -24,377 +24,457 @@ use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n     // Primitive types:\n-    fn emit_nil(&self);\n-    fn emit_uint(&self, v: uint);\n-    fn emit_u64(&self, v: u64);\n-    fn emit_u32(&self, v: u32);\n-    fn emit_u16(&self, v: u16);\n-    fn emit_u8(&self, v: u8);\n-    fn emit_int(&self, v: int);\n-    fn emit_i64(&self, v: i64);\n-    fn emit_i32(&self, v: i32);\n-    fn emit_i16(&self, v: i16);\n-    fn emit_i8(&self, v: i8);\n-    fn emit_bool(&self, v: bool);\n-    fn emit_float(&self, v: float);\n-    fn emit_f64(&self, v: f64);\n-    fn emit_f32(&self, v: f32);\n-    fn emit_char(&self, v: char);\n-    fn emit_str(&self, v: &str);\n+    fn emit_nil(&mut self);\n+    fn emit_uint(&mut self, v: uint);\n+    fn emit_u64(&mut self, v: u64);\n+    fn emit_u32(&mut self, v: u32);\n+    fn emit_u16(&mut self, v: u16);\n+    fn emit_u8(&mut self, v: u8);\n+    fn emit_int(&mut self, v: int);\n+    fn emit_i64(&mut self, v: i64);\n+    fn emit_i32(&mut self, v: i32);\n+    fn emit_i16(&mut self, v: i16);\n+    fn emit_i8(&mut self, v: i8);\n+    fn emit_bool(&mut self, v: bool);\n+    fn emit_float(&mut self, v: float);\n+    fn emit_f64(&mut self, v: f64);\n+    fn emit_f32(&mut self, v: f32);\n+    fn emit_char(&mut self, v: char);\n+    fn emit_str(&mut self, v: &str);\n \n     // Compound types:\n-    fn emit_enum(&self, name: &str, f: &fn());\n-\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, len: uint, f: &fn());\n-    fn emit_enum_variant_arg(&self, a_idx: uint, f: &fn());\n-\n-    fn emit_enum_struct_variant(&self, v_name: &str, v_id: uint, len: uint, f: &fn());\n-    fn emit_enum_struct_variant_field(&self, f_name: &str, f_idx: uint, f: &fn());\n-\n-    fn emit_struct(&self, name: &str, len: uint, f: &fn());\n-    fn emit_struct_field(&self, f_name: &str, f_idx: uint, f: &fn());\n-\n-    fn emit_tuple(&self, len: uint, f: &fn());\n-    fn emit_tuple_arg(&self, idx: uint, f: &fn());\n-\n-    fn emit_tuple_struct(&self, name: &str, len: uint, f: &fn());\n-    fn emit_tuple_struct_arg(&self, f_idx: uint, f: &fn());\n+    fn emit_enum(&mut self, name: &str, f: &fn(&mut Self));\n+\n+    fn emit_enum_variant(&mut self,\n+                         v_name: &str,\n+                         v_id: uint,\n+                         len: uint,\n+                         f: &fn(&mut Self));\n+    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: &fn(&mut Self));\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                v_name: &str,\n+                                v_id: uint,\n+                                len: uint,\n+                                f: &fn(&mut Self));\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      f_name: &str,\n+                                      f_idx: uint,\n+                                      f: &fn(&mut Self));\n+\n+    fn emit_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n+    fn emit_struct_field(&mut self,\n+                         f_name: &str,\n+                         f_idx: uint,\n+                         f: &fn(&mut Self));\n+\n+    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Self));\n+    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Self));\n+\n+    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n+    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: &fn(&mut Self));\n \n     // Specialized types:\n-    fn emit_option(&self, f: &fn());\n-    fn emit_option_none(&self);\n-    fn emit_option_some(&self, f: &fn());\n+    fn emit_option(&mut self, f: &fn(&mut Self));\n+    fn emit_option_none(&mut self);\n+    fn emit_option_some(&mut self, f: &fn(&mut Self));\n \n-    fn emit_seq(&self, len: uint, f: &fn());\n-    fn emit_seq_elt(&self, idx: uint, f: &fn());\n+    fn emit_seq(&mut self, len: uint, f: &fn(this: &mut Self));\n+    fn emit_seq_elt(&mut self, idx: uint, f: &fn(this: &mut Self));\n \n-    fn emit_map(&self, len: uint, f: &fn());\n-    fn emit_map_elt_key(&self, idx: uint, f: &fn());\n-    fn emit_map_elt_val(&self, idx: uint, f: &fn());\n+    fn emit_map(&mut self, len: uint, f: &fn(&mut Self));\n+    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Self));\n+    fn emit_map_elt_val(&mut self, idx: uint, f: &fn(&mut Self));\n }\n \n pub trait Decoder {\n     // Primitive types:\n-    fn read_nil(&self) -> ();\n-    fn read_uint(&self) -> uint;\n-    fn read_u64(&self) -> u64;\n-    fn read_u32(&self) -> u32;\n-    fn read_u16(&self) -> u16;\n-    fn read_u8(&self) -> u8;\n-    fn read_int(&self) -> int;\n-    fn read_i64(&self) -> i64;\n-    fn read_i32(&self) -> i32;\n-    fn read_i16(&self) -> i16;\n-    fn read_i8(&self) -> i8;\n-    fn read_bool(&self) -> bool;\n-    fn read_f64(&self) -> f64;\n-    fn read_f32(&self) -> f32;\n-    fn read_float(&self) -> float;\n-    fn read_char(&self) -> char;\n-    fn read_str(&self) -> ~str;\n+    fn read_nil(&mut self) -> ();\n+    fn read_uint(&mut self) -> uint;\n+    fn read_u64(&mut self) -> u64;\n+    fn read_u32(&mut self) -> u32;\n+    fn read_u16(&mut self) -> u16;\n+    fn read_u8(&mut self) -> u8;\n+    fn read_int(&mut self) -> int;\n+    fn read_i64(&mut self) -> i64;\n+    fn read_i32(&mut self) -> i32;\n+    fn read_i16(&mut self) -> i16;\n+    fn read_i8(&mut self) -> i8;\n+    fn read_bool(&mut self) -> bool;\n+    fn read_f64(&mut self) -> f64;\n+    fn read_f32(&mut self) -> f32;\n+    fn read_float(&mut self) -> float;\n+    fn read_char(&mut self) -> char;\n+    fn read_str(&mut self) -> ~str;\n \n     // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n-\n-    fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_enum_struct_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n-    fn read_enum_struct_variant_field<T>(&self, &f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_struct<T>(&self, s_name: &str, len: uint, f: &fn() -> T) -> T;\n-    fn read_struct_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_tuple_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n-\n-    fn read_tuple_struct<T>(&self, s_name: &str, f: &fn(uint) -> T) -> T;\n-    fn read_tuple_struct_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n+    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Self) -> T) -> T;\n+\n+    fn read_enum_variant<T>(&mut self,\n+                            names: &[&str],\n+                            f: &fn(&mut Self, uint) -> T)\n+                            -> T;\n+    fn read_enum_variant_arg<T>(&mut self,\n+                                a_idx: uint,\n+                                f: &fn(&mut Self) -> T)\n+                                -> T;\n+\n+    fn read_enum_struct_variant<T>(&mut self,\n+                                   names: &[&str],\n+                                   f: &fn(&mut Self, uint) -> T)\n+                                   -> T;\n+    fn read_enum_struct_variant_field<T>(&mut self,\n+                                         &f_name: &str,\n+                                         f_idx: uint,\n+                                         f: &fn(&mut Self) -> T)\n+                                         -> T;\n+\n+    fn read_struct<T>(&mut self,\n+                      s_name: &str,\n+                      len: uint,\n+                      f: &fn(&mut Self) -> T)\n+                      -> T;\n+    fn read_struct_field<T>(&mut self,\n+                            f_name: &str,\n+                            f_idx: uint,\n+                            f: &fn(&mut Self) -> T)\n+                            -> T;\n+\n+    fn read_tuple<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n+    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: &fn(&mut Self) -> T) -> T;\n+\n+    fn read_tuple_struct<T>(&mut self,\n+                            s_name: &str,\n+                            f: &fn(&mut Self, uint) -> T)\n+                            -> T;\n+    fn read_tuple_struct_arg<T>(&mut self,\n+                                a_idx: uint,\n+                                f: &fn(&mut Self) -> T)\n+                                -> T;\n \n     // Specialized types:\n-    fn read_option<T>(&self, f: &fn(bool) -> T) -> T;\n+    fn read_option<T>(&mut self, f: &fn(&mut Self, bool) -> T) -> T;\n \n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+    fn read_seq<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n \n-    fn read_map<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+    fn read_map<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n-    fn encode(&self, s: &S);\n+    fn encode(&self, s: &mut S);\n }\n \n pub trait Decodable<D:Decoder> {\n-    fn decode(d: &D) -> Self;\n+    fn decode(d: &mut D) -> Self;\n }\n \n impl<S:Encoder> Encodable<S> for uint {\n-    fn encode(&self, s: &S) { s.emit_uint(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_uint(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for uint {\n-    fn decode(d: &D) -> uint {\n+    fn decode(d: &mut D) -> uint {\n         d.read_uint()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for u8 {\n-    fn encode(&self, s: &S) { s.emit_u8(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u8(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for u8 {\n-    fn decode(d: &D) -> u8 {\n+    fn decode(d: &mut D) -> u8 {\n         d.read_u8()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for u16 {\n-    fn encode(&self, s: &S) { s.emit_u16(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u16(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for u16 {\n-    fn decode(d: &D) -> u16 {\n+    fn decode(d: &mut D) -> u16 {\n         d.read_u16()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for u32 {\n-    fn encode(&self, s: &S) { s.emit_u32(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u32(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for u32 {\n-    fn decode(d: &D) -> u32 {\n+    fn decode(d: &mut D) -> u32 {\n         d.read_u32()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for u64 {\n-    fn encode(&self, s: &S) { s.emit_u64(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u64(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for u64 {\n-    fn decode(d: &D) -> u64 {\n+    fn decode(d: &mut D) -> u64 {\n         d.read_u64()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for int {\n-    fn encode(&self, s: &S) { s.emit_int(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_int(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for int {\n-    fn decode(d: &D) -> int {\n+    fn decode(d: &mut D) -> int {\n         d.read_int()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for i8 {\n-    fn encode(&self, s: &S) { s.emit_i8(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i8(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for i8 {\n-    fn decode(d: &D) -> i8 {\n+    fn decode(d: &mut D) -> i8 {\n         d.read_i8()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for i16 {\n-    fn encode(&self, s: &S) { s.emit_i16(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i16(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for i16 {\n-    fn decode(d: &D) -> i16 {\n+    fn decode(d: &mut D) -> i16 {\n         d.read_i16()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for i32 {\n-    fn encode(&self, s: &S) { s.emit_i32(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i32(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for i32 {\n-    fn decode(d: &D) -> i32 {\n+    fn decode(d: &mut D) -> i32 {\n         d.read_i32()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for i64 {\n-    fn encode(&self, s: &S) { s.emit_i64(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i64(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for i64 {\n-    fn decode(d: &D) -> i64 {\n+    fn decode(d: &mut D) -> i64 {\n         d.read_i64()\n     }\n }\n \n impl<'self, S:Encoder> Encodable<S> for &'self str {\n-    fn encode(&self, s: &S) { s.emit_str(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n }\n \n impl<S:Encoder> Encodable<S> for ~str {\n-    fn encode(&self, s: &S) { s.emit_str(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for ~str {\n-    fn decode(d: &D) -> ~str {\n+    fn decode(d: &mut D) -> ~str {\n         d.read_str()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for @str {\n-    fn encode(&self, s: &S) { s.emit_str(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for @str {\n-    fn decode(d: &D) -> @str { d.read_str().to_managed() }\n+    fn decode(d: &mut D) -> @str {\n+        d.read_str().to_managed()\n+    }\n }\n \n impl<S:Encoder> Encodable<S> for float {\n-    fn encode(&self, s: &S) { s.emit_float(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_float(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for float {\n-    fn decode(d: &D) -> float {\n+    fn decode(d: &mut D) -> float {\n         d.read_float()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for f32 {\n-    fn encode(&self, s: &S) { s.emit_f32(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_f32(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for f32 {\n-    fn decode(d: &D) -> f32 {\n-        d.read_f32() }\n+    fn decode(d: &mut D) -> f32 {\n+        d.read_f32()\n+    }\n }\n \n impl<S:Encoder> Encodable<S> for f64 {\n-    fn encode(&self, s: &S) { s.emit_f64(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_f64(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for f64 {\n-    fn decode(d: &D) -> f64 {\n+    fn decode(d: &mut D) -> f64 {\n         d.read_f64()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for bool {\n-    fn encode(&self, s: &S) { s.emit_bool(*self) }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_bool(*self)\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for bool {\n-    fn decode(d: &D) -> bool {\n+    fn decode(d: &mut D) -> bool {\n         d.read_bool()\n     }\n }\n \n impl<S:Encoder> Encodable<S> for () {\n-    fn encode(&self, s: &S) { s.emit_nil() }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_nil()\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for () {\n-    fn decode(d: &D) -> () {\n+    fn decode(d: &mut D) -> () {\n         d.read_nil()\n     }\n }\n \n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n-    fn decode(d: &D) -> ~T {\n+    fn decode(d: &mut D) -> ~T {\n         ~Decodable::decode(d)\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n-    fn decode(d: &D) -> @T {\n+    fn decode(d: &mut D) -> @T {\n         @Decodable::decode(d)\n     }\n }\n \n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s))\n+                s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s))\n+                s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n-    fn decode(d: &D) -> ~[T] {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> ~[T] {\n+        do d.read_seq |d, len| {\n             do vec::from_fn(len) |i| {\n-                d.read_seq_elt(i, || Decodable::decode(d))\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n             }\n         }\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s))\n+                s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n-    fn decode(d: &D) -> @[T] {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> @[T] {\n+        do d.read_seq |d, len| {\n             do at_vec::from_fn(len) |i| {\n-                d.read_seq_elt(i, || Decodable::decode(d))\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n             }\n         }\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_option {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_option |s| {\n             match *self {\n                 None => s.emit_option_none(),\n-                Some(ref v) => s.emit_option_some(|| v.encode(s)),\n+                Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n-    fn decode(d: &D) -> Option<T> {\n-        do d.read_option |b| {\n+    fn decode(d: &mut D) -> Option<T> {\n+        do d.read_option |d, b| {\n             if b {\n                 Some(Decodable::decode(d))\n             } else {\n@@ -405,25 +485,25 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n }\n \n impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1) => {\n-                do s.emit_seq(2) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n+                do s.emit_seq(2) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n                 }\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n-    fn decode(d: &D) -> (T0, T1) {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> (T0, T1) {\n+        do d.read_seq |d, len| {\n             assert!(len == 2);\n             (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d))\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d))\n             )\n         }\n     }\n@@ -435,13 +515,13 @@ impl<\n     T1: Encodable<S>,\n     T2: Encodable<S>\n > Encodable<S> for (T0, T1, T2) {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2) => {\n-                do s.emit_seq(3) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                    s.emit_seq_elt(2, || t2.encode(s));\n+                do s.emit_seq(3) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n                 }\n             }\n         }\n@@ -454,13 +534,13 @@ impl<\n     T1: Decodable<D>,\n     T2: Decodable<D>\n > Decodable<D> for (T0, T1, T2) {\n-    fn decode(d: &D) -> (T0, T1, T2) {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> (T0, T1, T2) {\n+        do d.read_seq |d, len| {\n             assert!(len == 3);\n             (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d)),\n-                d.read_seq_elt(2, || Decodable::decode(d))\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d))\n             )\n         }\n     }\n@@ -473,14 +553,14 @@ impl<\n     T2: Encodable<S>,\n     T3: Encodable<S>\n > Encodable<S> for (T0, T1, T2, T3) {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_seq(4) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                    s.emit_seq_elt(2, || t2.encode(s));\n-                    s.emit_seq_elt(3, || t3.encode(s));\n+                do s.emit_seq(4) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                    s.emit_seq_elt(3, |s| t3.encode(s));\n                 }\n             }\n         }\n@@ -494,14 +574,14 @@ impl<\n     T2: Decodable<D>,\n     T3: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3) {\n-    fn decode(d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n+        do d.read_seq |d, len| {\n             assert!(len == 4);\n             (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d)),\n-                d.read_seq_elt(2, || Decodable::decode(d)),\n-                d.read_seq_elt(3, || Decodable::decode(d))\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d)),\n+                d.read_seq_elt(3, |d| Decodable::decode(d))\n             )\n         }\n     }\n@@ -515,15 +595,15 @@ impl<\n     T3: Encodable<S>,\n     T4: Encodable<S>\n > Encodable<S> for (T0, T1, T2, T3, T4) {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_seq(5) {\n-                    s.emit_seq_elt(0, || t0.encode(s));\n-                    s.emit_seq_elt(1, || t1.encode(s));\n-                    s.emit_seq_elt(2, || t2.encode(s));\n-                    s.emit_seq_elt(3, || t3.encode(s));\n-                    s.emit_seq_elt(4, || t4.encode(s));\n+                do s.emit_seq(5) |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                    s.emit_seq_elt(3, |s| t3.encode(s));\n+                    s.emit_seq_elt(4, |s| t4.encode(s));\n                 }\n             }\n         }\n@@ -538,16 +618,15 @@ impl<\n     T3: Decodable<D>,\n     T4: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n-    fn decode(d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n+        do d.read_seq |d, len| {\n             assert!(len == 5);\n             (\n-                d.read_seq_elt(0, || Decodable::decode(d)),\n-                d.read_seq_elt(1, || Decodable::decode(d)),\n-                d.read_seq_elt(2, || Decodable::decode(d)),\n-                d.read_seq_elt(3, || Decodable::decode(d)),\n-                d.read_seq_elt(4, || Decodable::decode(d))\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d)),\n+                d.read_seq_elt(3, |d| Decodable::decode(d)),\n+                d.read_seq_elt(4, |d| Decodable::decode(d))\n             )\n         }\n     }\n@@ -557,23 +636,23 @@ impl<\n     S: Encoder,\n     T: Encodable<S> + Copy\n > Encodable<S> for @mut DList<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.size) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.size) |s| {\n             let mut i = 0;\n             for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n+                s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @mut DList<T> {\n-    fn decode(d: &D) -> @mut DList<T> {\n+    fn decode(d: &mut D) -> @mut DList<T> {\n         let list = DList();\n-        do d.read_seq |len| {\n+        do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n-                list.push(d.read_seq_elt(i, || Decodable::decode(d)));\n+                list.push(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n         list\n@@ -584,21 +663,21 @@ impl<\n     S: Encoder,\n     T: Encodable<S>\n > Encodable<S> for Deque<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             for self.eachi |i, e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n+                s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n-    fn decode(d: &D) -> Deque<T> {\n+    fn decode(d: &mut D) -> Deque<T> {\n         let mut deque = Deque::new();\n-        do d.read_seq |len| {\n+        do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n-                deque.add_back(d.read_seq_elt(i, || Decodable::decode(d)));\n+                deque.add_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n         deque\n@@ -610,12 +689,12 @@ impl<\n     K: Encodable<E> + Hash + IterBytes + Eq,\n     V: Encodable<E>\n > Encodable<E> for HashMap<K, V> {\n-    fn encode(&self, e: &E) {\n-        do e.emit_map(self.len()) {\n+    fn encode(&self, e: &mut E) {\n+        do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n             for self.each |key, val| {\n-                e.emit_map_elt_key(i, || key.encode(e));\n-                e.emit_map_elt_val(i, || val.encode(e));\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n         }\n@@ -627,12 +706,12 @@ impl<\n     K: Decodable<D> + Hash + IterBytes + Eq,\n     V: Decodable<D>\n > Decodable<D> for HashMap<K, V> {\n-    fn decode(d: &D) -> HashMap<K, V> {\n-        do d.read_map |len| {\n+    fn decode(d: &mut D) -> HashMap<K, V> {\n+        do d.read_map |d, len| {\n             let mut map = HashMap::with_capacity(len);\n             for uint::range(0, len) |i| {\n-                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n@@ -644,11 +723,11 @@ impl<\n     S: Encoder,\n     T: Encodable<S> + Hash + IterBytes + Eq\n > Encodable<S> for HashSet<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n             for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n+                s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n@@ -659,11 +738,11 @@ impl<\n     D: Decoder,\n     T: Decodable<D> + Hash + IterBytes + Eq\n > Decodable<D> for HashSet<T> {\n-    fn decode(d: &D) -> HashSet<T> {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> HashSet<T> {\n+        do d.read_seq |d, len| {\n             let mut set = HashSet::with_capacity(len);\n             for uint::range(0, len) |i| {\n-                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n         }\n@@ -674,12 +753,12 @@ impl<\n     E: Encoder,\n     V: Encodable<E>\n > Encodable<E> for TrieMap<V> {\n-    fn encode(&self, e: &E) {\n-        do e.emit_map(self.len()) {\n+    fn encode(&self, e: &mut E) {\n+        do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n             for self.each |key, val| {\n-                e.emit_map_elt_key(i, || key.encode(e));\n-                e.emit_map_elt_val(i, || val.encode(e));\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n         }\n@@ -690,12 +769,12 @@ impl<\n     D: Decoder,\n     V: Decodable<D>\n > Decodable<D> for TrieMap<V> {\n-    fn decode(d: &D) -> TrieMap<V> {\n-        do d.read_map |len| {\n+    fn decode(d: &mut D) -> TrieMap<V> {\n+        do d.read_map |d, len| {\n             let mut map = TrieMap::new();\n             for uint::range(0, len) |i| {\n-                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n@@ -704,23 +783,23 @@ impl<\n }\n \n impl<S: Encoder> Encodable<S> for TrieSet {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n             for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n+                s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n     }\n }\n \n impl<D: Decoder> Decodable<D> for TrieSet {\n-    fn decode(d: &D) -> TrieSet {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> TrieSet {\n+        do d.read_seq |d, len| {\n             let mut set = TrieSet::new();\n             for uint::range(0, len) |i| {\n-                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n         }\n@@ -732,12 +811,12 @@ impl<\n     K: Encodable<E> + Eq + TotalOrd,\n     V: Encodable<E> + Eq\n > Encodable<E> for TreeMap<K, V> {\n-    fn encode(&self, e: &E) {\n-        do e.emit_map(self.len()) {\n+    fn encode(&self, e: &mut E) {\n+        do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n             for self.each |key, val| {\n-                e.emit_map_elt_key(i, || key.encode(e));\n-                e.emit_map_elt_val(i, || val.encode(e));\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n         }\n@@ -749,12 +828,12 @@ impl<\n     K: Decodable<D> + Eq + TotalOrd,\n     V: Decodable<D> + Eq\n > Decodable<D> for TreeMap<K, V> {\n-    fn decode(d: &D) -> TreeMap<K, V> {\n-        do d.read_map |len| {\n+    fn decode(d: &mut D) -> TreeMap<K, V> {\n+        do d.read_map |d, len| {\n             let mut map = TreeMap::new();\n             for uint::range(0, len) |i| {\n-                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n@@ -766,11 +845,11 @@ impl<\n     S: Encoder,\n     T: Encodable<S> + Eq + TotalOrd\n > Encodable<S> for TreeSet<T> {\n-    fn encode(&self, s: &S) {\n-        do s.emit_seq(self.len()) {\n+    fn encode(&self, s: &mut S) {\n+        do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n             for self.each |e| {\n-                s.emit_seq_elt(i, || e.encode(s));\n+                s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n         }\n@@ -781,11 +860,11 @@ impl<\n     D: Decoder,\n     T: Decodable<D> + Eq + TotalOrd\n > Decodable<D> for TreeSet<T> {\n-    fn decode(d: &D) -> TreeSet<T> {\n-        do d.read_seq |len| {\n+    fn decode(d: &mut D) -> TreeSet<T> {\n+        do d.read_seq |d, len| {\n             let mut set = TreeSet::new();\n             for uint::range(0, len) |i| {\n-                set.insert(d.read_seq_elt(i, || Decodable::decode(d)));\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n         }\n@@ -798,30 +877,30 @@ impl<\n // In some cases, these should eventually be coded as traits.\n \n pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T));\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut Self, v: &T));\n }\n \n impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T)) {\n-        do self.emit_seq(v.len()) {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n+        do self.emit_seq(v.len()) |this| {\n             for v.eachi |i, e| {\n-                do self.emit_seq_elt(i) {\n-                    f(e)\n+                do this.emit_seq_elt(i) |this| {\n+                    f(this, e)\n                 }\n             }\n         }\n     }\n }\n \n pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T];\n+    fn read_to_vec<T>(&mut self, f: &fn(&mut Self) -> T) -> ~[T];\n }\n \n impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T] {\n-        do self.read_seq |len| {\n+    fn read_to_vec<T>(&mut self, f: &fn(&mut D) -> T) -> ~[T] {\n+        do self.read_seq |this, len| {\n             do vec::from_fn(len) |i| {\n-                self.read_seq_elt(i, || f())\n+                this.read_seq_elt(i, |this| f(this))\n             }\n         }\n     }"}, {"sha": "a8e0f7d062a58af24f2be8e4c3ebc817798901f9", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -412,11 +412,3 @@ mod tests {\n         }\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "a18e2f47a7721b81b7db3ae0f362ee6e2b0b47f2", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1236,11 +1236,3 @@ mod big_tests {\n         }\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "a326af804bd1e1c6b6046c359f1a8364943d5237", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -124,11 +124,3 @@ pub mod std {\n     pub use serialize;\n     pub use test;\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "661247df1c1442fd5054bfd0c77739b52d627a67", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -100,4 +100,3 @@ fn test_task_pool() {\n         pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n     }\n }\n-"}, {"sha": "10645e947e2d9436927d40b7bb97db772e590954", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -27,6 +27,7 @@ pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n mod tests {\n     use tempfile::mkdtemp;\n     use tempfile;\n+    use core::os;\n \n     #[test]\n     fn test_mkdtemp() {\n@@ -42,13 +43,18 @@ mod tests {\n         use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n         use core::os;\n \n-        let root = mkdtemp(&os::tmpdir(), \"temp\").expect(\"recursive_mkdir_rel\");\n-        os::change_dir(&root);\n-        let path = Path(\"frob\");\n-        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path));\n-        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path));\n+        let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel\").\n+            expect(\"recursive_mkdir_rel\");\n+        assert!(do os::change_dir_locked(&root) {\n+            let path = Path(\"frob\");\n+            debug!(\"recursive_mkdir_rel: Making: %s in cwd %s [%?]\", path.to_str(),\n+                   os::getcwd().to_str(),\n+                   os::path_exists(&path));\n+            assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+            assert!(os::path_is_dir(&path));\n+            assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+            assert!(os::path_is_dir(&path));\n+        });\n     }\n \n     #[test]\n@@ -67,18 +73,44 @@ mod tests {\n         use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n         use core::os;\n \n-        let root = mkdtemp(&os::tmpdir(), \"temp\").expect(\"recursive_mkdir_rel_2\");\n-        os::change_dir(&root);\n-        let path = Path(\"./frob/baz\");\n-        debug!(\"...Making: %s in cwd %s\", path.to_str(), os::getcwd().to_str());\n-        assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path));\n-        assert!(os::path_is_dir(&path.pop()));\n-        let path2 = Path(\"quux/blat\");\n-        debug!(\"Making: %s in cwd %s\", path2.to_str(), os::getcwd().to_str());\n-        assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path2));\n-        assert!(os::path_is_dir(&path2.pop()));\n+        let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel_2\").\n+            expect(\"recursive_mkdir_rel_2\");\n+        assert!(do os::change_dir_locked(&root) {\n+            let path = Path(\"./frob/baz\");\n+            debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s [%?]\", path.to_str(),\n+                   os::getcwd().to_str(), os::path_exists(&path));\n+            assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+                assert!(os::path_is_dir(&path));\n+            assert!(os::path_is_dir(&path.pop()));\n+            let path2 = Path(\"quux/blat\");\n+            debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s\", path2.to_str(),\n+                   os::getcwd().to_str());\n+            assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+                assert!(os::path_is_dir(&path2));\n+            assert!(os::path_is_dir(&path2.pop()));\n+        });\n     }\n \n-}\n\\ No newline at end of file\n+    // Ideally this would be in core, but needs mkdtemp\n+    #[test]\n+    pub fn test_rmdir_recursive_ok() {\n+        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use core::os;\n+\n+        let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n+\n+        let tmpdir = mkdtemp(&os::tmpdir(), \"test\").expect(\"test_rmdir_recursive_ok: \\\n+                                            couldn't create temp dir\");\n+        let root = tmpdir.push(\"foo\");\n+\n+        debug!(\"making %s\", root.to_str());\n+        assert!(os::make_dir(&root, rwx));\n+        assert!(os::make_dir(&root.push(\"foo\"), rwx));\n+        assert!(os::make_dir(&root.push(\"foo\").push(\"bar\"), rwx));\n+        assert!(os::make_dir(&root.push(\"foo\").push(\"bar\").push(\"blat\"), rwx));\n+        assert!(os::remove_dir_recursive(&root));\n+        assert!(!os::path_exists(&root));\n+        assert!(!os::path_exists(&root.push(\"bar\")));\n+        assert!(!os::path_exists(&root.push(\"bar\").push(\"blat\")));\n+    }\n+}"}, {"sha": "a79b9f4c84980bce53c67b5999336996a797544d", "filename": "src/libstd/term.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -76,10 +76,3 @@ pub fn fg(writer: @io::Writer, color: u8) {\n pub fn bg(writer: @io::Writer, color: u8) {\n     return set_color(writer, '4' as u8, color);\n }\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "65fb0c7426a4effc7895459dcc7c22c259306d5d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -960,12 +960,3 @@ mod tests {\n         }\n     }\n }\n-\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "e681382ffc8289b213a4f89df0189c46a55ba409", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(deprecated_mode)];\n-\n use json;\n use sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n@@ -141,7 +139,7 @@ impl WorkMap {\n }\n \n impl<S:Encoder> Encodable<S> for WorkMap {\n-    fn encode(&self, s: &S) {\n+    fn encode(&self, s: &mut S) {\n         let mut d = ~[];\n         for self.each |k, v| {\n             d.push((copy *k, copy *v))\n@@ -152,7 +150,7 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n }\n \n impl<D:Decoder> Decodable<D> for WorkMap {\n-    fn decode(d: &D) -> WorkMap {\n+    fn decode(d: &mut D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = WorkMap::new();\n         for v.each |&(k, v)| {\n@@ -171,8 +169,8 @@ struct Database {\n pub impl Database {\n     fn prepare(&mut self,\n                fn_name: &str,\n-               declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n-    {\n+               declared_inputs: &WorkMap)\n+               -> Option<(WorkMap, WorkMap, ~str)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n         match self.db_cache.find(&k) {\n             None => None,\n@@ -231,15 +229,17 @@ struct Work<T> {\n \n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n     do io::with_str_writer |wr| {\n-        t.encode(&json::Encoder(wr));\n+        let mut encoder = json::Encoder(wr);\n+        t.encode(&mut encoder);\n     }\n }\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n-        Decodable::decode(&json::Decoder(j))\n+        let mut decoder = json::Decoder(j);\n+        Decodable::decode(&mut decoder)\n     }\n }\n "}, {"sha": "2216226ecb3ab29d6243b4e347031994924524e6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -71,20 +71,21 @@ pub type Name = uint;\n pub type Mrk = uint;\n \n impl<S:Encoder> Encodable<S> for ident {\n-    fn encode(&self, s: &S) {\n-        let intr = match unsafe {\n-            task::local_data::local_data_get(interner_key!())\n-        } {\n-            None => fail!(~\"encode: TLS interner not set up\"),\n-            Some(intr) => intr\n-        };\n-\n-        s.emit_str(*(*intr).get(*self));\n+    fn encode(&self, s: &mut S) {\n+        unsafe {\n+            let intr =\n+                match task::local_data::local_data_get(interner_key!()) {\n+                    None => fail!(~\"encode: TLS interner not set up\"),\n+                    Some(intr) => intr\n+                };\n+\n+            s.emit_str(*(*intr).get(*self));\n+        }\n     }\n }\n \n impl<D:Decoder> Decodable<D> for ident {\n-    fn decode(d: &D) -> ident {\n+    fn decode(d: &mut D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n@@ -389,7 +390,7 @@ pub enum binop {\n     add,\n     subtract,\n     mul,\n-    quot,\n+    div,\n     rem,\n     and,\n     or,\n@@ -1158,6 +1159,7 @@ pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n     ty: @Ty,\n+    attrs: ~[attribute],\n }\n \n pub type struct_field = spanned<struct_field_>;\n@@ -1174,10 +1176,7 @@ pub enum struct_field_kind {\n #[auto_decode]\n #[deriving(Eq)]\n pub struct struct_def {\n-    fields: ~[@struct_field], /* fields */\n-    /* (not including ctor or dtor) */\n-    /* dtor is optional */\n-    dtor: Option<struct_dtor>,\n+    fields: ~[@struct_field], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n     ctor_id: Option<node_id>\n@@ -1230,18 +1229,6 @@ impl to_bytes::IterBytes for struct_mutability {\n     }\n }\n \n-pub type struct_dtor = spanned<struct_dtor_>;\n-\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub struct struct_dtor_ {\n-    id: node_id,\n-    attrs: ~[attribute],\n-    self_id: node_id,\n-    body: blk,\n-}\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n@@ -1272,7 +1259,6 @@ pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n-    ii_dtor(struct_dtor, ident, Generics, def_id /* parent id */)\n }\n \n /* hold off on tests ... they appear in a later merge.\n@@ -1361,12 +1347,3 @@ mod test {\n }\n \n */\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "77a02adbafba719794ef6a7331f93c609de16528", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -14,7 +14,6 @@ use ast;\n use ast_util::{inlined_item_utils, stmt_id};\n use ast_util;\n use codemap;\n-use codemap::spanned;\n use diagnostic::span_handler;\n use parse::token::ident_interner;\n use print::pprust;\n@@ -92,8 +91,6 @@ pub enum ast_node {\n     node_stmt(@stmt),\n     node_arg,\n     node_local(ident),\n-    // Destructor for a struct\n-    node_dtor(Generics, @struct_dtor, def_id, @path),\n     node_block(blk),\n     node_struct_ctor(@struct_def, @item, @path),\n     node_callee_scope(@expr)\n@@ -159,7 +156,7 @@ pub fn map_decoded_item(diag: @span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     match *ii {\n-      ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n+      ii_item(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i,\n                                               AbiSet::Intrinsic(),\n@@ -187,27 +184,6 @@ pub fn map_fn(\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id, node_arg);\n     }\n-    match *fk {\n-        visit::fk_dtor(generics, ref attrs, self_id, parent_id) => {\n-            let dt = @spanned {\n-                node: ast::struct_dtor_ {\n-                    id: id,\n-                    attrs: /* FIXME (#2543) */ vec::from_slice(*attrs),\n-                    self_id: self_id,\n-                    body: /* FIXME (#2543) */ copy *body,\n-                },\n-                span: sp,\n-            };\n-            cx.map.insert(\n-                id,\n-                node_dtor(\n-                    /* FIXME (#2543) */ copy *generics,\n-                    dt,\n-                    parent_id,\n-                    @/* FIXME (#2543) */ copy cx.path));\n-      }\n-      _ => ()\n-    }\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n@@ -410,9 +386,6 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(&node_local(ident)) => {\n         fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident))\n       }\n-      Some(&node_dtor(*)) => { // add more info here\n-        fmt!(\"node_dtor (id=%?)\", id)\n-      }\n       Some(&node_block(_)) => {\n         fmt!(\"block\")\n       }\n@@ -430,11 +403,3 @@ pub fn node_item_query<Result>(items: map, id: node_id,\n         _ => fail!(error_msg)\n     }\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "a6094903d7b79d1d4e307349f3feeb8174f8a118", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -11,7 +11,7 @@\n use ast::*;\n use ast;\n use ast_util;\n-use codemap::{span, dummy_sp, spanned};\n+use codemap::{span, spanned};\n use parse::token;\n use visit;\n use opt_vec;\n@@ -41,12 +41,12 @@ pub fn stmt_id(s: &stmt) -> node_id {\n     }\n }\n \n-pub fn variant_def_ids(d: def) -> (def_id, def_id) {\n+pub fn variant_def_ids(d: def) -> Option<(def_id, def_id)> {\n     match d {\n       def_variant(enum_id, var_id) => {\n-        return (enum_id, var_id);\n+          Some((enum_id, var_id))\n       }\n-      _ => fail!(~\"non-variant in variant_def_ids\")\n+      _ => None\n     }\n }\n \n@@ -73,7 +73,7 @@ pub fn binop_to_str(op: binop) -> ~str {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n       mul => return ~\"*\",\n-      quot => return ~\"/\",\n+      div => return ~\"/\",\n       rem => return ~\"%\",\n       and => return ~\"&&\",\n       or => return ~\"||\",\n@@ -96,7 +96,7 @@ pub fn binop_to_method_name(op: binop) -> Option<~str> {\n       add => return Some(~\"add\"),\n       subtract => return Some(~\"sub\"),\n       mul => return Some(~\"mul\"),\n-      quot => return Some(~\"quot\"),\n+      div => return Some(~\"div\"),\n       rem => return Some(~\"rem\"),\n       bitxor => return Some(~\"bitxor\"),\n       bitand => return Some(~\"bitand\"),\n@@ -302,7 +302,6 @@ impl inlined_item_utils for inlined_item {\n             ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n             ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n             ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n-            ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n         }\n     }\n \n@@ -311,7 +310,6 @@ impl inlined_item_utils for inlined_item {\n             ii_item(i) => i.id,\n             ii_foreign(i) => i.id,\n             ii_method(_, m) => m.id,\n-            ii_dtor(ref dtor, _, _, _) => (*dtor).node.id\n         }\n     }\n \n@@ -320,10 +318,6 @@ impl inlined_item_utils for inlined_item {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n             ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-            ii_dtor(/*bad*/ copy dtor, _, ref generics, parent_id) => {\n-                visit::visit_struct_dtor_helper(dtor, generics,\n-                                                parent_id, e, v);\n-            }\n         }\n     }\n }\n@@ -341,7 +335,7 @@ pub fn is_self(d: ast::def) -> bool {\n /// Maps a binary operator to its precedence\n pub fn operator_prec(op: ast::binop) -> uint {\n   match op {\n-      mul | quot | rem   => 12u,\n+      mul | div | rem   => 12u,\n       // 'as' sits between here with 11\n       add | subtract    => 10u,\n       shl | shr         =>  9u,\n@@ -359,20 +353,6 @@ pub fn operator_prec(op: ast::binop) -> uint {\n /// not appearing in the prior table.\n pub static as_prec: uint = 11u;\n \n-pub fn dtor_ty() -> @ast::Ty {\n-    @ast::Ty {id: 0, node: ty_nil, span: dummy_sp()}\n-}\n-\n-pub fn dtor_dec() -> fn_decl {\n-    let nil_t = dtor_ty();\n-    // dtor has no args\n-    ast::fn_decl {\n-        inputs: ~[],\n-        output: nil_t,\n-        cf: return_val,\n-    }\n-}\n-\n pub fn empty_generics() -> Generics {\n     Generics {lifetimes: opt_vec::Empty,\n               ty_params: opt_vec::Empty}\n@@ -469,12 +449,6 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n             vfn(id);\n \n             match *fk {\n-                visit::fk_dtor(generics, _, self_id, parent_id) => {\n-                    visit_generics(generics);\n-                    vfn(id);\n-                    vfn(self_id);\n-                    vfn(parent_id.node);\n-                }\n                 visit::fk_item_fn(_, generics, _, _) => {\n                     visit_generics(generics);\n                 }\n@@ -868,11 +842,3 @@ mod test {\n     }\n \n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "f4f0def284327a3f4a66d09758f15ea68f8fa364", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -341,13 +341,3 @@ pub fn require_unique_names(diagnostic: @span_handler,\n         }\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "846097550d14f5b91badc4396c72827b8f2aff42", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -127,11 +127,13 @@ impl cmp::Eq for span {\n \n impl<S:Encoder> Encodable<S> for span {\n     /* Note #1972 -- spans are encoded but not decoded */\n-    fn encode(&self, _s: &S) { _s.emit_nil() }\n+    fn encode(&self, s: &mut S) {\n+        s.emit_nil()\n+    }\n }\n \n impl<D:Decoder> Decodable<D> for span {\n-    fn decode(_d: &D) -> span {\n+    fn decode(_d: &mut D) -> span {\n         dummy_sp()\n     }\n }\n@@ -522,15 +524,3 @@ mod test {\n         fm.next_line(BytePos(2));\n     }\n }\n-\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "53f40113532b22f4460fb48f85a0601ba3db644f", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -187,15 +187,3 @@ pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n         span: sp\n     })\n }\n-\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "bdf0a2a1dd07c10b71cba074a98b908003a9bf67", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 200, "deletions": 104, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -238,7 +238,8 @@ trait ExtCtxtMethods {\n     fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n     fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n     fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n-    fn lambda(&self, blk: ast::blk) -> @ast::expr;\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n     fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n     fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n     fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n@@ -254,8 +255,15 @@ trait ExtCtxtMethods {\n                         ident: ast::ident,\n                         args: ~[@ast::expr])\n                         -> @ast::expr;\n-    fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n+                    -> @ast::expr;\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_1(&self,\n+                      span: span,\n+                      stmts: ~[@ast::stmt],\n+                      ident: ast::ident)\n+                      -> @ast::expr;\n }\n \n impl ExtCtxtMethods for @ext_ctxt {\n@@ -388,12 +396,18 @@ impl ExtCtxtMethods for @ext_ctxt {\n                                 span: span}))\n     }\n \n-    fn lambda(&self, blk: ast::blk) -> @ast::expr {\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n         quote_expr!( || $blk_e )\n     }\n \n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n+        let ext_cx = *self;\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        quote_expr!( |$ident| $blk_e )\n+    }\n+\n     fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n         codemap::spanned {\n             node: ast::blk_ {\n@@ -461,15 +475,29 @@ impl ExtCtxtMethods for @ext_ctxt {\n         ident: ast::ident,\n         args: ~[@ast::expr]\n     ) -> @ast::expr {\n-        self.expr(span, ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+        self.expr(span,\n+                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+    }\n+\n+    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n+        self.lambda0(self.expr_blk(expr))\n+    }\n+\n+    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n+                    -> @ast::expr {\n+        self.lambda1(self.expr_blk(expr), ident)\n     }\n \n-    fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr {\n-        self.lambda(self.expr_blk(expr))\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda0(self.blk(span, stmts))\n     }\n \n-    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda(self.blk(span, stmts))\n+    fn lambda_stmts_1(&self,\n+                      span: span,\n+                      stmts: ~[@ast::stmt],\n+                      ident: ast::ident)\n+                      -> @ast::expr {\n+        self.lambda1(self.blk(span, stmts), ident)\n     }\n }\n \n@@ -644,7 +672,7 @@ fn mk_ser_method(\n             None,\n             ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n-                mutbl: ast::m_imm\n+                mutbl: ast::m_mutbl\n             }\n         ),\n         span: span,\n@@ -706,7 +734,7 @@ fn mk_deser_method(\n             None,\n             ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n-                mutbl: ast::m_imm\n+                mutbl: ast::m_mutbl\n             }\n         ),\n         span: span,\n@@ -758,8 +786,8 @@ fn mk_struct_ser_impl(\n     generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n-        // ast for `|| self.$(name).encode(__s)`\n-        let expr_lambda = cx.lambda_expr(\n+        // ast for `|__s| self.$(name).encode(__s)`\n+        let expr_lambda = cx.lambda_expr_1(\n             cx.expr_method_call(\n                 span,\n                 cx.expr_field(\n@@ -769,7 +797,8 @@ fn mk_struct_ser_impl(\n                 ),\n                 cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n-            )\n+            ),\n+            cx.ident_of(~\"__s\")\n         );\n \n         // ast for `__s.emit_struct_field($(name), $(idx), $(expr_lambda))`\n@@ -787,15 +816,15 @@ fn mk_struct_ser_impl(\n         )\n     };\n \n-    // ast for `__s.emit_struct($(name), || $(fields))`\n+    // ast for `__s.emit_struct($(name), |__s| $(fields))`\n     let ser_body = cx.expr_method_call(\n         span,\n         cx.expr_var(span, ~\"__s\"),\n         cx.ident_of(~\"emit_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n-            cx.lambda_stmts(span, fields),\n+            cx.lambda_stmts_1(span, fields, cx.ident_of(~\"__s\")),\n         ]\n     );\n \n@@ -810,8 +839,8 @@ fn mk_struct_deser_impl(\n     generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n-        // ast for `|| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda(\n+        // ast for `|__d| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda1(\n             cx.expr_blk(\n                 cx.expr_call(\n                     span,\n@@ -823,7 +852,8 @@ fn mk_struct_deser_impl(\n                     ]),\n                     ~[cx.expr_var(span, ~\"__d\")]\n                 )\n-            )\n+            ),\n+            cx.ident_of(~\"__d\")\n         );\n \n         // ast for `__d.read_struct_field($(name), $(idx), $(expr_lambda))`\n@@ -848,23 +878,24 @@ fn mk_struct_deser_impl(\n         }\n     };\n \n-    // ast for `read_struct($(name), || $(fields))`\n+    // ast for `read_struct($(name), |__d| $(fields))`\n     let body = cx.expr_method_call(\n         span,\n         cx.expr_var(span, ~\"__d\"),\n         cx.ident_of(~\"read_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n-            cx.lambda_expr(\n+            cx.lambda_expr_1(\n                 cx.expr(\n                     span,\n                     ast::expr_struct(\n                         cx.path(span, ~[ident]),\n                         fields,\n                         None\n                     )\n-                )\n+                ),\n+                cx.ident_of(~\"__d\")\n             ),\n         ]\n     );\n@@ -974,14 +1005,15 @@ fn ser_variant(\n             cx.ident_of(~\"emit_enum_variant_arg\")\n         );\n \n-        // ast for `|| $(v).encode(__s)`\n-        let expr_encode = cx.lambda_expr(\n-             cx.expr_method_call(\n+        // ast for `|__s| $(v).encode(__s)`\n+        let expr_encode = cx.lambda_expr_1(\n+            cx.expr_method_call(\n                 span,\n                  cx.expr_path(span, ~[names[a_idx]]),\n                  cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, ~\"__s\")]\n-            )\n+            ),\n+            cx.ident_of(~\"__s\")\n         );\n \n         // ast for `$(expr_emit)($(a_idx), $(expr_encode))`\n@@ -1003,7 +1035,7 @@ fn ser_variant(\n             cx.lit_str(span, @cx.str_of(v_name)),\n             cx.lit_uint(span, v_idx),\n             cx.lit_uint(span, stmts.len()),\n-            cx.lambda_stmts(span, stmts),\n+            cx.lambda_stmts_1(span, stmts, cx.ident_of(~\"__s\")),\n         ]\n     );\n \n@@ -1050,7 +1082,7 @@ fn mk_enum_ser_body(\n         cx.ident_of(~\"emit_enum\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(name)),\n-            cx.lambda_expr(match_expr),\n+            cx.lambda_expr_1(match_expr, cx.ident_of(~\"__s\")),\n         ]\n     )\n }\n@@ -1062,8 +1094,8 @@ fn mk_enum_deser_variant_nary(\n     args: ~[ast::variant_arg]\n ) -> @ast::expr {\n     let args = do args.mapi |idx, _arg| {\n-        // ast for `|| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda_expr(\n+        // ast for `|__s| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda_expr_1(\n             cx.expr_call(\n                 span,\n                 cx.expr_path_global(span, ~[\n@@ -1073,7 +1105,8 @@ fn mk_enum_deser_variant_nary(\n                     cx.ident_of(~\"decode\"),\n                 ]),\n                 ~[cx.expr_var(span, ~\"__d\")]\n-            )\n+            ),\n+            cx.ident_of(~\"__d\")\n         );\n \n         // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n@@ -1163,24 +1196,44 @@ fn mk_enum_deser_body(\n         span,\n         ast::expr_fn_block(\n             ast::fn_decl {\n-                inputs: ~[ast::arg {\n-                    is_mutbl: false,\n-                    ty: @ast::Ty {\n+                inputs: ~[\n+                    ast::arg {\n+                        is_mutbl: false,\n+                        ty: @ast::Ty {\n+                            id: ext_cx.next_id(),\n+                            node: ast::ty_infer,\n+                            span: span\n+                        },\n+                        pat: @ast::pat {\n+                            id: ext_cx.next_id(),\n+                            node: ast::pat_ident(\n+                                ast::bind_by_copy,\n+                                ast_util::ident_to_path(span,\n+                                    ext_cx.ident_of(~\"__d\")),\n+                                None),\n+                            span: span,\n+                        },\n                         id: ext_cx.next_id(),\n-                        node: ast::ty_infer,\n-                        span: span\n                     },\n-                    pat: @ast::pat {\n+                    ast::arg {\n+                        is_mutbl: false,\n+                        ty: @ast::Ty {\n+                            id: ext_cx.next_id(),\n+                            node: ast::ty_infer,\n+                            span: span\n+                        },\n+                        pat: @ast::pat {\n+                            id: ext_cx.next_id(),\n+                            node: ast::pat_ident(\n+                                ast::bind_by_copy,\n+                                ast_util::ident_to_path(span,\n+                                    ext_cx.ident_of(~\"i\")),\n+                                None),\n+                            span: span,\n+                        },\n                         id: ext_cx.next_id(),\n-                        node: ast::pat_ident(\n-                            ast::bind_by_copy,\n-                            ast_util::ident_to_path(span,\n-                                ext_cx.ident_of(~\"i\")),\n-                            None),\n-                        span: span,\n-                    },\n-                    id: ext_cx.next_id(),\n-                }],\n+                    }\n+                ],\n                 output: @ast::Ty {\n                     id: ext_cx.next_id(),\n                     node: ast::ty_infer,\n@@ -1198,13 +1251,14 @@ fn mk_enum_deser_body(\n     );\n \n     // ast for `__d.read_enum_variant($expr_arm_names, $(expr_lambda))`\n-    let expr_lambda = ext_cx.lambda_expr(\n+    let expr_lambda = ext_cx.lambda_expr_1(\n         ext_cx.expr_method_call(\n             span,\n             ext_cx.expr_var(span, ~\"__d\"),\n             ext_cx.ident_of(~\"read_enum_variant\"),\n             ~[expr_arm_names, expr_lambda]\n-        )\n+        ),\n+        ext_cx.ident_of(~\"__d\")\n     );\n \n     // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n@@ -1256,105 +1310,147 @@ mod test {\n     }\n \n     impl Encoder for TestEncoder {\n-        fn emit_nil(&self) { self.add_to_log(CallToEmitNil) }\n+        fn emit_nil(&mut self) { self.add_to_log(CallToEmitNil) }\n \n-        fn emit_uint(&self, v: uint) {self.add_to_log(CallToEmitUint(v)); }\n-        fn emit_u64(&self, _v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&self, _v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&self, _v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&self, _v: u8)   { self.add_unknown_to_log(); }\n+        fn emit_uint(&mut self, v: uint) {\n+            self.add_to_log(CallToEmitUint(v));\n+        }\n+        fn emit_u64(&mut self, _v: u64) { self.add_unknown_to_log(); }\n+        fn emit_u32(&mut self, _v: u32) { self.add_unknown_to_log(); }\n+        fn emit_u16(&mut self, _v: u16) { self.add_unknown_to_log(); }\n+        fn emit_u8(&mut self, _v: u8)   { self.add_unknown_to_log(); }\n \n-        fn emit_int(&self, _v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&self, _v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&self, _v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&self, _v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&self, _v: i8)   { self.add_unknown_to_log(); }\n+        fn emit_int(&mut self, _v: int) { self.add_unknown_to_log(); }\n+        fn emit_i64(&mut self, _v: i64) { self.add_unknown_to_log(); }\n+        fn emit_i32(&mut self, _v: i32) { self.add_unknown_to_log(); }\n+        fn emit_i16(&mut self, _v: i16) { self.add_unknown_to_log(); }\n+        fn emit_i8(&mut self, _v: i8)   { self.add_unknown_to_log(); }\n \n-        fn emit_bool(&self, _v: bool) { self.add_unknown_to_log(); }\n+        fn emit_bool(&mut self, _v: bool) { self.add_unknown_to_log(); }\n \n-        fn emit_f64(&self, _v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&self, _v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&self, _v: float) { self.add_unknown_to_log(); }\n+        fn emit_f64(&mut self, _v: f64) { self.add_unknown_to_log(); }\n+        fn emit_f32(&mut self, _v: f32) { self.add_unknown_to_log(); }\n+        fn emit_float(&mut self, _v: float) { self.add_unknown_to_log(); }\n \n-        fn emit_char(&self, _v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&self, _v: &str) { self.add_unknown_to_log(); }\n+        fn emit_char(&mut self, _v: char) { self.add_unknown_to_log(); }\n+        fn emit_str(&mut self, _v: &str) { self.add_unknown_to_log(); }\n \n-        fn emit_enum(&self, name: &str, f: &fn()) {\n-            self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n+        fn emit_enum(&mut self, name: &str, f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnum(name.to_str()));\n+            f(self);\n+        }\n \n-        fn emit_enum_variant(&self, name: &str, id: uint,\n-                             cnt: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n-            f();\n+        fn emit_enum_variant(&mut self,\n+                             name: &str,\n+                             id: uint,\n+                             cnt: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnumVariant(name.to_str(), id, cnt));\n+            f(self);\n         }\n \n-        fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n+        fn emit_enum_variant_arg(&mut self,\n+                                 idx: uint,\n+                                 f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnumVariantArg(idx));\n+            f(self);\n         }\n \n-        fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+        fn emit_enum_struct_variant(&mut self,\n+                                    name: &str,\n+                                    id: uint,\n+                                    cnt: uint,\n+                                    f: &fn(&mut TestEncoder)) {\n             self.emit_enum_variant(name, id, cnt, f)\n         }\n \n-        fn emit_enum_struct_variant_field(&self, _name: &str, idx: uint, f: &fn()) {\n+        fn emit_enum_struct_variant_field(&mut self,\n+                                          _name: &str,\n+                                          idx: uint,\n+                                          f: &fn(&mut TestEncoder)) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&self, name: &str, len: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n+        fn emit_struct(&mut self,\n+                       name: &str,\n+                       len: uint,\n+                       f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitStruct (name.to_str(),len));\n+            f(self);\n         }\n-        fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n-            self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n+        fn emit_struct_field(&mut self,\n+                             name: &str,\n+                             idx: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitField (name.to_str(),idx));\n+            f(self);\n         }\n \n-        fn emit_tuple(&self, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_tuple(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_tuple_arg(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_tuple_arg(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n \n-        fn emit_tuple_struct(&self, _name: &str, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_tuple_struct(&mut self,\n+                             _name: &str,\n+                             _len: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_tuple_struct_arg(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+\n+        fn emit_tuple_struct_arg(&mut self,\n+                                 _idx: uint,\n+                                 f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n \n-        fn emit_option(&self, f: &fn()) {\n+        fn emit_option(&mut self, f: &fn(&mut TestEncoder)) {\n             self.add_to_log(CallToEmitOption);\n-            f();\n+            f(self);\n         }\n-        fn emit_option_none(&self) {\n+        fn emit_option_none(&mut self) {\n             self.add_to_log(CallToEmitOptionNone);\n         }\n-        fn emit_option_some(&self, f: &fn()) {\n+        fn emit_option_some(&mut self, f: &fn(&mut TestEncoder)) {\n             self.add_to_log(CallToEmitOptionSome);\n-            f();\n+            f(self);\n         }\n \n-        fn emit_seq(&self, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_seq(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n \n-        fn emit_map(&self, _len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_map(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_map_elt_key(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n-        fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n         }\n     }\n \n \n     fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n-        let mut te = TestEncoder {call_log: @mut ~[]};\n-        val.encode(&te);\n+        let mut te = TestEncoder {\n+            call_log: @mut ~[]\n+        };\n+        val.encode(&mut te);\n         copy *te.call_log\n     }\n "}, {"sha": "da8f87d3891945937141ece987b69599e2eeb004", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -348,7 +348,7 @@ pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n \n pub fn expr_to_ident(cx: @ext_ctxt,\n                      expr: @ast::expr,\n-                     err_msg: ~str) -> ast::ident {\n+                     err_msg: &str) -> ast::ident {\n     match expr.node {\n       ast::expr_path(p) => {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n@@ -538,13 +538,3 @@ mod test {\n         assert_eq!(*(m.find(&@~\"def\").get()),16);\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "fe270abc2e4f224d017f14ac6e908a3f93a64273", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -96,7 +96,7 @@ fn create_decode_method(\n         cx,\n         span,\n         build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\")),\n-        ast::m_imm\n+        ast::m_mutbl\n     );\n     let d_ident = cx.ident_of(~\"__d\");\n     let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n@@ -219,6 +219,11 @@ fn create_read_struct_field(\n     // Call the substructure method.\n     let decode_expr = call_substructure_decode_method(cx, span);\n \n+    let d_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__d\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     let call_expr = build::mk_method_call(\n         cx,\n         span,\n@@ -227,7 +232,11 @@ fn create_read_struct_field(\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(ident)),\n             build::mk_uint(cx, span, idx),\n-            build::mk_lambda_no_args(cx, span, decode_expr),\n+            build::mk_lambda(cx,\n+                             span,\n+                             build::mk_fn_decl(~[d_arg],\n+                                               build::mk_ty_infer(cx, span)),\n+                             decode_expr),\n         ]\n     );\n \n@@ -282,6 +291,11 @@ fn expand_deriving_decodable_struct_method(\n         i += 1;\n     }\n \n+    let d_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__d\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     let read_struct_expr = build::mk_method_call(\n         cx,\n         span,\n@@ -294,9 +308,10 @@ fn expand_deriving_decodable_struct_method(\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n             build::mk_uint(cx, span, fields.len()),\n-            build::mk_lambda_no_args(\n+            build::mk_lambda(\n                 cx,\n                 span,\n+                build::mk_fn_decl(~[d_arg], build::mk_ty_infer(cx, span)),\n                 build::mk_struct_e(\n                     cx,\n                     span,\n@@ -334,14 +349,23 @@ fn create_read_variant_arg(\n             // Call the substructure method.\n             let expr = call_substructure_decode_method(cx, span);\n \n+            let d_arg = build::mk_arg(cx,\n+                                      span,\n+                                      cx.ident_of(~\"__d\"),\n+                                      build::mk_ty_infer(cx, span));\n+            let t_infer = build::mk_ty_infer(cx, span);\n+\n             let call_expr = build::mk_method_call(\n                 cx,\n                 span,\n                 build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n                 cx.ident_of(~\"read_enum_variant_arg\"),\n                 ~[\n                     build::mk_uint(cx, span, j),\n-                    build::mk_lambda_no_args(cx, span, expr),\n+                    build::mk_lambda(cx,\n+                                     span,\n+                                     build::mk_fn_decl(~[d_arg], t_infer),\n+                                     expr),\n                 ]\n             );\n \n@@ -399,6 +423,12 @@ fn create_read_enum_variant(\n                 span,\n                 build::mk_fn_decl(\n                     ~[\n+                        build::mk_arg(\n+                            cx,\n+                            span,\n+                            cx.ident_of(~\"__d\"),\n+                            build::mk_ty_infer(cx, span)\n+                        ),\n                         build::mk_arg(\n                             cx,\n                             span,\n@@ -434,6 +464,11 @@ fn expand_deriving_decodable_enum_method(\n         enum_definition\n     );\n \n+    let d_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__d\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     // Create the read_enum expression\n     let read_enum_expr = build::mk_method_call(\n         cx,\n@@ -442,7 +477,11 @@ fn expand_deriving_decodable_enum_method(\n         cx.ident_of(~\"read_enum\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n-            build::mk_lambda_no_args(cx, span, read_enum_variant_expr),\n+            build::mk_lambda(cx,\n+                             span,\n+                             build::mk_fn_decl(~[d_arg],\n+                                               build::mk_ty_infer(cx, span)),\n+                             read_enum_variant_expr),\n         ]\n     );\n "}, {"sha": "8f8139790ade9be66bbd42512751e154318f4c94", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -94,10 +94,9 @@ fn create_encode_method(\n         cx,\n         span,\n         build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\")),\n-        ast::m_imm\n+        ast::m_mutbl\n     );\n-    let e_ident = cx.ident_of(~\"__e\");\n-    let e_arg = build::mk_arg(cx, span, e_ident, e_arg_type);\n+    let e_arg = build::mk_arg(cx, span, cx.ident_of(~\"__e\"), e_arg_type);\n \n     // Create the type of the return value.\n     let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n@@ -226,10 +225,16 @@ fn expand_deriving_encodable_struct_method(\n                     self_field\n                 );\n \n+                let e_ident = cx.ident_of(~\"__e\");\n+                let e_arg = build::mk_arg(cx,\n+                                          span,\n+                                          e_ident,\n+                                          build::mk_ty_infer(cx, span));\n+\n                 let blk_expr = build::mk_lambda(\n                     cx,\n                     span,\n-                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                     encode_expr\n                 );\n \n@@ -257,6 +262,11 @@ fn expand_deriving_encodable_struct_method(\n         idx += 1;\n     }\n \n+    let e_arg = build::mk_arg(cx,\n+                              span,\n+                              cx.ident_of(~\"__e\"),\n+                              build::mk_ty_infer(cx, span));\n+\n     let emit_struct_stmt = build::mk_method_call(\n         cx,\n         span,\n@@ -272,7 +282,7 @@ fn expand_deriving_encodable_struct_method(\n             build::mk_lambda_stmts(\n                 cx,\n                 span,\n-                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                 statements\n             ),\n         ]\n@@ -309,10 +319,16 @@ fn expand_deriving_encodable_enum_method(\n             // Call the substructure method.\n             let expr = call_substructure_encode_method(cx, span, field);\n \n+            let e_ident = cx.ident_of(~\"__e\");\n+            let e_arg = build::mk_arg(cx,\n+                                      span,\n+                                      e_ident,\n+                                      build::mk_ty_infer(cx, span));\n+\n             let blk_expr = build::mk_lambda(\n                 cx,\n                 span,\n-                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                 expr\n             );\n \n@@ -331,6 +347,10 @@ fn expand_deriving_encodable_enum_method(\n         }\n \n         // Create the pattern body.\n+        let e_arg = build::mk_arg(cx,\n+                                  span,\n+                                  cx.ident_of(~\"__e\"),\n+                                  build::mk_ty_infer(cx, span));\n         let call_expr = build::mk_method_call(\n             cx,\n             span,\n@@ -343,7 +363,7 @@ fn expand_deriving_encodable_enum_method(\n                 build::mk_lambda_stmts(\n                     cx,\n                     span,\n-                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n                     stmts\n                 )\n             ]\n@@ -359,11 +379,17 @@ fn expand_deriving_encodable_enum_method(\n         }\n     };\n \n+    let e_ident = cx.ident_of(~\"__e\");\n+    let e_arg = build::mk_arg(cx,\n+                              span,\n+                              e_ident,\n+                              build::mk_ty_infer(cx, span));\n+\n     // Create the method body.\n     let lambda_expr = build::mk_lambda(\n         cx,\n         span,\n-        build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+        build::mk_fn_decl(~[e_arg], build::mk_ty_infer(cx, span)),\n         expand_enum_or_struct_match(cx, span, arms)\n     );\n "}, {"sha": "5b1e3737b236b5ca7ce7cb1276ea03e02674a295", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -34,13 +34,3 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     };\n     MRExpr(e)\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "965d95789c4bf392b025fe3223d28f685e367012", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -490,7 +490,7 @@ pub fn core_macros() -> ~str {\n \n         { $c:ident: $in:ty -> $out:ty; } => {\n \n-            mod $c {\n+            pub mod $c {\n                 fn key(_x: @::core::condition::Handler<$in,$out>) { }\n \n                 pub static cond :\n@@ -724,11 +724,3 @@ mod test {\n     }\n \n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "e9eebe5b2acc6ef98c529009d3d65d202bda64dc", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -273,15 +273,13 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {\n-                let portion = mk_uniq_str(cx, fmt_sp, s);\n-\n                 /* If this is the first portion, then initialize the local\n                    buffer with it directly. If it's actually the only piece,\n                    then there's no need for it to be mutable */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, npieces > 1, ident, portion));\n+                    stms.push(mk_local(cx, fmt_sp, npieces > 1, ident, mk_uniq_str(cx, fmt_sp, s)));\n                 } else {\n-                    let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), portion];\n+                    let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), mk_base_str(cx, fmt_sp, s)];\n                     let call = mk_call_global(cx,\n                                               fmt_sp,\n                                               ~[str_ident, push_ident],\n@@ -322,12 +320,3 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n \n     return mk_block(cx, fmt_sp, ~[], stms, Some(buf()));\n }\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "38e43d1ade562a4469c71e0b63f3f9b7edb8bbc5", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -80,4 +80,3 @@ impl proto::visitor<(), (), ()> for @ext_ctxt {\n         }\n     }\n }\n-"}, {"sha": "bd5353b2100314adab8de0cf0f6d87346abf4f9d", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -104,4 +104,3 @@ pub fn analyze(proto: &mut protocol_, _cx: @ext_ctxt) {\n         proto.bounded = Some(true);\n     }\n }\n-"}, {"sha": "85c578bc2ce1af23d77a99ed4ed45c4a6693e6fa", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -85,4 +85,3 @@ pub fn expand_proto(cx: @ext_ctxt, _sp: span, id: ast::ident,\n     // compile\n     base::MRItem(proto.compile(cx))\n }\n-"}, {"sha": "e876972fe6878c1cf74099a790da96247f84797d", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -415,7 +415,8 @@ impl gen_init for protocol {\n                             ast::struct_immutable,\n                             ast::inherited),\n                     id: cx.next_id(),\n-                    ty: fty\n+                    ty: fty,\n+                    attrs: ~[],\n                 },\n                 span: dummy_sp()\n             }\n@@ -431,7 +432,6 @@ impl gen_init for protocol {\n             dummy_sp(),\n             ast::struct_def {\n                 fields: fields,\n-                dtor: None,\n                 ctor_id: None\n             },\n             cx.strip_bounds(&generics))"}, {"sha": "647c7741bd8972f5ca4de5eadc1acf6b7a53b203", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -217,4 +217,3 @@ pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     };\n     visitor.visit_proto(proto, states)\n }\n-"}, {"sha": "2bf4b05aa6b02ed7025a26be6cc43eb61043dadf", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -760,4 +760,3 @@ fn expand_parse_call(cx: @ext_ctxt,\n                           id_ext(cx, parse_method),\n                           arg_exprs)\n }\n-"}, {"sha": "ab22b3152f4771d7b64ea3bbf1cf34ba2419be22", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -150,13 +150,3 @@ fn res_rel_file(cx: @ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n         copy *arg\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0c1e619985d2605844257393fa9406edc0bb8ca6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -438,11 +438,3 @@ pub fn parse_nt(p: &Parser, name: ~str) -> nonterminal {\n       _ => p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)\n     }\n }\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "229a8664d0c350b3a9af27ff4089d0d35ea86401", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -222,9 +222,12 @@ pub fn noop_fold_item(i: @item, fld: @ast_fold) -> Option<@item> {\n \n fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n                        -> @struct_field {\n+    let fold_attribute = |x| fold_attribute_(x, fld);\n+\n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n-                                          ty: fld.fold_ty(sf.node.ty) },\n+                                          ty: fld.fold_ty(sf.node.ty),\n+                                          attrs: sf.node.attrs.map(|e| fold_attribute(*e)) },\n                span: sf.span }\n }\n \n@@ -290,21 +293,8 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n \n fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n                 -> @ast::struct_def {\n-    let dtor = do struct_def.dtor.map |dtor| {\n-        let dtor_body = fld.fold_block(&dtor.node.body);\n-        let dtor_id   = fld.new_id(dtor.node.id);\n-        spanned {\n-            node: ast::struct_dtor_ {\n-                body: dtor_body,\n-                id: dtor_id,\n-                .. copy dtor.node\n-            },\n-            span: copy dtor.span\n-        }\n-    };\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n-        dtor: dtor,\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n     }\n }\n@@ -322,6 +312,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n             kind: copy f.node.kind,\n             id: fld.new_id(f.node.id),\n             ty: fld.fold_ty(f.node.ty),\n+            attrs: /* FIXME (#2543) */ copy f.node.attrs,\n         },\n         span: fld.new_span(f.span),\n     }\n@@ -655,22 +646,9 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n             })\n         }\n         struct_variant_kind(struct_def) => {\n-            let dtor = do struct_def.dtor.map |dtor| {\n-                let dtor_body = fld.fold_block(&dtor.node.body);\n-                let dtor_id   = fld.new_id(dtor.node.id);\n-                spanned {\n-                    node: ast::struct_dtor_ {\n-                        body: dtor_body,\n-                        id: dtor_id,\n-                        .. copy dtor.node\n-                    },\n-                    .. copy *dtor\n-                }\n-            };\n             kind = struct_variant_kind(@ast::struct_def {\n                 fields: vec::map(struct_def.fields,\n                                  |f| fld.fold_struct_field(*f)),\n-                dtor: dtor,\n                 ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n             })\n         }\n@@ -783,6 +761,7 @@ impl ast_fold for AstFoldFns {\n                 kind: copy sf.node.kind,\n                 id: sf.node.id,\n                 ty: (self as @ast_fold).fold_ty(sf.node.ty),\n+                attrs: copy sf.node.attrs,\n             },\n             span: (self.new_span)(sf.span),\n         }\n@@ -880,13 +859,3 @@ impl AstFoldExtensions for @ast_fold {\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "037b2c089f46a6936c2bce7b8ea704be98fbf4a8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -179,13 +179,3 @@ impl parser_attr for Parser {\n         }\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "8956622a06b589d98ca783ce4df8de7e8e4615a6", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -892,13 +892,3 @@ mod test {\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0c024958a24d8c3af92d55d24591d7884c5e7d62", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -418,9 +418,10 @@ mod test {\n         new_parser_from_source_str(ps,~[],~\"bogofile\",source_str)\n     }\n \n-    #[test] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n+    #[cfg(test)] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n         do io::with_str_writer |writer| {\n-            val.encode(~std::json::Encoder(writer));\n+            let mut encoder = std::json::Encoder(writer);\n+            val.encode(&mut encoder);\n         }\n     }\n \n@@ -674,13 +675,3 @@ mod test {\n         string_to_expr(@~\"a::z.froob(b,@(987+3))\");\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "e486a6254e76a302733a27f91f2471b89e5ca8a7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -18,7 +18,7 @@ removed.\n */\n \n \n-use ast::{expr, expr_lit, lit_nil};\n+use ast::{expr, expr_lit, lit_nil, attribute};\n use ast;\n use codemap::{span, respan};\n use parse::parser::Parser;\n@@ -282,13 +282,13 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_priv_section(&self) -> bool {\n+    fn try_parse_obsolete_priv_section(&self, attrs: ~[attribute]) -> bool {\n         if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n             self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n-                self.parse_single_struct_field(ast::private);\n+                self.parse_single_struct_field(ast::private, attrs);\n             }\n             self.bump();\n             true\n@@ -298,4 +298,3 @@ pub impl Parser {\n     }\n \n }\n-"}, {"sha": "4839b1797234936bce61d28e88f05282f2a8efc5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 59, "deletions": 137, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -19,7 +19,7 @@ use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n-use ast::{decl_local, default_blk, deref, quot, enum_def};\n+use ast::{decl_local, default_blk, deref, div, enum_def};\n use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n@@ -102,11 +102,6 @@ enum restriction {\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n-//  So that we can distinguish a class dtor from other class members\n-\n-enum class_contents { dtor_decl(blk, ~[attribute], codemap::span),\n-                      members(~[@struct_field]) }\n-\n type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[attribute]>);\n \n@@ -313,22 +308,22 @@ pub impl Parser {\n         }\n         return copy self.buffer[(*self.buffer_start + dist - 1) & 3].tok;\n     }\n-    fn fatal(&self, m: ~str) -> ! {\n+    fn fatal(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*copy self.span, m)\n     }\n-    fn span_fatal(&self, sp: span, m: ~str) -> ! {\n+    fn span_fatal(&self, sp: span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    fn span_note(&self, sp: span, m: ~str) {\n+    fn span_note(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n-    fn bug(&self, m: ~str) -> ! {\n+    fn bug(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(*copy self.span, m)\n     }\n-    fn warn(&self, m: ~str) {\n+    fn warn(&self, m: &str) {\n         self.sess.span_diagnostic.span_warn(*copy self.span, m)\n     }\n-    fn span_err(&self, sp: span, m: ~str) {\n+    fn span_err(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n     fn abort_if_errors(&self) {\n@@ -937,7 +932,7 @@ pub impl Parser {\n         loop {\n             match *self.token {\n                 token::MOD_SEP => {\n-                    match self.look_ahead(1u) {\n+                    match self.look_ahead(1) {\n                         token::IDENT(*) => {\n                             self.bump();\n                             ids.push(self.parse_ident());\n@@ -1836,7 +1831,7 @@ pub impl Parser {\n                   token::PLUS => aop = add,\n                   token::MINUS => aop = subtract,\n                   token::STAR => aop = mul,\n-                  token::SLASH => aop = quot,\n+                  token::SLASH => aop = div,\n                   token::PERCENT => aop = rem,\n                   token::CARET => aop = bitxor,\n                   token::AND => aop = bitand,\n@@ -2034,8 +2029,7 @@ pub impl Parser {\n             // This is a 'continue' expression\n             if opt_ident.is_some() {\n                 self.span_err(*self.last_span,\n-                              ~\"a label may not be used with a `loop` \\\n-                                expression\");\n+                              \"a label may not be used with a `loop` expression\");\n             }\n \n             let lo = self.span.lo;\n@@ -2172,7 +2166,7 @@ pub impl Parser {\n                     @ast::pat { node: pat_wild, _ } => (),\n                     @ast::pat { node: pat_ident(_, _, _), _ } => (),\n                     @ast::pat { span, _ } => self.span_fatal(\n-                        span, ~\"expected an identifier or `_`\"\n+                        span, \"expected an identifier or `_`\"\n                     )\n                 }\n                 slice = Some(subpat);\n@@ -2464,7 +2458,7 @@ pub impl Parser {\n                        -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n             self.span_fatal(*self.last_span,\n-                            ~\"expected identifier, found path\");\n+                            \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n@@ -2483,7 +2477,7 @@ pub impl Parser {\n         if *self.token == token::LPAREN {\n             self.span_fatal(\n                 *self.last_span,\n-                ~\"expected identifier, found enum pattern\");\n+                \"expected identifier, found enum pattern\");\n         }\n \n         pat_ident(binding_mode, name, sub)\n@@ -2525,7 +2519,9 @@ pub impl Parser {\n     }\n \n     // parse a structure field\n-    fn parse_name_and_ty(&self, pr: visibility) -> @struct_field {\n+    fn parse_name_and_ty(&self,\n+                         pr: visibility,\n+                         attrs: ~[attribute]) -> @struct_field {\n         let mut is_mutbl = struct_immutable;\n         let lo = self.span.lo;\n         if self.eat_keyword(&~\"mut\") {\n@@ -2540,7 +2536,8 @@ pub impl Parser {\n         @spanned(lo, self.last_span.hi, ast::struct_field_ {\n             kind: named_field(name, is_mutbl, pr),\n             id: self.get_id(),\n-            ty: ty\n+            ty: ty,\n+            attrs: attrs,\n         })\n     }\n \n@@ -2611,19 +2608,19 @@ pub impl Parser {\n \n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                            false) {\n-              iovi_item(i) => {\n-                let hi = i.span.hi;\n-                let decl = @spanned(lo, hi, decl_item(i));\n-                return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n-              }\n-              iovi_view_item(vi) => {\n-                self.span_fatal(vi.span, ~\"view items must be declared at \\\n-                                           the top of the block\");\n-              }\n-              iovi_foreign_item(_) => {\n-                  self.fatal(~\"foreign items are not allowed here\");\n-              }\n-              iovi_none() => { /* fallthrough */ }\n+                iovi_item(i) => {\n+                    let hi = i.span.hi;\n+                    let decl = @spanned(lo, hi, decl_item(i));\n+                    return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n+                }\n+                iovi_view_item(vi) => {\n+                    self.span_fatal(vi.span,\n+                                    \"view items must be declared at the top of the block\");\n+                }\n+                iovi_foreign_item(_) => {\n+                    self.fatal(~\"foreign items are not allowed here\");\n+                }\n+                iovi_none() => { /* fallthrough */ }\n             }\n \n             check_expected_item(self, item_attrs);\n@@ -2824,8 +2821,7 @@ pub impl Parser {\n                         result.push(RegionTyParamBound);\n                     } else {\n                         self.span_err(*self.span,\n-                                      ~\"`'static` is the only permissible \\\n-                                        region bound here\");\n+                                      \"`'static` is the only permissible region bound here\");\n                     }\n                     self.bump();\n                 }\n@@ -3240,7 +3236,7 @@ pub impl Parser {\n                     })\n                 }\n                 _ => {\n-                    self.span_err(*self.span, ~\"not a trait\");\n+                    self.span_err(*self.span, \"not a trait\");\n                     None\n                 }\n             };\n@@ -3299,34 +3295,15 @@ pub impl Parser {\n         }\n \n         let mut fields: ~[@struct_field];\n-        let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let is_tuple_like;\n \n         if self.eat(&token::LBRACE) {\n             // It's a record-like struct.\n             is_tuple_like = false;\n             fields = ~[];\n             while *self.token != token::RBRACE {\n-                match self.parse_struct_decl_field() {\n-                  dtor_decl(ref blk, ref attrs, s) => {\n-                      match the_dtor {\n-                        Some((_, _, s_first)) => {\n-                          self.span_note(s, fmt!(\"Duplicate destructor \\\n-                                     declaration for class %s\",\n-                                     *self.interner.get(class_name)));\n-                          self.span_fatal(copy s_first, ~\"First destructor \\\n-                                                          declared here\");\n-                        }\n-                        None => {\n-                          the_dtor = Some((copy *blk, copy *attrs, s));\n-                        }\n-                      }\n-                  }\n-                  members(mms) => {\n-                    for mms.each |struct_field| {\n-                        fields.push(*struct_field)\n-                    }\n-                  }\n+                for self.parse_struct_decl_field().each |struct_field| {\n+                    fields.push(*struct_field)\n                 }\n             }\n             if fields.len() == 0 {\n@@ -3342,11 +3319,13 @@ pub impl Parser {\n                 &token::RPAREN,\n                 seq_sep_trailing_allowed(token::COMMA)\n             ) |p| {\n+                let attrs = self.parse_outer_attributes();\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::struct_field_ {\n                     kind: unnamed_field,\n                     id: self.get_id(),\n-                    ty: p.parse_ty(false)\n+                    ty: p.parse_ty(false),\n+                    attrs: attrs,\n                 };\n                 @spanned(lo, p.span.hi, struct_field_)\n             };\n@@ -3365,19 +3344,11 @@ pub impl Parser {\n             );\n         }\n \n-        let actual_dtor = do the_dtor.map |dtor| {\n-            let (d_body, d_attrs, d_s) = copy *dtor;\n-            codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n-                                                     attrs: d_attrs,\n-                                                     self_id: self.get_id(),\n-                                                     body: d_body},\n-                       span: d_s}};\n         let _ = self.get_id();  // XXX: Workaround for crazy bug.\n         let new_id = self.get_id();\n         (class_name,\n          item_struct(@ast::struct_def {\n              fields: fields,\n-             dtor: actual_dtor,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None }\n          }, generics),\n          None)\n@@ -3391,12 +3362,14 @@ pub impl Parser {\n     }\n \n     // parse a structure field declaration\n-    fn parse_single_struct_field(&self, vis: visibility) -> @struct_field {\n+    fn parse_single_struct_field(&self,\n+                                 vis: visibility,\n+                                 attrs: ~[attribute]) -> @struct_field {\n         if self.eat_obsolete_ident(\"let\") {\n             self.obsolete(*self.last_span, ObsoleteLet);\n         }\n \n-        let a_var = self.parse_name_and_ty(vis);\n+        let a_var = self.parse_name_and_ty(vis, attrs);\n         match *self.token {\n             token::SEMI => {\n                 self.obsolete(copy *self.span, ObsoleteFieldTerminator);\n@@ -3420,34 +3393,27 @@ pub impl Parser {\n     }\n \n     // parse an element of a struct definition\n-    fn parse_struct_decl_field(&self) -> class_contents {\n-\n-        if self.try_parse_obsolete_priv_section() {\n-            return members(~[]);\n-        }\n+    fn parse_struct_decl_field(&self) -> ~[@struct_field] {\n \n         let attrs = self.parse_outer_attributes();\n \n+        if self.try_parse_obsolete_priv_section(attrs) {\n+            return ~[];\n+        }\n+\n         if self.eat_keyword(&~\"priv\") {\n-            return members(~[self.parse_single_struct_field(private)])\n+            return ~[self.parse_single_struct_field(private, attrs)]\n         }\n \n         if self.eat_keyword(&~\"pub\") {\n-           return members(~[self.parse_single_struct_field(public)]);\n+           return ~[self.parse_single_struct_field(public, attrs)];\n         }\n \n         if self.try_parse_obsolete_struct_ctor() {\n-            return members(~[]);\n+            return ~[];\n         }\n \n-        if self.eat_keyword(&~\"drop\") {\n-            let lo = self.last_span.lo;\n-            let body = self.parse_block();\n-            return dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n-        }\n-        else {\n-           return members(~[self.parse_single_struct_field(inherited)]);\n-        }\n+        return ~[self.parse_single_struct_field(inherited, attrs)];\n     }\n \n     // parse visiility: PUB, PRIV, or nothing\n@@ -3499,9 +3465,8 @@ pub impl Parser {\n             ) {\n               iovi_item(item) => items.push(item),\n               iovi_view_item(view_item) => {\n-                self.span_fatal(view_item.span, ~\"view items must be \\\n-                                                  declared at the top of the \\\n-                                                  module\");\n+                self.span_fatal(view_item.span, \"view items must be  declared at the top of the \\\n+                                                 module\");\n               }\n               _ => {\n                 self.fatal(\n@@ -3793,7 +3758,7 @@ pub impl Parser {\n         }\n \n         if opt_abis.is_some() {\n-            self.span_err(*self.span, ~\"an ABI may not be specified here\");\n+            self.span_err(*self.span, \"an ABI may not be specified here\");\n         }\n \n         // extern mod foo;\n@@ -3829,44 +3794,16 @@ pub impl Parser {\n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n     fn parse_struct_def(&self) -> @struct_def {\n-        let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n-            match self.parse_struct_decl_field() {\n-                dtor_decl(ref blk, ref attrs, s) => {\n-                    match the_dtor {\n-                        Some((_, _, s_first)) => {\n-                            self.span_note(s, ~\"duplicate destructor \\\n-                                                declaration\");\n-                            self.span_fatal(copy s_first,\n-                                            ~\"first destructor \\\n-                                              declared here\");\n-                        }\n-                        None => {\n-                            the_dtor = Some((copy *blk, copy *attrs, s));\n-                        }\n-                    }\n-                }\n-                members(mms) => {\n-                    for mms.each |struct_field| {\n-                        fields.push(*struct_field);\n-                    }\n-                }\n+            for self.parse_struct_decl_field().each |struct_field| {\n+                fields.push(*struct_field);\n             }\n         }\n         self.bump();\n-        let actual_dtor = do the_dtor.map |dtor| {\n-            let (d_body, d_attrs, d_s) = copy *dtor;\n-            codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n-                                                     attrs: d_attrs,\n-                                                     self_id: self.get_id(),\n-                                                     body: d_body },\n-                      span: d_s }\n-        };\n \n         return @ast::struct_def {\n             fields: fields,\n-            dtor: actual_dtor,\n             ctor_id: None\n         };\n     }\n@@ -4456,9 +4393,7 @@ pub impl Parser {\n                         view_item_extern_mod(*)\n                         if !extern_mod_allowed => {\n                             self.span_err(view_item.span,\n-                                          ~\"\\\"extern mod\\\" \\\n-                                            declarations are not \\\n-                                            allowed here\");\n+                                          \"\\\"extern mod\\\" declarations are not allowed here\");\n                         }\n                         view_item_extern_mod(*) => {}\n                     }\n@@ -4484,8 +4419,7 @@ pub impl Parser {\n                     iovi_none => break,\n                     iovi_view_item(view_item) => {\n                         self.span_err(view_item.span,\n-                                      ~\"`use` and `extern mod` declarations \\\n-                                        must precede items\");\n+                                      \"`use` and `extern mod` declarations must precede items\");\n                     }\n                     iovi_item(item) => {\n                         items.push(item)\n@@ -4520,8 +4454,7 @@ pub impl Parser {\n                 iovi_view_item(view_item) => {\n                     // I think this can't occur:\n                     self.span_err(view_item.span,\n-                                  ~\"`use` and `extern mod` declarations \\\n-                                    must precede items\");\n+                                  \"`use` and `extern mod` declarations must precede items\");\n                 }\n                 iovi_item(_) => {\n                     // FIXME #5668: this will occur for a macro invocation:\n@@ -4568,14 +4501,3 @@ pub impl Parser {\n         }\n     }\n }\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "fe7bd5b3bc17db3790e954d396dc11f805b840c6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 71, "deletions": 84, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -305,50 +305,47 @@ pub fn is_bar(t: &Token) -> bool {\n pub mod special_idents {\n     use ast::ident;\n \n-    pub static underscore : ident = ident { repr: 0u, ctxt: 0};\n-    pub static anon : ident = ident { repr: 1u, ctxt: 0};\n-    pub static dtor : ident = ident { repr: 2u, ctxt: 0}; // 'drop', but that's\n-                                                 // reserved\n-    pub static invalid : ident = ident { repr: 3u, ctxt: 0}; // ''\n-    pub static unary : ident = ident { repr: 4u, ctxt: 0};\n-    pub static not_fn : ident = ident { repr: 5u, ctxt: 0};\n-    pub static idx_fn : ident = ident { repr: 6u, ctxt: 0};\n-    pub static unary_minus_fn : ident = ident { repr: 7u, ctxt: 0};\n-    pub static clownshoes_extensions : ident = ident { repr: 8u, ctxt: 0};\n-\n-    pub static self_ : ident = ident { repr: 9u, ctxt: 0}; // 'self'\n+    pub static underscore : ident = ident { repr: 0, ctxt: 0};\n+    pub static anon : ident = ident { repr: 1, ctxt: 0};\n+    pub static invalid : ident = ident { repr: 2, ctxt: 0}; // ''\n+    pub static unary : ident = ident { repr: 3, ctxt: 0};\n+    pub static not_fn : ident = ident { repr: 4, ctxt: 0};\n+    pub static idx_fn : ident = ident { repr: 5, ctxt: 0};\n+    pub static unary_minus_fn : ident = ident { repr: 6, ctxt: 0};\n+    pub static clownshoes_extensions : ident = ident { repr: 7, ctxt: 0};\n+\n+    pub static self_ : ident = ident { repr: 8, ctxt: 0}; // 'self'\n \n     /* for matcher NTs */\n-    pub static item : ident = ident { repr: 10u, ctxt: 0};\n-    pub static block : ident = ident { repr: 11u, ctxt: 0};\n-    pub static stmt : ident = ident { repr: 12u, ctxt: 0};\n-    pub static pat : ident = ident { repr: 13u, ctxt: 0};\n-    pub static expr : ident = ident { repr: 14u, ctxt: 0};\n-    pub static ty : ident = ident { repr: 15u, ctxt: 0};\n-    pub static ident : ident = ident { repr: 16u, ctxt: 0};\n-    pub static path : ident = ident { repr: 17u, ctxt: 0};\n-    pub static tt : ident = ident { repr: 18u, ctxt: 0};\n-    pub static matchers : ident = ident { repr: 19u, ctxt: 0};\n-\n-    pub static str : ident = ident { repr: 20u, ctxt: 0}; // for the type\n+    pub static item : ident = ident { repr: 9, ctxt: 0};\n+    pub static block : ident = ident { repr: 10, ctxt: 0};\n+    pub static stmt : ident = ident { repr: 11, ctxt: 0};\n+    pub static pat : ident = ident { repr: 12, ctxt: 0};\n+    pub static expr : ident = ident { repr: 13, ctxt: 0};\n+    pub static ty : ident = ident { repr: 14, ctxt: 0};\n+    pub static ident : ident = ident { repr: 15, ctxt: 0};\n+    pub static path : ident = ident { repr: 16, ctxt: 0};\n+    pub static tt : ident = ident { repr: 17, ctxt: 0};\n+    pub static matchers : ident = ident { repr: 18, ctxt: 0};\n+\n+    pub static str : ident = ident { repr: 19, ctxt: 0}; // for the type\n \n     /* outside of libsyntax */\n-    pub static ty_visitor : ident = ident { repr: 21u, ctxt: 0};\n-    pub static arg : ident = ident { repr: 22u, ctxt: 0};\n-    pub static descrim : ident = ident { repr: 23u, ctxt: 0};\n-    pub static clownshoe_abi : ident = ident { repr: 24u, ctxt: 0};\n-    pub static clownshoe_stack_shim : ident = ident { repr: 25u, ctxt: 0};\n-    pub static tydesc : ident = ident { repr: 26u, ctxt: 0};\n-    pub static literally_dtor : ident = ident { repr: 27u, ctxt: 0};\n-    pub static main : ident = ident { repr: 28u, ctxt: 0};\n-    pub static opaque : ident = ident { repr: 29u, ctxt: 0};\n-    pub static blk : ident = ident { repr: 30u, ctxt: 0};\n-    pub static static : ident = ident { repr: 31u, ctxt: 0};\n-    pub static intrinsic : ident = ident { repr: 32u, ctxt: 0};\n-    pub static clownshoes_foreign_mod: ident = ident { repr: 33u, ctxt: 0};\n-    pub static unnamed_field: ident = ident { repr: 34u, ctxt: 0};\n-    pub static c_abi: ident = ident { repr: 35u, ctxt: 0};\n-    pub static type_self: ident = ident { repr: 36u, ctxt: 0};    // `Self`\n+    pub static ty_visitor : ident = ident { repr: 20, ctxt: 0};\n+    pub static arg : ident = ident { repr: 21, ctxt: 0};\n+    pub static descrim : ident = ident { repr: 22, ctxt: 0};\n+    pub static clownshoe_abi : ident = ident { repr: 23, ctxt: 0};\n+    pub static clownshoe_stack_shim : ident = ident { repr: 24, ctxt: 0};\n+    pub static tydesc : ident = ident { repr: 25, ctxt: 0};\n+    pub static main : ident = ident { repr: 26, ctxt: 0};\n+    pub static opaque : ident = ident { repr: 27, ctxt: 0};\n+    pub static blk : ident = ident { repr: 28, ctxt: 0};\n+    pub static static : ident = ident { repr: 29, ctxt: 0};\n+    pub static intrinsic : ident = ident { repr: 30, ctxt: 0};\n+    pub static clownshoes_foreign_mod: ident = ident { repr: 31, ctxt: 0};\n+    pub static unnamed_field: ident = ident { repr: 32, ctxt: 0};\n+    pub static c_abi: ident = ident { repr: 33, ctxt: 0};\n+    pub static type_self: ident = ident { repr: 34, ctxt: 0};    // `Self`\n }\n \n pub struct StringRef<'self>(&'self str);\n@@ -371,7 +368,7 @@ impl<'self> to_bytes::IterBytes for StringRef<'self> {\n pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n   match tok {\n       BINOP(STAR)    => Some(ast::mul),\n-      BINOP(SLASH)   => Some(ast::quot),\n+      BINOP(SLASH)   => Some(ast::div),\n       BINOP(PERCENT) => Some(ast::rem),\n       BINOP(PLUS)    => Some(ast::add),\n       BINOP(MINUS)   => Some(ast::subtract),\n@@ -426,41 +423,39 @@ pub fn mk_fresh_ident_interner() -> @ident_interner {\n     let init_vec = ~[\n         @~\"_\",                  // 0\n         @~\"anon\",               // 1\n-        @~\"drop\",               // 2\n-        @~\"\",                   // 3\n-        @~\"unary\",              // 4\n-        @~\"!\",                  // 5\n-        @~\"[]\",                 // 6\n-        @~\"unary-\",             // 7\n-        @~\"__extensions__\",     // 8\n-        @~\"self\",               // 9\n-        @~\"item\",               // 10\n-        @~\"block\",              // 11\n-        @~\"stmt\",               // 12\n-        @~\"pat\",                // 13\n-        @~\"expr\",               // 14\n-        @~\"ty\",                 // 15\n-        @~\"ident\",              // 16\n-        @~\"path\",               // 17\n-        @~\"tt\",                 // 18\n-        @~\"matchers\",           // 19\n-        @~\"str\",                // 20\n-        @~\"TyVisitor\",          // 21\n-        @~\"arg\",                // 22\n-        @~\"descrim\",            // 23\n-        @~\"__rust_abi\",         // 24\n-        @~\"__rust_stack_shim\",  // 25\n-        @~\"TyDesc\",             // 26\n-        @~\"dtor\",               // 27\n-        @~\"main\",               // 28\n-        @~\"<opaque>\",           // 29\n-        @~\"blk\",                // 30\n-        @~\"static\",             // 31\n-        @~\"intrinsic\",          // 32\n-        @~\"__foreign_mod__\",    // 33\n-        @~\"__field__\",          // 34\n-        @~\"C\",                  // 35\n-        @~\"Self\",               // 36\n+        @~\"\",                   // 2\n+        @~\"unary\",              // 3\n+        @~\"!\",                  // 4\n+        @~\"[]\",                 // 5\n+        @~\"unary-\",             // 6\n+        @~\"__extensions__\",     // 7\n+        @~\"self\",               // 8\n+        @~\"item\",               // 9\n+        @~\"block\",              // 10\n+        @~\"stmt\",               // 11\n+        @~\"pat\",                // 12\n+        @~\"expr\",               // 13\n+        @~\"ty\",                 // 14\n+        @~\"ident\",              // 15\n+        @~\"path\",               // 16\n+        @~\"tt\",                 // 17\n+        @~\"matchers\",           // 18\n+        @~\"str\",                // 19\n+        @~\"TyVisitor\",          // 20\n+        @~\"arg\",                // 21\n+        @~\"descrim\",            // 22\n+        @~\"__rust_abi\",         // 23\n+        @~\"__rust_stack_shim\",  // 24\n+        @~\"TyDesc\",             // 25\n+        @~\"main\",               // 26\n+        @~\"<opaque>\",           // 27\n+        @~\"blk\",                // 28\n+        @~\"static\",             // 29\n+        @~\"intrinsic\",          // 30\n+        @~\"__foreign_mod__\",    // 31\n+        @~\"__field__\",          // 32\n+        @~\"C\",                  // 33\n+        @~\"Self\",               // 34\n     ];\n \n     let rv = @ident_interner {\n@@ -561,11 +556,3 @@ pub fn reserved_keyword_table() -> HashSet<~str> {\n     }\n     return words;\n }\n-\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "43f62d72a9fade947212a5b10446796094457d3d", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -587,14 +587,3 @@ pub fn hardbreak_tok_offset(off: int) -> token {\n }\n \n pub fn hardbreak_tok() -> token { return hardbreak_tok_offset(0); }\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "6f3d6604d5b98de8cce1f7928383f8eadbc9b385", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -699,20 +699,14 @@ pub fn print_struct(s: @ps,\n         nbsp(s);\n         bopen(s);\n         hardbreak_if_not_bol(s);\n-        for struct_def.dtor.each |dtor| {\n-          hardbreak_if_not_bol(s);\n-          maybe_print_comment(s, dtor.span.lo);\n-          print_outer_attributes(s, dtor.node.attrs);\n-          head(s, ~\"drop\");\n-          print_block(s, &dtor.node.body);\n-        }\n \n         for struct_def.fields.each |field| {\n             match field.node.kind {\n                 ast::unnamed_field => fail!(~\"unexpected unnamed field\"),\n                 ast::named_field(ident, mutability, visibility) => {\n                     hardbreak_if_not_bol(s);\n                     maybe_print_comment(s, field.span.lo);\n+                    print_outer_attributes(s, field.node.attrs);\n                     print_visibility(s, visibility);\n                     if mutability == ast::struct_mutable {\n                         word_nbsp(s, ~\"mut\");\n@@ -2292,13 +2286,3 @@ mod test {\n         assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "b8327de0f1320b7292d97f5ee8c7b4309941c6d4", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -22,7 +22,6 @@\n \n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[deny(deprecated_mode)];\n #[deny(deprecated_pattern)];\n \n extern mod std(vers = \"0.7-pre\");\n@@ -90,4 +89,3 @@ pub mod ext {\n \n     pub mod trace_macros;\n }\n-"}, {"sha": "90dd49d684843165bb58f2592a7f21685a03a8e7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -11,7 +11,6 @@\n use abi::AbiSet;\n use ast::*;\n use ast;\n-use ast_util;\n use codemap::span;\n use parse;\n use opt_vec;\n@@ -45,13 +44,6 @@ pub enum fn_kind<'self> {\n \n     // |x, y| ...\n     fk_fn_block,\n-\n-    fk_dtor( // class destructor\n-        &'self Generics,\n-        &'self [attribute],\n-        node_id /* self id */,\n-        def_id /* parent class id */\n-    )\n }\n \n pub fn name_of_fn(fk: &fn_kind) -> ident {\n@@ -60,15 +52,13 @@ pub fn name_of_fn(fk: &fn_kind) -> ident {\n           name\n       }\n       fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n-      fk_dtor(*)                  => parse::token::special_idents::dtor\n     }\n }\n \n pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n     match *fk {\n         fk_item_fn(_, generics, _, _) |\n-        fk_method(_, generics, _) |\n-        fk_dtor(generics, _, _, _) => {\n+        fk_method(_, generics, _) => {\n             copy *generics\n         }\n         fk_anon(*) | fk_fn_block(*) => {\n@@ -375,25 +365,6 @@ pub fn visit_method_helper<E: Copy>(m: &method, e: E, v: vt<E>) {\n     );\n }\n \n-pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, generics: &Generics,\n-                                   parent_id: def_id, e: E, v: vt<E>) {\n-    (v.visit_fn)(\n-        &fk_dtor(\n-            generics,\n-            dtor.node.attrs,\n-            dtor.node.self_id,\n-            parent_id\n-        ),\n-        &ast_util::dtor_dec(),\n-        &dtor.node.body,\n-        dtor.span,\n-        dtor.node.id,\n-        e,\n-        v\n-    )\n-\n-}\n-\n pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                          _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n@@ -418,23 +389,14 @@ pub fn visit_trait_method<E: Copy>(m: &trait_method, e: E, v: vt<E>) {\n pub fn visit_struct_def<E: Copy>(\n     sd: @struct_def,\n     _nm: ast::ident,\n-    generics: &Generics,\n-    id: node_id,\n+    _generics: &Generics,\n+    _id: node_id,\n     e: E,\n     v: vt<E>\n ) {\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n-    for sd.dtor.each |dtor| {\n-        visit_struct_dtor_helper(\n-            *dtor,\n-            generics,\n-            ast_util::local_def(id),\n-            e,\n-            v\n-        )\n-    }\n }\n \n pub fn visit_struct_field<E: Copy>(sf: @struct_field, e: E, v: vt<E>) {\n@@ -801,11 +763,3 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n             v_struct_method(v.visit_struct_method, a, b, c)\n     });\n }\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "2e9f0d21fe321849a4759a01fc28eae82ef196d6", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -1 +1 @@\n-Subproject commit 56dd407f4f97a01b8df6554c569170d2fc276fcb\n+Subproject commit 2e9f0d21fe321849a4759a01fc28eae82ef196d6"}, {"sha": "6441f59a4d30c4371021a1d542a26c4e5200a533", "filename": "src/rt/arch/arm/_context.S", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2F_context.S?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -48,5 +48,3 @@ swap_registers:\n \tmsr cpsr_cxsf, r2\n \n \tmov pc, lr\n-\n-"}, {"sha": "77ec9d5182a17b89efaf56ba75f488b670e024c1", "filename": "src/rt/arch/arm/gpr.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fgpr.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -14,4 +14,3 @@ void rust_gpr::load() {\n     LOAD(r8);  LOAD(r9);  LOAD(r10); LOAD(r11);\n     LOAD(r12); LOAD(r13); LOAD(r14); LOAD(r15);\n }\n-"}, {"sha": "c8a3e916a371c0692d356f7a42bdf4cfb692ba49", "filename": "src/rt/arch/arm/gpr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fgpr.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -21,4 +21,3 @@ class rust_gpr : public rust_gpr_base {\n };\n \n #endif\n-"}, {"sha": "f0ec3f4b7a5118e6c6863654eddce2c61ea2d94f", "filename": "src/rt/arch/arm/morestack.S", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fmorestack.S?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -35,7 +35,7 @@ __morestack:\n     mov r0, r4         // The amount of stack needed\n     add r1, fp, #20    // Address of stack arguments\n     mov r2, r5         // Size of stack arguments\n-    \n+\n     // Create new stack\n     bl upcall_new_stack@plt\n \n@@ -64,7 +64,7 @@ __morestack:\n     // Restore return value\n \tmov r0, r4\n \tmov r1, r5\n-\t\n+\n     // Return\n     pop {r6, fp, lr}\n     mov pc, lr"}, {"sha": "95fce8746a118f6ed5a239819c328c6ae91e862c", "filename": "src/rt/arch/arm/record_sp.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Frecord_sp.S?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -28,4 +28,3 @@ get_sp_limit:\n get_sp:\n \tmov r0, sp\n \tmov pc, lr\n-"}, {"sha": "0d1c24e0fb7495a5f09c4067a7fc38d63d94152a", "filename": "src/rt/arch/arm/regs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Farm%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fregs.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -19,5 +19,3 @@\n #   define RUSTRT_ARG1_S r1\n #   define RUSTRT_ARG2_S r2\n #   define RUSTRT_ARG3_S r3\n-\n-"}, {"sha": "e2e4ffe35b4e4eb226a015262b1b0e778415bd18", "filename": "src/rt/arch/i386/_context.S", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.S?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -63,5 +63,3 @@ SWAP_REGISTERS:\n \n     // Return!\n     jmp *48(%eax)\n-\n-"}, {"sha": "e5a59d664b0d02a0f436353c86c8dd2871f3d06e", "filename": "src/rt/arch/i386/gpr.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fgpr.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -20,4 +20,3 @@ void rust_gpr::load() {\n     LOAD(eax); LOAD(ebx); LOAD(ecx); LOAD(edx);\n     LOAD(esi); LOAD(edi); LOAD(ebp); LOAD(esi);\n }\n-"}, {"sha": "1953170301c53df3e5e3633c4fb91d8e44e4bd24", "filename": "src/rt/arch/i386/gpr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fgpr.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -29,4 +29,3 @@ class rust_gpr : public rust_gpr_base {\n };\n \n #endif\n-"}, {"sha": "c1cd11fa432afe56d65a09d346e57ac65da6ab9b", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -97,7 +97,7 @@\n #endif\n .globl MORESTACK\n \n-// FIXME: What about _WIN32?\t\n+// FIXME: What about _WIN32?\n #if defined(__linux__) || defined(__FreeBSD__)\n \t.hidden MORESTACK\n #else\n@@ -253,4 +253,3 @@ L_upcall_del_stack$stub:\n \n \t.subsections_via_symbols\n #endif\n-"}, {"sha": "b48c1d4e732a506c9021316d7b2121c289a8ea7f", "filename": "src/rt/arch/mips/gpr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fmips%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fmips%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fgpr.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -30,4 +30,3 @@ class rust_gpr : public rust_gpr_base {\n };\n \n #endif\n-"}, {"sha": "f718cac963470402a7844e36dfa34f1ff188fc36", "filename": "src/rt/arch/x86_64/_context.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2F_context.S?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -121,4 +121,3 @@ SWAP_REGISTERS:\n         // Jump to the instruction pointer\n         // found in regs:\n         jmp *(RUSTRT_IP*8)(ARG1)\n-"}, {"sha": "37247d1dfdc8b04a3ab550986e1b90ce17b9fc23", "filename": "src/rt/arch/x86_64/gpr.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fgpr.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -22,4 +22,3 @@ void rust_gpr::load() {\n     LOAD(r8);  LOAD(r9);  LOAD(r10); LOAD(r11);\n     LOAD(r12); LOAD(r13); LOAD(r14); LOAD(r15);\n }\n-"}, {"sha": "18ef77dbba63198f0527281472fbe6118fe18a53", "filename": "src/rt/arch/x86_64/gpr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fgpr.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -30,4 +30,3 @@ class rust_gpr : public rust_gpr_base {\n };\n \n #endif\n-"}, {"sha": "1aca452df108b84e7fb0ccb77c54127e5d7c537c", "filename": "src/rt/arch/x86_64/regs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Farch%2Fx86_64%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fregs.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -43,5 +43,3 @@\n #   define RUSTRT_ARG4_S %r8\n #   define RUSTRT_ARG5_S %r9\n #endif\n-\n-"}, {"sha": "a49b52bffe15366be65ad230daea67387d298585", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -27,11 +27,11 @@ rust_opaque_box *boxed_region::malloc(type_desc *td, size_t body_size) {\n     if (live_allocs) live_allocs->prev = box;\n     live_allocs = box;\n \n-    LOG(rust_get_current_task(), box,\n+    /*LOG(rust_get_current_task(), box,\n         \"@malloc()=%p with td %p, size %lu==%lu+%lu, \"\n         \"align %lu, prev %p, next %p\\n\",\n         box, td, total_size, sizeof(rust_opaque_box), body_size,\n-        td->align, box->prev, box->next);\n+        td->align, box->prev, box->next);*/\n \n     return box;\n }\n@@ -50,9 +50,9 @@ rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n     if (new_box->next) new_box->next->prev = new_box;\n     if (live_allocs == box) live_allocs = new_box;\n \n-    LOG(rust_get_current_task(), box,\n+    /*LOG(rust_get_current_task(), box,\n         \"@realloc()=%p with orig=%p, size %lu==%lu+%lu\",\n-        new_box, box, total_size, sizeof(rust_opaque_box), new_size);\n+        new_box, box, total_size, sizeof(rust_opaque_box), new_size);*/\n \n     return new_box;\n }\n@@ -74,15 +74,15 @@ void boxed_region::free(rust_opaque_box *box) {\n     // double frees (kind of).\n     assert(box->td != NULL);\n \n-    LOG(rust_get_current_task(), box,\n+    /*LOG(rust_get_current_task(), box,\n         \"@free(%p) with td %p, prev %p, next %p\\n\",\n-        box, box->td, box->prev, box->next);\n+        box, box->td, box->prev, box->next);*/\n \n     if (box->prev) box->prev->next = box->next;\n     if (box->next) box->next->prev = box->prev;\n     if (live_allocs == box) live_allocs = box->next;\n \n-    if (env->poison_on_free) {\n+    if (poison_on_free) {\n         memset(box_body(box), 0xab, box->td->size);\n     }\n "}, {"sha": "178772007e51842adabc67d9a307baeecb435ecc", "filename": "src/rt/boxed_region.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fboxed_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fboxed_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -24,7 +24,7 @@ struct rust_env;\n  * a type descr which describes the payload (what follows the header). */\n class boxed_region {\n private:\n-    rust_env *env;\n+    bool poison_on_free;\n     memory_region *backing_region;\n     rust_opaque_box *live_allocs;\n \n@@ -41,8 +41,8 @@ class boxed_region {\n     boxed_region& operator=(const boxed_region& rhs);\n \n public:\n-    boxed_region(rust_env *e, memory_region *br)\n-        : env(e)\n+    boxed_region(memory_region *br, bool poison_on_free)\n+        : poison_on_free(poison_on_free)\n         , backing_region(br)\n         , live_allocs(NULL)\n     {}"}, {"sha": "c28b35e688d5a11be71eb7099e98121236a84609", "filename": "src/rt/isaac/rand.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fisaac%2Frand.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fisaac%2Frand.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Frand.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17", "patch": "@@ -52,5 +52,3 @@ void isaac(randctx *r);\n      (r)->randrsl[(r)->randcnt])\n \n #endif  /* RAND */\n-\n-"}, {"sha": "f3406712cb01251682fc8331f4122a54f10d4328", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "4ad57c11809ccc67ece729980b2d23bc46258ad0", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "fd1b7860b29a423ce08149853e51e33962fe859a", "filename": "src/rt/rust_abi.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_abi.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_abi.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_abi.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "4179bf751579f35a01d67b13585c8fb164fddd23", "filename": "src/rt/rust_abi.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_abi.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_abi.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_abi.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "b6fe78288e97aae07f651bb0fcfa3cf186cab3c0", "filename": "src/rt/rust_android_dummy.cpp", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_android_dummy.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_android_dummy.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_android_dummy.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "d2329a46c831a908c343c40aeedddbdb7be8a478", "filename": "src/rt/rust_android_dummy.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_android_dummy.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_android_dummy.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_android_dummy.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "a491379153e1a227a67a20cc39fabc3f3543b416", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "f403b0434b649c01dd2fa49fab9c4e569fb2ce2d", "filename": "src/rt/rust_debug.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_debug.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_debug.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_debug.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "7f025bb908e2ae39e611104e3ab73cfbe34a6225", "filename": "src/rt/rust_debug.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_debug.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_debug.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_debug.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "7ec2dda9cd40cf12eeb481dd468e25da1ed314b5", "filename": "src/rt/rust_gpr_base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_gpr_base.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_gpr_base.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gpr_base.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "0ba760786914006dc1f58c5660a52c9e18bec374", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 16, "deletions": 184, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "2911b970b1359ceea5abf246c344754e9abd9903", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "23e705357685d6841bf3bd6cfedf7f8ebd47cb41", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "b76a177e1c87aefb0e4fbc992c1dd6c474bf30db", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}, {"sha": "d82c39d6838ec7f866757d96e24a2034697a34f4", "filename": "src/rt/rust_test_helpers.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_test_helpers.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4300d4d2fa9d35ac73742c7d815ee157ce0f9c17/src%2Frt%2Frust_test_helpers.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.cpp?ref=4300d4d2fa9d35ac73742c7d815ee157ce0f9c17"}]}