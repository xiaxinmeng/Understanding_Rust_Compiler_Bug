{"sha": "109a6bc86c110751118307b969616319d8ed795b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOWE2YmM4NmMxMTA3NTExMTgzMDdiOTY5NjE2MzE5ZDhlZDc5NWI=", "commit": {"author": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T09:09:00Z"}, "committer": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T09:26:03Z"}, "message": "Fix PEP8 for htmldocck", "tree": {"sha": "9eb939ce04cb2583f9b35025fc6defca7d71c026", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eb939ce04cb2583f9b35025fc6defca7d71c026"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/109a6bc86c110751118307b969616319d8ed795b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/109a6bc86c110751118307b969616319d8ed795b", "html_url": "https://github.com/rust-lang/rust/commit/109a6bc86c110751118307b969616319d8ed795b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/109a6bc86c110751118307b969616319d8ed795b/comments", "author": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb2871bfba427654d70592f0f4fa0d1806a3fa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb2871bfba427654d70592f0f4fa0d1806a3fa0", "html_url": "https://github.com/rust-lang/rust/commit/bbb2871bfba427654d70592f0f4fa0d1806a3fa0"}], "stats": {"total": 60, "additions": 45, "deletions": 15}, "files": [{"sha": "22792ff76355149b4ee8eb006fba37618b094caf", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/109a6bc86c110751118307b969616319d8ed795b/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/109a6bc86c110751118307b969616319d8ed795b/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=109a6bc86c110751118307b969616319d8ed795b", "patch": "@@ -118,40 +118,54 @@\n VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n                      'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'])\n \n-# simplified HTML parser.\n-# this is possible because we are dealing with very regular HTML from rustdoc;\n-# we only have to deal with i) void elements and ii) empty attributes.\n+\n class CustomHTMLParser(HTMLParser):\n+    \"\"\"simplified HTML parser.\n+\n+    this is possible because we are dealing with very regular HTML from\n+    rustdoc; we only have to deal with i) void elements and ii) empty\n+    attributes.\"\"\"\n     def __init__(self, target=None):\n         HTMLParser.__init__(self)\n         self.__builder = target or ET.TreeBuilder()\n+\n     def handle_starttag(self, tag, attrs):\n         attrs = dict((k, v or '') for k, v in attrs)\n         self.__builder.start(tag, attrs)\n-        if tag in VOID_ELEMENTS: self.__builder.end(tag)\n+        if tag in VOID_ELEMENTS:\n+            self.__builder.end(tag)\n+\n     def handle_endtag(self, tag):\n         self.__builder.end(tag)\n+\n     def handle_startendtag(self, tag, attrs):\n         attrs = dict((k, v or '') for k, v in attrs)\n         self.__builder.start(tag, attrs)\n         self.__builder.end(tag)\n+\n     def handle_data(self, data):\n         self.__builder.data(data)\n+\n     def handle_entityref(self, name):\n         self.__builder.data(entitydefs[name])\n+\n     def handle_charref(self, name):\n         code = int(name[1:], 16) if name.startswith(('x', 'X')) else int(name, 10)\n         self.__builder.data(unichr(code).encode('utf-8'))\n+\n     def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n Command = namedtuple('Command', 'negated cmd args lineno')\n \n-# returns a generator out of the file object, which\n-# - removes `\\\\` then `\\n` then a shared prefix with the previous line then optional whitespace;\n-# - keeps a line number (starting from 0) of the first line being concatenated.\n+\n def concat_multi_lines(f):\n+    \"\"\"returns a generator out of the file object, which\n+    - removes `\\\\` then `\\n` then a shared prefix with the previous line then\n+      optional whitespace;\n+    - keeps a line number (starting from 0) of the first line being\n+      concatenated.\"\"\"\n     lastline = None # set to the last line when the last line has a backslash\n     firstlineno = None\n     catenated = ''\n@@ -162,7 +176,8 @@ def concat_multi_lines(f):\n         if lastline is not None:\n             maxprefix = 0\n             for i in xrange(min(len(line), len(lastline))):\n-                if line[i] != lastline[i]: break\n+                if line[i] != lastline[i]:\n+                    break\n                 maxprefix += 1\n             line = line[maxprefix:].lstrip()\n \n@@ -184,11 +199,14 @@ def concat_multi_lines(f):\n     (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n     (?P<args>.*)$\n ''', re.X)\n+\n+\n def get_commands(template):\n     with open(template, 'rUb') as f:\n         for lineno, line in concat_multi_lines(f):\n             m = LINE_PATTERN.search(line)\n-            if not m: continue\n+            if not m:\n+                continue\n \n             negated = (m.group('negated') == '!')\n             cmd = m.group('cmd')\n@@ -198,17 +216,22 @@ def get_commands(template):\n             args = shlex.split(args)\n             yield Command(negated=negated, cmd=cmd, args=args, lineno=lineno+1)\n \n+\n def _flatten(node, acc):\n-    if node.text: acc.append(node.text)\n+    if node.text:\n+        acc.append(node.text)\n     for e in node:\n         _flatten(e, acc)\n-        if e.tail: acc.append(e.tail)\n+        if e.tail:\n+            acc.append(e.tail)\n+\n \n def flatten(node):\n     acc = []\n     _flatten(node, acc)\n     return ''.join(acc)\n \n+\n def normalize_xpath(path):\n     if path.startswith('//'):\n         return '.' + path # avoid warnings\n@@ -218,6 +241,7 @@ def normalize_xpath(path):\n         raise RuntimeError('Non-absolute XPath is not supported due to \\\n                             the implementation issue.')\n \n+\n class CachedFiles(object):\n     def __init__(self, root):\n         self.root = root\n@@ -267,6 +291,7 @@ def get_tree(self, path):\n                 self.trees[path] = tree\n                 return self.trees[path]\n \n+\n def check_string(data, pat, regexp):\n     if not pat:\n         return True # special case a presence testing\n@@ -277,6 +302,7 @@ def check_string(data, pat, regexp):\n         pat = ' '.join(pat.split())\n         return pat in data\n \n+\n def check_tree_attr(tree, path, attr, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n@@ -287,9 +313,11 @@ def check_tree_attr(tree, path, attr, pat, regexp):\n             continue\n         else:\n             ret = check_string(value, pat, regexp)\n-            if ret: break\n+            if ret:\n+                break\n     return ret\n \n+\n def check_tree_text(tree, path, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n@@ -300,9 +328,11 @@ def check_tree_text(tree, path, pat, regexp):\n             continue\n         else:\n             ret = check_string(value, pat, regexp)\n-            if ret: break\n+            if ret:\n+                break\n     return ret\n \n+\n def check(target, commands):\n     cache = CachedFiles(target)\n     for c in commands:\n@@ -323,7 +353,8 @@ def check(target, commands):\n                     ret = check_tree_attr(cache.get_tree(c.args[0]), pat, attr, c.args[2], regexp)\n                 else: # normalized text\n                     pat = c.args[1]\n-                    if pat.endswith('/text()'): pat = pat[:-7]\n+                    if pat.endswith('/text()'):\n+                        pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n                 raise RuntimeError('Invalid number of @{} arguments \\\n@@ -348,4 +379,3 @@ def check(target, commands):\n         raise SystemExit(1)\n     else:\n         check(sys.argv[1], get_commands(sys.argv[2]))\n-"}]}