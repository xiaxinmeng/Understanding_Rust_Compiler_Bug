{"sha": "3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ODRkNzI3YzNiMjZlOTU5NmVjM2JkNjcxZTJhNzZhODdjZGI1ZmQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-15T17:00:14Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-15T17:04:01Z"}, "message": "Extend analysis-stats a bit\n\nThis adds some tools helpful when debugging nondeterminism in analysis-stats:\n - a `--randomize` option that analyses everything in random order\n - a `-vv` option that prints even more detail\n\nAlso add a debug log if Chalk fuel is exhausted (which would be a source of\nnondeterminism, but didn't happen in my tests).\n\nI found one source of nondeterminism (rust-lang/chalk#331), but there are still\nother cases remaining.", "tree": {"sha": "b0a1561d8dec30fc07bee0cfc2fb93cf6e162c2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0a1561d8dec30fc07bee0cfc2fb93cf6e162c2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "html_url": "https://github.com/rust-lang/rust/commit/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58f4dcf79ecf3b8dcec83d46a27a29340900a0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/58f4dcf79ecf3b8dcec83d46a27a29340900a0ef", "html_url": "https://github.com/rust-lang/rust/commit/58f4dcf79ecf3b8dcec83d46a27a29340900a0ef"}], "stats": {"total": 117, "additions": 103, "deletions": 14}, "files": [{"sha": "f9518758aa2a1dda3bc9700b6b665aef085bc606", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "patch": "@@ -1015,6 +1015,7 @@ name = \"ra_cli\"\n version = \"0.1.0\"\n dependencies = [\n  \"env_logger\",\n+ \"itertools\",\n  \"pico-args\",\n  \"ra_batch\",\n  \"ra_db\",\n@@ -1024,6 +1025,7 @@ dependencies = [\n  \"ra_ide\",\n  \"ra_prof\",\n  \"ra_syntax\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]"}, {"sha": "c034e24244e0bab26c76b40c6280a17665c3c739", "filename": "Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "patch": "@@ -31,3 +31,8 @@ opt-level = 0\n \n [patch.'crates-io']\n # rowan = { path = \"../rowan\" }\n+\n+[patch.'https://github.com/rust-lang/chalk.git']\n+# chalk-solve = { path = \"../chalk/chalk-solve\" }\n+# chalk-rust-ir = { path = \"../chalk/chalk-rust-ir\" }\n+# chalk-ir = { path = \"../chalk/chalk-ir\" }"}, {"sha": "53d4876f643c0d826d5266fe3d731b6c09886afd", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "patch": "@@ -6,8 +6,10 @@ authors = [\"rust-analyzer developers\"]\n publish = false\n \n [dependencies]\n+itertools = \"0.8.0\"\n pico-args = \"0.3.0\"\n env_logger = { version = \"0.7.1\", default-features = false }\n+rand = { version = \"0.7.0\", features = [\"small_rng\"] }\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide = { path = \"../ra_ide\" }"}, {"sha": "6d2dd34c64829c1b612b47517d0c8f7d851e34bf", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "patch": "@@ -2,6 +2,9 @@\n \n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n+use itertools::Itertools;\n+use rand::{seq::SliceRandom, thread_rng};\n+\n use hir::{\n     db::{DefDatabase, HirDatabase},\n     AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n@@ -19,6 +22,7 @@ pub fn run(\n     path: &Path,\n     only: Option<&str>,\n     with_deps: bool,\n+    randomize: bool,\n ) -> Result<()> {\n     let db_load_time = Instant::now();\n     let (mut host, roots) = ra_batch::load_cargo(path)?;\n@@ -41,7 +45,11 @@ pub fn run(\n             })\n             .collect::<HashSet<_>>();\n \n-    for krate in Crate::all(db) {\n+    let mut krates = Crate::all(db);\n+    if randomize {\n+        krates.shuffle(&mut thread_rng());\n+    }\n+    for krate in krates {\n         let module = krate.root_module(db).expect(\"crate without root module\");\n         let file_id = module.definition_source(db).file_id;\n         if members.contains(&db.file_source_root(file_id.original_file(db))) {\n@@ -50,6 +58,10 @@ pub fn run(\n         }\n     }\n \n+    if randomize {\n+        visit_queue.shuffle(&mut thread_rng());\n+    }\n+\n     println!(\"Crates in this dir: {}\", num_crates);\n     let mut num_decls = 0;\n     let mut funcs = Vec::new();\n@@ -79,10 +91,14 @@ pub fn run(\n     println!(\"Total functions: {}\", funcs.len());\n     println!(\"Item Collection: {:?}, {}\", analysis_time.elapsed(), ra_prof::memory_usage());\n \n+    if randomize {\n+        funcs.shuffle(&mut thread_rng());\n+    }\n+\n     let inference_time = Instant::now();\n     let mut bar = match verbosity {\n-        Verbosity::Verbose | Verbosity::Normal => ProgressReport::new(funcs.len() as u64),\n-        Verbosity::Quiet => ProgressReport::hidden(),\n+        Verbosity::Quiet | Verbosity::Spammy => ProgressReport::hidden(),\n+        _ => ProgressReport::new(funcs.len() as u64),\n     };\n \n     bar.tick();\n@@ -92,23 +108,36 @@ pub fn run(\n     let mut num_type_mismatches = 0;\n     for f in funcs {\n         let name = f.name(db);\n-        let mut msg = format!(\"processing: {}\", name);\n+        let full_name = f\n+            .module(db)\n+            .path_to_root(db)\n+            .into_iter()\n+            .rev()\n+            .filter_map(|it| it.name(db))\n+            .chain(Some(f.name(db)))\n+            .join(\"::\");\n+        if let Some(only_name) = only {\n+            if name.to_string() != only_name && full_name != only_name {\n+                continue;\n+            }\n+        }\n+        let mut msg = format!(\"processing: {}\", full_name);\n         if verbosity.is_verbose() {\n             let src = f.source(db);\n             let original_file = src.file_id.original_file(db);\n             let path = db.file_relative_path(original_file);\n             let syntax_range = src.value.syntax().text_range();\n             write!(msg, \" ({:?} {})\", path, syntax_range).unwrap();\n         }\n-        bar.set_message(&msg);\n-        if let Some(only_name) = only {\n-            if name.to_string() != only_name {\n-                continue;\n-            }\n+        if verbosity.is_spammy() {\n+            bar.println(format!(\"{}\", msg));\n         }\n+        bar.set_message(&msg);\n         let f_id = FunctionId::from(f);\n         let body = db.body(f_id.into());\n         let inference_result = db.infer(f_id.into());\n+        let (previous_exprs, previous_unknown, previous_partially_unknown) =\n+            (num_exprs, num_exprs_unknown, num_exprs_partially_unknown);\n         for (expr_id, _) in body.exprs.iter() {\n             let ty = &inference_result[expr_id];\n             num_exprs += 1;\n@@ -125,6 +154,33 @@ pub fn run(\n                     num_exprs_partially_unknown += 1;\n                 }\n             }\n+            if only.is_some() && verbosity.is_spammy() {\n+                // in super-verbose mode for just one function, we print every single expression\n+                let (_, sm) = db.body_with_source_map(f_id.into());\n+                let src = sm.expr_syntax(expr_id);\n+                if let Some(src) = src {\n+                    let original_file = src.file_id.original_file(db);\n+                    let line_index = host.analysis().file_line_index(original_file).unwrap();\n+                    let text_range = src.value.either(\n+                        |it| it.syntax_node_ptr().range(),\n+                        |it| it.syntax_node_ptr().range(),\n+                    );\n+                    let (start, end) = (\n+                        line_index.line_col(text_range.start()),\n+                        line_index.line_col(text_range.end()),\n+                    );\n+                    bar.println(format!(\n+                        \"{}:{}-{}:{}: {}\",\n+                        start.line + 1,\n+                        start.col_utf16,\n+                        end.line + 1,\n+                        end.col_utf16,\n+                        ty.display(db)\n+                    ));\n+                } else {\n+                    bar.println(format!(\"unknown location: {}\", ty.display(db)));\n+                }\n+            }\n             if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n                 num_type_mismatches += 1;\n                 if verbosity.is_verbose() {\n@@ -164,6 +220,15 @@ pub fn run(\n                 }\n             }\n         }\n+        if verbosity.is_spammy() {\n+            bar.println(format!(\n+                \"In {}: {} exprs, {} unknown, {} partial\",\n+                full_name,\n+                num_exprs - previous_exprs,\n+                num_exprs_unknown - previous_unknown,\n+                num_exprs_partially_unknown - previous_partially_unknown\n+            ));\n+        }\n         bar.inc(1);\n     }\n     bar.finish_and_clear();"}, {"sha": "6a0e447b96786bb379788353103bcaeccdc569ba", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "patch": "@@ -16,6 +16,7 @@ type Result<T> = std::result::Result<T, Box<dyn Error + Send + Sync>>;\n \n #[derive(Clone, Copy)]\n pub enum Verbosity {\n+    Spammy,\n     Verbose,\n     Normal,\n     Quiet,\n@@ -24,7 +25,13 @@ pub enum Verbosity {\n impl Verbosity {\n     fn is_verbose(self) -> bool {\n         match self {\n-            Verbosity::Verbose => true,\n+            Verbosity::Verbose | Verbosity::Spammy => true,\n+            _ => false,\n+        }\n+    }\n+    fn is_spammy(self) -> bool {\n+        match self {\n+            Verbosity::Spammy => true,\n             _ => false,\n         }\n     }\n@@ -86,14 +93,18 @@ fn main() -> Result<()> {\n                 return Ok(());\n             }\n             let verbosity = match (\n+                matches.contains([\"-vv\", \"--spammy\"]),\n                 matches.contains([\"-v\", \"--verbose\"]),\n                 matches.contains([\"-q\", \"--quiet\"]),\n             ) {\n-                (false, false) => Verbosity::Normal,\n-                (false, true) => Verbosity::Quiet,\n-                (true, false) => Verbosity::Verbose,\n-                (true, true) => Err(\"Invalid flags: -q conflicts with -v\")?,\n+                (true, _, true) => Err(\"Invalid flags: -q conflicts with -vv\")?,\n+                (true, _, false) => Verbosity::Spammy,\n+                (false, false, false) => Verbosity::Normal,\n+                (false, false, true) => Verbosity::Quiet,\n+                (false, true, false) => Verbosity::Verbose,\n+                (false, true, true) => Err(\"Invalid flags: -q conflicts with -v\")?,\n             };\n+            let randomize = matches.contains(\"--randomize\");\n             let memory_usage = matches.contains(\"--memory-usage\");\n             let only: Option<String> = matches.opt_value_from_str([\"-o\", \"--only\"])?;\n             let with_deps: bool = matches.contains(\"--with-deps\");\n@@ -111,6 +122,7 @@ fn main() -> Result<()> {\n                 path.as_ref(),\n                 only.as_ref().map(String::as_ref),\n                 with_deps,\n+                randomize,\n             )?;\n         }\n         \"analysis-bench\" => {"}, {"sha": "ff8e75b48eecd626bb60e1f493a8c2aa91940a8b", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3484d727c3b26e9596ec3bd671e2a76a87cdb5fd/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=3484d727c3b26e9596ec3bd671e2a76a87cdb5fd", "patch": "@@ -60,6 +60,9 @@ impl TraitSolver {\n                     context.0.db.check_canceled();\n                     let remaining = fuel.get();\n                     fuel.set(remaining - 1);\n+                    if remaining == 0 {\n+                        log::debug!(\"fuel exhausted\");\n+                    }\n                     remaining > 0\n                 })\n             }"}]}