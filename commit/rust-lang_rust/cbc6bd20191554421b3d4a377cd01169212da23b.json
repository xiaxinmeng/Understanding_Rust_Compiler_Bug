{"sha": "cbc6bd20191554421b3d4a377cd01169212da23b", "node_id": "C_kwDOAAsO6NoAKGNiYzZiZDIwMTkxNTU0NDIxYjNkNGEzNzdjZDAxMTY5MjEyZGEyM2I", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-08-24T01:42:12Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-08-24T01:42:12Z"}, "message": "add `depth_limit` in `QueryVTable`", "tree": {"sha": "0b44511f0603949c71e9471475b8c6283092e958", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b44511f0603949c71e9471475b8c6283092e958"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbc6bd20191554421b3d4a377cd01169212da23b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6bd20191554421b3d4a377cd01169212da23b", "html_url": "https://github.com/rust-lang/rust/commit/cbc6bd20191554421b3d4a377cd01169212da23b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6bd20191554421b3d4a377cd01169212da23b/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87991d5f5d72d6baca490141cb890211ba2f3843", "url": "https://api.github.com/repos/rust-lang/rust/commits/87991d5f5d72d6baca490141cb890211ba2f3843", "html_url": "https://github.com/rust-lang/rust/commit/87991d5f5d72d6baca490141cb890211ba2f3843"}], "stats": {"total": 137, "additions": 83, "deletions": 54}, "files": [{"sha": "6f27144910f807e1c43ff0d621b37d31b5031dc9", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -106,9 +106,12 @@ struct QueryModifiers {\n     /// Generate a dep node based on the dependencies of the query\n     anon: Option<Ident>,\n \n-    // Always evaluate the query, ignoring its dependencies\n+    /// Always evaluate the query, ignoring its dependencies\n     eval_always: Option<Ident>,\n \n+    /// Whether the query has a call depth limit\n+    depth_limit: Option<Ident>,\n+\n     /// Use a separate query provider for local and extern crates\n     separate_provide_extern: Option<Ident>,\n \n@@ -126,6 +129,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut no_hash = None;\n     let mut anon = None;\n     let mut eval_always = None;\n+    let mut depth_limit = None;\n     let mut separate_provide_extern = None;\n     let mut remap_env_constness = None;\n \n@@ -194,6 +198,8 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             try_insert!(anon = modifier);\n         } else if modifier == \"eval_always\" {\n             try_insert!(eval_always = modifier);\n+        } else if modifier == \"depth_limit\" {\n+            try_insert!(depth_limit = modifier);\n         } else if modifier == \"separate_provide_extern\" {\n             try_insert!(separate_provide_extern = modifier);\n         } else if modifier == \"remap_env_constness\" {\n@@ -215,6 +221,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n         no_hash,\n         anon,\n         eval_always,\n+        depth_limit,\n         separate_provide_extern,\n         remap_env_constness,\n     })\n@@ -365,6 +372,10 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         if let Some(eval_always) = &modifiers.eval_always {\n             attributes.push(quote! { (#eval_always) });\n         };\n+        // Pass on the depth_limit modifier\n+        if let Some(depth_limit) = &modifiers.depth_limit {\n+            attributes.push(quote! { (#depth_limit) });\n+        };\n         // Pass on the separate_provide_extern modifier\n         if let Some(separate_provide_extern) = &modifiers.separate_provide_extern {\n             attributes.push(quote! { (#separate_provide_extern) });"}, {"sha": "fc87c1ddae9e6ed43435fdf9e4169e209249f67b", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -1309,6 +1309,7 @@ rustc_queries! {\n     query layout_of(\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n     ) -> Result<ty::layout::TyAndLayout<'tcx>, ty::layout::LayoutError<'tcx>> {\n+        depth_limit\n         desc { \"computing layout of `{}`\", key.value }\n         remap_env_constness\n     }"}, {"sha": "0f34aa10a1257f03f53f349faf70e45e15ecd1e8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -1857,8 +1857,8 @@ pub mod tls {\n         /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n         pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n \n-        /// Used to prevent layout from recursing too deeply.\n-        pub layout_depth: usize,\n+        /// Used to prevent queries from calling too deeply.\n+        pub query_depth: usize,\n \n         /// The current dep graph task. This is used to add dependencies to queries\n         /// when executing them.\n@@ -1872,7 +1872,7 @@ pub mod tls {\n                 tcx,\n                 query: None,\n                 diagnostics: None,\n-                layout_depth: 0,\n+                query_depth: 0,\n                 task_deps: TaskDepsRef::Ignore,\n             }\n         }"}, {"sha": "384f17b3cdf35fc866830be9dcbb43dd5cb44d02", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -229,49 +229,38 @@ fn layout_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Result<TyAndLayout<'tcx>, LayoutError<'tcx>> {\n-    ty::tls::with_related_context(tcx, move |icx| {\n-        let (param_env, ty) = query.into_parts();\n-        debug!(?ty);\n-\n-        if !tcx.recursion_limit().value_within_limit(icx.layout_depth) {\n-            tcx.sess.fatal(&format!(\"overflow representing the type `{}`\", ty));\n+    let (param_env, ty) = query.into_parts();\n+    debug!(?ty);\n+\n+    let param_env = param_env.with_reveal_all_normalized(tcx);\n+    let unnormalized_ty = ty;\n+\n+    // FIXME: We might want to have two different versions of `layout_of`:\n+    // One that can be called after typecheck has completed and can use\n+    // `normalize_erasing_regions` here and another one that can be called\n+    // before typecheck has completed and uses `try_normalize_erasing_regions`.\n+    let ty = match tcx.try_normalize_erasing_regions(param_env, ty) {\n+        Ok(t) => t,\n+        Err(normalization_error) => {\n+            return Err(LayoutError::NormalizationFailure(ty, normalization_error));\n         }\n+    };\n \n-        // Update the ImplicitCtxt to increase the layout_depth\n-        let icx = ty::tls::ImplicitCtxt { layout_depth: icx.layout_depth + 1, ..icx.clone() };\n-\n-        ty::tls::enter_context(&icx, |_| {\n-            let param_env = param_env.with_reveal_all_normalized(tcx);\n-            let unnormalized_ty = ty;\n-\n-            // FIXME: We might want to have two different versions of `layout_of`:\n-            // One that can be called after typecheck has completed and can use\n-            // `normalize_erasing_regions` here and another one that can be called\n-            // before typecheck has completed and uses `try_normalize_erasing_regions`.\n-            let ty = match tcx.try_normalize_erasing_regions(param_env, ty) {\n-                Ok(t) => t,\n-                Err(normalization_error) => {\n-                    return Err(LayoutError::NormalizationFailure(ty, normalization_error));\n-                }\n-            };\n-\n-            if ty != unnormalized_ty {\n-                // Ensure this layout is also cached for the normalized type.\n-                return tcx.layout_of(param_env.and(ty));\n-            }\n+    if ty != unnormalized_ty {\n+        // Ensure this layout is also cached for the normalized type.\n+        return tcx.layout_of(param_env.and(ty));\n+    }\n \n-            let cx = LayoutCx { tcx, param_env };\n+    let cx = LayoutCx { tcx, param_env };\n \n-            let layout = cx.layout_of_uncached(ty)?;\n-            let layout = TyAndLayout { ty, layout };\n+    let layout = cx.layout_of_uncached(ty)?;\n+    let layout = TyAndLayout { ty, layout };\n \n-            cx.record_layout_for_printing(layout);\n+    cx.record_layout_for_printing(layout);\n \n-            sanity_check_layout(&cx, &layout);\n+    sanity_check_layout(&cx, &layout);\n \n-            Ok(layout)\n-        })\n-    })\n+    Ok(layout)\n }\n \n pub struct LayoutCx<'tcx, C> {"}, {"sha": "ecabe74218b94764f8cfc08fcf3fe7682db24f97", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -91,19 +91,24 @@ impl QueryContext for QueryCtxt<'_> {\n     fn start_query<R>(\n         &self,\n         token: QueryJobId,\n+        depth_limit: bool,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: impl FnOnce() -> R,\n     ) -> R {\n         // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n         // when accessing the `ImplicitCtxt`.\n         tls::with_related_context(**self, move |current_icx| {\n+            if depth_limit && !self.recursion_limit().value_within_limit(current_icx.query_depth) {\n+                self.depth_limit_error();\n+            }\n+\n             // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = ImplicitCtxt {\n                 tcx: **self,\n                 query: Some(token),\n                 diagnostics,\n-                layout_depth: current_icx.layout_depth,\n+                query_depth: current_icx.query_depth + depth_limit as usize,\n                 task_deps: current_icx.task_deps,\n             };\n \n@@ -205,6 +210,18 @@ macro_rules! is_eval_always {\n     };\n }\n \n+macro_rules! depth_limit {\n+    ([]) => {{\n+        false\n+    }};\n+    ([(depth_limit) $($rest:tt)*]) => {{\n+        true\n+    }};\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        depth_limit!([$($modifiers)*])\n+    };\n+}\n+\n macro_rules! hash_result {\n     ([]) => {{\n         Some(dep_graph::hash_result)\n@@ -335,6 +352,7 @@ macro_rules! define_queries {\n                 QueryVTable {\n                     anon: is_anon!([$($modifiers)*]),\n                     eval_always: is_eval_always!([$($modifiers)*]),\n+                    depth_limit: depth_limit!([$($modifiers)*]),\n                     dep_kind: dep_graph::DepKind::$name,\n                     hash_result: hash_result!([$($modifiers)*]),\n                     handle_cycle_error: |tcx, mut error| handle_cycle_error!([$($modifiers)*][tcx, error]),"}, {"sha": "bd0fd7ac3503a16ede69e8faa1f30a5f8140916d", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -23,6 +23,7 @@ pub struct QueryVTable<CTX: QueryContext, K, V> {\n     pub anon: bool,\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n+    pub depth_limit: bool,\n     pub cache_on_disk: bool,\n \n     pub compute: fn(CTX::DepContext, K) -> V,"}, {"sha": "a1f2b081d43465f2515b88aead23859b8e53fd73", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -14,7 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryConfig, QueryDescription, QueryVTable};\n \n-use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepContext, DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n \n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -119,7 +119,12 @@ pub trait QueryContext: HasDepContext {\n     fn start_query<R>(\n         &self,\n         token: QueryJobId,\n+        depth_limit: bool,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: impl FnOnce() -> R,\n     ) -> R;\n+\n+    fn depth_limit_error(&self) {\n+        self.dep_context().sess().fatal(\"queries overflow the depth limit!\");\n+    }\n }"}, {"sha": "6ae9147ff774fe1dfffb920e425cc08eddb1a125", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6bd20191554421b3d4a377cd01169212da23b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=cbc6bd20191554421b3d4a377cd01169212da23b", "patch": "@@ -381,7 +381,9 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job_id, None, || query.compute(*tcx.dep_context(), key));\n+        let result = tcx.start_query(job_id, query.depth_limit, None, || {\n+            query.compute(*tcx.dep_context(), key)\n+        });\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n@@ -394,7 +396,7 @@ where\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        if let Some(ret) = tcx.start_query(job_id, None, || {\n+        if let Some(ret) = tcx.start_query(job_id, false, None, || {\n             try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query)\n         }) {\n             return ret;\n@@ -404,18 +406,20 @@ where\n     let prof_timer = tcx.dep_context().profiler().query_provider();\n     let diagnostics = Lock::new(ThinVec::new());\n \n-    let (result, dep_node_index) = tcx.start_query(job_id, Some(&diagnostics), || {\n-        if query.anon {\n-            return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                query.compute(*tcx.dep_context(), key)\n-            });\n-        }\n+    let (result, dep_node_index) =\n+        tcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n+            if query.anon {\n+                return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n+                    query.compute(*tcx.dep_context(), key)\n+                });\n+            }\n \n-        // `to_dep_node` is expensive for some `DepKind`s.\n-        let dep_node = dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n+            // `to_dep_node` is expensive for some `DepKind`s.\n+            let dep_node =\n+                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n \n-        dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n-    });\n+            dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n+        });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n "}]}