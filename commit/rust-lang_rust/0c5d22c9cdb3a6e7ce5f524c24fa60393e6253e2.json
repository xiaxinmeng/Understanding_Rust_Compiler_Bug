{"sha": "0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNWQyMmM5Y2RiM2E2ZTdjZTVmNTI0YzI0ZmE2MDM5M2U2MjUzZTI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-09T17:48:52Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:04:41Z"}, "message": "librustc_trans: use tuple indexing", "tree": {"sha": "683bccfd37ded31fe3ab996dc4bf86705849e93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/683bccfd37ded31fe3ab996dc4bf86705849e93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2", "html_url": "https://github.com/rust-lang/rust/commit/0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2/comments", "author": null, "committer": null, "parents": [{"sha": "821b836634d7f86a867c0e642abbd15c3064b36d", "url": "https://api.github.com/repos/rust-lang/rust/commits/821b836634d7f86a867c0e642abbd15c3064b36d", "html_url": "https://github.com/rust-lang/rust/commit/821b836634d7f86a867c0e642abbd15c3064b36d"}], "stats": {"total": 14, "additions": 7, "deletions": 7}, "files": [{"sha": "e4f0543b5e70fccd12ebb21f49e0de48209c7006", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=0c5d22c9cdb3a6e7ce5f524c24fa60393e6253e2", "patch": "@@ -91,7 +91,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let vs = es.iter().map(|e| const_expr(cx, &**e).val0())\n+    let vs = es.iter().map(|e| const_expr(cx, &**e).0)\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n@@ -302,7 +302,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e).val0())\n+        exprs.iter().map(|e| const_expr(cx, &**e).0)\n              .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };\n     unsafe {\n@@ -575,7 +575,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr).val0(),\n+                          Some(ref f) => const_expr(cx, &*f.expr).0,\n                           None => {\n                               match base_val {\n                                   Some((bv, _)) => {\n@@ -594,7 +594,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            const_vec(cx, e, es.as_slice()).val0()\n+            const_vec(cx, e, es.as_slice()).0\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n@@ -605,7 +605,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem).val0());\n+            let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs.as_slice(), false)\n             } else {\n@@ -673,10 +673,10 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e).val0(),\n+          ast::ExprParen(ref e) => const_expr(cx, &**e).0,\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr).val0(),\n+                Some(ref expr) => const_expr(cx, &**expr).0,\n                 None => C_nil(cx)\n             }\n           }"}]}