{"sha": "b9585fda7bc32db3b129aa7ec43322ae0f089635", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NTg1ZmRhN2JjMzJkYjNiMTI5YWE3ZWM0MzMyMmFlMGYwODk2MzU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-08-10T23:42:57Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-08-11T18:06:21Z"}, "message": "When suggesting `for` lts, consider existing lifetime names\n\nFix #72404.", "tree": {"sha": "05793684ef298a3563324c345d9352b4e0ebd1b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05793684ef298a3563324c345d9352b4e0ebd1b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9585fda7bc32db3b129aa7ec43322ae0f089635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9585fda7bc32db3b129aa7ec43322ae0f089635", "html_url": "https://github.com/rust-lang/rust/commit/b9585fda7bc32db3b129aa7ec43322ae0f089635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9585fda7bc32db3b129aa7ec43322ae0f089635/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7956b1cef71ef633fb0e5e55451c5bb9ee9c59e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7956b1cef71ef633fb0e5e55451c5bb9ee9c59e2", "html_url": "https://github.com/rust-lang/rust/commit/7956b1cef71ef633fb0e5e55451c5bb9ee9c59e2"}], "stats": {"total": 192, "additions": 172, "deletions": 20}, "files": [{"sha": "5b8d8dd06356f670aecdd1c1794fdb07efe8cfa2", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 62, "deletions": 13, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=b9585fda7bc32db3b129aa7ec43322ae0f089635", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use log::debug;\n@@ -1244,7 +1244,8 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         count: usize,\n-        lifetime_names: &FxHashSet<Ident>,\n+        lifetime_names: &FxHashSet<Symbol>,\n+        lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n@@ -1258,11 +1259,60 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             ),\n         );\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n+                                name: &str,\n+                                formatter: &dyn Fn(&str) -> String| {\n+            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                self.missing_named_lifetime_spots.iter().rev().next()\n+            {\n+                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                let mut introduce_suggestion = vec![];\n+\n+                let a_to_z_repeat_n = |n| {\n+                    (b'a'..=b'z').map(move |c| {\n+                        let mut s = '\\''.to_string();\n+                        s.extend(std::iter::repeat(char::from(c)).take(n));\n+                        s\n+                    })\n+                };\n+\n+                // If all single char lifetime names are present, we wrap around and double the chars.\n+                let lt_name = (1..)\n+                    .flat_map(a_to_z_repeat_n)\n+                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                    .unwrap();\n+                let msg = format!(\n+                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                    span_type.descr(),\n+                    lt_name,\n+                );\n+                err.note(\n+                    \"for more information on higher-ranked polymorphism, visit \\\n+                    https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                );\n+                let for_sugg = span_type.suggestion(&lt_name);\n+                for param in params {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n+                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                        } else if snippet.starts_with(\"&'_ \") {\n+                            introduce_suggestion\n+                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[4..])));\n+                        }\n+                    }\n+                }\n+                introduce_suggestion.push((*for_span, for_sugg.to_string()));\n+                introduce_suggestion.push((span, formatter(&lt_name)));\n+                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+            }\n+\n             err.span_suggestion_verbose(\n                 span,\n                 &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                sugg,\n+                formatter(name),\n                 Applicability::MaybeIncorrect,\n             );\n         };\n@@ -1330,26 +1380,26 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n \n         match (lifetime_names.len(), lifetime_names.iter().next(), snippet.as_deref()) {\n             (1, Some(name), Some(\"&\")) => {\n-                suggest_existing(err, format!(\"&{} \", name));\n+                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n             }\n             (1, Some(name), Some(\"'_\")) => {\n-                suggest_existing(err, name.to_string());\n+                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n             }\n             (1, Some(name), Some(\"\")) => {\n-                suggest_existing(err, format!(\"{}, \", name).repeat(count));\n+                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n             }\n             (1, Some(name), Some(snippet)) if !snippet.ends_with('>') => {\n-                suggest_existing(\n-                    err,\n+                let f = |name: &str| {\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n                         std::iter::repeat(name.to_string())\n                             .take(count)\n                             .collect::<Vec<_>>()\n                             .join(\", \")\n-                    ),\n-                );\n+                    )\n+                };\n+                suggest_existing(err, &name.as_str()[..], &f);\n             }\n             (0, _, Some(\"&\")) if count == 1 => {\n                 suggest_new(err, \"&'a \");\n@@ -1367,8 +1417,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                 }\n             }\n             (n, ..) if n > 1 => {\n-                let spans: Vec<Span> = lifetime_names.iter().map(|lt| lt.span).collect();\n-                err.span_note(spans, \"these named lifetimes are available to use\");\n+                err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n                 if Some(\"\") == snippet.as_deref() {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders."}, {"sha": "e5accc7fde9d5bb1928feb81dfed628bde318f5f", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=b9585fda7bc32db3b129aa7ec43322ae0f089635", "patch": "@@ -2317,6 +2317,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n+        let mut lifetime_spans = vec![];\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2328,7 +2329,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(*name);\n+                            lifetime_names.insert(name.name);\n+                            lifetime_spans.push(name.span);\n                         }\n                     }\n                     late_depth += 1;\n@@ -2346,12 +2348,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n                         Elide::Error(ref e) => {\n-                            if let Scope::Binder { ref lifetimes, .. } = s {\n-                                // collect named lifetimes for suggestions\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(*name);\n+                            let mut scope = s;\n+                            loop {\n+                                match scope {\n+                                    Scope::Binder { ref lifetimes, s, .. } => {\n+                                        // Collect named lifetimes for suggestions.\n+                                        for name in lifetimes.keys() {\n+                                            if let hir::ParamName::Plain(name) = name {\n+                                                lifetime_names.insert(name.name);\n+                                                lifetime_spans.push(name.span);\n+                                            }\n+                                        }\n+                                        scope = s;\n+                                    }\n+                                    Scope::ObjectLifetimeDefault { ref s, .. }\n+                                    | Scope::Elision { ref s, .. } => {\n+                                        scope = s;\n                                     }\n+                                    _ => break,\n                                 }\n                             }\n                             break Some(e);\n@@ -2375,14 +2389,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(Ident::with_dummy_span(kw::StaticLifetime));\n+                lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             span,\n             lifetime_refs.len(),\n             &lifetime_names,\n+            lifetime_spans,\n             error.map(|p| &p[..]).unwrap_or(&[]),\n         );\n         err.emit();"}, {"sha": "6c68cc7bc61aa94e25067b7431d84f80d7326f9e", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr?ref=b9585fda7bc32db3b129aa7ec43322ae0f089635", "patch": "@@ -5,6 +5,11 @@ LL | fn elision<T: Fn() -> &i32>() {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn elision<T: for<'a> Fn() -> &'a i32>() {\n+   |               ^^^^^^^         ^^^\n help: consider using the `'static` lifetime\n    |\n LL | fn elision<T: Fn() -> &'static i32>() {"}, {"sha": "93d2f8e7911f08ceee48ca3eb3291a1b374722d8", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.elision.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr?ref=b9585fda7bc32db3b129aa7ec43322ae0f089635", "patch": "@@ -5,6 +5,11 @@ LL | fn elision(_: fn() -> &i32) {\n    |                       ^ expected named lifetime parameter\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the type lifetime-generic with a new `'a` lifetime\n+   |\n+LL | fn elision(_: for<'a> fn() -> &'a i32) {\n+   |               ^^^^^^^         ^^^\n help: consider using the `'static` lifetime\n    |\n LL | fn elision(_: fn() -> &'static i32) {"}, {"sha": "a90a90122ad19f1cb3f79b8c881f544eaea1e84d", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.rs?ref=b9585fda7bc32db3b129aa7ec43322ae0f089635", "patch": "@@ -0,0 +1,15 @@\n+struct X<'a>(&'a ());\n+struct S<'a>(&'a dyn Fn(&X) -> &X);\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing lifetime specifier\n+struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing lifetime specifier\n+\n+fn main() {\n+    let x = S(&|x| {\n+        println!(\"hi\");\n+        x\n+    });\n+    x.0(&X(&()));\n+}"}, {"sha": "2cb63500e48b919e571026ce0a0c865a307da0cf", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9585fda7bc32db3b129aa7ec43322ae0f089635/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=b9585fda7bc32db3b129aa7ec43322ae0f089635", "patch": "@@ -0,0 +1,63 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:2:32\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n+   |                         --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &'b X);\n+   |                      ^^^^^^^    ^^^^^     ^^^\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &'a X);\n+   |                                ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:2:33\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X);\n+   |                         --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider making the bound lifetime-generic with a new `'b` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn for<'b> Fn(&'b X) -> &X<'b>);\n+   |                      ^^^^^^^    ^^^^^      ^^^^^\n+help: consider using the `'a` lifetime\n+   |\n+LL | struct S<'a>(&'a dyn Fn(&X) -> &X<'a>);\n+   |                                 ^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:5:40\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |                                 --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |          ^^              ^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lt-for-hrtb.rs:5:41\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |                                 --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of argument 1's 2 lifetimes it is borrowed from\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lt-for-hrtb.rs:5:10\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n+   |          ^^              ^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}]}