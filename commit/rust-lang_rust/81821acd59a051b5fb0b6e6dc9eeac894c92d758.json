{"sha": "81821acd59a051b5fb0b6e6dc9eeac894c92d758", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxODIxYWNkNTlhMDUxYjVmYjBiNmU2ZGM5ZWVhYzg5NGM5MmQ3NTg=", "commit": {"author": {"name": "Fabian Zaiser", "email": "fabian.zaiser@gmail.com", "date": "2018-05-27T22:02:38Z"}, "committer": {"name": "Fabian Zaiser", "email": "fabian.zaiser@gmail.com", "date": "2018-06-08T03:29:25Z"}, "message": "Implement lint that checks for unidiomatic `unwrap()` (fixes #1770)\n\nThis checks for things like\n\n    if x.is_some() {\n        x.unwrap()\n    }\n\nwhich should be written using `if let` or `match` instead.\n\nIn the process I moved some logic to determine which variables are\nmutated in an expression to utils/usage.rs.", "tree": {"sha": "e6a7c9fb33bf63acbcce38373f1405442b41e4e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6a7c9fb33bf63acbcce38373f1405442b41e4e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81821acd59a051b5fb0b6e6dc9eeac894c92d758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81821acd59a051b5fb0b6e6dc9eeac894c92d758", "html_url": "https://github.com/rust-lang/rust/commit/81821acd59a051b5fb0b6e6dc9eeac894c92d758", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81821acd59a051b5fb0b6e6dc9eeac894c92d758/comments", "author": {"login": "fanzier", "id": 5846332, "node_id": "MDQ6VXNlcjU4NDYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5846332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fanzier", "html_url": "https://github.com/fanzier", "followers_url": "https://api.github.com/users/fanzier/followers", "following_url": "https://api.github.com/users/fanzier/following{/other_user}", "gists_url": "https://api.github.com/users/fanzier/gists{/gist_id}", "starred_url": "https://api.github.com/users/fanzier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fanzier/subscriptions", "organizations_url": "https://api.github.com/users/fanzier/orgs", "repos_url": "https://api.github.com/users/fanzier/repos", "events_url": "https://api.github.com/users/fanzier/events{/privacy}", "received_events_url": "https://api.github.com/users/fanzier/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fanzier", "id": 5846332, "node_id": "MDQ6VXNlcjU4NDYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5846332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fanzier", "html_url": "https://github.com/fanzier", "followers_url": "https://api.github.com/users/fanzier/followers", "following_url": "https://api.github.com/users/fanzier/following{/other_user}", "gists_url": "https://api.github.com/users/fanzier/gists{/gist_id}", "starred_url": "https://api.github.com/users/fanzier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fanzier/subscriptions", "organizations_url": "https://api.github.com/users/fanzier/orgs", "repos_url": "https://api.github.com/users/fanzier/repos", "events_url": "https://api.github.com/users/fanzier/events{/privacy}", "received_events_url": "https://api.github.com/users/fanzier/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9", "html_url": "https://github.com/rust-lang/rust/commit/d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9"}], "stats": {"total": 626, "additions": 560, "deletions": 66}, "files": [{"sha": "c4dfc1f0168d62dc2b5d50704b2b3c13c0c64350", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -200,6 +200,7 @@ pub mod unicode;\n pub mod unsafe_removed_from_name;\n pub mod unused_io_amount;\n pub mod unused_label;\n+pub mod unwrap;\n pub mod use_self;\n pub mod vec;\n pub mod write;\n@@ -421,6 +422,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box infallible_destructuring_match::Pass);\n     reg.register_late_lint_pass(box inherent_impl::Pass::default());\n     reg.register_late_lint_pass(box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n+    reg.register_late_lint_pass(box unwrap::Pass);\n+\n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -837,6 +840,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         types::UNIT_ARG,\n         types::UNNECESSARY_CAST,\n         unused_label::UNUSED_LABEL,\n+        unwrap::UNNECESSARY_UNWRAP,\n         zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n     ]);\n "}, {"sha": "20b10db0d6643d255cfe64feaad55de1812031f3", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 66, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -18,6 +18,7 @@ use std::iter::{once, Iterator};\n use syntax::ast;\n use syntax::codemap::Span;\n use crate::utils::{sugg, sext};\n+use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n use crate::utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n@@ -504,8 +505,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         // check for while loops which conditions never change\n-        if let ExprWhile(ref cond, ref block, _) = expr.node {\n-            check_infinite_loop(cx, cond, block, expr);\n+        if let ExprWhile(ref cond, _, _) = expr.node {\n+            check_infinite_loop(cx, cond, expr);\n         }\n     }\n \n@@ -2145,35 +2146,30 @@ fn path_name(e: &Expr) -> Option<Name> {\n     None\n }\n \n-fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, block: &'tcx Block, expr: &'tcx Expr) {\n+fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, expr: &'tcx Expr) {\n     if constant(cx, cx.tables, cond).is_some() {\n         // A pure constant condition (e.g. while false) is not linted.\n         return;\n     }\n \n-    let mut mut_var_visitor = VarCollectorVisitor {\n+    let mut var_visitor = VarCollectorVisitor {\n         cx,\n-        ids: HashMap::new(),\n+        ids: HashSet::new(),\n         def_ids: HashMap::new(),\n         skip: false,\n     };\n-    mut_var_visitor.visit_expr(cond);\n-    if mut_var_visitor.skip {\n+    var_visitor.visit_expr(cond);\n+    if var_visitor.skip {\n         return;\n     }\n-\n-    let mut delegate = MutVarsDelegate {\n-        used_mutably: mut_var_visitor.ids,\n-        skip: false,\n+    let used_in_condition = &var_visitor.ids;\n+    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n+        used_in_condition.is_disjoint(&used_mutably)\n+    } else {\n+        return\n     };\n-    let def_id = def_id::DefId::local(block.hir_id.owner);\n-    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n-    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(expr);\n-\n-    if delegate.skip {\n-        return;\n-    }\n-    if !(delegate.used_mutably.iter().any(|(_, v)| *v) || mut_var_visitor.def_ids.iter().any(|(_, v)| *v)) {\n+    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+    if no_cond_variable_mutated && !mutable_static_in_cond {\n         span_lint(\n             cx,\n             WHILE_IMMUTABLE_CONDITION,\n@@ -2189,7 +2185,7 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, b\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ids: HashMap<NodeId, bool>,\n+    ids: HashSet<NodeId>,\n     def_ids: HashMap<def_id::DefId, bool>,\n     skip: bool,\n }\n@@ -2203,7 +2199,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n             then {\n                 match def {\n                     Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                        self.ids.insert(node_id, false);\n+                        self.ids.insert(node_id);\n                     },\n                     Def::Static(def_id, mutable) => {\n                         self.def_ids.insert(def_id, mutable);\n@@ -2230,48 +2226,3 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n-\n-struct MutVarsDelegate {\n-    used_mutably: HashMap<NodeId, bool>,\n-    skip: bool,\n-}\n-\n-impl<'tcx> MutVarsDelegate {\n-    fn update(&mut self, cat: &'tcx Categorization) {\n-        match *cat {\n-            Categorization::Local(id) =>\n-                if let Some(used) = self.used_mutably.get_mut(&id) {\n-                    *used = true;\n-                },\n-            Categorization::Upvar(_) => {\n-                //FIXME: This causes false negatives. We can't get the `NodeId` from\n-                //`Categorization::Upvar(_)`. So we search for any `Upvar`s in the\n-                //`while`-body, not just the ones in the condition.\n-                self.skip = true\n-            },\n-            Categorization::Deref(ref cmt, _) | Categorization::Interior(ref cmt, _) => self.update(&cmt.cat),\n-            _ => {}\n-        }\n-    }\n-}\n-\n-\n-impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n-\n-    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n-\n-    fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n-\n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n-        if let ty::BorrowKind::MutBorrow = bk {\n-            self.update(&cmt.cat)\n-        }\n-    }\n-\n-    fn mutate(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n-        self.update(&cmt.cat)\n-    }\n-\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-}"}, {"sha": "6d209acef395761e69c2723f4e6e0aef9ce9157a", "filename": "clippy_lints/src/unwrap.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -0,0 +1,176 @@\n+use rustc::lint::*;\n+\n+use rustc::hir::intravisit::*;\n+use rustc::hir::*;\n+use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+use crate::utils::{in_macro, match_type, paths, usage::is_potentially_mutated};\n+\n+/// **What it does:** Checks for calls of unwrap[_err]() that cannot fail.\n+///\n+/// **Why is this bad?** Using `if let` or `match` is more idiomatic.\n+///\n+/// **Known problems:** Limitations of the borrow checker might make unwrap() necessary sometimes?\n+///\n+/// **Example:**\n+/// ```rust\n+/// if option.is_some() {\n+///     do_something_with(option.unwrap())\n+/// }\n+/// ```\n+///\n+/// Could be written:\n+///\n+/// ```rust\n+/// if let Some(value) = option {\n+///     do_something_with(value)\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub UNNECESSARY_UNWRAP,\n+    complexity,\n+    \"checks for calls of unwrap[_err]() that cannot fail\"\n+}\n+\n+pub struct Pass;\n+\n+/// Visitor that keeps track of which variables are unwrappable.\n+struct UnwrappableVariablesVisitor<'a, 'tcx: 'a> {\n+    unwrappables: Vec<UnwrapInfo<'tcx>>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+/// Contains information about whether a variable can be unwrapped.\n+#[derive(Copy, Clone, Debug)]\n+struct UnwrapInfo<'tcx> {\n+    /// The variable that is checked\n+    ident: &'tcx Path,\n+    /// The check, like `x.is_ok()`\n+    check: &'tcx Expr,\n+    /// Whether `is_some()` or `is_ok()` was called (as opposed to `is_err()` or `is_none()`).\n+    safe_to_unwrap: bool,\n+}\n+\n+/// Collects the information about unwrappable variables from an if condition\n+/// The `invert` argument tells us whether the condition is negated.\n+fn collect_unwrap_info<'a, 'tcx: 'a>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    invert: bool,\n+) -> Vec<UnwrapInfo<'tcx>> {\n+    if let Expr_::ExprBinary(op, left, right) = &expr.node {\n+        match (invert, op.node) {\n+            (false, BinOp_::BiAnd) | (false, BinOp_::BiBitAnd) | (true, BinOp_::BiOr) | (true, BinOp_::BiBitOr) => {\n+                let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n+                unwrap_info.append(&mut collect_unwrap_info(cx, right, invert));\n+                return unwrap_info;\n+            },\n+            _ => (),\n+        }\n+    } else if let Expr_::ExprUnary(UnNot, expr) = &expr.node {\n+        return collect_unwrap_info(cx, expr, !invert);\n+    } else {\n+        if_chain! {\n+            if let Expr_::ExprMethodCall(method_name, _, args) = &expr.node;\n+            if let Expr_::ExprPath(QPath::Resolved(None, path)) = &args[0].node;\n+            let ty = cx.tables.expr_ty(&args[0]);\n+            if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n+            let name = method_name.name.as_str();\n+            if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n+            then {\n+                assert!(args.len() == 1);\n+                let unwrappable = match name.as_ref() {\n+                    \"is_some\" | \"is_ok\" => true,\n+                    \"is_err\" | \"is_none\" => false,\n+                    _ => unreachable!(),\n+                };\n+                let safe_to_unwrap = unwrappable != invert;\n+                return vec![UnwrapInfo { ident: path, check: expr, safe_to_unwrap }];\n+            }\n+        }\n+    }\n+    Vec::new()\n+}\n+\n+impl<'a, 'tcx: 'a> UnwrappableVariablesVisitor<'a, 'tcx> {\n+    fn visit_branch(&mut self, cond: &'tcx Expr, branch: &'tcx Expr, else_branch: bool) {\n+        let prev_len = self.unwrappables.len();\n+        for unwrap_info in collect_unwrap_info(self.cx, cond, else_branch) {\n+            if is_potentially_mutated(unwrap_info.ident, cond, self.cx)\n+                || is_potentially_mutated(unwrap_info.ident, branch, self.cx)\n+            {\n+                // if the variable is mutated, we don't know whether it can be unwrapped:\n+                continue;\n+            }\n+            self.unwrappables.push(unwrap_info);\n+        }\n+        walk_expr(self, branch);\n+        self.unwrappables.truncate(prev_len);\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let Expr_::ExprIf(cond, then, els) = &expr.node {\n+            walk_expr(self, cond);\n+            self.visit_branch(cond, then, false);\n+            if let Some(els) = els {\n+                self.visit_branch(cond, els, true);\n+            }\n+        } else {\n+            // find `unwrap[_err]()` calls:\n+            if_chain! {\n+                if let Expr_::ExprMethodCall(ref method_name, _, ref args) = expr.node;\n+                if let Expr_::ExprPath(QPath::Resolved(None, ref path)) = args[0].node;\n+                if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.name.as_str());\n+                let call_to_unwrap = method_name.name == \"unwrap\";\n+                if let Some(unwrappable) = self.unwrappables.iter()\n+                    .find(|u| u.ident.def == path.def && call_to_unwrap == u.safe_to_unwrap);\n+                then {\n+                    self.cx.span_lint_note(\n+                        UNNECESSARY_UNWRAP,\n+                        expr.span,\n+                        &format!(\"You checked before that `{}()` cannot fail. \\\n+                        Instead of checking and unwrapping, it's better to use `if let` or `match`.\",\n+                        method_name.name),\n+                        unwrappable.check.span,\n+                        \"the check is happening here\",\n+                    );\n+                }\n+            }\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+    }\n+}\n+\n+impl<'a> LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNNECESSARY_UNWRAP)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        span: Span,\n+        fn_id: NodeId,\n+    ) {\n+        if in_macro(span) {\n+            return;\n+        }\n+\n+        let mut v = UnwrappableVariablesVisitor {\n+            cx,\n+            unwrappables: Vec::new(),\n+        };\n+\n+        walk_fn(&mut v, kind, decl, body.id(), span, fn_id);\n+    }\n+}"}, {"sha": "6c3f0c25a3ec653010e0fce88a47b3fe01894679", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -32,6 +32,7 @@ pub mod inspector;\n pub mod internal_lints;\n pub mod author;\n pub mod ptr;\n+pub mod usage;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;"}, {"sha": "6d75dfb486dc12a7c243f445443a5e9cc43a6d96", "filename": "clippy_lints/src/utils/usage.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -0,0 +1,82 @@\n+use rustc::lint::*;\n+\n+use rustc::hir::def::Def;\n+use rustc::hir::*;\n+use rustc::middle::expr_use_visitor::*;\n+use rustc::middle::mem_categorization::cmt_;\n+use rustc::middle::mem_categorization::Categorization;\n+use rustc::ty;\n+use std::collections::HashSet;\n+use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+\n+/// Returns a set of mutated local variable ids or None if mutations could not be determined.\n+pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<HashSet<NodeId>> {\n+    let mut delegate = MutVarsDelegate {\n+        used_mutably: HashSet::new(),\n+        skip: false,\n+    };\n+    let def_id = def_id::DefId::local(expr.hir_id.owner);\n+    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n+    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(expr);\n+\n+    if delegate.skip {\n+        return None;\n+    }\n+    Some(delegate.used_mutably)\n+}\n+\n+pub fn is_potentially_mutated<'a, 'tcx: 'a>(\n+    variable: &'tcx Path,\n+    expr: &'tcx Expr,\n+    cx: &'a LateContext<'a, 'tcx>,\n+) -> bool {\n+    let id = match variable.def {\n+        Def::Local(id) | Def::Upvar(id, ..) => id,\n+        _ => return true,\n+    };\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n+}\n+\n+struct MutVarsDelegate {\n+    used_mutably: HashSet<NodeId>,\n+    skip: bool,\n+}\n+\n+impl<'tcx> MutVarsDelegate {\n+    fn update(&mut self, cat: &'tcx Categorization) {\n+        match *cat {\n+            Categorization::Local(id) => {\n+                self.used_mutably.insert(id);\n+            },\n+            Categorization::Upvar(_) => {\n+                //FIXME: This causes false negatives. We can't get the `NodeId` from\n+                //`Categorization::Upvar(_)`. So we search for any `Upvar`s in the\n+                //`while`-body, not just the ones in the condition.\n+                self.skip = true\n+            },\n+            Categorization::Deref(ref cmt, _) | Categorization::Interior(ref cmt, _) => self.update(&cmt.cat),\n+            _ => {},\n+        }\n+    }\n+}\n+\n+impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n+    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+\n+    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n+\n+    fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            self.update(&cmt.cat)\n+        }\n+    }\n+\n+    fn mutate(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+        self.update(&cmt.cat)\n+    }\n+\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+}"}, {"sha": "75a5a2a2baa91c08ab7f1f18d90178f29fb3f94e", "filename": "tests/ui/checked_unwrap.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/tests%2Fui%2Fchecked_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/tests%2Fui%2Fchecked_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap.rs?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -0,0 +1,73 @@\n+fn main() {\n+    let x = Some(());\n+    if x.is_some() {\n+        x.unwrap();\n+    }\n+    if x.is_none() {\n+        // nothing to do here\n+    } else {\n+        x.unwrap();\n+    }\n+    let mut x: Result<(), ()> = Ok(());\n+    if x.is_ok() {\n+        x.unwrap();\n+    } else {\n+        x.unwrap_err();\n+    }\n+    if x.is_err() {\n+        x.unwrap_err();\n+    } else {\n+        x.unwrap();\n+    }\n+    if x.is_ok() {\n+        x = Err(());\n+        x.unwrap();\n+    } else {\n+        x = Ok(());\n+        x.unwrap_err();\n+    }\n+}\n+\n+fn test_complex_conditions() {\n+    let x: Result<(), ()> = Ok(());\n+    let y: Result<(), ()> = Ok(());\n+    if x.is_ok() && y.is_err() {\n+        x.unwrap();\n+        y.unwrap_err();\n+    } else {\n+        // not clear whether unwrappable:\n+        x.unwrap_err();\n+        y.unwrap();\n+    }\n+\n+    if x.is_ok() || y.is_ok() {\n+        // not clear whether unwrappable:\n+        x.unwrap();\n+        y.unwrap();\n+    } else {\n+        x.unwrap_err();\n+        y.unwrap_err();\n+    }\n+    let z: Result<(), ()> = Ok(());\n+    if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+        x.unwrap();\n+        y.unwrap_err();\n+        z.unwrap();\n+    }\n+    if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+        // not clear what's unwrappable\n+    } else {\n+        x.unwrap_err();\n+        y.unwrap();\n+        z.unwrap_err();\n+    }\n+}\n+\n+fn test_nested() {\n+    fn nested() {\n+        let x = Some(());\n+        if x.is_some() {\n+            x.unwrap();\n+        }\n+    }\n+}"}, {"sha": "337950f2e6618538c8a6cf9f0e2601559d445406", "filename": "tests/ui/checked_unwrap.stderr", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/81821acd59a051b5fb0b6e6dc9eeac894c92d758/tests%2Fui%2Fchecked_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81821acd59a051b5fb0b6e6dc9eeac894c92d758/tests%2Fui%2Fchecked_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap.stderr?ref=81821acd59a051b5fb0b6e6dc9eeac894c92d758", "patch": "@@ -0,0 +1,207 @@\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+ --> $DIR/checked_unwrap.rs:4:9\n+  |\n+4 |         x.unwrap();\n+  |         ^^^^^^^^^^\n+  |\n+  = note: `-D unnecessary-unwrap` implied by `-D warnings`\n+note: the check is happening here\n+ --> $DIR/checked_unwrap.rs:3:8\n+  |\n+3 |     if x.is_some() {\n+  |        ^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+ --> $DIR/checked_unwrap.rs:9:9\n+  |\n+9 |         x.unwrap();\n+  |         ^^^^^^^^^^\n+  |\n+note: the check is happening here\n+ --> $DIR/checked_unwrap.rs:6:8\n+  |\n+6 |     if x.is_none() {\n+  |        ^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:13:9\n+   |\n+13 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:12:8\n+   |\n+12 |     if x.is_ok() {\n+   |        ^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:15:9\n+   |\n+15 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:12:8\n+   |\n+12 |     if x.is_ok() {\n+   |        ^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:18:9\n+   |\n+18 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:17:8\n+   |\n+17 |     if x.is_err() {\n+   |        ^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:20:9\n+   |\n+20 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:17:8\n+   |\n+17 |     if x.is_err() {\n+   |        ^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:35:9\n+   |\n+35 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:34:8\n+   |\n+34 |     if x.is_ok() && y.is_err() {\n+   |        ^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:36:9\n+   |\n+36 |         y.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:34:21\n+   |\n+34 |     if x.is_ok() && y.is_err() {\n+   |                     ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:48:9\n+   |\n+48 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:43:8\n+   |\n+43 |     if x.is_ok() || y.is_ok() {\n+   |        ^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:49:9\n+   |\n+49 |         y.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:43:21\n+   |\n+43 |     if x.is_ok() || y.is_ok() {\n+   |                     ^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:53:9\n+   |\n+53 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:52:8\n+   |\n+52 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |        ^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:54:9\n+   |\n+54 |         y.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:52:23\n+   |\n+52 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |                       ^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:55:9\n+   |\n+55 |         z.unwrap();\n+   |         ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:52:36\n+   |\n+52 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |                                    ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:60:9\n+   |\n+60 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:57:8\n+   |\n+57 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |        ^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:61:9\n+   |\n+61 |         y.unwrap();\n+   |         ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:57:23\n+   |\n+57 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |                       ^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:62:9\n+   |\n+62 |         z.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:57:36\n+   |\n+57 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |                                    ^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:70:13\n+   |\n+70 |             x.unwrap();\n+   |             ^^^^^^^^^^\n+   |\n+note: the check is happening here\n+  --> $DIR/checked_unwrap.rs:69:12\n+   |\n+69 |         if x.is_some() {\n+   |            ^^^^^^^^^^^\n+\n+error: aborting due to 17 previous errors\n+"}]}