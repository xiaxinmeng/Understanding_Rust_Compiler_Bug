{"sha": "652da4ca55e5b579570083231a11680e9f889b11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MmRhNGNhNTVlNWI1Nzk1NzAwODMyMzFhMTE2ODBlOWY4ODliMTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-16T17:54:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-16T17:54:12Z"}, "message": "rustc: Implement immediates in the DPS engine; it should now always be at least as efficient as the original engine (and typically much more).", "tree": {"sha": "5f56de2c64c85a3dd4bad20742dd50ffe2696041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f56de2c64c85a3dd4bad20742dd50ffe2696041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/652da4ca55e5b579570083231a11680e9f889b11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/652da4ca55e5b579570083231a11680e9f889b11", "html_url": "https://github.com/rust-lang/rust/commit/652da4ca55e5b579570083231a11680e9f889b11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/652da4ca55e5b579570083231a11680e9f889b11/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88574c3cea87bc8f789883bcd518b8a91fb1a776", "url": "https://api.github.com/repos/rust-lang/rust/commits/88574c3cea87bc8f789883bcd518b8a91fb1a776", "html_url": "https://github.com/rust-lang/rust/commit/88574c3cea87bc8f789883bcd518b8a91fb1a776"}], "stats": {"total": 65, "additions": 49, "deletions": 16}, "files": [{"sha": "0ef4063ecb94bdba0e44e06f2c2bb5f49c592820", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/652da4ca55e5b579570083231a11680e9f889b11/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/652da4ca55e5b579570083231a11680e9f889b11/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=652da4ca55e5b579570083231a11680e9f889b11", "patch": "@@ -41,15 +41,16 @@ fn llelement_type(TypeRef llty) -> TypeRef {\n \n tag dest_slot {\n     dst_nil;\n-    dst_val(ValueRef);\n+    dst_imm(@mutable option[ValueRef]);\n+    dst_ptr(ValueRef);\n }\n \n tag dest_mode { dm_copy; dm_move; dm_alias; }\n \n type dest = rec(dest_slot slot, dest_mode mode);\n \n fn dest_slot_for_ptr(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest_slot {\n-    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_val(llptr) }\n+    if ty::type_is_nil(tcx, t) { dst_nil } else { dst_ptr(llptr) }\n }\n \n fn dest_copy(&ty::ctxt tcx, ValueRef llptr, ty::t t) -> dest {\n@@ -69,16 +70,34 @@ fn dest_tmp(&@block_ctxt bcx, ty::t t, bool alias) -> tup(@block_ctxt, dest) {\n     if ty::type_is_nil(bcx_tcx(bcx), t) {\n         ret tup(bcx, rec(slot=dst_nil, mode=mode));\n     }\n+    if trans::type_is_immediate(bcx_ccx(bcx), t) {\n+        ret tup(bcx, rec(slot=dst_imm(@mutable none), mode=mode));\n+    }\n     auto r = trans::alloc_ty(bcx, t);\n     trans::add_clean(bcx, r.val, t);\n     ret tup(r.bcx, rec(slot=dest_slot_for_ptr(bcx_tcx(bcx), r.val, t),\n                        mode=mode));\n }\n \n+// Invariant: the type of the destination must be structural (non-immediate).\n fn dest_ptr(&dest dest) -> ValueRef {\n     alt (dest.slot) {\n-      dst_nil { tc::C_null(tc::T_ptr(tc::T_i8())) }\n-      dst_val(?llptr) { llptr }\n+      dst_nil { fail \"nil dest in dest_ptr\" }\n+      dst_imm(_) { fail \"immediate dest in dest_ptr\" }\n+      dst_ptr(?llptr) { llptr }\n+    }\n+}\n+\n+fn dest_llval(&dest dest) -> ValueRef {\n+    alt (dest.slot) {\n+      dst_nil { ret tc::C_nil(); }\n+      dst_imm(?box) {\n+        alt (*box) {\n+          none { fail \"immediate wasn't filled in prior to dest_llval\"; }\n+          some(?llval) { ret llval; }\n+        }\n+      }\n+      dst_ptr(?llval) { ret llval; }\n     }\n }\n \n@@ -100,9 +119,15 @@ fn store(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n         -> @block_ctxt {\n     alt (dest.slot) {\n       dst_nil { /* no-op */ }\n-      dst_val(?lldestptr_orig) {\n+      dst_imm(?box) {\n+        if !std::option::is_none(*box) {\n+          fail \"attempt to store an immediate twice\";\n+        };\n+        *box = some(llsrc);\n+      }\n+      dst_ptr(?lldestptr_orig) {\n         auto lldestptr = lldestptr_orig;\n-        if (cast) {\n+        if cast {\n             lldestptr = bcx.build.PointerCast(lldestptr,\n                                               tc::T_ptr(lltype_of(llsrc)));\n         }\n@@ -201,39 +226,47 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n         ret lllevelptr;\n     }\n \n-    fn trans_log_upcall(&@block_ctxt bcx, &span sp, ValueRef in_llval,\n-                        int level, ty::t t) {\n+    fn trans_log_upcall(&@block_ctxt cx, &span sp, ValueRef in_llval,\n+                        int level, ty::t t) -> @block_ctxt {\n+        auto bcx = cx;\n         auto llval = in_llval;\n-        auto by_val; auto llupcall;\n+        auto llupcall;\n         alt (ty::struct(bcx_tcx(bcx), t)) {\n           ty::ty_machine(ast::ty_f32) {\n-            by_val = true; llupcall = bcx_ccx(bcx).upcalls.log_float;\n+            llupcall = bcx_ccx(bcx).upcalls.log_float;\n           }\n           ty::ty_machine(ast::ty_f64) | ty::ty_float {\n-            by_val = false; llupcall = bcx_ccx(bcx).upcalls.log_double;\n+            llupcall = bcx_ccx(bcx).upcalls.log_double;\n+\n+            // TODO: Here we have to spill due to legacy calling conventions.\n+            // This is no longer necessary.\n+            auto r = trans::alloc_ty(bcx, t);\n+            bcx = r.bcx; auto llptr = r.val;\n+            bcx.build.Store(llval, llptr);\n+            llval = llptr;\n           }\n           ty::ty_bool | ty::ty_machine(ast::ty_i8) |\n                 ty::ty_machine(ast::ty_i16) | ty::ty_machine(ast::ty_u8) |\n                 ty::ty_machine(ast::ty_u16) {\n-            by_val = true; llupcall = bcx_ccx(bcx).upcalls.log_int;\n+            llupcall = bcx_ccx(bcx).upcalls.log_int;\n             llval = bcx.build.ZExt(llval, tc::T_i32());\n           }\n           ty::ty_int | ty::ty_machine(ast::ty_i32) |\n                 ty::ty_machine(ast::ty_u32) {\n-            by_val = true; llupcall = bcx_ccx(bcx).upcalls.log_int;\n+            llupcall = bcx_ccx(bcx).upcalls.log_int;\n           }\n           ty::ty_istr {\n-            by_val = false; llupcall = bcx_ccx(bcx).upcalls.log_istr;\n+            llupcall = bcx_ccx(bcx).upcalls.log_istr;\n           }\n           _ {\n             bcx_ccx(bcx).sess.span_unimpl(sp, \"logging for values of type \" +\n                 ppaux::ty_to_str(bcx_tcx(bcx), t));\n           }\n         }\n \n-        if by_val { llval = bcx.build.Load(llval); }\n         bcx.build.Call(llupcall,\n                        ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llval]);\n+        ret bcx;\n     }\n \n     auto bcx = cx;\n@@ -253,7 +286,7 @@ fn trans_log(&@block_ctxt cx, &span sp, int level, &@ast::expr expr)\n     log_bcx = r._0; auto tmp = r._1;\n     log_bcx = trans_expr(log_bcx, tmp, expr);\n \n-    trans_log_upcall(log_bcx, sp, dest_ptr(tmp), level, expr_t);\n+    log_bcx = trans_log_upcall(log_bcx, sp, dest_llval(tmp), level, expr_t);\n \n     log_bcx = trans::trans_block_cleanups(log_bcx,\n                                           trans::find_scope_cx(log_bcx));"}]}