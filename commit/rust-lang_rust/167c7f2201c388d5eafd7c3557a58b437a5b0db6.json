{"sha": "167c7f2201c388d5eafd7c3557a58b437a5b0db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2N2M3ZjIyMDFjMzg4ZDVlYWZkN2MzNTU3YTU4YjQzN2E1YjBkYjY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-17T13:01:51Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-22T17:56:50Z"}, "message": "Don't force static refs to const memory", "tree": {"sha": "a0c6853a7a75a01cca7d874b05f648fae666bd4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0c6853a7a75a01cca7d874b05f648fae666bd4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/167c7f2201c388d5eafd7c3557a58b437a5b0db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/167c7f2201c388d5eafd7c3557a58b437a5b0db6", "html_url": "https://github.com/rust-lang/rust/commit/167c7f2201c388d5eafd7c3557a58b437a5b0db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/167c7f2201c388d5eafd7c3557a58b437a5b0db6/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4acc78e4d9fd3f81361ea68e3b5fc5d09879c60", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4acc78e4d9fd3f81361ea68e3b5fc5d09879c60", "html_url": "https://github.com/rust-lang/rust/commit/c4acc78e4d9fd3f81361ea68e3b5fc5d09879c60"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "b6b43526c7248eb517b1ff06dba9287fc5d73a4a", "filename": "src/constant.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/167c7f2201c388d5eafd7c3557a58b437a5b0db6/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167c7f2201c388d5eafd7c3557a58b437a5b0db6/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=167c7f2201c388d5eafd7c3557a58b437a5b0db6", "patch": "@@ -11,6 +11,7 @@ use rustc_mir::interpret::{\n     StackPopCleanup, StackPopInfo,\n };\n \n+use cranelift_codegen::ir::GlobalValue;\n use cranelift_module::*;\n \n use crate::prelude::*;\n@@ -47,7 +48,10 @@ fn codegen_static_ref<'tcx>(\n ) -> CPlace<'tcx> {\n     let linkage = crate::linkage::get_static_ref_linkage(fx.tcx, def_id);\n     let data_id = data_id_for_static(fx.tcx, fx.module, def_id, linkage);\n-    cplace_for_dataid(fx, layout, data_id)\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    fx.add_entity_comment(local_data_id, format!(\"{:?}\", def_id));\n+    cplace_for_dataid(fx, layout, local_data_id)\n }\n \n pub fn trans_constant<'tcx>(\n@@ -119,53 +123,52 @@ pub fn trans_const_value<'tcx>(\n             layout,\n         );\n     }\n-\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n         _ => unreachable!(\"Const {:?} should have been evaluated\", const_),\n     };\n \n     match const_val {\n         ConstValue::Scalar(x) => {\n-            let scalar = match layout.abi {\n-                layout::Abi::Scalar(ref x) => x,\n-                _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n-            };\n+            if fx.clif_type(layout.ty).is_none() {\n+                return trans_const_place(fx, const_).to_cvalue(fx);\n+            }\n \n-            match ty.kind {\n-                ty::Bool | ty::Uint(_) => {\n-                    let bits = const_.val.try_to_bits(layout.size).unwrap_or_else(|| {\n-                        panic!(\"{:?}\\n{:?}\", const_, layout);\n-                    });\n-                    CValue::const_val(fx, layout, bits)\n+            match x {\n+                Scalar::Raw { data, size } => {\n+                    assert_eq!(u64::from(size), layout.size.bytes());\n+                    return CValue::const_val(fx, layout, data);\n                 }\n-                ty::Int(_) => {\n-                    let bits = const_.val.try_to_bits(layout.size).unwrap();\n-                    CValue::const_val(\n-                        fx,\n-                        layout,\n-                        rustc::mir::interpret::sign_extend(bits, layout.size),\n-                    )\n-                }\n-                ty::Float(fty) => {\n-                    let bits = const_.val.try_to_bits(layout.size).unwrap();\n-                    let val = match fty {\n-                        FloatTy::F32 => fx\n-                            .bcx\n-                            .ins()\n-                            .f32const(Ieee32::with_bits(u32::try_from(bits).unwrap())),\n-                        FloatTy::F64 => fx\n-                            .bcx\n-                            .ins()\n-                            .f64const(Ieee64::with_bits(u64::try_from(bits).unwrap())),\n+                Scalar::Ptr(ptr) => {\n+                    let alloc_kind = fx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                    let base_addr = match alloc_kind {\n+                        Some(GlobalAlloc::Memory(alloc)) => {\n+                            fx.constants_cx.todo.insert(TodoItem::Alloc(ptr.alloc_id));\n+                            let data_id = data_id_for_alloc_id(fx.module, ptr.alloc_id, alloc.align);\n+                            let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            #[cfg(debug_assertions)]\n+                            fx.add_entity_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n+                        }\n+                        Some(GlobalAlloc::Function(instance)) => {\n+                            let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n+                            let local_func_id = fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                            fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n+                        }\n+                        Some(GlobalAlloc::Static(def_id)) => {\n+                            assert!(fx.tcx.is_static(def_id));\n+                            let linkage = crate::linkage::get_static_ref_linkage(fx.tcx, def_id);\n+                            let data_id = data_id_for_static(fx.tcx, fx.module, def_id, linkage);\n+                            let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            #[cfg(debug_assertions)]\n+                            fx.add_entity_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n+                        }\n+                        None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                     };\n-                    CValue::by_val(val, layout)\n+                    let val = fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap());\n+                    return CValue::by_val(val, layout);\n                 }\n-                ty::FnDef(_def_id, _substs) => CValue::by_ref(\n-                    crate::pointer::Pointer::const_addr(fx, fx.pointer_type.bytes() as i64),\n-                    layout,\n-                ),\n-                _ => trans_const_place(fx, const_).to_cvalue(fx),\n             }\n         }\n         ConstValue::ByRef { alloc, offset } => {\n@@ -228,7 +231,10 @@ fn trans_const_place<'tcx>(\n     let alloc_id = fx.tcx.alloc_map.lock().create_memory_alloc(alloc);\n     fx.constants_cx.todo.insert(TodoItem::Alloc(alloc_id));\n     let data_id = data_id_for_alloc_id(fx.module, alloc_id, alloc.align);\n-    cplace_for_dataid(fx, fx.layout_of(const_.ty), data_id)\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    #[cfg(debug_assertions)]\n+    fx.add_entity_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    cplace_for_dataid(fx, fx.layout_of(const_.ty), local_data_id)\n }\n \n fn data_id_for_alloc_id<B: Backend>(\n@@ -305,9 +311,8 @@ fn data_id_for_static(\n fn cplace_for_dataid<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     layout: TyLayout<'tcx>,\n-    data_id: DataId,\n+    local_data_id: GlobalValue,\n ) -> CPlace<'tcx> {\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)"}]}