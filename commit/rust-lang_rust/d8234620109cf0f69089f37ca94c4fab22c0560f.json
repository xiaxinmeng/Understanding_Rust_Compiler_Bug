{"sha": "d8234620109cf0f69089f37ca94c4fab22c0560f", "node_id": "C_kwDOAAsO6NoAKGQ4MjM0NjIwMTA5Y2YwZjY5MDg5ZjM3Y2E5NGM0ZmFiMjJjMDU2MGY", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-06-09T18:52:17Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-06-09T18:52:17Z"}, "message": "add cgroupv1 support to available_parallelism", "tree": {"sha": "eb29dd07c5e3e7ae75eb99863db5e996c4e58abb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb29dd07c5e3e7ae75eb99863db5e996c4e58abb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8234620109cf0f69089f37ca94c4fab22c0560f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8234620109cf0f69089f37ca94c4fab22c0560f", "html_url": "https://github.com/rust-lang/rust/commit/d8234620109cf0f69089f37ca94c4fab22c0560f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8234620109cf0f69089f37ca94c4fab22c0560f/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1", "html_url": "https://github.com/rust-lang/rust/commit/09d52bc5d4260bac8b9a2ea8ac7a07c5c72906f1"}], "stats": {"total": 176, "additions": 128, "deletions": 48}, "files": [{"sha": "05a2815632bd1c3cc9cefa1c40415e274e245ab7", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8234620109cf0f69089f37ca94c4fab22c0560f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8234620109cf0f69089f37ca94c4fab22c0560f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=d8234620109cf0f69089f37ca94c4fab22c0560f", "patch": "@@ -274,6 +274,7 @@\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n+#![feature(is_some_with)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]\n #![feature(mixed_integer_ops)]"}, {"sha": "c5b905685700b00cd88d98bc520613ff15cc0fb4", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 126, "deletions": 47, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d8234620109cf0f69089f37ca94c4fab22c0560f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8234620109cf0f69089f37ca94c4fab22c0560f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=d8234620109cf0f69089f37ca94c4fab22c0560f", "patch": "@@ -285,7 +285,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         ))] {\n             #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n             {\n-                let quota = cgroup2_quota().max(1);\n+                let quota = cgroups::quota().max(1);\n                 let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n                 unsafe {\n                     if libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n@@ -379,49 +379,77 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     }\n }\n \n-/// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n-/// be determined or is not set.\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n-fn cgroup2_quota() -> usize {\n+mod cgroups {\n     use crate::ffi::OsString;\n     use crate::fs::{try_exists, File};\n     use crate::io::Read;\n     use crate::os::unix::ffi::OsStringExt;\n     use crate::path::PathBuf;\n+    use crate::str::from_utf8;\n \n-    let mut quota = usize::MAX;\n-    if cfg!(miri) {\n-        // Attempting to open a file fails under default flags due to isolation.\n-        // And Miri does not have parallelism anyway.\n-        return quota;\n-    }\n-\n-    let _: Option<()> = try {\n-        let mut buf = Vec::with_capacity(128);\n-        // find our place in the cgroup hierarchy\n-        File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n-        let cgroup_path = buf\n-            .split(|&c| c == b'\\n')\n-            .filter_map(|line| {\n-                let mut fields = line.splitn(3, |&c| c == b':');\n-                // expect cgroupv2 which has an empty 2nd field\n-                if fields.nth(1) != Some(b\"\") {\n-                    return None;\n-                }\n-                let path = fields.last()?;\n-                // skip leading slash\n-                Some(path[1..].to_owned())\n-            })\n-            .next()?;\n-        let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+    enum Cgroup {\n+        V1,\n+        V2,\n+    }\n+\n+    /// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n+    /// be determined or is not set.\n+    pub(super) fn quota() -> usize {\n+        let mut quota = usize::MAX;\n+        if cfg!(miri) {\n+            // Attempting to open a file fails under default flags due to isolation.\n+            // And Miri does not have parallelism anyway.\n+            return quota;\n+        }\n+\n+        let _: Option<()> = try {\n+            let mut buf = Vec::with_capacity(128);\n+            // find our place in the cgroup hierarchy\n+            File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n+            let (cgroup_path, version) = buf\n+                .split(|&c| c == b'\\n')\n+                .filter_map(|line| {\n+                    let mut fields = line.splitn(3, |&c| c == b':');\n+                    // 2nd field is a list of controllers for v1 or empty for v2\n+                    let version = match fields.nth(1) {\n+                        Some(b\"\") => Some(Cgroup::V2),\n+                        Some(controllers)\n+                            if from_utf8(controllers)\n+                                .is_ok_and(|c| c.split(\",\").any(|c| c == \"cpu\")) =>\n+                        {\n+                            Some(Cgroup::V1)\n+                        }\n+                        _ => None,\n+                    }?;\n+\n+                    let path = fields.last()?;\n+                    // skip leading slash\n+                    Some((path[1..].to_owned(), version))\n+                })\n+                .next()?;\n+            let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+\n+            quota = match version {\n+                Cgroup::V1 => quota_v1(cgroup_path),\n+                Cgroup::V2 => quota_v2(cgroup_path),\n+            };\n+        };\n+\n+        quota\n+    }\n+\n+    fn quota_v2(group_path: PathBuf) -> usize {\n+        let mut quota = usize::MAX;\n \n         let mut path = PathBuf::with_capacity(128);\n         let mut read_buf = String::with_capacity(20);\n \n+        // standard mount location defined in file-hierarchy(7) manpage\n         let cgroup_mount = \"/sys/fs/cgroup\";\n \n         path.push(cgroup_mount);\n-        path.push(&cgroup_path);\n+        path.push(&group_path);\n \n         path.push(\"cgroup.controllers\");\n \n@@ -432,30 +460,81 @@ fn cgroup2_quota() -> usize {\n \n         path.pop();\n \n-        while path.starts_with(cgroup_mount) {\n-            path.push(\"cpu.max\");\n+        let _: Option<()> = try {\n+            while path.starts_with(cgroup_mount) {\n+                path.push(\"cpu.max\");\n+\n+                read_buf.clear();\n+\n+                if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n+                    let raw_quota = read_buf.lines().next()?;\n+                    let mut raw_quota = raw_quota.split(' ');\n+                    let limit = raw_quota.next()?;\n+                    let period = raw_quota.next()?;\n+                    match (limit.parse::<usize>(), period.parse::<usize>()) {\n+                        (Ok(limit), Ok(period)) => {\n+                            quota = quota.min(limit / period);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n \n-            read_buf.clear();\n+                path.pop(); // pop filename\n+                path.pop(); // pop dir\n+            }\n+        };\n \n-            if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n-                let raw_quota = read_buf.lines().next()?;\n-                let mut raw_quota = raw_quota.split(' ');\n-                let limit = raw_quota.next()?;\n-                let period = raw_quota.next()?;\n-                match (limit.parse::<usize>(), period.parse::<usize>()) {\n-                    (Ok(limit), Ok(period)) => {\n-                        quota = quota.min(limit / period);\n-                    }\n+        quota\n+    }\n+\n+    fn quota_v1(group_path: PathBuf) -> usize {\n+        let mut quota = usize::MAX;\n+        let mut path = PathBuf::with_capacity(128);\n+        let mut read_buf = String::with_capacity(20);\n+\n+        // Hardcode commonly used locations mentioned in the cgroups(7) manpage\n+        // since scanning mountinfo can be expensive on some systems.\n+        // This isn't exactly standardized since cgroupv1 was meant to allow flexibly\n+        // mixing and matching controller hierarchies.\n+        let mounts = [\"/sys/fs/cgroup/cpu\", \"/sys/fs/cgroup/cpu,cpuacct\"];\n+\n+        for mount in mounts {\n+            path.clear();\n+            path.push(mount);\n+            path.push(&group_path);\n+\n+            // skip if we guessed the mount incorrectly\n+            if matches!(try_exists(&path), Err(_) | Ok(false)) {\n+                continue;\n+            }\n+\n+            while path.starts_with(mount) {\n+                let mut parse_file = |name| {\n+                    path.push(name);\n+                    read_buf.clear();\n+\n+                    let mut f = File::open(&path).ok()?;\n+                    f.read_to_string(&mut read_buf).ok()?;\n+                    let parsed = read_buf.trim().parse::<usize>().ok()?;\n+\n+                    path.pop();\n+                    Some(parsed)\n+                };\n+\n+                let limit = parse_file(\"cpu.cfs_quota_us\");\n+                let period = parse_file(\"cpu.cfs_period_us\");\n+\n+                match (limit, period) {\n+                    (Some(limit), Some(period)) => quota = quota.min(limit / period),\n                     _ => {}\n                 }\n-            }\n \n-            path.pop(); // pop filename\n-            path.pop(); // pop dir\n+                path.pop();\n+            }\n         }\n-    };\n \n-    quota\n+        quota\n+    }\n }\n \n #[cfg(all("}, {"sha": "f02a7de04e5bef1eee58f9c86d665ad59858400e", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8234620109cf0f69089f37ca94c4fab22c0560f/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8234620109cf0f69089f37ca94c4fab22c0560f/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=d8234620109cf0f69089f37ca94c4fab22c0560f", "patch": "@@ -1571,7 +1571,7 @@ fn _assert_sync_and_send() {\n ///\n /// On Linux:\n /// - It may overcount the amount of parallelism available when limited by a\n-///   process-wide affinity mask or cgroup quotas and cgroup2 fs or `sched_getaffinity()` can't be\n+///   process-wide affinity mask or cgroup quotas and `sched_getaffinity()` or cgroup fs can't be\n ///   queried, e.g. due to sandboxing.\n /// - It may undercount the amount of parallelism if the current thread's affinity mask\n ///   does not reflect the process' cpuset, e.g. due to pinned threads."}]}