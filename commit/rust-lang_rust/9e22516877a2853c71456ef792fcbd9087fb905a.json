{"sha": "9e22516877a2853c71456ef792fcbd9087fb905a", "node_id": "C_kwDOAAsO6NoAKDllMjI1MTY4NzdhMjg1M2M3MTQ1NmVmNzkyZmNiZDkwODdmYjkwNWE", "commit": {"author": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-02-26T00:27:18Z"}, "committer": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-02-26T02:13:44Z"}, "message": "Fix `VecDeque::shrink_to` and add tests.\n\nThis adds both a test specific to #108453 as well as an exhaustive test\nthat goes through all possible combinations of head index, length and target capacity\nfor a deque with capacity 16.", "tree": {"sha": "b7222196f594b859ed6f3da8b5918bea08ba35ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7222196f594b859ed6f3da8b5918bea08ba35ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e22516877a2853c71456ef792fcbd9087fb905a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e22516877a2853c71456ef792fcbd9087fb905a", "html_url": "https://github.com/rust-lang/rust/commit/9e22516877a2853c71456ef792fcbd9087fb905a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e22516877a2853c71456ef792fcbd9087fb905a/comments", "author": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e6673a0473e90ef01a18eb575392c9e3859747", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e6673a0473e90ef01a18eb575392c9e3859747", "html_url": "https://github.com/rust-lang/rust/commit/34e6673a0473e90ef01a18eb575392c9e3859747"}], "stats": {"total": 159, "additions": 104, "deletions": 55}, "files": [{"sha": "b30449ed06a15895d29d3b0aa03d161458f0e926", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9e22516877a2853c71456ef792fcbd9087fb905a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e22516877a2853c71456ef792fcbd9087fb905a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=9e22516877a2853c71456ef792fcbd9087fb905a", "patch": "@@ -944,65 +944,72 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             return;\n         }\n \n-        if target_cap < self.capacity() {\n-            // There are three cases of interest:\n-            //   All elements are out of desired bounds\n-            //   Elements are contiguous, and head is out of desired bounds\n-            //   Elements are discontiguous, and tail is out of desired bounds\n+        // There are three cases of interest:\n+        //   All elements are out of desired bounds\n+        //   Elements are contiguous, and tail is out of desired bounds\n+        //   Elements are discontiguous, and head is out of desired bounds\n+        //\n+        // At all other times, element positions are unaffected.\n+\n+        // `head` and `len` are at most `isize::MAX` and `target_cap < self.capacity()`, so nothing can\n+        // overflow.\n+        let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n+\n+        if self.len == 0 {\n+            self.head = 0;\n+        } else if self.head >= target_cap && tail_outside {\n+            // Head and tail are both out of bounds, so copy all of them to the front.\n             //\n-            // At all other times, element positions are unaffected.\n+            //  H := head\n+            //  L := last element\n+            //                    H           L\n+            //   [. . . . . . . . o o o o o o o . ]\n+            //    H           L\n+            //   [o o o o o o o . ]\n+            unsafe {\n+                // nonoverlapping because `self.head >= target_cap >= self.len`.\n+                self.copy_nonoverlapping(self.head, 0, self.len);\n+            }\n+            self.head = 0;\n+        } else if self.head < target_cap && tail_outside {\n+            // Head is in bounds, tail is out of bounds.\n+            // Copy the overflowing part to the beginning of the\n+            // buffer. This won't overlap because `target_cap >= self.len`.\n             //\n-            // Indicates that elements at the head should be moved.\n-\n-            let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n-            // Move elements from out of desired bounds (positions after target_cap)\n-            if self.len == 0 {\n-                self.head = 0;\n-            } else if self.head >= target_cap && tail_outside {\n-                //  H := head\n-                //  L := last element\n-                //                    H           L\n-                //   [. . . . . . . . o o o o o o o . ]\n-                //    H           L\n-                //   [o o o o o o o . ]\n-                unsafe {\n-                    // nonoverlapping because self.head >= target_cap >= self.len\n-                    self.copy_nonoverlapping(self.head, 0, self.len);\n-                }\n-                self.head = 0;\n-            } else if self.head < target_cap && tail_outside {\n-                //  H := head\n-                //  L := last element\n-                //          H           L\n-                //   [. . . o o o o o o o . . . . . . ]\n-                //      L   H\n-                //   [o o . o o o o o ]\n-                let len = self.head + self.len - target_cap;\n-                unsafe {\n-                    self.copy_nonoverlapping(target_cap, 0, len);\n-                }\n-            } else if self.head >= target_cap {\n-                //  H := head\n-                //  L := last element\n-                //            L                   H\n-                //   [o o o o o . . . . . . . . . o o ]\n-                //            L   H\n-                //   [o o o o o . o o ]\n-                let len = self.capacity() - self.head;\n-                let new_head = target_cap - len;\n-                unsafe {\n-                    // can't use copy_nonoverlapping here for the same reason\n-                    // as in `handle_capacity_increase()`\n-                    self.copy(self.head, new_head, len);\n-                }\n-                self.head = new_head;\n+            //  H := head\n+            //  L := last element\n+            //          H           L\n+            //   [. . . o o o o o o o . . . . . . ]\n+            //      L   H\n+            //   [o o . o o o o o ]\n+            let len = self.head + self.len - target_cap;\n+            unsafe {\n+                self.copy_nonoverlapping(target_cap, 0, len);\n             }\n-\n-            self.buf.shrink_to_fit(target_cap);\n-\n-            debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n-            debug_assert!(self.len <= self.capacity());\n+        } else if !self.is_contiguous() {\n+            // Head is out of bounds, tail is in bounds.\n+            // Copy the head backwards so it lines up with the target capacity.\n+            // This won't overlap because `target_cap >= self.len`.\n+            //\n+            //  H := head\n+            //  L := last element\n+            //            L                   H\n+            //   [o o o o o . . . . . . . . . o o ]\n+            //            L   H\n+            //   [o o o o o . o o ]\n+            let head_len = self.capacity() - self.head;\n+            let new_head = target_cap - head_len;\n+            unsafe {\n+                // can't use `copy_nonoverlapping()` here because the new and old\n+                // regions for the head might overlap.\n+                self.copy(self.head, new_head, head_len);\n+            }\n+            self.head = new_head;\n         }\n+        self.buf.shrink_to_fit(target_cap);\n+\n+        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n+        debug_assert!(self.len <= self.capacity());\n     }\n \n     /// Shortens the deque, keeping the first `len` elements and dropping"}, {"sha": "205a8ff3c19a8cf3242fd97efd23756eb753ae20", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e22516877a2853c71456ef792fcbd9087fb905a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e22516877a2853c71456ef792fcbd9087fb905a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=9e22516877a2853c71456ef792fcbd9087fb905a", "patch": "@@ -748,6 +748,48 @@ fn test_drain() {\n     }\n }\n \n+#[test]\n+fn issue_108453() {\n+    let mut deque = VecDeque::with_capacity(10);\n+\n+    deque.push_back(1u8);\n+    deque.push_back(2);\n+    deque.push_back(3);\n+\n+    deque.push_front(10);\n+    deque.push_front(9);\n+\n+    deque.shrink_to(9);\n+\n+    assert_eq!(deque.into_iter().collect::<Vec<_>>(), vec![9, 10, 1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_shrink_to() {\n+    // test deques with capacity 16 with all possible head positions, lengths and target capacities.\n+    let cap = 16;\n+\n+    for len in 0..cap {\n+        for head in 0..cap {\n+            let expected = (1..=len).collect::<VecDeque<_>>();\n+\n+            for target_cap in len..cap {\n+                let mut deque = VecDeque::with_capacity(cap);\n+                // currently, `with_capacity` always allocates the exact capacity if it's greater than 8.\n+                assert_eq!(deque.capacity(), cap);\n+\n+                // we can let the head point anywhere in the buffer since the deque is empty.\n+                deque.head = head;\n+                deque.extend(1..=len);\n+\n+                deque.shrink_to(target_cap);\n+\n+                assert_eq!(deque, expected);\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_shrink_to_fit() {\n     // This test checks that every single combination of head and tail position,"}]}