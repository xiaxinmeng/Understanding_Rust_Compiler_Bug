{"sha": "79d1e5df2190e4cfdd1814af95837b21ef046745", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDFlNWRmMjE5MGU0Y2ZkZDE4MTRhZjk1ODM3YjIxZWYwNDY3NDU=", "commit": {"author": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-03-26T23:12:50Z"}, "committer": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2014-04-15T19:47:47Z"}, "message": "Support lifetime suggestion for method\n\nThis includes a change to the way lifetime names are generated. Say we\nfigure that `[#0, 'a, 'b]` have to be the same lifetimes, then instead\nof just generating a new lifetime `'c` like before to replace them, we\nwould reuse `'a`. This is done so that when the lifetime name comes\nfrom an impl, we don't give something that's completely off, and we\ndon't have to do much work to figure out where the name came from. For\nexample, for the following code snippet:\n\n```rust\nstruct Baz<'x> {\n    bar: &'x int\n}\n\nimpl<'x> Baz<'x> {\n    fn baz1(&self) -> &int {\n        self.bar\n    }\n}\n```\n\n`[#1, 'x]` (where `#1` is BrAnon(1) and refers to lifetime of `&int`)\nhave to be marked the same lifetime. With the old method, we would\ngenerate a new lifetime `'a` and suggest `fn baz1(&self) -> &'a int`\nor `fn baz1<'a>(&self) -> &'a int`, both of which are wrong.", "tree": {"sha": "dfec604a3889f58957e732a3b36fafdce711af55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfec604a3889f58957e732a3b36fafdce711af55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d1e5df2190e4cfdd1814af95837b21ef046745", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d1e5df2190e4cfdd1814af95837b21ef046745", "html_url": "https://github.com/rust-lang/rust/commit/79d1e5df2190e4cfdd1814af95837b21ef046745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d1e5df2190e4cfdd1814af95837b21ef046745/comments", "author": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "189584e792bfc10142793ca1117e803c2201991a", "url": "https://api.github.com/repos/rust-lang/rust/commits/189584e792bfc10142793ca1117e803c2201991a", "html_url": "https://github.com/rust-lang/rust/commit/189584e792bfc10142793ca1117e803c2201991a"}], "stats": {"total": 256, "additions": 199, "deletions": 57}, "files": [{"sha": "91cc0a20813423bd63d7301af1681bafffb2394a", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 174, "deletions": 52, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/79d1e5df2190e4cfdd1814af95837b21ef046745/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d1e5df2190e4cfdd1814af95837b21ef046745/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=79d1e5df2190e4cfdd1814af95837b21ef046745", "patch": "@@ -82,6 +82,7 @@ use syntax::ast_map;\n use syntax::ast_util;\n use syntax::ast_util::name_to_dummy_lifetime;\n use syntax::owned_slice::OwnedSlice;\n+use syntax::codemap;\n use syntax::parse::token;\n use syntax::print::pprust;\n use util::ppaux::UserString;\n@@ -143,10 +144,12 @@ trait ErrorReportingHelpers {\n                           origin: SubregionOrigin);\n \n     fn give_expl_lifetime_param(&self,\n-                                inputs: Vec<ast::Arg>,\n-                                output: ast::P<ast::Ty>,\n-                                item: ast::P<ast::Item>,\n-                                generics: ast::Generics);\n+                                decl: &ast::FnDecl,\n+                                fn_style: ast::FnStyle,\n+                                ident: ast::Ident,\n+                                opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                generics: &ast::Generics,\n+                                span: codemap::Span);\n }\n \n impl<'a> ErrorReporting for InferCtxt<'a> {\n@@ -260,6 +263,19 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             scope_id: ast::NodeId\n         }\n \n+        impl FreeRegionsFromSameFn {\n+            fn new(sub_fr: ty::FreeRegion,\n+                   sup_fr: ty::FreeRegion,\n+                   scope_id: ast::NodeId)\n+                   -> FreeRegionsFromSameFn {\n+                FreeRegionsFromSameFn {\n+                    sub_fr: sub_fr,\n+                    sup_fr: sup_fr,\n+                    scope_id: scope_id\n+                }\n+            }\n+        }\n+\n         fn free_regions_from_same_fn(tcx: &ty::ctxt,\n                                      sub: Region,\n                                      sup: Region)\n@@ -280,17 +296,14 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             match parent_node {\n                 Some(node) => match node {\n                     ast_map::NodeItem(item) => match item.node {\n-                        // FIXME: handle method\n                         ast::ItemFn(..) => {\n-                            let fr_from_same_fn = FreeRegionsFromSameFn {\n-                                sub_fr: fr1,\n-                                sup_fr: fr2,\n-                                scope_id: scope_id\n-                            };\n-                            Some(fr_from_same_fn)\n+                            Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n                         },\n                         _ => None\n                     },\n+                    ast_map::NodeMethod(..) => {\n+                        Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n+                    },\n                     _ => None\n                 },\n                 None => {\n@@ -662,21 +675,28 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         let node_inner = match parent_node {\n             Some(node) => match node {\n                 ast_map::NodeItem(item) => match item.node {\n-                    // FIXME: handling method\n-                    ast::ItemFn(ref fn_decl, _, _, ref gen, _) => {\n-                        Some((item, fn_decl, gen))\n+                    ast::ItemFn(ref fn_decl, ref pur, _, ref gen, _) => {\n+                        Some((fn_decl, gen, *pur, item.ident, None, item.span))\n                     },\n                     _ => None\n                 },\n+                ast_map::NodeMethod(m) => {\n+                    Some((&m.decl, &m.generics, m.fn_style,\n+                          m.ident, Some(m.explicit_self.node), m.span))\n+                },\n                 _ => None\n             },\n             None => None\n         };\n-        let (item, fn_decl, generics) = node_inner.expect(\"expect item fn\");\n-        let rebuilder = Rebuilder::new(self.tcx, *fn_decl,\n-                                       generics, same_regions);\n-        let (inputs, output, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(inputs, output, item, generics);\n+        let (fn_decl, generics, fn_style, ident, expl_self, span)\n+                                    = node_inner.expect(\"expect item fn\");\n+        let taken = lifetimes_in_scope(self.tcx, scope_id);\n+        let life_giver = LifeGiver::with_taken(taken.as_slice());\n+        let rebuilder = Rebuilder::new(self.tcx, *fn_decl, expl_self,\n+                                       generics, same_regions, &life_giver);\n+        let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n+        self.give_expl_lifetime_param(&fn_decl, fn_style, ident,\n+                                      expl_self, &generics, span);\n     }\n }\n \n@@ -694,53 +714,98 @@ struct RebuildPathInfo<'a> {\n struct Rebuilder<'a> {\n     tcx: &'a ty::ctxt,\n     fn_decl: ast::P<ast::FnDecl>,\n+    expl_self_opt: Option<ast::ExplicitSelf_>,\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n-    life_giver: LifeGiver,\n+    life_giver: &'a LifeGiver,\n     cur_anon: Cell<uint>,\n     inserted_anons: RefCell<HashSet<uint>>,\n }\n \n+enum FreshOrKept {\n+    Fresh,\n+    Kept\n+}\n+\n impl<'a> Rebuilder<'a> {\n     fn new(tcx: &'a ty::ctxt,\n            fn_decl: ast::P<ast::FnDecl>,\n+           expl_self_opt: Option<ast::ExplicitSelf_>,\n            generics: &'a ast::Generics,\n-           same_regions: &'a [SameRegions])\n+           same_regions: &'a [SameRegions],\n+           life_giver: &'a LifeGiver)\n            -> Rebuilder<'a> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n+            expl_self_opt: expl_self_opt,\n             generics: generics,\n             same_regions: same_regions,\n-            life_giver: LifeGiver::with_taken(generics.lifetimes.as_slice()),\n+            life_giver: life_giver,\n             cur_anon: Cell::new(0),\n             inserted_anons: RefCell::new(HashSet::new()),\n         }\n     }\n \n-    fn rebuild(&self) -> (Vec<ast::Arg>, ast::P<ast::Ty>, ast::Generics) {\n+    fn rebuild(&self)\n+               -> (ast::FnDecl, Option<ast::ExplicitSelf_>, ast::Generics) {\n+        let mut expl_self_opt = self.expl_self_opt;\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output;\n         let mut ty_params = self.generics.ty_params.clone();\n+        let mut kept_lifetimes = HashSet::new();\n         for sr in self.same_regions.iter() {\n             self.cur_anon.set(0);\n             self.offset_cur_anon();\n             let (anon_nums, region_names) =\n                                 self.extract_anon_nums_and_names(sr);\n-            let lifetime = self.life_giver.give_lifetime();\n+            let (lifetime, fresh_or_kept) = self.pick_lifetime(&region_names);\n+            match fresh_or_kept {\n+                Kept => { kept_lifetimes.insert(lifetime.name); }\n+                _ => ()\n+            }\n+            expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n+                                                   &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_arg_ty_or_output(output, lifetime,\n                                                    &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n                                                &region_names);\n         }\n-        let generated_lifetimes = self.life_giver.get_generated_lifetimes();\n+        let fresh_lifetimes = self.life_giver.get_generated_lifetimes();\n         let all_region_names = self.extract_all_region_names();\n         let generics = self.rebuild_generics(self.generics,\n-                                             generated_lifetimes,\n-                                             &all_region_names, ty_params);\n-        (inputs, output, generics)\n+                                             &fresh_lifetimes,\n+                                             &kept_lifetimes,\n+                                             &all_region_names,\n+                                             ty_params);\n+        let new_fn_decl = ast::FnDecl {\n+            inputs: inputs,\n+            output: output,\n+            cf: self.fn_decl.cf,\n+            variadic: self.fn_decl.variadic\n+        };\n+        (new_fn_decl, expl_self_opt, generics)\n+    }\n+\n+    fn pick_lifetime(&self,\n+                     region_names: &HashSet<ast::Name>)\n+                     -> (ast::Lifetime, FreshOrKept) {\n+        if region_names.len() > 0 {\n+            // It's not necessary to convert the set of region names to a\n+            // vector of string and then sort them. However, it makes the\n+            // choice of lifetime name deterministic and thus easier to test.\n+            let mut names = Vec::new();\n+            for rn in region_names.iter() {\n+                let lt_name = token::get_name(*rn).get().to_owned();\n+                names.push(lt_name);\n+            }\n+            names.sort();\n+            let name = token::str_to_ident(names.get(0).as_slice()).name;\n+            return (name_to_dummy_lifetime(name), Kept);\n+        }\n+        return (self.life_giver.give_lifetime(), Fresh);\n     }\n \n     fn extract_anon_nums_and_names(&self, same_regions: &SameRegions)\n@@ -849,9 +914,38 @@ impl<'a> Rebuilder<'a> {\n         })\n     }\n \n+    fn rebuild_expl_self(&self,\n+                         expl_self_opt: Option<ast::ExplicitSelf_>,\n+                         lifetime: ast::Lifetime,\n+                         anon_nums: &HashSet<uint>,\n+                         region_names: &HashSet<ast::Name>)\n+                         -> Option<ast::ExplicitSelf_> {\n+        match expl_self_opt {\n+            Some(expl_self) => match expl_self {\n+                ast::SelfRegion(lt_opt, muta) => match lt_opt {\n+                    Some(lt) => if region_names.contains(&lt.name) {\n+                        return Some(ast::SelfRegion(Some(lifetime), muta));\n+                    },\n+                    None => {\n+                        let anon = self.cur_anon.get();\n+                        self.inc_and_offset_cur_anon(1);\n+                        if anon_nums.contains(&anon) {\n+                            self.track_anon(anon);\n+                            return Some(ast::SelfRegion(Some(lifetime), muta));\n+                        }\n+                    }\n+                },\n+                _ => ()\n+            },\n+            None => ()\n+        }\n+        expl_self_opt\n+    }\n+\n     fn rebuild_generics(&self,\n                         generics: &ast::Generics,\n-                        add: Vec<ast::Lifetime>,\n+                        add: &Vec<ast::Lifetime>,\n+                        keep: &HashSet<ast::Name>,\n                         remove: &HashSet<ast::Name>,\n                         ty_params: OwnedSlice<ast::TyParam>)\n                         -> ast::Generics {\n@@ -860,7 +954,7 @@ impl<'a> Rebuilder<'a> {\n             lifetimes.push(*lt);\n         }\n         for lt in generics.lifetimes.iter() {\n-            if !remove.contains(&lt.name) {\n+            if keep.contains(&lt.name) || !remove.contains(&lt.name) {\n                 lifetimes.push((*lt).clone());\n             }\n         }\n@@ -1099,29 +1193,17 @@ impl<'a> Rebuilder<'a> {\n \n impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n     fn give_expl_lifetime_param(&self,\n-                                inputs: Vec<ast::Arg>,\n-                                output: ast::P<ast::Ty>,\n-                                item: ast::P<ast::Item>,\n-                                generics: ast::Generics) {\n-        let (fn_decl, fn_style, ident) = match item.node {\n-            // FIXME: handling method\n-            ast::ItemFn(ref fn_decl, ref fn_style, _, _, _) => {\n-                (fn_decl, fn_style, item.ident)\n-            },\n-            _ => fail!(\"Expect function or method\")\n-\n-        };\n-        let fd = ast::FnDecl {\n-            inputs: inputs,\n-            output: output,\n-            cf: fn_decl.cf,\n-            variadic: fn_decl.variadic\n-        };\n-        let suggested_fn =\n-            pprust::fun_to_str(&fd, *fn_style, ident, None, &generics);\n+                                decl: &ast::FnDecl,\n+                                fn_style: ast::FnStyle,\n+                                ident: ast::Ident,\n+                                opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                generics: &ast::Generics,\n+                                span: codemap::Span) {\n+        let suggested_fn = pprust::fun_to_str(decl, fn_style, ident,\n+                                              opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_note(item.span, msg);\n+        self.tcx.sess.span_note(span, msg);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1318,6 +1400,47 @@ impl Resolvable for @ty::TraitRef {\n     }\n }\n \n+fn lifetimes_in_scope(tcx: &ty::ctxt,\n+                      scope_id: ast::NodeId)\n+                      -> Vec<ast::Lifetime> {\n+    let mut taken = Vec::new();\n+    let parent = tcx.map.get_parent(scope_id);\n+    let method_id_opt = match tcx.map.find(parent) {\n+        Some(node) => match node {\n+            ast_map::NodeItem(item) => match item.node {\n+                ast::ItemFn(_, _, _, ref gen, _) => {\n+                    taken.push_all(gen.lifetimes.as_slice());\n+                    None\n+                },\n+                _ => None\n+            },\n+            ast_map::NodeMethod(m) => {\n+                taken.push_all(m.generics.lifetimes.as_slice());\n+                Some(m.id)\n+            },\n+            _ => None\n+        },\n+        None => None\n+    };\n+    if method_id_opt.is_some() {\n+        let method_id = method_id_opt.unwrap();\n+        let parent = tcx.map.get_parent(method_id);\n+        match tcx.map.find(parent) {\n+            Some(node) => match node {\n+                ast_map::NodeItem(item) => match item.node {\n+                    ast::ItemImpl(ref gen, _, _, _) => {\n+                        taken.push_all(gen.lifetimes.as_slice());\n+                    }\n+                    _ => ()\n+                },\n+                _ => ()\n+            },\n+            None => ()\n+        }\n+    }\n+    return taken;\n+}\n+\n // LifeGiver is responsible for generating fresh lifetime names\n struct LifeGiver {\n     taken: HashSet<~str>,\n@@ -1326,7 +1449,6 @@ struct LifeGiver {\n }\n \n impl LifeGiver {\n-    // FIXME: `taken` needs to include names from higher scope, too\n     fn with_taken(taken: &[ast::Lifetime]) -> LifeGiver {\n         let mut taken_ = HashSet::new();\n         for lt in taken.iter() {"}, {"sha": "a210c5d2f0e40c3e5569320f9834cc6d6439837b", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79d1e5df2190e4cfdd1814af95837b21ef046745/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d1e5df2190e4cfdd1814af95837b21ef046745/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=79d1e5df2190e4cfdd1814af95837b21ef046745", "patch": "@@ -22,7 +22,7 @@ impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n }\n \n fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn check<'a, I: Iterator<uint>, T: Itble<'a, uint, I>>(cont: &'a T) -> bool\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &'r T) -> bool\n     let cont_iter = cont.iter(); //~ ERROR: cannot infer\n     let result = cont_iter.fold(Some(0u16), |state, val| {\n         state.map_or(None, |mask| {"}, {"sha": "3328a5d23e62ec1923b89f71cd187d0acdba03ee", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/79d1e5df2190e4cfdd1814af95837b21ef046745/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d1e5df2190e4cfdd1814af95837b21ef046745/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=79d1e5df2190e4cfdd1814af95837b21ef046745", "patch": "@@ -17,7 +17,7 @@ fn foo1(x: &Foo) -> &int {\n }\n \n fn foo2<'a, 'b>(x: &'a Foo) -> &'b int {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo2<'c>(x: &'c Foo) -> &'c int\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo2<'a>(x: &'a Foo) -> &'a int\n     &x.bar //~ ERROR: cannot infer\n }\n \n@@ -28,7 +28,7 @@ fn foo3(x: &Foo) -> (&int, &int) {\n }\n \n fn foo4<'a, 'b>(x: &'a Foo) -> (&'b int, &'a int, &int) {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo4<'c>(x: &'c Foo) -> (&'c int, &'c int, &'c int)\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn foo4<'a>(x: &'a Foo) -> (&'a int, &'a int, &'a int)\n     (&x.bar, &x.bar, &x.bar) //~ ERROR: cannot infer\n     //~^ ERROR: cannot infer\n }\n@@ -48,7 +48,7 @@ fn bar1(x: &Bar) -> (&int, &int, &int) {\n }\n \n fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&int, &int, &int) {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'d, 'e, 'a, 'c>(x: &'e Bar<'a, 'd, 'c>) -> (&'d int, &'e int, &'e int)\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn bar2<'d, 'a, 'b, 'c>(x: &'d Bar<'a, 'b, 'c>) -> (&'b int, &'d int, &'d int)\n     (x.bar, &x.baz, &x.baz) //~ ERROR: mismatched types\n     //~^ ERROR: cannot infer\n     //~^^ ERROR: cannot infer\n@@ -62,8 +62,28 @@ fn cat<'x>(x: Cat<'x, Dog>) -> &int {\n }\n \n fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &int {\n-//~^ NOTE: consider using an explicit lifetime parameter as shown: fn cat2<'a, 'x>(x: Cat<'x, Dog<'a>>) -> &'a int\n+//~^ NOTE: consider using an explicit lifetime parameter as shown: fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'y int\n     x.t.dog //~ ERROR: mismatched types\n }\n \n+struct Baz<'x> {\n+    bar: &'x int\n+}\n+\n+impl<'x> Baz<'x> {\n+    fn baz1(&self) -> &int {\n+    //~^ NOTE: consider using an explicit lifetime parameter as shown: fn baz1(&self) -> &'x int\n+        self.bar //~ ERROR: mismatched types\n+    }\n+}\n+\n+impl<'a> Baz<'a> {\n+    fn baz2(&self, x: &int) -> (&int, &int) {\n+    //~^ NOTE: consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'b int) -> (&'a int, &'b int)\n+        (self.bar, x) //~ ERROR: cannot infer\n+        //~^ ERROR: mismatched types\n+        //~^^ ERROR: mismatched types\n+    }\n+}\n+\n fn main() {}"}]}