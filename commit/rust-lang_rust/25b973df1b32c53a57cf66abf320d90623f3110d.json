{"sha": "25b973df1b32c53a57cf66abf320d90623f3110d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Yjk3M2RmMWIzMmM1M2E1N2NmNjZhYmYzMjBkOTA2MjNmMzExMGQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-30T18:39:35Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-30T18:39:35Z"}, "message": "Finish support for typechecking and translating records. Un-XFAIL rec.rs.", "tree": {"sha": "46c8c7ca57c40dcb765bfcf79d6aebb8a4d4b3ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c8c7ca57c40dcb765bfcf79d6aebb8a4d4b3ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25b973df1b32c53a57cf66abf320d90623f3110d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25b973df1b32c53a57cf66abf320d90623f3110d", "html_url": "https://github.com/rust-lang/rust/commit/25b973df1b32c53a57cf66abf320d90623f3110d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25b973df1b32c53a57cf66abf320d90623f3110d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c426521ee63390a94a2f7660a0dd61c5e978540", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c426521ee63390a94a2f7660a0dd61c5e978540", "html_url": "https://github.com/rust-lang/rust/commit/9c426521ee63390a94a2f7660a0dd61c5e978540"}], "stats": {"total": 79, "additions": 79, "deletions": 0}, "files": [{"sha": "f41ea356943a509de6b04b8c629b82b37a56b59b", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25b973df1b32c53a57cf66abf320d90623f3110d/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/25b973df1b32c53a57cf66abf320d90623f3110d/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=25b973df1b32c53a57cf66abf320d90623f3110d", "patch": "@@ -534,6 +534,7 @@ TEST_XFAILS_SELF := $(filter-out \\\n                         item-name-overload.rs \\\n                         lazy-init.rs \\\n                         multiline-comment.rs \\\n+                        rec.rs \\\n                         return-nil.rs \\\n                         tup.rs \\\n                         u32-decr.rs \\"}, {"sha": "d5b738264f07b8c785374dbb45ed1924be4c186c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25b973df1b32c53a57cf66abf320d90623f3110d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b973df1b32c53a57cf66abf320d90623f3110d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=25b973df1b32c53a57cf66abf320d90623f3110d", "patch": "@@ -280,6 +280,13 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n             }\n             ret T_struct(tys);\n         }\n+        case (typeck.ty_rec(?fields)) {\n+            let vec[TypeRef] tys = vec();\n+            for (typeck.field f in fields) {\n+                tys += type_of(cx, f.ty);\n+            }\n+            ret T_struct(tys);\n+        }\n         case (typeck.ty_fn(?args, ?out)) {\n             let vec[TypeRef] atys = vec(T_taskptr());\n             for (typeck.arg arg in args) {\n@@ -1106,6 +1113,12 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n             auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n             ret tup(res(r.bcx, v), lv._1);\n         }\n+        case (typeck.ty_rec(?fields)) {\n+            let uint ix = typeck.field_idx(cx.fcx.ccx.sess, sp,\n+                                           field, fields);\n+            auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n+            ret tup(res(r.bcx, v), lv._1);\n+        }\n     }\n     cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\");\n     fail;\n@@ -1201,6 +1214,23 @@ impure fn trans_tup(@block_ctxt cx, vec[tup(ast.mutability, @ast.expr)] args,\n     ret res(r.bcx, tup_val);\n }\n \n+impure fn trans_rec(@block_ctxt cx, vec[tup(ast.ident, @ast.expr)] args,\n+                    &ast.ann ann) -> result {\n+    auto ty = node_type(cx.fcx.ccx, ann);\n+    auto tup_val = cx.build.Alloca(ty);\n+    let int i = 0;\n+    auto r = res(cx, C_nil());\n+    for (tup(ast.ident, @ast.expr) arg in args) {\n+        auto t = typeck.expr_ty(arg._1);\n+        auto src_res = trans_expr(r.bcx, arg._1);\n+        auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));\n+        // FIXME: calculate copy init-ness in typestate.\n+        r = copy_ty(src_res.bcx, true, dst_elt, src_res.val, t);\n+        i += 1;\n+    }\n+    ret res(r.bcx, tup_val);\n+}\n+\n \n \n impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n@@ -1261,6 +1291,10 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_tup(cx, args, ann);\n         }\n \n+        case (ast.expr_rec(?args, ?ann)) {\n+            ret trans_rec(cx, args, ann);\n+        }\n+\n         // lval cases fall through to trans_lval and then\n         // possibly load the result (if it's non-structural).\n "}, {"sha": "78dff420ab728c76a26c31c799ce4ec61922524d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/25b973df1b32c53a57cf66abf320d90623f3110d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25b973df1b32c53a57cf66abf320d90623f3110d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=25b973df1b32c53a57cf66abf320d90623f3110d", "patch": "@@ -474,6 +474,19 @@ fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n     ret accum;\n }\n \n+fn field_idx(session.session sess, &span sp,\n+             &ast.ident id, vec[field] fields) -> uint {\n+    let uint i = 0u;\n+    for (field f in fields) {\n+        if (_str.eq(f.label, id)) {\n+            ret i;\n+        }\n+        i += 1u;\n+    }\n+    sess.span_err(sp, \"unknown field '\" + id + \"' of record\");\n+    fail;\n+}\n+\n // Type utilities\n \n // FIXME: remove me when == works on these tags.\n@@ -1346,6 +1359,22 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_tup(args_1, ann));\n         }\n \n+        case (ast.expr_rec(?args, _)) {\n+            let vec[tup(ast.ident, @ast.expr)] args_1 = vec();\n+            let vec[field] args_t = vec();\n+\n+            for (tup(ast.ident, @ast.expr) arg in args) {\n+                auto expr_1 = check_expr(fcx, arg._1);\n+                args_1 += tup(arg._0, expr_1);\n+                append[field](args_t,rec(label=arg._0,\n+                                         ty=expr_ty(expr_1)));\n+            }\n+\n+            auto ann = ast.ann_type(plain_ty(ty_rec(args_t)));\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_rec(args_1, ann));\n+        }\n+\n         case (ast.expr_field(?base, ?field, _)) {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = expr_ty(base_1);\n@@ -1363,6 +1392,21 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                                field,\n                                                                ann));\n                 }\n+\n+                case (ty_rec(?fields)) {\n+                    let uint ix = field_idx(fcx.ccx.sess,\n+                                            expr.span, field, fields);\n+                    if (ix >= _vec.len[typeck.field](fields)) {\n+                        fcx.ccx.sess.span_err(expr.span,\n+                                              \"bad index on record\");\n+                    }\n+                    auto ann = ast.ann_type(fields.(ix).ty);\n+                    ret @fold.respan[ast.expr_](expr.span,\n+                                                ast.expr_field(base_1,\n+                                                               field,\n+                                                               ann));\n+                }\n+\n                 case (_) {\n                     fcx.ccx.sess.unimpl(\"base type for expr_field \"\n                                         + \"in typeck.check_expr: \""}]}