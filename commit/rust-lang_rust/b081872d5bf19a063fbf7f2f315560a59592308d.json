{"sha": "b081872d5bf19a063fbf7f2f315560a59592308d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODE4NzJkNWJmMTlhMDYzZmJmN2YyZjMxNTU2MGE1OTU5MjMwOGQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-12-28T20:16:19Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-01-28T14:38:17Z"}, "message": "Implement `PartialEq<&[A]>` for `VecDeque<A>`.\n\nFixes https://github.com/rust-lang/rust/issues/38625.", "tree": {"sha": "0c90cd9141cd63f3906f52a44b6414e88ae13540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c90cd9141cd63f3906f52a44b6414e88ae13540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b081872d5bf19a063fbf7f2f315560a59592308d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b081872d5bf19a063fbf7f2f315560a59592308d", "html_url": "https://github.com/rust-lang/rust/commit/b081872d5bf19a063fbf7f2f315560a59592308d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b081872d5bf19a063fbf7f2f315560a59592308d/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "010c3e25c453d0217b114aa125a956cd99f60c88", "url": "https://api.github.com/repos/rust-lang/rust/commits/010c3e25c453d0217b114aa125a956cd99f60c88", "html_url": "https://github.com/rust-lang/rust/commit/010c3e25c453d0217b114aa125a956cd99f60c88"}], "stats": {"total": 129, "additions": 93, "deletions": 36}, "files": [{"sha": "5e1adb3d808ce1bb71cd0d38d7fdf618a9d5f589", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 74, "deletions": 36, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b081872d5bf19a063fbf7f2f315560a59592308d/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b081872d5bf19a063fbf7f2f315560a59592308d/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=b081872d5bf19a063fbf7f2f315560a59592308d", "patch": "@@ -469,9 +469,9 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n+    /// assert_eq!(buf, [3, 4, 5]);\n     /// buf.swap(0, 2);\n-    /// assert_eq!(buf[0], 5);\n-    /// assert_eq!(buf[2], 3);\n+    /// assert_eq!(buf, [5, 4, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&mut self, i: usize, j: usize) {\n@@ -649,9 +649,9 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n+    /// assert_eq!(buf, [5, 10, 15]);\n     /// buf.truncate(1);\n-    /// assert_eq!(buf.len(), 1);\n-    /// assert_eq!(Some(&5), buf.get(0));\n+    /// assert_eq!(buf, [5]);\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n@@ -826,8 +826,9 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n-    /// assert_eq!(vec![3].into_iter().collect::<VecDeque<_>>(), v.drain(2..).collect());\n-    /// assert_eq!(vec![1, 2].into_iter().collect::<VecDeque<_>>(), v);\n+    /// let drained = v.drain(2..).collect::<VecDeque<_>>();\n+    /// assert_eq!(drained, [3]);\n+    /// assert_eq!(v, [1, 2]);\n     ///\n     /// // A full range clears all contents\n     /// v.drain(..);\n@@ -1179,11 +1180,10 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n+    /// assert_eq!(buf, [1, 2, 3]);\n     ///\n     /// assert_eq!(buf.swap_remove_back(0), Some(1));\n-    /// assert_eq!(buf.len(), 2);\n-    /// assert_eq!(buf[0], 3);\n-    /// assert_eq!(buf[1], 2);\n+    /// assert_eq!(buf, [3, 2]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n@@ -1215,11 +1215,10 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n+    /// assert_eq!(buf, [1, 2, 3]);\n     ///\n     /// assert_eq!(buf.swap_remove_front(2), Some(3));\n-    /// assert_eq!(buf.len(), 2);\n-    /// assert_eq!(buf[0], 2);\n-    /// assert_eq!(buf[1], 1);\n+    /// assert_eq!(buf, [2, 1]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n@@ -1250,11 +1249,10 @@ impl<T> VecDeque<T> {\n     /// vec_deque.push_back('a');\n     /// vec_deque.push_back('b');\n     /// vec_deque.push_back('c');\n+    /// assert_eq!(vec_deque, &['a', 'b', 'c']);\n     ///\n     /// vec_deque.insert(1, 'd');\n-    ///\n-    /// let vec = vec_deque.into_iter().collect::<Vec<_>>();\n-    /// assert_eq!(vec, ['a', 'd', 'b', 'c']);\n+    /// assert_eq!(vec_deque, &['a', 'd', 'b', 'c']);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n@@ -1478,9 +1476,10 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n+    /// assert_eq!(buf, [1, 2, 3]);\n     ///\n     /// assert_eq!(buf.remove(1), Some(2));\n-    /// assert_eq!(buf.get(1), Some(&3));\n+    /// assert_eq!(buf, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> Option<T> {\n@@ -1659,9 +1658,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n     /// let buf2 = buf.split_off(1);\n-    /// // buf = [1], buf2 = [2, 3]\n-    /// assert_eq!(buf.len(), 1);\n-    /// assert_eq!(buf2.len(), 2);\n+    /// assert_eq!(buf, [1]);\n+    /// assert_eq!(buf2, [2, 3]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n@@ -1718,11 +1716,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let mut buf2: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1, 2].into_iter().collect();\n+    /// let mut buf2: VecDeque<_> = vec![3, 4].into_iter().collect();\n     /// buf.append(&mut buf2);\n-    /// assert_eq!(buf.len(), 6);\n-    /// assert_eq!(buf2.len(), 0);\n+    /// assert_eq!(buf, [1, 2, 3, 4]);\n+    /// assert_eq!(buf2, []);\n     /// ```\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n@@ -1745,9 +1743,7 @@ impl<T> VecDeque<T> {\n     /// let mut buf = VecDeque::new();\n     /// buf.extend(1..5);\n     /// buf.retain(|&x| x%2 == 0);\n-    ///\n-    /// let v: Vec<_> = buf.into_iter().collect();\n-    /// assert_eq!(&v[..], &[2, 4]);\n+    /// assert_eq!(buf, [2, 4]);\n     /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n@@ -1781,11 +1777,13 @@ impl<T: Clone> VecDeque<T> {\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n+    /// assert_eq!(buf, [5, 10, 15]);\n+    ///\n     /// buf.resize(2, 0);\n-    /// buf.resize(6, 20);\n-    /// for (a, b) in [5, 10, 20, 20, 20, 20].iter().zip(&buf) {\n-    ///     assert_eq!(a, b);\n-    /// }\n+    /// assert_eq!(buf, [5, 10]);\n+    ///\n+    /// buf.resize(5, 20);\n+    /// assert_eq!(buf, [5, 10, 20, 20, 20]);\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n@@ -2162,6 +2160,46 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for VecDeque<A> {}\n \n+macro_rules! __impl_slice_eq1 {\n+    ($Lhs: ty, $Rhs: ty) => {\n+        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n+    };\n+    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+        #[stable(feature = \"vec-deque-partial-eq-slice\", since = \"1.16.0\")]\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+            fn eq(&self, other: &$Rhs) -> bool {\n+                if self.len() != other.len() {\n+                    return false;\n+                }\n+                let (sa, sb) = self.as_slices();\n+                let (oa, ob) = other[..].split_at(sa.len());\n+                sa == oa && sb == ob\n+            }\n+        }\n+    }\n+}\n+\n+__impl_slice_eq1! { VecDeque<A>, Vec<B> }\n+__impl_slice_eq1! { VecDeque<A>, &'b [B] }\n+__impl_slice_eq1! { VecDeque<A>, &'b mut [B] }\n+\n+macro_rules! array_impls {\n+    ($($N: expr)+) => {\n+        $(\n+            __impl_slice_eq1! { VecDeque<A>, [B; $N] }\n+            __impl_slice_eq1! { VecDeque<A>, &'b [B; $N] }\n+            __impl_slice_eq1! { VecDeque<A>, &'b mut [B; $N] }\n+        )+\n+    }\n+}\n+\n+array_impls! {\n+     0  1  2  3  4  5  6  7  8  9\n+    10 11 12 13 14 15 16 17 18 19\n+    20 21 22 23 24 25 26 27 28 29\n+    30 31 32\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n     fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n@@ -2434,7 +2472,7 @@ mod tests {\n             let final_len = usable_cap / 2;\n \n             for len in 0..final_len {\n-                let expected = if back {\n+                let expected: VecDeque<_> = if back {\n                     (0..len).collect()\n                 } else {\n                     (0..len).rev().collect()\n@@ -2483,7 +2521,7 @@ mod tests {\n         // len is the length *after* insertion\n         for len in 1..cap {\n             // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect();\n+            let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..cap {\n                 for to_insert in 0..len {\n                     tester.tail = tail_pos;\n@@ -2516,7 +2554,7 @@ mod tests {\n         // len is the length *after* removal\n         for len in 0..cap - 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect();\n+            let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..cap {\n                 for to_remove in 0..len + 1 {\n                     tester.tail = tail_pos;\n@@ -2591,7 +2629,7 @@ mod tests {\n \n         for len in 0..cap + 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect();\n+            let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..max_cap + 1 {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -2624,9 +2662,9 @@ mod tests {\n             // index to split at\n             for at in 0..len + 1 {\n                 // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = (0..).take(at).collect();\n+                let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n                 // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = (at..).take(len - at).collect();\n+                let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n \n                 for tail_pos in 0..cap {\n                     tester.tail = tail_pos;"}, {"sha": "bb60f888f8be6e80521610fc89fa3fb290d8c809", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b081872d5bf19a063fbf7f2f315560a59592308d/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b081872d5bf19a063fbf7f2f315560a59592308d/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=b081872d5bf19a063fbf7f2f315560a59592308d", "patch": "@@ -603,6 +603,25 @@ fn test_eq() {\n     assert!(e == VecDeque::new());\n }\n \n+#[test]\n+fn test_partial_eq_array() {\n+    let d = VecDeque::<char>::new();\n+    assert!(d == []);\n+\n+    let mut d = VecDeque::new();\n+    d.push_front('a');\n+    assert!(d == ['a']);\n+\n+    let mut d = VecDeque::new();\n+    d.push_back('a');\n+    assert!(d == ['a']);\n+\n+    let mut d = VecDeque::new();\n+    d.push_back('a');\n+    d.push_back('b');\n+    assert!(d == ['a', 'b']);\n+}\n+\n #[test]\n fn test_hash() {\n     let mut x = VecDeque::new();"}]}