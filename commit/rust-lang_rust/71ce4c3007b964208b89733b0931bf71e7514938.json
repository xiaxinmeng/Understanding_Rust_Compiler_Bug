{"sha": "71ce4c3007b964208b89733b0931bf71e7514938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxY2U0YzMwMDdiOTY0MjA4Yjg5NzMzYjA5MzFiZjcxZTc1MTQ5Mzg=", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2017-11-29T21:42:25Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2018-10-30T18:06:07Z"}, "message": "Fix DWARF generation for enums\n\nThe DWARF generated for Rust enums was always somewhat unusual.\nRather than using DWARF constructs directly, it would emit magic field\nnames like \"RUST$ENCODED$ENUM$0$Name\" and \"RUST$ENUM$DISR\".  Since\nPR #45225, though, even this has not worked -- the ad hoc scheme was\nnot updated to handle the wider variety of niche-filling layout\noptimizations now available.\n\nThis patch changes the generated DWARF to use the standard tags meant\nfor this purpose; namely, DW_TAG_variant and DW_TAG_variant_part.\n\nThe patch to implement this went in to LLVM 7.  In order to work with\nolder versions of LLVM, and because LLVM doesn't do anything here for\nPDB, the existing code is kept as a fallback mode.\n\nSupport for this DWARF is in the Rust lldb and in gdb 8.2.\n\nCloses #32920\nCloses #32924\nCloses #52762\nCloses #53153", "tree": {"sha": "f14df6bdfddd9b6040c448112ba71882719557d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f14df6bdfddd9b6040c448112ba71882719557d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71ce4c3007b964208b89733b0931bf71e7514938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71ce4c3007b964208b89733b0931bf71e7514938", "html_url": "https://github.com/rust-lang/rust/commit/71ce4c3007b964208b89733b0931bf71e7514938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71ce4c3007b964208b89733b0931bf71e7514938/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8aef7cae14bc7a56859408c90253e9bcc07fcff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8aef7cae14bc7a56859408c90253e9bcc07fcff", "html_url": "https://github.com/rust-lang/rust/commit/e8aef7cae14bc7a56859408c90253e9bcc07fcff"}], "stats": {"total": 643, "additions": 495, "deletions": 148}, "files": [{"sha": "6290f5c8e67ea234cd35b9806321d3c2ecb8b6c1", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 379, "deletions": 144, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/71ce4c3007b964208b89733b0931bf71e7514938/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ce4c3007b964208b89733b0931bf71e7514938/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=71ce4c3007b964208b89733b0931bf71e7514938", "patch": "@@ -31,9 +31,9 @@ use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n-use common::CodegenCx;\n+use common::{CodegenCx, C_u64};\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, PrimitiveExt, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, Integer, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout};\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n use rustc_fs_util::path2cstr;\n@@ -205,6 +205,7 @@ enum RecursiveTypeDescription<'ll, 'tcx> {\n         unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n         metadata_stub: &'ll DICompositeType,\n+        member_holding_stub: &'ll DICompositeType,\n         member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n     },\n     FinalMetadata(&'ll DICompositeType)\n@@ -215,6 +216,7 @@ fn create_and_register_recursive_type_forward_declaration(\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: &'ll DICompositeType,\n+    member_holding_stub: &'ll DICompositeType,\n     member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n \n@@ -227,6 +229,7 @@ fn create_and_register_recursive_type_forward_declaration(\n         unfinished_type,\n         unique_type_id,\n         metadata_stub,\n+        member_holding_stub,\n         member_description_factory,\n     }\n }\n@@ -242,6 +245,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                 unfinished_type,\n                 unique_type_id,\n                 metadata_stub,\n+                member_holding_stub,\n                 ref member_description_factory,\n             } => {\n                 // Make sure that we have a forward declaration of the type in\n@@ -266,7 +270,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n-                                              metadata_stub,\n+                                              member_holding_stub,\n                                               member_descriptions);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n@@ -350,6 +354,7 @@ fn vec_slice_metadata(\n             size: pointer_size,\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n+            discriminant: None,\n         },\n         MemberDescription {\n             name: \"length\".to_owned(),\n@@ -358,6 +363,7 @@ fn vec_slice_metadata(\n             size: usize_size,\n             align: usize_align,\n             flags: DIFlags::FlagZero,\n+            discriminant: None,\n         },\n     ];\n \n@@ -458,6 +464,7 @@ fn trait_pointer_metadata(\n             size: data_ptr_field.size,\n             align: data_ptr_field.align,\n             flags: DIFlags::FlagArtificial,\n+            discriminant: None,\n         },\n         MemberDescription {\n             name: \"vtable\".to_owned(),\n@@ -466,6 +473,7 @@ fn trait_pointer_metadata(\n             size: vtable_field.size,\n             align: vtable_field.align,\n             flags: DIFlags::FlagArtificial,\n+            discriminant: None,\n         },\n     ];\n \n@@ -914,6 +922,7 @@ struct MemberDescription<'ll> {\n     size: Size,\n     align: Align,\n     flags: DIFlags,\n+    discriminant: Option<u64>,\n }\n \n // A factory for MemberDescriptions. It produces a list of member descriptions\n@@ -981,6 +990,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1013,6 +1023,7 @@ fn prepare_struct_metadata(\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n+        struct_metadata_stub,\n         StructMDF(StructMemberDescriptionFactory {\n             ty: struct_type,\n             variant,\n@@ -1045,6 +1056,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1059,15 +1071,18 @@ fn prepare_tuple_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n \n+    let struct_stub = create_struct_stub(cx,\n+                                         tuple_type,\n+                                         &tuple_name[..],\n+                                         unique_type_id,\n+                                         NO_SCOPE_METADATA);\n+\n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         tuple_type,\n         unique_type_id,\n-        create_struct_stub(cx,\n-                           tuple_type,\n-                           &tuple_name[..],\n-                           unique_type_id,\n-                           NO_SCOPE_METADATA),\n+        struct_stub,\n+        struct_stub,\n         TupleMDF(TupleMemberDescriptionFactory {\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n@@ -1099,6 +1114,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1130,6 +1146,7 @@ fn prepare_union_metadata(\n         union_type,\n         unique_type_id,\n         union_metadata_stub,\n+        union_metadata_stub,\n         UnionMDF(UnionMemberDescriptionFactory {\n             layout: cx.layout_of(union_type),\n             variant,\n@@ -1142,6 +1159,20 @@ fn prepare_union_metadata(\n // Enums\n //=-----------------------------------------------------------------------------\n \n+// DWARF variant support is only available starting in LLVM 7.\n+// Although the earlier enum debug info output did not work properly\n+// in all situations, it is better for the time being to continue to\n+// sometimes emit the old style rather than emit something completely\n+// useless when rust is compiled against LLVM 6 or older.  This\n+// function decides which representation will be emitted.\n+fn use_enum_fallback(cx: &CodegenCx) -> bool {\n+    // On MSVC we have to use the fallback mode, because LLVM doesn't\n+    // lower variant parts to PDB.\n+    return cx.sess().target.target.options.is_like_msvc || unsafe {\n+        llvm::LLVMRustVersionMajor() < 7\n+    };\n+}\n+\n // Describes the members of an enum value: An enum is described as a union of\n // structs in DWARF. This MemberDescriptionFactory provides the description for\n // the members of this union; so for every variant of the given enum, this\n@@ -1159,6 +1190,15 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n+\n+        // This will always find the metadata in the type map.\n+        let fallback = use_enum_fallback(cx);\n+        let self_metadata = if fallback {\n+            self.containing_scope\n+        } else {\n+            type_metadata(cx, self.enum_type, self.span)\n+        };\n+\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n             layout::Variants::Single { index } => {\n@@ -1167,7 +1207,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                           self.layout,\n                                           &adt.variants[index],\n                                           NoDiscriminant,\n-                                          self.containing_scope,\n+                                          self_metadata,\n                                           self.span);\n \n                 let member_descriptions =\n@@ -1178,26 +1218,36 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                               member_descriptions);\n                 vec![\n                     MemberDescription {\n-                        name: String::new(),\n+                        name: if fallback {\n+                            String::new()\n+                        } else {\n+                            adt.variants[index].name.as_str().to_string()\n+                        },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n                         size: self.layout.size,\n                         align: self.layout.align,\n-                        flags: DIFlags::FlagZero\n+                        flags: DIFlags::FlagZero,\n+                        discriminant: None,\n                     }\n                 ]\n             }\n             layout::Variants::Tagged { ref variants, .. } => {\n-                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n-                    .expect(\"\"));\n+                let discriminant_info = if fallback {\n+                    RegularDiscriminant(self.discriminant_type_metadata\n+                                        .expect(\"\"))\n+                } else {\n+                    // This doesn't matter in this case.\n+                    NoDiscriminant\n+                };\n                 (0..variants.len()).map(|i| {\n                     let variant = self.layout.for_variant(cx, i);\n                     let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n                                               &adt.variants[i],\n                                               discriminant_info,\n-                                              self.containing_scope,\n+                                              self_metadata,\n                                               self.span);\n \n                     let member_descriptions = member_desc_factory\n@@ -1207,75 +1257,124 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                                   variant_type_metadata,\n                                                   member_descriptions);\n                     MemberDescription {\n-                        name: String::new(),\n+                        name: if fallback {\n+                            String::new()\n+                        } else {\n+                            adt.variants[i].name.as_str().to_string()\n+                        },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align,\n-                        flags: DIFlags::FlagZero\n+                        size: self.layout.size,\n+                        align: self.layout.align,\n+                        flags: DIFlags::FlagZero,\n+                        discriminant: Some(self.layout.ty.ty_adt_def().unwrap()\n+                                           .discriminant_for_variant(cx.tcx, i)\n+                                           .val as u64),\n                     }\n                 }).collect()\n             }\n-            layout::Variants::NicheFilling { dataful_variant, ref niche_variants, .. } => {\n-                let variant = self.layout.for_variant(cx, dataful_variant);\n-                // Create a description of the non-null variant\n-                let (variant_type_metadata, member_description_factory) =\n-                    describe_enum_variant(cx,\n-                                          variant,\n-                                          &adt.variants[dataful_variant],\n-                                          OptimizedDiscriminant,\n-                                          self.containing_scope,\n-                                          self.span);\n+            layout::Variants::NicheFilling {\n+                ref niche_variants,\n+                niche_start,\n+                ref variants,\n+                dataful_variant,\n+                ..\n+            } => {\n+                if fallback {\n+                    let variant = self.layout.for_variant(cx, dataful_variant);\n+                    // Create a description of the non-null variant\n+                    let (variant_type_metadata, member_description_factory) =\n+                        describe_enum_variant(cx,\n+                                              variant,\n+                                              &adt.variants[dataful_variant],\n+                                              OptimizedDiscriminant,\n+                                              self.containing_scope,\n+                                              self.span);\n \n-                let variant_member_descriptions =\n-                    member_description_factory.create_member_descriptions(cx);\n+                    let variant_member_descriptions =\n+                        member_description_factory.create_member_descriptions(cx);\n \n-                set_members_of_composite_type(cx,\n-                                              variant_type_metadata,\n-                                              variant_member_descriptions);\n-\n-                // Encode the information about the null variant in the union\n-                // member's name.\n-                let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n-                // HACK(eddyb) the debuggers should just handle offset+size\n-                // of discriminant instead of us having to recover its path.\n-                // Right now it's not even going to work for `niche_start > 0`,\n-                // and for multiple niche variants it only supports the first.\n-                fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                                                name: &mut String,\n-                                                layout: TyLayout<'tcx>,\n-                                                offset: Size,\n-                                                size: Size) {\n-                    for i in 0..layout.fields.count() {\n-                        let field_offset = layout.fields.offset(i);\n-                        if field_offset > offset {\n-                            continue;\n-                        }\n-                        let inner_offset = offset - field_offset;\n-                        let field = layout.field(cx, i);\n-                        if inner_offset + size <= field.size {\n-                            write!(name, \"{}$\", i).unwrap();\n-                            compute_field_path(cx, name, field, inner_offset, size);\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  variant_member_descriptions);\n+\n+                    // Encode the information about the null variant in the union\n+                    // member's name.\n+                    let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n+                    // Right now it's not even going to work for `niche_start > 0`,\n+                    // and for multiple niche variants it only supports the first.\n+                    fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n+                                                    name: &mut String,\n+                                                    layout: TyLayout<'tcx>,\n+                                                    offset: Size,\n+                                                    size: Size) {\n+                        for i in 0..layout.fields.count() {\n+                            let field_offset = layout.fields.offset(i);\n+                            if field_offset > offset {\n+                                continue;\n+                            }\n+                            let inner_offset = offset - field_offset;\n+                            let field = layout.field(cx, i);\n+                            if inner_offset + size <= field.size {\n+                                write!(name, \"{}$\", i).unwrap();\n+                                compute_field_path(cx, name, field, inner_offset, size);\n+                            }\n                         }\n                     }\n+                    compute_field_path(cx, &mut name,\n+                                       self.layout,\n+                                       self.layout.fields.offset(0),\n+                                       self.layout.field(cx, 0).size);\n+                    name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n+\n+                    // Create the (singleton) list of descriptions of union members.\n+                    vec![\n+                        MemberDescription {\n+                            name,\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: variant.size,\n+                            align: variant.align,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                        }\n+                    ]\n+                } else {\n+                    (0..variants.len()).map(|i| {\n+                        let variant = self.layout.for_variant(cx, i);\n+                        let (variant_type_metadata, member_desc_factory) =\n+                            describe_enum_variant(cx,\n+                                                  variant,\n+                                                  &adt.variants[i],\n+                                                  OptimizedDiscriminant,\n+                                                  self_metadata,\n+                                                  self.span);\n+\n+                        let member_descriptions = member_desc_factory\n+                            .create_member_descriptions(cx);\n+\n+                        set_members_of_composite_type(cx,\n+                                                      variant_type_metadata,\n+                                                      member_descriptions);\n+\n+                        let niche_value = if i == dataful_variant {\n+                            None\n+                        } else {\n+                            Some((i.wrapping_sub(*niche_variants.start()) as u128)\n+                                 .wrapping_add(niche_start) as u64)\n+                        };\n+\n+                        MemberDescription {\n+                            name: adt.variants[i].name.as_str().to_string(),\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: niche_value,\n+                        }\n+                    }).collect()\n                 }\n-                compute_field_path(cx, &mut name,\n-                                   self.layout,\n-                                   self.layout.fields.offset(0),\n-                                   self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n-\n-                // Create the (singleton) list of descriptions of union members.\n-                vec![\n-                    MemberDescription {\n-                        name,\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align,\n-                        flags: DIFlags::FlagZero\n-                    }\n-                ]\n             }\n         }\n     }\n@@ -1297,14 +1396,19 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n             let (size, align) = cx.size_and_align_of(ty);\n             MemberDescription {\n                 name: name.to_string(),\n-                type_metadata: match self.discriminant_type_metadata {\n-                    Some(metadata) if i == 0 => metadata,\n-                    _ => type_metadata(cx, ty, self.span)\n+                type_metadata: if use_enum_fallback(cx) {\n+                    match self.discriminant_type_metadata {\n+                        Some(metadata) if i == 0 => metadata,\n+                        _ => type_metadata(cx, ty, self.span)\n+                    }\n+                } else {\n+                    type_metadata(cx, ty, self.span)\n                 },\n                 offset: self.offsets[i],\n                 size,\n                 align,\n-                flags: DIFlags::FlagZero\n+                flags: DIFlags::FlagZero,\n+                discriminant: None,\n             }\n         }).collect()\n     }\n@@ -1317,10 +1421,10 @@ enum EnumDiscriminantInfo<'ll> {\n     NoDiscriminant\n }\n \n-// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n-// of the variant, and (3) a MemberDescriptionFactory for producing the\n-// descriptions of the fields of the variant. This is a rudimentary version of a\n-// full RecursiveTypeDescription.\n+// Returns a tuple of (1) type_metadata_stub of the variant, (2) a\n+// MemberDescriptionFactory for producing the descriptions of the\n+// fields of the variant. This is a rudimentary version of a full\n+// RecursiveTypeDescription.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n@@ -1343,29 +1447,46 @@ fn describe_enum_variant(\n                                            unique_type_id,\n                                            Some(containing_scope));\n \n-    // If this is not a univariant enum, there is also the discriminant field.\n-    let (discr_offset, discr_arg) = match discriminant_info {\n-        RegularDiscriminant(_) => {\n-            // We have the layout of an enum variant, we need the layout of the outer enum\n-            let enum_layout = cx.layout_of(layout.ty);\n-            (Some(enum_layout.fields.offset(0)),\n-             Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n-        }\n-        _ => (None, None),\n-    };\n-    let offsets = discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n-        layout.fields.offset(i)\n-    })).collect();\n-\n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args = discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n-        let name = if variant.ctor_kind == CtorKind::Fn {\n-            format!(\"__{}\", i)\n-        } else {\n-            variant.fields[i].ident.to_string()\n+    let (offsets, args) = if use_enum_fallback(cx) {\n+        // If this is not a univariant enum, there is also the discriminant field.\n+        let (discr_offset, discr_arg) = match discriminant_info {\n+            RegularDiscriminant(_) => {\n+                // We have the layout of an enum variant, we need the layout of the outer enum\n+                let enum_layout = cx.layout_of(layout.ty);\n+                (Some(enum_layout.fields.offset(0)),\n+                 Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n+            }\n+            _ => (None, None),\n         };\n-        (name, layout.field(cx, i).ty)\n-    })).collect();\n+        (\n+            discr_offset.into_iter().chain((0..layout.fields.count()).map(|i| {\n+                layout.fields.offset(i)\n+            })).collect(),\n+            discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n+                let name = if variant.ctor_kind == CtorKind::Fn {\n+                    format!(\"__{}\", i)\n+                } else {\n+                    variant.fields[i].ident.to_string()\n+                };\n+                (name, layout.field(cx, i).ty)\n+            })).collect()\n+        )\n+    } else {\n+        (\n+            (0..layout.fields.count()).map(|i| {\n+                layout.fields.offset(i)\n+            }).collect(),\n+            (0..layout.fields.count()).map(|i| {\n+                let name = if variant.ctor_kind == CtorKind::Fn {\n+                    format!(\"__{}\", i)\n+                } else {\n+                    variant.fields[i].ident.to_string()\n+                };\n+                (name, layout.field(cx, i).ty)\n+            }).collect()\n+        )\n+    };\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {\n@@ -1401,22 +1522,22 @@ fn prepare_enum_metadata(\n     // <unknown>\n     let file_metadata = unknown_file_metadata(cx);\n \n-    let def = enum_type.ty_adt_def().unwrap();\n-    let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n-        .zip(&def.variants)\n-        .map(|(discr, v)| {\n-            let name = SmallCStr::new(&v.name.as_str());\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    name.as_ptr(),\n-                    // FIXME: what if enumeration has i128 discriminant?\n-                    discr.val as u64))\n-            }\n-        })\n-        .collect();\n-\n     let discriminant_type_metadata = |discr: layout::Primitive| {\n+        let def = enum_type.ty_adt_def().unwrap();\n+        let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n+            .zip(&def.variants)\n+            .map(|(discr, v)| {\n+                let name = SmallCStr::new(&v.name.as_str());\n+                unsafe {\n+                    Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                        DIB(cx),\n+                        name.as_ptr(),\n+                        // FIXME: what if enumeration has i128 discriminant?\n+                        discr.val as u64))\n+                }\n+            })\n+            .collect();\n+\n         let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n@@ -1441,7 +1562,7 @@ fn prepare_enum_metadata(\n                         discriminant_size.bits(),\n                         discriminant_align.abi_bits() as u32,\n                         create_DIArray(DIB(cx), &enumerators_metadata),\n-                        discriminant_base_type_metadata)\n+                        discriminant_base_type_metadata, true)\n                 };\n \n                 debug_context(cx).created_enum_disr_types\n@@ -1455,16 +1576,10 @@ fn prepare_enum_metadata(\n \n     let layout = cx.layout_of(enum_type);\n \n-    let discriminant_type_metadata = match layout.variants {\n-        layout::Variants::Single { .. } |\n-        layout::Variants::NicheFilling { .. } => None,\n-        layout::Variants::Tagged { ref tag, .. } => {\n-            Some(discriminant_type_metadata(tag.value))\n-        }\n-    };\n-\n-    if let (&layout::Abi::Scalar(_), Some(discr)) = (&layout.abi, discriminant_type_metadata) {\n-        return FinalMetadata(discr);\n+    match (&layout.abi, &layout.variants) {\n+        (&layout::Abi::Scalar(_), &layout::Variants::Tagged {ref tag, .. }) =>\n+            return FinalMetadata(discriminant_type_metadata(tag.value)),\n+        _ => {}\n     }\n \n     let (enum_type_size, enum_type_align) = layout.size_and_align();\n@@ -1473,30 +1588,146 @@ fn prepare_enum_metadata(\n     let unique_type_id_str = SmallCStr::new(\n         debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n     );\n-    let enum_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateUnionType(\n-        DIB(cx),\n-        containing_scope,\n-        enum_name.as_ptr(),\n-        file_metadata,\n-        UNKNOWN_LINE_NUMBER,\n-        enum_type_size.bits(),\n-        enum_type_align.abi_bits() as u32,\n-        DIFlags::FlagZero,\n-        None,\n-        0, // RuntimeLang\n-        unique_type_id_str.as_ptr())\n+\n+    if use_enum_fallback(cx) {\n+        let discriminant_type_metadata = match layout.variants {\n+            layout::Variants::Single { .. } |\n+            layout::Variants::NicheFilling { .. } => None,\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                Some(discriminant_type_metadata(tag.value))\n+            }\n+        };\n+\n+        let enum_metadata = unsafe {\n+            llvm::LLVMRustDIBuilderCreateUnionType(\n+                DIB(cx),\n+                containing_scope,\n+                enum_name.as_ptr(),\n+                file_metadata,\n+                UNKNOWN_LINE_NUMBER,\n+                enum_type_size.bits(),\n+                enum_type_align.abi_bits() as u32,\n+                DIFlags::FlagZero,\n+                None,\n+                0, // RuntimeLang\n+                unique_type_id_str.as_ptr())\n+        };\n+\n+        return create_and_register_recursive_type_forward_declaration(\n+            cx,\n+            enum_type,\n+            unique_type_id,\n+            enum_metadata,\n+            enum_metadata,\n+            EnumMDF(EnumMemberDescriptionFactory {\n+                enum_type,\n+                layout,\n+                discriminant_type_metadata,\n+                containing_scope,\n+                span,\n+            }),\n+        );\n+    }\n+\n+    let discriminator_metadata = match &layout.variants {\n+        // A single-variant enum has no discriminant.\n+        &layout::Variants::Single { .. } => None,\n+\n+        &layout::Variants::NicheFilling { ref niche, .. } => {\n+            // Find the integer type of the correct size.\n+            let discr_type = niche.value.to_ty(cx.tcx);\n+            let (size, align) = cx.size_and_align_of(discr_type);\n+\n+            let discr_type = (match size.bits() {\n+                8 => Integer::I8,\n+                16 => Integer::I16,\n+                32 => Integer::I32,\n+                64 => Integer::I64,\n+                bits => bug!(\"prepare_enum_metadata: unknown niche bit size {}\", bits),\n+            }).to_ty(cx.tcx, false);\n+\n+            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    ptr::null_mut(),\n+                    file_metadata,\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.abi_bits() as u32,\n+                    layout.fields.offset(0).bits(),\n+                    DIFlags::FlagArtificial,\n+                    discr_metadata))\n+            }\n+        },\n+\n+        &layout::Variants::Tagged { ref tag, .. } => {\n+            let discr_type = tag.value.to_ty(cx.tcx);\n+            let (size, align) = cx.size_and_align_of(discr_type);\n+\n+            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    ptr::null_mut(),\n+                    file_metadata,\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.abi_bits() as u32,\n+                    layout.fields.offset(0).bits(),\n+                    DIFlags::FlagArtificial,\n+                    discr_metadata))\n+            }\n+        },\n+    };\n+\n+    let empty_array = create_DIArray(DIB(cx), &[]);\n+    let variant_part = unsafe {\n+        llvm::LLVMRustDIBuilderCreateVariantPart(\n+            DIB(cx),\n+            containing_scope,\n+            ptr::null_mut(),\n+            file_metadata,\n+            UNKNOWN_LINE_NUMBER,\n+            enum_type_size.bits(),\n+            enum_type_align.abi_bits() as u32,\n+            DIFlags::FlagZero,\n+            discriminator_metadata,\n+            empty_array,\n+            unique_type_id_str.as_ptr())\n+    };\n+\n+    // The variant part must be wrapped in a struct according to DWARF.\n+    let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n+    let struct_wrapper = unsafe {\n+        llvm::LLVMRustDIBuilderCreateStructType(\n+            DIB(cx),\n+            Some(containing_scope),\n+            enum_name.as_ptr(),\n+            file_metadata,\n+            UNKNOWN_LINE_NUMBER,\n+            enum_type_size.bits(),\n+            enum_type_align.abi_bits() as u32,\n+            DIFlags::FlagZero,\n+            None,\n+            type_array,\n+            0,\n+            None,\n+            unique_type_id_str.as_ptr())\n     };\n \n     return create_and_register_recursive_type_forward_declaration(\n         cx,\n         enum_type,\n         unique_type_id,\n-        enum_metadata,\n+        struct_wrapper,\n+        variant_part,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n             layout,\n-            discriminant_type_metadata,\n+            discriminant_type_metadata: None,\n             containing_scope,\n             span,\n         }),\n@@ -1565,7 +1796,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n         .map(|member_description| {\n             let member_name = CString::new(member_description.name).unwrap();\n             unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                Some(llvm::LLVMRustDIBuilderCreateVariantMemberType(\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n@@ -1574,6 +1805,10 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                     member_description.size.bits(),\n                     member_description.align.abi_bits() as u32,\n                     member_description.offset.bits(),\n+                    match member_description.discriminant {\n+                        None => None,\n+                        Some(value) => Some(C_u64(cx, value)),\n+                    },\n                     member_description.flags,\n                     member_description.type_metadata))\n             }"}, {"sha": "f046ea030272afe045dfa05b59295aee2f019806", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/71ce4c3007b964208b89733b0931bf71e7514938/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ce4c3007b964208b89733b0931bf71e7514938/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=71ce4c3007b964208b89733b0931bf71e7514938", "patch": "@@ -1307,6 +1307,19 @@ extern \"C\" {\n                                              Ty: &'a DIType)\n                                              -> &'a DIDerivedType;\n \n+    pub fn LLVMRustDIBuilderCreateVariantMemberType(Builder: &DIBuilder<'a>,\n+                                                    Scope: &'a DIScope,\n+                                                    Name: *const c_char,\n+                                                    File: &'a DIFile,\n+                                                    LineNumber: c_uint,\n+                                                    SizeInBits: u64,\n+                                                    AlignInBits: u32,\n+                                                    OffsetInBits: u64,\n+                                                    Discriminant: Option<&'a Value>,\n+                                                    Flags: DIFlags,\n+                                                    Ty: &'a DIType)\n+                                                    -> &'a DIType;\n+\n     pub fn LLVMRustDIBuilderCreateLexicalBlock(Builder: &DIBuilder<'a>,\n                                                Scope: &'a DIScope,\n                                                File: &'a DIFile,\n@@ -1384,7 +1397,8 @@ extern \"C\" {\n                                                   SizeInBits: u64,\n                                                   AlignInBits: u32,\n                                                   Elements: &'a DIArray,\n-                                                  ClassType: &'a DIType)\n+                                                  ClassType: &'a DIType,\n+                                                  IsFixed: bool)\n                                                   -> &'a DIType;\n \n     pub fn LLVMRustDIBuilderCreateUnionType(Builder: &DIBuilder<'a>,\n@@ -1400,6 +1414,19 @@ extern \"C\" {\n                                             UniqueId: *const c_char)\n                                             -> &'a DIType;\n \n+    pub fn LLVMRustDIBuilderCreateVariantPart(Builder: &DIBuilder<'a>,\n+                                              Scope: &'a DIScope,\n+                                              Name: *const c_char,\n+                                              File: &'a DIFile,\n+                                              LineNo: c_uint,\n+                                              SizeInBits: u64,\n+                                              AlignInBits: u32,\n+                                              Flags: DIFlags,\n+                                              Discriminator: Option<&'a DIDerivedType>,\n+                                              Elements: &'a DIArray,\n+                                              UniqueId: *const c_char)\n+                                              -> &'a DIDerivedType;\n+\n     pub fn LLVMSetUnnamedAddr(GlobalVar: &Value, UnnamedAddr: Bool);\n \n     pub fn LLVMRustDIBuilderCreateTemplateTypeParameter(Builder: &DIBuilder<'a>,"}, {"sha": "7051ead40a5f825878b59bf08d4e768be9e99a4a", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=71ce4c3007b964208b89733b0931bf71e7514938", "patch": "@@ -1 +1 @@\n-Subproject commit caddcd9b9dc9479a20908d93c3e47c49b021379e\n+Subproject commit 7051ead40a5f825878b59bf08d4e768be9e99a4a"}, {"sha": "affec73e3ac62d608c8db0fbf46090698b2e74cc", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/71ce4c3007b964208b89733b0931bf71e7514938/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/71ce4c3007b964208b89733b0931bf71e7514938/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=71ce4c3007b964208b89733b0931bf71e7514938", "patch": "@@ -713,6 +713,21 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStructType(\n       unwrapDI<DIType>(VTableHolder), UniqueId));\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantPart(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMMetadataRef Discriminator,\n+    LLVMMetadataRef Elements, const char *UniqueId) {\n+#if LLVM_VERSION_GE(7, 0)\n+  return wrap(Builder->createVariantPart(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIDerivedType>(Discriminator),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), UniqueId));\n+#else\n+  abort();\n+#endif\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMemberType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n     LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n@@ -724,6 +739,28 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMemberType(\n                                         fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantMemberType(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n+    uint32_t AlignInBits, uint64_t OffsetInBits, LLVMValueRef Discriminant,\n+    LLVMRustDIFlags Flags, LLVMMetadataRef Ty) {\n+#if LLVM_VERSION_GE(7, 0)\n+  llvm::ConstantInt* D = nullptr;\n+  if (Discriminant) {\n+    D = unwrap<llvm::ConstantInt>(Discriminant);\n+  }\n+  return wrap(Builder->createVariantMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+                                               unwrapDI<DIFile>(File), LineNo,\n+                                               SizeInBits, AlignInBits, OffsetInBits, D,\n+                                               fromRust(Flags), unwrapDI<DIType>(Ty)));\n+#else\n+  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+                                        unwrapDI<DIFile>(File), LineNo,\n+                                        SizeInBits, AlignInBits, OffsetInBits,\n+                                        fromRust(Flags), unwrapDI<DIType>(Ty)));\n+#endif\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n     LLVMMetadataRef File, unsigned Line, unsigned Col) {\n@@ -826,11 +863,19 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMMetadataRef Elements,\n-    LLVMMetadataRef ClassTy) {\n+    LLVMMetadataRef ClassTy, bool IsFixed) {\n+#if LLVM_VERSION_GE(7, 0)\n   return wrap(Builder->createEnumerationType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n-      unwrapDI<DIType>(ClassTy)));\n+      unwrapDI<DIType>(ClassTy), \"\", IsFixed));\n+#else\n+  // Ignore IsFixed on older LLVM.\n+  return wrap(Builder->createEnumerationType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n+      unwrapDI<DIType>(ClassTy), \"\"));\n+#endif\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateUnionType("}, {"sha": "2bcac922910c098265593a39a8da988cb63929f2", "filename": "src/test/codegen/enum-debug.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/71ce4c3007b964208b89733b0931bf71e7514938/src%2Ftest%2Fcodegen%2Fenum-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ce4c3007b964208b89733b0931bf71e7514938/src%2Ftest%2Fcodegen%2Fenum-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-debug.rs?ref=71ce4c3007b964208b89733b0931bf71e7514938", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test depends on a patch that was committed to upstream LLVM\n+// before 7.0, then backported to the Rust LLVM fork.  It tests that\n+// optimized enum debug info accurately reflects the enum layout.\n+\n+// ignore-tidy-linelength\n+// ignore-windows\n+// min-system-llvm-version 7.0\n+\n+// compile-flags: -g -C no-prepopulate-passes\n+\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_variant_part,{{.*}}discriminator:{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"A\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"A\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"B\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"B\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"C\",{{.*}}extraData:{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"C\",{{.*}}\n+// CHECK: {{.*}}DIDerivedType{{.*}}tag: DW_TAG_member,{{.*}}name: \"D\",{{.*}}\n+// CHECK: {{.*}}DICompositeType{{.*}}tag: DW_TAG_structure_type,{{.*}}name: \"D\",{{.*}}\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+\n+enum E { A, B, C, D(bool) }\n+\n+pub fn main() {\n+    let e = E::D(true);\n+}"}]}