{"sha": "2ad98a0b42917dbb0914f458829db7511be168d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZDk4YTBiNDI5MTdkYmIwOTE0ZjQ1ODgyOWRiNzUxMWJlMTY4ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-30T03:29:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-30T03:29:43Z"}, "message": "Auto merge of #35032 - vadimcn:rusty-ehabi, r=alexcrichton\n\nImplement ARM personality routine in Rust.\n\nRemove the `eh_personality_catch` lang item.\nUse a simplified version of `cfg_if!` in libunwind.\n\nCloses #34786", "tree": {"sha": "b88a6e534e5984f36ab60f52dfed73b3437231ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b88a6e534e5984f36ab60f52dfed73b3437231ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad98a0b42917dbb0914f458829db7511be168d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad98a0b42917dbb0914f458829db7511be168d4", "html_url": "https://github.com/rust-lang/rust/commit/2ad98a0b42917dbb0914f458829db7511be168d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad98a0b42917dbb0914f458829db7511be168d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f164cf5d6443fd265f93662055d744074648189f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f164cf5d6443fd265f93662055d744074648189f", "html_url": "https://github.com/rust-lang/rust/commit/f164cf5d6443fd265f93662055d744074648189f"}, {"sha": "6cef93d400b183d70c6c37856b46bb36d7bd8e16", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cef93d400b183d70c6c37856b46bb36d7bd8e16", "html_url": "https://github.com/rust-lang/rust/commit/6cef93d400b183d70c6c37856b46bb36d7bd8e16"}], "stats": {"total": 584, "additions": 314, "deletions": 270}, "files": [{"sha": "fdae8f69a9c0ef31f49fca61b919c7e17cfa0244", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 159, "deletions": 112, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=2ad98a0b42917dbb0914f458829db7511be168d4", "patch": "@@ -61,6 +61,8 @@ use core::ptr;\n use alloc::boxed::Box;\n \n use unwind as uw;\n+use libc::{c_int, uintptr_t};\n+use dwarf::eh::{self, EHContext, EHAction};\n \n #[repr(C)]\n struct Exception {\n@@ -106,139 +108,184 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n     0x4d4f5a_00_52555354\n }\n \n-// All targets, except ARM which uses a slightly different ABI (however, iOS goes here as it uses\n-// SjLj unwinding).  Also, 64-bit Windows implementation lives in seh64_gnu.rs\n-#[cfg(all(any(target_os = \"ios\", not(target_arch = \"arm\"))))]\n-pub mod eabi {\n-    use unwind as uw;\n-    use libc::{c_int, uintptr_t};\n-    use dwarf::eh::{EHContext, EHAction, find_eh_action};\n \n-    // Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n-    // and TargetLowering::getExceptionSelectorRegister() for each architecture,\n-    // then mapped to DWARF register numbers via register definition tables\n-    // (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n-    // See also http://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n+// Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n+// and TargetLowering::getExceptionSelectorRegister() for each architecture,\n+// then mapped to DWARF register numbers via register definition tables\n+// (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n+// See also http://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n \n-    #[cfg(target_arch = \"x86\")]\n-    const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n+#[cfg(target_arch = \"x86\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n \n-    #[cfg(target_arch = \"x86_64\")]\n-    const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n+#[cfg(target_arch = \"x86_64\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n \n-    #[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n-    const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n+#[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n \n-    #[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n-    const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n \n-    #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n-    const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n+#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n \n-    // Based on GCC's C and C++ personality routines.  For reference, see:\n-    // https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n-    // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    #[allow(unused)]\n-    unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n-                                             actions: uw::_Unwind_Action,\n-                                             exception_class: uw::_Unwind_Exception_Class,\n-                                             exception_object: *mut uw::_Unwind_Exception,\n-                                             context: *mut uw::_Unwind_Context)\n-                                             -> uw::_Unwind_Reason_Code {\n-        if version != 1 {\n-            return uw::_URC_FATAL_PHASE1_ERROR;\n-        }\n-        let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n-        let mut ip_before_instr: c_int = 0;\n-        let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n-        let eh_context = EHContext {\n-            // The return address points 1 byte past the call instruction,\n-            // which could be in the next IP range in LSDA range table.\n-            ip: if ip_before_instr != 0 { ip } else { ip - 1 },\n-            func_start: uw::_Unwind_GetRegionStart(context),\n-            get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n-            get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n-        };\n-        let eh_action = find_eh_action(lsda, &eh_context);\n+// The following code is based on GCC's C and C++ personality routines.  For reference, see:\n+// https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n+// https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n \n-        if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n-            match eh_action {\n-                EHAction::None | EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n-                EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n-                EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n-            }\n-        } else {\n-            match eh_action {\n-                EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n-                EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n-                    uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n-                    uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                    uw::_Unwind_SetIP(context, lpad);\n-                    return uw::_URC_INSTALL_CONTEXT;\n-                }\n-                EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n+// The personality routine for most of our targets, except ARM, which has a slightly different ABI\n+// (however, iOS goes here as it uses SjLj unwinding).  Also, the 64-bit Windows implementation\n+// lives in seh64_gnu.rs\n+#[cfg(all(any(target_os = \"ios\", not(target_arch = \"arm\"))))]\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+#[allow(unused)]\n+unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n+                                         actions: uw::_Unwind_Action,\n+                                         exception_class: uw::_Unwind_Exception_Class,\n+                                         exception_object: *mut uw::_Unwind_Exception,\n+                                         context: *mut uw::_Unwind_Context)\n+                                         -> uw::_Unwind_Reason_Code {\n+    if version != 1 {\n+        return uw::_URC_FATAL_PHASE1_ERROR;\n+    }\n+    let eh_action = find_eh_action(context);\n+    if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+        match eh_action {\n+            EHAction::None | EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n+        }\n+    } else {\n+        match eh_action {\n+            EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                uw::_Unwind_SetIP(context, lpad);\n+                return uw::_URC_INSTALL_CONTEXT;\n             }\n+            EHAction::Terminate => return uw::_URC_FATAL_PHASE2_ERROR,\n         }\n     }\n-\n-    #[cfg(stage0)]\n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub unsafe extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                                       actions: uw::_Unwind_Action,\n-                                                       exception_class: uw::_Unwind_Exception_Class,\n-                                                       ue_header: *mut uw::_Unwind_Exception,\n-                                                       context: *mut uw::_Unwind_Context)\n-                                                       -> uw::_Unwind_Reason_Code {\n-        rust_eh_personality(version, actions, exception_class, ue_header, context)\n-    }\n }\n \n-// ARM EHABI uses a slightly different personality routine signature,\n-// but otherwise works the same.\n+// ARM EHABI personality routine.\n+// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n-pub mod eabi {\n-    use unwind as uw;\n-    use libc::c_int;\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n+                                         exception_object: *mut uw::_Unwind_Exception,\n+                                         context: *mut uw::_Unwind_Context)\n+                                        -> uw::_Unwind_Reason_Code {\n+    let state = state as c_int;\n+    let action = state & uw::_US_ACTION_MASK as c_int;\n+    let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n+        // Backtraces on ARM will call the personality routine with\n+        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+        // we want to continue unwinding the stack, otherwise all our backtraces\n+        // would end at __rust_try\n+        if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n+            return continue_unwind(exception_object, context)\n+        }\n+        true\n+    } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n+        false\n+    } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n+        return continue_unwind(exception_object, context);\n+    } else {\n+        return uw::_URC_FAILURE;\n+    };\n \n-    extern \"C\" {\n-        fn __gcc_personality_v0(state: uw::_Unwind_State,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-                                -> uw::_Unwind_Reason_Code;\n-    }\n+    // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n+    // and LSDA pointers, however ARM EHABI places them into the exception object.\n+    // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n+    // take only the context pointer, GCC personality routines stash a pointer to exception_object\n+    // in the context, using location reserved for ARM's \"scratch register\" (r12).\n+    uw::_Unwind_SetGR(context, uw::UNWIND_POINTER_REG, exception_object as uw::_Unwind_Ptr);\n+    // ...A more principled approach would be to provide the full definition of ARM's\n+    // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n+    // bypassing DWARF compatibility functions.\n \n-    #[lang = \"eh_personality\"]\n-    #[no_mangle]\n-    extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n-                                      ue_header: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code {\n-        unsafe { __gcc_personality_v0(state, ue_header, context) }\n+    let eh_action = find_eh_action(context);\n+    if search_phase {\n+        match eh_action {\n+            EHAction::None |\n+            EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n+            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+            EHAction::Terminate => return uw::_URC_FAILURE,\n+        }\n+    } else {\n+        match eh_action {\n+            EHAction::None => return continue_unwind(exception_object, context),\n+            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n+                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                uw::_Unwind_SetIP(context, lpad);\n+                return uw::_URC_INSTALL_CONTEXT;\n+            }\n+            EHAction::Terminate => return uw::_URC_FAILURE,\n+        }\n     }\n \n-    #[lang = \"eh_personality_catch\"]\n-    #[no_mangle]\n-    pub extern \"C\" fn rust_eh_personality_catch(state: uw::_Unwind_State,\n-                                                ue_header: *mut uw::_Unwind_Exception,\n-                                                context: *mut uw::_Unwind_Context)\n-                                                -> uw::_Unwind_Reason_Code {\n-        // Backtraces on ARM will call the personality routine with\n-        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n-        // we want to continue unwinding the stack, otherwise all our backtraces\n-        // would end at __rust_try.\n-        if (state as c_int & uw::_US_ACTION_MASK as c_int) ==\n-           uw::_US_VIRTUAL_UNWIND_FRAME as c_int &&\n-           (state as c_int & uw::_US_FORCE_UNWIND as c_int) == 0 {\n-            // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n+    // On ARM EHABI the personality routine is responsible for actually\n+    // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n+    unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n+                              context: *mut uw::_Unwind_Context)\n+                              -> uw::_Unwind_Reason_Code {\n+        if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n+            uw::_URC_CONTINUE_UNWIND\n         } else {\n-            // cleanup phase\n-            unsafe { __gcc_personality_v0(state, ue_header, context) }\n+            uw::_URC_FAILURE\n         }\n     }\n+    // defined in libgcc\n+    extern \"C\" {\n+        fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+                                -> uw::_Unwind_Reason_Code;\n+    }\n+}\n+\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> EHAction {\n+    let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n+    let mut ip_before_instr: c_int = 0;\n+    let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n+    let eh_context = EHContext {\n+        // The return address points 1 byte past the call instruction,\n+        // which could be in the next IP range in LSDA range table.\n+        ip: if ip_before_instr != 0 { ip } else { ip - 1 },\n+        func_start: uw::_Unwind_GetRegionStart(context),\n+        get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n+        get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n+    };\n+    eh::find_eh_action(lsda, &eh_context)\n+}\n+\n+// *** Delete after a new snapshot ***\n+#[cfg(all(stage0, any(target_os = \"ios\", not(target_arch = \"arm\"))))]\n+#[lang = \"eh_personality_catch\"]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_eh_personality_catch(version: c_int,\n+                                                    actions: uw::_Unwind_Action,\n+                                                    exception_class: uw::_Unwind_Exception_Class,\n+                                                    ue_header: *mut uw::_Unwind_Exception,\n+                                                    context: *mut uw::_Unwind_Context)\n+                                                    -> uw::_Unwind_Reason_Code {\n+    rust_eh_personality(version, actions, exception_class, ue_header, context)\n+}\n+\n+// *** Delete after a new snapshot ***\n+#[cfg(all(stage0, target_arch = \"arm\", not(target_os = \"ios\")))]\n+#[lang = \"eh_personality_catch\"]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rust_eh_personality_catch(state: uw::_Unwind_State,\n+                                                    ue_header: *mut uw::_Unwind_Exception,\n+                                                    context: *mut uw::_Unwind_Context)\n+                                                    -> uw::_Unwind_Reason_Code {\n+    rust_eh_personality(state, ue_header, context)\n }\n \n // See docs in the `unwind` module."}, {"sha": "3642e2488958e921fa8b1efd6a514858873a5de8", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=2ad98a0b42917dbb0914f458829db7511be168d4", "patch": "@@ -81,6 +81,7 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n // This is considered acceptable, because the behavior of throwing exceptions\n // through a C ABI boundary is undefined.\n \n+// *** Delete after a new snapshot ***\n #[cfg(stage0)]\n #[lang = \"eh_personality_catch\"]\n #[cfg(not(test))]"}, {"sha": "a209b1d1abd7c6e320fbf0e129a59a2f992f4bce", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=2ad98a0b42917dbb0914f458829db7511be168d4", "patch": "@@ -359,7 +359,6 @@ language_item_table! {\n     StartFnLangItem,                 \"start\",                   start_fn;\n \n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n-    EhPersonalityCatchLangItem,      \"eh_personality_catch\",    eh_personality_catch;\n     EhUnwindResumeLangItem,          \"eh_unwind_resume\",        eh_unwind_resume;\n     MSVCTryFilterLangItem,           \"msvc_try_filter\",         msvc_try_filter;\n "}, {"sha": "1e4a27481827dae8b84405efd1d4eb74696d0893", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=2ad98a0b42917dbb0914f458829db7511be168d4", "patch": "@@ -19,7 +19,6 @@ use rustc::ty::subst;\n use rustc::ty::subst::FnSpace;\n use abi::{Abi, FnType};\n use adt;\n-use attributes;\n use base::*;\n use build::*;\n use callee::{self, Callee};\n@@ -37,7 +36,6 @@ use machine;\n use type_::Type;\n use rustc::ty::{self, Ty};\n use Disr;\n-use rustc::ty::subst::Substs;\n use rustc::hir;\n use syntax::ast;\n use syntax::ptr::P;\n@@ -1173,7 +1171,6 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n     let llfn = get_rust_try_fn(bcx.fcx, &mut |bcx| {\n         let ccx = bcx.ccx();\n-        let tcx = ccx.tcx();\n         let dloc = DebugLoc::None;\n \n         // Translates the shims described above:\n@@ -1193,20 +1190,6 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        attributes::emit_uwtable(bcx.fcx.llfn, true);\n-        let target = &bcx.sess().target.target;\n-        let catch_pers = if target.arch == \"arm\" && target.target_os != \"ios\" {\n-            // Only ARM still uses a separate catch personality (for now)\n-            match tcx.lang_items.eh_personality_catch() {\n-                Some(did) => {\n-                    Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n-                }\n-                None => bug!(\"eh_personality_catch not defined\"),\n-            }\n-        } else {\n-            bcx.fcx.eh_personality()\n-        };\n-\n         let then = bcx.fcx.new_temp_block(\"then\");\n         let catch = bcx.fcx.new_temp_block(\"catch\");\n \n@@ -1224,7 +1207,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n                                     false);\n-        let vals = LandingPad(catch, lpad_ty, catch_pers, 1);\n+        let vals = LandingPad(catch, lpad_ty, bcx.fcx.eh_personality(), 1);\n         AddClause(catch, vals, C_null(Type::i8p(ccx)));\n         let ptr = ExtractValue(catch, vals, 0);\n         Store(catch, ptr, BitCast(catch, local_ptr, Type::i8p(ccx).ptr_to()));"}, {"sha": "5e242db0a888db8c1dbd41c6aafb58ef9d27c196", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 153, "deletions": 139, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad98a0b42917dbb0914f458829db7511be168d4/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=2ad98a0b42917dbb0914f458829db7511be168d4", "patch": "@@ -10,38 +10,15 @@\n \n #![allow(bad_style)]\n \n-use libc;\n-\n-#[cfg(any(not(target_arch = \"arm\"), target_os = \"ios\"))]\n-pub use self::_Unwind_Action::*;\n-#[cfg(target_arch = \"arm\")]\n-pub use self::_Unwind_State::*;\n-pub use self::_Unwind_Reason_Code::*;\n-\n-#[cfg(any(not(target_arch = \"arm\"), target_os = \"ios\"))]\n-#[repr(C)]\n-#[derive(Clone, Copy)]\n-pub enum _Unwind_Action {\n-    _UA_SEARCH_PHASE = 1,\n-    _UA_CLEANUP_PHASE = 2,\n-    _UA_HANDLER_FRAME = 4,\n-    _UA_FORCE_UNWIND = 8,\n-    _UA_END_OF_STACK = 16,\n+macro_rules! cfg_if {\n+    ( $( if #[cfg( $meta:meta )] { $($it1:item)* } else { $($it2:item)* } )* ) =>\n+        ( $( $( #[cfg($meta)] $it1)* $( #[cfg(not($meta))] $it2)* )* )\n }\n \n-#[cfg(target_arch = \"arm\")]\n-#[repr(C)]\n-#[derive(Clone, Copy)]\n-pub enum _Unwind_State {\n-    _US_VIRTUAL_UNWIND_FRAME = 0,\n-    _US_UNWIND_FRAME_STARTING = 1,\n-    _US_UNWIND_FRAME_RESUME = 2,\n-    _US_ACTION_MASK = 3,\n-    _US_FORCE_UNWIND = 8,\n-    _US_END_OF_STACK = 16,\n-}\n+use libc::{c_int, c_void, uintptr_t};\n \n #[repr(C)]\n+#[derive(Copy, Clone, PartialEq)]\n pub enum _Unwind_Reason_Code {\n     _URC_NO_REASON = 0,\n     _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n@@ -52,17 +29,15 @@ pub enum _Unwind_Reason_Code {\n     _URC_HANDLER_FOUND = 6,\n     _URC_INSTALL_CONTEXT = 7,\n     _URC_CONTINUE_UNWIND = 8,\n-    _URC_FAILURE = 9, // used only by ARM EABI\n+    _URC_FAILURE = 9, // used only by ARM EHABI\n }\n+pub use self::_Unwind_Reason_Code::*;\n \n pub type _Unwind_Exception_Class = u64;\n-\n-pub type _Unwind_Word = libc::uintptr_t;\n-pub type _Unwind_Ptr = libc::uintptr_t;\n-\n-pub type _Unwind_Trace_Fn = extern \"C\" fn(ctx: *mut _Unwind_Context, arg: *mut libc::c_void)\n+pub type _Unwind_Word = uintptr_t;\n+pub type _Unwind_Ptr = uintptr_t;\n+pub type _Unwind_Trace_Fn = extern \"C\" fn(ctx: *mut _Unwind_Context, arg: *mut c_void)\n                                           -> _Unwind_Reason_Code;\n-\n #[cfg(target_arch = \"x86\")]\n pub const unwinder_private_data_size: usize = 5;\n \n@@ -99,91 +74,55 @@ pub enum _Unwind_Context {}\n \n pub type _Unwind_Exception_Cleanup_Fn = extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                                                       exception: *mut _Unwind_Exception);\n-\n-#[cfg_attr(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n-               target_os = \"freebsd\",\n-               target_os = \"solaris\",\n-               all(target_os = \"linux\",\n-                   target_env = \"musl\",\n-                   not(target_arch = \"x86\"),\n-                   not(target_arch = \"x86_64\"))),\n-           link(name = \"gcc_s\"))]\n-#[cfg_attr(all(target_os = \"linux\",\n-               target_env = \"musl\",\n-               any(target_arch = \"x86\", target_arch = \"x86_64\"),\n-               not(test)),\n-           link(name = \"unwind\", kind = \"static\"))]\n-#[cfg_attr(any(target_os = \"android\", target_os = \"openbsd\"),\n-           link(name = \"gcc\"))]\n-#[cfg_attr(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-           link(name = \"gcc\"))]\n-#[cfg_attr(all(target_os = \"netbsd\", target_vendor = \"rumprun\"),\n-           link(name = \"unwind\"))]\n-#[cfg_attr(target_os = \"dragonfly\",\n-           link(name = \"gcc_pic\"))]\n-#[cfg_attr(target_os = \"bitrig\",\n-           link(name = \"c++abi\"))]\n-#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"),\n-           link(name = \"gcc_eh\"))]\n-#[cfg(not(cargobuild))]\n-extern \"C\" {}\n-\n extern \"C\" {\n-    // iOS on armv7 uses SjLj exceptions and requires to link\n-    // against corresponding routine (..._SjLj_...)\n-    #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-    #[unwind]\n-    pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n-\n-    #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-    #[unwind]\n-    fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n-\n-    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n-\n     #[unwind]\n     pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n-\n-    // No native _Unwind_Backtrace on iOS\n-    #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n-    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                             trace_argument: *mut libc::c_void)\n-                             -> _Unwind_Reason_Code;\n-\n-    // available since GCC 4.2.0, should be fine for our purpose\n-    #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n-              not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-    pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n-                             ip_before_insn: *mut libc::c_int)\n-                             -> libc::uintptr_t;\n-\n-    pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n+    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n+    pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> *mut c_void;\n     pub fn _Unwind_GetRegionStart(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n     pub fn _Unwind_GetTextRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n     pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n-    pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: libc::c_int, value: _Unwind_Ptr);\n-    pub fn _Unwind_SetIP(ctx: *mut _Unwind_Context, value: _Unwind_Ptr);\n-\n-    #[cfg(all(not(target_os = \"android\"),\n-              not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-    pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void) -> *mut libc::c_void;\n }\n \n-// ... and now we just providing access to SjLj counterspart\n-// through a standard name to hide those details from others\n-// (see also comment above regarding _Unwind_RaiseException)\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n-#[inline]\n-pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception) -> _Unwind_Reason_Code {\n-    _Unwind_SjLj_RaiseException(exc)\n-}\n+cfg_if! {\n+if #[cfg(not(any(all(target_os = \"android\", target_arch = \"arm\"),\n+                 all(target_os = \"linux\", target_arch = \"arm\"))))] {\n+    // Not ARM EHABI\n+    #[repr(C)]\n+    #[derive(Copy, Clone, PartialEq)]\n+    pub enum _Unwind_Action {\n+        _UA_SEARCH_PHASE = 1,\n+        _UA_CLEANUP_PHASE = 2,\n+        _UA_HANDLER_FRAME = 4,\n+        _UA_FORCE_UNWIND = 8,\n+        _UA_END_OF_STACK = 16,\n+    }\n+    pub use self::_Unwind_Action::*;\n+\n+    extern \"C\" {\n+        pub fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word;\n+        pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word);\n+        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> _Unwind_Word;\n+        pub fn _Unwind_SetIP(ctx: *mut _Unwind_Context, value: _Unwind_Word);\n+        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context, ip_before_insn: *mut c_int)\n+                                 -> _Unwind_Word;\n+        pub fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void;\n+    }\n+\n+} else {\n+    // ARM EHABI\n+    #[repr(C)]\n+    #[derive(Copy, Clone, PartialEq)]\n+    pub enum _Unwind_State {\n+        _US_VIRTUAL_UNWIND_FRAME = 0,\n+        _US_UNWIND_FRAME_STARTING = 1,\n+        _US_UNWIND_FRAME_RESUME = 2,\n+        _US_ACTION_MASK = 3,\n+        _US_FORCE_UNWIND = 8,\n+        _US_END_OF_STACK = 16,\n+    }\n+    pub use self::_Unwind_State::*;\n \n-// On android, the function _Unwind_GetIP is a macro, and this is the\n-// expansion of the macro. This is all copy/pasted directly from the\n-// header file with the definition of _Unwind_GetIP.\n-#[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n-          all(target_os = \"linux\", target_arch = \"arm\")))]\n-pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n     #[repr(C)]\n     enum _Unwind_VRS_Result {\n         _UVRSR_OK = 0,\n@@ -198,6 +137,7 @@ pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n         _UVRSC_WMMXD = 3,\n         _UVRSC_WMMXC = 4,\n     }\n+    use self::_Unwind_VRS_RegClass::*;\n     #[repr(C)]\n     enum _Unwind_VRS_DataRepresentation {\n         _UVRSD_UINT32 = 0,\n@@ -207,42 +147,116 @@ pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n         _UVRSD_FLOAT = 4,\n         _UVRSD_DOUBLE = 5,\n     }\n+    use self::_Unwind_VRS_DataRepresentation::*;\n+\n+    pub const UNWIND_POINTER_REG: c_int = 12;\n+    pub const UNWIND_IP_REG: c_int = 15;\n \n-    type _Unwind_Word = libc::c_uint;\n     extern \"C\" {\n         fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n-                           klass: _Unwind_VRS_RegClass,\n-                           word: _Unwind_Word,\n+                           regclass: _Unwind_VRS_RegClass,\n+                           regno: _Unwind_Word,\n+                           repr: _Unwind_VRS_DataRepresentation,\n+                           data: *mut c_void)\n+                           -> _Unwind_VRS_Result;\n+\n+        fn _Unwind_VRS_Set(ctx: *mut _Unwind_Context,\n+                           regclass: _Unwind_VRS_RegClass,\n+                           regno: _Unwind_Word,\n                            repr: _Unwind_VRS_DataRepresentation,\n-                           data: *mut libc::c_void)\n+                           data: *mut c_void)\n                            -> _Unwind_VRS_Result;\n     }\n \n-    let mut val: _Unwind_Word = 0;\n-    let ptr = &mut val as *mut _Unwind_Word;\n-    let _ = _Unwind_VRS_Get(ctx,\n-                            _Unwind_VRS_RegClass::_UVRSC_CORE,\n-                            15,\n-                            _Unwind_VRS_DataRepresentation::_UVRSD_UINT32,\n-                            ptr as *mut libc::c_void);\n-    (val & !1) as libc::uintptr_t\n-}\n+    // On Android or ARM/Linux, these are implemented as macros:\n+\n+    pub unsafe fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word {\n+        let mut val: _Unwind_Word = 0;\n+        _Unwind_VRS_Get(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n+                        &mut val as *mut _ as *mut c_void);\n+        val\n+    }\n \n-// This function doesn't exist on Android or ARM/Linux, so make it same\n-// to _Unwind_GetIP\n-#[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n-          all(target_os = \"linux\", target_arch = \"arm\")))]\n-pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n-                                ip_before_insn: *mut libc::c_int)\n-                                -> libc::uintptr_t {\n-    *ip_before_insn = 0;\n-    _Unwind_GetIP(ctx)\n+    pub unsafe fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word) {\n+        let mut value = value;\n+        _Unwind_VRS_Set(ctx, _UVRSC_CORE, reg_index as _Unwind_Word, _UVRSD_UINT32,\n+                        &mut value as *mut _ as *mut c_void);\n+    }\n+\n+    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context)\n+                                -> _Unwind_Word {\n+        let val = _Unwind_GetGR(ctx, UNWIND_IP_REG);\n+        (val & !1) as _Unwind_Word\n+    }\n+\n+    pub unsafe fn _Unwind_SetIP(ctx: *mut _Unwind_Context,\n+                                value: _Unwind_Word) {\n+        // Propagate thumb bit to instruction pointer\n+        let thumb_state = _Unwind_GetGR(ctx, UNWIND_IP_REG) & 1;\n+        let value = value | thumb_state;\n+        _Unwind_SetGR(ctx, UNWIND_IP_REG, value);\n+    }\n+\n+    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                                    ip_before_insn: *mut c_int)\n+                                    -> _Unwind_Word {\n+        *ip_before_insn = 0;\n+        _Unwind_GetIP(ctx)\n+    }\n+\n+    // This function also doesn't exist on Android or ARM/Linux, so make it a no-op\n+    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut c_void) -> *mut c_void {\n+        pc\n+    }\n }\n \n-// This function also doesn't exist on Android or ARM/Linux, so make it\n-// a no-op\n-#[cfg(any(target_os = \"android\",\n-          all(target_os = \"linux\", target_arch = \"arm\")))]\n-pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void) -> *mut libc::c_void {\n-    pc\n+if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n+    // Not 32-bit iOS\n+    extern \"C\" {\n+        #[unwind]\n+        pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n+        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                                 trace_argument: *mut c_void)\n+                                 -> _Unwind_Reason_Code;\n+    }\n+} else {\n+    // 32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()\n+    extern \"C\" {\n+        #[unwind]\n+        pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception) -> _Unwind_Reason_Code {\n+        _Unwind_SjLj_RaiseException(exc)\n+    }\n }\n+} // cfg_if!\n+\n+#[cfg_attr(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n+               target_os = \"freebsd\",\n+               target_os = \"solaris\",\n+               all(target_os = \"linux\",\n+                   target_env = \"musl\",\n+                   not(target_arch = \"x86\"),\n+                   not(target_arch = \"x86_64\"))),\n+           link(name = \"gcc_s\"))]\n+#[cfg_attr(all(target_os = \"linux\",\n+               target_env = \"musl\",\n+               any(target_arch = \"x86\", target_arch = \"x86_64\"),\n+               not(test)),\n+           link(name = \"unwind\", kind = \"static\"))]\n+#[cfg_attr(any(target_os = \"android\", target_os = \"openbsd\"),\n+           link(name = \"gcc\"))]\n+#[cfg_attr(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+           link(name = \"gcc\"))]\n+#[cfg_attr(all(target_os = \"netbsd\", target_vendor = \"rumprun\"),\n+           link(name = \"unwind\"))]\n+#[cfg_attr(target_os = \"dragonfly\",\n+           link(name = \"gcc_pic\"))]\n+#[cfg_attr(target_os = \"bitrig\",\n+           link(name = \"c++abi\"))]\n+#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"),\n+           link(name = \"gcc_eh\"))]\n+#[cfg(not(cargobuild))]\n+extern \"C\" {}"}]}