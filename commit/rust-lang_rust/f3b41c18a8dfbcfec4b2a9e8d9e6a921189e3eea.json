{"sha": "f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYjQxYzE4YThkZmJjZmVjNGIyYTllOGQ5ZTZhOTIxMTg5ZTNlZWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-18T15:31:47Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-03T10:39:34Z"}, "message": "Check fields in union patters/expressions\n\nMake parsing of union items backward compatible\nAdd some tests", "tree": {"sha": "1d6aaf94ca46fd2e08df59767b8b2fb9c799313a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6aaf94ca46fd2e08df59767b8b2fb9c799313a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "html_url": "https://github.com/rust-lang/rust/commit/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957971b63abbc816aebc6654dc68cf9ff15837d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/957971b63abbc816aebc6654dc68cf9ff15837d7", "html_url": "https://github.com/rust-lang/rust/commit/957971b63abbc816aebc6654dc68cf9ff15837d7"}], "stats": {"total": 274, "additions": 227, "deletions": 47}, "files": [{"sha": "5c19fa2a66cfcd2b252299b5171d779139025cdf", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -11,7 +11,6 @@\n use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference, VariantKind};\n use check::{FnCtxt, Expectation};\n use lint;\n@@ -509,11 +508,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n-        let substs = match pat_ty.sty {\n-            ty::TyStruct(_, substs) | ty::TyUnion(_, substs) | ty::TyEnum(_, substs) => substs,\n-            _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n-        };\n-        self.check_struct_pat_fields(pat.span, fields, variant, substs, etc);\n+        self.check_struct_pat_fields(pat_ty, pat.span, variant, fields, etc);\n     }\n \n     fn check_pat_path(&self,\n@@ -658,19 +653,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// `path` is the AST path item naming the type of this struct.\n-    /// `fields` is the field patterns of the struct pattern.\n-    /// `struct_fields` describes the type of each field of the struct.\n-    /// `struct_id` is the ID of the struct.\n-    /// `etc` is true if the pattern said '...' and false otherwise.\n-    pub fn check_struct_pat_fields(&self,\n-                                   span: Span,\n-                                   fields: &'gcx [Spanned<hir::FieldPat>],\n-                                   variant: ty::VariantDef<'tcx>,\n-                                   substs: &Substs<'tcx>,\n-                                   etc: bool) {\n+    fn check_struct_pat_fields(&self,\n+                               adt_ty: Ty<'tcx>,\n+                               span: Span,\n+                               variant: ty::VariantDef<'tcx>,\n+                               fields: &'gcx [Spanned<hir::FieldPat>],\n+                               etc: bool) {\n         let tcx = self.tcx;\n \n+        let (substs, kind_name) = match adt_ty.sty {\n+            ty::TyEnum(_, substs) => (substs, \"variant\"),\n+            ty::TyStruct(_, substs) => (substs, \"struct\"),\n+            ty::TyUnion(_, substs) => (substs, \"union\"),\n+            _ => span_bug!(span, \"struct pattern is not an ADT\")\n+        };\n+\n         // Index the struct fields' types.\n         let field_map = variant.fields\n             .iter()\n@@ -700,11 +697,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .map(|f| self.field_ty(span, f, substs))\n                         .unwrap_or_else(|| {\n                             struct_span_err!(tcx.sess, span, E0026,\n-                                             \"struct `{}` does not have a field named `{}`\",\n+                                             \"{} `{}` does not have a field named `{}`\",\n+                                             kind_name,\n                                              tcx.item_path_str(variant.did),\n                                              field.name)\n                                 .span_label(span,\n-                                            &format!(\"struct `{}` does not have field `{}`\",\n+                                            &format!(\"{} `{}` does not have field `{}`\",\n+                                                     kind_name,\n                                                      tcx.item_path_str(variant.did),\n                                                      field.name))\n                                 .emit();\n@@ -717,8 +716,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_pat(&field.pat, field_ty);\n         }\n \n-        // Report an error if not all the fields were specified.\n-        if !etc {\n+        // Report an error if incorrect number of the fields were specified.\n+        if kind_name == \"union\" {\n+            if fields.len() > 1 {\n+                tcx.sess.span_err(span, \"union patterns can have at most one field\");\n+            }\n+            if fields.is_empty() && !etc {\n+                tcx.sess.span_err(span, \"union patterns without `..` \\\n+                                         should have at least one field\");\n+            }\n+        } else if !etc {\n             for field in variant.fields\n                 .iter()\n                 .filter(|field| !used_fields.contains_key(&field.name)) {"}, {"sha": "f8ee9efee7a5a52f479a01d559ab935a7aae823f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -3109,17 +3109,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             ty: Ty<'tcx>,\n                             variant: ty::VariantDef<'tcx>,\n                             field: &hir::Field,\n-                            skip_fields: &[hir::Field]) {\n+                            skip_fields: &[hir::Field],\n+                            kind_name: &str) {\n         let mut err = self.type_error_struct_with_diag(\n             field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n                 struct_span_err!(self.tcx.sess, field.name.span, E0559,\n-                                 \"struct variant `{}::{}` has no field named `{}`\",\n-                                 actual, variant.name.as_str(), field.name.node)\n+                                 \"{} `{}::{}` has no field named `{}`\",\n+                                 kind_name, actual, variant.name.as_str(), field.name.node)\n             } else {\n                 struct_span_err!(self.tcx.sess, field.name.span, E0560,\n-                                 \"structure `{}` has no field named `{}`\",\n-                                 actual, field.name.node)\n+                                 \"{} `{}` has no field named `{}`\",\n+                                 kind_name, actual, field.name.node)\n             },\n             ty);\n         // prevent all specified fields from being suggested\n@@ -3135,8 +3136,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n-        let substs = match adt_ty.sty {\n-            ty::TyStruct(_, substs) | ty::TyUnion(_, substs) | ty::TyEnum(_, substs) => substs,\n+        let (substs, kind_name) = match adt_ty.sty {\n+            ty::TyEnum(_, substs) => (substs, \"variant\"),\n+            ty::TyStruct(_, substs) => (substs, \"struct\"),\n+            ty::TyUnion(_, substs) => (substs, \"union\"),\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3175,7 +3178,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     err.emit();\n                 } else {\n-                    self.report_unknown_field(adt_ty, variant, field, ast_fields);\n+                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n                 }\n             }\n \n@@ -3184,11 +3187,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_expr_coercable_to_type(&field.expr, expected_field_type);\n         }\n \n-            // Make sure the programmer specified all the fields.\n-        if check_completeness &&\n-            !error_happened &&\n-            !remaining_fields.is_empty()\n-        {\n+        // Make sure the programmer specified correct number of fields.\n+        if kind_name == \"union\" {\n+            if ast_fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union expressions should have exactly one field\");\n+            }\n+        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n             span_err!(tcx.sess, span, E0063,\n                       \"missing field{} {} in initializer of `{}`\",\n                       if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n@@ -3198,7 +3202,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       .join(\", \"),\n                       adt_ty);\n         }\n-\n     }\n \n     fn check_struct_fields_on_error(&self,"}, {"sha": "ec9dc1bae5ad9061f0ac2e643a87885c914f0add", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -5957,8 +5957,10 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.eat_keyword(keywords::Union) {\n+        if self.check_keyword(keywords::Union) &&\n+                self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword()) {\n             // UNION ITEM\n+            self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_union()?;\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,"}, {"sha": "d5f1614c14d2d0d8b1bfe7d73f6228159d885c9a", "filename": "src/test/compile-fail/issue-17800.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -18,7 +18,7 @@ enum MyOption<T> {\n fn main() {\n     match MyOption::MySome(42) {\n         MyOption::MySome { x: 42 } => (),\n-        //~^ ERROR struct `MyOption::MySome` does not have a field named `x`\n+        //~^ ERROR variant `MyOption::MySome` does not have a field named `x`\n         //~| ERROR pattern does not mention field `0`\n         _ => (),\n     }"}, {"sha": "a8350fe0986c044c4241a01aef05f53d78022bc9", "filename": "src/test/compile-fail/issue-19922.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -14,5 +14,5 @@ enum Homura {\n \n fn main() {\n     let homura = Homura::Akemi { kaname: () };\n-    //~^ ERROR struct variant `Homura::Akemi` has no field named `kaname`\n+    //~^ ERROR variant `Homura::Akemi` has no field named `kaname`\n }"}, {"sha": "c93e75042dd1752c352cb4d88265baae9405afba", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -13,5 +13,5 @@\n struct NonCopyable(());\n \n fn main() {\n-    let z = NonCopyable{ p: () }; //~ ERROR structure `NonCopyable` has no field named `p`\n+    let z = NonCopyable{ p: () }; //~ ERROR struct `NonCopyable` has no field named `p`\n }"}, {"sha": "c4aff9471b8a108573a0736cbe3c7d79052c1245", "filename": "src/test/compile-fail/numeric-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -13,7 +13,7 @@\n struct S(u8, u16);\n \n fn main() {\n-    let s = S{0b1: 10, 0: 11}; //~ ERROR structure `S` has no field named `0b1`\n+    let s = S{0b1: 10, 0: 11}; //~ ERROR struct `S` has no field named `0b1`\n     match s {\n         S{0: a, 0x1: b, ..} => {} //~ ERROR does not have a field named `0x1`\n     }"}, {"sha": "5f1f8ca856f9c7fff0698bbadbdca46f1d6b2f94", "filename": "src/test/compile-fail/struct-fields-hints-no-dupe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -17,7 +17,7 @@ struct A {\n fn main() {\n     let a = A {\n         foo : 5,\n-        bar : 42,//~ ERROR structure `A` has no field named `bar`\n+        bar : 42,//~ ERROR struct `A` has no field named `bar`\n         //~^ HELP did you mean `barr`?\n         car : 9,\n     };"}, {"sha": "4ba1fd2f7bb33de6a946f77c1ca7018ff6ac5654", "filename": "src/test/compile-fail/struct-fields-hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -17,7 +17,7 @@ struct A {\n fn main() {\n     let a = A {\n         foo : 5,\n-        bar : 42,//~ ERROR structure `A` has no field named `bar`\n+        bar : 42,//~ ERROR struct `A` has no field named `bar`\n         //~^ HELP did you mean `car`?\n     };\n }"}, {"sha": "5d16573f2f1e3e373070389e4ef589c55d56f5c4", "filename": "src/test/compile-fail/struct-fields-too-many.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -15,6 +15,6 @@ struct BuildData {\n fn main() {\n     let foo = BuildData {\n         foo: 0,\n-        bar: 0 //~ ERROR structure `BuildData` has no field named `bar`\n+        bar: 0 //~ ERROR struct `BuildData` has no field named `bar`\n     };\n }"}, {"sha": "41bd00a518c5c01caab4d4242fdf1911624b6f8b", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -22,16 +22,16 @@ struct A {\n fn main () {\n     // external crate struct\n     let k = B {\n-        aa: 20, //~ ERROR structure `xc::B` has no field named `aa`\n+        aa: 20, //~ ERROR struct `xc::B` has no field named `aa`\n         //~^ HELP did you mean `a`?\n-        bb: 20, //~ ERROR structure `xc::B` has no field named `bb`\n+        bb: 20, //~ ERROR struct `xc::B` has no field named `bb`\n         //~^ HELP did you mean `a`?\n     };\n     // local crate struct\n     let l = A {\n-        aa: 20, //~ ERROR structure `A` has no field named `aa`\n+        aa: 20, //~ ERROR struct `A` has no field named `aa`\n         //~^ HELP did you mean `a`?\n-        bb: 20, //~ ERROR structure `A` has no field named `bb`\n+        bb: 20, //~ ERROR struct `A` has no field named `bb`\n         //~^ HELP did you mean `b`?\n     };\n }"}, {"sha": "ce5bbf60fee2547eeb9a6ccdfca8e4f2d9efb3be", "filename": "src/test/compile-fail/union-empty.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Funion-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Funion-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion-empty.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {} //~ ERROR unions cannot have zero fields\n+\n+fn main() {}"}, {"sha": "2bd1b8a7b32c2da68d8f3eee1a160c9aa91cf694", "filename": "src/test/compile-fail/union-fields.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Funion-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Fcompile-fail%2Funion-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion-fields.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8,\n+    b: u16,\n+}\n+\n+fn main() {\n+    let u = U {}; //~ ERROR union expressions should have exactly one field\n+    let u = U { a: 0 }; // OK\n+    let u = U { a: 0, b: 1 }; //~ ERROR union expressions should have exactly one field\n+    let u = U { a: 0, b: 1, c: 2 }; //~ ERROR union expressions should have exactly one field\n+                                    //~^ ERROR union `U` has no field named `c`\n+    let u = U { ..u }; //~ ERROR union expressions should have exactly one field\n+                       //~^ ERROR functional record update syntax requires a struct\n+\n+    let U {} = u; //~ ERROR union patterns without `..` should have at least one field\n+    let U { a } = u; // OK\n+    let U { a, b } = u; //~ ERROR union patterns can have at most one field\n+    let U { a, b, c } = u; //~ ERROR union patterns can have at most one field\n+                           //~^ ERROR union `U` does not have a field named `c`\n+    let U { .. } = u; // OK\n+    let U { a, .. } = u; // OK\n+}"}, {"sha": "c1210dd6212104db9ab8df4c27d1217b26b0a6b9", "filename": "src/test/run-pass/union-backcomp.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-backcomp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-backcomp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion-backcomp.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+fn main() {\n+    let union = 10;\n+\n+    union;\n+\n+    union as u8;\n+\n+    union U {\n+        a: u8,\n+    }\n+}"}, {"sha": "dee86b232b4857d6cd1da7434117992d4b3b8c30", "filename": "src/test/run-pass/union-basic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion-basic.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -25,13 +25,21 @@ union W {\n     b: u64,\n }\n \n+#[repr(C)]\n+union Y {\n+    f1: u16,\n+    f2: [u8; 4],\n+}\n+\n fn main() {\n     assert_eq!(size_of::<U>(), 1);\n     assert_eq!(size_of::<U64>(), 8);\n     assert_eq!(size_of::<W>(), 8);\n     assert_eq!(align_of::<U>(), 1);\n     assert_eq!(align_of::<U64>(), align_of::<u64>());\n     assert_eq!(align_of::<W>(), align_of::<u64>());\n+    assert_eq!(size_of::<Y>(), 4);\n+    assert_eq!(align_of::<Y>(), 2);\n \n     let u = U { a: 10 };\n     assert_eq!(u.a, 10);"}, {"sha": "467403ff2e126662bb9fd5d3523d84c8455b216a", "filename": "src/test/run-pass/union-drop.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion-drop.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Drop works for union itself.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8\n+}\n+\n+impl Drop for U {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    // 'unions are not fully implemented', src/librustc_trans/glue.rs:567\n+    // let u = U { a: 1 };\n+}"}, {"sha": "6b39eed7ac942c3a580ef87e22f8db9fb4288e64", "filename": "src/test/run-pass/union-pat-refutability.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-pat-refutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea/src%2Ftest%2Frun-pass%2Funion-pat-refutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion-pat-refutability.rs?ref=f3b41c18a8dfbcfec4b2a9e8d9e6a921189e3eea", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[repr(u32)]\n+enum Tag { I, F }\n+\n+#[repr(C)]\n+union U {\n+    i: i32,\n+    f: f32,\n+}\n+\n+#[repr(C)]\n+struct Value {\n+    tag: Tag,\n+    u: U,\n+}\n+\n+fn is_zero(v: Value) -> bool {\n+    unsafe {\n+        match v {\n+            Value { tag: Tag::I, u: U { i: 0 } } => true,\n+            Value { tag: Tag::F, u: U { f: 0.0 } } => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+union W {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn refut(w: W) {\n+    match w {\n+        W { a: 10 } => {\n+            panic!();\n+        }\n+        W { b } => {\n+            assert_eq!(b, 11);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    // ICE\n+    // let v = Value { tag: Tag::I, u: U { i: 1 } };\n+    // assert_eq!(is_zero(v), false);\n+\n+    // ICE\n+    // let w = W { a: 11 };\n+    // refut(w);\n+}"}]}