{"sha": "8961063c605702435d1b1f699b6883b9722af87c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NjEwNjNjNjA1NzAyNDM1ZDFiMWY2OTliNjg4M2I5NzIyYWY4N2M=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-25T06:37:52Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-25T06:39:12Z"}, "message": "Handle some cases of StructWrappedNullablePointer.\n\n... plus a bunch of minor refactorings.", "tree": {"sha": "9b0562ac1aca26606fddb21673b7a350bc50deee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b0562ac1aca26606fddb21673b7a350bc50deee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8961063c605702435d1b1f699b6883b9722af87c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8961063c605702435d1b1f699b6883b9722af87c", "html_url": "https://github.com/rust-lang/rust/commit/8961063c605702435d1b1f699b6883b9722af87c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8961063c605702435d1b1f699b6883b9722af87c/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51c5b6392d7679b2e7adb6e3a6e375b97432c39b", "url": "https://api.github.com/repos/rust-lang/rust/commits/51c5b6392d7679b2e7adb6e3a6e375b97432c39b", "html_url": "https://github.com/rust-lang/rust/commit/51c5b6392d7679b2e7adb6e3a6e375b97432c39b"}], "stats": {"total": 184, "additions": 130, "deletions": 54}, "files": [{"sha": "a7df8748ae402b1d762d9838c4db61d5d9387493", "filename": "src/interpreter.rs", "status": "modified", "additions": 130, "deletions": 31, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8961063c605702435d1b1f699b6883b9722af87c/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8961063c605702435d1b1f699b6883b9722af87c/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=8961063c605702435d1b1f699b6883b9722af87c", "patch": "@@ -6,7 +6,7 @@ use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n use std::ops::{Deref, DerefMut};\n@@ -413,7 +413,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(target)\n     }\n \n-    fn drop(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<()> {\n+    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n         if !self.type_needs_drop(ty) {\n             self.log(1, || print!(\"no need to drop {:?}\", ty));\n             return Ok(());\n@@ -455,7 +455,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: ty::Ty<'tcx>) -> EvalResult<u64> {\n+    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty);\n \n@@ -466,16 +466,14 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n \n             RawNullablePointer { nndiscr, .. } => {\n-                let not_null = match self.memory.read_usize(adt_ptr) {\n-                    Ok(0) => false,\n-                    Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n-                    Err(e) => return Err(e),\n-                };\n-                assert!(nndiscr == 0 || nndiscr == 1);\n-                if not_null { nndiscr } else { 1 - nndiscr }\n+                self.read_nonnull_discriminant_value(adt_ptr, nndiscr)?\n             }\n \n-            StructWrappedNullablePointer { .. } => unimplemented!(),\n+            StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n+                let offset = self.nonnull_offset(adt_ty, nndiscr, discrfield);\n+                let nonnull = adt_ptr.offset(offset.bytes() as isize);\n+                self.read_nonnull_discriminant_value(nonnull, nndiscr)?\n+            }\n \n             // The discriminant_value intrinsic returns 0 for non-sum types.\n             Array { .. } | FatPointer { .. } | Scalar { .. } | Univariant { .. } |\n@@ -485,6 +483,16 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(discr_val)\n     }\n \n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<u64> {\n+        let not_null = match self.memory.read_usize(ptr) {\n+            Ok(0) => false,\n+            Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n+            Err(e) => return Err(e),\n+        };\n+        assert!(nndiscr == 0 || nndiscr == 1);\n+        Ok(if not_null { nndiscr } else { 1 - nndiscr })\n+    }\n+\n     fn call_intrinsic(\n         &mut self,\n         name: &str,\n@@ -793,6 +801,23 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                         }\n                     }\n \n+                    StructWrappedNullablePointer { nndiscr, ref nonnull, ref discrfield } => {\n+                        if let mir::AggregateKind::Adt(_, variant, _) = *kind {\n+                            if nndiscr == variant as u64 {\n+                                let offsets = iter::once(0)\n+                                    .chain(nonnull.offset_after_field.iter().map(|s| s.bytes()));\n+                                try!(self.assign_fields(dest, offsets, operands));\n+                            } else {\n+                                assert_eq!(operands.len(), 0);\n+                                let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield);\n+                                let dest = dest.offset(offset.bytes() as isize);\n+                                try!(self.memory.write_isize(dest, 0));\n+                            }\n+                        } else {\n+                            panic!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n+                        }\n+                    }\n+\n                     CEnum { discr, signed, .. } => {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _) = *kind {\n@@ -900,6 +925,73 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(())\n     }\n \n+    fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> Size {\n+        // Skip the constant 0 at the start meant for LLVM GEP.\n+        let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n+\n+        // Handle the field index for the outer non-null variant.\n+        let inner_ty = match ty.sty {\n+            ty::TyEnum(adt_def, substs) => {\n+                let variant = &adt_def.variants[nndiscr as usize];\n+                let index = path.next().unwrap();\n+                let field = &variant.fields[index];\n+                field.ty(self.tcx, substs)\n+            }\n+            _ => panic!(\n+                \"non-enum for StructWrappedNullablePointer: {}\",\n+                ty,\n+            ),\n+        };\n+\n+        self.field_path_offset(inner_ty, path)\n+    }\n+\n+    fn field_path_offset<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> Size {\n+        let mut offset = Size::from_bytes(0);\n+\n+        // Skip the initial 0 intended for LLVM GEP.\n+        for field_index in path {\n+            let field_offset = self.get_field_offset(ty, field_index);\n+            ty = self.get_field_ty(ty, field_index);\n+            offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n+        }\n+\n+        offset\n+    }\n+\n+    fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::TyStruct(adt_def, substs) => {\n+                adt_def.struct_variant().fields[field_index].ty(self.tcx, substs)\n+            }\n+\n+            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyBox(ty) => {\n+                assert_eq!(field_index, 0);\n+                ty\n+            }\n+            _ => panic!(\"can't handle type: {:?}\", ty),\n+        }\n+    }\n+\n+    fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> Size {\n+        let layout = self.type_layout(ty);\n+\n+        use rustc::ty::layout::Layout::*;\n+        match *layout {\n+            Univariant { .. } => {\n+                assert_eq!(field_index, 0);\n+                Size::from_bytes(0)\n+            }\n+            FatPointer { .. } => {\n+                let bytes = layout::FAT_PTR_ADDR * self.memory.pointer_size;\n+                Size::from_bytes(bytes as u64)\n+            }\n+            _ => panic!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout),\n+        }\n+    }\n+\n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n@@ -944,35 +1036,42 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n                     Field(field, _) => {\n+                        use rustc::ty::layout::Layout::*;\n                         let variant = match *base_layout {\n-                            Layout::Univariant { ref variant, .. } => variant,\n-                            Layout::General { ref variants, .. } => {\n+                            Univariant { ref variant, .. } => variant,\n+                            General { ref variants, .. } => {\n                                 if let LvalueExtra::DowncastVariant(variant_idx) = base.extra {\n                                     &variants[variant_idx]\n                                 } else {\n                                     panic!(\"field access on enum had no variant index\");\n                                 }\n                             }\n-                            Layout::RawNullablePointer { .. } => {\n+                            RawNullablePointer { .. } => {\n                                 assert_eq!(field.index(), 0);\n                                 return Ok(base);\n                             }\n+                            StructWrappedNullablePointer { ref nonnull, .. } => nonnull,\n                             _ => panic!(\"field access on non-product type: {:?}\", base_layout),\n                         };\n \n                         let offset = variant.field_offset(field.index()).bytes();\n                         base.ptr.offset(offset as isize)\n                     },\n \n-                    Downcast(_, variant) => match *base_layout {\n-                        Layout::General { discr, .. } => {\n-                            return Ok(Lvalue {\n-                                ptr: base.ptr.offset(discr.size().bytes() as isize),\n-                                extra: LvalueExtra::DowncastVariant(variant),\n-                            });\n+                    Downcast(_, variant) => {\n+                        use rustc::ty::layout::Layout::*;\n+                        match *base_layout {\n+                            General { discr, .. } => {\n+                                return Ok(Lvalue {\n+                                    ptr: base.ptr.offset(discr.size().bytes() as isize),\n+                                    extra: LvalueExtra::DowncastVariant(variant),\n+                                });\n+                            }\n+                            RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n+                                return Ok(base);\n+                            }\n+                            _ => panic!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n                         }\n-                        Layout::RawNullablePointer { .. } => return Ok(base),\n-                        _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_layout),\n                     },\n \n                     Deref => {\n@@ -1052,24 +1151,24 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         }\n     }\n \n-    fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> ty::Ty<'tcx> {\n+    fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx))\n     }\n \n-    fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> ty::Ty<'tcx> {\n+    fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(self.mir().operand_ty(self.tcx, operand))\n     }\n \n-    fn monomorphize(&self, ty: ty::Ty<'tcx>) -> ty::Ty<'tcx> {\n+    fn monomorphize(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let substituted = ty.subst(self.tcx, self.substs());\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_needs_drop(&self, ty: ty::Ty<'tcx>) -> bool {\n+    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n         self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n     }\n \n-    fn move_(&mut self, src: Pointer, dest: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<()> {\n+    fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n         let size = self.type_size(ty);\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n@@ -1078,15 +1177,15 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn type_is_sized(&self, ty: ty::Ty<'tcx>) -> bool {\n+    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n-    fn type_size(&self, ty: ty::Ty<'tcx>) -> usize {\n+    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n         self.type_layout(ty).size(&self.tcx.data_layout).bytes() as usize\n     }\n \n-    fn type_layout(&self, ty: ty::Ty<'tcx>) -> &'tcx Layout {\n+    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty);\n \n@@ -1096,7 +1195,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         })\n     }\n \n-    pub fn read_primval(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<PrimVal> {\n+    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n         let val = match ty.sty {\n             ty::TyBool              => PrimVal::Bool(self.memory.read_bool(ptr)?),"}, {"sha": "880ca42d45557942593f61e4377775b47ee5a234", "filename": "tests/compile-fail/bugs/struct_wrapped_nullable_pointer.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51c5b6392d7679b2e7adb6e3a6e375b97432c39b/tests%2Fcompile-fail%2Fbugs%2Fstruct_wrapped_nullable_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c5b6392d7679b2e7adb6e3a6e375b97432c39b/tests%2Fcompile-fail%2Fbugs%2Fstruct_wrapped_nullable_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbugs%2Fstruct_wrapped_nullable_pointer.rs?ref=51c5b6392d7679b2e7adb6e3a6e375b97432c39b", "patch": "@@ -1,23 +0,0 @@\n-#![feature(custom_attribute, box_syntax)]\n-#![allow(dead_code, unused_attributes)]\n-\n-// error-pattern:can't handle destination layout StructWrappedNullablePointer\n-\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct Loop(Rc<RefCell<Option<Loop>>>);\n-\n-#[miri_run]\n-fn rc_reference_cycle() -> Loop {\n-    let a = Rc::new(RefCell::new(None));\n-    let b = a.clone();\n-    *a.borrow_mut() = Some(Loop(b));\n-    Loop(a)\n-}\n-\n-#[miri_run]\n-fn main() {\n-    let x = rc_reference_cycle().0;\n-    assert!(x.borrow().is_some());\n-}"}]}