{"sha": "01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNDEzZGQ3ZDRkMDRiYTNjMTMyNGJiMTQ5YWQyNWI2OGQ5M2RkOTg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-04T18:00:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-04T18:00:45Z"}, "message": "extract_function does not move locals defined outside of loops", "tree": {"sha": "e7813e0d6a9cd183459e71026505ad1e0d9886a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7813e0d6a9cd183459e71026505ad1e0d9886a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "html_url": "https://github.com/rust-lang/rust/commit/01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01413dd7d4d04ba3c1324bb149ad25b68d93dd98/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55441f7ed944fa0fd56a2a225fb72ee5a5044c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55441f7ed944fa0fd56a2a225fb72ee5a5044c0", "html_url": "https://github.com/rust-lang/rust/commit/f55441f7ed944fa0fd56a2a225fb72ee5a5044c0"}], "stats": {"total": 155, "additions": 141, "deletions": 14}, "files": [{"sha": "bae62908a190cef2900b86d4894d8977f49692bb", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 118, "deletions": 14, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/01413dd7d4d04ba3c1324bb149ad25b68d93dd98/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01413dd7d4d04ba3c1324bb149ad25b68d93dd98/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "patch": "@@ -96,7 +96,8 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 return;\n             }\n \n-            let params = body.extracted_function_params(ctx, locals_used.iter().copied());\n+            let params =\n+                body.extracted_function_params(ctx, &container_info, locals_used.iter().copied());\n \n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n@@ -183,8 +184,8 @@ struct Function {\n struct Param {\n     var: Local,\n     ty: hir::Type,\n-    has_usages_afterwards: bool,\n-    has_mut_inside_body: bool,\n+    move_local: bool,\n+    requires_mut: bool,\n     is_copy: bool,\n }\n \n@@ -226,6 +227,7 @@ struct ControlFlow {\n struct ContainerInfo {\n     is_const: bool,\n     is_in_tail: bool,\n+    parent_loop: Option<SyntaxNode>,\n     /// The function's return type, const's type etc.\n     ret_type: Option<hir::Type>,\n }\n@@ -335,11 +337,11 @@ impl ParamKind {\n \n impl Param {\n     fn kind(&self) -> ParamKind {\n-        match (self.has_usages_afterwards, self.has_mut_inside_body, self.is_copy) {\n-            (true, true, _) => ParamKind::MutRef,\n-            (true, false, false) => ParamKind::SharedRef,\n-            (false, true, _) => ParamKind::MutValue,\n-            (true, false, true) | (false, false, _) => ParamKind::Value,\n+        match (self.move_local, self.requires_mut, self.is_copy) {\n+            (false, true, _) => ParamKind::MutRef,\n+            (false, false, false) => ParamKind::SharedRef,\n+            (true, true, _) => ParamKind::MutValue,\n+            (_, false, _) => ParamKind::Value,\n         }\n     }\n \n@@ -622,6 +624,15 @@ impl FunctionBody {\n     fn analyze_container(&self, sema: &Semantics<RootDatabase>) -> Option<ContainerInfo> {\n         let mut ancestors = self.parent()?.ancestors();\n         let infer_expr_opt = |expr| sema.type_of_expr(&expr?).map(TypeInfo::adjusted);\n+        let mut parent_loop = None;\n+        let mut set_parent_loop = |loop_: &dyn ast::LoopBodyOwner| {\n+            if loop_\n+                .loop_body()\n+                .map_or(false, |it| it.syntax().text_range().contains_range(self.text_range()))\n+            {\n+                parent_loop.get_or_insert(loop_.syntax().clone());\n+            }\n+        };\n         let (is_const, expr, ty) = loop {\n             let anc = ancestors.next()?;\n             break match_ast! {\n@@ -658,6 +669,18 @@ impl FunctionBody {\n                     },\n                     ast::Variant(__) => return None,\n                     ast::Meta(__) => return None,\n+                    ast::LoopExpr(it) => {\n+                        set_parent_loop(&it);\n+                        continue;\n+                    },\n+                    ast::ForExpr(it) => {\n+                        set_parent_loop(&it);\n+                        continue;\n+                    },\n+                    ast::WhileExpr(it) => {\n+                        set_parent_loop(&it);\n+                        continue;\n+                    },\n                     _ => continue,\n                 }\n             };\n@@ -670,7 +693,7 @@ impl FunctionBody {\n             container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n                 container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n             });\n-        Some(ContainerInfo { is_in_tail, is_const, ret_type: ty })\n+        Some(ContainerInfo { is_in_tail, is_const, parent_loop, ret_type: ty })\n     }\n \n     fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n@@ -780,34 +803,38 @@ impl FunctionBody {\n \n         Some(ControlFlow { kind, is_async, is_unsafe: _is_unsafe })\n     }\n+\n     /// find variables that should be extracted as params\n     ///\n     /// Computes additional info that affects param type and mutability\n     fn extracted_function_params(\n         &self,\n         ctx: &AssistContext,\n+        container_info: &ContainerInfo,\n         locals: impl Iterator<Item = Local>,\n     ) -> Vec<Param> {\n         locals\n             .map(|local| (local, local.source(ctx.db())))\n             .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))\n             .filter_map(|(local, src)| {\n-                if src.value.is_left() {\n-                    Some(local)\n+                if let Either::Left(src) = src.value {\n+                    Some((local, src))\n                 } else {\n                     stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n                     None\n                 }\n             })\n-            .map(|var| {\n+            .map(|(var, src)| {\n                 let usages = LocalUsages::find_local_usages(ctx, var);\n                 let ty = var.ty(ctx.db());\n                 let is_copy = ty.is_copy(ctx.db());\n                 Param {\n                     var,\n                     ty,\n-                    has_usages_afterwards: self.has_usages_after_body(&usages),\n-                    has_mut_inside_body: has_exclusive_usages(ctx, &usages, self),\n+                    move_local: container_info.parent_loop.as_ref().map_or(true, |it| {\n+                        it.text_range().contains_range(src.syntax().text_range())\n+                    }) && !self.has_usages_after_body(&usages),\n+                    requires_mut: has_exclusive_usages(ctx, &usages, self),\n                     is_copy,\n                 }\n             })\n@@ -4009,6 +4036,83 @@ const FOO: () = {\n const fn $0fun_name() {\n     ()\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_move_outer_loop_vars() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    let mut x = 5;\n+    for _ in 0..10 {\n+        $0x += 1;$0\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let mut x = 5;\n+    for _ in 0..10 {\n+        fun_name(&mut x);\n+    }\n+}\n+\n+fn $0fun_name(x: &mut i32) {\n+    *x += 1;\n+}\n+\"#,\n+        );\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    for _ in 0..10 {\n+        let mut x = 5;\n+        $0x += 1;$0\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    for _ in 0..10 {\n+        let mut x = 5;\n+        fun_name(x);\n+    }\n+}\n+\n+fn $0fun_name(mut x: i32) {\n+    x += 1;\n+}\n+\"#,\n+        );\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    loop {\n+        let mut x = 5;\n+        for _ in 0..10 {\n+            $0x += 1;$0\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    loop {\n+        let mut x = 5;\n+        for _ in 0..10 {\n+            fun_name(&mut x);\n+        }\n+    }\n+}\n+\n+fn $0fun_name(x: &mut i32) {\n+    *x += 1;\n+}\n \"#,\n         );\n     }"}, {"sha": "2532738562bd4465f93d697caec22f20aea0ec61", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/01413dd7d4d04ba3c1324bb149ad25b68d93dd98/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01413dd7d4d04ba3c1324bb149ad25b68d93dd98/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "patch": "@@ -17,6 +17,7 @@\n //!     deref_mut: deref\n //!     index: sized\n //!     fn:\n+//!     try:\n //!     pin:\n //!     future: pin\n //!     option:\n@@ -266,6 +267,28 @@ pub mod ops {\n     }\n     pub use self::function::{Fn, FnMut, FnOnce};\n     // endregion:fn\n+    // region:try\n+    mod try_ {\n+        pub enum ControlFlow<B, C = ()> {\n+            Continue(C),\n+            Break(B),\n+        }\n+        pub trait FromResidual<R = Self::Residual> {\n+            #[lang = \"from_residual\"]\n+            fn from_residual(residual: R) -> Self;\n+        }\n+        #[lang = \"try\"]\n+        pub trait Try: FromResidual<Self::Residual> {\n+            type Output;\n+            type Residual;\n+            #[lang = \"from_output\"]\n+            fn from_output(output: Self::Output) -> Self;\n+            #[lang = \"branch\"]\n+            fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;\n+        }\n+    }\n+    pub use self::try_::{ControlFlow, FromResidual, Try};\n+    // endregion:try\n }\n \n // region:eq"}]}