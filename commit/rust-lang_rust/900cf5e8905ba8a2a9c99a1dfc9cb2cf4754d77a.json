{"sha": "900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "node_id": "C_kwDOAAsO6NoAKDkwMGNmNWU4OTA1YmE4YTJhOWM5OWExZGZjOWNiMmNmNDc1NGQ3N2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-23T22:45:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-23T22:45:22Z"}, "message": "Auto merge of #88804 - Mark-Simulacrum:never-algo-v2, r=nikomatsakis,jackh726\n\nRevise never type fallback algorithm\n\nThis is a rebase of https://github.com/rust-lang/rust/pull/84573, but dropping the stabilization of never type (and the accompanying large test diff).\n\nEach commit builds & has tests updated alongside it, and could be reviewed in a more or less standalone fashion. But it may make more sense to review the PR as a whole, I'm not sure. It should be noted that tests being updated isn't really a good indicator of final behavior -- never_type_fallback is not enabled by default in this PR, so we can't really see the full effects of the commits here.\n\nThis combines the work by Niko, which is [documented in this gist](https://gist.github.com/nikomatsakis/7a07b265dc12f5c3b3bd0422018fa660), with some additional rules largely derived to target specific known patterns that regress with the algorithm solely derived by Niko. We build these from an intuition that:\n\n* In general, fallback to `()` is *sound* in all cases\n* But, in general, we *prefer* fallback to `!` as it accepts more code, particularly that written to intentionally use `!` (e.g., Result's with a Infallible/! variant).\n\nWhen evaluating Niko's proposed algorithm, we find that there are certain cases where fallback to `!` leads to compilation failures in real-world code, and fallback to `()` fixes those errors. In order to allow for stabilization, we need to fix a good portion of these patterns.\n\nThe final rule set this PR proposes is that, by default, we fallback from `?T` to `!`, with the following exceptions:\n\n1. `?T: Foo` and `Bar::Baz = ?T` and `(): Foo`, then fallback to `()`\n2. Per [Niko's algorithm](https://gist.github.com/nikomatsakis/7a07b265dc12f5c3b3bd0422018fa660#proposal-fallback-chooses-between--and--based-on-the-coercion-graph), the \"live\" `?T` also fallback to `()`.\n\nThe first rule is necessary to address a fairly common pattern which boils down to something like the snippet below. Without rule 1, we do not see the closure's return type as needing a () fallback, which leads to compilation failure.\n\n```rust\n#![feature(never_type_fallback)]\n\ntrait Bar { }\nimpl Bar for () {  }\nimpl Bar for u32 {  }\n\nfn foo<R: Bar>(_: impl Fn() -> R) {}\n\nfn main() {\n    foo(|| panic!());\n}\n```\n\nr? `@jackh726`", "tree": {"sha": "8e5fd45ac208f2c935d848129b42cc5b892a1768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e5fd45ac208f2c935d848129b42cc5b892a1768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "html_url": "https://github.com/rust-lang/rust/commit/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b862bed9889808b69629fd7246317189b9517a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b862bed9889808b69629fd7246317189b9517a5", "html_url": "https://github.com/rust-lang/rust/commit/2b862bed9889808b69629fd7246317189b9517a5"}, {"sha": "c4c5fc8c4ce976387b3c7bc012ac274b4559b8ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c5fc8c4ce976387b3c7bc012ac274b4559b8ef", "html_url": "https://github.com/rust-lang/rust/commit/c4c5fc8c4ce976387b3c7bc012ac274b4559b8ef"}], "stats": {"total": 907, "additions": 733, "deletions": 174}, "files": [{"sha": "8dd7e6af257fc53f1bf74d3ae4328f401af4d552", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -22,14 +22,14 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n+use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::unify_key::replace_if_possible;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use super::{equate::Equate, type_variable::Diverging};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n@@ -645,7 +645,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 .inner\n                                 .borrow_mut()\n                                 .type_variables()\n-                                .new_var(self.for_universe, Diverging::NotDiverging, origin);\n+                                .new_var(self.for_universe, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n \n                             // Record that we replaced `vid` with `new_var_id` as part of a generalization\n@@ -885,11 +885,12 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n \n                         let origin =\n                             *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n-                        let new_var_id = self.infcx.inner.borrow_mut().type_variables().new_var(\n-                            self.for_universe,\n-                            Diverging::NotDiverging,\n-                            origin,\n-                        );\n+                        let new_var_id = self\n+                            .infcx\n+                            .inner\n+                            .borrow_mut()\n+                            .type_variables()\n+                            .new_var(self.for_universe, origin);\n                         let u = self.tcx().mk_ty_var(new_var_id);\n                         debug!(\n                             \"ConstInferUnifier: replacing original vid={:?} with new={:?}\","}, {"sha": "632e792bbd1acadccd66b06465116facb2ee18a1", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -46,7 +46,7 @@ use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, Veri\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n-use self::type_variable::{Diverging, TypeVariableOrigin, TypeVariableOriginKind};\n+use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n pub mod canonical;\n@@ -702,17 +702,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.freshener())\n     }\n \n-    /// Returns whether `ty` is a diverging type variable or not.\n-    /// (If `ty` is not a type variable at all, returns not diverging.)\n-    ///\n-    /// No attempt is made to resolve `ty`.\n-    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> Diverging {\n-        match *ty.kind() {\n-            ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n-            _ => Diverging::NotDiverging,\n-        }\n-    }\n-\n     /// Returns the origin of the type variable identified by `vid`, or `None`\n     /// if this is not a type variable.\n     ///\n@@ -1071,31 +1060,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: Diverging, origin: TypeVariableOrigin) -> TyVid {\n-        self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n+    /// Number of type variables created so far.\n+    pub fn num_ty_vars(&self) -> usize {\n+        self.inner.borrow_mut().type_variables().num_vars()\n+    }\n+\n+    pub fn next_ty_var_id(&self, origin: TypeVariableOrigin) -> TyVid {\n+        self.inner.borrow_mut().type_variables().new_var(self.universe(), origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::NotDiverging, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(origin))\n     }\n \n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(\n-            universe,\n-            Diverging::NotDiverging,\n-            origin,\n-        );\n+        let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::Diverges, origin))\n-    }\n-\n     pub fn next_const_var(\n         &self,\n         ty: Ty<'tcx>,\n@@ -1207,7 +1193,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // as the substitutions for the default, `(T, U)`.\n                 let ty_var_id = self.inner.borrow_mut().type_variables().new_var(\n                     self.universe(),\n-                    Diverging::NotDiverging,\n                     TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(\n                             param.name,"}, {"sha": "73d74584a5e13db33c74ced5712e7d8b7427eed4", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -22,7 +22,6 @@\n //!   constituents)\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::infer::type_variable::Diverging;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use rustc_data_structures::fx::FxHashMap;\n@@ -927,8 +926,7 @@ where\n                             // Replacing with a new variable in the universe `self.universe`,\n                             // it will be unified later with the original type variable in\n                             // the universe `_universe`.\n-                            let new_var_id =\n-                                variables.new_var(self.universe, Diverging::NotDiverging, origin);\n+                            let new_var_id = variables.new_var(self.universe, origin);\n \n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);"}, {"sha": "0e832685310d51b687d225f2fdb5139359f28383", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -129,19 +129,16 @@ pub enum TypeVariableOriginKind {\n     SubstitutionPlaceholder,\n     AutoDeref,\n     AdjustmentType,\n-    DivergingFn,\n+\n+    /// In type check, when we are type checking a function that\n+    /// returns `-> dyn Foo`, we substitute a type variable for the\n+    /// return type for diagnostic purposes.\n+    DynReturnFn,\n     LatticeVariable,\n }\n \n pub(crate) struct TypeVariableData {\n     origin: TypeVariableOrigin,\n-    diverging: Diverging,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum Diverging {\n-    NotDiverging,\n-    Diverges,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -191,14 +188,6 @@ impl<'tcx> TypeVariableStorage<'tcx> {\n }\n \n impl<'tcx> TypeVariableTable<'_, 'tcx> {\n-    /// Returns the diverges flag given when `vid` was created.\n-    ///\n-    /// Note that this function does not return care whether\n-    /// `vid` has been unified with something else or not.\n-    pub fn var_diverges(&self, vid: ty::TyVid) -> Diverging {\n-        self.storage.values.get(vid.index()).diverging\n-    }\n-\n     /// Returns the origin that was given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n@@ -260,21 +249,17 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     pub fn new_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n-        diverging: Diverging,\n         origin: TypeVariableOrigin,\n     ) -> ty::TyVid {\n         let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });\n \n         let sub_key = self.sub_relations().new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n \n-        let index = self.values().push(TypeVariableData { origin, diverging });\n+        let index = self.values().push(TypeVariableData { origin });\n         assert_eq!(eq_key.vid.as_u32(), index as u32);\n \n-        debug!(\n-            \"new_var(index={:?}, universe={:?}, diverging={:?}, origin={:?}\",\n-            eq_key.vid, universe, diverging, origin,\n-        );\n+        debug!(\"new_var(index={:?}, universe={:?}, origin={:?}\", eq_key.vid, universe, origin,);\n \n         eq_key.vid\n     }"}, {"sha": "a12f7dc759c09aa7d5a415896568cb5d557041e1", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,5 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ToPredicate, Ty, WithConstness};\n@@ -73,6 +74,8 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     }\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships>;\n }\n \n pub trait TraitEngineExt<'tcx> {"}, {"sha": "cc81ddbcc01b9806268b7db9f09121013a5d0c01", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -2090,3 +2090,16 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+#[derive(Debug, Default, Copy, Clone)]\n+pub struct FoundRelationships {\n+    /// This is true if we identified that this Ty (`?T`) is found in a `?T: Foo`\n+    /// obligation, where:\n+    ///\n+    ///  * `Foo` is not `Sized`\n+    ///  * `(): Foo` may be satisfied\n+    pub self_in_trait: bool,\n+    /// This is true if we identified that this Ty (`?T`) is found in a `<_ as\n+    /// _>::AssocType = ?T`\n+    pub output: bool,\n+}"}, {"sha": "1e17ba204b2c7ff2fc0548e9d0dda3532e0deb04", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1672,6 +1672,14 @@ impl<'tcx> TyS<'tcx> {\n         matches!(self.kind(), Infer(TyVar(_)))\n     }\n \n+    #[inline]\n+    pub fn ty_vid(&self) -> Option<ty::TyVid> {\n+        match self.kind() {\n+            &Infer(TyVar(vid)) => Some(vid),\n+            _ => None,\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n         matches!(self.kind(), Infer(_))"}, {"sha": "ec62ee400688ca2f62cae140fc32b1f40da8bf5e", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -7,16 +7,21 @@ use crate::traits::{\n     ChalkEnvironmentAndGoal, FulfillmentError, FulfillmentErrorCode, ObligationCause,\n     PredicateObligation, SelectionError, TraitEngine,\n };\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_middle::ty::{self, Ty};\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n+\n+    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n }\n \n impl FulfillmentContext<'tcx> {\n     crate fn new() -> Self {\n-        FulfillmentContext { obligations: FxIndexSet::default() }\n+        FulfillmentContext {\n+            obligations: FxIndexSet::default(),\n+            relationships: FxHashMap::default(),\n+        }\n     }\n }\n \n@@ -39,6 +44,8 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         assert!(!infcx.is_in_snapshot());\n         let obligation = infcx.resolve_vars_if_possible(obligation);\n \n+        super::relationships::update(self, infcx, &obligation);\n+\n         self.obligations.insert(obligation);\n     }\n \n@@ -146,4 +153,8 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.iter().cloned().collect()\n     }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        &mut self.relationships\n+    }\n }"}, {"sha": "61462f23886ce650c6e911ad02857ff5fe549bee", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,4 +1,5 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n@@ -53,6 +54,9 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+\n+    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n+\n     // Should this fulfillment context register type-lives-for-region\n     // obligations on its parent infcx? In some cases, region\n     // obligations are either already known to hold (normalization) or\n@@ -97,6 +101,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: true,\n             usable_in_snapshot: false,\n         }\n@@ -105,6 +110,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: true,\n             usable_in_snapshot: true,\n         }\n@@ -113,6 +119,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            relationships: FxHashMap::default(),\n             register_region_obligations: false,\n             usable_in_snapshot: false,\n         }\n@@ -210,6 +217,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n+        super::relationships::update(self, infcx, &obligation);\n+\n         self.predicates\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n@@ -265,6 +274,10 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        &mut self.relationships\n+    }\n }\n \n struct FulfillProcessor<'a, 'b, 'tcx> {"}, {"sha": "df2422048b9d7b90d60f97b7fc09f26b52675db8", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -15,6 +15,7 @@ mod object_safety;\n mod on_unimplemented;\n mod project;\n pub mod query;\n+pub(crate) mod relationships;\n mod select;\n mod specialize;\n mod structural_match;"}, {"sha": "7751dd84f4cac95d4b61f62d6706e67c7c23df16", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,69 @@\n+use crate::infer::InferCtxt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n+use crate::traits::{ObligationCause, PredicateObligation};\n+use rustc_infer::traits::TraitEngine;\n+use rustc_middle::ty::{self, ToPredicate};\n+\n+pub(crate) fn update<'tcx, T>(\n+    engine: &mut T,\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    obligation: &PredicateObligation<'tcx>,\n+) where\n+    T: TraitEngine<'tcx>,\n+{\n+    // (*) binder skipped\n+    if let ty::PredicateKind::Trait(predicate) = obligation.predicate.kind().skip_binder() {\n+        if let Some(ty) =\n+            infcx.shallow_resolve(predicate.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n+        {\n+            if infcx\n+                .tcx\n+                .lang_items()\n+                .sized_trait()\n+                .map_or(false, |st| st != predicate.trait_ref.def_id)\n+            {\n+                let new_self_ty = infcx.tcx.types.unit;\n+\n+                let trait_ref = ty::TraitRef {\n+                    substs: infcx\n+                        .tcx\n+                        .mk_substs_trait(new_self_ty, &predicate.trait_ref.substs[1..]),\n+                    ..predicate.trait_ref\n+                };\n+\n+                // Then contstruct a new obligation with Self = () added\n+                // to the ParamEnv, and see if it holds.\n+                let o = rustc_infer::traits::Obligation::new(\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                    obligation\n+                        .predicate\n+                        .kind()\n+                        .map_bound(|_| {\n+                            // (*) binder moved here\n+                            ty::PredicateKind::Trait(ty::TraitPredicate {\n+                                trait_ref,\n+                                constness: predicate.constness,\n+                            })\n+                        })\n+                        .to_predicate(infcx.tcx),\n+                );\n+                // Don't report overflow errors. Otherwise equivalent to may_hold.\n+                if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) {\n+                    if result.may_apply() {\n+                        engine.relationships().entry(ty).or_default().self_in_trait = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    if let ty::PredicateKind::Projection(predicate) = obligation.predicate.kind().skip_binder() {\n+        // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n+        // we need to make it into one.\n+        if let Some(vid) = predicate.ty.ty_vid() {\n+            debug!(\"relationship: {:?}.output = true\", vid);\n+            engine.relationships().entry(vid).or_default().output = true;\n+        }\n+    }\n+}"}, {"sha": "9f0ed0cd18d920aeeb125d9f5bcd4ed3902cdd21", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -241,32 +241,16 @@ pub(super) fn check_fn<'a, 'tcx>(\n     // we saw and assigning it to the expected return type. This isn't\n     // really expected to fail, since the coercions would have failed\n     // earlier when trying to find a LUB.\n-    //\n-    // However, the behavior around `!` is sort of complex. In the\n-    // event that the `actual_return_ty` comes back as `!`, that\n-    // indicates that the fn either does not return or \"returns\" only\n-    // values of type `!`. In this case, if there is an expected\n-    // return type that is *not* `!`, that should be ok. But if the\n-    // return type is being inferred, we want to \"fallback\" to `!`:\n-    //\n-    //     let x = move || panic!();\n-    //\n-    // To allow for that, I am creating a type variable with diverging\n-    // fallback. This was deemed ever so slightly better than unifying\n-    // the return value with `!` because it allows for the caller to\n-    // make more assumptions about the return type (e.g., they could do\n-    //\n-    //     let y: Option<u32> = Some(x());\n-    //\n-    // which would then cause this return type to become `u32`, not\n-    // `!`).\n     let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n     let mut actual_return_ty = coercion.complete(&fcx);\n-    if actual_return_ty.is_never() {\n-        actual_return_ty = fcx.next_diverging_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::DivergingFn,\n-            span,\n-        });\n+    debug!(\"actual_return_ty = {:?}\", actual_return_ty);\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // We have special-cased the case where the function is declared\n+        // `-> dyn Foo` and we don't actually relate it to the\n+        // `fcx.ret_coercion`, so just substitute a type variable.\n+        actual_return_ty =\n+            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n+        debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n     }\n     fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n "}, {"sha": "5b9481ce4e1b9d0cd92efa4d1014ce0f4130a83f", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -159,24 +159,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Coercing from `!` to any type is allowed:\n         if a.is_never() {\n-            // Subtle: If we are coercing from `!` to `?T`, where `?T` is an unbound\n-            // type variable, we want `?T` to fallback to `!` if not\n-            // otherwise constrained. An example where this arises:\n-            //\n-            //     let _: Option<?T> = Some({ return; });\n-            //\n-            // here, we would coerce from `!` to `?T`.\n-            return if b.is_ty_var() {\n-                // Micro-optimization: no need for this if `b` is\n-                // already resolved in some way.\n-                let diverging_ty = self.next_diverging_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::AdjustmentType,\n-                    span: self.cause.span,\n-                });\n-                self.coerce_from_inference_variable(diverging_ty, b, simple(Adjust::NeverToAny))\n-            } else {\n-                success(simple(Adjust::NeverToAny)(b), b, vec![])\n-            };\n+            return success(simple(Adjust::NeverToAny)(b), b, vec![]);\n         }\n \n         // Coercing *from* an unresolved inference variable means that"}, {"sha": "8a69e0a737d501c1b2aed4d780c1a65fd8b321da", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 !self.typeck_results.borrow().adjustments().contains_key(expr.hir_id),\n                 \"expression with never type wound up being adjusted\"\n             );\n-            let adj_ty = self.next_diverging_ty_var(TypeVariableOrigin {\n+            let adj_ty = self.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::AdjustmentType,\n                 span: expr.span,\n             });"}, {"sha": "296e45337ed1035b3ed1868396f371ba6b045c86", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 336, "deletions": 36, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,29 +1,52 @@\n use crate::check::FnCtxt;\n-use rustc_infer::infer::type_variable::Diverging;\n+use rustc_data_structures::{\n+    fx::FxHashMap,\n+    graph::WithSuccessors,\n+    graph::{iterate::DepthFirstSearch, vec_graph::VecGraph},\n+    stable_set::FxHashSet,\n+};\n use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// Performs type inference fallback, returning true if any fallback\n     /// occurs.\n     pub(super) fn type_inference_fallback(&self) -> bool {\n+        debug!(\n+            \"type-inference-fallback start obligations: {:#?}\",\n+            self.fulfillment_cx.borrow_mut().pending_obligations()\n+        );\n+\n         // All type checking constraints were added, try to fallback unsolved variables.\n         self.select_obligations_where_possible(false, |_| {});\n-        let mut fallback_has_occurred = false;\n \n+        debug!(\n+            \"type-inference-fallback post selection obligations: {:#?}\",\n+            self.fulfillment_cx.borrow_mut().pending_obligations()\n+        );\n+\n+        // Check if we have any unsolved varibales. If not, no need for fallback.\n+        let unsolved_variables = self.unsolved_variables();\n+        if unsolved_variables.is_empty() {\n+            return false;\n+        }\n+\n+        let diverging_fallback = self.calculate_diverging_fallback(&unsolved_variables);\n+\n+        let mut fallback_has_occurred = false;\n         // We do fallback in two passes, to try to generate\n         // better error messages.\n         // The first time, we do *not* replace opaque types.\n-        for ty in &self.unsolved_variables() {\n+        for ty in unsolved_variables {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty);\n+            fallback_has_occurred |= self.fallback_if_possible(ty, &diverging_fallback);\n         }\n \n-        // We now see if we can make progress. This might\n-        // cause us to unify inference variables for opaque types,\n-        // since we may have unified some other type variables\n-        // during the first phase of fallback.\n-        // This means that we only replace inference variables with their underlying\n-        // opaque types as a last resort.\n+        // We now see if we can make progress. This might cause us to\n+        // unify inference variables for opaque types, since we may\n+        // have unified some other type variables during the first\n+        // phase of fallback.  This means that we only replace\n+        // inference variables with their underlying opaque types as a\n+        // last resort.\n         //\n         // In code like this:\n         //\n@@ -62,36 +85,44 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     //\n     // - Unconstrained floats are replaced with with `f64`.\n     //\n-    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n-    //   is enabled. Otherwise, they are replaced with `()`.\n+    // - Non-numerics may get replaced with `()` or `!`, depending on\n+    //   how they were categorized by `calculate_diverging_fallback`\n+    //   (and the setting of `#![feature(never_type_fallback)]`).\n+    //\n+    // Fallback becomes very dubious if we have encountered\n+    // type-checking errors.  In that case, fallback to Error.\n     //\n-    // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n-    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+    fn fallback_if_possible(\n+        &self,\n+        ty: Ty<'tcx>,\n+        diverging_fallback: &FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+    ) -> bool {\n         // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n-        // is an unsolved variable, and we determine its fallback based\n-        // solely on how it was created, not what other type variables\n-        // it may have been unified with since then.\n+        // is an unsolved variable, and we determine its fallback\n+        // based solely on how it was created, not what other type\n+        // variables it may have been unified with since then.\n         //\n-        // The reason this matters is that other attempts at fallback may\n-        // (in principle) conflict with this fallback, and we wish to generate\n-        // a type error in that case. (However, this actually isn't true right now,\n-        // because we're only using the builtin fallback rules. This would be\n-        // true if we were using user-supplied fallbacks. But it's still useful\n-        // to write the code to detect bugs.)\n+        // The reason this matters is that other attempts at fallback\n+        // may (in principle) conflict with this fallback, and we wish\n+        // to generate a type error in that case. (However, this\n+        // actually isn't true right now, because we're only using the\n+        // builtin fallback rules. This would be true if we were using\n+        // user-supplied fallbacks. But it's still useful to write the\n+        // code to detect bugs.)\n         //\n-        // (Note though that if we have a general type variable `?T` that is then unified\n-        // with an integer type variable `?I` that ultimately never gets\n-        // resolved to a special integral type, `?T` is not considered unsolved,\n-        // but `?I` is. The same is true for float variables.)\n+        // (Note though that if we have a general type variable `?T`\n+        // that is then unified with an integer type variable `?I`\n+        // that ultimately never gets resolved to a special integral\n+        // type, `?T` is not considered unsolved, but `?I` is. The\n+        // same is true for float variables.)\n         let fallback = match ty.kind() {\n             _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n-            _ => match self.type_var_diverges(ty) {\n-                Diverging::Diverges => self.tcx.mk_diverging_default(),\n-                Diverging::NotDiverging => return false,\n+            _ => match diverging_fallback.get(&ty) {\n+                Some(&fallback_ty) => fallback_ty,\n+                None => return false,\n             },\n         };\n         debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n@@ -105,11 +136,10 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n-    /// Second round of fallback: Unconstrained type variables\n-    /// created from the instantiation of an opaque\n-    /// type fall back to the opaque type itself. This is a\n-    /// somewhat incomplete attempt to manage \"identity passthrough\"\n-    /// for `impl Trait` types.\n+    /// Second round of fallback: Unconstrained type variables created\n+    /// from the instantiation of an opaque type fall back to the\n+    /// opaque type itself. This is a somewhat incomplete attempt to\n+    /// manage \"identity passthrough\" for `impl Trait` types.\n     ///\n     /// For example, in this code:\n     ///\n@@ -158,4 +188,274 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             return false;\n         }\n     }\n+\n+    /// The \"diverging fallback\" system is rather complicated. This is\n+    /// a result of our need to balance 'do the right thing' with\n+    /// backwards compatibility.\n+    ///\n+    /// \"Diverging\" type variables are variables created when we\n+    /// coerce a `!` type into an unbound type variable `?X`. If they\n+    /// never wind up being constrained, the \"right and natural\" thing\n+    /// is that `?X` should \"fallback\" to `!`. This means that e.g. an\n+    /// expression like `Some(return)` will ultimately wind up with a\n+    /// type like `Option<!>` (presuming it is not assigned or\n+    /// constrained to have some other type).\n+    ///\n+    /// However, the fallback used to be `()` (before the `!` type was\n+    /// added).  Moreover, there are cases where the `!` type 'leaks\n+    /// out' from dead code into type variables that affect live\n+    /// code. The most common case is something like this:\n+    ///\n+    /// ```rust\n+    /// match foo() {\n+    ///     22 => Default::default(), // call this type `?D`\n+    ///     _ => return, // return has type `!`\n+    /// } // call the type of this match `?M`\n+    /// ```\n+    ///\n+    /// Here, coercing the type `!` into `?M` will create a diverging\n+    /// type variable `?X` where `?X <: ?M`.  We also have that `?D <:\n+    /// ?M`. If `?M` winds up unconstrained, then `?X` will\n+    /// fallback. If it falls back to `!`, then all the type variables\n+    /// will wind up equal to `!` -- this includes the type `?D`\n+    /// (since `!` doesn't implement `Default`, we wind up a \"trait\n+    /// not implemented\" error in code like this). But since the\n+    /// original fallback was `()`, this code used to compile with `?D\n+    /// = ()`. This is somewhat surprising, since `Default::default()`\n+    /// on its own would give an error because the types are\n+    /// insufficiently constrained.\n+    ///\n+    /// Our solution to this dilemma is to modify diverging variables\n+    /// so that they can *either* fallback to `!` (the default) or to\n+    /// `()` (the backwards compatibility case). We decide which\n+    /// fallback to use based on whether there is a coercion pattern\n+    /// like this:\n+    ///\n+    /// ```\n+    /// ?Diverging -> ?V\n+    /// ?NonDiverging -> ?V\n+    /// ?V != ?NonDiverging\n+    /// ```\n+    ///\n+    /// Here `?Diverging` represents some diverging type variable and\n+    /// `?NonDiverging` represents some non-diverging type\n+    /// variable. `?V` can be any type variable (diverging or not), so\n+    /// long as it is not equal to `?NonDiverging`.\n+    ///\n+    /// Intuitively, what we are looking for is a case where a\n+    /// \"non-diverging\" type variable (like `?M` in our example above)\n+    /// is coerced *into* some variable `?V` that would otherwise\n+    /// fallback to `!`. In that case, we make `?V` fallback to `!`,\n+    /// along with anything that would flow into `?V`.\n+    ///\n+    /// The algorithm we use:\n+    /// * Identify all variables that are coerced *into* by a\n+    ///   diverging variable.  Do this by iterating over each\n+    ///   diverging, unsolved variable and finding all variables\n+    ///   reachable from there. Call that set `D`.\n+    /// * Walk over all unsolved, non-diverging variables, and find\n+    ///   any variable that has an edge into `D`.\n+    fn calculate_diverging_fallback(\n+        &self,\n+        unsolved_variables: &[Ty<'tcx>],\n+    ) -> FxHashMap<Ty<'tcx>, Ty<'tcx>> {\n+        debug!(\"calculate_diverging_fallback({:?})\", unsolved_variables);\n+\n+        let relationships = self.fulfillment_cx.borrow_mut().relationships().clone();\n+\n+        // Construct a coercion graph where an edge `A -> B` indicates\n+        // a type variable is that is coerced\n+        let coercion_graph = self.create_coercion_graph();\n+\n+        // Extract the unsolved type inference variable vids; note that some\n+        // unsolved variables are integer/float variables and are excluded.\n+        let unsolved_vids = unsolved_variables.iter().filter_map(|ty| ty.ty_vid());\n+\n+        // Compute the diverging root vids D -- that is, the root vid of\n+        // those type variables that (a) are the target of a coercion from\n+        // a `!` type and (b) have not yet been solved.\n+        //\n+        // These variables are the ones that are targets for fallback to\n+        // either `!` or `()`.\n+        let diverging_roots: FxHashSet<ty::TyVid> = self\n+            .diverging_type_vars\n+            .borrow()\n+            .iter()\n+            .map(|&ty| self.infcx.shallow_resolve(ty))\n+            .filter_map(|ty| ty.ty_vid())\n+            .map(|vid| self.infcx.root_var(vid))\n+            .collect();\n+        debug!(\n+            \"calculate_diverging_fallback: diverging_type_vars={:?}\",\n+            self.diverging_type_vars.borrow()\n+        );\n+        debug!(\"calculate_diverging_fallback: diverging_roots={:?}\", diverging_roots);\n+\n+        // Find all type variables that are reachable from a diverging\n+        // type variable. These will typically default to `!`, unless\n+        // we find later that they are *also* reachable from some\n+        // other type variable outside this set.\n+        let mut roots_reachable_from_diverging = DepthFirstSearch::new(&coercion_graph);\n+        let mut diverging_vids = vec![];\n+        let mut non_diverging_vids = vec![];\n+        for unsolved_vid in unsolved_vids {\n+            let root_vid = self.infcx.root_var(unsolved_vid);\n+            debug!(\n+                \"calculate_diverging_fallback: unsolved_vid={:?} root_vid={:?} diverges={:?}\",\n+                unsolved_vid,\n+                root_vid,\n+                diverging_roots.contains(&root_vid),\n+            );\n+            if diverging_roots.contains(&root_vid) {\n+                diverging_vids.push(unsolved_vid);\n+                roots_reachable_from_diverging.push_start_node(root_vid);\n+\n+                debug!(\n+                    \"calculate_diverging_fallback: root_vid={:?} reaches {:?}\",\n+                    root_vid,\n+                    coercion_graph.depth_first_search(root_vid).collect::<Vec<_>>()\n+                );\n+\n+                // drain the iterator to visit all nodes reachable from this node\n+                roots_reachable_from_diverging.complete_search();\n+            } else {\n+                non_diverging_vids.push(unsolved_vid);\n+            }\n+        }\n+\n+        debug!(\n+            \"calculate_diverging_fallback: roots_reachable_from_diverging={:?}\",\n+            roots_reachable_from_diverging,\n+        );\n+\n+        // Find all type variables N0 that are not reachable from a\n+        // diverging variable, and then compute the set reachable from\n+        // N0, which we call N. These are the *non-diverging* type\n+        // variables. (Note that this set consists of \"root variables\".)\n+        let mut roots_reachable_from_non_diverging = DepthFirstSearch::new(&coercion_graph);\n+        for &non_diverging_vid in &non_diverging_vids {\n+            let root_vid = self.infcx.root_var(non_diverging_vid);\n+            if roots_reachable_from_diverging.visited(root_vid) {\n+                continue;\n+            }\n+            roots_reachable_from_non_diverging.push_start_node(root_vid);\n+            roots_reachable_from_non_diverging.complete_search();\n+        }\n+        debug!(\n+            \"calculate_diverging_fallback: roots_reachable_from_non_diverging={:?}\",\n+            roots_reachable_from_non_diverging,\n+        );\n+\n+        debug!(\"inherited: {:#?}\", self.inh.fulfillment_cx.borrow_mut().pending_obligations());\n+        debug!(\"obligations: {:#?}\", self.fulfillment_cx.borrow_mut().pending_obligations());\n+        debug!(\"relationships: {:#?}\", relationships);\n+\n+        // For each diverging variable, figure out whether it can\n+        // reach a member of N. If so, it falls back to `()`. Else\n+        // `!`.\n+        let mut diverging_fallback = FxHashMap::default();\n+        diverging_fallback.reserve(diverging_vids.len());\n+        for &diverging_vid in &diverging_vids {\n+            let diverging_ty = self.tcx.mk_ty_var(diverging_vid);\n+            let root_vid = self.infcx.root_var(diverging_vid);\n+            let can_reach_non_diverging = coercion_graph\n+                .depth_first_search(root_vid)\n+                .any(|n| roots_reachable_from_non_diverging.visited(n));\n+\n+            let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n+\n+            for (vid, rel) in relationships.iter() {\n+                if self.infcx.root_var(*vid) == root_vid {\n+                    relationship.self_in_trait |= rel.self_in_trait;\n+                    relationship.output |= rel.output;\n+                }\n+            }\n+\n+            if relationship.self_in_trait && relationship.output {\n+                // This case falls back to () to ensure that the code pattern in\n+                // src/test/ui/never_type/fallback-closure-ret.rs continues to\n+                // compile when never_type_fallback is enabled.\n+                //\n+                // This rule is not readily explainable from first principles,\n+                // but is rather intended as a patchwork fix to ensure code\n+                // which compiles before the stabilization of never type\n+                // fallback continues to work.\n+                //\n+                // Typically this pattern is encountered in a function taking a\n+                // closure as a parameter, where the return type of that closure\n+                // (checked by `relationship.output`) is expected to implement\n+                // some trait (checked by `relationship.self_in_trait`). This\n+                // can come up in non-closure cases too, so we do not limit this\n+                // rule to specifically `FnOnce`.\n+                //\n+                // When the closure's body is something like `panic!()`, the\n+                // return type would normally be inferred to `!`. However, it\n+                // needs to fall back to `()` in order to still compile, as the\n+                // trait is specifically implemented for `()` but not `!`.\n+                //\n+                // For details on the requirements for these relationships to be\n+                // set, see the relationship finding module in\n+                // compiler/rustc_trait_selection/src/traits/relationships.rs.\n+                debug!(\"fallback to () - found trait and projection: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n+            } else if can_reach_non_diverging {\n+                debug!(\"fallback to () - reached non-diverging: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n+            } else {\n+                debug!(\"fallback to ! - all diverging: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.mk_diverging_default());\n+            }\n+        }\n+\n+        diverging_fallback\n+    }\n+\n+    /// Returns a graph whose nodes are (unresolved) inference variables and where\n+    /// an edge `?A -> ?B` indicates that the variable `?A` is coerced to `?B`.\n+    fn create_coercion_graph(&self) -> VecGraph<ty::TyVid> {\n+        let pending_obligations = self.fulfillment_cx.borrow_mut().pending_obligations();\n+        debug!(\"create_coercion_graph: pending_obligations={:?}\", pending_obligations);\n+        let coercion_edges: Vec<(ty::TyVid, ty::TyVid)> = pending_obligations\n+            .into_iter()\n+            .filter_map(|obligation| {\n+                // The predicates we are looking for look like `Coerce(?A -> ?B)`.\n+                // They will have no bound variables.\n+                obligation.predicate.kind().no_bound_vars()\n+            })\n+            .filter_map(|atom| {\n+                // We consider both subtyping and coercion to imply 'flow' from\n+                // some position in the code `a` to a different position `b`.\n+                // This is then used to determine which variables interact with\n+                // live code, and as such must fall back to `()` to preserve\n+                // soundness.\n+                //\n+                // In practice currently the two ways that this happens is\n+                // coercion and subtyping.\n+                let (a, b) = if let ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) = atom {\n+                    (a, b)\n+                } else if let ty::PredicateKind::Subtype(ty::SubtypePredicate {\n+                    a_is_expected: _,\n+                    a,\n+                    b,\n+                }) = atom\n+                {\n+                    (a, b)\n+                } else {\n+                    return None;\n+                };\n+\n+                let a_vid = self.root_vid(a)?;\n+                let b_vid = self.root_vid(b)?;\n+                Some((a_vid, b_vid))\n+            })\n+            .collect();\n+        debug!(\"create_coercion_graph: coercion_edges={:?}\", coercion_edges);\n+        let num_ty_vars = self.infcx.num_ty_vars();\n+        VecGraph::new(num_ty_vars, coercion_edges)\n+    }\n+\n+    /// If `ty` is an unresolved type variable, returns its root vid.\n+    fn root_vid(&self, ty: Ty<'tcx>) -> Option<ty::TyVid> {\n+        Some(self.infcx.root_var(self.infcx.shallow_resolve(ty).ty_vid()?))\n+    }\n }"}, {"sha": "562d05d3ef9b1b00e803893f1539fd66e5f00397", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -286,6 +286,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        for a in &adj {\n+            if let Adjust::NeverToAny = a.kind {\n+                if a.target.is_ty_var() {\n+                    self.diverging_type_vars.borrow_mut().insert(a.target);\n+                    debug!(\"apply_adjustments: adding `{:?}` as diverging type var\", a.target);\n+                }\n+            }\n+        }\n+\n         let autoborrow_mut = adj.iter().any(|adj| {\n             matches!(\n                 adj,"}, {"sha": "f7552c1f4eb0cae7e6281e52d553f3cae5a09ec6", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,6 +1,7 @@\n use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n@@ -56,6 +57,11 @@ pub struct Inherited<'a, 'tcx> {\n     pub(super) constness: hir::Constness,\n \n     pub(super) body_id: Option<hir::BodyId>,\n+\n+    /// Whenever we introduce an adjustment from `!` into a type variable,\n+    /// we record that type variable here. This is later used to inform\n+    /// fallback. See the `fallback` module for details.\n+    pub(super) diverging_type_vars: RefCell<FxHashSet<Ty<'tcx>>>,\n }\n \n impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n@@ -121,6 +127,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n+            diverging_type_vars: RefCell::new(Default::default()),\n             constness,\n             body_id,\n         }"}, {"sha": "fbaa874792a0180031fb706523a303daac511232", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.nofallback.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n+  --> $DIR/coerce-issue-49593-box-never.rs:17:53\n+   |\n+LL |     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n+   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n+   |\n+   = note: required for the cast to the object type `dyn std::error::Error`\n+\n+error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n+  --> $DIR/coerce-issue-49593-box-never.rs:22:49\n+   |\n+LL |     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n+   |\n+   = note: required for the cast to the object type `(dyn std::error::Error + 'static)`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7a4324bd5adcedd124b9473e4e742cb1ea3fd4e8", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,5 +1,9 @@\n-// check-pass\n-#![feature(never_type, never_type_fallback)]\n+// revisions: nofallback fallback\n+//[fallback] check-pass\n+//[nofallback] check-fail\n+\n+#![feature(never_type)]\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n #![allow(unreachable_code)]\n \n use std::error::Error;\n@@ -11,10 +15,12 @@ fn raw_ptr_box<T>(t: T) -> *mut T {\n \n fn foo(x: !) -> Box<dyn Error> {\n     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n+    //[nofallback]~^ ERROR trait bound `(): std::error::Error` is not satisfied\n }\n \n fn foo_raw_ptr(x: !) -> *mut dyn Error {\n     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n+    //[nofallback]~^ ERROR trait bound `(): std::error::Error` is not satisfied\n }\n \n fn no_coercion(d: *mut dyn Error) -> *mut dyn Error {"}, {"sha": "588d644c77b0dc159d5a056c30fb087d339bb400", "filename": "src/test/ui/never_type/defaulted-never-note.fallback.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `!: ImplementedForUnitButNotNever` is not satisfied\n-  --> $DIR/defaulted-never-note.rs:26:5\n+  --> $DIR/defaulted-never-note.rs:30:5\n    |\n LL |     foo(_x);\n    |     ^^^ the trait `ImplementedForUnitButNotNever` is not implemented for `!`\n@@ -8,7 +8,7 @@ LL |     foo(_x);\n    = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n    = help: did you intend to use the type `()` here instead?\n note: required by a bound in `foo`\n-  --> $DIR/defaulted-never-note.rs:21:11\n+  --> $DIR/defaulted-never-note.rs:25:11\n    |\n LL | fn foo<T: ImplementedForUnitButNotNever>(_t: T) {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `foo`", "previous_filename": "src/test/ui/never_type/defaulted-never-note.stderr"}, {"sha": "54f551759cb3926f9cf7cdf02865e6c171bd64ff", "filename": "src/test/ui/never_type/defaulted-never-note.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,6 +1,10 @@\n+// revisions: nofallback fallback\n+//[nofallback] run-pass\n+//[fallback] check-fail\n+\n // We need to opt into the `never_type_fallback` feature\n // to trigger the requirement that this is testing.\n-#![feature(never_type, never_type_fallback)]\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n \n #![allow(unused)]\n \n@@ -19,16 +23,16 @@ trait ImplementedForUnitButNotNever {}\n impl ImplementedForUnitButNotNever for () {}\n \n fn foo<T: ImplementedForUnitButNotNever>(_t: T) {}\n-//~^ NOTE required by this bound in `foo`\n-//~| NOTE required by a bound in `foo`\n+//[fallback]~^ NOTE required by this bound in `foo`\n+//[fallback]~| NOTE required by a bound in `foo`\n fn smeg() {\n     let _x = return;\n     foo(_x);\n-    //~^ ERROR the trait bound\n-    //~| NOTE the trait `ImplementedForUnitButNotNever` is not implemented\n-    //~| NOTE this trait is implemented for `()`\n-    //~| NOTE this error might have been caused\n-    //~| HELP did you intend\n+    //[fallback]~^ ERROR the trait bound\n+    //[fallback]~| NOTE the trait `ImplementedForUnitButNotNever` is not implemented\n+    //[fallback]~| NOTE this trait is implemented for `()`\n+    //[fallback]~| NOTE this error might have been caused\n+    //[fallback]~| HELP did you intend\n }\n \n fn main() {"}, {"sha": "45a3362fa6d8ea07dc6eab46c26da2bbe14182ba", "filename": "src/test/ui/never_type/diverging-fallback-control-flow.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -1,30 +1,28 @@\n+// revisions: nofallback fallback\n // run-pass\n \n #![allow(dead_code)]\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n #![allow(unreachable_code)]\n-\n // Test various cases where we permit an unconstrained variable\n-// to fallback based on control-flow.\n-//\n-// These represent current behavior, but are pretty dubious.  I would\n-// like to revisit these and potentially change them. --nmatsakis\n-\n-#![feature(never_type, never_type_fallback)]\n+// to fallback based on control-flow. In all of these cases,\n+// the type variable winds up being the target of both a `!` coercion\n+// and a coercion from a non-`!` variable, and hence falls back to `()`.\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n \n-trait BadDefault {\n+trait UnitDefault {\n     fn default() -> Self;\n }\n \n-impl BadDefault for u32 {\n+impl UnitDefault for u32 {\n     fn default() -> Self {\n         0\n     }\n }\n \n-impl BadDefault for ! {\n-    fn default() -> ! {\n+impl UnitDefault for () {\n+    fn default() -> () {\n         panic!()\n     }\n }\n@@ -33,7 +31,7 @@ fn assignment() {\n     let x;\n \n     if true {\n-        x = BadDefault::default();\n+        x = UnitDefault::default();\n     } else {\n         x = return;\n     }\n@@ -45,13 +43,13 @@ fn assignment_rev() {\n     if true {\n         x = return;\n     } else {\n-        x = BadDefault::default();\n+        x = UnitDefault::default();\n     }\n }\n \n fn if_then_else() {\n     let _x = if true {\n-        BadDefault::default()\n+        UnitDefault::default()\n     } else {\n         return;\n     };\n@@ -61,19 +59,19 @@ fn if_then_else_rev() {\n     let _x = if true {\n         return;\n     } else {\n-        BadDefault::default()\n+        UnitDefault::default()\n     };\n }\n \n fn match_arm() {\n-    let _x = match Ok(BadDefault::default()) {\n+    let _x = match Ok(UnitDefault::default()) {\n         Ok(v) => v,\n         Err(()) => return,\n     };\n }\n \n fn match_arm_rev() {\n-    let _x = match Ok(BadDefault::default()) {\n+    let _x = match Ok(UnitDefault::default()) {\n         Err(()) => return,\n         Ok(v) => v,\n     };\n@@ -84,7 +82,7 @@ fn loop_break() {\n         if false {\n             break return;\n         } else {\n-            break BadDefault::default();\n+            break UnitDefault::default();\n         }\n     };\n }\n@@ -94,9 +92,9 @@ fn loop_break_rev() {\n         if false {\n             break return;\n         } else {\n-            break BadDefault::default();\n+            break UnitDefault::default();\n         }\n     };\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "3a5b602f1118fc196623978bf86cef4b2135b583", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.fallback.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `!: Test` is not satisfied\n+  --> $DIR/diverging-fallback-no-leak.rs:17:5\n+   |\n+LL |     unconstrained_arg(return);\n+   |     ^^^^^^^^^^^^^^^^^ the trait `Test` is not implemented for `!`\n+   |\n+   = note: this trait is implemented for `()`.\n+   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n+   = help: did you intend to use the type `()` here instead?\n+note: required by a bound in `unconstrained_arg`\n+  --> $DIR/diverging-fallback-no-leak.rs:12:25\n+   |\n+LL | fn unconstrained_arg<T: Test>(_: T) {}\n+   |                         ^^^^ required by this bound in `unconstrained_arg`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "03478e19ddcddbb5bf57adf7c147a5ce4c3b1058", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,19 @@\n+// revisions: nofallback fallback\n+//[nofallback] check-pass\n+\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n+\n+fn make_unit() {}\n+\n+trait Test {}\n+impl Test for i32 {}\n+impl Test for () {}\n+\n+fn unconstrained_arg<T: Test>(_: T) {}\n+\n+fn main() {\n+    // Here the type variable falls back to `!`,\n+    // and hence we get a type error.\n+    unconstrained_arg(return);\n+    //[fallback]~^ ERROR trait bound `!: Test` is not satisfied\n+}"}, {"sha": "7ea97126f89c992c12111a802dfec18142219318", "filename": "src/test/ui/never_type/diverging-fallback-unconstrained-return.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,37 @@\n+// Variant of diverging-falllback-control-flow that tests\n+// the specific case of a free function with an unconstrained\n+// return type. This captures the pattern we saw in the wild\n+// in the objc crate, where changing the fallback from `!` to `()`\n+// resulted in unsoundness.\n+//\n+// check-pass\n+\n+// revisions: nofallback fallback\n+\n+#![cfg_attr(fallback, feature(never_type, never_type_fallback))]\n+\n+\n+fn make_unit() {}\n+\n+trait UnitReturn {}\n+impl UnitReturn for i32 {}\n+impl UnitReturn for () {}\n+\n+fn unconstrained_return<T: UnitReturn>() -> T {\n+    unsafe {\n+        let make_unit_fn: fn() = make_unit;\n+        let ffi: fn() -> T = std::mem::transmute(make_unit_fn);\n+        ffi()\n+    }\n+}\n+\n+fn main() {\n+    // In Ye Olde Days, the `T` parameter of `unconstrained_return`\n+    // winds up \"entangled\" with the `!` type that results from\n+    // `panic!`, and hence falls back to `()`. This is kind of unfortunate\n+    // and unexpected. When we introduced the `!` type, the original\n+    // idea was to change that fallback to `!`, but that would have resulted\n+    // in this code no longer compiling (or worse, in some cases it injected\n+    // unsound results).\n+    let _ = if true { unconstrained_return() } else { panic!() };\n+}"}, {"sha": "5c8ce48cbb0b6abf750b6bc99bebb778222399f8", "filename": "src/test/ui/never_type/fallback-closure-ret.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-ret.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,23 @@\n+// This test verifies that never type fallback preserves the following code in a\n+// compiling state. This pattern is fairly common in the wild, notably seen in\n+// wasmtime v0.16. Typically this is some closure wrapper that expects a\n+// collection of 'known' signatures, and -> ! is not included in that set.\n+//\n+// This test is specifically targeted by the unit type fallback when\n+// encountering a set of obligations like `?T: Foo` and `Trait::Projection =\n+// ?T`. In the code below, these are `R: Bar` and `Fn::Output = R`.\n+//\n+// revisions: nofallback fallback\n+// check-pass\n+\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n+\n+trait Bar { }\n+impl Bar for () {  }\n+impl Bar for u32 {  }\n+\n+fn foo<R: Bar>(_: impl Fn() -> R) {}\n+\n+fn main() {\n+    foo(|| panic!());\n+}"}, {"sha": "78d1a3caf4a30e379e01860e4b3fb3a65535aa4a", "filename": "src/test/ui/never_type/fallback-closure-wrap.fallback.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,17 @@\n+error[E0271]: type mismatch resolving `<[closure@$DIR/fallback-closure-wrap.rs:18:40: 21:6] as FnOnce<()>>::Output == ()`\n+  --> $DIR/fallback-closure-wrap.rs:18:31\n+   |\n+LL |       let error = Closure::wrap(Box::new(move || {\n+   |  _______________________________^\n+LL | |\n+LL | |         panic!(\"Can't connect to server.\");\n+LL | |     }) as Box<dyn FnMut()>);\n+   | |______^ expected `()`, found `!`\n+   |\n+   = note: expected unit type `()`\n+                   found type `!`\n+   = note: required for the cast to the object type `dyn FnMut()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "af0577ac0609fcb24d9eaad0302819b6f5787771", "filename": "src/test/ui/never_type/fallback-closure-wrap.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,30 @@\n+// This is a minified example from Crater breakage observed when attempting to\n+// stabilize never type, nstoddard/webgl-gui @ 22f0169f.\n+//\n+// This particular test case currently fails as the inference to `()` rather\n+// than `!` happens as a result of an `as` cast, which is not currently tracked.\n+// Crater did not find many cases of this occuring, but it is included for\n+// awareness.\n+//\n+// revisions: nofallback fallback\n+//[nofallback] check-pass\n+//[fallback] check-fail\n+\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n+\n+use std::marker::PhantomData;\n+\n+fn main() {\n+    let error = Closure::wrap(Box::new(move || {\n+        //[fallback]~^ ERROR type mismatch resolving\n+        panic!(\"Can't connect to server.\");\n+    }) as Box<dyn FnMut()>);\n+}\n+\n+struct Closure<T: ?Sized>(PhantomData<T>);\n+\n+impl<T: ?Sized> Closure<T> {\n+    fn wrap(data: Box<T>) -> Closure<T> {\n+        todo!()\n+    }\n+}"}, {"sha": "f374266626bcc4c517d47de601b08ab3231f44ca", "filename": "src/test/ui/never_type/never-value-fallback-issue-66757.nofallback.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `E: From<()>` is not satisfied\n+  --> $DIR/never-value-fallback-issue-66757.rs:27:5\n+   |\n+LL |     <E as From<_>>::from(never);\n+   |     ^^^^^^^^^^^^^^^^^^^^ the trait `From<()>` is not implemented for `E`\n+   |\n+   = help: the following implementations were found:\n+             <E as From<!>>\n+note: required by `from`\n+  --> $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+   |\n+LL |     fn from(_: T) -> Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6dc7e6ad2d93de43f267af45bfa69836d55cfbe4", "filename": "src/test/ui/never_type/never-value-fallback-issue-66757.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.rs?ref=900cf5e8905ba8a2a9c99a1dfc9cb2cf4754d77a", "patch": "@@ -4,12 +4,13 @@\n // never) and an uninferred variable (here the argument to `From`) it\n // doesn't fallback to `()` but rather `!`.\n //\n-// run-pass\n+// revisions: nofallback fallback\n+//[fallback] run-pass\n+//[nofallback] check-fail\n \n #![feature(never_type)]\n \n-// FIXME(#67225) -- this should be true even without the fallback gate.\n-#![feature(never_type_fallback)]\n+#![cfg_attr(fallback, feature(never_type_fallback))]\n \n struct E;\n \n@@ -23,7 +24,7 @@ impl From<!> for E {\n #[allow(dead_code)]\n fn foo(never: !) {\n     <E as From<!>>::from(never);  // Ok\n-    <E as From<_>>::from(never);  // Inference fails here\n+    <E as From<_>>::from(never);  //[nofallback]~ ERROR trait bound `E: From<()>` is not satisfied\n }\n \n fn main() { }"}]}