{"sha": "c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YmJmYjk0NzQ4ZjRjYTljNDgzZmQyNGExYzg0ZTRlZjg0OTkzZTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-09T11:57:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-09T11:57:50Z"}, "message": "Rollup merge of #69762 - RalfJung:validity-errors, r=oli-obk\n\nEnsure that validity only raises validity errors\n\nFor now, only as a debug-assertion (similar to const-prop detecting errors that allocate).\n\nNow includes https://github.com/rust-lang/rust/pull/69646.\n[Relative diff](https://github.com/RalfJung/rust/compare/layout-visitor...RalfJung:validity-errors).\n\nr? @oli-obk", "tree": {"sha": "950672a5c7a85268bf4448cf36e863f127f212e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/950672a5c7a85268bf4448cf36e863f127f212e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZi8+CRBK7hj4Ov3rIwAAdHIIACnDAnIGyAiCqD3at6dUkdRY\nhV9Y0Eq+ZVzqHNhegUyQWBDcii/ij5EjGLT99hzqXx+k+221m6EyszmiZpOd+AqA\nqE4GYeVBfZ3GhyMiHGQYmoJSQ7WN4mxKF51m8jxkeVXHm1aV+r57VHI47z7Roy9F\n/77FCf9s75O+F3ksXJyaejgU14w3ZEXSu93B8FmvqT6dRiqrXS94OfHzXi8yRKnN\ndOiIIACdv/mKF89ZXK8cz2J5euoEbTMpJEo5oZc+JW0uemgheq6A5e8Fvc+qvVLb\nFwUYpM2Jeb3wk2BBzArH1GLzSSUNwNT1faYLBQtPrM5+Ah6FGyyzCUFIQquXdf8=\n=RoFl\n-----END PGP SIGNATURE-----\n", "payload": "tree 950672a5c7a85268bf4448cf36e863f127f212e7\nparent eaf6905c558093c101b41b791ac4fba3dbe96779\nparent ed3014a2b9470a89165f2762ba746ee7736d5590\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583755070 +0100\ncommitter GitHub <noreply@github.com> 1583755070 +0100\n\nRollup merge of #69762 - RalfJung:validity-errors, r=oli-obk\n\nEnsure that validity only raises validity errors\n\nFor now, only as a debug-assertion (similar to const-prop detecting errors that allocate).\n\nNow includes https://github.com/rust-lang/rust/pull/69646.\n[Relative diff](https://github.com/RalfJung/rust/compare/layout-visitor...RalfJung:validity-errors).\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "html_url": "https://github.com/rust-lang/rust/commit/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf6905c558093c101b41b791ac4fba3dbe96779", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf6905c558093c101b41b791ac4fba3dbe96779", "html_url": "https://github.com/rust-lang/rust/commit/eaf6905c558093c101b41b791ac4fba3dbe96779"}, {"sha": "ed3014a2b9470a89165f2762ba746ee7736d5590", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3014a2b9470a89165f2762ba746ee7736d5590", "html_url": "https://github.com/rust-lang/rust/commit/ed3014a2b9470a89165f2762ba746ee7736d5590"}], "stats": {"total": 261, "additions": 167, "deletions": 94}, "files": [{"sha": "b46095927b70910aee9e5ffaeefefd1906cb3914", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -245,7 +245,7 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n-impl From<ErrorHandled> for InterpErrorInfo<'tcx> {\n+impl From<ErrorHandled> for InterpErrorInfo<'_> {\n     fn from(err: ErrorHandled) -> Self {\n         match err {\n             ErrorHandled::Reported => err_inval!(ReferencedConstant),\n@@ -291,7 +291,7 @@ pub enum InvalidProgramInfo<'tcx> {\n     Layout(layout::LayoutError<'tcx>),\n }\n \n-impl fmt::Debug for InvalidProgramInfo<'tcx> {\n+impl fmt::Debug for InvalidProgramInfo<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use InvalidProgramInfo::*;\n         match self {\n@@ -321,6 +321,8 @@ pub enum UndefinedBehaviorInfo {\n     RemainderByZero,\n     /// Overflowing inbounds pointer arithmetic.\n     PointerArithOverflow,\n+    /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n+    InvalidMeta(&'static str),\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -338,6 +340,7 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n             DivisionByZero => write!(f, \"dividing by zero\"),\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n+            InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n         }\n     }\n }\n@@ -354,8 +357,8 @@ pub enum UnsupportedOpInfo<'tcx> {\n     Unsupported(String),\n \n     /// When const-prop encounters a situation it does not support, it raises this error.\n-    /// This must not allocate for performance reasons.\n-    ConstPropUnsupported(&'tcx str),\n+    /// This must not allocate for performance reasons (hence `str`, not `String`).\n+    ConstPropUnsupported(&'static str),\n \n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n@@ -612,3 +615,19 @@ impl fmt::Debug for InterpError<'_> {\n         }\n     }\n }\n+\n+impl InterpError<'_> {\n+    /// Some errors allocate to be created as they contain free-form strings.\n+    /// And sometimes we want to be sure that did not happen as it is a\n+    /// waste of resources.\n+    pub fn allocates(&self) -> bool {\n+        match self {\n+            InterpError::MachineStop(_)\n+            | InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n+            | InterpError::Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_)) => true,\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "ffbff00cf376005a6b983d0ddc9c247b1ad67383", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -186,7 +186,12 @@ fn validate_and_turn_into_const<'tcx>(\n         if cid.promoted.is_none() {\n             let mut ref_tracking = RefTracking::new(mplace);\n             while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+                ecx.const_validate_operand(\n+                    mplace.into(),\n+                    path,\n+                    &mut ref_tracking,\n+                    /*may_ref_to_static*/ is_static,\n+                )?;\n             }\n         }\n         // Now that we validated, turn this into a proper constant."}, {"sha": "9b28b7a20c044ef3779e561566cb22b6e52ff866", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -457,10 +457,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Check if this brought us over the size limit.\n                 if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n-                    throw_ub_format!(\n-                        \"wide pointer metadata contains invalid information: \\\n-                        total size is bigger than largest supported object\"\n-                    );\n+                    throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n             }\n@@ -476,10 +473,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Make sure the slice is not too big.\n                 let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n-                    err_ub_format!(\n-                        \"invalid slice: \\\n-                        total size is bigger than largest supported object\"\n-                    )\n+                    err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))\n             }\n@@ -685,7 +679,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // invariant -- that is, unless a function somehow has a ptr to\n                     // its return place... but the way MIR is currently generated, the\n                     // return place is always a local and then this cannot happen.\n-                    self.validate_operand(self.place_to_op(return_place)?, vec![], None)?;\n+                    self.validate_operand(self.place_to_op(return_place)?)?;\n                 }\n             } else {\n                 // Uh, that shouldn't happen... the function did not intend to return"}, {"sha": "a4815b9696ebb5d0d0d2a4c57e3e4d8adb1afe1d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -689,7 +689,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n+            self.validate_operand(self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -706,7 +706,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None)?;\n+            self.validate_operand(dest.into())?;\n         }\n \n         Ok(())\n@@ -843,7 +843,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n+            self.validate_operand(self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -951,7 +951,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None)?;\n+            self.validate_operand(dest.into())?;\n         }\n \n         Ok(())"}, {"sha": "05bb010959b32093e07245b623fa14c4baf8fb0d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -46,13 +46,17 @@ macro_rules! try_validation {\n     ($e:expr, $what:expr, $where:expr, $details:expr) => {{\n         match $e {\n             Ok(x) => x,\n+            // We re-throw the error, so we are okay with allocation:\n+            // this can only slow down builds that fail anyway.\n             Err(_) => throw_validation_failure!($what, $where, $details),\n         }\n     }};\n \n     ($e:expr, $what:expr, $where:expr) => {{\n         match $e {\n             Ok(x) => x,\n+            // We re-throw the error, so we are okay with allocation:\n+            // this can only slow down builds that fail anyway.\n             Err(_) => throw_validation_failure!($what, $where),\n         }\n     }};\n@@ -167,6 +171,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     path: Vec<PathElem>,\n     ref_tracking_for_consts:\n         Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    may_ref_to_static: bool,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n@@ -320,9 +325,17 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n-        let (size, align) = self\n-            .ecx\n-            .size_and_align_of(place.meta, place.layout)?\n+        let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n+            Ok(res) => res,\n+            Err(err) => match err.kind {\n+                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(\n+                    format_args!(\"invalid {} metadata: {}\", kind, msg),\n+                    self.path\n+                ),\n+                _ => bug!(\"Unexpected error during ptr size_and_align_of: {}\", err),\n+            },\n+        };\n+        let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n@@ -359,10 +372,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         format_args!(\"a dangling {} (created from integer)\", kind),\n                         self.path\n                     ),\n-                    _ => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n-                        self.path\n-                    ),\n+                    err_unsup!(PointerOutOfBounds { .. }) | err_unsup!(DanglingPointerDeref) => {\n+                        throw_validation_failure!(\n+                            format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n+                            self.path\n+                        )\n+                    }\n+                    _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n                 }\n             }\n         };\n@@ -380,6 +396,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n                         return Ok(());\n                     }\n+                    if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n+                        throw_validation_failure!(\n+                            format_args!(\"a {} pointing to a static variable\", kind),\n+                            self.path\n+                        );\n+                    }\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!\n@@ -638,6 +660,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 err_unsup!(ReadPointerAsBytes) => {\n                     throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n                 }\n+                // Propagate upwards (that will also check for unexpected errors).\n                 _ => return Err(err),\n             },\n         }\n@@ -773,31 +796,59 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n-    /// is an indirect operand.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    ///\n-    /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n-    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n-    /// specific validation checks.\n-    pub fn validate_operand(\n+    fn validate_operand_internal(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking_for_consts: Option<\n             &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n         >,\n+        may_ref_to_static: bool,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n+        trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n-        let mut visitor = ValidityVisitor { path, ref_tracking_for_consts, ecx: self };\n+        let mut visitor =\n+            ValidityVisitor { path, ref_tracking_for_consts, may_ref_to_static, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n         let op = self.force_op_ptr(op).unwrap_or(op);\n \n-        // Run it\n-        visitor.visit_value(op)\n+        // Run it.\n+        match visitor.visit_value(op) {\n+            Ok(()) => Ok(()),\n+            Err(err) if matches!(err.kind, err_unsup!(ValidationFailure { .. })) => Err(err),\n+            Err(err) if cfg!(debug_assertions) => {\n+                bug!(\"Unexpected error during validation: {}\", err)\n+            }\n+            Err(err) => Err(err),\n+        }\n+    }\n+\n+    /// This function checks the data at `op` to be const-valid.\n+    /// `op` is assumed to cover valid memory if it is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    ///\n+    /// `ref_tracking` is used to record references that we encounter so that they\n+    /// can be checked recursively by an outside driving loop.\n+    ///\n+    /// `may_ref_to_static` controls whether references are allowed to point to statics.\n+    #[inline(always)]\n+    pub fn const_validate_operand(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        path: Vec<PathElem>,\n+        ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n+        may_ref_to_static: bool,\n+    ) -> InterpResult<'tcx> {\n+        self.validate_operand_internal(op, path, Some(ref_tracking), may_ref_to_static)\n+    }\n+\n+    /// This function checks the data at `op` to be runtime-valid.\n+    /// `op` is assumed to cover valid memory if it is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    #[inline(always)]\n+    pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        self.validate_operand_internal(op, vec![], None, false)\n     }\n }"}, {"sha": "a07c8575b300c9048d9266c8352a3dc67cd61109", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -404,32 +404,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                use rustc::mir::interpret::{\n-                    InterpError::*, UndefinedBehaviorInfo, UnsupportedOpInfo,\n-                };\n-                match error.kind {\n-                    MachineStop(_) => bug!(\"ConstProp does not stop\"),\n-\n-                    // Some error shouldn't come up because creating them causes\n-                    // an allocation, which we should avoid. When that happens,\n-                    // dedicated error variants should be introduced instead.\n-                    // Only test this in debug builds though to avoid disruptions.\n-                    Unsupported(UnsupportedOpInfo::Unsupported(_))\n-                    | Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n-                    | UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n-                    | UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_))\n-                        if cfg!(debug_assertions) =>\n-                    {\n-                        bug!(\"const-prop encountered allocating error: {:?}\", error.kind);\n-                    }\n-\n-                    Unsupported(_)\n-                    | UndefinedBehavior(_)\n-                    | InvalidProgram(_)\n-                    | ResourceExhaustion(_) => {\n-                        // Ignore these errors.\n-                    }\n-                }\n+                // Some errors shouldn't come up because creating them causes\n+                // an allocation, which we should avoid. When that happens,\n+                // dedicated error variants should be introduced instead.\n+                // Only test this in debug builds though to avoid disruptions.\n+                debug_assert!(\n+                    !error.kind.allocates(),\n+                    \"const-prop encountered allocating error: {}\",\n+                    error\n+                );\n                 None\n             }\n         };\n@@ -654,11 +637,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.validate_operand(\n+        if let Err(e) = self.ecx.const_validate_operand(\n             value,\n             vec![],\n             // FIXME: is ref tracking too expensive?\n-            Some(&mut interpret::RefTracking::empty()),\n+            &mut interpret::RefTracking::empty(),\n+            /*may_ref_to_static*/ true,\n         ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;"}, {"sha": "c6b8e8eb611819a10c9af6cb0da142ca8a246158", "filename": "src/test/ui/consts/const-eval/dangling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -6,7 +6,7 @@ use std::{mem, usize};\n const TEST: () = { unsafe { //~ NOTE\n     let slice: *const [u8] = mem::transmute((1usize, usize::MAX));\n     let _val = &*slice; //~ ERROR: any use of this value will cause an error\n-    //~^ NOTE: total size is bigger than largest supported object\n+    //~^ NOTE: slice is bigger than largest supported object\n     //~^^ on by default\n } };\n "}, {"sha": "b9ddc93b03b84e942dfc318b09c2d48b275743fd", "filename": "src/test/ui/consts/const-eval/dangling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | / const TEST: () = { unsafe {\n LL | |     let slice: *const [u8] = mem::transmute((1usize, usize::MAX));\n LL | |     let _val = &*slice;\n-   | |                ^^^^^^^ invalid slice: total size is bigger than largest supported object\n+   | |                ^^^^^^^ invalid metadata in wide pointer: slice is bigger than largest supported object\n LL | |\n LL | |\n LL | | } };"}, {"sha": "2d48309b727229354512ca82cad09ce87a9ff9ed", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -31,12 +31,16 @@ const STR_VALID: &str = unsafe { mem::transmute((&42u8, 1usize)) };\n // bad str\n const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+//~^ ERROR it is undefined behavior to use this value\n // bad str\n const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad str in user-defined unsized type\n const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n+const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n \n // invalid UTF-8\n const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n@@ -83,7 +87,7 @@ const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute\n // # raw slice\n const RAW_SLICE_VALID: *const [u8] = unsafe { mem::transmute((&42u8, 1usize)) }; // ok\n const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, 999usize)) }; // ok because raw\n-const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::max_value())) }; // ok because raw\n+const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::MAX)) }; // ok because raw\n const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n //~^ ERROR it is undefined behavior to use this value\n     let uninit_len = MaybeUninit::<usize> { uninit: () };"}, {"sha": "a562c64b124f99e36c73b838f24976bdd54f2013", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -7,15 +7,23 @@ LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:35:1\n+  --> $DIR/ub-wide-ptr.rs:34:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object at .0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:37:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:38:1\n+  --> $DIR/ub-wide-ptr.rs:40:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -25,21 +33,29 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:42:1\n    |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:46:1\n+   |\n LL | const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:45:1\n+  --> $DIR/ub-wide-ptr.rs:49:1\n    |\n LL | const MYSTR_NO_UTF8: &MyStr = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:52:1\n+  --> $DIR/ub-wide-ptr.rs:56:1\n    |\n LL | / const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n LL | |\n@@ -51,63 +67,63 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:58:1\n+  --> $DIR/ub-wide-ptr.rs:62:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:61:1\n+  --> $DIR/ub-wide-ptr.rs:65:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:64:1\n+  --> $DIR/ub-wide-ptr.rs:68:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:67:1\n+  --> $DIR/ub-wide-ptr.rs:71:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n+  --> $DIR/ub-wide-ptr.rs:75:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:81:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:80:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:91:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -119,65 +135,65 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:99:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:98:1\n+  --> $DIR/ub-wide-ptr.rs:102:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:101:1\n+  --> $DIR/ub-wide-ptr.rs:105:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:109:1\n+  --> $DIR/ub-wide-ptr.rs:113:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:115:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:117:5\n+  --> $DIR/ub-wide-ptr.rs:121:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid use of NULL pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:121:5\n+  --> $DIR/ub-wide-ptr.rs:125:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f2ca7ff782591d0b45d8e9598f708a2c2a1ddf5e", "filename": "src/test/ui/consts/const-points-to-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -8,7 +8,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-points-to-static.rs:5:1\n    |\n LL | const TEST: &u8 = &MY_STATIC;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "5e85be45b164711a54c96d36519996e76263d345", "filename": "src/test/ui/consts/issue-63952.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -8,7 +8,7 @@ LL | |             ptr: &42,\n ...  |\n LL | |     .slice\n LL | | };\n-   | |__^ invalid slice: total size is bigger than largest supported object\n+   | |__^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "ad777cfe8ea4bcb2d52a6a4b393e620a825bd4c0", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=c9bbfb94748f4ca9c483fd24a1c84e4ef84993e0", "patch": "@@ -48,7 +48,7 @@ LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n LL | |\n LL | | };\n-   | |__^ constant accesses static\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -97,7 +97,7 @@ LL | |     static FOO: usize = 0;\n LL | |     &FOO\n LL | |\n LL | | };\n-   | |__^ constant accesses static\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}