{"sha": "65248c5e05493d2f90acf2944ea657a03bce380a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MjQ4YzVlMDU0OTNkMmY5MGFjZjI5NDRlYTY1N2EwM2JjZTM4MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-25T01:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-25T01:01:42Z"}, "message": "auto merge of #19934 : tomjakubowski/rust/rustdoc-unboxed-closures-redux, r=alexcrichton\n\nWe render HRTB and the unboxed closure trait sugar (the so-called \r\n\"parenthesized\" notation) where appropriate. Also address the new\r\n`for` syntax on the old closures.", "tree": {"sha": "c8872fd121ad29d6639f67aed27f9740c238e873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8872fd121ad29d6639f67aed27f9740c238e873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65248c5e05493d2f90acf2944ea657a03bce380a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65248c5e05493d2f90acf2944ea657a03bce380a", "html_url": "https://github.com/rust-lang/rust/commit/65248c5e05493d2f90acf2944ea657a03bce380a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65248c5e05493d2f90acf2944ea657a03bce380a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e11b22713aebd28ceaaa2ecef937c9b9d247c2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e11b22713aebd28ceaaa2ecef937c9b9d247c2f", "html_url": "https://github.com/rust-lang/rust/commit/7e11b22713aebd28ceaaa2ecef937c9b9d247c2f"}, {"sha": "64b5464f303ec2e0561e8d879d6d43691743f392", "url": "https://api.github.com/repos/rust-lang/rust/commits/64b5464f303ec2e0561e8d879d6d43691743f392", "html_url": "https://github.com/rust-lang/rust/commit/64b5464f303ec2e0561e8d879d6d43691743f392"}], "stats": {"total": 314, "additions": 220, "deletions": 94}, "files": [{"sha": "cdc51bb801c58a718df8f3ce76bfd3dd315618f7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65248c5e05493d2f90acf2944ea657a03bce380a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65248c5e05493d2f90acf2944ea657a03bce380a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=65248c5e05493d2f90acf2944ea657a03bce380a", "patch": "@@ -328,7 +328,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             derived: clean::detect_derived(attrs.as_slice()),\n             trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n-                    clean::TraitBound(ty) => ty,\n+                    clean::TraitBound(polyt) => polyt.trait_,\n                     clean::RegionBound(..) => unreachable!(),\n                 }\n             }),"}, {"sha": "e28e125caa4d431ec9488cf026bc12e618c52a37", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 134, "deletions": 43, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/65248c5e05493d2f90acf2944ea657a03bce380a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65248c5e05493d2f90acf2944ea657a03bce380a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=65248c5e05493d2f90acf2944ea657a03bce380a", "patch": "@@ -43,8 +43,7 @@ use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n-use rustc::middle::subst;\n-use rustc::middle::subst::VecPerParamSpace;\n+use rustc::middle::subst::{mod, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n use rustc::middle::stability;\n use rustc::session::config;\n@@ -493,7 +492,7 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n #[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n-    TraitBound(Type)\n+    TraitBound(PolyTrait)\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n@@ -516,19 +515,55 @@ impl Clean<Vec<TyParamBound>> for ty::ExistentialBounds {\n     }\n }\n \n-fn external_path(cx: &DocContext, name: &str, substs: &subst::Substs) -> Path {\n+fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n+                        substs: &subst::Substs) -> PathParameters {\n+    use rustc::middle::ty::sty;\n     let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n                     .filter_map(|v| v.clean(cx))\n                     .collect();\n     let types = substs.types.get_slice(subst::TypeSpace).to_vec();\n-    let types = types.clean(cx);\n+\n+    match (trait_did, cx.tcx_opt()) {\n+        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n+        (Some(did), Some(ref tcx)) if tcx.lang_items.fn_trait_kind(did).is_some() => {\n+            assert_eq!(types.len(), 2);\n+            let inputs = match types[0].sty {\n+                sty::ty_tup(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                _ => {\n+                    return PathParameters::AngleBracketed {\n+                        lifetimes: lifetimes,\n+                        types: types.clean(cx)\n+                    }\n+                }\n+            };\n+            let output = match types[1].sty {\n+                sty::ty_tup(ref v) if v.is_empty() => None, // -> ()\n+                _ => Some(types[1].clean(cx))\n+            };\n+            PathParameters::Parenthesized {\n+                inputs: inputs,\n+                output: output\n+            }\n+        },\n+        (_, _) => {\n+            PathParameters::AngleBracketed {\n+                lifetimes: lifetimes,\n+                types: types.clean(cx),\n+            }\n+        }\n+    }\n+}\n+\n+// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n+// from Fn<(A, B,), C> to Fn(A, B) -> C\n+fn external_path(cx: &DocContext, name: &str, trait_did: Option<ast::DefId>,\n+                 substs: &subst::Substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            lifetimes: lifetimes,\n-            types: types,\n+            params: external_path_params(cx, trait_did, substs)\n         }],\n     }\n }\n@@ -543,25 +578,28 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(cx, \"Send\", &empty)),\n+                 external_path(cx, \"Send\", None, &empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(cx, \"Sized\", &empty)),\n+                 external_path(cx, \"Sized\", None, &empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(cx, \"Copy\", &empty)),\n+                 external_path(cx, \"Copy\", None, &empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(cx, \"Sync\", &empty)),\n+                 external_path(cx, \"Sync\", None, &empty)),\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(did,\n                                                                 (fqn, TypeTrait));\n-        TraitBound(ResolvedPath {\n-            path: path,\n-            typarams: None,\n-            did: did,\n+        TraitBound(PolyTrait {\n+            trait_: ResolvedPath {\n+                path: path,\n+                typarams: None,\n+                did: did,\n+            },\n+            lifetimes: vec![]\n         })\n     }\n }\n@@ -582,13 +620,34 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         let fqn = fqn.into_iter().map(|i| i.to_string())\n                      .collect::<Vec<String>>();\n         let path = external_path(cx, fqn.last().unwrap().as_slice(),\n-                                 &self.substs);\n+                                 Some(self.def_id), &self.substs);\n         cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n-        TraitBound(ResolvedPath {\n-            path: path,\n-            typarams: None,\n-            did: self.def_id,\n+\n+        debug!(\"ty::TraitRef\\n  substs.types(TypeSpace): {}\\n\",\n+               self.substs.types.get_slice(ParamSpace::TypeSpace));\n+\n+        // collect any late bound regions\n+        let mut late_bounds = vec![];\n+        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace).iter() {\n+            use rustc::middle::ty::{Region, sty};\n+            if let sty::ty_tup(ref ts) = ty_s.sty {\n+                for &ty_s in ts.iter() {\n+                    if let sty::ty_rptr(ref reg, _) = ty_s.sty {\n+                        if let &Region::ReLateBound(_, _) = reg {\n+                            debug!(\"  hit an ReLateBound {}\", reg);\n+                            if let Some(lt) = reg.clean(cx) {\n+                                late_bounds.push(lt)\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        TraitBound(PolyTrait {\n+            trait_: ResolvedPath { path: path, typarams: None, did: self.def_id, },\n+            lifetimes: late_bounds\n         })\n     }\n }\n@@ -615,7 +674,7 @@ impl<'tcx> Clean<(Vec<TyParamBound>, Option<Type>)> for ty::ParamBounds<'tcx> {\n             (v, None)\n         } else {\n             let ty = match ty::BoundSized.clean(cx) {\n-                TraitBound(ty) => ty,\n+                TraitBound(polyt) => polyt.trait_,\n                 _ => unreachable!()\n             };\n             (v, Some(ty))\n@@ -627,7 +686,10 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().iter().filter_map(|r| r.clean(cx)).map(RegionBound));\n-        v.extend(self.types.iter().map(|t| TraitBound(t.clean(cx))));\n+        v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n+            trait_: t.clean(cx),\n+            lifetimes: vec![]\n+        })));\n         if v.len() > 0 {Some(v)} else {None}\n     }\n }\n@@ -1006,9 +1068,12 @@ impl Clean<Type> for ast::TraitRef {\n     }\n }\n \n-impl Clean<Type> for ast::PolyTraitRef {\n-    fn clean(&self, cx: &DocContext) -> Type {\n-        self.trait_ref.clean(cx)\n+impl Clean<PolyTrait> for ast::PolyTraitRef {\n+    fn clean(&self, cx: &DocContext) -> PolyTrait {\n+        PolyTrait {\n+            trait_: self.trait_ref.clean(cx),\n+            lifetimes: self.bound_lifetimes.clean(cx)\n+        }\n     }\n }\n \n@@ -1129,6 +1194,13 @@ impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n     }\n }\n \n+/// A trait reference, which may have higher ranked lifetimes.\n+#[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+pub struct PolyTrait {\n+    pub trait_: Type,\n+    pub lifetimes: Vec<Lifetime>\n+}\n+\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n@@ -1399,7 +1471,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     _ => TypeEnum,\n                 };\n                 let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n-                                         substs);\n+                                         None, substs);\n                 cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n@@ -1708,31 +1780,48 @@ impl Clean<Path> for ast::Path {\n }\n \n #[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n-pub struct PathSegment {\n-    pub name: String,\n-    pub lifetimes: Vec<Lifetime>,\n-    pub types: Vec<Type>,\n+pub enum PathParameters {\n+    AngleBracketed {\n+        lifetimes: Vec<Lifetime>,\n+        types: Vec<Type>,\n+    },\n+    Parenthesized {\n+        inputs: Vec<Type>,\n+        output: Option<Type>\n+    }\n }\n \n-impl Clean<PathSegment> for ast::PathSegment {\n-    fn clean(&self, cx: &DocContext) -> PathSegment {\n-        let (lifetimes, types) = match self.parameters {\n+impl Clean<PathParameters> for ast::PathParameters {\n+    fn clean(&self, cx: &DocContext) -> PathParameters {\n+        match *self {\n             ast::AngleBracketedParameters(ref data) => {\n-                (data.lifetimes.clean(cx), data.types.clean(cx))\n+                PathParameters::AngleBracketed {\n+                    lifetimes: data.lifetimes.clean(cx),\n+                    types: data.types.clean(cx)\n+                }\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n-                // FIXME -- rustdoc should be taught about Foo() notation\n-                let inputs = Tuple(data.inputs.clean(cx));\n-                let output = data.output.as_ref().map(|t| t.clean(cx)).unwrap_or(Tuple(Vec::new()));\n-                (Vec::new(), vec![inputs, output])\n+                PathParameters::Parenthesized {\n+                    inputs: data.inputs.clean(cx),\n+                    output: data.output.clean(cx)\n+                }\n             }\n-        };\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+pub struct PathSegment {\n+    pub name: String,\n+    pub params: PathParameters\n+}\n \n+impl Clean<PathSegment> for ast::PathSegment {\n+    fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n             name: self.identifier.clean(cx),\n-            lifetimes: lifetimes,\n-            types: types,\n+            params: self.parameters.clean(cx)\n         }\n     }\n }\n@@ -2363,8 +2452,10 @@ fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n             global: false,\n             segments: vec![PathSegment {\n                 name: name.to_string(),\n-                lifetimes: vec![],\n-                types: vec![t.clean(cx)],\n+                params: PathParameters::AngleBracketed {\n+                    lifetimes: vec![],\n+                    types: vec![t.clean(cx)],\n+                }\n             }],\n         },\n     }"}, {"sha": "841588e401261d7d01fa73a1e0cfd2eaf885e1ed", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 85, "deletions": 50, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/65248c5e05493d2f90acf2944ea657a03bce380a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65248c5e05493d2f90acf2944ea657a03bce380a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=65248c5e05493d2f90acf2944ea657a03bce380a", "patch": "@@ -142,6 +142,22 @@ impl fmt::Show for clean::Lifetime {\n     }\n }\n \n+impl fmt::Show for clean::PolyTrait {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.lifetimes.len() > 0 {\n+            try!(f.write(\"for&lt;\".as_bytes()));\n+            for (i, lt) in self.lifetimes.iter().enumerate() {\n+                if i > 0 {\n+                    try!(f.write(\", \".as_bytes()));\n+                }\n+                try!(write!(f, \"{}\", lt));\n+            }\n+            try!(f.write(\"&gt; \".as_bytes()));\n+        }\n+        write!(f, \"{}\", self.trait_)\n+    }\n+}\n+\n impl fmt::Show for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -155,37 +171,69 @@ impl fmt::Show for clean::TyParamBound {\n     }\n }\n \n-impl fmt::Show for clean::Path {\n+impl fmt::Show for clean::PathParameters {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.global {\n-            try!(f.write(\"::\".as_bytes()))\n-        }\n-\n-        for (i, seg) in self.segments.iter().enumerate() {\n-            if i > 0 {\n-                try!(f.write(\"::\".as_bytes()))\n-            }\n-            try!(f.write(seg.name.as_bytes()));\n-\n-            if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                try!(f.write(\"&lt;\".as_bytes()));\n-                let mut comma = false;\n-                for lifetime in seg.lifetimes.iter() {\n-                    if comma {\n-                        try!(f.write(\", \".as_bytes()));\n+        match *self {\n+            clean::PathParameters::AngleBracketed { ref lifetimes, ref types } => {\n+                if lifetimes.len() > 0 || types.len() > 0 {\n+                    try!(f.write(\"&lt;\".as_bytes()));\n+                    let mut comma = false;\n+                    for lifetime in lifetimes.iter() {\n+                        if comma {\n+                            try!(f.write(\", \".as_bytes()));\n+                        }\n+                        comma = true;\n+                        try!(write!(f, \"{}\", *lifetime));\n                     }\n-                    comma = true;\n-                    try!(write!(f, \"{}\", *lifetime));\n+                    for ty in types.iter() {\n+                        if comma {\n+                            try!(f.write(\", \".as_bytes()));\n+                        }\n+                        comma = true;\n+                        try!(write!(f, \"{}\", *ty));\n+                    }\n+                    try!(f.write(\"&gt;\".as_bytes()));\n                 }\n-                for ty in seg.types.iter() {\n+            }\n+            clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n+                try!(f.write(\"(\".as_bytes()));\n+                let mut comma = false;\n+                for ty in inputs.iter() {\n                     if comma {\n                         try!(f.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n                     try!(write!(f, \"{}\", *ty));\n                 }\n-                try!(f.write(\"&gt;\".as_bytes()));\n+                try!(f.write(\")\".as_bytes()));\n+                if let Some(ref ty) = *output {\n+                    try!(f.write(\" -&gt; \".as_bytes()));\n+                    try!(write!(f, \"{}\", ty));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl fmt::Show for clean::PathSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(f.write(self.name.as_bytes()));\n+        write!(f, \"{}\", self.params)\n+    }\n+}\n+\n+impl fmt::Show for clean::Path {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.global {\n+            try!(f.write(\"::\".as_bytes()))\n+        }\n+\n+        for (i, seg) in self.segments.iter().enumerate() {\n+            if i > 0 {\n+                try!(f.write(\"::\".as_bytes()))\n             }\n+            try!(write!(f, \"{}\", seg));\n         }\n         Ok(())\n     }\n@@ -227,23 +275,8 @@ fn path<F, G>(w: &mut fmt::Formatter,\n     G: FnOnce(&render::Cache) -> Option<(Vec<String>, ItemType)>,\n {\n     // The generics will get written to both the title and link\n-    let mut generics = String::new();\n     let last = path.segments.last().unwrap();\n-    if last.lifetimes.len() > 0 || last.types.len() > 0 {\n-        let mut counter = 0u;\n-        generics.push_str(\"&lt;\");\n-        for lifetime in last.lifetimes.iter() {\n-            if counter > 0 { generics.push_str(\", \"); }\n-            counter += 1;\n-            generics.push_str(format!(\"{}\", *lifetime).as_slice());\n-        }\n-        for ty in last.types.iter() {\n-            if counter > 0 { generics.push_str(\", \"); }\n-            counter += 1;\n-            generics.push_str(format!(\"{}\", *ty).as_slice());\n-        }\n-        generics.push_str(\"&gt;\");\n-    }\n+    let generics = format!(\"{}\", last.params);\n \n     let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n     let cache = cache();\n@@ -389,15 +422,6 @@ impl fmt::Show for clean::Type {\n                 try!(resolved_path(f, did, path, false));\n                 tybounds(f, typarams)\n             }\n-            clean::PolyTraitRef(ref bounds) => {\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        try!(write!(f, \" + \"));\n-                    }\n-                    try!(write!(f, \"{}\", *bound));\n-                }\n-                Ok(())\n-            }\n             clean::Infer => write!(f, \"_\"),\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n@@ -407,7 +431,7 @@ impl fmt::Show for clean::Type {\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_string()\n                        } else {\n-                           format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n+                           format!(\"for &lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n                        arrow = decl.decl.output,\n@@ -436,7 +460,7 @@ impl fmt::Show for clean::Type {\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_string()\n                        } else {\n-                           format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n+                           format!(\"for &lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n                        bounds = if decl.bounds.len() == 0 {\n@@ -505,6 +529,15 @@ impl fmt::Show for clean::Type {\n                     }\n                 }\n             }\n+            clean::PolyTraitRef(ref bounds) => {\n+                for (i, bound) in bounds.iter().enumerate() {\n+                    if i != 0 {\n+                        try!(write!(f, \" + \"));\n+                    }\n+                    try!(write!(f, \"{}\", *bound));\n+                }\n+                Ok(())\n+            }\n             clean::QPath { ref name, ref self_type, ref trait_ } => {\n                 write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n             }\n@@ -644,8 +677,10 @@ impl fmt::Show for clean::ViewListIdent {\n                     global: false,\n                     segments: vec!(clean::PathSegment {\n                         name: self.name.clone(),\n-                        lifetimes: Vec::new(),\n-                        types: Vec::new(),\n+                        params: clean::PathParameters::AngleBracketed {\n+                            lifetimes: Vec::new(),\n+                            types: Vec::new(),\n+                        }\n                     })\n                 };\n                 resolved_path(f, did, &path, false)"}]}