{"sha": "ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhM2JlODM0ODgxYTVhNjJjMDBjYjQ5YWMwOWIyZDFiOWYzNWZlNWY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-20T20:15:05Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-20T20:15:05Z"}, "message": "Lint about `format!(\"{}\", foo)`", "tree": {"sha": "0f1d5f7c14dcb52d985dc4fb2203bd3cc1e04a61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f1d5f7c14dcb52d985dc4fb2203bd3cc1e04a61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "html_url": "https://github.com/rust-lang/rust/commit/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6443b992898eebf465470c2dcdb93fdbd87d381", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6443b992898eebf465470c2dcdb93fdbd87d381", "html_url": "https://github.com/rust-lang/rust/commit/b6443b992898eebf465470c2dcdb93fdbd87d381"}], "stats": {"total": 93, "additions": 86, "deletions": 7}, "files": [{"sha": "704b4e8e8fa0324350e7a0839a3b8cdd338eeb65", "filename": "src/format.rs", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/src%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/src%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformat.rs?ref=ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "patch": "@@ -1,11 +1,14 @@\n+use rustc::front::map::Node::NodeItem;\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use utils::{is_expn_of, span_lint};\n+use syntax::ast::LitKind;\n+use utils::{DISPLAY_FMT_METHOD_PATH, FMT_ARGUMENTS_NEWV1_PATH};\n+use utils::{is_expn_of, match_path, span_lint};\n \n /// **What it does:** This lints about use of `format!(\"string literal with no argument\")`.\n ///\n /// **Why is this bad?** There is no point of doing that. If you want a `String` you can use\n-/// `to_owned` on the string literal. The even worst `&format!(\"foo\")` is often encountered in the\n+/// `to_owned` on the string literal. The even worse `&format!(\"foo\")` is often encountered in the\n /// wild.\n ///\n /// **Known problems:** None.\n@@ -28,13 +31,82 @@ impl LintPass for FormatMacLint {\n \n impl LateLintPass for FormatMacLint {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-        if let ExprMatch(ref matchee, _, _) = expr.node {\n-            if let ExprTup(ref tup) = matchee.node {\n-                if tup.is_empty() && is_expn_of(cx, expr.span, \"format\").is_some() {\n-                    span_lint(cx, USELESS_FORMAT, expr.span, &\"useless use of `format!`\");\n+        if let Some(span) = is_expn_of(cx, expr.span, \"format\") {\n+            match expr.node {\n+                // `format!(\"{}\", foo)` expansion\n+                ExprCall(ref fun, ref args) => {\n+                    if_let_chain!{[\n+                        let ExprPath(_, ref path) = fun.node,\n+                        args.len() == 2,\n+                        match_path(path, &FMT_ARGUMENTS_NEWV1_PATH),\n+                        // ensure the format string is `\"{..}\"` with only one argument and no text\n+                        check_static_str(cx, &args[0]),\n+                        // ensure the format argument is `{}` ie. Display with no fancy option\n+                        check_arg_is_display(&args[1])\n+                    ], {\n+                        span_lint(cx, USELESS_FORMAT, span, &\"useless use of `format!`\");\n+                    }}\n                 }\n+                // `format!(\"foo\")` expansion contains `match () { () => [], }`\n+                ExprMatch(ref matchee, _, _) => {\n+                    if let ExprTup(ref tup) = matchee.node {\n+                        if tup.is_empty() {\n+                            span_lint(cx, USELESS_FORMAT, span, &\"useless use of `format!`\");\n+                        }\n+                    }\n+                }\n+                _ => (),\n             }\n         }\n     }\n }\n+\n+/// Checks if the expressions matches\n+/// ```\n+/// { static __STATIC_FMTSTR: &[\"\"] = _; __STATIC_FMTSTR }\n+/// ```\n+fn check_static_str(cx: &LateContext, expr: &Expr) -> bool {\n+    if_let_chain! {[\n+        let ExprBlock(ref block) = expr.node,\n+        block.stmts.len() == 1,\n+        let StmtDecl(ref decl, _) = block.stmts[0].node,\n+        let DeclItem(ref decl) = decl.node,\n+        let Some(NodeItem(decl)) = cx.tcx.map.find(decl.id),\n+        decl.name.as_str() == \"__STATIC_FMTSTR\",\n+        let ItemStatic(_, _, ref expr) = decl.node,\n+        let ExprAddrOf(_, ref expr) = expr.node, // &[\"\"]\n+        let ExprVec(ref expr) = expr.node,\n+        expr.len() == 1,\n+        let ExprLit(ref lit) = expr[0].node,\n+        let LitKind::Str(ref lit, _) = lit.node,\n+        lit.is_empty()\n+    ], {\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n+/// Checks if the expressions matches\n+/// ```\n+/// &match (&42,) {\n+///     (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],\n+/// })\n+/// ```\n+fn check_arg_is_display(expr: &Expr) -> bool {\n+    if_let_chain! {[\n+        let ExprAddrOf(_, ref expr) = expr.node,\n+        let ExprMatch(_, ref arms, _) = expr.node,\n+        arms.len() == 1,\n+        let ExprVec(ref exprs) = arms[0].body.node,\n+        exprs.len() == 1,\n+        let ExprCall(_, ref args) = exprs[0].node,\n+        args.len() == 2,\n+        let ExprPath(None, ref path) = args[1].node,\n+        match_path(path, &DISPLAY_FMT_METHOD_PATH)\n+    ], {\n+        return true;\n+    }}\n+\n+    false\n+}"}, {"sha": "8348eb09834b29855991ba5dae3c1dfd1034db53", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "patch": "@@ -56,6 +56,7 @@ pub mod enum_variants;\n pub mod eq_op;\n pub mod escape;\n pub mod eta_reduction;\n+pub mod format;\n pub mod identity_op;\n pub mod items_after_statements;\n pub mod len_zero;"}, {"sha": "68137fbbf2a3fbefec77a523ef4ba85d80e201c6", "filename": "src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "patch": "@@ -28,7 +28,9 @@ pub const CLONE_TRAIT_PATH: [&'static str; 2] = [\"clone\", \"Clone\"];\n pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const DEBUG_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n+pub const DISPLAY_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n pub const DROP_PATH: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n+pub const FMT_ARGUMENTS_NEWV1_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTV1_NEW_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const HASHMAP_ENTRY_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];"}, {"sha": "0219771e09e46b1282193f0e92c1fc4d963b80c6", "filename": "tests/compile-fail/format.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/tests%2Fcompile-fail%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f/tests%2Fcompile-fail%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fformat.rs?ref=ba3be834881a5a62c00cb49ac09b2d1b9f35fe5f", "patch": "@@ -4,7 +4,11 @@\n \n fn main() {\n     format!(\"foo\"); //~ERROR useless use of `format!`\n+    format!(\"{}\", 42); //~ERROR useless use of `format!`\n+    format!(\"{:?}\", 42); // we only want to warn about `{}`\n+    format!(\"{:+}\", 42); // we only want to warn about `{}`\n     format!(\"foo {}\", 42);\n+    format!(\"{} bar\", 42);\n \n     println!(\"foo\");\n     println!(\"foo {}\", 42);"}]}