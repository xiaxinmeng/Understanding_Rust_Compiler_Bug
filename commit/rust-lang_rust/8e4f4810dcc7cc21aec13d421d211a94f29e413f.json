{"sha": "8e4f4810dcc7cc21aec13d421d211a94f29e413f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNGY0ODEwZGNjN2NjMjFhZWMxM2Q0MjFkMjExYTk0ZjI5ZTQxM2Y=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-23T17:54:02Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-01T13:43:44Z"}, "message": "Fill some holes in SVH/ICH computation, making it more strict.", "tree": {"sha": "2618492600ed784ded8e6d6463d69e5be9f1971b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2618492600ed784ded8e6d6463d69e5be9f1971b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e4f4810dcc7cc21aec13d421d211a94f29e413f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4f4810dcc7cc21aec13d421d211a94f29e413f", "html_url": "https://github.com/rust-lang/rust/commit/8e4f4810dcc7cc21aec13d421d211a94f29e413f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e4f4810dcc7cc21aec13d421d211a94f29e413f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd65cb223a3cd1a0fa8d98e9402f8725d606f6b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd65cb223a3cd1a0fa8d98e9402f8725d606f6b2", "html_url": "https://github.com/rust-lang/rust/commit/dd65cb223a3cd1a0fa8d98e9402f8725d606f6b2"}], "stats": {"total": 356, "additions": 291, "deletions": 65}, "files": [{"sha": "6ad93d8f4733cb4bc58a2ba05bdfcab3b167f0df", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e4f4810dcc7cc21aec13d421d211a94f29e413f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4f4810dcc7cc21aec13d421d211a94f29e413f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=8e4f4810dcc7cc21aec13d421d211a94f29e413f", "patch": "@@ -35,6 +35,8 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::util::common::record_time;\n+use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n@@ -48,19 +50,27 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                                     -> IncrementalHashesMap {\n     let _ignore = tcx.dep_graph.in_ignore();\n     let krate = tcx.map.krate();\n-    let mut visitor = HashItemsVisitor { tcx: tcx,\n-                                         hashes: FnvHashMap(),\n-                                         def_path_hashes: DefPathHashes::new(tcx) };\n-    visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| visit::walk_crate(v, krate));\n-    krate.visit_all_items(&mut visitor);\n-    visitor.compute_crate_hash();\n+    let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n+    let mut visitor = HashItemsVisitor {\n+        tcx: tcx,\n+        hashes: FnvHashMap(),\n+        def_path_hashes: DefPathHashes::new(tcx),\n+        hash_spans: hash_spans\n+    };\n+    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n+        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX),\n+                                 |v| visit::walk_crate(v, krate));\n+        krate.visit_all_items(&mut visitor);\n+    });\n+    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n     visitor.hashes\n }\n \n struct HashItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_path_hashes: DefPathHashes<'a, 'tcx>,\n     hashes: IncrementalHashesMap,\n+    hash_spans: bool,\n }\n \n impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n@@ -81,7 +91,8 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n         let mut state = SipHasher::new();\n         walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n                                                    self.tcx,\n-                                                   &mut self.def_path_hashes));\n+                                                   &mut self.def_path_hashes,\n+                                                   self.hash_spans));\n         let item_hash = state.finish();\n         self.hashes.insert(DepNode::Hir(def_id), item_hash);\n         debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n@@ -117,9 +128,12 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n             item_hashes.hash(&mut crate_state);\n         }\n \n-        for attr in &krate.attrs {\n-            debug!(\"krate attr {:?}\", attr);\n-            attr.meta().hash(&mut crate_state);\n+        {\n+            let mut visitor = StrictVersionHashVisitor::new(&mut crate_state,\n+                                                            self.tcx,\n+                                                            &mut self.def_path_hashes,\n+                                                            self.hash_spans);\n+            visitor.hash_attributes(&krate.attrs);\n         }\n \n         let crate_hash = crate_state.finish();"}, {"sha": "de286d68fe980528bd80b2c7ce51681eb786d5eb", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 266, "deletions": 55, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/8e4f4810dcc7cc21aec13d421d211a94f29e413f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4f4810dcc7cc21aec13d421d211a94f29e413f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=8e4f4810dcc7cc21aec13d421d211a94f29e413f", "patch": "@@ -13,18 +13,16 @@\n // hash computation, but for many kinds of items the order of\n // declaration should be irrelevant to the ABI.\n \n-pub use self::SawExprComponent::*;\n-pub use self::SawStmtComponent::*;\n+use self::SawExprComponent::*;\n use self::SawAbiComponent::*;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name, NodeId, Attribute};\n use syntax::parse::token;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n use rustc::ty::TyCtxt;\n \n use std::hash::{Hash, SipHasher};\n@@ -34,22 +32,41 @@ use super::def_path_hash::DefPathHashes;\n pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n     pub st: &'a mut SipHasher,\n-\n     // collect a deterministic hash of def-ids that we have seen\n     def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n+    hash_spans: bool,\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     pub fn new(st: &'a mut SipHasher,\n                tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>)\n+               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n+               hash_spans: bool)\n                -> Self {\n-        StrictVersionHashVisitor { st: st, tcx: tcx, def_path_hashes: def_path_hashes }\n+        StrictVersionHashVisitor {\n+            st: st,\n+            tcx: tcx,\n+            def_path_hashes: def_path_hashes,\n+            hash_spans: hash_spans,\n+        }\n     }\n \n     fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n         self.def_path_hashes.hash(def_id)\n     }\n+\n+    #[inline]\n+    fn hash_span(&mut self, span: Span) {\n+        if self.hash_spans {\n+            let _ = span;\n+        }\n+    }\n+\n+    fn hash_discriminant<T>(&mut self, v: &T) {\n+        unsafe {\n+            ::std::intrinsics::discriminant_value(&v).hash(self.st);\n+        }\n+    }\n }\n \n // To off-load the bulk of the hash-computation on #[derive(Hash)],\n@@ -80,26 +97,35 @@ enum SawAbiComponent<'a> {\n     SawIdent(token::InternedString),\n     SawStructDef(token::InternedString),\n \n-    SawLifetime(token::InternedString),\n-    SawLifetimeDef(token::InternedString),\n+    SawLifetime,\n+    SawLifetimeDef(usize),\n \n     SawMod,\n     SawForeignItem,\n     SawItem,\n     SawTy,\n     SawGenerics,\n-    SawFn,\n     SawTraitItem,\n     SawImplItem,\n     SawStructField,\n     SawVariant,\n-    SawPath,\n+    SawPath(bool),\n+    SawPathSegment,\n+    SawPathParameters,\n+    SawPathListItem,\n     SawBlock,\n     SawPat,\n     SawLocal,\n     SawArm,\n     SawExpr(SawExprComponent<'a>),\n-    SawStmt(SawStmtComponent),\n+    SawStmt,\n+    SawVis,\n+    SawWherePredicate,\n+    SawTyParamBound,\n+    SawPolyTraitRef,\n+    SawAssocTypeBinding,\n+    SawAttribute(ast::AttrStyle, bool),\n+    SawMacroDef,\n }\n \n /// SawExprComponent carries all of the information that we want\n@@ -117,7 +143,7 @@ enum SawAbiComponent<'a> {\n /// guarantee of collision-freedom, hash collisions are just\n /// (hopefully) unlikely.)\n #[derive(Hash)]\n-pub enum SawExprComponent<'a> {\n+enum SawExprComponent<'a> {\n \n     SawExprLoop(Option<token::InternedString>),\n     SawExprField(token::InternedString),\n@@ -185,31 +211,39 @@ fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n     }\n }\n \n-/// SawStmtComponent is analogous to SawExprComponent, but for statements.\n-#[derive(Hash)]\n-pub enum SawStmtComponent {\n-    SawStmtExpr,\n-    SawStmtSemi,\n+macro_rules! hash_attrs {\n+    ($visitor:expr, $attrs:expr) => ({\n+        let attrs = $attrs;\n+        if attrs.len() > 0 {\n+            $visitor.hash_attributes(attrs);\n+        }\n+    })\n }\n \n-impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n+impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn visit_nested_item(&mut self, _: ItemId) {\n         // Each item is hashed independently; ignore nested items.\n     }\n \n-    fn visit_variant_data(&mut self, s: &'tcx VariantData, name: Name,\n-                          g: &'tcx Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self,\n+                          s: &'tcx VariantData,\n+                          name: Name,\n+                          _: &'tcx Generics,\n+                          _: NodeId,\n+                          span: Span) {\n         debug!(\"visit_variant_data: st={:?}\", self.st);\n         SawStructDef(name.as_str()).hash(self.st);\n-        visit::walk_generics(self, g);\n-        visit::walk_struct_def(self, s)\n+        self.hash_span(span);\n+        visit::walk_struct_def(self, s);\n     }\n \n-    fn visit_variant(&mut self, v: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx Variant,\n+                     g: &'tcx Generics,\n+                     item_id: NodeId) {\n         debug!(\"visit_variant: st={:?}\", self.st);\n         SawVariant.hash(self.st);\n-        // walk_variant does not call walk_generics, so do it here.\n-        visit::walk_generics(self, g);\n+        hash_attrs!(self, &v.node.attrs);\n         visit::walk_variant(self, v, g, item_id)\n     }\n \n@@ -227,19 +261,22 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n     // (If you edit a method such that it deviates from the\n     // pattern, please move that method up above this comment.)\n \n-    fn visit_name(&mut self, _: Span, name: Name) {\n+    fn visit_name(&mut self, span: Span, name: Name) {\n         debug!(\"visit_name: st={:?}\", self.st);\n         SawIdent(name.as_str()).hash(self.st);\n+        self.hash_span(span);\n     }\n \n     fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n         debug!(\"visit_lifetime: st={:?}\", self.st);\n-        SawLifetime(l.name.as_str()).hash(self.st);\n+        SawLifetime.hash(self.st);\n+        visit::walk_lifetime(self, l);\n     }\n \n     fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n         debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-        SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n+        SawLifetimeDef(l.bounds.len()).hash(self.st);\n+        visit::walk_lifetime_def(self, l);\n     }\n \n     // We do recursively walk the bodies of functions/methods\n@@ -249,7 +286,12 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n     // crates to be recompiled.\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n-        SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n+        SawExpr(saw_expr(&ex.node)).hash(self.st);\n+        // No need to explicitly hash the discriminant here, since we are\n+        // implicitly hashing the discriminant of SawExprComponent.\n+        self.hash_span(ex.span);\n+        hash_attrs!(self, &ex.attrs);\n+        visit::walk_expr(self, ex)\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx Stmt) {\n@@ -263,8 +305,16 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n         // rules).\n         match s.node {\n             StmtDecl(..) => (),\n-            StmtExpr(..) => SawStmt(SawStmtExpr).hash(self.st),\n-            StmtSemi(..) => SawStmt(SawStmtSemi).hash(self.st),\n+            StmtExpr(..) => {\n+                SawStmt.hash(self.st);\n+                self.hash_discriminant(&s.node);\n+                self.hash_span(s.span);\n+            }\n+            StmtSemi(..) => {\n+                SawStmt.hash(self.st);\n+                self.hash_discriminant(&s.node);\n+                self.hash_span(s.span);\n+            }\n         }\n \n         visit::walk_stmt(self, s)\n@@ -277,17 +327,21 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n         // perhaps reachability) somewhere here, so foreign items\n         // that do not leak into downstream crates would not be\n         // part of the ABI.\n-        SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n+        SawForeignItem.hash(self.st);\n+        self.hash_span(i.span);\n+        hash_attrs!(self, &i.attrs);\n+        visit::walk_foreign_item(self, i)\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n \n-        // FIXME (#14132) ideally would incorporate reachability\n-        // analysis somewhere here, so items that never leak into\n-        // downstream crates (e.g. via monomorphisation or\n-        // inlining) would not be part of the ABI.\n-        SawItem.hash(self.st); visit::walk_item(self, i)\n+        SawItem.hash(self.st);\n+        // Hash the value of the discriminant of the Item variant.\n+        self.hash_discriminant(&i.node);\n+        self.hash_span(i.span);\n+        hash_attrs!(self, &i.attrs);\n+        visit::walk_item(self, i)\n     }\n \n     fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, n: NodeId) {\n@@ -297,63 +351,159 @@ impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx\n \n     fn visit_ty(&mut self, t: &'tcx Ty) {\n         debug!(\"visit_ty: st={:?}\", self.st);\n-        SawTy.hash(self.st); visit::walk_ty(self, t)\n+        SawTy.hash(self.st);\n+        self.hash_span(t.span);\n+        visit::walk_ty(self, t)\n     }\n \n     fn visit_generics(&mut self, g: &'tcx Generics) {\n         debug!(\"visit_generics: st={:?}\", self.st);\n-        SawGenerics.hash(self.st); visit::walk_generics(self, g)\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n-                b: &'tcx Block, s: Span, n: NodeId) {\n-        debug!(\"visit_fn: st={:?}\", self.st);\n-        SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n+        SawGenerics.hash(self.st);\n+        // FIXME: nested stuff\n+        visit::walk_generics(self, g)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n-        SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n+        SawTraitItem.hash(self.st);\n+        self.hash_discriminant(&ti.node);\n+        self.hash_span(ti.span);\n+        hash_attrs!(self, &ti.attrs);\n+        visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n-        SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n+        SawImplItem.hash(self.st);\n+        self.hash_discriminant(&ii.node);\n+        self.hash_span(ii.span);\n+        hash_attrs!(self, &ii.attrs);\n+        visit::walk_impl_item(self, ii)\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         debug!(\"visit_struct_field: st={:?}\", self.st);\n-        SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n+        SawStructField.hash(self.st);\n+        self.hash_span(s.span);\n+        hash_attrs!(self, &s.attrs);\n+        visit::walk_struct_field(self, s)\n     }\n \n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n-        SawPath.hash(self.st); visit::walk_path(self, path)\n+        SawPath(path.global).hash(self.st);\n+        self.hash_span(path.span);\n+        visit::walk_path(self, path)\n     }\n \n     fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n-        SawBlock.hash(self.st); visit::walk_block(self, b)\n+        SawBlock.hash(self.st);\n+        self.hash_span(b.span);\n+        visit::walk_block(self, b)\n     }\n \n     fn visit_pat(&mut self, p: &'tcx Pat) {\n         debug!(\"visit_pat: st={:?}\", self.st);\n-        SawPat.hash(self.st); visit::walk_pat(self, p)\n+        SawPat.hash(self.st);\n+        self.hash_discriminant(&p.node);\n+        self.hash_span(p.span);\n+        visit::walk_pat(self, p)\n     }\n \n     fn visit_local(&mut self, l: &'tcx Local) {\n         debug!(\"visit_local: st={:?}\", self.st);\n-        SawLocal.hash(self.st); visit::walk_local(self, l)\n+        SawLocal.hash(self.st);\n+        hash_attrs!(self, &l.attrs);\n+        visit::walk_local(self, l)\n+        // No need to hash span, we are hashing all component spans\n     }\n \n     fn visit_arm(&mut self, a: &'tcx Arm) {\n         debug!(\"visit_arm: st={:?}\", self.st);\n-        SawArm.hash(self.st); visit::walk_arm(self, a)\n+        SawArm.hash(self.st);\n+        hash_attrs!(self, &a.attrs);\n+        visit::walk_arm(self, a)\n     }\n \n     fn visit_id(&mut self, id: NodeId) {\n         debug!(\"visit_id: id={} st={:?}\", id, self.st);\n-        self.hash_resolve(id);\n+        self.hash_resolve(id)\n+    }\n+\n+    fn visit_vis(&mut self, v: &'tcx Visibility) {\n+        debug!(\"visit_vis: st={:?}\", self.st);\n+        SawVis.hash(self.st);\n+        self.hash_discriminant(&v);\n+        visit::walk_vis(self, v)\n+    }\n+\n+    fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n+        debug!(\"visit_where_predicate: st={:?}\", self.st);\n+        SawWherePredicate.hash(self.st);\n+        self.hash_discriminant(predicate);\n+        // Ignoring span. Any important nested components should be visited.\n+        visit::walk_where_predicate(self, predicate)\n+    }\n+\n+    fn visit_ty_param_bound(&mut self, bounds: &'tcx TyParamBound) {\n+        debug!(\"visit_ty_param_bound: st={:?}\", self.st);\n+        SawTyParamBound.hash(self.st);\n+        self.hash_discriminant(bounds);\n+        // The TraitBoundModifier in TraitTyParamBound will be hash in\n+        // visit_poly_trait_ref()\n+        visit::walk_ty_param_bound(self, bounds)\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: &'tcx TraitBoundModifier) {\n+        debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n+        SawPolyTraitRef.hash(self.st);\n+        m.hash(self.st);\n+        visit::walk_poly_trait_ref(self, t, m)\n+    }\n+\n+    fn visit_path_list_item(&mut self, prefix: &'tcx Path, item: &'tcx PathListItem) {\n+        debug!(\"visit_path_list_item: st={:?}\", self.st);\n+        SawPathListItem.hash(self.st);\n+        self.hash_discriminant(&item.node);\n+        self.hash_span(item.span);\n+        visit::walk_path_list_item(self, prefix, item)\n+    }\n+\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx PathSegment) {\n+        debug!(\"visit_path_segment: st={:?}\", self.st);\n+        SawPathSegment.hash(self.st);\n+        visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'tcx PathParameters) {\n+        debug!(\"visit_path_parameters: st={:?}\", self.st);\n+        SawPathParameters.hash(self.st);\n+        self.hash_discriminant(path_parameters);\n+        visit::walk_path_parameters(self, path_span, path_parameters)\n+    }\n+\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx TypeBinding) {\n+        debug!(\"visit_assoc_type_binding: st={:?}\", self.st);\n+        SawAssocTypeBinding.hash(self.st);\n+        self.hash_span(type_binding.span);\n+        visit::walk_assoc_type_binding(self, type_binding)\n+    }\n+\n+    fn visit_attribute(&mut self, _: &Attribute) {\n+        // We explicitly do not use this method, since doing that would\n+        // implicitly impose an order on the attributes being hashed, while we\n+        // explicitly don't want their order to matter\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'tcx MacroDef) {\n+        debug!(\"visit_macro_def: st={:?}\", self.st);\n+        if macro_def.export {\n+            SawMacroDef.hash(self.st);\n+            hash_attrs!(self, &macro_def.attrs);\n+            visit::walk_macro_def(self, macro_def)\n+            // FIXME: We should hash the body of the macro too.\n+        }\n     }\n }\n \n@@ -450,4 +600,65 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             }\n         }\n     }\n+\n+    fn hash_meta_item(&mut self, meta_item: &ast::MetaItem) {\n+        // ignoring span information, it doesn't matter here\n+        match meta_item.node {\n+            ast::MetaItemKind::Word(ref s) => {\n+                \"Word\".hash(self.st);\n+                s.len().hash(self.st);\n+                s.hash(self.st);\n+            }\n+            ast::MetaItemKind::NameValue(ref s, ref lit) => {\n+                \"NameValue\".hash(self.st);\n+                s.len().hash(self.st);\n+                s.hash(self.st);\n+                lit.node.hash(self.st);\n+            }\n+            ast::MetaItemKind::List(ref s, ref items) => {\n+                \"List\".hash(self.st);\n+                s.len().hash(self.st);\n+                s.hash(self.st);\n+                // Sort subitems so the hash does not depend on their order\n+                let indices = self.indices_sorted_by(&items, |p| {\n+                    meta_item_sort_key(&*p)\n+                });\n+                items.len().hash(self.st);\n+                for (index, &item_index) in indices.iter().enumerate() {\n+                    index.hash(self.st);\n+                    self.hash_meta_item(&items[item_index]);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn hash_attributes(&mut self, attributes: &[Attribute]) {\n+        let indices = self.indices_sorted_by(attributes, |attr| {\n+            meta_item_sort_key(&attr.node.value)\n+        });\n+\n+        for i in indices {\n+            let attr = &attributes[i].node;\n+            SawAttribute(attr.style, attr.is_sugared_doc).hash(self.st);\n+            self.hash_meta_item(&*attr.value);\n+        }\n+    }\n+\n+    fn indices_sorted_by<T, K, F>(&mut self, items: &[T], get_key: F) -> Vec<usize>\n+        where K: Ord,\n+              F: Fn(&T) -> K\n+    {\n+        let mut indices = Vec::with_capacity(items.len());\n+        indices.extend(0 .. items.len());\n+        indices.sort_by_key(|index| get_key(&items[*index]));\n+        indices\n+    }\n+}\n+\n+fn meta_item_sort_key(item: &ast::MetaItem) -> token::InternedString {\n+    match item.node {\n+        ast::MetaItemKind::Word(ref s) |\n+        ast::MetaItemKind::NameValue(ref s, _) |\n+        ast::MetaItemKind::List(ref s, _) => s.clone()\n+    }\n }"}, {"sha": "feacfdc96731f7a36747b0a54352f689381a7014", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e4f4810dcc7cc21aec13d421d211a94f29e413f/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e4f4810dcc7cc21aec13d421d211a94f29e413f/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=8e4f4810dcc7cc21aec13d421d211a94f29e413f", "patch": "@@ -23,6 +23,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n+#![feature(core_intrinsics)]\n \n extern crate graphviz;\n extern crate rbml;"}]}