{"sha": "89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "node_id": "C_kwDOAAsO6NoAKDg5YTE4Y2I2MDA1M2E2YzFiM2I1ZjgxNzI0NmRkZmQ5MTdiZTFlM2U", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-04-09T08:27:47Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-05-12T00:16:25Z"}, "message": "Add `unsigned_offset_from` on pointers\n\nLike we have `add`/`sub` which are the `usize` version of `offset`, this adds the `usize` equivalent of `offset_from`.  Like how `.add(d)` replaced a whole bunch of `.offset(d as isize)`, you can see from the changes here that it's fairly common that code actually knows the order between the pointers and *wants* a `usize`, not an `isize`.\n\nAs a bonus, this can do `sub nuw`+`udiv exact`, rather than `sub`+`sdiv exact`, which can be optimized slightly better because it doesn't have to worry about negatives.  That's why the slice iterators weren't using `offset_from`, though I haven't updated that code in this PR because slices are so perf-critical that I'll do it as its own change.\n\nThis is an intrinsic, like `offset_from`, so that it can eventually be allowed in CTFE.  It also allows checking the extra safety condition -- see the test confirming that CTFE catches it if you pass the pointers in the wrong order.", "tree": {"sha": "06a98e2a5b6cd45bd0542f91e167f0a15e138779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06a98e2a5b6cd45bd0542f91e167f0a15e138779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "html_url": "https://github.com/rust-lang/rust/commit/89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dd68402c5d7da168f87d8551dd9aed1d8a21893", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd68402c5d7da168f87d8551dd9aed1d8a21893", "html_url": "https://github.com/rust-lang/rust/commit/6dd68402c5d7da168f87d8551dd9aed1d8a21893"}], "stats": {"total": 290, "additions": 265, "deletions": 25}, "files": [{"sha": "b254ca3bec8435a729001cf530744dfdb0d10831", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -713,14 +713,21 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        ptr_offset_from, (v ptr, v base) {\n+        ptr_offset_from | ptr_offset_from_unsigned, (v ptr, v base) {\n             let ty = substs.type_at(0);\n             let isize_layout = fx.layout_of(fx.tcx.types.isize);\n \n             let pointee_size: u64 = fx.layout_of(ty).size.bytes();\n-            let diff = fx.bcx.ins().isub(ptr, base);\n+            let diff_bytes = fx.bcx.ins().isub(ptr, base);\n             // FIXME this can be an exact division.\n-            let val = CValue::by_val(fx.bcx.ins().sdiv_imm(diff, pointee_size as i64), isize_layout);\n+            let diff = if intrinsic == sym::ptr_offset_from_unsigned {\n+                // Because diff_bytes ULT isize::MAX, this would be fine as signed,\n+                // but unsigned is slightly easier to codegen, so might as well.\n+                fx.bcx.ins().udiv_imm(diff_bytes, pointee_size as i64)\n+            } else {\n+                fx.bcx.ins().sdiv_imm(diff_bytes, pointee_size as i64)\n+            };\n+            let val = CValue::by_val(diff, isize_layout);\n             ret.write_cvalue(fx, val);\n         };\n "}, {"sha": "6d6d3ae01f4a3baba88421b73f667b1b4ca3a30c", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -555,21 +555,28 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            sym::ptr_offset_from => {\n+            sym::ptr_offset_from | sym::ptr_offset_from_unsigned => {\n                 let ty = substs.type_at(0);\n                 let pointee_size = bx.layout_of(ty).size;\n \n-                // This is the same sequence that Clang emits for pointer subtraction.\n-                // It can be neither `nsw` nor `nuw` because the input is treated as\n-                // unsigned but then the output is treated as signed, so neither works.\n                 let a = args[0].immediate();\n                 let b = args[1].immediate();\n                 let a = bx.ptrtoint(a, bx.type_isize());\n                 let b = bx.ptrtoint(b, bx.type_isize());\n-                let d = bx.sub(a, b);\n                 let pointee_size = bx.const_usize(pointee_size.bytes());\n-                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n-                bx.exactsdiv(d, pointee_size)\n+                if name == sym::ptr_offset_from {\n+                    // This is the same sequence that Clang emits for pointer subtraction.\n+                    // It can be neither `nsw` nor `nuw` because the input is treated as\n+                    // unsigned but then the output is treated as signed, so neither works.\n+                    let d = bx.sub(a, b);\n+                    // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n+                    bx.exactsdiv(d, pointee_size)\n+                } else {\n+                    // The `_unsigned` version knows the relative ordering of the pointers,\n+                    // so can use `sub nuw` and `udiv exact` instead of dealing in signed.\n+                    let d = bx.unchecked_usub(a, b);\n+                    bx.exactudiv(d, pointee_size)\n+                }\n             }\n \n             _ => {"}, {"sha": "f6dd02a9abacfa288217c0e6a6ce502828d4567b", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -308,7 +308,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, self);\n                 self.write_pointer(offset_ptr, dest)?;\n             }\n-            sym::ptr_offset_from => {\n+            sym::ptr_offset_from | sym::ptr_offset_from_unsigned => {\n                 let a = self.read_pointer(&args[0])?;\n                 let b = self.read_pointer(&args[1])?;\n \n@@ -330,8 +330,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // Both are pointers. They must be into the same allocation.\n                         if a_alloc_id != b_alloc_id {\n                             throw_ub_format!(\n-                                \"ptr_offset_from cannot compute offset of pointers into different \\\n-                                allocations.\",\n+                                \"{} cannot compute offset of pointers into different allocations.\",\n+                                intrinsic_name,\n                             );\n                         }\n                         // And they must both be valid for zero-sized accesses (\"in-bounds or one past the end\").\n@@ -348,16 +348,30 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             CheckInAllocMsg::OffsetFromTest,\n                         )?;\n \n+                        if intrinsic_name == sym::ptr_offset_from_unsigned && a_offset < b_offset {\n+                            throw_ub_format!(\n+                                \"{} cannot compute a negative offset, but {} < {}\",\n+                                intrinsic_name,\n+                                a_offset.bytes(),\n+                                b_offset.bytes(),\n+                            );\n+                        }\n+\n                         // Compute offset.\n                         let usize_layout = self.layout_of(self.tcx.types.usize)?;\n                         let isize_layout = self.layout_of(self.tcx.types.isize)?;\n+                        let ret_layout = if intrinsic_name == sym::ptr_offset_from {\n+                            isize_layout\n+                        } else {\n+                            usize_layout\n+                        };\n                         let a_offset = ImmTy::from_uint(a_offset.bytes(), usize_layout);\n                         let b_offset = ImmTy::from_uint(b_offset.bytes(), usize_layout);\n                         let (val, _overflowed, _ty) =\n                             self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n                         let pointee_layout = self.layout_of(substs.type_at(0))?;\n-                        let val = ImmTy::from_scalar(val, isize_layout);\n-                        let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n+                        let val = ImmTy::from_scalar(val, ret_layout);\n+                        let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n                         self.exact_div(&val, &size, dest)?;\n                     }\n                 }"}, {"sha": "2cc6eb03585676c441a8bd369be1b85c446877c1", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -1079,6 +1079,7 @@ symbols! {\n         ptr_null,\n         ptr_null_mut,\n         ptr_offset_from,\n+        ptr_offset_from_unsigned,\n         pub_macro_rules,\n         pub_restricted,\n         pure,"}, {"sha": "b67185e52116d9a004acb90dd6b864948cf4c1b0", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -305,6 +305,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::ptr_offset_from => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.isize)\n             }\n+            sym::ptr_offset_from_unsigned => {\n+                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.usize)\n+            }\n             sym::unchecked_div | sym::unchecked_rem | sym::exact_div => {\n                 (1, vec![param(0), param(0)], param(0))\n             }"}, {"sha": "1c569e156077b16cd69a11b5231990e5273f92de", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -127,6 +127,7 @@\n #![feature(pattern)]\n #![feature(ptr_internals)]\n #![feature(ptr_metadata)]\n+#![feature(ptr_unsigned_offset_from)]\n #![feature(receiver_trait)]\n #![feature(set_ptr_value)]\n #![feature(slice_group_by)]"}, {"sha": "376aa4812bd7ac248078bcec6d100d43a08f3690", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -1056,7 +1056,7 @@ where\n         fn drop(&mut self) {\n             // `T` is not a zero-sized type, and these are pointers into a slice's elements.\n             unsafe {\n-                let len = self.end.offset_from(self.start) as usize;\n+                let len = self.end.unsigned_offset_from(self.start);\n                 ptr::copy_nonoverlapping(self.start, self.dest, len);\n             }\n         }"}, {"sha": "1e4d911e7e6d7e8e4bc638e4e87cdde4dd4fb669", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -163,7 +163,7 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n             // it from the original vec but also avoid creating a &mut to the front since that could\n             // invalidate raw pointers to it which some unsafe code might rely on.\n             let vec_ptr = vec.as_mut().as_mut_ptr();\n-            let drop_offset = drop_ptr.offset_from(vec_ptr) as usize;\n+            let drop_offset = drop_ptr.unsigned_offset_from(vec_ptr);\n             let to_drop = ptr::slice_from_raw_parts_mut(vec_ptr.add(drop_offset), drop_len);\n             ptr::drop_in_place(to_drop);\n         }"}, {"sha": "a393732567bba0020d232adb82a1f01a9e9eac43", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -250,7 +250,7 @@ where\n         let sink =\n             self.try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(end)).unwrap();\n         // iteration succeeded, don't drop head\n-        unsafe { ManuallyDrop::new(sink).dst.offset_from(dst_buf) as usize }\n+        unsafe { ManuallyDrop::new(sink).dst.unsigned_offset_from(dst_buf) }\n     }\n }\n "}, {"sha": "62334f6daba651c97f23f6ea3d5f3ce1a071e7c6", "filename": "library/alloc/src/vec/in_place_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -10,7 +10,7 @@ pub(super) struct InPlaceDrop<T> {\n \n impl<T> InPlaceDrop<T> {\n     fn len(&self) -> usize {\n-        unsafe { self.dst.offset_from(self.inner) as usize }\n+        unsafe { self.dst.unsigned_offset_from(self.inner) }\n     }\n }\n "}, {"sha": "b4797f3781305ca233730b69a457b5c448ec9df0", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -169,7 +169,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         let exact = if mem::size_of::<T>() == 0 {\n             self.end.addr().wrapping_sub(self.ptr.addr())\n         } else {\n-            unsafe { self.end.offset_from(self.ptr) as usize }\n+            unsafe { self.end.unsigned_offset_from(self.ptr) }\n         };\n         (exact, Some(exact))\n     }"}, {"sha": "10de5ff2d1d19b23dc11a571c918b44d09df9b46", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -1903,6 +1903,11 @@ extern \"rust-intrinsic\" {\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"92980\")]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n+    /// See documentation of `<*const T>::unsigned_offset_from` for details.\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"92980\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n+\n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n     ///\n     /// Note that, unlike most intrinsics, this is safe to call;\n@@ -2385,3 +2390,11 @@ where\n {\n     called_in_const.call_once(arg)\n }\n+\n+/// Bootstrap polyfill\n+#[cfg(bootstrap)]\n+pub const unsafe fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize {\n+    // SAFETY: we have stricter preconditions than `ptr_offset_from`, so can\n+    // call it, and its output has to be positive, so we can just cast.\n+    unsafe { ptr_offset_from(ptr, base) as _ }\n+}"}, {"sha": "203c78fda0b64cff3137f3e4bed4685a72695d0f", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -611,6 +611,67 @@ impl<T: ?Sized> *const T {\n         unsafe { intrinsics::ptr_offset_from(self, origin) }\n     }\n \n+    /// Calculates the distance between two pointers, *where it's known that\n+    /// `self` is equal to or greater than `origin`*. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This computes the same value that [`offset_from`](#method.offset_from)\n+    /// would compute, but with the added precondition that that the offset is\n+    /// guaranteed to be non-negative.  This method is equivalent to\n+    /// `usize::from(self.offset_from(origin)).unwrap_unchecked()`,\n+    /// but it provides slightly more information to the optimizer, which can\n+    /// sometimes allow it to optimize slightly better with some backends.\n+    ///\n+    /// This method is the inverse of [`add`](#method.add) (and, with the parameters\n+    /// in the other order, of [`sub`](#method.sub)).\n+    ///\n+    /// # Safety\n+    ///\n+    /// - The distance between the pointers must be non-negative (`self >= origin`)\n+    ///\n+    /// - *All* the safety conditions of [`offset_from`](#method.offset_from)\n+    ///   apply to this method as well; see it for the full details.\n+    ///\n+    /// Importantly, despite the return type of this method being able to represent\n+    /// a larger offset, it's still *not permitted* to pass pointers which differ\n+    /// by more than `isize::MAX` *bytes*.  As such, the result of this method will\n+    /// always be less than or equal to `isize::MAX as usize`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_unsigned_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.unsigned_offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.add(2), ptr2);\n+    ///     assert_eq!(ptr2.sub(2), ptr1);\n+    ///     assert_eq!(ptr2.unsigned_offset_from(ptr2), 0);\n+    /// }\n+    ///\n+    /// // This would be incorrect, as the pointers are not correctly ordered:\n+    /// // ptr1.offset_from(ptr2)\n+    /// ```\n+    #[unstable(feature = \"ptr_unsigned_offset_from\", issue = \"88888888\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"92980\")]\n+    #[inline]\n+    pub const unsafe fn unsigned_offset_from(self, origin: *const T) -> usize\n+    where\n+        T: Sized,\n+    {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n+        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n+        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+    }\n+\n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n     /// At runtime this function behaves like `self == other`."}, {"sha": "a0457df1b88bdc7f0635f613f6d11b38fc86579f", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -787,6 +787,66 @@ impl<T: ?Sized> *mut T {\n         unsafe { (self as *const T).offset_from(origin) }\n     }\n \n+    /// Calculates the distance between two pointers, *where it's known that\n+    /// `self` is equal to or greater than `origin`*. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This computes the same value that [`offset_from`](#method.offset_from)\n+    /// would compute, but with the added precondition that that the offset is\n+    /// guaranteed to be non-negative.  This method is equivalent to\n+    /// `usize::from(self.offset_from(origin)).unwrap_unchecked()`,\n+    /// but it provides slightly more information to the optimizer, which can\n+    /// sometimes allow it to optimize slightly better with some backends.\n+    ///\n+    /// This method is the inverse of [`add`](#method.add) (and, with the parameters\n+    /// in the other order, of [`sub`](#method.sub)).\n+    ///\n+    /// # Safety\n+    ///\n+    /// - The distance between the pointers must be non-negative (`self >= origin`)\n+    ///\n+    /// - *All* the safety conditions of [`offset_from`](#method.offset_from)\n+    ///   apply to this method as well; see it for the full details.\n+    ///\n+    /// Importantly, despite the return type of this method being able to represent\n+    /// a larger offset, it's still *not permitted* to pass pointers which differ\n+    /// by more than `isize::MAX` *bytes*.  As such, the result of this method will\n+    /// always be less than or equal to `isize::MAX as usize`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_unsigned_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let p: *mut i32 = a.as_mut_ptr();\n+    /// unsafe {\n+    ///     let ptr1: *mut i32 = p.add(1);\n+    ///     let ptr2: *mut i32 = p.add(3);\n+    ///\n+    ///     assert_eq!(ptr2.unsigned_offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.add(2), ptr2);\n+    ///     assert_eq!(ptr2.sub(2), ptr1);\n+    ///     assert_eq!(ptr2.unsigned_offset_from(ptr2), 0);\n+    /// }\n+    ///\n+    /// // This would be incorrect, as the pointers are not correctly ordered:\n+    /// // ptr1.offset_from(ptr2)\n+    #[unstable(feature = \"ptr_unsigned_offset_from\", issue = \"88888888\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"92980\")]\n+    #[inline]\n+    pub const unsafe fn unsigned_offset_from(self, origin: *const T) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: the caller must uphold the safety contract for `unsigned_offset_from`.\n+        unsafe { (self as *const T).unsigned_offset_from(origin) }\n+    }\n+\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer"}, {"sha": "e95f8a3143a5f08116641afe769f7535943e52b6", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -215,7 +215,7 @@ pub const fn from_mut<T>(s: &mut T) -> &mut [T] {\n #[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n pub unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_ptr_range`.\n-    unsafe { from_raw_parts(range.start, range.end.offset_from(range.start) as usize) }\n+    unsafe { from_raw_parts(range.start, range.end.unsigned_offset_from(range.start)) }\n }\n \n /// Performs the same functionality as [`from_ptr_range`], except that a\n@@ -265,5 +265,5 @@ pub unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T] {\n #[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n pub unsafe fn from_mut_ptr_range<'a, T>(range: Range<*mut T>) -> &'a mut [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_mut_ptr_range`.\n-    unsafe { from_raw_parts_mut(range.start, range.end.offset_from(range.start) as usize) }\n+    unsafe { from_raw_parts_mut(range.start, range.end.unsigned_offset_from(range.start)) }\n }"}, {"sha": "d0de4c8355d05a9385cd41d4c0be8f31d65f35a8", "filename": "src/test/codegen/intrinsics/offset_from.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fcodegen%2Fintrinsics%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fcodegen%2Fintrinsics%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Foffset_from.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -0,0 +1,36 @@\n+// compile-flags: -C opt-level=1\n+// only-64bit (because we're using [ui]size)\n+\n+#![crate_type = \"lib\"]\n+#![feature(core_intrinsics)]\n+\n+//! Basic optimizations are enabled because otherwise `x86_64-gnu-nopt` had an alloca.\n+//! Uses a type with non-power-of-two size to avoid normalizations to shifts.\n+\n+use std::intrinsics::*;\n+\n+type RGB = [u8; 3];\n+\n+// CHECK-LABEL: @offset_from_odd_size\n+#[no_mangle]\n+pub unsafe fn offset_from_odd_size(a: *const RGB, b: *const RGB) -> isize {\n+    // CHECK: start\n+    // CHECK-NEXT: ptrtoint\n+    // CHECK-NEXT: ptrtoint\n+    // CHECK-NEXT: sub i64\n+    // CHECK-NEXT: sdiv exact i64 %{{[0-9]+}}, 3\n+    // CHECK-NEXT: ret i64\n+    ptr_offset_from(a, b)\n+}\n+\n+// CHECK-LABEL: @offset_from_unsigned_odd_size\n+#[no_mangle]\n+pub unsafe fn offset_from_unsigned_odd_size(a: *const RGB, b: *const RGB) -> usize {\n+    // CHECK: start\n+    // CHECK-NEXT: ptrtoint\n+    // CHECK-NEXT: ptrtoint\n+    // CHECK-NEXT: sub nuw i64\n+    // CHECK-NEXT: udiv exact i64 %{{[0-9]+}}, 3\n+    // CHECK-NEXT: ret i64\n+    ptr_offset_from_unsigned(a, b)\n+}"}, {"sha": "ace6c5b85add7fe3f75d2a8cb57c05761fce0786", "filename": "src/test/ui/consts/offset_from.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n #![feature(const_ptr_offset_from)]\n+#![feature(ptr_unsigned_offset_from)]\n \n struct Struct {\n     field: (),\n@@ -43,9 +44,16 @@ pub const OFFSET_EQUAL_INTS: isize = {\n     unsafe { ptr.offset_from(ptr) }\n };\n \n+pub const OFFSET_UNSIGNED: usize = {\n+    let a = ['a', 'b', 'c'];\n+    let ptr = a.as_ptr();\n+    unsafe { ptr.add(2).unsigned_offset_from(ptr) }\n+};\n+\n fn main() {\n     assert_eq!(OFFSET, 0);\n     assert_eq!(OFFSET_2, 1);\n     assert_eq!(OVERFLOW, -1);\n     assert_eq!(OFFSET_EQUAL_INTS, 0);\n+    assert_eq!(OFFSET_UNSIGNED, 2);\n }"}, {"sha": "f604f57e39d98d41d1b736e9c9bb64c528f48058", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -1,7 +1,7 @@\n #![feature(const_ptr_offset_from)]\n #![feature(core_intrinsics)]\n \n-use std::intrinsics::ptr_offset_from;\n+use std::intrinsics::{ptr_offset_from, ptr_offset_from_unsigned};\n \n #[repr(C)]\n struct Struct {\n@@ -15,7 +15,7 @@ pub const DIFFERENT_ALLOC: usize = {\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n-    //~| cannot compute offset of pointers into different allocations.\n+    //~| ptr_offset_from cannot compute offset of pointers into different allocations.\n     offset as usize\n };\n \n@@ -70,4 +70,21 @@ const OUT_OF_BOUNDS_SAME: isize = {\n     //~| pointer at offset 10 is out-of-bounds\n };\n \n+pub const DIFFERENT_ALLOC_UNSIGNED: usize = {\n+    let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+    let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+    let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n+    let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n+    let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n+    //~| ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+    offset as usize\n+};\n+\n+const WRONG_ORDER_UNSIGNED: usize = {\n+    let a = ['a', 'b', 'c'];\n+    let p = a.as_ptr();\n+    unsafe { ptr_offset_from_unsigned(p, p.add(2) ) } //~ERROR evaluation of constant value failed\n+    //~| cannot compute a negative offset, but 0 < 8\n+};\n+\n fn main() {}"}, {"sha": "4c98fd72cacc3ba2ba96fa265f970a1b51bc3d0b", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89a18cb60053a6c1b3b5f817246ddfd917be1e3e/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=89a18cb60053a6c1b3b5f817246ddfd917be1e3e", "patch": "@@ -54,6 +54,18 @@ error[E0080]: evaluation of constant value failed\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc26 has size 4, so pointer at offset 10 is out-of-bounds\n \n-error: aborting due to 8 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:78:27\n+   |\n+LL |     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) };\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:86:14\n+   |\n+LL |     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned cannot compute a negative offset, but 0 < 8\n+\n+error: aborting due to 10 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}