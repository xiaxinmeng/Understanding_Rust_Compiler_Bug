{"sha": "6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "node_id": "C_kwDOAAsO6NoAKDZmNDUxZmNhMGRjN2Y5YWI5ZjM0MWZiNTI5Zjg2MWZhZmQyMDViMmY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-09T09:01:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-09T09:01:43Z"}, "message": "Merge from rustc", "tree": {"sha": "b8308e42c6a378ff7d5a4978cc3cfb5a7a34dc25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8308e42c6a378ff7d5a4978cc3cfb5a7a34dc25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "html_url": "https://github.com/rust-lang/rust/commit/6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "185156280f8e952a864c5f4f4c4daa03bc04d46c", "url": "https://api.github.com/repos/rust-lang/rust/commits/185156280f8e952a864c5f4f4c4daa03bc04d46c", "html_url": "https://github.com/rust-lang/rust/commit/185156280f8e952a864c5f4f4c4daa03bc04d46c"}, {"sha": "77c85e9cba0c3f8b185c63f013cca1350b2e5492", "url": "https://api.github.com/repos/rust-lang/rust/commits/77c85e9cba0c3f8b185c63f013cca1350b2e5492", "html_url": "https://github.com/rust-lang/rust/commit/77c85e9cba0c3f8b185c63f013cca1350b2e5492"}], "stats": {"total": 3515, "additions": 2224, "deletions": 1291}, "files": [{"sha": "7bec05cc575a875239d1ba10cc269c7827e68ada", "filename": ".github/ISSUE_TEMPLATE/ice.yaml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/.github%2FISSUE_TEMPLATE%2Fice.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/.github%2FISSUE_TEMPLATE%2Fice.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.yaml?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,4 +1,4 @@\n-name: Internal Compiler Error (Structured form)\n+name: Internal Compiler Error (for use by automated tooling)\n description: For now, you'll want to use the other ICE template, as GitHub forms have strict limits on the size of fields so backtraces cannot be pasted directly.\n labels: [\"C-bug\", \"I-ICE\", \"T-compiler\"]\n title: \"[ICE]: \""}, {"sha": "b51105750c82cc9aa428298d520959ab20071409", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -60,9 +60,8 @@ jobs:\n             env: {}\n           - name: x86_64-gnu-tools\n             tidy: false\n-            env:\n-              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n             os: ubuntu-20.04-xl\n+            env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:"}, {"sha": "ad01ef5e41f162a918ad976df5ec3beb88a80c13", "filename": "Cargo.lock", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -127,6 +127,12 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8f8cb5d814eb646a863c4f24978cff2880c4be96ad8cde2c0f0678732902e271\"\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b\"\n+\n [[package]]\n name = \"arrayvec\"\n version = \"0.7.0\"\n@@ -407,7 +413,7 @@ dependencies = [\n  \"unicode-xid\",\n  \"url\",\n  \"walkdir\",\n- \"winapi\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -436,7 +442,7 @@ name = \"cargo-credential-wincred\"\n version = \"0.2.0\"\n dependencies = [\n  \"cargo-credential\",\n- \"winapi\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -496,7 +502,7 @@ dependencies = [\n  \"time 0.3.17\",\n  \"toml_edit\",\n  \"url\",\n- \"winapi\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -516,7 +522,7 @@ dependencies = [\n  \"shell-escape\",\n  \"tempfile\",\n  \"walkdir\",\n- \"winapi\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -791,7 +797,7 @@ dependencies = [\n name = \"clippy_utils\"\n version = \"0.1.69\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"if_chain\",\n  \"itertools\",\n  \"rustc-semver\",\n@@ -2217,7 +2223,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"46112a93252b123d31a119a8d1a1ac19deac4fac6e0e8b0df58f0d4e5870e63c\"\n dependencies = [\n  \"libc\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -2229,7 +2235,7 @@ dependencies = [\n  \"hermit-abi 0.2.6\",\n  \"io-lifetimes\",\n  \"rustix\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -2670,7 +2676,7 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"52ffbca2f655e33c08be35d87278e5b18b89550a37dbd598c20db92f6a471123\"\n dependencies = [\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -2987,7 +2993,7 @@ dependencies = [\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -3912,7 +3918,7 @@ dependencies = [\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"bitflags\",\n  \"cfg-if\",\n  \"ena\",\n@@ -4169,7 +4175,7 @@ dependencies = [\n name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"smallvec\",\n@@ -4866,7 +4872,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.7.0\",\n  \"askama\",\n  \"expect-test\",\n  \"itertools\",\n@@ -4969,7 +4975,7 @@ dependencies = [\n  \"io-lifetimes\",\n  \"libc\",\n  \"linux-raw-sys\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -5375,9 +5381,9 @@ dependencies = [\n \n [[package]]\n name = \"strip-ansi-escapes\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9d63676e2abafa709460982ddc02a3bb586b6d15a49b75c212e06edd3933acee\"\n+checksum = \"011cbb39cf7c1f62871aea3cc46e5817b0937b49e9447370c93cacbe93a766d8\"\n dependencies = [\n  \"vte\",\n ]\n@@ -5499,7 +5505,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cb20089a8ba2b69debd491f8d2d023761cbf196e999218c591fa1e7e15a21907\"\n dependencies = [\n  \"rustix\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -6089,9 +6095,9 @@ checksum = \"05e42f7c18b8f902290b009cde6d651262f956c98bc51bca4cd1d511c9cd85c7\"\n \n [[package]]\n name = \"utf8parse\"\n-version = \"0.1.1\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n+checksum = \"936e4b492acfd135421d8dca4b1aa80a7bfc26e702ef3af710e0752684df5372\"\n \n [[package]]\n name = \"uuid\"\n@@ -6122,11 +6128,23 @@ checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"vte\"\n-version = \"0.3.3\"\n+version = \"0.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f42f536e22f7fcbb407639765c8fd78707a33109301f834a594758bedd6e8cf\"\n+checksum = \"6cbce692ab4ca2f1f3047fcf732430249c0e971bfdd2b234cf2c47ad93af5983\"\n dependencies = [\n+ \"arrayvec 0.5.2\",\n  \"utf8parse\",\n+ \"vte_generate_state_changes\",\n+]\n+\n+[[package]]\n+name = \"vte_generate_state_changes\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d257817081c7dffcdbab24b9e62d2def62e2ff7d00b1c20062551e6cccc145ff\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n ]\n \n [[package]]\n@@ -6251,47 +6269,71 @@ dependencies = [\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.45.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"windows-targets\"\n+version = \"0.42.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8e2522491fbfcd58cc84d47aeb2958948c4b8982e9a2d8a2a35bbaed431390e7\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+checksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n+checksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n+checksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n+checksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+checksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n+checksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+checksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\"\n \n [[package]]\n name = \"writeable\""}, {"sha": "cd621bc67a1de9328e4fec0d2ebc27fa721df944", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1567,8 +1567,18 @@ impl<'a> State<'a> {\n \n             match bound {\n                 GenericBound::Trait(tref, modifier) => {\n-                    if modifier == &TraitBoundModifier::Maybe {\n-                        self.word(\"?\");\n+                    match modifier {\n+                        TraitBoundModifier::None => {}\n+                        TraitBoundModifier::Maybe => {\n+                            self.word(\"?\");\n+                        }\n+                        TraitBoundModifier::MaybeConst => {\n+                            self.word_space(\"~const\");\n+                        }\n+                        TraitBoundModifier::MaybeConstMaybe => {\n+                            self.word_space(\"~const\");\n+                            self.word(\"?\");\n+                        }\n                     }\n                     self.print_poly_trait_ref(tref);\n                 }"}, {"sha": "7b07c2a463371d531fa5ee6c3569492cacd2cd49", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -803,6 +803,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 predicates\n                     .iter()\n                     .map(|(param, constraint)| (param.name.as_str(), &**constraint, None)),\n+                None,\n             );\n         }\n     }"}, {"sha": "3006e27e1d5b53882bfaa8528bcee7b4f8ab849b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1139,7 +1139,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         if let ty::Adt(def, substs) = ty.kind()\n                             && Some(def.did()) == tcx.lang_items().pin_type()\n                             && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()\n-                            && let self_ty = infcx.replace_bound_vars_with_fresh_vars(\n+                            && let self_ty = infcx.instantiate_binder_with_fresh_vars(\n                                 fn_call_span,\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),"}, {"sha": "1dc6c42fbf78ea3a4b60f27ec9370de3bcad73d2", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -83,16 +83,8 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n         self.constraints.member_constraints = tmp;\n \n-        for (predicate, constraint_category) in outlives {\n-            // At the moment, we never generate any \"higher-ranked\"\n-            // region constraints like `for<'a> 'a: 'b`. At some point\n-            // when we move to universes, we will, and this assertion\n-            // will start to fail.\n-            let predicate = predicate.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", predicate,);\n-            });\n-\n-            self.convert(predicate, *constraint_category);\n+        for &(predicate, constraint_category) in outlives {\n+            self.convert(predicate, constraint_category);\n         }\n     }\n "}, {"sha": "c6b78df9a5ff033db5671483da5f41c53ae772c0", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // so that they represent the view from \"inside\" the closure.\n         let user_provided_sig = self\n             .instantiate_canonical_with_fresh_inference_vars(body.span, &user_provided_poly_sig);\n-        let user_provided_sig = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let user_provided_sig = self.infcx.instantiate_binder_with_fresh_vars(\n             body.span,\n             LateBoundRegionConversionTime::FnCall,\n             user_provided_sig,"}, {"sha": "e8a353b1c8fcc61474ad64cb001971ede5a5b67a", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -153,7 +153,10 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         let path_debug = cx.path_global(span, cx.std_path(&[sym::fmt, sym::Debug]));\n         let ty_dyn_debug = cx.ty(\n             span,\n-            ast::TyKind::TraitObject(vec![cx.trait_bound(path_debug)], ast::TraitObjectSyntax::Dyn),\n+            ast::TyKind::TraitObject(\n+                vec![cx.trait_bound(path_debug, false)],\n+                ast::TraitObjectSyntax::Dyn,\n+            ),\n         );\n         let ty_slice = cx.ty(\n             span,"}, {"sha": "970b9115d8d79639aa232db382c0936dbad366e9", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -605,18 +605,26 @@ impl<'a> TraitDef<'a> {\n                     let bounds: Vec<_> = self\n                         .additional_bounds\n                         .iter()\n-                        .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                        .map(|p| {\n+                            cx.trait_bound(\n+                                p.to_path(cx, self.span, type_ident, generics),\n+                                self.is_const,\n+                            )\n+                        })\n                         .chain(\n                             // Add a bound for the current trait.\n                             self.skip_path_as_bound\n                                 .not()\n-                                .then(|| cx.trait_bound(trait_path.clone())),\n+                                .then(|| cx.trait_bound(trait_path.clone(), self.is_const)),\n                         )\n                         .chain({\n                             // Add a `Copy` bound if required.\n                             if is_packed && self.needs_copy_as_bound_if_packed {\n                                 let p = deriving::path_std!(marker::Copy);\n-                                Some(cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                                Some(cx.trait_bound(\n+                                    p.to_path(cx, self.span, type_ident, generics),\n+                                    self.is_const,\n+                                ))\n                             } else {\n                                 None\n                             }\n@@ -694,18 +702,24 @@ impl<'a> TraitDef<'a> {\n                         let mut bounds: Vec<_> = self\n                             .additional_bounds\n                             .iter()\n-                            .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                            .map(|p| {\n+                                cx.trait_bound(\n+                                    p.to_path(cx, self.span, type_ident, generics),\n+                                    self.is_const,\n+                                )\n+                            })\n                             .collect();\n \n                         // Require the current trait.\n-                        bounds.push(cx.trait_bound(trait_path.clone()));\n+                        bounds.push(cx.trait_bound(trait_path.clone(), self.is_const));\n \n                         // Add a `Copy` bound if required.\n                         if is_packed && self.needs_copy_as_bound_if_packed {\n                             let p = deriving::path_std!(marker::Copy);\n-                            bounds.push(\n-                                cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)),\n-                            );\n+                            bounds.push(cx.trait_bound(\n+                                p.to_path(cx, self.span, type_ident, generics),\n+                                self.is_const,\n+                            ));\n                         }\n \n                         let predicate = ast::WhereBoundPredicate {\n@@ -1543,31 +1557,46 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    // In general, fields in packed structs are copied via a\n-                    // block, e.g. `&{self.0}`. The one exception is `[u8]`\n-                    // fields, which cannot be copied and also never cause\n-                    // unaligned references. This exception is allowed to\n-                    // handle the `FlexZeroSlice` type in the `zerovec` crate\n-                    // within `icu4x-0.9.0`.\n-                    //\n-                    // Once use of `icu4x-0.9.0` has dropped sufficiently, this\n-                    // exception should be removed.\n-                    let is_u8_slice = if let TyKind::Slice(ty) = &struct_field.ty.kind &&\n-                        let TyKind::Path(None, rustc_ast::Path { segments, .. }) = &ty.kind &&\n-                        let [seg] = segments.as_slice() &&\n-                        seg.ident.name == sym::u8 && seg.args.is_none()\n-                    {\n-                        true\n-                    } else {\n-                        false\n-                    };\n                     if is_packed {\n-                        if is_u8_slice {\n+                        // In general, fields in packed structs are copied via a\n+                        // block, e.g. `&{self.0}`. The two exceptions are `[u8]`\n+                        // and `str` fields, which cannot be copied and also never\n+                        // cause unaligned references. These exceptions are allowed\n+                        // to handle the `FlexZeroSlice` type in the `zerovec`\n+                        // crate within `icu4x-0.9.0`.\n+                        //\n+                        // Once use of `icu4x-0.9.0` has dropped sufficiently, this\n+                        // exception should be removed.\n+                        let is_simple_path = |ty: &P<ast::Ty>, sym| {\n+                            if let TyKind::Path(None, ast::Path { segments, .. }) = &ty.kind &&\n+                                let [seg] = segments.as_slice() &&\n+                                seg.ident.name == sym && seg.args.is_none()\n+                            {\n+                                true\n+                            } else {\n+                                false\n+                            }\n+                        };\n+\n+                        let exception = if let TyKind::Slice(ty) = &struct_field.ty.kind &&\n+                            is_simple_path(ty, sym::u8)\n+                        {\n+                            Some(\"byte\")\n+                        } else if is_simple_path(&struct_field.ty, sym::str) {\n+                            Some(\"string\")\n+                        } else {\n+                            None\n+                        };\n+\n+                        if let Some(ty) = exception {\n                             cx.sess.parse_sess.buffer_lint_with_diagnostic(\n                                 BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n                                 sp,\n                                 ast::CRATE_NODE_ID,\n-                                \"byte slice in a packed struct that derives a built-in trait\",\n+                                &format!(\n+                                    \"{} slice in a packed struct that derives a built-in trait\",\n+                                    ty\n+                                ),\n                                 rustc_lint_defs::BuiltinLintDiagnostics::ByteSliceInPackedStructWithDerive\n                             );\n                         } else {"}, {"sha": "aabd5b1f773f70baa3691862eb4a190f8068a8fb", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -154,7 +154,7 @@ fn mk_ty_param(\n         .iter()\n         .map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n-            cx.trait_bound(path)\n+            cx.trait_bound(path, false)\n         })\n         .collect();\n     cx.typaram(span, Ident::new(name, span), bounds, None)"}, {"sha": "fc8e0c67ae09a0ec4b8d22aa8c9d5c9608a27854", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -126,7 +126,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let vtable = self.get_vtable_ptr(src.layout.ty, data.principal())?;\n                     let vtable = Scalar::from_maybe_pointer(vtable, self);\n                     let data = self.read_immediate(src)?.to_scalar();\n-                    let _assert_pointer_sized = data.to_pointer(self)?;\n+                    let _assert_pointer_like = data.to_pointer(self)?;\n                     let val = Immediate::ScalarPair(data, vtable);\n                     self.write_immediate(val, dest)?;\n                 } else {"}, {"sha": "5042c6bac9932dcfd4821aa3e273c14fab373b7d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -78,13 +78,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         col: u32,\n     ) -> MPlaceTy<'tcx, M::Provenance> {\n         let loc_details = &self.tcx.sess.opts.unstable_opts.location_detail;\n+        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n+        // pointless, since that would require allocating more memory than these short strings.\n         let file = if loc_details.file {\n             self.allocate_str(filename.as_str(), MemoryKind::CallerLocation, Mutability::Not)\n+                .unwrap()\n         } else {\n             // FIXME: This creates a new allocation each time. It might be preferable to\n             // perform this allocation only once, and re-use the `MPlaceTy`.\n             // See https://github.com/rust-lang/rust/pull/89920#discussion_r730012398\n-            self.allocate_str(\"<redacted>\", MemoryKind::CallerLocation, Mutability::Not)\n+            self.allocate_str(\"<redacted>\", MemoryKind::CallerLocation, Mutability::Not).unwrap()\n         };\n         let line = if loc_details.line { Scalar::from_u32(line) } else { Scalar::from_u32(0) };\n         let col = if loc_details.column { Scalar::from_u32(col) } else { Scalar::from_u32(0) };\n@@ -95,8 +98,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .bound_type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n             .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n-        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n-        // pointless, since that would require allocating more memory than a Location.\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n \n         // Initialize fields."}, {"sha": "d8087a36a7c6abfb48240319148c8e68e2bf3917", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -291,7 +291,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn adjust_alloc_base_pointer(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer,\n-    ) -> Pointer<Self::Provenance>;\n+    ) -> InterpResult<'tcx, Pointer<Self::Provenance>>;\n \n     /// \"Int-to-pointer cast\"\n     fn ptr_from_addr_cast(\n@@ -505,8 +505,8 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     fn adjust_alloc_base_pointer(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<AllocId> {\n-        ptr\n+    ) -> InterpResult<$tcx, Pointer<AllocId>> {\n+        Ok(ptr)\n     }\n \n     #[inline(always)]"}, {"sha": "cfad930b1e52ec6ca1174e7700b5e3135fbcdf80", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => {}\n         }\n         // And we need to get the provenance.\n-        Ok(M::adjust_alloc_base_pointer(self, ptr))\n+        M::adjust_alloc_base_pointer(self, ptr)\n     }\n \n     pub fn create_fn_alloc_ptr(\n@@ -200,8 +200,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        // We can `unwrap` since `alloc` contains no pointers.\n-        Ok(self.allocate_raw_ptr(alloc, kind).unwrap())\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n     pub fn allocate_bytes_ptr(\n@@ -210,10 +209,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n         mutability: Mutability,\n-    ) -> Pointer<M::Provenance> {\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        // We can `unwrap` since `alloc` contains no pointers.\n-        self.allocate_raw_ptr(alloc, kind).unwrap()\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n     /// This can fail only of `alloc` contains provenance.\n@@ -230,7 +228,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         );\n         let alloc = M::adjust_allocation(self, id, Cow::Owned(alloc), Some(kind))?;\n         self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        Ok(M::adjust_alloc_base_pointer(self, Pointer::from(id)))\n+        M::adjust_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n     pub fn reallocate_ptr("}, {"sha": "038282e2161e6637891d2cde59fe2e766e40b189", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -754,8 +754,8 @@ where\n         str: &str,\n         kind: MemoryKind<M::MemoryKind>,\n         mutbl: Mutability,\n-    ) -> MPlaceTy<'tcx, M::Provenance> {\n-        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n+        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl)?;\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n \n@@ -764,7 +764,7 @@ where\n             ty::TypeAndMut { ty: self.tcx.types.str_, mutbl },\n         );\n         let layout = self.layout_of(ty).unwrap();\n-        MPlaceTy { mplace, layout, align: layout.align.abi }\n+        Ok(MPlaceTy { mplace, layout, align: layout.align.abi })\n     }\n \n     /// Writes the aggregate to the destination."}, {"sha": "3e416b89ca6ea5a417821cc3468ef09eb4155b57", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -136,6 +136,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                             &param_ty.name.as_str(),\n                             &constraint,\n                             None,\n+                            None,\n                         );\n                     }\n                 }"}, {"sha": "7fab8954cb19f1911ff8654061770315bbf0e0a7", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -11,6 +11,7 @@\n #![feature(associated_type_bounds)]\n #![feature(auto_traits)]\n #![feature(cell_leak)]\n+#![feature(core_intrinsics)]\n #![feature(extend_one)]\n #![feature(hash_raw_entry)]\n #![feature(hasher_prefixfree_extras)]"}, {"sha": "3aca03f6e5c63cbae99bda4e58c09b05cddcf065", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -88,6 +88,7 @@ use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::error::Error;\n use std::fs;\n+use std::intrinsics::unlikely;\n use std::path::Path;\n use std::process;\n use std::sync::Arc;\n@@ -395,11 +396,18 @@ impl SelfProfilerRef {\n     /// Record a query in-memory cache hit.\n     #[inline(always)]\n     pub fn query_cache_hit(&self, query_invocation_id: QueryInvocationId) {\n-        self.instant_query_event(\n-            |profiler| profiler.query_cache_hit_event_kind,\n-            query_invocation_id,\n-            EventFilter::QUERY_CACHE_HITS,\n-        );\n+        #[inline(never)]\n+        #[cold]\n+        fn cold_call(profiler_ref: &SelfProfilerRef, query_invocation_id: QueryInvocationId) {\n+            profiler_ref.instant_query_event(\n+                |profiler| profiler.query_cache_hit_event_kind,\n+                query_invocation_id,\n+            );\n+        }\n+\n+        if unlikely(self.event_filter_mask.contains(EventFilter::QUERY_CACHE_HITS)) {\n+            cold_call(self, query_invocation_id);\n+        }\n     }\n \n     /// Start profiling a query being blocked on a concurrent execution.\n@@ -444,20 +452,15 @@ impl SelfProfilerRef {\n         &self,\n         event_kind: fn(&SelfProfiler) -> StringId,\n         query_invocation_id: QueryInvocationId,\n-        event_filter: EventFilter,\n     ) {\n-        drop(self.exec(event_filter, |profiler| {\n-            let event_id = StringId::new_virtual(query_invocation_id.0);\n-            let thread_id = get_thread_id();\n-\n-            profiler.profiler.record_instant_event(\n-                event_kind(profiler),\n-                EventId::from_virtual(event_id),\n-                thread_id,\n-            );\n-\n-            TimingGuard::none()\n-        }));\n+        let event_id = StringId::new_virtual(query_invocation_id.0);\n+        let thread_id = get_thread_id();\n+        let profiler = self.profiler.as_ref().unwrap();\n+        profiler.profiler.record_instant_event(\n+            event_kind(profiler),\n+            EventId::from_virtual(event_id),\n+            thread_id,\n+        );\n     }\n \n     pub fn with_profiler(&self, f: impl FnOnce(&SelfProfiler)) {"}, {"sha": "bdf2978cee2587f90fd93661ca1d6151965293cd", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -229,10 +229,6 @@ fn run_compiler(\n         registry: diagnostics_registry(),\n     };\n \n-    if !tracing::dispatcher::has_been_set() {\n-        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n-    }\n-\n     match make_input(config.opts.error_format, &matches.free) {\n         Err(reported) => return Err(reported),\n         Ok(Some(input)) => {\n@@ -326,14 +322,16 @@ fn run_compiler(\n                 }\n             }\n \n-            let mut gctxt = queries.global_ctxt()?;\n+            // Make sure name resolution and macro expansion is run.\n+            queries.global_ctxt()?;\n+\n             if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n \n             // Make sure the `output_filenames` query is run for its side\n             // effects of writing the dep-info and reporting errors.\n-            gctxt.enter(|tcx| tcx.output_filenames(()));\n+            queries.global_ctxt()?.enter(|tcx| tcx.output_filenames(()));\n \n             if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n                 && sess.opts.output_types.len() == 1\n@@ -345,7 +343,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            gctxt.enter(|tcx| {\n+            queries.global_ctxt()?.enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n                     let crate_name = tcx.crate_name(LOCAL_CRATE);\n@@ -362,8 +360,6 @@ fn run_compiler(\n                 result\n             })?;\n \n-            drop(gctxt);\n-\n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n@@ -1200,11 +1196,9 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     if !info.payload().is::<rustc_errors::ExplicitBug>()\n         && !info.payload().is::<rustc_errors::DelayedBugPanic>()\n     {\n-        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n-        handler.emit_diagnostic(&mut d);\n+        handler.emit_err(session_diagnostics::Ice);\n     }\n \n-    handler.emit_note(session_diagnostics::Ice);\n     handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n     handler.emit_note(session_diagnostics::IceVersion {\n         version: util::version_str!().unwrap_or(\"unknown_version\"),\n@@ -1253,16 +1247,7 @@ pub fn install_ice_hook() {\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// tracing crate version.\n pub fn init_rustc_env_logger() {\n-    init_rustc_env_logger_with_backtrace_option(&None);\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n-/// choose a target module you wish to show backtraces along with its logging.\n-pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n-    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n-        early_error(ErrorOutputType::default(), &error.to_string());\n-    }\n+    init_env_logger(\"RUSTC_LOG\");\n }\n \n /// This allows tools to enable rust logging without having to magically match rustc's\n@@ -1326,6 +1311,7 @@ mod signal_handler {\n pub fn main() -> ! {\n     let start_time = Instant::now();\n     let start_rss = get_resident_set_size();\n+    init_rustc_env_logger();\n     signal_handler::install();\n     let mut callbacks = TimePassesCallbacks::default();\n     install_ice_hook();"}, {"sha": "800f3c521778d756f86b6c5e08f00dc76b2f1ada", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -286,6 +286,7 @@ E0519: include_str!(\"./error_codes/E0519.md\"),\n E0520: include_str!(\"./error_codes/E0520.md\"),\n E0521: include_str!(\"./error_codes/E0521.md\"),\n E0522: include_str!(\"./error_codes/E0522.md\"),\n+E0523: include_str!(\"./error_codes/E0523.md\"),\n E0524: include_str!(\"./error_codes/E0524.md\"),\n E0525: include_str!(\"./error_codes/E0525.md\"),\n E0527: include_str!(\"./error_codes/E0527.md\"),\n@@ -622,7 +623,6 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0488, // lifetime of variable does not enclose its declaration\n //  E0489, // type/lifetime parameter not in scope here\n //  E0490, // removed: unreachable\n-    E0523, // two dependencies have same (crate-name, disambiguator) but different SVH\n //  E0526, // shuffle indices are not constant\n //  E0540, // multiple rustc_deprecated attributes\n //  E0548, // replaced with a generic attribute input check"}, {"sha": "209cbb00db562f3daa36e38d79b58e70c938828f", "filename": "compiler/rustc_error_codes/src/error_codes/E0464.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0464.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0464.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0464.md?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,6 +1,21 @@\n The compiler found multiple library files with the requested crate name.\n \n+```compile_fail\n+// aux-build:crateresolve-1.rs\n+// aux-build:crateresolve-2.rs\n+// aux-build:crateresolve-3.rs\n+\n+extern crate crateresolve;\n+//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found\n+\n+fn main() {}\n+```\n+\n This error can occur in several different cases -- for example, when using\n `extern crate` or passing `--extern` options without crate paths. It can also be\n caused by caching issues with the build directory, in which case `cargo clean`\n may help.\n+\n+In the above example, there are three different library files, all of which\n+define the same crate name. Without providing a full path, there is no way for\n+the compiler to know which crate it should use."}, {"sha": "0ddf70386c28d847523bbe042b56f684c7a4d95f", "filename": "compiler/rustc_error_codes/src/error_codes/E0523.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0523.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0523.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0523.md?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,25 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+The compiler found multiple library files with the requested crate name.\n+\n+```compile_fail\n+// aux-build:crateresolve-1.rs\n+// aux-build:crateresolve-2.rs\n+// aux-build:crateresolve-3.rs\n+\n+extern crate crateresolve;\n+//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found\n+\n+fn main() {}\n+```\n+\n+This error can occur in several different cases -- for example, when using\n+`extern crate` or passing `--extern` options without crate paths. It can also be\n+caused by caching issues with the build directory, in which case `cargo clean`\n+may help.\n+\n+In the above example, there are three different library files, all of which\n+define the same crate name. Without providing a full path, there is no way for\n+the compiler to know which crate it should use.\n+\n+*Note that E0523 has been merged into E0464.*"}, {"sha": "9768526a2f47d52088fc500e6643b7efad8eca8e", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 57, "deletions": 38, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1882,9 +1882,8 @@ impl EmitterWriter {\n                             &mut buffer,\n                             &mut row_num,\n                             &Vec::new(),\n-                            p,\n+                            p + line_start,\n                             l,\n-                            line_start,\n                             show_code_change,\n                             max_line_num_len,\n                             &file_lines,\n@@ -1907,9 +1906,8 @@ impl EmitterWriter {\n                                 &mut buffer,\n                                 &mut row_num,\n                                 &Vec::new(),\n-                                p,\n+                                p + line_start,\n                                 l,\n-                                line_start,\n                                 show_code_change,\n                                 max_line_num_len,\n                                 &file_lines,\n@@ -1925,9 +1923,8 @@ impl EmitterWriter {\n                                 &mut buffer,\n                                 &mut row_num,\n                                 &Vec::new(),\n-                                p,\n+                                p + line_start,\n                                 l,\n-                                line_start,\n                                 show_code_change,\n                                 max_line_num_len,\n                                 &file_lines,\n@@ -1941,9 +1938,8 @@ impl EmitterWriter {\n                     &mut buffer,\n                     &mut row_num,\n                     highlight_parts,\n-                    line_pos,\n+                    line_pos + line_start,\n                     line,\n-                    line_start,\n                     show_code_change,\n                     max_line_num_len,\n                     &file_lines,\n@@ -2167,40 +2163,63 @@ impl EmitterWriter {\n         buffer: &mut StyledBuffer,\n         row_num: &mut usize,\n         highlight_parts: &Vec<SubstitutionHighlight>,\n-        line_pos: usize,\n-        line: &str,\n-        line_start: usize,\n+        line_num: usize,\n+        line_to_add: &str,\n         show_code_change: DisplaySuggestion,\n         max_line_num_len: usize,\n         file_lines: &FileLines,\n         is_multiline: bool,\n     ) {\n-        // Print the span column to avoid confusion\n-        buffer.puts(*row_num, 0, &self.maybe_anonymized(line_start + line_pos), Style::LineNumber);\n         if let DisplaySuggestion::Diff = show_code_change {\n-            // Add the line number for both addition and removal to drive the point home.\n-            //\n-            // N - fn foo<A: T>(bar: A) {\n-            // N + fn foo(bar: impl T) {\n-            buffer.puts(\n-                *row_num - 1,\n-                0,\n-                &self.maybe_anonymized(line_start + line_pos),\n-                Style::LineNumber,\n-            );\n-            buffer.puts(*row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n-            buffer.puts(\n-                *row_num - 1,\n-                max_line_num_len + 3,\n-                &normalize_whitespace(\n-                    &file_lines.file.get_line(file_lines.lines[line_pos].line_index).unwrap(),\n-                ),\n-                Style::NoStyle,\n-            );\n-            buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+            // We need to print more than one line if the span we need to remove is multiline.\n+            // For more info: https://github.com/rust-lang/rust/issues/92741\n+            let lines_to_remove = file_lines.lines.iter().take(file_lines.lines.len() - 1);\n+            for (index, line_to_remove) in lines_to_remove.enumerate() {\n+                buffer.puts(\n+                    *row_num - 1,\n+                    0,\n+                    &self.maybe_anonymized(line_num + index),\n+                    Style::LineNumber,\n+                );\n+                buffer.puts(*row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n+                let line = normalize_whitespace(\n+                    &file_lines.file.get_line(line_to_remove.line_index).unwrap(),\n+                );\n+                buffer.puts(*row_num - 1, max_line_num_len + 3, &line, Style::NoStyle);\n+                *row_num += 1;\n+            }\n+            // If the last line is exactly equal to the line we need to add, we can skip both of them.\n+            // This allows us to avoid output like the following:\n+            // 2 - &\n+            // 2 + if true { true } else { false }\n+            // 3 - if true { true } else { false }\n+            // If those lines aren't equal, we print their diff\n+            let last_line_index = file_lines.lines[file_lines.lines.len() - 1].line_index;\n+            let last_line = &file_lines.file.get_line(last_line_index).unwrap();\n+            if last_line != line_to_add {\n+                buffer.puts(\n+                    *row_num - 1,\n+                    0,\n+                    &self.maybe_anonymized(line_num + file_lines.lines.len() - 1),\n+                    Style::LineNumber,\n+                );\n+                buffer.puts(*row_num - 1, max_line_num_len + 1, \"- \", Style::Removal);\n+                buffer.puts(\n+                    *row_num - 1,\n+                    max_line_num_len + 3,\n+                    &normalize_whitespace(last_line),\n+                    Style::NoStyle,\n+                );\n+                buffer.puts(*row_num, 0, &self.maybe_anonymized(line_num), Style::LineNumber);\n+                buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n+                buffer.append(*row_num, &normalize_whitespace(line_to_add), Style::NoStyle);\n+            } else {\n+                *row_num -= 2;\n+            }\n         } else if is_multiline {\n+            buffer.puts(*row_num, 0, &self.maybe_anonymized(line_num), Style::LineNumber);\n             match &highlight_parts[..] {\n-                [SubstitutionHighlight { start: 0, end }] if *end == line.len() => {\n+                [SubstitutionHighlight { start: 0, end }] if *end == line_to_add.len() => {\n                     buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n                 }\n                 [] => {\n@@ -2210,17 +2229,17 @@ impl EmitterWriter {\n                     buffer.puts(*row_num, max_line_num_len + 1, \"~ \", Style::Addition);\n                 }\n             }\n+            buffer.append(*row_num, &normalize_whitespace(line_to_add), Style::NoStyle);\n         } else {\n+            buffer.puts(*row_num, 0, &self.maybe_anonymized(line_num), Style::LineNumber);\n             draw_col_separator(buffer, *row_num, max_line_num_len + 1);\n+            buffer.append(*row_num, &normalize_whitespace(line_to_add), Style::NoStyle);\n         }\n \n-        // print the suggestion\n-        buffer.append(*row_num, &normalize_whitespace(line), Style::NoStyle);\n-\n         // Colorize addition/replacements with green.\n         for &SubstitutionHighlight { start, end } in highlight_parts {\n             // Account for tabs when highlighting (#87972).\n-            let tabs: usize = line\n+            let tabs: usize = line_to_add\n                 .chars()\n                 .take(start)\n                 .map(|ch| match ch {"}, {"sha": "b4c12651e7a2d36e7011fac4664f36d63f695c05", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -131,10 +131,14 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn trait_bound(&self, path: ast::Path) -> ast::GenericBound {\n+    pub fn trait_bound(&self, path: ast::Path, is_const: bool) -> ast::GenericBound {\n         ast::GenericBound::Trait(\n             self.poly_trait_ref(path.span, path),\n-            ast::TraitBoundModifier::None,\n+            if is_const {\n+                ast::TraitBoundModifier::MaybeConst\n+            } else {\n+                ast::TraitBoundModifier::None\n+            },\n         )\n     }\n "}, {"sha": "0454633091568ea61c5de649f85d8b206d79b019", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -287,7 +287,7 @@ language_item_table! {\n     TryTraitBranch,          sym::branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n     TryTraitFromYeet,        sym::from_yeet,           from_yeet_fn,               Target::Fn,             GenericRequirement::None;\n \n-    PointerSized,            sym::pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n+    PointerLike,             sym::pointer_like,        pointer_like,               Target::Trait,          GenericRequirement::Exact(0);\n \n     Poll,                    sym::Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n     PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;"}, {"sha": "236e36f28ca474e5261a54a0b2565149811179d6", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -246,7 +246,7 @@ fn compare_method_predicate_entailment<'tcx>(\n \n     let mut wf_tys = FxIndexSet::default();\n \n-    let unnormalized_impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n+    let unnormalized_impl_sig = infcx.instantiate_binder_with_fresh_vars(\n         impl_m_span,\n         infer::HigherRankedType,\n         tcx.fn_sig(impl_m.def_id).subst_identity(),\n@@ -640,7 +640,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let impl_sig = ocx.normalize(\n         &norm_cause,\n         param_env,\n-        infcx.replace_bound_vars_with_fresh_vars(\n+        infcx.instantiate_binder_with_fresh_vars(\n             return_span,\n             infer::HigherRankedType,\n             tcx.fn_sig(impl_m.def_id).subst_identity(),"}, {"sha": "8c2423e3ca0d1f78f9c8847a73171c6fe7b1a207", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -176,6 +176,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 bounds.iter().map(|(param, constraint, def_id)| {\n                     (param.as_str(), constraint.as_str(), *def_id)\n                 }),\n+                None,\n             );\n             err.emit();\n         }"}, {"sha": "089863a66e73be9843af6ea4a5f42098aeb81edf", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(substs).is_none() {\n                     let closure_sig = substs.as_closure().sig();\n-                    let closure_sig = self.replace_bound_vars_with_fresh_vars(\n+                    let closure_sig = self.instantiate_binder_with_fresh_vars(\n                         call_expr.span,\n                         infer::FnCall,\n                         closure_sig,\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // renormalize the associated types at this point, since they\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n-        let fn_sig = self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig);\n+        let fn_sig = self.instantiate_binder_with_fresh_vars(call_expr.span, infer::FnCall, fn_sig);\n         let fn_sig = self.normalize(call_expr.span, fn_sig);\n \n         // Call the generic checker."}, {"sha": "211fe477a2d8d77bd77890602796e55bfe103a80", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             )\n             .map(|(hir_ty, &supplied_ty)| {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                self.replace_bound_vars_with_fresh_vars(\n+                self.instantiate_binder_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     // (*) binder moved to here\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.extend(obligations);\n             }\n \n-            let supplied_output_ty = self.replace_bound_vars_with_fresh_vars(\n+            let supplied_output_ty = self.instantiate_binder_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n                 supplied_sig.output(),"}, {"sha": "7173239ba619a849b0e71a46e49ed3395dde162e", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -765,7 +765,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             self.cause.clone(),\n             self.param_env,\n             ty::Binder::dummy(\n-                self.tcx.at(self.cause.span).mk_trait_ref(hir::LangItem::PointerSized, [a]),\n+                self.tcx.at(self.cause.span).mk_trait_ref(hir::LangItem::PointerLike, [a]),\n             ),\n         ));\n "}, {"sha": "bb235a4836153aedb9883677474e83942bdda263", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // placeholder lifetimes with probing, we just replace higher lifetimes\n                     // with fresh vars.\n                     let span = args.get(i).map(|a| a.span).unwrap_or(expr.span);\n-                    let input = self.replace_bound_vars_with_fresh_vars(\n+                    let input = self.instantiate_binder_with_fresh_vars(\n                         span,\n                         infer::LateBoundRegionConversionTime::FnCall,\n                         fn_sig.input(i),\n@@ -586,7 +586,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Also, as we just want to check sizedness, instead of introducing\n             // placeholder lifetimes with probing, we just replace higher lifetimes\n             // with fresh vars.\n-            let output = self.replace_bound_vars_with_fresh_vars(\n+            let output = self.instantiate_binder_with_fresh_vars(\n                 expr.span,\n                 infer::LateBoundRegionConversionTime::FnCall,\n                 fn_sig.output(),"}, {"sha": "db1acb599271696008ec0143c1f68a587ddf173f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 373, "deletions": 1, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,10 +1,382 @@\n use crate::FnCtxt;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::traits::ObligationCauseCode;\n+use rustc_middle::ty::{self, DefIdTree, Ty, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_span::{self, Span};\n use rustc_trait_selection::traits;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn adjust_fulfillment_error_for_expr_obligation(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+    ) -> bool {\n+        let (traits::ExprItemObligation(def_id, hir_id, idx) | traits::ExprBindingObligation(def_id, _, hir_id, idx))\n+            = *error.obligation.cause.code().peel_derives() else { return false; };\n+        let hir = self.tcx.hir();\n+        let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n+\n+        let Some(unsubstituted_pred) =\n+            self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n+            else { return false; };\n+\n+        let generics = self.tcx.generics_of(def_id);\n+        let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n+            _ => ty::List::empty(),\n+        };\n+\n+        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n+            predicate_substs.types().find_map(|ty| {\n+                ty.walk().find_map(|arg| {\n+                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                        && let ty::Param(param_ty) = ty.kind()\n+                        && matches(param_ty)\n+                    {\n+                        Some(arg)\n+                    } else {\n+                        None\n+                    }\n+                })\n+            })\n+        };\n+\n+        // Prefer generics that are local to the fn item, since these are likely\n+        // to be the cause of the unsatisfied predicate.\n+        let mut param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n+        });\n+        // Fall back to generic that isn't local to the fn item. This will come\n+        // from a trait or impl, for example.\n+        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n+                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n+        });\n+        // Finally, the `Self` parameter is possibly the reason that the predicate\n+        // is unsatisfied. This is less likely to be true for methods, because\n+        // method probe means that we already kinda check that the predicates due\n+        // to the `Self` type are true.\n+        let mut self_param_to_point_at =\n+            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n+\n+        // Finally, for ambiguity-related errors, we actually want to look\n+        // for a parameter that is the source of the inference type left\n+        // over in this predicate.\n+        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n+            fallback_param_to_point_at = None;\n+            self_param_to_point_at = None;\n+            param_to_point_at =\n+                self.find_ambiguous_parameter_in(def_id, error.root_obligation.predicate);\n+        }\n+\n+        if self.closure_span_overlaps_error(error, expr.span) {\n+            return false;\n+        }\n+\n+        match &expr.kind {\n+            hir::ExprKind::Path(qpath) => {\n+                if let hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Call(callee, args),\n+                    hir_id: call_hir_id,\n+                    span: call_span,\n+                    ..\n+                }) = hir.get_parent(expr.hir_id)\n+                    && callee.hir_id == expr.hir_id\n+                {\n+                    if self.closure_span_overlaps_error(error, *call_span) {\n+                        return false;\n+                    }\n+\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                        .into_iter()\n+                        .flatten()\n+                    {\n+                        if self.blame_specific_arg_if_possible(\n+                                error,\n+                                def_id,\n+                                param,\n+                                *call_hir_id,\n+                                callee.span,\n+                                None,\n+                                args,\n+                            )\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                // Notably, we only point to params that are local to the\n+                // item we're checking, since those are the ones we are able\n+                // to look in the final `hir::PathSegment` for. Everything else\n+                // would require a deeper search into the `qpath` than I think\n+                // is worthwhile.\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n+                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    .into_iter()\n+                    .flatten()\n+                {\n+                    if self.blame_specific_arg_if_possible(\n+                        error,\n+                        def_id,\n+                        param,\n+                        hir_id,\n+                        segment.ident.span,\n+                        Some(receiver),\n+                        args,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::ExprKind::Struct(qpath, fields, ..) => {\n+                if let Res::Def(\n+                    hir::def::DefKind::Struct | hir::def::DefKind::Variant,\n+                    variant_def_id,\n+                ) = self.typeck_results.borrow().qpath_res(qpath, hir_id)\n+                {\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    {\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n+                                def_id,\n+                                param,\n+                                variant_def_id,\n+                                fields,\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+\n+    fn point_at_path_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param: ty::GenericArg<'tcx>,\n+        qpath: &hir::QPath<'tcx>,\n+    ) -> bool {\n+        match qpath {\n+            hir::QPath::Resolved(_, path) => {\n+                if let Some(segment) = path.segments.last()\n+                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::QPath::TypeRelative(_, segment) => {\n+                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+\n+    fn point_at_generic_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        segment: &hir::PathSegment<'tcx>,\n+    ) -> bool {\n+        let own_substs = self\n+            .tcx\n+            .generics_of(def_id)\n+            .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n+        let Some((index, _)) = own_substs\n+            .iter()\n+            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n+            .enumerate()\n+            .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n+        let Some(arg) = segment\n+            .args()\n+            .args\n+            .iter()\n+            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n+            .nth(index) else { return false; };\n+        error.obligation.cause.span = arg\n+            .span()\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(arg.span());\n+        true\n+    }\n+\n+    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n+        &self,\n+        item_def_id: DefId,\n+        t: T,\n+    ) -> Option<ty::GenericArg<'tcx>> {\n+        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n+        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n+            type BreakTy = ty::GenericArg<'tcx>;\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n+                if let Some(origin) = self.0.type_var_origin(ty)\n+                    && let rustc_infer::infer::type_variable::TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n+                        origin.kind\n+                    && let generics = self.0.tcx.generics_of(self.1)\n+                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n+                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n+                        .get(index as usize)\n+                {\n+                    ControlFlow::Break(*subst)\n+                } else {\n+                    ty.super_visit_with(self)\n+                }\n+            }\n+        }\n+        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n+    }\n+\n+    fn closure_span_overlaps_error(\n+        &self,\n+        error: &traits::FulfillmentError<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        if let traits::FulfillmentErrorCode::CodeSelectionError(\n+            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n+        ) = error.code\n+            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n+            && span.overlaps(self.tcx.def_span(*def_id))\n+        {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_field_if_possible(\n+        &self,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        variant_def_id: DefId,\n+        expr_fields: &[hir::ExprField<'tcx>],\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n+        let def = self.tcx.adt_def(def_id);\n+\n+        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n+        let fields_referencing_param: Vec<_> = def\n+            .variant_with_id(variant_def_id)\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                let field_ty = field.ty(self.tcx, identity_substs);\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+            })\n+            .collect();\n+\n+        if let [field] = fields_referencing_param.as_slice() {\n+            for expr_field in expr_fields {\n+                // Look for the ExprField that matches the field, using the\n+                // same rules that check_expr_struct uses for macro hygiene.\n+                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n+                {\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        call_hir_id: hir::HirId,\n+        callee_span: Span,\n+        receiver: Option<&'tcx hir::Expr<'tcx>>,\n+        args: &'tcx [hir::Expr<'tcx>],\n+    ) -> bool {\n+        let ty = self.tcx.type_of(def_id);\n+        if !ty.is_fn() {\n+            return false;\n+        }\n+        let sig = ty.fn_sig(self.tcx).skip_binder();\n+        let args_referencing_param: Vec<_> = sig\n+            .inputs()\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .collect();\n+        // If there's one field that references the given generic, great!\n+        if let [(idx, _)] = args_referencing_param.as_slice()\n+            && let Some(arg) = receiver\n+                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n+            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n+            error.obligation.cause.map_code(|parent_code| {\n+                ObligationCauseCode::FunctionArgumentObligation {\n+                    arg_hir_id: arg.hir_id,\n+                    call_hir_id,\n+                    parent_code,\n+                }\n+            });\n+            return true;\n+        } else if args_referencing_param.len() > 0 {\n+            // If more than one argument applies, then point to the callee span at least...\n+            // We have chance to fix this up further in `point_at_generics_if_possible`\n+            error.obligation.cause.span = callee_span;\n+        }\n+\n+        false\n+    }\n+\n     /**\n      * Recursively searches for the most-specific blamable expression.\n      * For example, if you have a chain of constraints like:"}, {"sha": "2a1265600de8b32738e227b6670768c98af19401", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 369, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -26,7 +26,7 @@ use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, sym, Span};\n@@ -36,8 +36,6 @@ use std::iter;\n use std::mem;\n use std::slice;\n \n-use std::ops::ControlFlow;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1758,372 +1756,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_fulfillment_error_for_expr_obligation(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-    ) -> bool {\n-        let (traits::ExprItemObligation(def_id, hir_id, idx) | traits::ExprBindingObligation(def_id, _, hir_id, idx))\n-            = *error.obligation.cause.code().peel_derives() else { return false; };\n-        let hir = self.tcx.hir();\n-        let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n-\n-        let Some(unsubstituted_pred) =\n-            self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n-            else { return false; };\n-\n-        let generics = self.tcx.generics_of(def_id);\n-        let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n-            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n-            _ => ty::List::empty(),\n-        };\n-\n-        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n-            predicate_substs.types().find_map(|ty| {\n-                ty.walk().find_map(|arg| {\n-                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Param(param_ty) = ty.kind()\n-                        && matches(param_ty)\n-                    {\n-                        Some(arg)\n-                    } else {\n-                        None\n-                    }\n-                })\n-            })\n-        };\n-\n-        // Prefer generics that are local to the fn item, since these are likely\n-        // to be the cause of the unsatisfied predicate.\n-        let mut param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n-        });\n-        // Fall back to generic that isn't local to the fn item. This will come\n-        // from a trait or impl, for example.\n-        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n-                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n-        });\n-        // Finally, the `Self` parameter is possibly the reason that the predicate\n-        // is unsatisfied. This is less likely to be true for methods, because\n-        // method probe means that we already kinda check that the predicates due\n-        // to the `Self` type are true.\n-        let mut self_param_to_point_at =\n-            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n-\n-        // Finally, for ambiguity-related errors, we actually want to look\n-        // for a parameter that is the source of the inference type left\n-        // over in this predicate.\n-        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n-            fallback_param_to_point_at = None;\n-            self_param_to_point_at = None;\n-            param_to_point_at =\n-                self.find_ambiguous_parameter_in(def_id, error.root_obligation.predicate);\n-        }\n-\n-        if self.closure_span_overlaps_error(error, expr.span) {\n-            return false;\n-        }\n-\n-        match &expr.kind {\n-            hir::ExprKind::Path(qpath) => {\n-                if let hir::Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::Call(callee, args),\n-                    hir_id: call_hir_id,\n-                    span: call_span,\n-                    ..\n-                }) = hir.get_parent(expr.hir_id)\n-                    && callee.hir_id == expr.hir_id\n-                {\n-                    if self.closure_span_overlaps_error(error, *call_span) {\n-                        return false;\n-                    }\n-\n-                    for param in\n-                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                        .into_iter()\n-                        .flatten()\n-                    {\n-                        if self.blame_specific_arg_if_possible(\n-                                error,\n-                                def_id,\n-                                param,\n-                                *call_hir_id,\n-                                callee.span,\n-                                None,\n-                                args,\n-                            )\n-                        {\n-                            return true;\n-                        }\n-                    }\n-                }\n-                // Notably, we only point to params that are local to the\n-                // item we're checking, since those are the ones we are able\n-                // to look in the final `hir::PathSegment` for. Everything else\n-                // would require a deeper search into the `qpath` than I think\n-                // is worthwhile.\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n-                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                    .into_iter()\n-                    .flatten()\n-                {\n-                    if self.blame_specific_arg_if_possible(\n-                        error,\n-                        def_id,\n-                        param,\n-                        hir_id,\n-                        segment.ident.span,\n-                        Some(receiver),\n-                        args,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::ExprKind::Struct(qpath, fields, ..) => {\n-                if let Res::Def(DefKind::Struct | DefKind::Variant, variant_def_id) =\n-                    self.typeck_results.borrow().qpath_res(qpath, hir_id)\n-                {\n-                    for param in\n-                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                    {\n-                        if let Some(param) = param {\n-                            let refined_expr = self.point_at_field_if_possible(\n-                                def_id,\n-                                param,\n-                                variant_def_id,\n-                                fields,\n-                            );\n-\n-                            match refined_expr {\n-                                None => {}\n-                                Some((refined_expr, _)) => {\n-                                    error.obligation.cause.span = refined_expr\n-                                        .span\n-                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                                        .unwrap_or(refined_expr.span);\n-                                    return true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n-    fn closure_span_overlaps_error(\n-        &self,\n-        error: &traits::FulfillmentError<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        if let traits::FulfillmentErrorCode::CodeSelectionError(\n-            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n-        ) = error.code\n-            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n-            && span.overlaps(self.tcx.def_span(*def_id))\n-        {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n-    /// looking for the most-specific-possible span to blame.\n-    ///\n-    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n-    /// expression mentioned.\n-    ///\n-    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n-    /// the provided function call expression, and mark it as responsible for the fullfillment\n-    /// error.\n-    fn blame_specific_arg_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        call_hir_id: hir::HirId,\n-        callee_span: Span,\n-        receiver: Option<&'tcx hir::Expr<'tcx>>,\n-        args: &'tcx [hir::Expr<'tcx>],\n-    ) -> bool {\n-        let ty = self.tcx.type_of(def_id);\n-        if !ty.is_fn() {\n-            return false;\n-        }\n-        let sig = ty.fn_sig(self.tcx).skip_binder();\n-        let args_referencing_param: Vec<_> = sig\n-            .inputs()\n-            .iter()\n-            .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n-            .collect();\n-        // If there's one field that references the given generic, great!\n-        if let [(idx, _)] = args_referencing_param.as_slice()\n-            && let Some(arg) = receiver\n-                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n-\n-            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n-\n-            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n-                // This is more specific than pointing at the entire argument.\n-                self.blame_specific_expr_if_possible(error, arg_expr)\n-            }\n-\n-            error.obligation.cause.map_code(|parent_code| {\n-                ObligationCauseCode::FunctionArgumentObligation {\n-                    arg_hir_id: arg.hir_id,\n-                    call_hir_id,\n-                    parent_code,\n-                }\n-            });\n-            return true;\n-        } else if args_referencing_param.len() > 0 {\n-            // If more than one argument applies, then point to the callee span at least...\n-            // We have chance to fix this up further in `point_at_generics_if_possible`\n-            error.obligation.cause.span = callee_span;\n-        }\n-\n-        false\n-    }\n-\n-    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n-    pub fn point_at_field_if_possible(\n-        &self,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        variant_def_id: DefId,\n-        expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n-        let def = self.tcx.adt_def(def_id);\n-\n-        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n-        let fields_referencing_param: Vec<_> = def\n-            .variant_with_id(variant_def_id)\n-            .fields\n-            .iter()\n-            .filter(|field| {\n-                let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n-            })\n-            .collect();\n-\n-        if let [field] = fields_referencing_param.as_slice() {\n-            for expr_field in expr_fields {\n-                // Look for the ExprField that matches the field, using the\n-                // same rules that check_expr_struct uses for macro hygiene.\n-                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n-                {\n-                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn point_at_path_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param: ty::GenericArg<'tcx>,\n-        qpath: &QPath<'tcx>,\n-    ) -> bool {\n-        match qpath {\n-            hir::QPath::Resolved(_, path) => {\n-                if let Some(segment) = path.segments.last()\n-                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::QPath::TypeRelative(_, segment) => {\n-                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n-    fn point_at_generic_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        segment: &hir::PathSegment<'tcx>,\n-    ) -> bool {\n-        let own_substs = self\n-            .tcx\n-            .generics_of(def_id)\n-            .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n-        let Some((index, _)) = own_substs\n-            .iter()\n-            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n-            .enumerate()\n-            .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n-        let Some(arg) = segment\n-            .args()\n-            .args\n-            .iter()\n-            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n-            .nth(index) else { return false; };\n-        error.obligation.cause.span = arg\n-            .span()\n-            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-            .unwrap_or(arg.span());\n-        true\n-    }\n-\n-    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n-        &self,\n-        item_def_id: DefId,\n-        t: T,\n-    ) -> Option<ty::GenericArg<'tcx>> {\n-        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n-        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n-            type BreakTy = ty::GenericArg<'tcx>;\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-                if let Some(origin) = self.0.type_var_origin(ty)\n-                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n-                        origin.kind\n-                    && let generics = self.0.tcx.generics_of(self.1)\n-                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n-                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n-                        .get(index as usize)\n-                {\n-                    ControlFlow::Break(*subst)\n-                } else {\n-                    ty.super_visit_with(self)\n-                }\n-            }\n-        }\n-        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n-    }\n-\n     fn label_fn_like(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "3814ddaf73f44b8e64ebeb89418f1c875dc1da16", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         item_segment: &hir::PathSegment<'_>,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        let trait_ref = self.replace_bound_vars_with_fresh_vars(\n+        let trait_ref = self.instantiate_binder_with_fresh_vars(\n             span,\n             infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n             poly_trait_ref,"}, {"sha": "eaad57d8c2e9f1088ab839e4e266d62b302ea743", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1336,16 +1336,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::Path { segments: [segment], .. },\n             ))\n             | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n-                let self_ty = self.astconv().ast_ty_to_ty(ty);\n-                if let Ok(pick) = self.probe_for_name(\n-                    Mode::Path,\n-                    Ident::new(capitalized_name, segment.ident.span),\n-                    Some(expected_ty),\n-                    IsSuggestion(true),\n-                    self_ty,\n-                    expr.hir_id,\n-                    ProbeScope::TraitsInScope,\n-                ) {\n+                if let Some(self_ty) = self.typeck_results.borrow().node_type_opt(ty.hir_id)\n+                    && let Ok(pick) = self.probe_for_name(\n+                        Mode::Path,\n+                        Ident::new(capitalized_name, segment.ident.span),\n+                        Some(expected_ty),\n+                        IsSuggestion(true),\n+                        self_ty,\n+                        expr.hir_id,\n+                        ProbeScope::TraitsInScope,\n+                    )\n+                {\n                     (pick.item, segment)\n                 } else {\n                     return false;\n@@ -1457,6 +1458,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     generics,\n                     diag,\n                     vec![(param.name.as_str(), \"Clone\", Some(clone_trait_did))].into_iter(),\n+                    None,\n                 );\n             } else {\n                 self.suggest_derive(diag, &[(trait_ref.to_predicate(self.tcx), None, None)]);"}, {"sha": "fa0dc4d84150636f57bcebd7014b102d8bd57596", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                     let original_poly_trait_ref = principal.with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref = this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n-                        this.replace_bound_vars_with_fresh_vars(upcast_poly_trait_ref);\n+                        this.instantiate_binder_with_fresh_vars(upcast_poly_trait_ref);\n                     debug!(\n                         \"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n                         original_poly_trait_ref, upcast_trait_ref, trait_def_id\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             probe::WhereClausePick(poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_bound_vars_with_fresh_vars(poly_trait_ref).substs\n+                self.instantiate_binder_with_fresh_vars(poly_trait_ref).substs\n             }\n         }\n     }\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let sig = self.tcx.fn_sig(def_id).subst(self.tcx, all_substs);\n         debug!(\"type scheme substituted, sig={:?}\", sig);\n \n-        let sig = self.replace_bound_vars_with_fresh_vars(sig);\n+        let sig = self.instantiate_binder_with_fresh_vars(sig);\n         debug!(\"late-bound lifetimes from method instantiated, sig={:?}\", sig);\n \n         (sig, method_predicates)\n@@ -625,10 +625,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n-    fn replace_bound_vars_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n+    fn instantiate_binder_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n     {\n-        self.fcx.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, value)\n+        self.fcx.instantiate_binder_with_fresh_vars(self.span, infer::FnCall, value)\n     }\n }"}, {"sha": "d5d10cf272afad674cced63f4473b4c934562a5b", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // with bound regions.\n         let fn_sig = tcx.fn_sig(def_id).subst(self.tcx, substs);\n         let fn_sig =\n-            self.replace_bound_vars_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n+            self.instantiate_binder_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n \n         let InferOk { value, obligations: o } =\n             self.at(&obligation.cause, self.param_env).normalize(fn_sig);"}, {"sha": "4ce401b52bd269292890b3b9bd3da39132ef1825", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -924,7 +924,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             ty::AssocKind::Fn => self.probe(|_| {\n                 let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                 let fty = self.tcx.fn_sig(method.def_id).subst(self.tcx, substs);\n-                let fty = self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, fty);\n+                let fty = self.instantiate_binder_with_fresh_vars(self.span, infer::FnCall, fty);\n \n                 if let Some(self_ty) = self_ty {\n                     if self"}, {"sha": "7cc9e49b1b62adf66597091e683e21525347ca8f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -268,14 +268,12 @@ impl<'tcx> InferCtxt<'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints.outlives.push((\n-                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n-                            constraint_category,\n-                        ));\n-                        output_query_region_constraints.outlives.push((\n-                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n-                            constraint_category,\n-                        ));\n+                        output_query_region_constraints\n+                            .outlives\n+                            .push((ty::OutlivesPredicate(v_o.into(), v_r), constraint_category));\n+                        output_query_region_constraints\n+                            .outlives\n+                            .push((ty::OutlivesPredicate(v_r.into(), v_o), constraint_category));\n                     }\n                 }\n \n@@ -318,10 +316,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             query_response.value.region_constraints.outlives.iter().filter_map(|&r_c| {\n                 let r_c = substitute_value(self.tcx, &result_subst, r_c);\n \n-                // Screen out `'a: 'a` cases -- we skip the binder here but\n-                // only compare the inner values to one another, so they are still at\n-                // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n+                // Screen out `'a: 'a` cases.\n+                let ty::OutlivesPredicate(k1, r2) = r_c.0;\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -559,11 +555,11 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     pub fn query_outlives_constraint_to_obligation(\n         &self,\n-        predicate: QueryOutlivesConstraint<'tcx>,\n+        (predicate, _): QueryOutlivesConstraint<'tcx>,\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate;\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -578,7 +574,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.0.rebind(atom);\n+        let predicate = ty::Binder::dummy(atom);\n \n         Obligation::new(self.tcx, cause, param_env, predicate)\n     }\n@@ -643,8 +639,7 @@ pub fn make_query_region_constraints<'tcx>(\n     let outlives: Vec<_> = constraints\n         .iter()\n         .map(|(k, origin)| {\n-            // no bound vars in the code above\n-            let constraint = ty::Binder::dummy(match *k {\n+            let constraint = match *k {\n                 // Swap regions because we are going from sub (<=) to outlives\n                 // (>=).\n                 Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n@@ -658,16 +653,12 @@ pub fn make_query_region_constraints<'tcx>(\n                     ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n                 }\n                 Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            });\n+            };\n             (constraint, origin.to_constraint_category())\n         })\n-        .chain(\n-            outlives_obligations\n-                // no bound vars in the code above\n-                .map(|(ty, r, constraint_category)| {\n-                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n-                }),\n-        )\n+        .chain(outlives_obligations.map(|(ty, r, constraint_category)| {\n+            (ty::OutlivesPredicate(ty.into(), r), constraint_category)\n+        }))\n         .collect();\n \n     QueryRegionConstraints { outlives, member_constraints: member_constraints.clone() }"}, {"sha": "7db4d92a177a1b89b13e9c93f58a3a6f9babe43d", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 let a_types = infcx.tcx.anonymize_bound_vars(a_types);\n                 let b_types = infcx.tcx.anonymize_bound_vars(b_types);\n                 if a_types.bound_vars() == b_types.bound_vars() {\n-                    let (a_types, b_types) = infcx.replace_bound_vars_with_placeholders(\n+                    let (a_types, b_types) = infcx.instantiate_binder_with_placeholders(\n                         a_types.map_bound(|a_types| (a_types, b_types.skip_binder())),\n                     );\n                     for (a, b) in std::iter::zip(a_types, b_types) {"}, {"sha": "86f3174b7b2bb25e9c82d410761a445a4a5760f9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1922,7 +1922,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         (ty::Uint(ty::UintTy::U8), ty::Char) => {\n                             if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n                                 && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                && code.chars().next().map_or(false, |c| c.is_ascii())\n+                                && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n+                                && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n                             {\n                                 err.span_suggestion(\n                                     span,"}, {"sha": "984e8cf6a0eb909f872fb50574b53c586847a349", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -77,49 +77,86 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n                         if tcx.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n                     {\n-                        let generics = tcx.generics_of(body_owner_def_id);\n-                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        let p_def_id = tcx\n+                            .generics_of(body_owner_def_id)\n+                            .type_param(p, tcx)\n+                            .def_id;\n+                        let p_span = tcx.def_span(p_def_id);\n                         if !sp.contains(p_span) {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                         let hir = tcx.hir();\n                         let mut note = true;\n-                        if let Some(generics) = generics\n-                            .type_param(p, tcx)\n-                            .def_id\n+                        let parent = p_def_id\n                             .as_local()\n-                            .map(|id| hir.local_def_id_to_hir_id(id))\n-                            .and_then(|id| tcx.hir().find_parent(id))\n-                            .as_ref()\n-                            .and_then(|node| node.generics())\n+                            .and_then(|id| {\n+                                let local_id = hir.local_def_id_to_hir_id(id);\n+                                let generics = tcx.hir().find_parent(local_id)?.generics()?;\n+                                Some((id, generics))\n+                            });\n+                        if let Some((local_id, generics)) = parent\n                         {\n                             // Synthesize the associated type restriction `Add<Output = Expected>`.\n                             // FIXME: extract this logic for use in other diagnostics.\n                             let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(tcx);\n-                            let path =\n-                                tcx.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n                             let item_name = tcx.item_name(proj.def_id);\n                             let item_args = self.format_generic_args(assoc_substs);\n \n-                            let path = if path.ends_with('>') {\n-                                format!(\n-                                    \"{}, {}{} = {}>\",\n-                                    &path[..path.len() - 1],\n-                                    item_name,\n-                                    item_args,\n-                                    p\n-                                )\n+                            // Here, we try to see if there's an existing\n+                            // trait implementation that matches the one that\n+                            // we're suggesting to restrict. If so, find the\n+                            // \"end\", whether it be at the end of the trait\n+                            // or the end of the generic arguments.\n+                            let mut matching_span = None;\n+                            let mut matched_end_of_args = false;\n+                            for bound in generics.bounds_for_param(local_id) {\n+                                let potential_spans = bound\n+                                    .bounds\n+                                    .iter()\n+                                    .find_map(|bound| {\n+                                        let bound_trait_path = bound.trait_ref()?.path;\n+                                        let def_id = bound_trait_path.res.opt_def_id()?;\n+                                        let generic_args = bound_trait_path.segments.iter().last().map(|path| path.args());\n+                                        (def_id == trait_ref.def_id).then_some((bound_trait_path.span, generic_args))\n+                                    });\n+\n+                                if let Some((end_of_trait, end_of_args)) = potential_spans {\n+                                    let args_span = end_of_args.and_then(|args| args.span());\n+                                    matched_end_of_args = args_span.is_some();\n+                                    matching_span = args_span\n+                                        .or_else(|| Some(end_of_trait))\n+                                        .map(|span| span.shrink_to_hi());\n+                                    break;\n+                                }\n+                            }\n+\n+                            if matched_end_of_args {\n+                                // Append suggestion to the end of our args\n+                                let path = format!(\", {}{} = {}\",item_name, item_args, p);\n+                                note = !suggest_constraining_type_param(\n+                                    tcx,\n+                                    generics,\n+                                    diag,\n+                                    &format!(\"{}\", proj.self_ty()),\n+                                    &path,\n+                                    None,\n+                                    matching_span,\n+                                );\n                             } else {\n-                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n-                            };\n-                            note = !suggest_constraining_type_param(\n-                                tcx,\n-                                generics,\n-                                diag,\n-                                &format!(\"{}\", proj.self_ty()),\n-                                &path,\n-                                None,\n-                            );\n+                                // Suggest adding a bound to an existing trait\n+                                // or if the trait doesn't exist, add the trait\n+                                // and the suggested bounds.\n+                                let path = format!(\"<{}{} = {}>\", item_name, item_args, p);\n+                                note = !suggest_constraining_type_param(\n+                                    tcx,\n+                                    generics,\n+                                    diag,\n+                                    &format!(\"{}\", proj.self_ty()),\n+                                    &path,\n+                                    None,\n+                                    matching_span,\n+                                );\n+                            }\n                         }\n                         if note {\n                             diag.note(\"you might be missing a type parameter or trait bound\");"}, {"sha": "412e52d8fd7e21bbd2f9143ba587dbabcb7fa7ad", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -38,13 +38,13 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         // First, we instantiate each bound region in the supertype with a\n         // fresh placeholder region. Note that this automatically creates\n         // a new universe if needed.\n-        let sup_prime = self.infcx.replace_bound_vars_with_placeholders(sup);\n+        let sup_prime = self.infcx.instantiate_binder_with_placeholders(sup);\n \n         // Next, we instantiate each bound region in the subtype\n         // with a fresh region variable. These region variables --\n         // but no other pre-existing region variables -- can name\n         // the placeholders.\n-        let sub_prime = self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, sub);\n+        let sub_prime = self.infcx.instantiate_binder_with_fresh_vars(span, HigherRankedType, sub);\n \n         debug!(\"a_prime={:?}\", sub_prime);\n         debug!(\"b_prime={:?}\", sup_prime);\n@@ -70,7 +70,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n     #[instrument(level = \"debug\", skip(self), ret)]\n-    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n+    pub fn instantiate_binder_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n     {"}, {"sha": "35918b8bae1c20b10290401962683d9a88ed13df", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -995,7 +995,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         Ok(self.commit_if_ok(|_snapshot| {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n-                self.replace_bound_vars_with_placeholders(predicate);\n+                self.instantiate_binder_with_placeholders(predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n@@ -1008,7 +1008,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: &traits::ObligationCause<'tcx>,\n         predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) {\n-        let ty::OutlivesPredicate(r_a, r_b) = self.replace_bound_vars_with_placeholders(predicate);\n+        let ty::OutlivesPredicate(r_a, r_b) = self.instantiate_binder_with_placeholders(predicate);\n         let origin =\n             SubregionOrigin::from_obligation_cause(cause, || RelateRegionParamBound(cause.span));\n         self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n@@ -1447,7 +1447,14 @@ impl<'tcx> InferCtxt<'tcx> {\n         value\n     }\n \n-    pub fn replace_bound_vars_with_fresh_vars<T>(\n+    // Instantiates the bound variables in a given binder with fresh inference\n+    // variables in the current universe.\n+    //\n+    // Use this method if you'd like to find some substitution of the binder's\n+    // variables (e.g. during a method call). If there isn't a [`LateBoundRegionConversionTime`]\n+    // that corresponds to your use case, consider whether or not you should\n+    // use [`InferCtxt::instantiate_binder_with_placeholders`] instead.\n+    pub fn instantiate_binder_with_fresh_vars<T>(\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,"}, {"sha": "532fbd0ffe4c40c685a47ef74098d5945fdacd60", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -161,7 +161,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 let a_types = infcx.tcx.anonymize_bound_vars(a_types);\n                 let b_types = infcx.tcx.anonymize_bound_vars(b_types);\n                 if a_types.bound_vars() == b_types.bound_vars() {\n-                    let (a_types, b_types) = infcx.replace_bound_vars_with_placeholders(\n+                    let (a_types, b_types) = infcx.instantiate_binder_with_placeholders(\n                         a_types.map_bound(|a_types| (a_types, b_types.skip_binder())),\n                     );\n                     for (a, b) in std::iter::zip(a_types, b_types) {"}, {"sha": "5165ee424e31ba8ad5d9906fa8300ebad0214aa0", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -758,7 +758,6 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });\n-    tracked!(log_backtrace, Some(\"filter\".to_string()));\n     tracked!(maximal_hir_to_mir_coverage, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));\n     tracked!(mir_emit_retag, true);"}, {"sha": "9d8ad9d9ed9f6f5c7d2fa66b7e0d656ba2393581", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4073,7 +4073,8 @@ declare_lint! {\n \n declare_lint! {\n     /// The `byte_slice_in_packed_struct_with_derive` lint detects cases where a byte slice field\n-    /// (`[u8]`) is used in a `packed` struct that derives one or more built-in traits.\n+    /// (`[u8]`) or string slice field (`str`) is used in a `packed` struct that derives one or\n+    /// more built-in traits.\n     ///\n     /// ### Example\n     ///\n@@ -4091,11 +4092,11 @@ declare_lint! {\n     /// ### Explanation\n     ///\n     /// This was previously accepted but is being phased out, because fields in packed structs are\n-    /// now required to implement `Copy` for `derive` to work. Byte slices are a temporary\n-    /// exception because certain crates depended on them.\n+    /// now required to implement `Copy` for `derive` to work. Byte slices and string slices are a\n+    /// temporary exception because certain crates depended on them.\n     pub BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n     Warn,\n-    \"`[u8]` slice used in a packed struct with `derive`\",\n+    \"`[u8]` or `str` used in a packed struct with `derive`\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #107457 <https://github.com/rust-lang/rust/issues/107457>\",\n         reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,"}, {"sha": "9146a3739b2b1b76dfe30a8dd68ec355debede20", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4,7 +4,6 @@\n #include \"llvm/ADT/ArrayRef.h\"\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/ADT/SmallVector.h\"\n-#include \"llvm/ADT/Triple.h\"\n #include \"llvm/Analysis/Lint.h\"\n #include \"llvm/Analysis/Passes.h\"\n #include \"llvm/IR/IRBuilder.h\"\n@@ -44,6 +43,12 @@\n #include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/Linker/Linker.h\"\n \n+#if LLVM_VERSION_GE(16, 0)\n+#include \"llvm/TargetParser/Triple.h\"\n+#else\n+#include \"llvm/ADT/Triple.h\"\n+#endif\n+\n extern \"C\" void LLVMRustSetLastError(const char *);\n \n enum class LLVMRustResult { Success, Failure };"}, {"sha": "019fdc30dcec5606fb4d8e0f9a9f045480c19dce", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -54,25 +54,12 @@ use tracing_subscriber::fmt::{\n use tracing_subscriber::layer::SubscriberExt;\n \n pub fn init_rustc_env_logger() -> Result<(), Error> {\n-    init_rustc_env_logger_with_backtrace_option(&None)\n-}\n-\n-pub fn init_rustc_env_logger_with_backtrace_option(\n-    backtrace_target: &Option<String>,\n-) -> Result<(), Error> {\n-    init_env_logger_with_backtrace_option(\"RUSTC_LOG\", backtrace_target)\n+    init_env_logger(\"RUSTC_LOG\")\n }\n \n /// In contrast to `init_rustc_env_logger` this allows you to choose an env var\n /// other than `RUSTC_LOG`.\n pub fn init_env_logger(env: &str) -> Result<(), Error> {\n-    init_env_logger_with_backtrace_option(env, &None)\n-}\n-\n-pub fn init_env_logger_with_backtrace_option(\n-    env: &str,\n-    backtrace_target: &Option<String>,\n-) -> Result<(), Error> {\n     let filter = match env::var(env) {\n         Ok(env) => EnvFilter::new(env),\n         _ => EnvFilter::default().add_directive(Directive::from(LevelFilter::WARN)),\n@@ -106,16 +93,16 @@ pub fn init_env_logger_with_backtrace_option(\n     let layer = layer.with_thread_ids(true).with_thread_names(true);\n \n     let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);\n-    match backtrace_target {\n-        Some(str) => {\n+    match env::var(format!(\"{env}_BACKTRACE\")) {\n+        Ok(str) => {\n             let fmt_layer = tracing_subscriber::fmt::layer()\n                 .with_writer(io::stderr)\n                 .without_time()\n                 .event_format(BacktraceFormatter { backtrace_target: str.to_string() });\n             let subscriber = subscriber.with(fmt_layer);\n             tracing::subscriber::set_global_default(subscriber).unwrap();\n         }\n-        None => {\n+        Err(_) => {\n             tracing::subscriber::set_global_default(subscriber).unwrap();\n         }\n     };"}, {"sha": "bf8b8aa2ce49704e13d47567f016d7ad2535e97b", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -356,7 +356,12 @@ impl<'a> CrateLoader<'a> {\n         for (_, other) in self.cstore.iter_crate_data() {\n             // Same stable crate id but different SVH\n             if other.stable_crate_id() == root.stable_crate_id() && other.hash() != root.hash() {\n-                return Err(CrateError::SymbolConflictsOthers(root.name()));\n+                bug!(\n+                    \"Previously returned E0523 here. \\\n+                     See https://github.com/rust-lang/rust/pull/100599 for additional discussion.\\\n+                     root.name() = {}.\",\n+                    root.name()\n+                );\n             }\n         }\n "}, {"sha": "c32686779facb5be9c91f306815ceba751897316", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -511,14 +511,6 @@ pub struct SymbolConflictsCurrent {\n     pub crate_name: Symbol,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(metadata_symbol_conflicts_others, code = \"E0523\")]\n-pub struct SymbolConflictsOthers {\n-    #[primary_span]\n-    pub span: Span,\n-    pub crate_name: Symbol,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(metadata_stable_crate_id_collision)]\n pub struct StableCrateIdCollision {"}, {"sha": "755a24253504ec844eb3be0225a8772db6e0bdc1", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -945,7 +945,6 @@ pub(crate) enum CrateError {\n     ExternLocationNotFile(Symbol, PathBuf),\n     MultipleCandidates(Symbol, CrateFlavor, Vec<PathBuf>),\n     SymbolConflictsCurrent(Symbol),\n-    SymbolConflictsOthers(Symbol),\n     StableCrateIdCollision(Symbol, Symbol),\n     DlOpen(String),\n     DlSym(String),\n@@ -989,9 +988,6 @@ impl CrateError {\n             CrateError::SymbolConflictsCurrent(root_name) => {\n                 sess.emit_err(errors::SymbolConflictsCurrent { span, crate_name: root_name });\n             }\n-            CrateError::SymbolConflictsOthers(root_name) => {\n-                sess.emit_err(errors::SymbolConflictsOthers { span, crate_name: root_name });\n-            }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n                 sess.emit_err(errors::StableCrateIdCollision { span, crate_name0, crate_name1 });\n             }"}, {"sha": "d6f20a8fc06ec563f960c59e604c96b89464c2b7", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -324,10 +324,8 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> = (\n-    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n-    ConstraintCategory<'tcx>,\n-);\n+pub type QueryOutlivesConstraint<'tcx> =\n+    (ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>, ConstraintCategory<'tcx>);\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "f22c0dbc60d9d0f6a7114f0db7f87b550737eaca", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -430,8 +430,10 @@ pub enum ResourceExhaustionInfo {\n     ///\n     /// The exact limit is set by the `const_eval_limit` attribute.\n     StepLimitReached,\n-    /// There is not enough memory to perform an allocation.\n+    /// There is not enough memory (on the host) to perform an allocation.\n     MemoryExhausted,\n+    /// The address space (of the target) is full.\n+    AddressSpaceFull,\n }\n \n impl fmt::Display for ResourceExhaustionInfo {\n@@ -447,6 +449,9 @@ impl fmt::Display for ResourceExhaustionInfo {\n             MemoryExhausted => {\n                 write!(f, \"tried to allocate more memory than available to compiler\")\n             }\n+            AddressSpaceFull => {\n+                write!(f, \"there are no more free addresses in the address space\")\n+            }\n         }\n     }\n }"}, {"sha": "0a16ede64991de8d36cd4adf23c1ac435a783e07", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -54,14 +54,14 @@ rustc_queries! {\n     /// This is because the `hir_crate` query gives you access to all other items.\n     /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n     /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n-    query hir_crate(key: ()) -> Crate<'tcx> {\n+    query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n         arena_cache\n         eval_always\n         desc { \"getting the crate HIR\" }\n     }\n \n     /// All items in the crate.\n-    query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n+    query hir_crate_items(_: ()) -> &'tcx rustc_middle::hir::ModuleItems {\n         arena_cache\n         eval_always\n         desc { \"getting HIR crate items\" }\n@@ -71,7 +71,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n     /// Avoid calling this query directly.\n-    query hir_module_items(key: LocalDefId) -> rustc_middle::hir::ModuleItems {\n+    query hir_module_items(key: LocalDefId) -> &'tcx rustc_middle::hir::ModuleItems {\n         arena_cache\n         desc { |tcx| \"getting HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n@@ -183,7 +183,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query unsizing_params_for_adt(key: DefId) -> rustc_index::bit_set::BitSet<u32>\n+    query unsizing_params_for_adt(key: DefId) -> &'tcx rustc_index::bit_set::BitSet<u32>\n     {\n         arena_cache\n         desc { |tcx|\n@@ -218,7 +218,7 @@ rustc_queries! {\n \n     /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n     /// associated generics.\n-    query generics_of(key: DefId) -> ty::Generics {\n+    query generics_of(key: DefId) -> &'tcx ty::Generics {\n         desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n@@ -295,19 +295,19 @@ rustc_queries! {\n     /// These are assembled from the following places:\n     /// - `extern` blocks (depending on their `link` attributes)\n     /// - the `libs` (`-l`) option\n-    query native_libraries(_: CrateNum) -> Vec<NativeLib> {\n+    query native_libraries(_: CrateNum) -> &'tcx Vec<NativeLib> {\n         arena_cache\n         desc { \"looking up the native libraries of a linked crate\" }\n         separate_provide_extern\n     }\n \n-    query shallow_lint_levels_on(key: hir::OwnerId) -> rustc_middle::lint::ShallowLintLevelMap {\n+    query shallow_lint_levels_on(key: hir::OwnerId) -> &'tcx rustc_middle::lint::ShallowLintLevelMap {\n         eval_always // fetches `resolutions`\n         arena_cache\n         desc { |tcx| \"looking up lint levels for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n-    query lint_expectations(_: ()) -> Vec<(LintExpectationId, LintExpectation)> {\n+    query lint_expectations(_: ()) -> &'tcx Vec<(LintExpectationId, LintExpectation)> {\n         arena_cache\n         desc { \"computing `#[expect]`ed lints in this crate\" }\n     }\n@@ -347,7 +347,7 @@ rustc_queries! {\n     }\n \n     /// Set of param indexes for type params that are in the type's representation\n-    query params_in_repr(key: DefId) -> rustc_index::bit_set::BitSet<u32> {\n+    query params_in_repr(key: DefId) -> &'tcx rustc_index::bit_set::BitSet<u32> {\n         desc { \"finding type parameters in the representation\" }\n         arena_cache\n         no_hash\n@@ -364,14 +364,14 @@ rustc_queries! {\n     }\n \n     /// Create a THIR tree for debugging.\n-    query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> String {\n+    query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx String {\n         no_hash\n         arena_cache\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n     /// Create a list-like THIR representation for debugging.\n-    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> String {\n+    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx String {\n         no_hash\n         arena_cache\n         desc { |tcx| \"constructing flat THIR representation for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n@@ -380,7 +380,7 @@ rustc_queries! {\n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n-    query mir_keys(_: ()) -> rustc_data_structures::fx::FxIndexSet<LocalDefId> {\n+    query mir_keys(_: ()) -> &'tcx rustc_data_structures::fx::FxIndexSet<LocalDefId> {\n         arena_cache\n         desc { \"getting a list of all mir_keys\" }\n     }\n@@ -478,7 +478,7 @@ rustc_queries! {\n \n     query symbols_for_closure_captures(\n         key: (LocalDefId, LocalDefId)\n-    ) -> Vec<rustc_span::Symbol> {\n+    ) -> &'tcx Vec<rustc_span::Symbol> {\n         arena_cache\n         desc {\n             |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n@@ -487,7 +487,7 @@ rustc_queries! {\n         }\n     }\n \n-    query mir_generator_witnesses(key: DefId) -> mir::GeneratorLayout<'tcx> {\n+    query mir_generator_witnesses(key: DefId) -> &'tcx mir::GeneratorLayout<'tcx> {\n         arena_cache\n         desc { |tcx| \"generator witness types for `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n@@ -508,14 +508,14 @@ rustc_queries! {\n \n     /// Returns coverage summary info for a function, after executing the `InstrumentCoverage`\n     /// MIR pass (assuming the -Cinstrument-coverage option is enabled).\n-    query coverageinfo(key: ty::InstanceDef<'tcx>) -> mir::CoverageInfo {\n+    query coverageinfo(key: ty::InstanceDef<'tcx>) -> &'tcx mir::CoverageInfo {\n         desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key.def_id()) }\n         arena_cache\n     }\n \n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n     /// function was optimized out before codegen, and before being added to the Coverage Map.\n-    query covered_code_regions(key: DefId) -> Vec<&'tcx mir::coverage::CodeRegion> {\n+    query covered_code_regions(key: DefId) -> &'tcx Vec<&'tcx mir::coverage::CodeRegion> {\n         desc {\n             |tcx| \"retrieving the covered `CodeRegion`s, if instrumented, for `{}`\",\n             tcx.def_path_str(key)\n@@ -557,7 +557,7 @@ rustc_queries! {\n         desc { \"erasing regions from `{}`\", ty }\n     }\n \n-    query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n+    query wasm_import_module_map(_: CrateNum) -> &'tcx FxHashMap<DefId, String> {\n         arena_cache\n         desc { \"getting wasm import module map\" }\n     }\n@@ -632,7 +632,7 @@ rustc_queries! {\n         desc { |tcx| \"computing the bounds for type parameter `{}`\", tcx.hir().ty_param_name(key.1) }\n     }\n \n-    query trait_def(key: DefId) -> ty::TraitDef {\n+    query trait_def(key: DefId) -> &'tcx ty::TraitDef {\n         desc { |tcx| \"computing trait definition for `{}`\", tcx.def_path_str(key) }\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n@@ -703,7 +703,7 @@ rustc_queries! {\n     }\n \n     /// Gets a map with the variance of every item; use `item_variance` instead.\n-    query crate_variances(_: ()) -> ty::CrateVariancesMap<'tcx> {\n+    query crate_variances(_: ()) -> &'tcx ty::CrateVariancesMap<'tcx> {\n         arena_cache\n         desc { \"computing the variances for items in this crate\" }\n     }\n@@ -716,7 +716,7 @@ rustc_queries! {\n     }\n \n     /// Maps from thee `DefId` of a type to its (inferred) outlives.\n-    query inferred_outlives_crate(_: ()) -> ty::CratePredicatesMap<'tcx> {\n+    query inferred_outlives_crate(_: ()) -> &'tcx ty::CratePredicatesMap<'tcx> {\n         arena_cache\n         desc { \"computing the inferred outlives predicates for items in this crate\" }\n     }\n@@ -729,15 +729,15 @@ rustc_queries! {\n     }\n \n     /// Maps from a trait item to the trait item \"descriptor\".\n-    query associated_item(key: DefId) -> ty::AssocItem {\n+    query associated_item(key: DefId) -> &'tcx ty::AssocItem {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n         arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n-    query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n+    query associated_items(key: DefId) -> &'tcx ty::AssocItems<'tcx> {\n         arena_cache\n         desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }\n@@ -763,7 +763,7 @@ rustc_queries! {\n     ///\n     /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n-    query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+    query impl_item_implementor_ids(impl_id: DefId) -> &'tcx FxHashMap<DefId, DefId> {\n         arena_cache\n         desc { |tcx| \"comparing impl items against trait for `{}`\", tcx.def_path_str(impl_id) }\n     }\n@@ -884,7 +884,7 @@ rustc_queries! {\n     ///\n     /// The second return value maps from ADTs to ignored derived traits (e.g. Debug and Clone) and\n     /// their respective impl (i.e., part of the derive macro)\n-    query live_symbols_and_ignored_derived_traits(_: ()) -> (\n+    query live_symbols_and_ignored_derived_traits(_: ()) -> &'tcx (\n         FxHashSet<LocalDefId>,\n         FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n     ) {\n@@ -964,7 +964,7 @@ rustc_queries! {\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n-    query crate_inherent_impls(k: ()) -> CrateInherentImpls {\n+    query crate_inherent_impls(k: ()) -> &'tcx CrateInherentImpls {\n         arena_cache\n         desc { \"finding all inherent impls defined in crate\" }\n     }\n@@ -1099,7 +1099,7 @@ rustc_queries! {\n         desc { \"checking for private elements in public interfaces\" }\n     }\n \n-    query reachable_set(_: ()) -> FxHashSet<LocalDefId> {\n+    query reachable_set(_: ()) -> &'tcx FxHashSet<LocalDefId> {\n         arena_cache\n         desc { \"reachability\" }\n     }\n@@ -1111,7 +1111,7 @@ rustc_queries! {\n     }\n \n     /// Generates a MIR body for the shim.\n-    query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n+    query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n         arena_cache\n         desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n@@ -1191,7 +1191,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n+    query codegen_fn_attrs(def_id: DefId) -> &'tcx CodegenFnAttrs {\n         desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n         arena_cache\n         cache_on_disk_if { def_id.is_local() }\n@@ -1209,7 +1209,7 @@ rustc_queries! {\n     }\n     /// Gets the rendered value of the specified constant or associated constant.\n     /// Used by rustdoc.\n-    query rendered_const(def_id: DefId) -> String {\n+    query rendered_const(def_id: DefId) -> &'tcx String {\n         arena_cache\n         desc { |tcx| \"rendering constant initializer of `{}`\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n@@ -1268,12 +1268,12 @@ rustc_queries! {\n     }\n \n     /// Given a trait `trait_id`, return all known `impl` blocks.\n-    query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n+    query trait_impls_of(trait_id: DefId) -> &'tcx ty::trait_def::TraitImpls {\n         arena_cache\n         desc { |tcx| \"finding trait impls of `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n-    query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n+    query specialization_graph_of(trait_id: DefId) -> &'tcx specialization_graph::Graph {\n         arena_cache\n         desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n         cache_on_disk_if { true }\n@@ -1403,7 +1403,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n+    query dependency_formats(_: ()) -> &'tcx Lrc<crate::middle::dependency_format::Dependencies> {\n         arena_cache\n         desc { \"getting the linkage format of all dependencies\" }\n     }\n@@ -1503,7 +1503,7 @@ rustc_queries! {\n     // Does not include external symbols that don't have a corresponding DefId,\n     // like the compiler-generated `main` function and so on.\n     query reachable_non_generics(_: CrateNum)\n-        -> DefIdMap<SymbolExportInfo> {\n+        -> &'tcx DefIdMap<SymbolExportInfo> {\n         arena_cache\n         desc { \"looking up the exported symbols of a crate\" }\n         separate_provide_extern\n@@ -1526,7 +1526,7 @@ rustc_queries! {\n     /// added or removed in any upstream crate. Instead use the narrower\n     /// `upstream_monomorphizations_for`, `upstream_drop_glue_for`, or, even\n     /// better, `Instance::upstream_monomorphization()`.\n-    query upstream_monomorphizations(_: ()) -> DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n+    query upstream_monomorphizations(_: ()) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n         arena_cache\n         desc { \"collecting available upstream monomorphizations\" }\n     }\n@@ -1541,7 +1541,6 @@ rustc_queries! {\n     query upstream_monomorphizations_for(def_id: DefId)\n         -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n     {\n-        arena_cache\n         desc { |tcx|\n             \"collecting available upstream monomorphizations for `{}`\",\n             tcx.def_path_str(def_id),\n@@ -1569,7 +1568,7 @@ rustc_queries! {\n     }\n \n     /// Returns a list of all `extern` blocks of a crate.\n-    query foreign_modules(_: CrateNum) -> FxHashMap<DefId, ForeignModule> {\n+    query foreign_modules(_: CrateNum) -> &'tcx FxHashMap<DefId, ForeignModule> {\n         arena_cache\n         desc { \"looking up the foreign modules of a linked crate\" }\n         separate_provide_extern\n@@ -1603,15 +1602,15 @@ rustc_queries! {\n \n     /// Gets the extra data to put in each output filename for a crate.\n     /// For example, compiling the `foo` crate with `extra-filename=-a` creates a `libfoo-b.rlib` file.\n-    query extra_filename(_: CrateNum) -> String {\n+    query extra_filename(_: CrateNum) -> &'tcx String {\n         arena_cache\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n         separate_provide_extern\n     }\n \n     /// Gets the paths where the crate came from in the file system.\n-    query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n+    query crate_extern_paths(_: CrateNum) -> &'tcx Vec<PathBuf> {\n         arena_cache\n         eval_always\n         desc { \"looking up the paths for extern crates\" }\n@@ -1642,7 +1641,7 @@ rustc_queries! {\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: hir::OwnerId) -> ResolveLifetimes {\n+    query resolve_lifetimes(_: hir::OwnerId) -> &'tcx ResolveLifetimes {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n@@ -1713,15 +1712,15 @@ rustc_queries! {\n         desc { |tcx| \"computing crate imported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n-    query lib_features(_: ()) -> LibFeatures {\n+    query lib_features(_: ()) -> &'tcx LibFeatures {\n         arena_cache\n         desc { \"calculating the lib features map\" }\n     }\n     query defined_lib_features(_: CrateNum) -> &'tcx [(Symbol, Option<Symbol>)] {\n         desc { \"calculating the lib features defined in a crate\" }\n         separate_provide_extern\n     }\n-    query stability_implications(_: CrateNum) -> FxHashMap<Symbol, Symbol> {\n+    query stability_implications(_: CrateNum) -> &'tcx FxHashMap<Symbol, Symbol> {\n         arena_cache\n         desc { \"calculating the implications between `#[unstable]` features defined in a crate\" }\n         separate_provide_extern\n@@ -1732,14 +1731,14 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     /// Returns the lang items defined in another crate by loading it from metadata.\n-    query get_lang_items(_: ()) -> LanguageItems {\n+    query get_lang_items(_: ()) -> &'tcx LanguageItems {\n         arena_cache\n         eval_always\n         desc { \"calculating the lang items map\" }\n     }\n \n     /// Returns all diagnostic items defined in all crates.\n-    query all_diagnostic_items(_: ()) -> rustc_hir::diagnostic_items::DiagnosticItems {\n+    query all_diagnostic_items(_: ()) -> &'tcx rustc_hir::diagnostic_items::DiagnosticItems {\n         arena_cache\n         eval_always\n         desc { \"calculating the diagnostic items map\" }\n@@ -1752,7 +1751,7 @@ rustc_queries! {\n     }\n \n     /// Returns the diagnostic items defined in a crate.\n-    query diagnostic_items(_: CrateNum) -> rustc_hir::diagnostic_items::DiagnosticItems {\n+    query diagnostic_items(_: CrateNum) -> &'tcx rustc_hir::diagnostic_items::DiagnosticItems {\n         arena_cache\n         desc { \"calculating the diagnostic items map in a crate\" }\n         separate_provide_extern\n@@ -1762,11 +1761,11 @@ rustc_queries! {\n         desc { \"calculating the missing lang items in a crate\" }\n         separate_provide_extern\n     }\n-    query visible_parent_map(_: ()) -> DefIdMap<DefId> {\n+    query visible_parent_map(_: ()) -> &'tcx DefIdMap<DefId> {\n         arena_cache\n         desc { \"calculating the visible parent map\" }\n     }\n-    query trimmed_def_paths(_: ()) -> FxHashMap<DefId, Symbol> {\n+    query trimmed_def_paths(_: ()) -> &'tcx FxHashMap<DefId, Symbol> {\n         arena_cache\n         desc { \"calculating trimmed def paths\" }\n     }\n@@ -1775,14 +1774,14 @@ rustc_queries! {\n         desc { \"seeing if we're missing an `extern crate` item for this crate\" }\n         separate_provide_extern\n     }\n-    query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n+    query used_crate_source(_: CrateNum) -> &'tcx Lrc<CrateSource> {\n         arena_cache\n         eval_always\n         desc { \"looking at the source for a crate\" }\n         separate_provide_extern\n     }\n     /// Returns the debugger visualizers defined for this crate.\n-    query debugger_visualizers(_: CrateNum) -> Vec<rustc_span::DebuggerVisualizerFile> {\n+    query debugger_visualizers(_: CrateNum) -> &'tcx Vec<rustc_span::DebuggerVisualizerFile> {\n         arena_cache\n         desc { \"looking up the debugger visualizers for this crate\" }\n         separate_provide_extern\n@@ -1820,7 +1819,7 @@ rustc_queries! {\n         desc { |tcx| \"finding names imported by glob use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n-    query stability_index(_: ()) -> stability::Index {\n+    query stability_index(_: ()) -> &'tcx stability::Index {\n         arena_cache\n         eval_always\n         desc { \"calculating the stability index for the local crate\" }\n@@ -1884,7 +1883,7 @@ rustc_queries! {\n     ///\n     /// This query returns an `&Arc` because codegen backends need the value even after the `TyCtxt`\n     /// has been destroyed.\n-    query output_filenames(_: ()) -> Arc<OutputFilenames> {\n+    query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n         feedable\n         desc { \"getting output filenames\" }\n         arena_cache\n@@ -2057,7 +2056,7 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    query supported_target_features(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n+    query supported_target_features(_: CrateNum) -> &'tcx FxHashMap<String, Option<Symbol>> {\n         arena_cache\n         eval_always\n         desc { \"looking up supported target features\" }\n@@ -2116,23 +2115,24 @@ rustc_queries! {\n     /// span) for an *existing* error. Therefore, it is best-effort, and may never handle\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n-    query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, traits::WellFormedLoc)) -> Option<traits::ObligationCause<'tcx>> {\n+    query diagnostic_hir_wf_check(\n+        key: (ty::Predicate<'tcx>, traits::WellFormedLoc)\n+    ) -> &'tcx Option<traits::ObligationCause<'tcx>> {\n         arena_cache\n         eval_always\n         no_hash\n         desc { \"performing HIR wf-checking for predicate `{:?}` at item `{:?}`\", key.0, key.1 }\n     }\n \n-\n     /// The list of backend features computed from CLI flags (`-Ctarget-cpu`, `-Ctarget-feature`,\n     /// `--target` and similar).\n-    query global_backend_features(_: ()) -> Vec<String> {\n+    query global_backend_features(_: ()) -> &'tcx Vec<String> {\n         arena_cache\n         eval_always\n         desc { \"computing the backend features for CLI flags\" }\n     }\n \n-    query generator_diagnostic_data(key: DefId) -> Option<GeneratorDiagnosticData<'tcx>> {\n+    query generator_diagnostic_data(key: DefId) -> &'tcx Option<GeneratorDiagnosticData<'tcx>> {\n         arena_cache\n         desc { |tcx| \"looking up generator diagnostic data of `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern"}, {"sha": "0a30ae9d0aa78522c461b8a6dff9c81d7e0b28e9", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -193,19 +193,24 @@ fn suggest_removing_unsized_bound(\n }\n \n /// Suggest restricting a type param with a new bound.\n+///\n+/// If `span_to_replace` is provided, then that span will be replaced with the\n+/// `constraint`. If one wasn't provided, then the full bound will be suggested.\n pub fn suggest_constraining_type_param(\n     tcx: TyCtxt<'_>,\n     generics: &hir::Generics<'_>,\n     err: &mut Diagnostic,\n     param_name: &str,\n     constraint: &str,\n     def_id: Option<DefId>,\n+    span_to_replace: Option<Span>,\n ) -> bool {\n     suggest_constraining_type_params(\n         tcx,\n         generics,\n         err,\n         [(param_name, constraint, def_id)].into_iter(),\n+        span_to_replace,\n     )\n }\n \n@@ -215,6 +220,7 @@ pub fn suggest_constraining_type_params<'a>(\n     generics: &hir::Generics<'_>,\n     err: &mut Diagnostic,\n     param_names_and_constraints: impl Iterator<Item = (&'a str, &'a str, Option<DefId>)>,\n+    span_to_replace: Option<Span>,\n ) -> bool {\n     let mut grouped = FxHashMap::default();\n     param_names_and_constraints.for_each(|(param_name, constraint, def_id)| {\n@@ -253,7 +259,9 @@ pub fn suggest_constraining_type_params<'a>(\n         let mut suggest_restrict = |span, bound_list_non_empty| {\n             suggestions.push((\n                 span,\n-                if bound_list_non_empty {\n+                if span_to_replace.is_some() {\n+                    constraint.clone()\n+                } else if bound_list_non_empty {\n                     format!(\" + {}\", constraint)\n                 } else {\n                     format!(\" {}\", constraint)\n@@ -262,6 +270,11 @@ pub fn suggest_constraining_type_params<'a>(\n             ))\n         };\n \n+        if let Some(span) = span_to_replace {\n+            suggest_restrict(span, true);\n+            continue;\n+        }\n+\n         // When the type parameter has been provided bounds\n         //\n         //    Message:"}, {"sha": "933aaadd62e1dd4a34dfc36410a192d904b2f259", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -112,15 +112,15 @@ macro_rules! query_helper_param_ty {\n     ($K:ty) => { $K };\n }\n \n-macro_rules! query_storage {\n-    ([][$K:ty, $V:ty]) => {\n-        <<$K as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n+macro_rules! query_if_arena {\n+    ([] $arena:ty, $no_arena:ty) => {\n+        $no_arena\n     };\n-    ([(arena_cache) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        <<$K as Key>::CacheSelector as CacheSelector<'tcx, $V>>::ArenaCache\n+    ([(arena_cache) $($rest:tt)*] $arena:ty, $no_arena:ty) => {\n+        $arena\n     };\n-    ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n-        query_storage!([$($modifiers)*][$($args)*])\n+    ([$other:tt $($modifiers:tt)*]$($args:tt)*) => {\n+        query_if_arena!([$($modifiers)*]$($args)*)\n     };\n }\n \n@@ -184,23 +184,30 @@ macro_rules! define_callbacks {\n \n             $(pub type $name<'tcx> = $($K)*;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n+        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n         pub mod query_values {\n             use super::*;\n \n-            $(pub type $name<'tcx> = $V;)*\n+            $(pub type $name<'tcx> = query_if_arena!([$($modifiers)*] <$V as Deref>::Target, $V);)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes)]\n+        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n         pub mod query_storage {\n             use super::*;\n \n-            $(pub type $name<'tcx> = query_storage!([$($modifiers)*][$($K)*, $V]);)*\n+            $(\n+                pub type $name<'tcx> = query_if_arena!([$($modifiers)*]\n+                    <<$($K)* as Key>::CacheSelector\n+                        as CacheSelector<'tcx, <$V as Deref>::Target>>::ArenaCache,\n+                    <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n+                );\n+            )*\n         }\n+\n         #[allow(nonstandard_style, unused_lifetimes)]\n         pub mod query_stored {\n             use super::*;\n \n-            $(pub type $name<'tcx> = <query_storage::$name<'tcx> as QueryStorage>::Stored;)*\n+            $(pub type $name<'tcx> = $V;)*\n         }\n \n         #[derive(Default)]\n@@ -226,7 +233,7 @@ macro_rules! define_callbacks {\n             $($(#[$attr])*\n             #[inline(always)]\n             #[must_use]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<'tcx>\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V\n             {\n                 self.at(DUMMY_SP).$name(key)\n             })*\n@@ -235,7 +242,7 @@ macro_rules! define_callbacks {\n         impl<'tcx> TyCtxtAt<'tcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> query_stored::$name<'tcx>\n+            pub fn $name(self, key: query_helper_param_ty!($($K)*)) -> $V\n             {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n@@ -306,7 +313,7 @@ macro_rules! define_callbacks {\n                 span: Span,\n                 key: query_keys::$name<'tcx>,\n                 mode: QueryMode,\n-            ) -> Option<query_stored::$name<'tcx>>;)*\n+            ) -> Option<$V>;)*\n         }\n     };\n }\n@@ -328,7 +335,7 @@ macro_rules! define_feedable {\n         $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n             $(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, value: $V) -> query_stored::$name<'tcx> {\n+            pub fn $name(self, value: query_values::$name<'tcx>) -> $V {\n                 let key = self.key().into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n "}, {"sha": "0d466bbe56e01d82b7d5550ca8dc2688495c3a0c", "filename": "compiler/rustc_mir_dataflow/src/drop_flag_effects.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,5 +1,5 @@\n use crate::elaborate_drops::DropFlagState;\n-use rustc_middle::mir::{self, Body, Location};\n+use rustc_middle::mir::{self, Body, Location, Terminator, TerminatorKind};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n@@ -194,6 +194,17 @@ pub fn drop_flag_effects_for_location<'tcx, F>(\n         on_all_children_bits(tcx, body, move_data, path, |mpi| callback(mpi, DropFlagState::Absent))\n     }\n \n+    // Drop does not count as a move but we should still consider the variable uninitialized.\n+    if let Some(Terminator { kind: TerminatorKind::Drop { place, .. }, .. }) =\n+        body.stmt_at(loc).right()\n+    {\n+        if let LookupResult::Exact(mpi) = move_data.rev_lookup.find(place.as_ref()) {\n+            on_all_children_bits(tcx, body, move_data, mpi, |mpi| {\n+                callback(mpi, DropFlagState::Absent)\n+            })\n+        }\n+    }\n+\n     debug!(\"drop_flag_effects: assignment for location({:?})\", loc);\n \n     for_location_inits(tcx, body, move_data, loc, |mpi| callback(mpi, DropFlagState::Present));"}, {"sha": "115c8afcce0cf7c15964bd53b175366c0ac6b7fd", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -376,7 +376,8 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n             | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Unreachable => {}\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. } => {}\n \n             TerminatorKind::Assert { ref cond, .. } => {\n                 self.gather_operand(cond);\n@@ -391,10 +392,6 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.create_move_path(place);\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n-\n-            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n-                self.gather_move(place);\n-            }\n             TerminatorKind::DropAndReplace { place, ref value, .. } => {\n                 self.create_move_path(place);\n                 self.gather_operand(value);"}, {"sha": "a6ef2a742c8736219f84946e85a8e6e44ee2c544", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -223,13 +223,13 @@ pub trait ValueAnalysis<'tcx> {\n         self.super_terminator(terminator, state)\n     }\n \n-    fn super_terminator(&self, terminator: &Terminator<'tcx>, _state: &mut State<Self::Value>) {\n+    fn super_terminator(&self, terminator: &Terminator<'tcx>, state: &mut State<Self::Value>) {\n         match &terminator.kind {\n             TerminatorKind::Call { .. } | TerminatorKind::InlineAsm { .. } => {\n                 // Effect is applied by `handle_call_return`.\n             }\n-            TerminatorKind::Drop { .. } => {\n-                // We don't track dropped places.\n+            TerminatorKind::Drop { place, .. } => {\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n             }\n             TerminatorKind::DropAndReplace { .. } | TerminatorKind::Yield { .. } => {\n                 // They would have an effect, but are not allowed in this phase."}, {"sha": "6e279232bcb48ce3e22ed586e0d9b6c96ec6dde9", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -153,8 +153,9 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &mut Operand<'tcx>, loc: Location) {\n         if let Operand::Move(place) = *operand\n-            && let Some(local) = place.as_local()\n-            && !self.fully_moved.contains(local)\n+            // A move out of a projection of a copy is equivalent to a copy of the original projection.\n+            && !place.has_deref()\n+            && !self.fully_moved.contains(place.local)\n         {\n             *operand = Operand::Copy(place);\n         }"}, {"sha": "c2ff8645635e01597ea6c0d55ece679df9e80f9f", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -18,6 +18,35 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use std::fmt;\n \n+/// During MIR building, Drop and DropAndReplace terminators are inserted in every place where a drop may occur.\n+/// However, in this phase, the presence of these terminators does not guarantee that a destructor will run,\n+/// as the target of the drop may be uninitialized.\n+/// In general, the compiler cannot determine at compile time whether a destructor will run or not.\n+///\n+/// At a high level, this pass refines Drop and DropAndReplace to only run the destructor if the\n+/// target is initialized. The way this is achievied is by inserting drop flags for every variable\n+/// that may be dropped, and then using those flags to determine whether a destructor should run.\n+/// This pass also removes DropAndReplace, replacing it with a Drop paired with an assign statement.\n+/// Once this is complete, Drop terminators in the MIR correspond to a call to the \"drop glue\" or\n+/// \"drop shim\" for the type of the dropped place.\n+///\n+/// This pass relies on dropped places having an associated move path, which is then used to determine\n+/// the initialization status of the place and its descendants.\n+/// It's worth noting that a MIR containing a Drop without an associated move path is probably ill formed,\n+/// as it would allow running a destructor on a place behind a reference:\n+///\n+/// ```text\n+// fn drop_term<T>(t: &mut T) {\n+//     mir!(\n+//         {\n+//             Drop(*t, exit)\n+//         }\n+//         exit = {\n+//             Return()\n+//         }\n+//     )\n+// }\n+/// ```\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {"}, {"sha": "5b92563fc358b68b1bbf824feacef2d9542e4a09", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -694,8 +694,9 @@ impl<'a> Parser<'a> {\n         // `where`, so stop if it's it.\n         // We also continue if we find types (not traits), again for error recovery.\n         while self.can_begin_bound()\n-            || self.token.can_begin_type()\n-            || (self.token.is_reserved_ident() && !self.token.is_keyword(kw::Where))\n+            || (self.may_recover()\n+                && (self.token.can_begin_type()\n+                    || (self.token.is_reserved_ident() && !self.token.is_keyword(kw::Where))))\n         {\n             if self.token.is_keyword(kw::Dyn) {\n                 // Account for `&dyn Trait + dyn Other`."}, {"sha": "9443ded704d63059c8ae48cdd7acc859876ecc74", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -47,7 +47,7 @@ impl DepNodeIndex {\n }\n \n impl From<DepNodeIndex> for QueryInvocationId {\n-    #[inline]\n+    #[inline(always)]\n     fn from(dep_node_index: DepNodeIndex) -> Self {\n         QueryInvocationId(dep_node_index.as_u32())\n     }"}, {"sha": "9f875b4373173cac741bc7fdd5058627de025b0e", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -23,10 +23,6 @@ pub trait CacheSelector<'tcx, V> {\n pub trait QueryStorage {\n     type Value: Debug;\n     type Stored: Copy;\n-\n-    /// Store a value without putting it in the cache.\n-    /// This is meant to be used with cycle errors.\n-    fn store_nocache(&self, value: Self::Value) -> Self::Stored;\n }\n \n pub trait QueryCache: QueryStorage + Sized {\n@@ -68,12 +64,6 @@ impl<K, V> Default for DefaultCache<K, V> {\n impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n     type Value = V;\n     type Stored = V;\n-\n-    #[inline]\n-    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n-        // We have no dedicated storage\n-        value\n-    }\n }\n \n impl<K, V> QueryCache for DefaultCache<K, V>\n@@ -144,13 +134,6 @@ impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n impl<'tcx, K: Eq + Hash, V: Debug + 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n     type Value = V;\n     type Stored = &'tcx V;\n-\n-    #[inline]\n-    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n-        let value = self.arena.alloc((value, DepNodeIndex::INVALID));\n-        let value = unsafe { &*(&value.0 as *const _) };\n-        &value\n-    }\n }\n \n impl<'tcx, K, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V>\n@@ -231,12 +214,6 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n     type Value = V;\n     type Stored = V;\n-\n-    #[inline]\n-    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n-        // We have no dedicated storage\n-        value\n-    }\n }\n \n impl<K, V> QueryCache for VecCache<K, V>\n@@ -309,13 +286,6 @@ impl<'tcx, K: Idx, V> Default for VecArenaCache<'tcx, K, V> {\n impl<'tcx, K: Eq + Idx, V: Debug + 'tcx> QueryStorage for VecArenaCache<'tcx, K, V> {\n     type Value = V;\n     type Stored = &'tcx V;\n-\n-    #[inline]\n-    fn store_nocache(&self, value: Self::Value) -> Self::Stored {\n-        let value = self.arena.alloc((value, DepNodeIndex::INVALID));\n-        let value = unsafe { &*(&value.0 as *const _) };\n-        &value\n-    }\n }\n \n impl<'tcx, K, V: 'tcx> QueryCache for VecArenaCache<'tcx, K, V>"}, {"sha": "ed66d1929c5e78d1843c78fe756f057ce4bf8096", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -121,20 +121,17 @@ where\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<Qcx, V, R, D: DepKind>(\n+fn mk_cycle<Qcx, R, D: DepKind>(\n     qcx: Qcx,\n     cycle_error: CycleError<D>,\n     handler: HandleCycleError,\n-    cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where\n     Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n-    V: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n-    R: Copy,\n+    R: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n-    let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n-    cache.store_nocache(value)\n+    handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler)\n }\n \n fn handle_cycle_error<Tcx, V>(\n@@ -346,9 +343,7 @@ where\n {\n     match cache.lookup(&key) {\n         Some((value, index)) => {\n-            if std::intrinsics::unlikely(tcx.profiler().enabled()) {\n-                tcx.profiler().query_cache_hit(index.into());\n-            }\n+            tcx.profiler().query_cache_hit(index.into());\n             tcx.dep_graph().read_index(index);\n             Some(value)\n         }\n@@ -399,7 +394,7 @@ where\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(qcx, error, Q::HANDLE_CYCLE_ERROR, cache);\n+            let result = mk_cycle(qcx, error, Q::HANDLE_CYCLE_ERROR);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n@@ -408,9 +403,7 @@ where\n                 panic!(\"value must be in cache after waiting\")\n             };\n \n-            if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n-                qcx.dep_context().profiler().query_cache_hit(index.into());\n-            }\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n             query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n \n             (v, Some(index))\n@@ -776,9 +769,7 @@ where\n     // Ensure that only one of them runs the query.\n     let cache = Q::query_cache(qcx);\n     if let Some((_, index)) = cache.lookup(&key) {\n-        if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n-            qcx.dep_context().profiler().query_cache_hit(index.into());\n-        }\n+        qcx.dep_context().profiler().query_cache_hit(index.into());\n         return;\n     }\n "}, {"sha": "61cb81aec3de07d583251348574cbc3cfeac54ec", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1413,8 +1413,6 @@ options! {\n         \"what location details should be tracked when using caller_location, either \\\n         `none`, or a comma separated list of location details, for which \\\n         valid options are `file`, `line`, and `column` (default: `file,line,column`)\"),\n-    log_backtrace: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"add a backtrace along with logging\"),\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "ef417d3e0a708211a369a964f1c139375d9330c1", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1085,7 +1085,7 @@ symbols! {\n         plugins,\n         pointee_trait,\n         pointer,\n-        pointer_sized,\n+        pointer_like,\n         poll,\n         position,\n         post_dash_lto: \"post-lto\","}, {"sha": "8525b96c0c21ffdf2927a63b6c2ab5822095bd3a", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -128,9 +128,9 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n-    // A type is `PointerSized` if we can compute its layout, and that layout\n+    // A type is `PointerLike` if we can compute its layout, and that layout\n     // matches the layout of `usize`.\n-    fn consider_builtin_pointer_sized_candidate(\n+    fn consider_builtin_pointer_like_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n@@ -312,8 +312,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             || lang_items.clone_trait() == Some(trait_def_id)\n         {\n             G::consider_builtin_copy_clone_candidate(self, goal)\n-        } else if lang_items.pointer_sized() == Some(trait_def_id) {\n-            G::consider_builtin_pointer_sized_candidate(self, goal)\n+        } else if lang_items.pointer_like() == Some(trait_def_id) {\n+            G::consider_builtin_pointer_like_candidate(self, goal)\n         } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n             G::consider_builtin_fn_trait_candidates(self, goal, kind)\n         } else if lang_items.tuple_trait() == Some(trait_def_id) {"}, {"sha": "c1936b7dbe41ec0743130a33af65837e39b92345", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::Subtype(pred) => {\n-                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                    let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((pred.a, pred.b)),\n                                     );\n                                     let expected_found = ExpectedFound::new(true, a, b);\n@@ -84,7 +84,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::Coerce(pred) => {\n-                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                    let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((pred.a, pred.b)),\n                                     );\n                                     let expected_found = ExpectedFound::new(false, a, b);\n@@ -94,7 +94,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::ConstEquate(a, b) => {\n-                                    let (a, b) = infcx.replace_bound_vars_with_placeholders(\n+                                    let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((a, b)),\n                                     );\n                                     let expected_found = ExpectedFound::new(true, a, b);"}, {"sha": "36f987c9f9cb6d3e1a2db0bbcd2e588e9c40c373", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -26,7 +26,7 @@ pub(super) trait InferCtxtExt<'tcx> {\n         rhs: T,\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n \n-    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n         &self,\n         value: ty::Binder<'tcx, T>,\n     ) -> T;\n@@ -65,11 +65,11 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             })\n     }\n \n-    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+    fn instantiate_binder_with_infer<T: TypeFoldable<'tcx> + Copy>(\n         &self,\n         value: ty::Binder<'tcx, T>,\n     ) -> T {\n-        self.replace_bound_vars_with_fresh_vars(\n+        self.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::HigherRankedType,\n             value,"}, {"sha": "9f092b6018f483303bc1691784701619f33fff14", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            let kind = self.infcx.replace_bound_vars_with_placeholders(kind);\n+            let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n             let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n             let (_, certainty) = self.evaluate_goal(goal)?;\n             self.make_canonical_response(certainty)"}, {"sha": "e3ec71d1b4f7375643eef5d6393af37c1b140675", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -323,7 +323,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         {\n             ecx.infcx.probe(|_| {\n                 let assumption_projection_pred =\n-                    ecx.infcx.instantiate_bound_vars_with_infer(poly_projection_pred);\n+                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n                 let nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n@@ -370,11 +370,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         bug!(\"`Copy`/`Clone` does not have an associated type: {:?}\", goal);\n     }\n \n-    fn consider_builtin_pointer_sized_candidate(\n+    fn consider_builtin_pointer_like_candidate(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        bug!(\"`PointerSized` does not have an associated type: {:?}\", goal);\n+        bug!(\"`PointerLike` does not have an associated type: {:?}\", goal);\n     }\n \n     fn consider_builtin_fn_trait_candidates("}, {"sha": "a2ca4bc189c87faae28f66fa694633ab1ade0125", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -7,7 +7,7 @@ use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::TyCtxt;\n-use std::collections::hash_map::Entry;\n+use std::{collections::hash_map::Entry, mem};\n \n rustc_index::newtype_index! {\n     pub struct StackDepth {}\n@@ -134,12 +134,15 @@ impl<'tcx> SearchGraph<'tcx> {\n         let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n+        // We eagerly update the response in the cache here. If we have to reevaluate\n+        // this goal we use the new response when hitting a cycle, and we definitely\n+        // want to access the final response whenever we look at the cache.\n+        let prev_response = mem::replace(&mut provisional_entry.response, response);\n+\n         // Was the current goal the root of a cycle and was the provisional response\n         // different from the final one.\n-        if has_been_used && provisional_entry.response != response {\n-            // If so, update the provisional reponse for this goal...\n-            provisional_entry.response = response;\n-            // ...remove all entries whose result depends on this goal\n+        if has_been_used && prev_response != response {\n+            // If so, remove all entries whose result depends on this goal\n             // from the provisional cache...\n             //\n             // That's not completely correct, as a nested goal can also"}, {"sha": "06a72e95d4905461814477d70ad25e42d060f91b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             // FIXME: Constness and polarity\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred =\n-                    ecx.infcx.instantiate_bound_vars_with_infer(poly_trait_pred);\n+                    ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n                 let nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n@@ -131,7 +131,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         )\n     }\n \n-    fn consider_builtin_pointer_sized_candidate(\n+    fn consider_builtin_pointer_like_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {"}, {"sha": "1ee35a86e626424a3c6a0871f9b84f3f01145423", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -54,7 +54,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         }\n \n         ty::GeneratorWitness(types) => {\n-            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n         }\n \n         ty::GeneratorWitnessMIR(..) => todo!(),\n@@ -174,7 +174,7 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         }\n \n         ty::GeneratorWitness(types) => {\n-            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+            Ok(infcx.instantiate_binder_with_placeholders(types).to_vec())\n         }\n \n         ty::GeneratorWitnessMIR(..) => todo!(),"}, {"sha": "84045c4d0edea11f5e61f766a0f1bc3cf1f607e8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -22,7 +22,7 @@ pub fn recompute_applicable_impls<'tcx>(\n     let impl_may_apply = |impl_def_id| {\n         let ocx = ObligationCtxt::new_in_snapshot(infcx);\n         let placeholder_obligation =\n-            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let obligation_trait_ref =\n             ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n \n@@ -47,11 +47,11 @@ pub fn recompute_applicable_impls<'tcx>(\n     let param_env_candidate_may_apply = |poly_trait_predicate: ty::PolyTraitPredicate<'tcx>| {\n         let ocx = ObligationCtxt::new_in_snapshot(infcx);\n         let placeholder_obligation =\n-            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let obligation_trait_ref =\n             ocx.normalize(&ObligationCause::dummy(), param_env, placeholder_obligation.trait_ref);\n \n-        let param_env_predicate = infcx.replace_bound_vars_with_fresh_vars(\n+        let param_env_predicate = infcx.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::HigherRankedType,\n             poly_trait_predicate,"}, {"sha": "cf1e05ada4713615087d28181215dd5dd9d95660", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1716,7 +1716,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let (values, err) = if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n                 bound_predicate.skip_binder()\n             {\n-                let data = self.replace_bound_vars_with_fresh_vars(\n+                let data = self.instantiate_binder_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     bound_predicate.rebind(data),"}, {"sha": "59aef52910ee3f287b359383db57b2fcb1e31d61", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -679,6 +679,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         &param_name,\n                         &constraint,\n                         Some(trait_pred.def_id()),\n+                        None,\n                     ) {\n                         return;\n                     }\n@@ -897,7 +898,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             return false;\n         }\n \n-        let self_ty = self.replace_bound_vars_with_fresh_vars(\n+        let self_ty = self.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n             trait_pred.self_ty(),\n@@ -1087,6 +1088,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     param.name.as_str(),\n                     \"Clone\",\n                     Some(clone_trait),\n+                    None,\n                 );\n             }\n             err.span_suggestion_verbose(\n@@ -1189,7 +1191,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         }) else { return None; };\n \n-        let output = self.replace_bound_vars_with_fresh_vars(\n+        let output = self.instantiate_binder_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n             output,\n@@ -1198,7 +1200,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .skip_binder()\n             .iter()\n             .map(|ty| {\n-                self.replace_bound_vars_with_fresh_vars(\n+                self.instantiate_binder_with_fresh_vars(\n                     DUMMY_SP,\n                     LateBoundRegionConversionTime::FnCall,\n                     inputs.rebind(*ty),\n@@ -3804,13 +3806,13 @@ fn hint_missing_borrow<'tcx>(\n     err: &mut Diagnostic,\n ) {\n     let found_args = match found.kind() {\n-        ty::FnPtr(f) => infcx.replace_bound_vars_with_placeholders(*f).inputs().iter(),\n+        ty::FnPtr(f) => infcx.instantiate_binder_with_placeholders(*f).inputs().iter(),\n         kind => {\n             span_bug!(span, \"found was converted to a FnPtr above but is now {:?}\", kind)\n         }\n     };\n     let expected_args = match expected.kind() {\n-        ty::FnPtr(f) => infcx.replace_bound_vars_with_placeholders(*f).inputs().iter(),\n+        ty::FnPtr(f) => infcx.instantiate_binder_with_placeholders(*f).inputs().iter(),\n         kind => {\n             span_bug!(span, \"expected was converted to a FnPtr above but is now {:?}\", kind)\n         }"}, {"sha": "3adc1e62e0d4853368bb663dba6e88d5f978431d", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => {\n                     let pred =\n-                        ty::Binder::dummy(infcx.replace_bound_vars_with_placeholders(binder));\n+                        ty::Binder::dummy(infcx.instantiate_binder_with_placeholders(binder));\n                     ProcessResult::Changed(mk_pending(vec![obligation.with(infcx.tcx, pred)]))\n                 }\n                 ty::PredicateKind::Ambiguous => ProcessResult::Unchanged,"}, {"sha": "aa81bc640aa6c56367e4e9cdf87abf9e7e73984e", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -215,7 +215,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n     let r = infcx.commit_if_ok(|_snapshot| {\n         let old_universe = infcx.universe();\n         let placeholder_predicate =\n-            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let new_universe = infcx.universe();\n \n         let placeholder_obligation = obligation.with(infcx.tcx, placeholder_predicate);\n@@ -2046,7 +2046,7 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n     let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n \n-    let cache_entry = infcx.replace_bound_vars_with_fresh_vars(\n+    let cache_entry = infcx.instantiate_binder_with_fresh_vars(\n         cause.span,\n         LateBoundRegionConversionTime::HigherRankedType,\n         poly_cache_entry,"}, {"sha": "e9f7c3bc4cca2ecb93a54bb13e454f2e46d12818", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -94,7 +94,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_candidates_for_transmutability(obligation, &mut candidates);\n             } else if lang_items.tuple_trait() == Some(def_id) {\n                 self.assemble_candidate_for_tuple(obligation, &mut candidates);\n-            } else if lang_items.pointer_sized() == Some(def_id) {\n+            } else if lang_items.pointer_like() == Some(def_id) {\n                 self.assemble_candidate_for_ptr_sized(obligation, &mut candidates);\n             } else {\n                 if lang_items.clone_trait() == Some(def_id) {\n@@ -488,7 +488,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n             let placeholder_trait_predicate =\n-                self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n+                self.infcx.instantiate_binder_with_placeholders(poly_trait_predicate);\n \n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the"}, {"sha": "fcc4820c2a6b6ff424131ceaac1a69ec4b5399a8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -151,7 +151,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx.replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+            self.infcx.instantiate_binder_with_placeholders(trait_predicate).trait_ref;\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n@@ -336,7 +336,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n \n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n+            let trait_ref = self.infcx.instantiate_binder_with_placeholders(poly_trait_ref);\n             let trait_obligations: Vec<PredicateObligation<'_>> = self.impl_or_trait_obligations(\n                 &cause,\n                 obligation.recursion_depth + 1,\n@@ -427,7 +427,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n-        let trait_predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+        let trait_predicate = self.infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());\n         let obligation_trait_ref = ty::Binder::dummy(trait_predicate.trait_ref);\n         let ty::Dynamic(data, ..) = *self_ty.kind() else {\n@@ -437,7 +437,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let object_trait_ref = data.principal().unwrap_or_else(|| {\n             span_bug!(obligation.cause.span, \"object candidate with no principal\")\n         });\n-        let object_trait_ref = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let object_trait_ref = self.infcx.instantiate_binder_with_fresh_vars(\n             obligation.cause.span,\n             HigherRankedType,\n             object_trait_ref,\n@@ -629,7 +629,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Confirm the `type Output: Sized;` bound that is present on `FnOnce`\n-        let output_ty = self.infcx.replace_bound_vars_with_placeholders(sig.output());\n+        let output_ty = self.infcx.instantiate_binder_with_placeholders(sig.output());\n         let output_ty = normalize_with_depth_to(\n             self,\n             obligation.param_env,\n@@ -652,7 +652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_trait_alias_candidate\");\n \n         let alias_def_id = obligation.predicate.def_id();\n-        let predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+        let predicate = self.infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let trait_ref = predicate.trait_ref;\n         let trait_def_id = trait_ref.def_id;\n         let substs = trait_ref.substs;"}, {"sha": "984d6fde2686c58384a99a272062b95191794f84", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1618,7 +1618,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> smallvec::SmallVec<[(usize, ty::BoundConstness); 2]> {\n         let poly_trait_predicate = self.infcx.resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n-            self.infcx.replace_bound_vars_with_placeholders(poly_trait_predicate);\n+            self.infcx.instantiate_binder_with_placeholders(poly_trait_predicate);\n         debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n@@ -1738,7 +1738,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         potentially_unnormalized_candidates: bool,\n     ) -> ProjectionMatchesProjection {\n         let mut nested_obligations = Vec::new();\n-        let infer_predicate = self.infcx.replace_bound_vars_with_fresh_vars(\n+        let infer_predicate = self.infcx.instantiate_binder_with_fresh_vars(\n             obligation.cause.span,\n             LateBoundRegionConversionTime::HigherRankedType,\n             env_predicate,\n@@ -2339,7 +2339,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .flat_map(|ty| {\n                 let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/\n \n-                let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n+                let placeholder_ty = self.infcx.instantiate_binder_with_placeholders(ty);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     ensure_sufficient_stack(|| {\n                         project::normalize_with_depth(\n@@ -2418,7 +2418,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<Normalized<'tcx, SubstsRef<'tcx>>, ()> {\n         let placeholder_obligation =\n-            self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+            self.infcx.instantiate_binder_with_placeholders(obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);"}, {"sha": "4aa958878d4b304678644cd7eb50c5d92812371a", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -220,7 +220,8 @@ bitflags! {\n                                           // which is different from how types/const are freshened.\n                                           | TypeFlags::HAS_TY_FRESH.bits\n                                           | TypeFlags::HAS_CT_FRESH.bits\n-                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n+                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits\n+                                          | TypeFlags::HAS_RE_ERASED.bits;\n \n         /// Does this have `Projection`?\n         const HAS_TY_PROJECTION           = 1 << 10;"}, {"sha": "3ede95e84313dde8cdc4e15a01dd8d4693bb6e3a", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -310,47 +310,51 @@ impl<I: Interner> Clone for TyKind<I> {\n impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n     fn eq(&self, other: &TyKind<I>) -> bool {\n-        tykind_discriminant(self) == tykind_discriminant(other)\n-            && match (self, other) {\n-                (Int(a_i), Int(b_i)) => a_i == b_i,\n-                (Uint(a_u), Uint(b_u)) => a_u == b_u,\n-                (Float(a_f), Float(b_f)) => a_f == b_f,\n-                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d == b_d && a_s == b_s,\n-                (Foreign(a_d), Foreign(b_d)) => a_d == b_d,\n-                (Array(a_t, a_c), Array(b_t, b_c)) => a_t == b_t && a_c == b_c,\n-                (Slice(a_t), Slice(b_t)) => a_t == b_t,\n-                (RawPtr(a_t), RawPtr(b_t)) => a_t == b_t,\n-                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => a_r == b_r && a_t == b_t && a_m == b_m,\n-                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d == b_d && a_s == b_s,\n-                (FnPtr(a_s), FnPtr(b_s)) => a_s == b_s,\n-                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n-                    a_p == b_p && a_r == b_r && a_repr == b_repr\n-                }\n-                (Closure(a_d, a_s), Closure(b_d, b_s)) => a_d == b_d && a_s == b_s,\n-                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n-                    a_d == b_d && a_s == b_s && a_m == b_m\n-                }\n-                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n-                (\n-                    &GeneratorWitnessMIR(ref a_d, ref a_s),\n-                    &GeneratorWitnessMIR(ref b_d, ref b_s),\n-                ) => a_d == b_d && a_s == b_s,\n-                (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n-                (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i == b_i && a_p == b_p,\n-                (Param(a_p), Param(b_p)) => a_p == b_p,\n-                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n-                (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n-                (Infer(a_t), Infer(b_t)) => a_t == b_t,\n-                (Error(a_e), Error(b_e)) => a_e == b_e,\n-                (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => true,\n-                _ => {\n-                    debug_assert!(\n-                        false,\n-                        \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\"\n-                    );\n-                    true\n-                }\n+        // You might expect this `match` to be preceded with this:\n+        //\n+        //   tykind_discriminant(self) == tykind_discriminant(other) &&\n+        //\n+        // but the data patterns in practice are such that a comparison\n+        // succeeds 99%+ of the time, and it's faster to omit it.\n+        match (self, other) {\n+            (Int(a_i), Int(b_i)) => a_i == b_i,\n+            (Uint(a_u), Uint(b_u)) => a_u == b_u,\n+            (Float(a_f), Float(b_f)) => a_f == b_f,\n+            (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+            (Foreign(a_d), Foreign(b_d)) => a_d == b_d,\n+            (Array(a_t, a_c), Array(b_t, b_c)) => a_t == b_t && a_c == b_c,\n+            (Slice(a_t), Slice(b_t)) => a_t == b_t,\n+            (RawPtr(a_t), RawPtr(b_t)) => a_t == b_t,\n+            (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => a_r == b_r && a_t == b_t && a_m == b_m,\n+            (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+            (FnPtr(a_s), FnPtr(b_s)) => a_s == b_s,\n+            (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                a_p == b_p && a_r == b_r && a_repr == b_repr\n             }\n+            (Closure(a_d, a_s), Closure(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+            (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                a_d == b_d && a_s == b_s && a_m == b_m\n+            }\n+            (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n+            (&GeneratorWitnessMIR(ref a_d, ref a_s), &GeneratorWitnessMIR(ref b_d, ref b_s)) => {\n+                a_d == b_d && a_s == b_s\n+            }\n+            (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n+            (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i == b_i && a_p == b_p,\n+            (Param(a_p), Param(b_p)) => a_p == b_p,\n+            (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n+            (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n+            (Infer(a_t), Infer(b_t)) => a_t == b_t,\n+            (Error(a_e), Error(b_e)) => a_e == b_e,\n+            (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => true,\n+            _ => {\n+                debug_assert!(\n+                    tykind_discriminant(self) != tykind_discriminant(other),\n+                    \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\"\n+                );\n+                false\n+            }\n+        }\n     }\n }\n \n@@ -408,7 +412,7 @@ impl<I: Interner> Ord for TyKind<I> {\n                 (Error(a_e), Error(b_e)) => a_e.cmp(b_e),\n                 (Bool, Bool) | (Char, Char) | (Str, Str) | (Never, Never) => Ordering::Equal,\n                 _ => {\n-                    debug_assert!(false, \"This branch must be unreachable, maybe the match is missing an arm? self = self = {self:?}, other = {other:?}\");\n+                    debug_assert!(false, \"This branch must be unreachable, maybe the match is missing an arm? self = {self:?}, other = {other:?}\");\n                     Ordering::Equal\n                 }\n             }"}, {"sha": "f99395c72aa034627e3e130f8d370f6b6e3c95c2", "filename": "library/alloc/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -991,12 +991,6 @@ impl IntoStringError {\n     pub fn utf8_error(&self) -> Utf8Error {\n         self.error\n     }\n-\n-    #[doc(hidden)]\n-    #[unstable(feature = \"cstr_internals\", issue = \"none\")]\n-    pub fn __source(&self) -> &Utf8Error {\n-        &self.error\n-    }\n }\n \n impl IntoStringError {\n@@ -1141,6 +1135,6 @@ impl core::error::Error for IntoStringError {\n     }\n \n     fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {\n-        Some(self.__source())\n+        Some(&self.error)\n     }\n }"}, {"sha": "e9cc3875f683b1cf09c301775eb249ce87734920", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -116,7 +116,6 @@\n #![feature(const_eval_select)]\n #![feature(const_pin)]\n #![feature(const_waker)]\n-#![feature(cstr_from_bytes_until_nul)]\n #![feature(dispatch_from_dyn)]\n #![feature(error_generic_member_access)]\n #![feature(error_in_core)]"}, {"sha": "7565918851554bd5de13ae1f88ba4ef551fd3119", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -928,12 +928,12 @@ impl String {\n \n     /// Copies elements from `src` range to the end of the string.\n     ///\n-    /// ## Panics\n+    /// # Panics\n     ///\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n-    /// ## Examples\n+    /// # Examples\n     ///\n     /// ```\n     /// #![feature(string_extend_from_within)]"}, {"sha": "5decd7d5a65bbb0031432e113f0dbaedbffa7c15", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -131,28 +131,15 @@ pub struct TryFromSliceError(());\n impl fmt::Display for TryFromSliceError {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.__description(), f)\n+        #[allow(deprecated)]\n+        self.description().fmt(f)\n     }\n }\n \n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl Error for TryFromSliceError {\n     #[allow(deprecated)]\n     fn description(&self) -> &str {\n-        self.__description()\n-    }\n-}\n-\n-impl TryFromSliceError {\n-    #[unstable(\n-        feature = \"array_error_internals\",\n-        reason = \"available through Error trait and this method should not \\\n-                     be exposed publicly\",\n-        issue = \"none\"\n-    )]\n-    #[inline]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n         \"could not convert slice to array\"\n     }\n }"}, {"sha": "136bbcb8b21b4c020854157102e3276954325217", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -2,6 +2,7 @@\n \n use crate::char::TryFromCharError;\n use crate::convert::TryFrom;\n+use crate::error::Error;\n use crate::fmt;\n use crate::mem::transmute;\n use crate::str::FromStr;\n@@ -150,31 +151,28 @@ pub struct ParseCharError {\n     kind: CharErrorKind,\n }\n \n-impl ParseCharError {\n-    #[unstable(\n-        feature = \"char_error_internals\",\n-        reason = \"this method should not be available publicly\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum CharErrorKind {\n+    EmptyString,\n+    TooManyChars,\n+}\n+\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+impl Error for ParseCharError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n         match self.kind {\n             CharErrorKind::EmptyString => \"cannot parse char from empty string\",\n             CharErrorKind::TooManyChars => \"too many characters in string\",\n         }\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum CharErrorKind {\n-    EmptyString,\n-    TooManyChars,\n-}\n-\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n impl fmt::Display for ParseCharError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.__description().fmt(f)\n+        #[allow(deprecated)]\n+        self.description().fmt(f)\n     }\n }\n "}, {"sha": "571bc4bcfd13dc3670bd8e0914978c88f007e38c", "filename": "library/core/src/error.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -486,26 +486,10 @@ impl Error for crate::char::CharTryFromError {\n     }\n }\n \n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-impl Error for crate::char::ParseCharError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        self.__description()\n-    }\n-}\n-\n #[stable(feature = \"duration_checked_float\", since = \"1.66.0\")]\n impl Error for crate::time::TryFromFloatSecsError {}\n \n-#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n-impl Error for crate::ffi::FromBytesWithNulError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        self.__description()\n-    }\n-}\n-\n-#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+#[stable(feature = \"cstr_from_bytes_until_nul\", since = \"CURRENT_RUSTC_VERSION\")]\n impl Error for crate::ffi::FromBytesUntilNulError {}\n \n #[unstable(feature = \"get_many_mut\", issue = \"104642\")]"}, {"sha": "cd00fd0daf9e18dd14a29d547779dd9cb46e723f", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,4 +1,5 @@\n use crate::cmp::Ordering;\n+use crate::error::Error;\n use crate::ffi::c_char;\n use crate::fmt;\n use crate::intrinsics;\n@@ -129,10 +130,12 @@ impl FromBytesWithNulError {\n     const fn not_nul_terminated() -> FromBytesWithNulError {\n         FromBytesWithNulError { kind: FromBytesWithNulErrorKind::NotNulTerminated }\n     }\n+}\n \n-    #[doc(hidden)]\n-    #[unstable(feature = \"cstr_internals\", issue = \"none\")]\n-    pub fn __description(&self) -> &str {\n+#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n+impl Error for FromBytesWithNulError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n         match self.kind {\n             FromBytesWithNulErrorKind::InteriorNul(..) => {\n                 \"data provided contains an interior nul byte\"\n@@ -150,10 +153,10 @@ impl FromBytesWithNulError {\n /// This error is created by the [`CStr::from_bytes_until_nul`] method.\n ///\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+#[stable(feature = \"cstr_from_bytes_until_nul\", since = \"CURRENT_RUSTC_VERSION\")]\n pub struct FromBytesUntilNulError(());\n \n-#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+#[stable(feature = \"cstr_from_bytes_until_nul\", since = \"CURRENT_RUSTC_VERSION\")]\n impl fmt::Display for FromBytesUntilNulError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"data provided does not contain a nul\")\n@@ -180,7 +183,7 @@ impl Default for &CStr {\n impl fmt::Display for FromBytesWithNulError {\n     #[allow(deprecated, deprecated_in_future)]\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.__description())?;\n+        f.write_str(self.description())?;\n         if let FromBytesWithNulErrorKind::InteriorNul(pos) = self.kind {\n             write!(f, \" at byte pos {pos}\")?;\n         }\n@@ -306,8 +309,6 @@ impl CStr {\n     ///\n     /// # Examples\n     /// ```\n-    /// #![feature(cstr_from_bytes_until_nul)]\n-    ///\n     /// use std::ffi::CStr;\n     ///\n     /// let mut buffer = [0u8; 16];\n@@ -322,8 +323,9 @@ impl CStr {\n     /// assert_eq!(c_str.to_str().unwrap(), \"AAAAAAAA\");\n     /// ```\n     ///\n-    #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n-    #[rustc_const_unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+    #[rustc_allow_const_fn_unstable(const_slice_index)]\n+    #[stable(feature = \"cstr_from_bytes_until_nul\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"cstr_from_bytes_until_nul\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub const fn from_bytes_until_nul(bytes: &[u8]) -> Result<&CStr, FromBytesUntilNulError> {\n         let nul_pos = memchr::memchr(0, bytes);\n         match nul_pos {"}, {"sha": "e11bca5962a156a9059d7a8ceb561731fe68ee53", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -872,13 +872,14 @@ pub trait Destruct {}\n pub trait Tuple {}\n \n /// A marker for things\n-#[unstable(feature = \"pointer_sized_trait\", issue = \"none\")]\n-#[lang = \"pointer_sized\"]\n+#[unstable(feature = \"pointer_like_trait\", issue = \"none\")]\n+#[cfg_attr(bootstrap, lang = \"pointer_sized\")]\n+#[cfg_attr(not(bootstrap), lang = \"pointer_like\")]\n #[rustc_on_unimplemented(\n-    message = \"`{Self}` needs to be a pointer-sized type\",\n-    label = \"`{Self}` needs to be a pointer-sized type\"\n+    message = \"`{Self}` needs to have the same alignment and size as a pointer\",\n+    label = \"`{Self}` needs to be a pointer-like type\"\n )]\n-pub trait PointerSized {}\n+pub trait PointerLike {}\n \n /// Implementations of `Copy` for primitive types.\n ///"}, {"sha": "f8d493e8b6276210b85c594eb208f5edb8ea0164", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -75,6 +75,7 @@\n     issue = \"none\"\n )]\n \n+use crate::error::Error;\n use crate::fmt;\n use crate::str::FromStr;\n \n@@ -182,15 +183,10 @@ enum FloatErrorKind {\n     Invalid,\n }\n \n-impl ParseFloatError {\n-    #[unstable(\n-        feature = \"int_error_internals\",\n-        reason = \"available through Error trait and this method should \\\n-                  not be exposed publicly\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseFloatError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n         match self.kind {\n             FloatErrorKind::Empty => \"cannot parse float from empty string\",\n             FloatErrorKind::Invalid => \"invalid float literal\",\n@@ -201,7 +197,8 @@ impl ParseFloatError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for ParseFloatError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.__description().fmt(f)\n+        #[allow(deprecated)]\n+        self.description().fmt(f)\n     }\n }\n "}, {"sha": "1bae4efe7d936110605d6f1aae8dfb55995f0f14", "filename": "library/core/src/num/error.rs", "status": "modified", "additions": 18, "deletions": 39, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -9,23 +9,19 @@ use crate::fmt;\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct TryFromIntError(pub(crate) ());\n \n-impl TryFromIntError {\n-    #[unstable(\n-        feature = \"int_error_internals\",\n-        reason = \"available through Error trait and this method should \\\n-                  not be exposed publicly\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        \"out of range integral type conversion attempted\"\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl fmt::Display for TryFromIntError {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        #[allow(deprecated)]\n+        self.description().fmt(fmt)\n     }\n }\n \n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl fmt::Display for TryFromIntError {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.__description().fmt(fmt)\n+impl Error for TryFromIntError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        \"out of range integral type conversion attempted\"\n     }\n }\n \n@@ -121,43 +117,26 @@ impl ParseIntError {\n     pub fn kind(&self) -> &IntErrorKind {\n         &self.kind\n     }\n-    #[unstable(\n-        feature = \"int_error_internals\",\n-        reason = \"available through Error trait and this method should \\\n-                  not be exposed publicly\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        match self.kind {\n-            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n-            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n-            IntErrorKind::PosOverflow => \"number too large to fit in target type\",\n-            IntErrorKind::NegOverflow => \"number too small to fit in target type\",\n-            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for ParseIntError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.__description().fmt(f)\n+        #[allow(deprecated)]\n+        self.description().fmt(f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for ParseIntError {\n     #[allow(deprecated)]\n     fn description(&self) -> &str {\n-        self.__description()\n-    }\n-}\n-\n-#[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl Error for TryFromIntError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        self.__description()\n+        match self.kind {\n+            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n+            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n+            IntErrorKind::PosOverflow => \"number too large to fit in target type\",\n+            IntErrorKind::NegOverflow => \"number too small to fit in target type\",\n+            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n+        }\n     }\n }"}, {"sha": "0497416745fdf426fc53f87cf5753c381ee2f1af", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -9,9 +9,6 @@ use crate::mem;\n use crate::ops::{Add, Mul, Sub};\n use crate::str::FromStr;\n \n-#[cfg(not(no_fp_fmt_parse))]\n-use crate::error::Error;\n-\n // Used because the `?` operator is not allowed in a const context.\n macro_rules! try_opt {\n     ($e:expr) => {\n@@ -61,15 +58,6 @@ pub use wrapping::Wrapping;\n #[cfg(not(no_fp_fmt_parse))]\n pub use dec2flt::ParseFloatError;\n \n-#[cfg(not(no_fp_fmt_parse))]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for ParseFloatError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        self.__description()\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use error::ParseIntError;\n "}, {"sha": "98c8349eb602484c795f9514f697616558086b53", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -16,25 +16,29 @@ const USIZE_BYTES: usize = mem::size_of::<usize>();\n /// bytes where the borrow propagated all the way to the most significant\n /// bit.\"\n #[inline]\n+#[rustc_const_stable(feature = \"const_memchr\", since = \"1.65.0\")]\n const fn contains_zero_byte(x: usize) -> bool {\n     x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n }\n \n-#[cfg(target_pointer_width = \"16\")]\n #[inline]\n+#[cfg(target_pointer_width = \"16\")]\n+#[rustc_const_stable(feature = \"const_memchr\", since = \"1.65.0\")]\n const fn repeat_byte(b: u8) -> usize {\n     (b as usize) << 8 | b as usize\n }\n \n-#[cfg(not(target_pointer_width = \"16\"))]\n #[inline]\n+#[cfg(not(target_pointer_width = \"16\"))]\n+#[rustc_const_stable(feature = \"const_memchr\", since = \"1.65.0\")]\n const fn repeat_byte(b: u8) -> usize {\n     (b as usize) * (usize::MAX / 255)\n }\n \n /// Returns the first index matching the byte `x` in `text`.\n-#[must_use]\n #[inline]\n+#[must_use]\n+#[rustc_const_stable(feature = \"const_memchr\", since = \"1.65.0\")]\n pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n     // Fast path for small slices.\n     if text.len() < 2 * USIZE_BYTES {\n@@ -45,6 +49,7 @@ pub const fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n }\n \n #[inline]\n+#[rustc_const_stable(feature = \"const_memchr\", since = \"1.65.0\")]\n const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {\n     let mut i = 0;\n \n@@ -60,6 +65,10 @@ const fn memchr_naive(x: u8, text: &[u8]) -> Option<usize> {\n     None\n }\n \n+#[rustc_allow_const_fn_unstable(const_cmp)]\n+#[rustc_allow_const_fn_unstable(const_slice_index)]\n+#[rustc_allow_const_fn_unstable(const_align_offset)]\n+#[rustc_const_stable(feature = \"const_memchr\", since = \"1.65.0\")]\n const fn memchr_aligned(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //"}, {"sha": "1d14efc7523b42a9c86e4f23b555e45771df316a", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -928,8 +928,8 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n-    pub fn as_mut_ptr(&self) -> *mut bool {\n-        self.v.get() as *mut bool\n+    pub const fn as_mut_ptr(&self) -> *mut bool {\n+        self.v.get().cast()\n     }\n \n     /// Fetches the value, and applies a function to it that returns an optional\n@@ -1803,7 +1803,7 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// ```ignore (extern-declaration)\n     /// #![feature(atomic_mut_ptr)]\n-    //// use std::sync::atomic::AtomicPtr;\n+    /// use std::sync::atomic::AtomicPtr;\n     ///\n     /// extern \"C\" {\n     ///     fn my_atomic_op(arg: *mut *mut u32);\n@@ -1819,7 +1819,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n-    pub fn as_mut_ptr(&self) -> *mut *mut T {\n+    pub const fn as_mut_ptr(&self) -> *mut *mut T {\n         self.p.get()\n     }\n }\n@@ -2727,7 +2727,7 @@ macro_rules! atomic_int {\n             #[unstable(feature = \"atomic_mut_ptr\",\n                    reason = \"recently added\",\n                    issue = \"66893\")]\n-            pub fn as_mut_ptr(&self) -> *mut $int_type {\n+            pub const fn as_mut_ptr(&self) -> *mut $int_type {\n                 self.v.get()\n             }\n         }"}, {"sha": "7f07e4fddef77ca7f0c0e51f5352a922b5d5b776", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -102,7 +102,7 @@ enum ErrorData<C> {\n /// portability.\n ///\n /// [`into`]: Into::into\n-#[unstable(feature = \"raw_os_error_ty\", issue = \"none\")]\n+#[unstable(feature = \"raw_os_error_ty\", issue = \"107792\")]\n pub type RawOsError = i32;\n \n // `#[repr(align(4))]` is probably redundant, it should have that value or"}, {"sha": "b2b6d86134b6292bff70b20964bd26584b1bcac8", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -262,7 +262,7 @@ use crate::sys_common::memchr;\n \n #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use self::buffered::WriterPanicked;\n-#[unstable(feature = \"raw_os_error_ty\", issue = \"none\")]\n+#[unstable(feature = \"raw_os_error_ty\", issue = \"107792\")]\n pub use self::error::RawOsError;\n pub(crate) use self::stdio::attempt_print_to_stderr;\n #[unstable(feature = \"internal_output_capture\", issue = \"none\")]"}, {"sha": "363a26671746759aa815a2be79befe2bb9ce567d", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -273,13 +273,9 @@\n #![feature(utf8_chunks)]\n //\n // Library features (core):\n-#![feature(array_error_internals)]\n #![feature(atomic_mut_ptr)]\n-#![feature(char_error_internals)]\n #![feature(char_internals)]\n #![feature(core_intrinsics)]\n-#![feature(cstr_from_bytes_until_nul)]\n-#![feature(cstr_internals)]\n #![feature(duration_constants)]\n #![feature(error_generic_member_access)]\n #![feature(error_in_core)]\n@@ -291,7 +287,6 @@\n #![feature(float_next_up_down)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n-#![feature(int_error_internals)]\n #![feature(is_some_and)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]"}, {"sha": "439b8d52a2d8673b62486a2c75da854f65ef2386", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -396,6 +396,14 @@ impl<T: AsFd> AsFd for crate::sync::Arc<T> {\n     }\n }\n \n+#[stable(feature = \"asfd_rc\", since = \"CURRENT_RUSTC_VERSION\")]\n+impl<T: AsFd> AsFd for crate::rc::Rc<T> {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        (**self).as_fd()\n+    }\n+}\n+\n #[stable(feature = \"asfd_ptrs\", since = \"1.64.0\")]\n impl<T: AsFd> AsFd for Box<T> {\n     #[inline]"}, {"sha": "c138162f1ab08b5cad949162ec687a9eb1ea4467", "filename": "library/std/src/os/fd/raw.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -244,6 +244,14 @@ impl<T: AsRawFd> AsRawFd for crate::sync::Arc<T> {\n     }\n }\n \n+#[stable(feature = \"asfd_rc\", since = \"CURRENT_RUSTC_VERSION\")]\n+impl<T: AsRawFd> AsRawFd for crate::rc::Rc<T> {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        (**self).as_raw_fd()\n+    }\n+}\n+\n #[stable(feature = \"asrawfd_ptrs\", since = \"1.63.0\")]\n impl<T: AsRawFd> AsRawFd for Box<T> {\n     #[inline]"}, {"sha": "c298817895cd17c00cfdea87d99b01f5c4a4946e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -87,14 +87,16 @@ def _download(path, url, probably_big, verbose, exception):\n         # If curl is not present on Win32, we should not sys.exit\n         #   but raise `CalledProcessError` or `OSError` instead\n         require([\"curl\", \"--version\"], exception=platform_is_win32)\n-        run([\"curl\", option,\n-             \"-L\", # Follow redirect.\n-             \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n-             \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n-             \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n-            verbose=verbose,\n-            exception=True, # Will raise RuntimeError on failure\n-        )\n+        with open(path, \"wb\") as outfile:\n+            run([\"curl\", option,\n+                \"-L\", # Follow redirect.\n+                \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n+                \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n+                \"--retry\", \"3\", \"-Sf\", url],\n+                stdout=outfile,    #Implements cli redirect operator '>'\n+                verbose=verbose,\n+                exception=True, # Will raise RuntimeError on failure\n+            )\n     except (subprocess.CalledProcessError, OSError, RuntimeError):\n         # see http://serverfault.com/questions/301128/how-to-download\n         if platform_is_win32:"}, {"sha": "2b613ad50ee482f9011748d46554b6ead681a80f", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 123, "deletions": 26, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,6 +1,7 @@\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::Config;\n use crate::{t, VERSION};\n+use sha2::Digest;\n use std::env::consts::EXE_SUFFIX;\n use std::fmt::Write as _;\n use std::fs::File;\n@@ -10,6 +11,9 @@ use std::process::Command;\n use std::str::FromStr;\n use std::{fmt, fs, io};\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n pub enum Profile {\n     Compiler,\n@@ -19,6 +23,15 @@ pub enum Profile {\n     User,\n }\n \n+/// A list of historical hashes of `src/etc/vscode_settings.json`.\n+/// New entries should be appended whenever this is updated so we can detect\n+/// outdated vs. user-modified settings files.\n+static SETTINGS_HASHES: &[&str] = &[\n+    \"ea67e259dedf60d4429b6c349a564ffcd1563cf41c920a856d1f5b16b4701ac8\",\n+    \"56e7bf011c71c5d81e0bf42e84938111847a810eee69d906bba494ea90b51922\",\n+];\n+static VSCODE_SETTINGS: &str = include_str!(\"../etc/vscode_settings.json\");\n+\n impl Profile {\n     fn include_path(&self, src_path: &Path) -> PathBuf {\n         PathBuf::from(format!(\"{}/src/bootstrap/defaults/config.{}.toml\", src_path.display(), self))\n@@ -155,6 +168,7 @@ pub fn setup(config: &Config, profile: Profile) {\n \n     if !config.dry_run() {\n         t!(install_git_hook_maybe(&config));\n+        t!(create_vscode_settings_maybe(&config));\n     }\n \n     println!();\n@@ -351,6 +365,34 @@ pub fn interactive_path() -> io::Result<Profile> {\n     Ok(template)\n }\n \n+#[derive(PartialEq)]\n+enum PromptResult {\n+    Yes,   // y/Y/yes\n+    No,    // n/N/no\n+    Print, // p/P/print\n+}\n+\n+/// Prompt a user for a answer, looping until they enter an accepted input or nothing\n+fn prompt_user(prompt: &str) -> io::Result<Option<PromptResult>> {\n+    let mut input = String::new();\n+    loop {\n+        print!(\"{prompt} \");\n+        io::stdout().flush()?;\n+        input.clear();\n+        io::stdin().read_line(&mut input)?;\n+        match input.trim().to_lowercase().as_str() {\n+            \"y\" | \"yes\" => return Ok(Some(PromptResult::Yes)),\n+            \"n\" | \"no\" => return Ok(Some(PromptResult::No)),\n+            \"p\" | \"print\" => return Ok(Some(PromptResult::Print)),\n+            \"\" => return Ok(None),\n+            _ => {\n+                eprintln!(\"error: unrecognized option '{}'\", input.trim());\n+                eprintln!(\"note: press Ctrl+C to exit\");\n+            }\n+        };\n+    }\n+}\n+\n // install a git hook to automatically run tidy, if they want\n fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n     let git = t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n@@ -363,43 +405,98 @@ fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n         return Ok(());\n     }\n \n-    let mut input = String::new();\n-    println!();\n     println!(\n-        \"Rust's CI will automatically fail if it doesn't pass `tidy`, the internal tool for ensuring code quality.\n+        \"\\nRust's CI will automatically fail if it doesn't pass `tidy`, the internal tool for ensuring code quality.\n If you'd like, x.py can install a git hook for you that will automatically run `test tidy` before\n pushing your code to ensure your code is up to par. If you decide later that this behavior is\n undesirable, simply delete the `pre-push` file from .git/hooks.\"\n     );\n \n-    let should_install = loop {\n-        print!(\"Would you like to install the git hook?: [y/N] \");\n-        io::stdout().flush()?;\n-        input.clear();\n-        io::stdin().read_line(&mut input)?;\n-        break match input.trim().to_lowercase().as_str() {\n-            \"y\" | \"yes\" => true,\n-            \"n\" | \"no\" | \"\" => false,\n-            _ => {\n-                eprintln!(\"error: unrecognized option '{}'\", input.trim());\n-                eprintln!(\"note: press Ctrl+C to exit\");\n-                continue;\n-            }\n-        };\n-    };\n-\n-    if should_install {\n-        let src = config.src.join(\"src\").join(\"etc\").join(\"pre-push.sh\");\n-        match fs::hard_link(src, &dst) {\n-            Err(e) => eprintln!(\n+    if prompt_user(\"Would you like to install the git hook?: [y/N]\")? != Some(PromptResult::Yes) {\n+        println!(\"Ok, skipping installation!\");\n+        return Ok(());\n+    }\n+    let src = config.src.join(\"src\").join(\"etc\").join(\"pre-push.sh\");\n+    match fs::hard_link(src, &dst) {\n+        Err(e) => {\n+            eprintln!(\n                 \"error: could not create hook {}: do you already have the git hook installed?\\n{}\",\n                 dst.display(),\n                 e\n-            ),\n-            Ok(_) => println!(\"Linked `src/etc/pre-push.sh` to `.git/hooks/pre-push`\"),\n+            );\n+            return Err(e);\n+        }\n+        Ok(_) => println!(\"Linked `src/etc/pre-push.sh` to `.git/hooks/pre-push`\"),\n+    };\n+    Ok(())\n+}\n+\n+/// Create a `.vscode/settings.json` file for rustc development, or just print it\n+fn create_vscode_settings_maybe(config: &Config) -> io::Result<()> {\n+    let (current_hash, historical_hashes) = SETTINGS_HASHES.split_last().unwrap();\n+    let vscode_settings = config.src.join(\".vscode\").join(\"settings.json\");\n+    // If None, no settings.json exists\n+    // If Some(true), is a previous version of settings.json\n+    // If Some(false), is not a previous version (i.e. user modified)\n+    // If it's up to date we can just skip this\n+    let mut mismatched_settings = None;\n+    if let Ok(current) = fs::read_to_string(&vscode_settings) {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(&current);\n+        let hash = hex::encode(hasher.finalize().as_slice());\n+        if hash == *current_hash {\n+            return Ok(());\n+        } else if historical_hashes.contains(&hash.as_str()) {\n+            mismatched_settings = Some(true);\n+        } else {\n+            mismatched_settings = Some(false);\n+        }\n+    }\n+    println!(\n+        \"\\nx.py can automatically install the recommended `.vscode/settings.json` file for rustc development\"\n+    );\n+    match mismatched_settings {\n+        Some(true) => eprintln!(\n+            \"warning: existing `.vscode/settings.json` is out of date, x.py will update it\"\n+        ),\n+        Some(false) => eprintln!(\n+            \"warning: existing `.vscode/settings.json` has been modified by user, x.py will back it up and replace it\"\n+        ),\n+        _ => (),\n+    }\n+    let should_create = match prompt_user(\n+        \"Would you like to create/update `settings.json`, or only print suggested settings?: [y/p/N]\",\n+    )? {\n+        Some(PromptResult::Yes) => true,\n+        Some(PromptResult::Print) => false,\n+        _ => {\n+            println!(\"Ok, skipping settings!\");\n+            return Ok(());\n+        }\n+    };\n+    if should_create {\n+        let path = config.src.join(\".vscode\");\n+        if !path.exists() {\n+            fs::create_dir(&path)?;\n+        }\n+        let verb = match mismatched_settings {\n+            // exists but outdated, we can replace this\n+            Some(true) => \"Updated\",\n+            // exists but user modified, back it up\n+            Some(false) => {\n+                // exists and is not current version or outdated, so back it up\n+                let mut backup = vscode_settings.clone();\n+                backup.set_extension(\"bak\");\n+                eprintln!(\"warning: copying `settings.json` to `settings.json.bak`\");\n+                fs::copy(&vscode_settings, &backup)?;\n+                \"Updated\"\n+            }\n+            _ => \"Created\",\n         };\n+        fs::write(&vscode_settings, &VSCODE_SETTINGS)?;\n+        println!(\"{verb} `.vscode/settings.json`\");\n     } else {\n-        println!(\"Ok, skipping installation!\");\n+        println!(\"\\n{VSCODE_SETTINGS}\");\n     }\n     Ok(())\n }"}, {"sha": "dcf9d18e63210165e38bff00e86cc9c3370bad1a", "filename": "src/bootstrap/setup/tests.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Fsetup%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Fsetup%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup%2Ftests.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,14 @@\n+use super::{SETTINGS_HASHES, VSCODE_SETTINGS};\n+use sha2::Digest;\n+\n+#[test]\n+fn check_matching_settings_hash() {\n+    let mut hasher = sha2::Sha256::new();\n+    hasher.update(&VSCODE_SETTINGS);\n+    let hash = hex::encode(hasher.finalize().as_slice());\n+    assert_eq!(\n+        &hash,\n+        SETTINGS_HASHES.last().unwrap(),\n+        \"Update `SETTINGS_HASHES` with the new hash of `src/etc/vscode_settings.json`\"\n+    );\n+}"}, {"sha": "8a0c532cfb02fe5c29132adb7cb6a2757728696a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1114,9 +1114,6 @@ impl Step for Tidy {\n             cmd.arg(\"--bless\");\n         }\n \n-        builder.info(\"tidy check\");\n-        try_run(builder, &mut cmd);\n-\n         if builder.config.channel == \"dev\" || builder.config.channel == \"nightly\" {\n             builder.info(\"fmt check\");\n             if builder.initial_rustfmt().is_none() {\n@@ -1134,6 +1131,11 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n             }\n             crate::format::format(&builder, !builder.config.cmd.bless(), &[]);\n         }\n+\n+        builder.info(\"tidy check\");\n+        try_run(builder, &mut cmd);\n+\n+        builder.ensure(ExpandYamlAnchors {});\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {"}, {"sha": "3c128c0ca251b514142c020fbc7c6409ee843a06", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -307,8 +307,6 @@ jobs:\n           - name: x86_64-gnu-tools\n             <<: *job-linux-xl\n             tidy: false\n-            env:\n-              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n \n   auto:\n     permissions:"}, {"sha": "48127166ad0809b644ba4b533b042588ab0eec7a", "filename": "src/ci/scripts/should-skip-this.sh", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fshould-skip-this.sh?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,46 +1,11 @@\n #!/bin/bash\n-# Set the SKIP_JOB environment variable if this job is supposed to only run\n-# when submodules are updated and they were not. The following time consuming\n-# tasks will be skipped when the environment variable is present.\n+# Set the SKIP_JOB environment variable if this job is not supposed to run on the current builder.\n \n set -euo pipefail\n IFS=$'\\n\\t'\n \n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n-if [[ -n \"${CI_ONLY_WHEN_SUBMODULES_CHANGED-}\" ]]; then\n-    git fetch \"https://github.com/$GITHUB_REPOSITORY\" \"$GITHUB_BASE_REF\"\n-    BASE_COMMIT=\"$(git merge-base FETCH_HEAD HEAD)\"\n-\n-    echo \"Searching for toolstate changes between $BASE_COMMIT and $(git rev-parse HEAD)\"\n-\n-    if git diff \"$BASE_COMMIT\" | grep --quiet \"^index .* 160000\"; then\n-        # Submodules pseudo-files inside git have the 160000 permissions, so when\n-        # those files are present in the diff a submodule was updated.\n-        echo \"Submodules were updated\"\n-    elif ! (git diff --quiet \"$BASE_COMMIT\" -- \\\n-             src/tools/clippy src/tools/rustfmt src/tools/miri \\\n-             library/std/src/sys); then\n-        # There is not an easy blanket search for subtrees. For now, manually list\n-        # the subtrees.\n-        # Also run this when the platform-specific parts of std change, in case\n-        # that breaks Miri.\n-        echo \"Tool subtrees were updated\"\n-    elif ! (git diff --quiet \"$BASE_COMMIT\" -- \\\n-             tests/rustdoc-gui \\\n-             src/librustdoc \\\n-             src/ci/docker/host-x86_64/x86_64-gnu-tools/Dockerfile \\\n-             src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version \\\n-             src/tools/rustdoc-gui); then\n-        # There was a change in either rustdoc or in its GUI tests.\n-        echo \"Rustdoc was updated\"\n-    else\n-        echo \"Not executing this job since no submodules nor subtrees were updated\"\n-        ciCommandSetEnv SKIP_JOB 1\n-        exit 0\n-    fi\n-fi\n-\n if [[ -n \"${CI_ONLY_WHEN_CHANNEL-}\" ]]; then\n     if [[ \"${CI_ONLY_WHEN_CHANNEL}\" = \"$(cat src/ci/channel)\" ]]; then\n         echo \"The channel is the expected one\""}, {"sha": "cea6033ede208f7ce091ba1f800aa1c151f9ce19", "filename": "src/doc/rustc/book.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fdoc%2Frustc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fdoc%2Frustc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fbook.toml?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -5,3 +5,4 @@ title = \"The rustc book\"\n \n [output.html]\n git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/rustc\"\n+edit-url-template = \"https://github.com/rust-lang/rust/edit/master/src/doc/rustc/{path}\""}, {"sha": "1770c121a0e73064d6db671d6bf3b50b10784e5a", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -562,7 +562,7 @@ Supported values for this option are:\n * `v0` \u2014 The \"v0\" mangling scheme. The specific format is not specified at\n   this time.\n \n-The default if not specified will use a compiler-chosen default which may\n+The default, if not specified, will use a compiler-chosen default which may\n change in the future.\n \n [name mangling]: https://en.wikipedia.org/wiki/Name_mangling"}, {"sha": "8013b4988e1414ad1ee408dd494b84da85edb034", "filename": "src/doc/unstable-book/src/library-features/char-error-internals.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/185156280f8e952a864c5f4f4c4daa03bc04d46c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-error-internals.md", "raw_url": "https://github.com/rust-lang/rust/raw/185156280f8e952a864c5f4f4c4daa03bc04d46c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-error-internals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-error-internals.md?ref=185156280f8e952a864c5f4f4c4daa03bc04d46c", "patch": "@@ -1,5 +0,0 @@\n-# `char_error_internals`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "402e4fa5ef6d73fcf3f4f2ef0a610add95f9d018", "filename": "src/doc/unstable-book/src/library-features/int-error-internals.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/185156280f8e952a864c5f4f4c4daa03bc04d46c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fint-error-internals.md", "raw_url": "https://github.com/rust-lang/rust/raw/185156280f8e952a864c5f4f4c4daa03bc04d46c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fint-error-internals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fint-error-internals.md?ref=185156280f8e952a864c5f4f4c4daa03bc04d46c", "patch": "@@ -1,5 +0,0 @@\n-# `int_error_internals`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "04c34ce91c0b7aa72d05371e94e4a0d08f789cad", "filename": "src/etc/vscode_settings.json", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fetc%2Fvscode_settings.json", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Fetc%2Fvscode_settings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvscode_settings.json?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,28 @@\n+{\n+    \"rust-analyzer.check.invocationLocation\": \"root\",\n+    \"rust-analyzer.check.invocationStrategy\": \"once\",\n+    \"rust-analyzer.checkOnSave.overrideCommand\": [\n+        \"python3\",\n+        \"x.py\",\n+        \"check\",\n+        \"--json-output\"\n+    ],\n+    \"rust-analyzer.linkedProjects\": [\"src/bootstrap/Cargo.toml\", \"Cargo.toml\"],\n+    \"rust-analyzer.rustfmt.overrideCommand\": [\n+        \"./build/host/rustfmt/bin/rustfmt\",\n+        \"--edition=2021\"\n+    ],\n+    \"rust-analyzer.procMacro.server\": \"./build/host/stage0/libexec/rust-analyzer-proc-macro-srv\",\n+    \"rust-analyzer.procMacro.enable\": true,\n+    \"rust-analyzer.cargo.buildScripts.enable\": true,\n+    \"rust-analyzer.cargo.buildScripts.invocationLocation\": \"root\",\n+    \"rust-analyzer.cargo.buildScripts.invocationStrategy\": \"once\",\n+    \"rust-analyzer.cargo.buildScripts.overrideCommand\": [\n+        \"python3\",\n+        \"x.py\",\n+        \"check\",\n+        \"--json-output\"\n+    ],\n+    \"rust-analyzer.cargo.sysroot\": \"./build/host/stage0-sysroot\",\n+    \"rust-analyzer.rustc.source\": \"./Cargo.toml\"\n+}"}, {"sha": "8a7a8ea5fd1f268a69c6e7f39eb319030f032896", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -289,7 +289,7 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n                 if f.alternate() {\n                     f.write_str(\" \")?;\n                 } else {\n-                    f.write_str(\"<br>\")?;\n+                    f.write_str(\"\\n\")?;\n                 }\n \n                 match pred {\n@@ -352,24 +352,24 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n             }\n         } else {\n             let mut br_with_padding = String::with_capacity(6 * indent + 28);\n-            br_with_padding.push_str(\"<br>\");\n+            br_with_padding.push_str(\"\\n\");\n \n             let padding_amout =\n                 if ending == Ending::Newline { indent + 4 } else { indent + \"fn where \".len() };\n \n             for _ in 0..padding_amout {\n                 br_with_padding.push_str(\" \");\n             }\n-            let where_preds = where_preds.to_string().replace(\"<br>\", &br_with_padding);\n+            let where_preds = where_preds.to_string().replace(\"\\n\", &br_with_padding);\n \n             if ending == Ending::Newline {\n                 let mut clause = \" \".repeat(indent.saturating_sub(1));\n                 write!(clause, \"<span class=\\\"where fmt-newline\\\">where{where_preds},</span>\")?;\n                 clause\n             } else {\n-                // insert a <br> tag after a single space but before multiple spaces at the start\n+                // insert a newline after a single space but before multiple spaces at the start\n                 if indent == 0 {\n-                    format!(\"<br><span class=\\\"where\\\">where{where_preds}</span>\")\n+                    format!(\"\\n<span class=\\\"where\\\">where{where_preds}</span>\")\n                 } else {\n                     // put the first one on the same line as the 'where' keyword\n                     let where_preds = where_preds.replacen(&br_with_padding, \" \", 1);\n@@ -1315,7 +1315,8 @@ impl clean::FnDecl {\n \n     /// * `header_len`: The length of the function header and name. In other words, the number of\n     ///   characters in the function declaration up to but not including the parentheses.\n-    ///   <br>Used to determine line-wrapping.\n+    ///   This is expected to go into a `<pre>`/`code-header` block, so indentation and newlines\n+    ///   are preserved.\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n     pub(crate) fn full_print<'a, 'tcx: 'a>(\n@@ -1363,7 +1364,7 @@ impl clean::FnDecl {\n                 }\n             } else {\n                 if i > 0 {\n-                    args.push_str(\"<br>\");\n+                    args.push_str(\"\\n\");\n                 }\n                 if input.is_const {\n                     args.push_str(\"const \");\n@@ -1389,7 +1390,7 @@ impl clean::FnDecl {\n         let mut args = args.into_inner();\n \n         if self.c_variadic {\n-            args.push_str(\",<br> ...\");\n+            args.push_str(\",\\n ...\");\n             args_plain.push_str(\", ...\");\n         }\n \n@@ -1399,24 +1400,20 @@ impl clean::FnDecl {\n \n         let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n         let output = if declaration_len > 80 {\n-            let full_pad = format!(\"<br>{}\", \" \".repeat(indent + 4));\n-            let close_pad = format!(\"<br>{}\", \" \".repeat(indent));\n+            let full_pad = format!(\"\\n{}\", \" \".repeat(indent + 4));\n+            let close_pad = format!(\"\\n{}\", \" \".repeat(indent));\n             format!(\n                 \"({pad}{args}{close}){arrow}\",\n                 pad = if self.inputs.values.is_empty() { \"\" } else { &full_pad },\n-                args = args.replace(\"<br>\", &full_pad),\n+                args = args.replace(\"\\n\", &full_pad),\n                 close = close_pad,\n                 arrow = arrow\n             )\n         } else {\n-            format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \" \"), arrow = arrow)\n+            format!(\"({args}){arrow}\", args = args.replace(\"\\n\", \" \"), arrow = arrow)\n         };\n \n-        if f.alternate() {\n-            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n-        } else {\n-            write!(f, \"{}\", output)\n-        }\n+        write!(f, \"{}\", output)\n     }\n }\n "}, {"sha": "83c07f63d10ab22413adc3b12d2ed4bc43394cf3", "filename": "src/librustdoc/html/static/images/wheel.svg", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Fwheel.svg", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Fwheel.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Fwheel.svg?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1 +1 @@\n-<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" id=\"Capa_1\" width=\"27.434\" height=\"29.5\" enable-background=\"new 0 0 27.434 29.5\" version=\"1.1\" viewBox=\"0 0 27.434 29.5\" xml:space=\"preserve\"><g><path d=\"M27.315,18.389c-0.165-0.604-0.509-1.113-0.981-1.459c-0.042-0.144-0.083-0.429-0.015-0.761l0.037-0.177v-0.182V14.8 c0-1.247-0.006-1.277-0.048-1.472c-0.076-0.354-0.035-0.653,0.007-0.803c0.477-0.346,0.828-0.861,0.996-1.476 c0.261-0.956,0.076-2.091-0.508-3.114l-0.591-1.032c-0.746-1.307-1.965-2.119-3.182-2.119c-0.378,0-0.75,0.081-1.085,0.235 c-0.198-0.025-0.554-0.15-0.855-0.389l-0.103-0.082l-0.114-0.065l-1.857-1.067L18.92,3.36l-0.105-0.044 c-0.376-0.154-0.658-0.41-0.768-0.556C17.918,1.172,16.349,0,14.296,0H13.14c-2.043,0-3.608,1.154-3.749,2.721 C9.277,2.862,8.999,3.104,8.633,3.25l-0.1,0.039L8.439,3.341L6.495,4.406L6.363,4.479L6.245,4.573 C5.936,4.82,5.596,4.944,5.416,4.977c-0.314-0.139-0.66-0.21-1.011-0.21c-1.198,0-2.411,0.819-3.165,2.139L0.65,7.938 c-0.412,0.72-0.642,1.521-0.644,2.258c-0.003,0.952,0.362,1.756,1.013,2.256c0.034,0.155,0.061,0.448-0.016,0.786 c-0.038,0.168-0.062,0.28-0.062,1.563c0,1.148,0,1.148,0.015,1.262l0.009,0.073l0.017,0.073c0.073,0.346,0.045,0.643,0.011,0.802 C0.348,17.512-0.01,18.314,0,19.268c0.008,0.729,0.238,1.523,0.648,2.242l0.589,1.031c0.761,1.331,1.967,2.159,3.15,2.159 c0.324,0,0.645-0.064,0.938-0.187c0.167,0.038,0.492,0.156,0.813,0.416l0.11,0.088l0.124,0.07l2.045,1.156l0.102,0.057l0.107,0.043 c0.364,0.147,0.646,0.381,0.766,0.521c0.164,1.52,1.719,2.634,3.745,2.634h1.155c2.037,0,3.598-1.134,3.747-2.675 c0.117-0.145,0.401-0.393,0.774-0.549l0.111-0.047l0.105-0.062l1.96-1.159l0.105-0.062l0.097-0.075 c0.309-0.246,0.651-0.371,0.832-0.402c0.313,0.138,0.662,0.212,1.016,0.212c1.199,0,2.412-0.82,3.166-2.139l0.59-1.032 C27.387,20.48,27.575,19.342,27.315,18.389z M25.274,20.635l-0.59,1.032c-0.438,0.765-1.104,1.251-1.639,1.251 c-0.133,0-0.258-0.029-0.369-0.094c-0.15-0.086-0.346-0.127-0.566-0.127c-0.596,0-1.383,0.295-2.01,0.796l-1.96,1.157 c-1.016,0.425-1.846,1.291-1.846,1.929s-0.898,1.159-1.998,1.159H13.14c-1.1,0-1.998-0.514-1.998-1.141s-0.834-1.477-1.854-1.888 l-2.046-1.157c-0.636-0.511-1.425-0.814-2.006-0.814c-0.202,0-0.379,0.037-0.516,0.115c-0.101,0.057-0.214,0.084-0.333,0.084 c-0.518,0-1.179-0.498-1.62-1.271l-0.591-1.032c-0.545-0.954-0.556-1.983-0.024-2.286c0.532-0.305,0.78-1.432,0.551-2.506 c0,0,0-0.003,0-1.042c0-1.088,0.021-1.18,0.021-1.18c0.238-1.072-0.01-2.203-0.552-2.513C1.631,10.8,1.634,9.765,2.18,8.812 L2.769,7.78c0.438-0.766,1.103-1.251,1.636-1.251c0.131,0,0.255,0.029,0.365,0.092C4.92,6.707,5.114,6.747,5.334,6.747 c0.596,0,1.38-0.296,2.007-0.795l1.944-1.065c1.021-0.407,1.856-1.277,1.856-1.933c0-0.656,0.898-1.192,1.998-1.192h1.156V1.761 c1.1,0,1.998,0.545,1.998,1.211c0,0.667,0.832,1.554,1.849,1.973L20,6.013c0.618,0.489,1.401,0.775,2.012,0.775 c0.24,0,0.454-0.045,0.62-0.139c0.122-0.069,0.259-0.102,0.403-0.102c0.551,0,1.221,0.476,1.653,1.231l0.59,1.032 c0.544,0.953,0.518,2.004-0.062,2.334c-0.577,0.331-0.859,1.48-0.627,2.554c0,0,0.01,0.042,0.01,1.103c0,1.012,0,1.012,0,1.012 c-0.218,1.049,0.068,2.174,0.636,2.498C25.802,18.635,25.819,19.68,25.274,20.635z\"/><path d=\"M13.61,7.611c-3.913,0-7.084,3.173-7.084,7.085c0,3.914,3.171,7.085,7.084,7.085s7.085-3.172,7.085-7.085 C20.695,10.784,17.523,7.611,13.61,7.611z M13.61,20.02c-2.936,0-5.323-2.388-5.323-5.323c0-2.935,2.388-5.323,5.323-5.323 s5.324,2.388,5.324,5.323C18.934,17.632,16.546,20.02,13.61,20.02z\"/><path d=\"M13.682,9.908c-2.602,0-4.718,2.116-4.718,4.718c0,2.601,2.116,4.716,4.718,4.716c2.601,0,4.717-2.115,4.717-4.716 C18.399,12.024,16.283,9.908,13.682,9.908z M13.682,17.581c-1.633,0-2.956-1.323-2.956-2.955s1.323-2.956,2.956-2.956 c1.632,0,2.956,1.324,2.956,2.956S15.314,17.581,13.682,17.581z\"/></g></svg>\n\\ No newline at end of file\n+<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"27.434\" height=\"29.5\" enable-background=\"new 0 0 27.434 29.5\" viewBox=\"0 0 27.434 29.5\"><path d=\"M27.316 18.39a2.696 2.696 0 0 0-.98-1.46 1.62 1.62 0 0 1-.016-.762l.035-.176v-1.191c0-1.246-.003-1.278-.046-1.473a1.717 1.717 0 0 1 .007-.805c.477-.343.829-.859.997-1.472.257-.957.074-2.094-.508-3.117l-.594-1.032c-.746-1.304-1.965-2.117-3.18-2.117-.379 0-.75.078-1.086.235a1.958 1.958 0 0 1-.855-.391l-.102-.082-.117-.063-1.855-1.07-.094-.055-.106-.043c-.378-.156-.66-.41-.77-.554C17.919 1.172 16.349 0 14.297 0h-1.155c-2.043 0-3.61 1.152-3.75 2.723-.114.14-.391.382-.758.527l-.102.04-.094.05-1.94 1.066-.134.074-.117.094a2.019 2.019 0 0 1-.832.403 2.518 2.518 0 0 0-1.008-.211c-1.199 0-2.414.82-3.168 2.14l-.59 1.032c-.41.718-.64 1.523-.64 2.257-.004.953.36 1.758 1.012 2.258.035.152.058.445-.016.785-.04.168-.063.282-.063 1.563 0 1.148 0 1.148.016 1.261l.008.075.015.074c.075.344.047.64.012.8-.644.5-1.004 1.302-.992 2.259.008.726.238 1.52.648 2.242l.59 1.027c.758 1.332 1.965 2.16 3.149 2.16.324 0 .644-.062.937-.187.168.039.492.156.813.418l.11.086.124.07 2.047 1.156.102.059.105.043c.363.144.648.379.766.52.164 1.519 1.718 2.632 3.746 2.632h1.156c2.035 0 3.598-1.133 3.746-2.672.117-.144.402-.394.773-.55l.114-.047.101-.063 1.961-1.156.106-.063.097-.078c.309-.246.653-.37.832-.398.313.136.66.21 1.016.21 1.2 0 2.41-.82 3.164-2.14l.594-1.031c.59-1.028.777-2.164.52-3.117Zm-2.043 2.247-.59 1.031c-.437.766-1.105 1.25-1.636 1.25a.7.7 0 0 1-.371-.094 1.146 1.146 0 0 0-.567-.129c-.593 0-1.382.297-2.007.797l-1.961 1.156c-1.016.426-1.848 1.293-1.848 1.93 0 .64-.898 1.16-1.996 1.16H13.14c-1.102 0-2-.515-2-1.14 0-.63-.832-1.477-1.852-1.887l-2.047-1.16c-.637-.512-1.426-.813-2.008-.813-.199 0-.379.035-.515.114a.648.648 0 0 1-.332.085c-.52 0-1.18-.5-1.621-1.273l-.59-1.031c-.543-.953-.555-1.98-.024-2.285.532-.305.782-1.434.551-2.504V14.8c0-1.09.02-1.18.02-1.18.238-1.074-.008-2.203-.551-2.516-.54-.304-.54-1.34.008-2.293l.59-1.03c.437-.766 1.101-1.255 1.636-1.255a.73.73 0 0 1 .364.094c.152.086.343.125.566.125.594 0 1.379-.297 2.004-.793l1.945-1.066c1.02-.407 1.856-1.278 1.856-1.934 0-.656.898-1.191 2-1.191h1.156c1.098 0 1.996.543 1.996 1.21 0 .669.832 1.555 1.848 1.973L20 6.012c.617.492 1.402.777 2.012.777.242 0 .453-.047.62-.14a.79.79 0 0 1 .403-.102c.55 0 1.223.476 1.652 1.23l.59 1.032c.543.953.52 2.004-.062 2.336-.574.332-.86 1.48-.625 2.554 0 0 .008.04.008 1.102v1.011c-.215 1.051.07 2.176.636 2.5.567.325.586 1.368.04 2.325Zm0 0\"/><path d=\"M13.61 7.61a7.084 7.084 0 0 0-7.083 7.085 7.085 7.085 0 1 0 14.168 0A7.088 7.088 0 0 0 13.61 7.61Zm0 12.41a5.33 5.33 0 0 1-5.325-5.325 5.33 5.33 0 0 1 5.324-5.32 5.327 5.327 0 0 1 5.325 5.32 5.328 5.328 0 0 1-5.325 5.325Zm0 0\"/><path d=\"M13.684 9.906a4.722 4.722 0 0 0-4.72 4.719 4.722 4.722 0 0 0 4.72 4.719 4.724 4.724 0 0 0 4.714-4.719 4.724 4.724 0 0 0-4.714-4.719Zm0 7.676a2.954 2.954 0 1 1 0-5.91 2.953 2.953 0 0 1 2.953 2.953 2.957 2.957 0 0 1-2.953 2.957Zm0 0\"/></svg>\n\\ No newline at end of file"}, {"sha": "7690d8f251f7485a04affbcb445b9b6ca7486687", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -23,11 +23,13 @@\n     {%- for theme in themes -%}\n         <link rel=\"stylesheet\" disabled href=\"{{page.root_path|safe}}{{theme}}{{page.resource_suffix}}.css\"> {#- -#}\n     {%- endfor -%}\n+    {%- if !layout.default_settings.is_empty() -%}\n     <script id=\"default-settings\" {# -#}\n       {% for (k, v) in layout.default_settings %}\n         data-{{k}}=\"{{v}}\"\n       {%- endfor -%}\n     ></script> {#- -#}\n+    {%- endif -%}\n     <script src=\"{{static_root_path|safe}}{{files.storage_js}}\"></script> {#- -#}\n     {%- if page.css_class.contains(\"crate\") -%}\n     <script defer src=\"{{page.root_path|safe}}crates{{page.resource_suffix}}.js\"></script> {#- -#}"}, {"sha": "82c3bb79e3a19a5164e33819ef81bfc2c984bc56", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1 +1 @@\n-Subproject commit e84a7928d93a31f284b497c214a2ece69b4d7719\n+Subproject commit 82c3bb79e3a19a5164e33819ef81bfc2c984bc56"}, {"sha": "3fc72ecbbc484ffd2b9e292b00585fcbedeeb392", "filename": "src/tools/expand-yaml-anchors/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fexpand-yaml-anchors%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fexpand-yaml-anchors%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fexpand-yaml-anchors%2Fsrc%2Fmain.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -51,7 +51,7 @@ impl App {\n             [\"generate\", ref base] => (Mode::Generate, PathBuf::from(base)),\n             [\"check\", ref base] => (Mode::Check, PathBuf::from(base)),\n             _ => {\n-                eprintln!(\"usage: expand-yaml-anchors <source-dir> <dest-dir>\");\n+                eprintln!(\"usage: expand-yaml-anchors <generate|check> <base-dir>\");\n                 std::process::exit(1);\n             }\n         };"}, {"sha": "dcb1879042041daa9e9a0d520c4ef7d7265db366", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -162,11 +162,14 @@ impl<'mir, 'tcx> GlobalStateInner {\n         Ok(Pointer::new(Some(Provenance::Wildcard), Size::from_bytes(addr)))\n     }\n \n-    fn alloc_base_addr(ecx: &MiriInterpCx<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n+    fn alloc_base_addr(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        alloc_id: AllocId,\n+    ) -> InterpResult<'tcx, u64> {\n         let mut global_state = ecx.machine.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n-        match global_state.base_addr.entry(alloc_id) {\n+        Ok(match global_state.base_addr.entry(alloc_id) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 // There is nothing wrong with a raw pointer being cast to an integer only after\n@@ -181,7 +184,10 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     rng.gen_range(0..16)\n                 };\n                 // From next_base_addr + slack, round up to adjust for alignment.\n-                let base_addr = global_state.next_base_addr.checked_add(slack).unwrap();\n+                let base_addr = global_state\n+                    .next_base_addr\n+                    .checked_add(slack)\n+                    .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n                 let base_addr = Self::align_addr(base_addr, align.bytes());\n                 entry.insert(base_addr);\n                 trace!(\n@@ -197,24 +203,33 @@ impl<'mir, 'tcx> GlobalStateInner {\n                 // of at least 1 to avoid two allocations having the same base address.\n                 // (The logic in `alloc_id_from_addr` assumes unique addresses, and different\n                 // function/vtable pointers need to be distinguishable!)\n-                global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n+                global_state.next_base_addr = base_addr\n+                    .checked_add(max(size.bytes(), 1))\n+                    .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n+                // Even if `Size` didn't overflow, we might still have filled up the address space.\n+                if global_state.next_base_addr > ecx.machine_usize_max() {\n+                    throw_exhaust!(AddressSpaceFull);\n+                }\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n                 global_state.int_to_ptr_map.push((base_addr, alloc_id));\n \n                 base_addr\n             }\n-        }\n+        })\n     }\n \n     /// Convert a relative (tcx) pointer to an absolute address.\n-    pub fn rel_ptr_to_addr(ecx: &MiriInterpCx<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n+    pub fn rel_ptr_to_addr(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        ptr: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx, u64> {\n         let (alloc_id, offset) = ptr.into_parts(); // offset is relative (AllocId provenance)\n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id)?;\n \n         // Add offset with the right kind of pointer-overflowing arithmetic.\n         let dl = ecx.data_layout();\n-        dl.overflowing_offset(base_addr, offset.bytes()).0\n+        Ok(dl.overflowing_offset(base_addr, offset.bytes()).0)\n     }\n \n     /// When a pointer is used for a memory access, this computes where in which allocation the\n@@ -232,7 +247,9 @@ impl<'mir, 'tcx> GlobalStateInner {\n             GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n         };\n \n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+        // This cannot fail: since we already have a pointer with that provenance, rel_ptr_to_addr\n+        // must have been called in the past.\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id).unwrap();\n \n         // Wrapping \"addr - base_addr\"\n         let dl = ecx.data_layout();"}, {"sha": "8e44d4d7adec8465607827b6ba9f06529a623ce3", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -971,7 +971,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn adjust_alloc_base_pointer(\n         ecx: &MiriInterpCx<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<Provenance> {\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         if cfg!(debug_assertions) {\n             // The machine promises to never call us on thread-local or extern statics.\n             let alloc_id = ptr.provenance;\n@@ -985,17 +985,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 _ => {}\n             }\n         }\n-        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n+        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr)?;\n         let tag = if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n             borrow_tracker.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n             BorTag::default()\n         };\n-        Pointer::new(\n+        Ok(Pointer::new(\n             Provenance::Concrete { alloc_id: ptr.provenance, tag },\n             Size::from_bytes(absolute_addr),\n-        )\n+        ))\n     }\n \n     #[inline(always)]"}, {"sha": "ed1c6ebfece76ceed96988a2385a21c6d0145065", "filename": "src/tools/miri/src/shims/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -190,9 +190,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             0 => {\n                 // These are \"mutable\" allocations as we consider them to be owned by the callee.\n                 let name_alloc =\n-                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut)?;\n                 let filename_alloc =\n-                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut)?;\n \n                 this.write_immediate(\n                     name_alloc.to_ref(this),"}, {"sha": "0ea1137200b9d98177de5a0770fa040a7fd19471", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -172,7 +172,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         // First arg: message.\n-        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not);\n+        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not)?;\n \n         // Call the lang item.\n         let panic = this.tcx.lang_items().panic_fn().unwrap();"}, {"sha": "80b8d67401ad143086b69363c11e86e51f1dae2b", "filename": "src/tools/miri/tests/pass-dep/shims/pthreads.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,5 +1,4 @@\n //@ignore-target-windows: No libc on Windows\n-#![feature(cstr_from_bytes_until_nul)]\n use std::ffi::{CStr, CString};\n use std::thread;\n "}, {"sha": "9981e4d1ea6ac0992ff21be5514d4230dc77548b", "filename": "src/tools/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1 +1 @@\n-Subproject commit 5b2eee7eed72b4894909c5eecbf014ea0b5ad995\n+Subproject commit 9981e4d1ea6ac0992ff21be5514d4230dc77548b"}, {"sha": "dd2fd1911f227c162b9b249b5a0e2c268dc538b8", "filename": "src/tools/tidy/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -31,7 +31,7 @@ const IGNORE_DOCTEST_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E06\n \n // Error codes that don't yet have a UI test. This list will eventually be removed.\n const IGNORE_UI_TEST_CHECK: &[&str] =\n-    &[\"E0461\", \"E0465\", \"E0476\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\"];\n+    &[\"E0461\", \"E0465\", \"E0476\", \"E0514\", \"E0554\", \"E0640\", \"E0717\", \"E0729\"];\n \n macro_rules! verbose_print {\n     ($verbose:expr, $($fmt:tt)*) => {"}, {"sha": "83551a1d820abe0c5c30ce395dd968100f813638", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -10,7 +10,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 939;\n-const ISSUES_ENTRY_LIMIT: usize = 1998;\n+const ISSUES_ENTRY_LIMIT: usize = 2001;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     for dir in Walk::new(&path.join(\"ui\")) {"}, {"sha": "02308beb88af27b42bd9fcfed01d5c11bed855bf", "filename": "tests/mir-opt/copy-prop/move_projection.f.CopyProp.diff", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fmir-opt%2Fcopy-prop%2Fmove_projection.f.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fmir-opt%2Fcopy-prop%2Fmove_projection.f.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fmove_projection.f.CopyProp.diff?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,31 @@\n+- // MIR for `f` before CopyProp\n++ // MIR for `f` after CopyProp\n+  \n+  fn f(_1: Foo) -> bool {\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/move_projection.rs:+0:17: +0:21\n+      let mut _2: Foo;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+      let mut _3: u8;                      // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+-         _2 = _1;                         // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+-         _3 = move (_2.0: u8);            // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+-         _0 = opaque::<Foo>(move _1) -> bb1; // scope 0 at $DIR/move_projection.rs:+6:13: +6:44\n++         _3 = (_1.0: u8);                 // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n++         _0 = opaque::<Foo>(_1) -> bb1;   // scope 0 at $DIR/move_projection.rs:+6:13: +6:44\n+                                           // mir::Constant\n+                                           // + span: $DIR/move_projection.rs:19:28: 19:34\n+                                           // + literal: Const { ty: fn(Foo) -> bool {opaque::<Foo>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          _0 = opaque::<u8>(move _3) -> bb2; // scope 0 at $DIR/move_projection.rs:+9:13: +9:44\n+                                           // mir::Constant\n+                                           // + span: $DIR/move_projection.rs:22:28: 22:34\n+                                           // + literal: Const { ty: fn(u8) -> bool {opaque::<u8>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/move_projection.rs:+12:13: +12:21\n+      }\n+  }\n+  "}, {"sha": "2a1bbae99a4c8b3c4899f3ea9d4096c9ef70df06", "filename": "tests/mir-opt/copy-prop/move_projection.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fmir-opt%2Fcopy-prop%2Fmove_projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fmir-opt%2Fcopy-prop%2Fmove_projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fmove_projection.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,34 @@\n+// unit-test: CopyProp\n+\n+#![feature(custom_mir, core_intrinsics)]\n+#![allow(unused_assignments)]\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+fn opaque(_: impl Sized) -> bool { true }\n+\n+struct Foo(u8);\n+\n+#[custom_mir(dialect = \"analysis\", phase = \"post-cleanup\")]\n+fn f(a: Foo) -> bool {\n+    mir!(\n+        {\n+            let b = a;\n+            // This is a move out of a copy, so must become a copy of `a.0`.\n+            let c = Move(b.0);\n+            Call(RET, bb1, opaque(Move(a)))\n+        }\n+        bb1 = {\n+            Call(RET, ret, opaque(Move(c)))\n+        }\n+        ret = {\n+            Return()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    assert!(f(Foo(0)));\n+}\n+\n+// EMIT_MIR move_projection.f.CopyProp.diff"}, {"sha": "66ba4df767ccf2ff004604ac17d3070affa706c1", "filename": "tests/mir-opt/simple_option_map_e2e.ezmap.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -34,7 +34,7 @@ fn ezmap(_1: Option<i32>) -> Option<i32> {\n     }\n \n     bb3: {\n-        _4 = move ((_1 as Some).0: i32); // scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n+        _4 = ((_1 as Some).0: i32);      // scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n         StorageLive(_5);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n         _5 = Add(_4, const 1_i32);       // scope 3 at $DIR/simple_option_map_e2e.rs:+1:16: +1:21\n         _0 = Option::<i32>::Some(move _5); // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30"}, {"sha": "706db892cb30d528759fcf9de517b68a2627e429", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -77,7 +77,6 @@\n     -Z                            llvm-plugins=val -- a list LLVM plugins to enable (space separated)\n     -Z                         llvm-time-trace=val -- generate JSON tracing data file from LLVM data (default: no)\n     -Z                         location-detail=val -- what location details should be tracked when using caller_location, either `none`, or a comma separated list of location details, for which valid options are `file`, `line`, and `column` (default: `file,line,column`)\n-    -Z                           log-backtrace=val -- add a backtrace along with logging\n     -Z                                      ls=val -- list the symbols defined by a library crate (default: no)\n     -Z                         macro-backtrace=val -- show macro backtraces (default: no)\n     -Z             maximal-hir-to-mir-coverage=val -- save as much information as possible about the correspondence between MIR and HIR as source scopes (default: no)"}, {"sha": "70bcbcb6ff44ae3d5851a71b6f729950a41c4795", "filename": "tests/rustdoc/async-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fasync-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fasync-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fasync-fn.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -77,7 +77,7 @@ struct AsyncFdReadyGuard<'a, T> { x: &'a T }\n \n impl Foo {\n     // @has async_fn/struct.Foo.html\n-    // @has - '//*[@class=\"method\"]' 'pub async fn complicated_lifetimes( &self, context: &impl Bar) -> impl Iterator<Item = &usize>'\n+    // @has - '//*[@class=\"method\"]' 'pub async fn complicated_lifetimes( &self, context: &impl Bar ) -> impl Iterator<Item = &usize>'\n     pub async fn complicated_lifetimes(&self, context: &impl Bar) -> impl Iterator<Item = &usize> {}\n     // taken from `tokio` as an example of a method that was particularly bad before\n     // @has - '//*[@class=\"method\"]' \"pub async fn readable<T>(&self) -> Result<AsyncFdReadyGuard<'_, T>, ()>\""}, {"sha": "cbda095424b7d1536c6ea359a48c86b76c11ecee", "filename": "tests/rustdoc/const-generics/const-generics-docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -31,7 +31,7 @@ impl Trait<{1 + 2}> for u8 {}\n impl<const N: usize> Trait<N> for [u8; N] {}\n \n // @has foo/struct.Foo.html '//pre[@class=\"rust item-decl\"]' \\\n-//      'pub struct Foo<const N: usize>where u8: Trait<N>'\n+//      'pub struct Foo<const N: usize> where u8: Trait<N>'\n pub struct Foo<const N: usize> where u8: Trait<N>;\n // @has foo/struct.Bar.html '//pre[@class=\"rust item-decl\"]' 'pub struct Bar<T, const N: usize>(_)'\n pub struct Bar<T, const N: usize>([T; N]);"}, {"sha": "d73393633f3b8c97b1ea04eee609a46ce59a4d50", "filename": "tests/rustdoc/decl-trailing-whitespace.declaration.html", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fdecl-trailing-whitespace.declaration.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fdecl-trailing-whitespace.declaration.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdecl-trailing-whitespace.declaration.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,9 +1,23 @@\n <code>pub trait Write {\n     // Required methods\n-    fn <a href=\"#tymethod.poll_write\" class=\"fn\">poll_write</a>(<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buf: &amp;mut [<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>]<br />&#160;&#160;&#160;&#160;) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt;;\n-<span class=\"item-spacer\" />    fn <a href=\"#tymethod.poll_flush\" class=\"fn\">poll_flush</a>(<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;<br />&#160;&#160;&#160;&#160;) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt;;\n-<span class=\"item-spacer\" />    fn <a href=\"#tymethod.poll_close\" class=\"fn\">poll_close</a>(<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;<br />&#160;&#160;&#160;&#160;) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt;;\n+    fn <a href=\"#tymethod.poll_write\" class=\"fn\">poll_write</a>(\n+        self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,\n+        cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,\n+        buf: &amp;mut [<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>]\n+    ) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt;;\n+<span class=\"item-spacer\" />    fn <a href=\"#tymethod.poll_flush\" class=\"fn\">poll_flush</a>(\n+        self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,\n+        cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;\n+    ) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt;;\n+<span class=\"item-spacer\" />    fn <a href=\"#tymethod.poll_close\" class=\"fn\">poll_close</a>(\n+        self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,\n+        cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;\n+    ) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt;;\n \n     // Provided method\n-    fn <a href=\"#method.poll_write_vectored\" class=\"fn\">poll_write_vectored</a>(<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bufs: &amp;[<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>]<br />&#160;&#160;&#160;&#160;) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt; { ... }\n-}</code>\n+    fn <a href=\"#method.poll_write_vectored\" class=\"fn\">poll_write_vectored</a>(\n+        self: <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,\n+        cx: &amp;mut <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"{{channel}}/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt;,\n+        bufs: &amp;[<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>]\n+    ) -&gt; <a class=\"enum\" href=\"{{channel}}/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"{{channel}}/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"{{channel}}/std/primitive.usize.html\">usize</a>, <a class=\"struct\" href=\"struct.Error.html\" title=\"struct foo::Error\">Error</a>&gt;&gt; { ... }\n+}</code>\n\\ No newline at end of file"}, {"sha": "7ab82bb582965909480eee1defb38a96fe149ec6", "filename": "tests/rustdoc/generic-associated-types/gats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fgeneric-associated-types%2Fgats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fgeneric-associated-types%2Fgats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fgeneric-associated-types%2Fgats.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -2,7 +2,7 @@\n \n // @has foo/trait.LendingIterator.html\n pub trait LendingIterator {\n-    // @has - '//*[@id=\"associatedtype.Item\"]//h4[@class=\"code-header\"]' \"type Item<'a>where Self: 'a\"\n+    // @has - '//*[@id=\"associatedtype.Item\"]//h4[@class=\"code-header\"]' \"type Item<'a> where Self: 'a\"\n     type Item<'a> where Self: 'a;\n \n     // @has - '//*[@id=\"tymethod.next\"]//h4[@class=\"code-header\"]' \\\n@@ -23,7 +23,7 @@ impl LendingIterator for () {\n pub struct Infinite<T>(T);\n \n // @has foo/trait.LendingIterator.html\n-// @has - '//*[@id=\"associatedtype.Item-2\"]//h4[@class=\"code-header\"]' \"type Item<'a>where Self: 'a = &'a T\"\n+// @has - '//*[@id=\"associatedtype.Item-2\"]//h4[@class=\"code-header\"]' \"type Item<'a> where Self: 'a = &'a T\"\n impl<T> LendingIterator for Infinite<T> {\n     type Item<'a> where Self: 'a = &'a T;\n "}, {"sha": "b6a1552bc00caccca655c5439f64878f9567d8d4", "filename": "tests/rustdoc/inline_cross/impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline_cross%2Fimpl_trait.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -11,7 +11,7 @@ pub use impl_trait_aux::func;\n // @has impl_trait/fn.func2.html\n // @has - '//pre[@class=\"rust item-decl\"]' \"func2<T>(\"\n // @has - '//pre[@class=\"rust item-decl\"]' \"_x: impl Deref<Target = Option<T>> + Iterator<Item = T>,\"\n-// @has - '//pre[@class=\"rust item-decl\"]' \"_y: impl Iterator<Item = u8>)\"\n+// @has - '//pre[@class=\"rust item-decl\"]' \"_y: impl Iterator<Item = u8> )\"\n // @!has - '//pre[@class=\"rust item-decl\"]' 'where'\n pub use impl_trait_aux::func2;\n "}, {"sha": "4184086f622abaff7f57fb211360c358ccfe15c8", "filename": "tests/rustdoc/issue-34928.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fissue-34928.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fissue-34928.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-34928.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -2,5 +2,5 @@\n \n pub trait Bar {}\n \n-// @has foo/struct.Foo.html '//pre' 'pub struct Foo<T>(pub T)where T: Bar;'\n+// @has foo/struct.Foo.html '//pre' 'pub struct Foo<T>(pub T) where T: Bar;'\n pub struct Foo<T>(pub T) where T: Bar;"}, {"sha": "571d7f06fdc62e401f5b5c161b9a7f79247f4e44", "filename": "tests/rustdoc/reexports-priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Freexports-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Freexports-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexports-priv.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -98,7 +98,7 @@ pub mod outer {\n         pub use reexports::foo;\n         // @has 'foo/outer/inner/fn.foo_crate.html' '//pre[@class=\"rust item-decl\"]' 'pub(crate) fn foo_crate()'\n         pub(crate) use reexports::foo_crate;\n-        // @has 'foo/outer/inner/fn.foo_super.html' '//pre[@class=\"rust item-decl\"]' 'pub(in outer) fn foo_super()'\n+        // @has 'foo/outer/inner/fn.foo_super.html' '//pre[@class=\"rust item-decl\"]' 'pub(in outer) fn foo_super( )'\n         pub(super) use::reexports::foo_super;\n         // @!has 'foo/outer/inner/fn.foo_self.html'\n         pub(self) use reexports::foo_self;"}, {"sha": "ef4294c8f76d3c397131c17862c091e2de5f19f8", "filename": "tests/rustdoc/where.SWhere_Simd_item-decl.html", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhere.SWhere_Simd_item-decl.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1 +1,3 @@\n-<pre class=\"rust item-decl\"><code>pub struct Simd&lt;T&gt;(_)<br /><span class=\"where\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"trait.MyTrait.html\" title=\"trait foo::MyTrait\">MyTrait</a></span>;</code></pre>\n\\ No newline at end of file\n+<pre class=\"rust item-decl\"><code>pub struct Simd&lt;T&gt;(_)\n+<span class=\"where\">where\n+         T: <a class=\"trait\" href=\"trait.MyTrait.html\" title=\"trait foo::MyTrait\">MyTrait</a></span>;</code></pre>\n\\ No newline at end of file"}, {"sha": "e8ab061e679dd09f7f39d99ac6a5d397fa770da6", "filename": "tests/rustdoc/where.SWhere_TraitWhere_item-decl.html", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhere.SWhere_TraitWhere_item-decl.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,8 +1,13 @@\n <pre class=\"rust item-decl\"><code>pub trait TraitWhere {\n-    type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a>&lt;'a&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class=\"where\">where Self: 'a</span>;\n+    type <a href=\"#associatedtype.Item\" class=\"associatedtype\">Item</a>&lt;'a&gt;\n+       <span class=\"where\">where Self: 'a</span>;\n \n     // Provided methods\n-    fn <a href=\"#method.func\" class=\"fn\">func</a>(self)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class=\"where\">where Self: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a></span> { ... }\n-<span class=\"item-spacer\" />    fn <a href=\"#method.lines\" class=\"fn\">lines</a>(self) -&gt; <a class=\"struct\" href=\"{{channel}}/std/io/struct.Lines.html\" title=\"struct std::io::Lines\">Lines</a>&lt;Self&gt;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class=\"where\">where Self: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a></span> { ... }\n-<span class=\"item-spacer\" />    fn <a href=\"#method.merge\" class=\"fn\">merge</a>&lt;T&gt;(self, a: T)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class=\"where\">where Self: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a></span> { ... }\n+    fn <a href=\"#method.func\" class=\"fn\">func</a>(self)\n+       <span class=\"where\">where Self: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a></span> { ... }\n+<span class=\"item-spacer\" />    fn <a href=\"#method.lines\" class=\"fn\">lines</a>(self) -&gt; <a class=\"struct\" href=\"{{channel}}/std/io/struct.Lines.html\" title=\"struct std::io::Lines\">Lines</a>&lt;Self&gt;\n+       <span class=\"where\">where Self: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a></span> { ... }\n+<span class=\"item-spacer\" />    fn <a href=\"#method.merge\" class=\"fn\">merge</a>&lt;T&gt;(self, a: T)\n+       <span class=\"where\">where Self: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,\n+             T: <a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a></span> { ... }\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "8b8a126e89dd524c1364280c2f97445332bd1a98", "filename": "tests/rustdoc/where.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhere.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4,7 +4,7 @@ use std::io::Lines;\n \n pub trait MyTrait { fn dummy(&self) { } }\n \n-// @has foo/struct.Alpha.html '//pre' \"pub struct Alpha<A>(_)where A: MyTrait\"\n+// @has foo/struct.Alpha.html '//pre' \"pub struct Alpha<A>(_) where A: MyTrait\"\n pub struct Alpha<A>(A) where A: MyTrait;\n // @has foo/trait.Bravo.html '//pre' \"pub trait Bravo<B>where B: MyTrait\"\n pub trait Bravo<B> where B: MyTrait { fn get(&self, B: B); }"}, {"sha": "20b60b68e88cfed63dc3f9deb4a1c59fc19f2488", "filename": "tests/rustdoc/whitespace-after-where-clause.enum.html", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhitespace-after-where-clause.enum.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,4 +1,5 @@\n-<pre class=\"rust item-decl\"><code>pub enum Cow&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n+<pre class=\"rust item-decl\"><code>pub enum Cow&lt;'a, B&gt;<span class=\"where fmt-newline\">where\n+    B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     Borrowed(<a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a B</a>),\n     Whatever(<a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>),\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "948ddc499da8ad9c8c2b24fc43eb1ab3ba87d1ee", "filename": "tests/rustdoc/whitespace-after-where-clause.struct.html", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhitespace-after-where-clause.struct.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,4 +1,5 @@\n-<pre class=\"rust item-decl\"><code>pub struct Struct&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n+<pre class=\"rust item-decl\"><code>pub struct Struct&lt;'a, B&gt;<span class=\"where fmt-newline\">where\n+    B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     pub a: <a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a B</a>,\n     pub b: <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>,\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "0928b48e6b64cf9b9b1d1e8f998e32532cde13ac", "filename": "tests/rustdoc/whitespace-after-where-clause.trait.html", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.trait.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.trait.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhitespace-after-where-clause.trait.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,4 +1,5 @@\n-<pre class=\"rust item-decl\"><code>pub trait ToOwned&lt;T&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;T: <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</span>{\n+<pre class=\"rust item-decl\"><code>pub trait ToOwned&lt;T&gt;<span class=\"where fmt-newline\">where\n+    T: <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</span>{\n     type <a href=\"#associatedtype.Owned\" class=\"associatedtype\">Owned</a>;\n \n     // Required methods"}, {"sha": "38b6cb8b5c6131ddc25fac5f75acd81eb9eb0550", "filename": "tests/rustdoc/whitespace-after-where-clause.union.html", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fwhitespace-after-where-clause.union.html?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,3 +1,4 @@\n-<pre class=\"rust item-decl\"><code>pub union Union&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n+<pre class=\"rust item-decl\"><code>pub union Union&lt;'a, B&gt;<span class=\"where fmt-newline\">where\n+    B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     /* private fields */\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "2281d9419b461e03853b2b3b03e348501cb1271e", "filename": "tests/ui/associated-types/hr-associated-type-projection-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fhr-associated-type-projection-1.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -16,8 +16,8 @@ LL |     for<'b> <Self as UnsafeCopy<'b, T>>::Item: std::ops::Deref<Target = T>,\n    |                                                                ^^^^^^^^^^ required by this bound in `UnsafeCopy`\n help: consider further restricting this bound\n    |\n-LL | impl<T: Copy + std::ops::Deref + Deref<Target = T>> UnsafeCopy<'_, T> for T {\n-   |                                +++++++++++++++++++\n+LL | impl<T: Copy + std::ops::Deref<Target = T>> UnsafeCopy<'_, T> for T {\n+   |                               ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "1816d842d6c4179c0d57bb4513db215ea498b080", "filename": "tests/ui/async-await/future-sizes/async-awaiting-fut.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Z print-type-sizes --crate-type lib\n+// edition:2021\n+// build-pass\n+// ignore-pass\n+\n+async fn wait() {}\n+\n+async fn big_fut(arg: [u8; 1024]) {}\n+\n+async fn calls_fut(fut: impl std::future::Future<Output = ()>) {\n+    loop {\n+        wait().await;\n+        if true {\n+            return fut.await;\n+        } else {\n+            wait().await;\n+        }\n+    }\n+}\n+\n+pub async fn test() {\n+    let fut = big_fut([0u8; 1024]);\n+    calls_fut(fut).await;\n+}"}, {"sha": "eaf3e4b61e304a9241c510b538dd9a5dc794642a", "filename": "tests/ui/async-await/future-sizes/async-awaiting-fut.stdout", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ffuture-sizes%2Fasync-awaiting-fut.stdout?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,72 @@\n+print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:21:21: 24:2]`: 3078 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n+print-type-size     variant `Suspend0`: 3077 bytes\n+print-type-size         local `.__awaitee`: 3077 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 0 bytes\n+print-type-size     variant `Panicked`: 0 bytes\n+print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:10:64: 19:2]`: 3077 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 2051 bytes\n+print-type-size         padding: 1026 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size     variant `Suspend0`: 2052 bytes\n+print-type-size         local `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         local `..generator_field4`: 1 bytes\n+print-type-size         padding: 1 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `.__awaitee`: 1 bytes\n+print-type-size     variant `Suspend1`: 3076 bytes\n+print-type-size         padding: 1024 bytes\n+print-type-size         local `..generator_field4`: 1 bytes, alignment: 1 bytes\n+print-type-size         padding: 1 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `.__awaitee`: 1025 bytes\n+print-type-size     variant `Suspend2`: 2052 bytes\n+print-type-size         local `.fut`: 1025 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         local `..generator_field4`: 1 bytes\n+print-type-size         padding: 1 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size         local `.__awaitee`: 1 bytes\n+print-type-size     variant `Returned`: 2051 bytes\n+print-type-size         padding: 1026 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 2051 bytes\n+print-type-size         padding: 1026 bytes\n+print-type-size         upvar `.fut`: 1025 bytes, alignment: 1 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async-awaiting-fut.rs:10:64: 19:2]>`: 3077 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 3077 bytes\n+print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async-awaiting-fut.rs:10:64: 19:2]>`: 3077 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 3077 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 3077 bytes\n+print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:8:35: 8:37]`: 1025 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 1024 bytes\n+print-type-size         upvar `.arg`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 1024 bytes\n+print-type-size         upvar `.arg`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 1024 bytes\n+print-type-size         upvar `.arg`: 1024 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async-awaiting-fut.rs:8:35: 8:37]>`: 1025 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 1025 bytes\n+print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async-awaiting-fut.rs:8:35: 8:37]>`: 1025 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 1025 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 1025 bytes\n+print-type-size type: `[async fn body@$DIR/async-awaiting-fut.rs:6:17: 6:19]`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n+print-type-size     variant `Returned`: 0 bytes\n+print-type-size     variant `Panicked`: 0 bytes\n+print-type-size type: `std::mem::ManuallyDrop<bool>`: 1 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 1 bytes\n+print-type-size type: `std::mem::MaybeUninit<bool>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 1 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 1 bytes\n+print-type-size type: `std::task::Poll<()>`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Ready`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Pending`: 0 bytes"}, {"sha": "e42edf1d4af51ad13062ae292a9ed19a510401b1", "filename": "tests/ui/attributes/log-backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fattributes%2Flog-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fattributes%2Flog-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Flog-backtrace.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,9 +1,9 @@\n // run-pass\n //\n-// This test makes sure that log-backtrace option doesn't give a compilation error.\n+// This test makes sure that log-backtrace option at least parses correctly\n //\n // dont-check-compiler-stdout\n // dont-check-compiler-stderr\n // rustc-env:RUSTC_LOG=info\n-// compile-flags: -Zlog-backtrace=rustc_metadata::creader\n+// rustc-env:RUSTC_LOG_BACKTRACE=rustc_metadata::creader\n fn main() {}"}, {"sha": "81f28c1755deb452976804391ac6d6b5f9ce0d0b", "filename": "tests/ui/consts/const-eval/const-eval-query-stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,8 +1,7 @@\n // compile-flags: -Ztreat-err-as-bug=1\n // failure-status: 101\n // rustc-env:RUST_BACKTRACE=1\n-// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"\\nerror: .*unexpectedly panicked.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\""}, {"sha": "01fb8153cf3846c9be84c82096379456d5c275fc", "filename": "tests/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/const-eval-query-stack.rs:17:16\n+  --> $DIR/const-eval-query-stack.rs:16:16\n    |\n LL | const X: i32 = 1 / 0;\n    |                ^^^^^ attempt to divide `1_i32` by zero"}, {"sha": "58be4519720178b8fab1f5504fc43607bc8e05a9", "filename": "tests/ui/derives/deriving-with-repr-packed.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -33,4 +33,14 @@ struct FlexZeroSlice {\n     //~^^ this was previously accepted\n }\n \n+// Again, currently allowed, but will be phased out.\n+#[derive(Debug)]\n+#[repr(packed)]\n+struct WithStr {\n+    width: u8,\n+    data: str,\n+    //~^ WARNING string slice in a packed struct that derives a built-in trait\n+    //~^^ this was previously accepted\n+}\n+\n fn main() {}"}, {"sha": "0cfe03869af1bd6846e3e836dca9d12ee5f37fd0", "filename": "tests/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -13,6 +13,20 @@ LL |     data: [u8],\n    = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n    = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+warning: string slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-with-repr-packed.rs:41:5\n+   |\n+LL | #[derive(Debug)]\n+   |          ----- in this derive macro expansion\n+...\n+LL |     data: str,\n+   |     ^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0507]: cannot move out of `self` which is behind a shared reference\n   --> $DIR/deriving-with-repr-packed.rs:22:10\n    |\n@@ -24,7 +38,7 @@ LL | struct X(Y);\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error; 2 warnings emitted\n \n For more information about this error, try `rustc --explain E0507`.\n Future incompatibility report: Future breakage diagnostic:\n@@ -43,3 +57,19 @@ LL |     data: [u8],\n    = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n    = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+Future breakage diagnostic:\n+warning: string slice in a packed struct that derives a built-in trait\n+  --> $DIR/deriving-with-repr-packed.rs:41:5\n+   |\n+LL | #[derive(Debug)]\n+   |          ----- in this derive macro expansion\n+...\n+LL |     data: str,\n+   |     ^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #107457 <https://github.com/rust-lang/rust/issues/107457>\n+   = help: consider implementing the trait by hand, or remove the `packed` attribute\n+   = note: `#[warn(byte_slice_in_packed_struct_with_derive)]` on by default\n+   = note: this warning originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "0365d87a6f82aae88f3b23ce85dd8f398d69b2a1", "filename": "tests/ui/dyn-star/align.over_aligned.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Falign.over_aligned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Falign.over_aligned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Falign.over_aligned.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -7,13 +7,13 @@ LL | #![feature(dyn_star)]\n    = note: see issue #102425 <https://github.com/rust-lang/rust/issues/102425> for more information\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0277]: `AlignedUsize` needs to be a pointer-sized type\n+error[E0277]: `AlignedUsize` needs to have the same alignment and size as a pointer\n   --> $DIR/align.rs:15:13\n    |\n LL |     let x = AlignedUsize(12) as dyn* Debug;\n-   |             ^^^^^^^^^^^^^^^^ `AlignedUsize` needs to be a pointer-sized type\n+   |             ^^^^^^^^^^^^^^^^ `AlignedUsize` needs to be a pointer-like type\n    |\n-   = help: the trait `PointerSized` is not implemented for `AlignedUsize`\n+   = help: the trait `PointerLike` is not implemented for `AlignedUsize`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "6679997a9402917a5e269ce9ff576be23a481f07", "filename": "tests/ui/dyn-star/align.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Falign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Falign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Falign.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -13,5 +13,5 @@ struct AlignedUsize(usize);\n \n fn main() {\n     let x = AlignedUsize(12) as dyn* Debug;\n-    //[over_aligned]~^ ERROR `AlignedUsize` needs to be a pointer-sized type\n+    //[over_aligned]~^ ERROR `AlignedUsize` needs to have the same alignment and size as a pointer\n }"}, {"sha": "85749aa7b00e2a886db52603620c04cdd4e05662", "filename": "tests/ui/dyn-star/check-size-at-cast-polymorphic-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -9,7 +9,7 @@ fn dyn_debug(_: (dyn* Debug + '_)) {\n \n fn polymorphic<T: Debug + ?Sized>(t: &T) {\n     dyn_debug(t);\n-    //~^ ERROR `&T` needs to be a pointer-sized type\n+    //~^ ERROR `&T` needs to have the same alignment and size as a pointer\n }\n \n fn main() {}"}, {"sha": "350630f794138d31a4c28ffe45ed5c0bb0e29fb4", "filename": "tests/ui/dyn-star/check-size-at-cast-polymorphic-bad.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,14 +1,14 @@\n-error[E0277]: `&T` needs to be a pointer-sized type\n+error[E0277]: `&T` needs to have the same alignment and size as a pointer\n   --> $DIR/check-size-at-cast-polymorphic-bad.rs:11:15\n    |\n LL |     dyn_debug(t);\n-   |               ^ `&T` needs to be a pointer-sized type\n+   |               ^ `&T` needs to be a pointer-like type\n    |\n-   = help: the trait `PointerSized` is not implemented for `&T`\n+   = help: the trait `PointerLike` is not implemented for `&T`\n help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n-LL | fn polymorphic<T: Debug + ?Sized>(t: &T) where &T: PointerSized {\n-   |                                          ++++++++++++++++++++++\n+LL | fn polymorphic<T: Debug + ?Sized>(t: &T) where &T: PointerLike {\n+   |                                          +++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "17bc4f303bffabd1ad541756d76b45e791fa61c4", "filename": "tests/ui/dyn-star/check-size-at-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -5,6 +5,6 @@ use std::fmt::Debug;\n \n fn main() {\n     let i = [1, 2, 3, 4] as dyn* Debug;\n-    //~^ ERROR `[i32; 4]` needs to be a pointer-sized type\n+    //~^ ERROR `[i32; 4]` needs to have the same alignment and size as a pointer\n     dbg!(i);\n }"}, {"sha": "19700b40644006df9e1b388ade33cc10dad87b38", "filename": "tests/ui/dyn-star/check-size-at-cast.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,10 +1,10 @@\n-error[E0277]: `[i32; 4]` needs to be a pointer-sized type\n+error[E0277]: `[i32; 4]` needs to have the same alignment and size as a pointer\n   --> $DIR/check-size-at-cast.rs:7:13\n    |\n LL |     let i = [1, 2, 3, 4] as dyn* Debug;\n-   |             ^^^^^^^^^^^^ `[i32; 4]` needs to be a pointer-sized type\n+   |             ^^^^^^^^^^^^ `[i32; 4]` needs to be a pointer-like type\n    |\n-   = help: the trait `PointerSized` is not implemented for `[i32; 4]`\n+   = help: the trait `PointerLike` is not implemented for `[i32; 4]`\n \n error: aborting due to previous error\n "}, {"sha": "e60144fea74c348aa3a425f99581d59b3f4f5bfd", "filename": "tests/ui/dyn-star/upcast.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fupcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fdyn-star%2Fupcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fupcast.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -7,13 +7,13 @@ LL | #![feature(dyn_star, trait_upcasting)]\n    = note: see issue #102425 <https://github.com/rust-lang/rust/issues/102425> for more information\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0277]: `dyn* Foo` needs to be a pointer-sized type\n+error[E0277]: `dyn* Foo` needs to have the same alignment and size as a pointer\n   --> $DIR/upcast.rs:30:23\n    |\n LL |     let w: dyn* Bar = w;\n-   |                       ^ `dyn* Foo` needs to be a pointer-sized type\n+   |                       ^ `dyn* Foo` needs to be a pointer-like type\n    |\n-   = help: the trait `PointerSized` is not implemented for `dyn* Foo`\n+   = help: the trait `PointerLike` is not implemented for `dyn* Foo`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "47717fbd508a899d03729d19e5623e1fa33f6d24", "filename": "tests/ui/error-codes/E0523.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ferror-codes%2FE0523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ferror-codes%2FE0523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0523.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:crateresolve1-1.rs\n+// aux-build:crateresolve1-2.rs\n+// aux-build:crateresolve1-3.rs\n+\n+// normalize-stderr-test: \"\\.nll/\" -> \"/\"\n+// normalize-stderr-test: \"\\\\\\?\\\\\" -> \"\"\n+// normalize-stderr-test: \"(lib)?crateresolve1-([123])\\.[a-z]+\" -> \"libcrateresolve1-$2.somelib\"\n+\n+// NOTE: This test is duplicated from `tests/ui/crate-loading/crateresolve1.rs`.\n+\n+extern crate crateresolve1;\n+//~^ ERROR multiple candidates for `rlib` dependency `crateresolve1` found\n+\n+fn main() {}"}, {"sha": "8e3eb2159c298d7b20f14804dea3f63d1598b21e", "filename": "tests/ui/error-codes/E0523.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ferror-codes%2FE0523.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ferror-codes%2FE0523.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0523.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,13 @@\n+error[E0464]: multiple candidates for `rlib` dependency `crateresolve1` found\n+  --> $DIR/E0523.rs:11:1\n+   |\n+LL | extern crate crateresolve1;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: candidate #1: $TEST_BUILD_DIR/error-codes/E0523/auxiliary/libcrateresolve1-1.somelib\n+   = note: candidate #2: $TEST_BUILD_DIR/error-codes/E0523/auxiliary/libcrateresolve1-2.somelib\n+   = note: candidate #3: $TEST_BUILD_DIR/error-codes/E0523/auxiliary/libcrateresolve1-3.somelib\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0464`."}, {"sha": "5a18983a3fa709b892d0efa52feae2183d90a4aa", "filename": "tests/ui/fmt/respanned-literal-issue-106191.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -3,7 +3,7 @@\n // known-bug: #106191\n // unset-rustc-env:RUST_BACKTRACE\n // had to be reverted\n-// error-pattern:internal compiler error\n+// error-pattern:unexpectedly panicked\n // failure-status:101\n // dont-check-compiler-stderr\n "}, {"sha": "f0212e985a92cdd95e411b4fcc777ff8a6e859dc", "filename": "tests/ui/generic-associated-types/issue-68656-unsized-values.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -15,8 +15,8 @@ LL |     type Item<'a>: std::ops::Deref<Target = T>;\n    |                                    ^^^^^^^^^^ required by this bound in `UnsafeCopy::Item`\n help: consider further restricting this bound\n    |\n-LL | impl<T: Copy + std::ops::Deref + Deref<Target = T>> UnsafeCopy<T> for T {\n-   |                                +++++++++++++++++++\n+LL | impl<T: Copy + std::ops::Deref<Target = T>> UnsafeCopy<T> for T {\n+   |                               ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "054adbffbeafb66317e041b162ed5520584b4c3a", "filename": "tests/ui/generic-associated-types/missing-bounds.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4,7 +4,7 @@ use std::ops::Add;\n \n struct A<B>(B);\n \n-impl<B> Add for A<B> where B: Add + Add<Output = B> {\n+impl<B> Add for A<B> where B: Add<Output = B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n@@ -14,7 +14,7 @@ impl<B> Add for A<B> where B: Add + Add<Output = B> {\n \n struct C<B>(B);\n \n-impl<B: Add + Add<Output = B>> Add for C<B> {\n+impl<B: Add<Output = B>> Add for C<B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n@@ -34,7 +34,7 @@ impl<B: std::ops::Add<Output = B>> Add for D<B> {\n \n struct E<B>(B);\n \n-impl<B: Add + Add<Output = B>> Add for E<B> where B: Add<Output = B> {\n+impl<B: Add<Output = B>> Add for E<B> where B: Add<Output = B> {\n     //~^ ERROR equality constraints are not yet supported in `where` clauses\n     type Output = Self;\n "}, {"sha": "535edec575a7d715f1e061740db25993337a3ac4", "filename": "tests/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -37,8 +37,8 @@ LL | struct A<B>(B);\n    |        ^\n help: consider further restricting this bound\n    |\n-LL | impl<B> Add for A<B> where B: Add + Add<Output = B> {\n-   |                                   +++++++++++++++++\n+LL | impl<B> Add for A<B> where B: Add<Output = B> {\n+   |                                  ++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/missing-bounds.rs:21:14\n@@ -60,8 +60,8 @@ LL | struct C<B>(B);\n    |        ^\n help: consider further restricting this bound\n    |\n-LL | impl<B: Add + Add<Output = B>> Add for C<B> {\n-   |             +++++++++++++++++\n+LL | impl<B: Add<Output = B>> Add for C<B> {\n+   |            ++++++++++++\n \n error[E0369]: cannot add `B` to `B`\n   --> $DIR/missing-bounds.rs:31:21\n@@ -96,8 +96,8 @@ LL | struct E<B>(B);\n    |        ^\n help: consider further restricting this bound\n    |\n-LL | impl<B: Add + Add<Output = B>> Add for E<B> where <B as Add>::Output = B {\n-   |             +++++++++++++++++\n+LL | impl<B: Add<Output = B>> Add for E<B> where <B as Add>::Output = B {\n+   |            ++++++++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "f3a773837785e3a98f80e9fcc421b06006b29cb4", "filename": "tests/ui/impl-trait/issues/issue-86800.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -9,9 +9,7 @@ LL | type TransactionFuture<'__, O> = impl '__ + Future<Output = TransactionResu\n \n stack backtrace:\n \n-error: internal compiler error: unexpected panic\n-\n-\n+error: the compiler unexpectedly panicked. this is a bug.\n \n \n "}, {"sha": "d07aeb6c029fe57d5e92084d97f2f574dab75524", "filename": "tests/ui/issues/issue-92741.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fissues%2Fissue-92741.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fissues%2Fissue-92741.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-92741.fixed?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn main() {}\n+fn _foo() -> bool {\n+    if true { true } else { false }\n+}\n+\n+fn _bar() -> bool {\n+    if true { true } else { false }\n+}\n+\n+fn _baz() -> bool {\n+    if true { true } else { false }\n+}"}, {"sha": "413d5bf047853a1fb056e8557b70b43d1570318c", "filename": "tests/ui/issues/issue-92741.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fissues%2Fissue-92741.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fissues%2Fissue-92741.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-92741.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+fn main() {}\n+fn _foo() -> bool {\n+    &  //~ ERROR 4:5: 6:36: mismatched types [E0308]\n+    mut\n+    if true { true } else { false }\n+}\n+\n+fn _bar() -> bool {\n+    &  //~ ERROR 10:5: 11:40: mismatched types [E0308]\n+    mut if true { true } else { false }\n+}\n+\n+fn _baz() -> bool {\n+    & mut //~ ERROR 15:5: 16:36: mismatched types [E0308]\n+    if true { true } else { false }\n+}"}, {"sha": "49315e7a8bf6bc9ae748acc46965d414f02825fe", "filename": "tests/ui/issues/issue-92741.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fissues%2Fissue-92741.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fissues%2Fissue-92741.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-92741.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,49 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-92741.rs:4:5\n+   |\n+LL |   fn _foo() -> bool {\n+   |                ---- expected `bool` because of return type\n+LL | /     &\n+LL | |     mut\n+LL | |     if true { true } else { false }\n+   | |___________________________________^ expected `bool`, found `&mut bool`\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     &\n+LL -     mut\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-92741.rs:10:5\n+   |\n+LL |   fn _bar() -> bool {\n+   |                ---- expected `bool` because of return type\n+LL | /     &\n+LL | |     mut if true { true } else { false }\n+   | |_______________________________________^ expected `bool`, found `&mut bool`\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     &\n+LL -     mut if true { true } else { false }\n+LL +     if true { true } else { false }\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-92741.rs:15:5\n+   |\n+LL |   fn _baz() -> bool {\n+   |                ---- expected `bool` because of return type\n+LL | /     & mut\n+LL | |     if true { true } else { false }\n+   | |___________________________________^ expected `bool`, found `&mut bool`\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     & mut\n+   |\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a3a514fb830958beb540e7452e46f0733f02c019", "filename": "tests/ui/layout/valid_range_oob.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Flayout%2Fvalid_range_oob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Flayout%2Fvalid_range_oob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Fvalid_range_oob.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -1,4 +1,4 @@\n-error: internal compiler error: unexpected panic\n+error: the compiler unexpectedly panicked. this is a bug.\n \n query stack during panic:\n #0 [layout_of] computing layout of `Foo`"}, {"sha": "fdc2a7666d69b0a6ccbaad809fd933bf45124919", "filename": "tests/ui/macros/stringify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fstringify.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -626,7 +626,7 @@ fn test_item() {\n         stringify_item!(\n             impl ~const Struct {}\n         ),\n-        \"impl Struct {}\", // FIXME\n+        \"impl ~const Struct {}\",\n     );\n \n     // ItemKind::MacCall\n@@ -838,15 +838,15 @@ fn test_ty() {\n     assert_eq!(stringify_ty!(dyn Send + 'a), \"dyn Send + 'a\");\n     assert_eq!(stringify_ty!(dyn 'a + Send), \"dyn 'a + Send\");\n     assert_eq!(stringify_ty!(dyn ?Sized), \"dyn ?Sized\");\n-    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn ~const Clone\");\n     assert_eq!(stringify_ty!(dyn for<'a> Send), \"dyn for<'a> Send\");\n \n     // TyKind::ImplTrait\n     assert_eq!(stringify_ty!(impl Send), \"impl Send\");\n     assert_eq!(stringify_ty!(impl Send + 'a), \"impl Send + 'a\");\n     assert_eq!(stringify_ty!(impl 'a + Send), \"impl 'a + Send\");\n     assert_eq!(stringify_ty!(impl ?Sized), \"impl ?Sized\");\n-    assert_eq!(stringify_ty!(impl ~const Clone), \"impl Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(impl ~const Clone), \"impl ~const Clone\");\n     assert_eq!(stringify_ty!(impl for<'a> Send), \"impl for<'a> Send\");\n \n     // TyKind::Paren"}, {"sha": "14a45687875f849865d7d8168f74996cfef697e6", "filename": "tests/ui/mir/issue-107678-projection-with-lifetime.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fmir%2Fissue-107678-projection-with-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fmir%2Fissue-107678-projection-with-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fissue-107678-projection-with-lifetime.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,20 @@\n+// build-pass\n+\n+#![crate_type = \"lib\"]\n+\n+pub trait StreamOnce {\n+    type Error;\n+}\n+\n+pub trait ResetStream: StreamOnce {\n+    fn reset(&mut self) -> Result<(), Self::Error>;\n+}\n+\n+impl<'a> ResetStream for &'a str\n+    where Self: StreamOnce\n+{\n+    #[inline]\n+    fn reset(&mut self) -> Result<(), Self::Error> {\n+        Ok(())\n+    }\n+}"}, {"sha": "517a172089fe93e720a276ed51e89c822ee557c1", "filename": "tests/ui/mir/issue-107691.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fmir%2Fissue-107691.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fmir%2Fissue-107691.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fissue-107691.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,42 @@\n+// build-pass\n+// compile-flags: -C opt-level=3\n+\n+#![crate_type = \"lib\"]\n+\n+pub trait Archive {\n+    type Archived;\n+    type Resolver;\n+\n+    fn resolve(resolver: Self::Resolver, out: *mut Self::Archived);\n+}\n+\n+pub type Archived<T> = <T as Archive>::Archived;\n+pub type Resolver<T> = <T as Archive>::Resolver;\n+\n+pub struct Record<'a> {\n+    _payload: &'a [u8],\n+}\n+\n+pub struct ArchivedRecord<'a>\n+where\n+    &'a [u8]: Archive,\n+{\n+    _payload: Archived<&'a [u8]>,\n+}\n+\n+pub struct RecordResolver<'a>\n+where\n+    &'a [u8]: Archive,\n+{\n+    _payload: Resolver<&'a [u8]>,\n+}\n+\n+impl<'a> Archive for Record<'a>\n+where\n+    &'a [u8]: Archive,\n+{\n+    type Archived = ArchivedRecord<'a>;\n+    type Resolver = RecordResolver<'a>;\n+\n+    fn resolve(_resolver: Self::Resolver, _out: *mut Self::Archived) {}\n+}"}, {"sha": "7bf08bee9222465b3d01f963615c1fc7da3ba0aa", "filename": "tests/ui/panics/default-backtrace-ice.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4,9 +4,7 @@ LL | fn main() { missing_ident; }\n \n stack backtrace:\n \n-error: internal compiler error: unexpected panic\n-\n-\n+error: the compiler unexpectedly panicked. this is a bug.\n \n \n "}, {"sha": "218cd7678594fd072dff910ad52dc5b670ffd4eb", "filename": "tests/ui/parser/bad-recover-kw-after-impl.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fparser%2Fbad-recover-kw-after-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fparser%2Fbad-recover-kw-after-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbad-recover-kw-after-impl.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+// edition:2021\n+// for the `impl` + keyword test\n+\n+macro_rules! impl_primitive {\n+    ($ty:ty) => {\n+        compile_error!(\"whoops\");\n+    };\n+    (impl async) => {};\n+}\n+\n+impl_primitive!(impl async);\n+\n+fn main() {}"}, {"sha": "510e08ba091a4058f3e76fb08280e42a1c44c607", "filename": "tests/ui/parser/bad-recover-ty-after-impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fparser%2Fbad-recover-ty-after-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fparser%2Fbad-recover-ty-after-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbad-recover-ty-after-impl.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+macro_rules! impl_primitive {\n+    ($ty:ty) => { impl_primitive!(impl $ty); };\n+    (impl $ty:ty) => { fn a(_: $ty) {} }\n+}\n+\n+impl_primitive! { u8 }\n+\n+macro_rules! test {\n+    ($ty:ty) => { compile_error!(\"oh no\"); };\n+    (impl &) => {};\n+}\n+\n+test!(impl &);\n+\n+fn main() {}"}, {"sha": "64683ae3a6ebd13c175e91fb9dce51109f22c756", "filename": "tests/ui/recursion/issue-83150.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Frecursion%2Fissue-83150.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Frecursion%2Fissue-83150.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion%2Fissue-83150.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -9,9 +9,11 @@ LL |     func(&mut iter.map(|x| x + 1))\n    = help: a `loop` may express intention better if this is on purpose\n    = note: `#[warn(unconditional_recursion)]` on by default\n \n-error[E0275]: overflow evaluating the requirement `Map<&mut Map<&mut Map<&mut Map<..., ...>, ...>, ...>, ...>: Iterator`\n+error[E0275]: overflow evaluating the requirement `Map<&mut std::ops::Range<u8>, [closure@$DIR/issue-83150.rs:12:24: 12:27]>: Iterator`\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_83150`)\n+   = note: required for `&mut Map<&mut std::ops::Range<u8>, [closure@$DIR/issue-83150.rs:12:24: 12:27]>` to implement `Iterator`\n+   = note: 65 redundant requirements hidden\n    = note: required for `&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<..., ...>, ...>, ...>, ...>, ...>, ...>, ...>` to implement `Iterator`\n    = note: the full type name has been written to '$TEST_BUILD_DIR/recursion/issue-83150/issue-83150.long-type-hash.txt'\n "}, {"sha": "72edfbc97e48fb0b3421cad2dfb19eda8e5b880e", "filename": "tests/ui/rfc-2632-const-trait-impl/const_derives/derive-const-with-params.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-with-params.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(derive_const)]\n+#![feature(const_trait_impl)]\n+\n+#[derive_const(PartialEq)]\n+pub struct Reverse<T>(T);\n+\n+const fn foo(a: Reverse<i32>, b: Reverse<i32>) -> bool {\n+    a == b\n+}\n+\n+fn main() {}"}, {"sha": "07712ce0de684ae624bf3e527754e234eeb2c58b", "filename": "tests/ui/suggestions/restrict-existing-type-bounds.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Frestrict-existing-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Frestrict-existing-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Frestrict-existing-type-bounds.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,30 @@\n+pub trait TryAdd<Rhs = Self> {\n+    type Error;\n+    type Output;\n+\n+    fn try_add(self, rhs: Rhs) -> Result<Self::Output, Self::Error>;\n+}\n+\n+impl<T: TryAdd> TryAdd for Option<T> {\n+    type Error = <T as TryAdd>::Error;\n+    type Output = Option<<T as TryAdd>::Output>;\n+\n+    fn try_add(self, rhs: Self) -> Result<Self::Output, Self::Error> {\n+        Ok(self) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct Other<A>(A);\n+\n+struct X;\n+\n+impl<T: TryAdd<Error = X>> TryAdd for Other<T> {\n+    type Error = <T as TryAdd>::Error;\n+    type Output = Other<<T as TryAdd>::Output>;\n+\n+    fn try_add(self, rhs: Self) -> Result<Self::Output, Self::Error> {\n+        Ok(self) //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "14a244b790a6380d51eb4f486540d66c08247063", "filename": "tests/ui/suggestions/restrict-existing-type-bounds.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Frestrict-existing-type-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Frestrict-existing-type-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Frestrict-existing-type-bounds.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,57 @@\n+error[E0308]: mismatched types\n+  --> $DIR/restrict-existing-type-bounds.rs:13:12\n+   |\n+LL | impl<T: TryAdd> TryAdd for Option<T> {\n+   |      - this type parameter\n+...\n+LL |         Ok(self)\n+   |         -- ^^^^ expected `Option<<T as TryAdd>::Output>`, found `Option<T>`\n+   |         |\n+   |         arguments to this enum variant are incorrect\n+   |\n+   = note: expected enum `Option<<T as TryAdd>::Output>`\n+              found enum `Option<T>`\n+help: the type constructed contains `Option<T>` due to the type of the argument passed\n+  --> $DIR/restrict-existing-type-bounds.rs:13:9\n+   |\n+LL |         Ok(self)\n+   |         ^^^----^\n+   |            |\n+   |            this argument influences the type of `Ok`\n+note: tuple variant defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+help: consider further restricting this bound\n+   |\n+LL | impl<T: TryAdd<Output = T>> TryAdd for Option<T> {\n+   |               ++++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/restrict-existing-type-bounds.rs:26:12\n+   |\n+LL | impl<T: TryAdd<Error = X>> TryAdd for Other<T> {\n+   |      - this type parameter\n+...\n+LL |         Ok(self)\n+   |         -- ^^^^ expected `Other<<T as TryAdd>::Output>`, found `Other<T>`\n+   |         |\n+   |         arguments to this enum variant are incorrect\n+   |\n+   = note: expected struct `Other<<T as TryAdd>::Output>`\n+              found struct `Other<T>`\n+help: the type constructed contains `Other<T>` due to the type of the argument passed\n+  --> $DIR/restrict-existing-type-bounds.rs:26:9\n+   |\n+LL |         Ok(self)\n+   |         ^^^----^\n+   |            |\n+   |            this argument influences the type of `Ok`\n+note: tuple variant defined here\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+help: consider further restricting this bound\n+   |\n+LL | impl<T: TryAdd<Error = X, Output = T>> TryAdd for Other<T> {\n+   |                         ++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "80cd2ca7dfc9afd0e7f732c47ed84f8d61b2af9c", "filename": "tests/ui/suggestions/type-mismatch-byte-literal.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Ftype-mismatch-byte-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Ftype-mismatch-byte-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-mismatch-byte-literal.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -12,7 +12,19 @@ fn main() {\n     //~^ ERROR: mismatched types [E0308]\n     //~| HELP: if you meant to write a byte literal, prefix with `b`\n \n+    let _a: u8 = '\\x20';\n+    //~^ ERROR: mismatched types [E0308]\n+    //~| HELP: if you meant to write a byte literal, prefix with `b`\n+\n+    // Do not issue the suggestion if the char literal is a Unicode escape\n+    foo('\\u{0080}');\n+    //~^ ERROR: mismatched types [E0308]\n+\n     // Do not issue the suggestion if the char literal isn't ASCII\n     let _t: u8 = '\u20ac';\n     //~^ ERROR: mismatched types [E0308]\n+\n+    // Do not issue the suggestion if the char literal isn't ASCII\n+    foo('\\u{1f980}');\n+    //~^ ERROR: mismatched types [E0308]\n }"}, {"sha": "3d27149f0dcf13704a737b6541e94009b4800c7c", "filename": "tests/ui/suggestions/type-mismatch-byte-literal.stderr", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Ftype-mismatch-byte-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Fsuggestions%2Ftype-mismatch-byte-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-mismatch-byte-literal.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -30,13 +30,54 @@ LL |     foo(b'#');\n    |         ~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/type-mismatch-byte-literal.rs:16:18\n+  --> $DIR/type-mismatch-byte-literal.rs:15:18\n+   |\n+LL |     let _a: u8 = '\\x20';\n+   |             --   ^^^^^^ expected `u8`, found `char`\n+   |             |\n+   |             expected due to this\n+   |\n+help: if you meant to write a byte literal, prefix with `b`\n+   |\n+LL |     let _a: u8 = b'\\x20';\n+   |                  ~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch-byte-literal.rs:20:9\n+   |\n+LL |     foo('\\u{0080}');\n+   |     --- ^^^^^^^^^^ expected `u8`, found `char`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/type-mismatch-byte-literal.rs:4:4\n+   |\n+LL | fn foo(_t: u8) {}\n+   |    ^^^ ------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch-byte-literal.rs:24:18\n    |\n LL |     let _t: u8 = '\u20ac';\n    |             --   ^^^ expected `u8`, found `char`\n    |             |\n    |             expected due to this\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch-byte-literal.rs:28:9\n+   |\n+LL |     foo('\\u{1f980}');\n+   |     --- ^^^^^^^^^^^ expected `u8`, found `char`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/type-mismatch-byte-literal.rs:4:4\n+   |\n+LL | fn foo(_t: u8) {}\n+   |    ^^^ ------\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "3745a075e6a448086ed3396469b3e19b0c3d8954", "filename": "tests/ui/traits/new-solver/pointer-like.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-like.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+#![feature(pointer_like_trait)]\n+\n+use std::marker::PointerLike;\n+\n+fn require_(_: impl PointerLike) {}\n+\n+fn main() {\n+    require_(1usize);\n+    require_(1u16);\n+    //~^ ERROR `u16` needs to have the same alignment and size as a pointer\n+    require_(&1i16);\n+}"}, {"sha": "f695e64187d4423d0603a11c29347955aee7c374", "filename": "tests/ui/traits/new-solver/pointer-like.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-like.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-like.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-like.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: `u16` needs to have the same alignment and size as a pointer\n+  --> $DIR/pointer-like.rs:11:14\n+   |\n+LL |     require_(1u16);\n+   |     -------- ^^^^ the trait `PointerLike` is not implemented for `u16`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: the trait bound `u16: PointerLike` is not satisfied\n+note: required by a bound in `require_`\n+  --> $DIR/pointer-like.rs:7:21\n+   |\n+LL | fn require_(_: impl PointerLike) {}\n+   |                     ^^^^^^^^^^^ required by this bound in `require_`\n+help: consider borrowing here\n+   |\n+LL |     require_(&1u16);\n+   |              +\n+LL |     require_(&mut 1u16);\n+   |              ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "15681cd132ec64b583380bbff700f3119bace75f", "filename": "tests/ui/traits/new-solver/pointer-sized.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/185156280f8e952a864c5f4f4c4daa03bc04d46c/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185156280f8e952a864c5f4f4c4daa03bc04d46c/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs?ref=185156280f8e952a864c5f4f4c4daa03bc04d46c", "patch": "@@ -1,12 +0,0 @@\n-#![feature(pointer_sized_trait)]\n-\n-use std::marker::PointerSized;\n-\n-fn require_pointer_sized(_: impl PointerSized) {}\n-\n-fn main() {\n-    require_pointer_sized(1usize);\n-    require_pointer_sized(1u16);\n-    //~^ ERROR `u16` needs to be a pointer-sized type\n-    require_pointer_sized(&1i16);\n-}"}, {"sha": "b250b1331bbf9ef1083cc1349d7b6e74ec91e7f7", "filename": "tests/ui/traits/new-solver/pointer-sized.stderr", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/185156280f8e952a864c5f4f4c4daa03bc04d46c/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/185156280f8e952a864c5f4f4c4daa03bc04d46c/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr?ref=185156280f8e952a864c5f4f4c4daa03bc04d46c", "patch": "@@ -1,24 +0,0 @@\n-error[E0277]: `u16` needs to be a pointer-sized type\n-  --> $DIR/pointer-sized.rs:9:27\n-   |\n-LL |     require_pointer_sized(1u16);\n-   |     --------------------- ^^^^ the trait `PointerSized` is not implemented for `u16`\n-   |     |\n-   |     required by a bound introduced by this call\n-   |\n-   = note: the trait bound `u16: PointerSized` is not satisfied\n-note: required by a bound in `require_pointer_sized`\n-  --> $DIR/pointer-sized.rs:5:34\n-   |\n-LL | fn require_pointer_sized(_: impl PointerSized) {}\n-   |                                  ^^^^^^^^^^^^ required by this bound in `require_pointer_sized`\n-help: consider borrowing here\n-   |\n-LL |     require_pointer_sized(&1u16);\n-   |                           +\n-LL |     require_pointer_sized(&mut 1u16);\n-   |                           ++++\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "a3d97927bad2222037e19e1b5baa705e897a2278", "filename": "tests/ui/traits/new-solver/provisional-result-done.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,37 @@\n+// known-bug: unknown\n+// compile-flags: -Ztrait-solver=next\n+// failure-status: 101\n+// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n+\n+// This tests checks that we update results in the provisional cache when\n+// we pop a goal from the stack.\n+#![feature(auto_traits)]\n+auto trait Coinductive {}\n+struct Foo<T>(T);\n+struct Bar<T>(T);\n+\n+impl<T> Coinductive for Foo<T>\n+where\n+    Bar<T>: Coinductive\n+{}\n+\n+impl<T> Coinductive for Bar<T>\n+where\n+    Foo<T>: Coinductive,\n+    Bar<T>: ConstrainInfer,\n+{}\n+\n+trait ConstrainInfer {}\n+impl ConstrainInfer for Bar<u8> {}\n+impl ConstrainInfer for Foo<u16> {}\n+\n+fn impls<T: Coinductive>() -> T { todo!() }\n+\n+fn constrain<T: ConstrainInfer>(_: T) {}\n+\n+fn main() {\n+    // This should constrain `_` to `u8`.\n+    impls::<Foo<_>>();\n+}"}, {"sha": "ffc92b81f089e7d3b0c83443b62fb5a9d745d49e", "filename": "tests/ui/traits/new-solver/provisional-result-done.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,6 @@\n+error: the compiler unexpectedly panicked. this is a bug.\n+\n+query stack during panic:\n+#0 [check_well_formed] checking that `<impl at $DIR/provisional-result-done.rs:20:1: 20:31>` is well-formed\n+#1 [check_mod_type_wf] checking that types are well-formed in top-level module\n+end of query stack"}, {"sha": "22c6175048a63ecff25877a248f98d99c970b54a", "filename": "tests/ui/treat-err-as-bug/delay_span_bug.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4,7 +4,7 @@ error: internal compiler error: delayed span bug triggered by #[rustc_error(dela\n LL | fn main() {}\n    | ^^^^^^^^^\n \n-error: internal compiler error: unexpected panic\n+error: the compiler unexpectedly panicked. this is a bug.\n \n query stack during panic:\n #0 [trigger_delay_span_bug] triggering a delay span bug"}, {"sha": "3a56445a26b58102caea740bef520fef157f3a00", "filename": "tests/ui/treat-err-as-bug/err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftreat-err-as-bug%2Ferr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftreat-err-as-bug%2Ferr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftreat-err-as-bug%2Ferr.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -4,7 +4,7 @@ error[E0080]: could not evaluate static initializer\n LL | pub static C: u32 = 0 - 1;\n    |                     ^^^^^ attempt to compute `0_u32 - 1_u32`, which would overflow\n \n-error: internal compiler error: unexpected panic\n+error: the compiler unexpectedly panicked. this is a bug.\n \n query stack during panic:\n #0 [eval_to_allocation_raw] const-evaluating + checking `C`"}, {"sha": "6fbac2ee9758e26eada49c860323cbf4c8a58519", "filename": "tests/ui/typeck/issue-107775.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftypeck%2Fissue-107775.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftypeck%2Fissue-107775.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107775.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,40 @@\n+// edition: 2021\n+\n+use std::collections::HashMap;\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+pub trait Trait {\n+    fn do_something<'async_trait>(byte: u8)\n+    ->\n+        Pin<Box<dyn Future<Output = ()> +\n+        Send + 'async_trait>>;\n+}\n+\n+pub struct Struct;\n+\n+impl Trait for Struct {\n+    fn do_something<'async_trait>(byte: u8)\n+        ->\n+            Pin<Box<dyn Future<Output = ()> +\n+            Send + 'async_trait>> {\n+        Box::pin(\n+\n+            async move { let byte = byte; let _: () = {}; })\n+    }\n+}\n+\n+pub struct Map {\n+    map: HashMap<u16, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>>>,\n+}\n+\n+impl Map {\n+    pub fn new() -> Self {\n+        let mut map = HashMap::new();\n+        map.insert(1, Struct::do_something);\n+        Self { map }\n+        //~^ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9ee9c022c6e8cc978514a33e27493d09481b514b", "filename": "tests/ui/typeck/issue-107775.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107775.stderr?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-107775.rs:35:16\n+   |\n+LL |         map.insert(1, Struct::do_something);\n+   |                    -  -------------------- this is of type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+   |                    |\n+   |                    this is of type `{integer}`, which causes `map` to be inferred as `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+LL |         Self { map }\n+   |                ^^^ expected `HashMap<u16, fn(u8) -> Pin<...>>`, found `HashMap<{integer}, ...>`\n+   |\n+   = note: expected struct `HashMap<u16, fn(_) -> Pin<Box<(dyn Future<Output = ()> + Send + 'static)>>>`\n+              found struct `HashMap<{integer}, fn(_) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "dbcba7871ec96fdd86ce86d0fb4263cf783b451a", "filename": "tests/ui/unpretty/ast-const-trait-bound.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Funpretty%2Fast-const-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Funpretty%2Fast-const-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funpretty%2Fast-const-trait-bound.rs?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: -Zunpretty=normal\n+// check-pass\n+\n+fn foo() where T: ~const Bar {}"}, {"sha": "dbcba7871ec96fdd86ce86d0fb4263cf783b451a", "filename": "tests/ui/unpretty/ast-const-trait-bound.stdout", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Funpretty%2Fast-const-trait-bound.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6f451fca0dc7f9ab9f341fb529f861fafd205b2f/tests%2Fui%2Funpretty%2Fast-const-trait-bound.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funpretty%2Fast-const-trait-bound.stdout?ref=6f451fca0dc7f9ab9f341fb529f861fafd205b2f", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: -Zunpretty=normal\n+// check-pass\n+\n+fn foo() where T: ~const Bar {}"}]}