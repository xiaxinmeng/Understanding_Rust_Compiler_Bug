{"sha": "b1646cbfd908dc948b251e362669af421100647a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNjQ2Y2JmZDkwOGRjOTQ4YjI1MWUzNjI2NjlhZjQyMTEwMDY0N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-21T02:11:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-21T02:11:22Z"}, "message": "auto merge of #14731 : jakub-/rust/pattern-matching-refactor, r=alexcrichton\n\nThis PR is changing the error messages for non-exhaustive pattern matching to include a more accurate witness, i.e. a pattern that is not covered by any of the ones provided by the user. Example:\r\n\r\n```rust\r\nfn main() {\r\n\tmatch (true, (Some(\"foo\"), [true, true]), Some(42u)) {\r\n\t\t(false, _, _) => (),\r\n\t\t(true, (None, [true, _]), None) => (),\r\n\t\t(true, (None, [false, _]), Some(1u)) => ()\r\n\t}\r\n}\r\n```\r\n\r\n```sh\r\n/tmp/witness.rs:2:2: 6:3 error: non-exhaustive patterns: (true, (core::option::Some(_), _), _) not covered\r\n/tmp/witness.rs:2 \tmatch (true, (Some(\"foo\"), [true, true]), Some(42u)) {\r\n/tmp/witness.rs:3 \t\t(false, _, _) => (),\r\n/tmp/witness.rs:4 \t\t(true, (None, [true, _]), None) => (),\r\n/tmp/witness.rs:5 \t\t(true, (None, [false, _]), Some(1u)) => ()\r\n/tmp/witness.rs:6 \t}\r\n```\r\n\r\nAs part of that, I refactored some of the relevant code and carried over the changes to fixed vectors from the previous PR.\r\n\r\nI'm putting it out there for now but the tests will be red.", "tree": {"sha": "4ee04c45c4e5925fe948aa63f99e7ec3b5b47925", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ee04c45c4e5925fe948aa63f99e7ec3b5b47925"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1646cbfd908dc948b251e362669af421100647a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1646cbfd908dc948b251e362669af421100647a", "html_url": "https://github.com/rust-lang/rust/commit/b1646cbfd908dc948b251e362669af421100647a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1646cbfd908dc948b251e362669af421100647a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2563481ca93877551116b11cde3cc7e21f1d6048", "url": "https://api.github.com/repos/rust-lang/rust/commits/2563481ca93877551116b11cde3cc7e21f1d6048", "html_url": "https://github.com/rust-lang/rust/commit/2563481ca93877551116b11cde3cc7e21f1d6048"}, {"sha": "a88819adbecabd9f26aec4423415044db4f66279", "url": "https://api.github.com/repos/rust-lang/rust/commits/a88819adbecabd9f26aec4423415044db4f66279", "html_url": "https://github.com/rust-lang/rust/commit/a88819adbecabd9f26aec4423415044db4f66279"}], "stats": {"total": 1374, "additions": 728, "deletions": 646}, "files": [{"sha": "6d8b178ba0014092bd77de97831a92279b43a2c1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 490, "deletions": 583, "changes": 1073, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -10,23 +10,57 @@\n \n #![allow(non_camel_case_types)]\n \n-use middle::const_eval::{compare_const_vals, lookup_const_by_id};\n-use middle::const_eval::{eval_const_expr, const_val, const_bool, const_float};\n+use middle::const_eval::{compare_const_vals, const_bool, const_float, const_val};\n+use middle::const_eval::{eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n-use util::ppaux::ty_to_str;\n \n-use std::cmp;\n use std::gc::{Gc, GC};\n use std::iter;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n-use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token;\n+use syntax::codemap::{Span, Spanned, DUMMY_SP};\n+use syntax::owned_slice::OwnedSlice;\n+use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n+use util::ppaux::ty_to_str;\n+\n+type Matrix = Vec<Vec<Gc<Pat>>>;\n+\n+#[deriving(Clone)]\n+enum Usefulness {\n+    Useful(Vec<Gc<Pat>>),\n+    NotUseful\n+}\n+\n+enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness\n+}\n+\n+impl Usefulness {\n+    fn useful(self) -> Option<Vec<Gc<Pat>>> {\n+        match self {\n+            Useful(pats) => Some(pats),\n+            _ => None\n+        }\n+    }\n+}\n+\n+fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n+    ty::with_path(tcx, id, |mut path| Path {\n+        global: false,\n+        segments: path.last().map(|elem| PathSegment {\n+            identifier: Ident::new(elem.name()),\n+            lifetimes: vec!(),\n+            types: OwnedSlice::empty()\n+        }).move_iter().collect(),\n+        span: DUMMY_SP,\n+    })\n+}\n \n struct MatchCheckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n@@ -58,38 +92,39 @@ pub fn check_crate(tcx: &ty::ctxt,\n fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     visit::walk_expr(cx, ex, ());\n     match ex.node {\n-      ExprMatch(scrut, ref arms) => {\n-        // First, check legality of move bindings.\n-        for arm in arms.iter() {\n-            check_legality_of_move_bindings(cx,\n-                                            arm.guard.is_some(),\n-                                            arm.pats.as_slice());\n-        }\n+        ExprMatch(scrut, ref arms) => {\n+            // First, check legality of move bindings.\n+            for arm in arms.iter() {\n+                check_legality_of_move_bindings(cx,\n+                                                arm.guard.is_some(),\n+                                                arm.pats.as_slice());\n+            }\n \n-        check_arms(cx, arms.as_slice());\n-        /* Check for exhaustiveness */\n-         // Check for empty enum, because is_useful only works on inhabited\n-         // types.\n-       let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n-       if (*arms).is_empty() {\n-           if !type_is_empty(cx.tcx, pat_ty) {\n-               // We know the type is inhabited, so this must be wrong\n-               cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n-                            type {} is non-empty\",\n-                            ty_to_str(cx.tcx, pat_ty)).as_slice());\n-           }\n-           // If the type *is* empty, it's vacuously exhaustive\n-           return;\n-       }\n-       let m: matrix = arms\n-          .iter()\n-          .filter(|&arm| is_unguarded(arm))\n-          .flat_map(|arm| arm.pats.iter())\n-          .map(|pat| vec!(pat.clone()))\n-          .collect();\n-       check_exhaustive(cx, ex.span, &m);\n-     }\n-     _ => ()\n+            // Second, check for unreachable arms.\n+            check_arms(cx, arms.as_slice());\n+\n+            // Finally, check if the whole match expression is exhaustive.\n+            // Check for empty enum, because is_useful only works on inhabited types.\n+            let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n+            if (*arms).is_empty() {\n+               if !type_is_empty(cx.tcx, pat_ty) {\n+                   // We know the type is inhabited, so this must be wrong\n+                   cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n+                                type {} is non-empty\",\n+                                ty_to_str(cx.tcx, pat_ty)).as_slice());\n+               }\n+               // If the type *is* empty, it's vacuously exhaustive\n+               return;\n+            }\n+            let m: Matrix = arms\n+                .iter()\n+                .filter(|&arm| is_unguarded(arm))\n+                .flat_map(|arm| arm.pats.iter())\n+                .map(|pat| vec!(pat.clone()))\n+                .collect();\n+            check_exhaustive(cx, ex.span, &m);\n+        },\n+        _ => ()\n     }\n }\n \n@@ -98,7 +133,6 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     let mut seen = Vec::new();\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n-\n             // Check that we do not match against a static NaN (#6804)\n             let pat_matches_nan: |&Pat| -> bool = |p| {\n                 let opt_def = cx.tcx.def_map.borrow().find_copy(&p.id);\n@@ -123,11 +157,9 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n             });\n \n             let v = vec!(*pat);\n-            match is_useful(cx, &seen, v.as_slice()) {\n-              not_useful => {\n-                cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n-              }\n-              _ => ()\n+            match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n+                NotUseful => cx.tcx.sess.span_err(pat.span, \"unreachable pattern\"),\n+                _ => ()\n             }\n             if arm.guard.is_none() { seen.push(v); }\n         }\n@@ -136,80 +168,163 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n \n fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n     match p.node {\n-      PatIdent(_, _, Some(s)) => { raw_pat(s) }\n-      _ => { p }\n+        PatIdent(_, _, Some(s)) => { raw_pat(s) }\n+        _ => { p }\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &matrix) {\n-    let ext = match is_useful(cx, m, [wild()]) {\n-        not_useful => {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n+    match is_useful(cx, m, [wild()], ConstructWitness) {\n+        NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n         }\n-        useful_ => None,\n-        useful(ty, ref ctor) => {\n+        Useful(pats) => {\n+            let witness = match pats.as_slice() {\n+                [witness] => witness,\n+                [] => wild(),\n+                _ => unreachable!()\n+            };\n+            let msg = format!(\"non-exhaustive patterns: `{0}` not covered\", pat_to_str(&*witness));\n+            cx.tcx.sess.span_err(sp, msg.as_slice());\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, PartialEq)]\n+enum ctor {\n+    single,\n+    variant(DefId /* variant */, bool /* is_structure */),\n+    val(const_val),\n+    range(const_val, const_val),\n+    vec(uint)\n+}\n+\n+fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n+    let node = match value {\n+        &const_bool(b) => LitBool(b),\n+        _ => unreachable!()\n+    };\n+    box(GC) Expr {\n+        id: 0,\n+        node: ExprLit(box(GC) Spanned { node: node, span: DUMMY_SP }),\n+        span: DUMMY_SP\n+    }\n+}\n+\n+fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty: ty::t) -> Gc<Pat> {\n+    let pat = match ty::get(lty).sty {\n+        ty::ty_tup(_) => PatTup(pats),\n+\n+        ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n+            let (vid, is_structure) = match ctor {\n+                &variant(vid, is_structure) => (vid, is_structure),\n+                _ => (cid, true)\n+            };\n+            if is_structure {\n+                let fields = ty::lookup_struct_fields(cx.tcx, vid);\n+                let field_pats = fields.move_iter()\n+                    .zip(pats.iter())\n+                    .map(|(field, pat)| FieldPat {\n+                        ident: Ident::new(field.name),\n+                        pat: pat.clone()\n+                    }).collect();\n+                PatStruct(def_to_path(cx.tcx, vid), field_pats, false)\n+            } else {\n+                PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n+            }\n+        },\n+\n+        ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n             match ty::get(ty).sty {\n-                ty::ty_bool => {\n-                    match *ctor {\n-                        val(const_bool(true)) => Some(\"true\".to_string()),\n-                        val(const_bool(false)) => Some(\"false\".to_string()),\n-                        _ => None\n-                    }\n-                }\n-                ty::ty_enum(id, _) => {\n-                    let vid = match *ctor {\n-                        variant(id) => id,\n-                        _ => fail!(\"check_exhaustive: non-variant ctor\"),\n-                    };\n-                    let variants = ty::enum_variants(cx.tcx, id);\n-\n-                    match variants.iter().find(|v| v.id == vid) {\n-                        Some(v) => {\n-                            Some(token::get_ident(v.name).get()\n-                                                         .to_str()\n-                                                         .into_string())\n-                        }\n-                        None => {\n-                            fail!(\"check_exhaustive: bad variant in ctor\")\n-                        }\n-                    }\n-                }\n-                ty::ty_vec(..) | ty::ty_rptr(..) => {\n-                    match *ctor {\n-                        vec(n) => {\n-                            Some(format!(\"vectors of length {}\", n))\n-                        }\n-                        _ => None\n-                    }\n+                ty::ty_vec(_, None) => match ctor {\n+                    &vec(_) => PatVec(pats, None, vec!()),\n+                    _ => unreachable!()\n+                },\n+                ty::ty_str => PatWild,\n+                _ => {\n+                    assert_eq!(pats.len(), 1);\n+                    PatRegion(pats.get(0).clone())\n                 }\n-                _ => None\n+            }\n+        },\n+\n+        ty::ty_box(_) => {\n+            assert_eq!(pats.len(), 1);\n+            PatBox(pats.get(0).clone())\n+        },\n+\n+        _ => {\n+            match ctor {\n+                &vec(_) => PatVec(pats, None, vec!()),\n+                &val(ref v) => PatLit(const_val_to_expr(v)),\n+                _ => PatWild\n             }\n         }\n     };\n-    let msg = format!(\"non-exhaustive patterns{}\", match ext {\n-        Some(ref s) => format!(\": {} not covered\", *s),\n-        None => \"\".to_string()\n-    });\n-    cx.tcx.sess.span_err(sp, msg.as_slice());\n+\n+    box(GC) Pat {\n+        id: 0,\n+        node: pat,\n+        span: DUMMY_SP\n+    }\n }\n \n-type matrix = Vec<Vec<Gc<Pat>>>;\n+fn missing_constructor(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Option<ctor> {\n+    let used_constructors: Vec<ctor> = m.iter()\n+        .filter_map(|r| pat_ctor_id(cx, left_ty, *r.get(0)))\n+        .collect();\n \n-#[deriving(Clone)]\n-enum useful {\n-    useful(ty::t, ctor),\n-    useful_,\n-    not_useful,\n+    all_constructors(cx, m, left_ty)\n+        .move_iter()\n+        .find(|c| !used_constructors.contains(c))\n }\n \n-#[deriving(Clone, PartialEq)]\n-enum ctor {\n-    single,\n-    variant(DefId),\n-    val(const_val),\n-    range(const_val, const_val),\n-    vec(uint)\n+fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor> {\n+    fn vec_constructors(m: &Matrix) -> Vec<ctor> {\n+        let max_vec_len = m.iter().map(|r| match r.get(0).node {\n+            PatVec(ref before, _, ref after) => before.len() + after.len(),\n+            _ => 0u\n+        }).max().unwrap_or(0u);\n+        let contains_slice = m.iter().any(|r| match r.get(0).node {\n+            PatVec(_, ref slice, _) => slice.is_some(),\n+            _ => false\n+        });\n+        let lengths = iter::range_inclusive(0u, if contains_slice {\n+            max_vec_len\n+        } else {\n+            max_vec_len + 1\n+        });\n+        lengths.map(|len| vec(len)).collect()\n+    }\n+\n+    match ty::get(left_ty).sty {\n+        ty::ty_bool =>\n+            [true, false].iter().map(|b| val(const_bool(*b))).collect(),\n+\n+        ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) => vec_constructors(m),\n+            _ => vec!(single)\n+        },\n+\n+        ty::ty_enum(eid, _) =>\n+            ty::enum_variants(cx.tcx, eid)\n+                .iter()\n+                .map(|va| variant(va.id, va.arg_names.is_some()))\n+                .collect(),\n+\n+        ty::ty_vec(_, None) =>\n+            vec_constructors(m),\n+\n+        ty::ty_vec(_, Some(n)) =>\n+            vec!(vec(n)),\n+\n+        ty::ty_nil if !m.iter().all(|r| is_wild(cx, *r.get(0))) =>\n+            vec!(),\n+\n+        _ =>\n+            vec!(single)\n+    }\n }\n \n // Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n@@ -225,12 +340,13 @@ enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[Gc<Pat>]) -> useful {\n+fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n+             witness: WitnessPreference) -> Usefulness {\n     if m.len() == 0u {\n-        return useful_;\n+        return Useful(vec!());\n     }\n     if m.get(0).len() == 0u {\n-        return not_useful\n+        return NotUseful;\n     }\n     let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n         Some(r) => {\n@@ -241,310 +357,156 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[Gc<Pat>]) -> useful {\n                 _ => *r.get(0)\n             }\n         }\n-        None if v.len() == 0 => return not_useful,\n+        None if v.len() == 0 => return NotUseful,\n         None => v[0]\n     };\n-    let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n-                  else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n-\n-    match pat_ctor_id(cx, v[0]) {\n-      None => {\n-        match missing_ctor(cx, m, left_ty) {\n-          None => {\n-            match ty::get(left_ty).sty {\n-              ty::ty_bool => {\n-                  match is_useful_specialized(cx, m, v,\n-                                              val(const_bool(true)),\n-                                              0u, left_ty){\n-                      not_useful => {\n-                          is_useful_specialized(cx, m, v,\n-                                                val(const_bool(false)),\n-                                                0u, left_ty)\n-                      }\n-                      u => u,\n-                  }\n-              }\n-              ty::ty_enum(eid, _) => {\n-                  for va in (*ty::enum_variants(cx.tcx, eid)).iter() {\n-                      match is_useful_specialized(cx, m, v, variant(va.id),\n-                                                  va.args.len(), left_ty) {\n-                        not_useful => (),\n-                        u => return u,\n-                      }\n-                  }\n-                  not_useful\n-              }\n-              ty::ty_vec(_, Some(n)) => {\n-                  is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n-              }\n-              ty::ty_vec(..) => fail!(\"impossible case\"),\n-              ty::ty_rptr(_, ty::mt{ty: ty, ..}) | ty::ty_uniq(ty) => match ty::get(ty).sty {\n-                  ty::ty_vec(_, None) => {\n-                      let max_len = m.iter().rev().fold(0, |max_len, r| {\n-                          match r.get(0).node {\n-                              PatVec(ref before, _, ref after) => {\n-                                  cmp::max(before.len() + after.len(), max_len)\n-                              }\n-                              _ => max_len\n-                          }\n-                      });\n-                      for n in iter::range(0u, max_len + 1) {\n-                          match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n-                              not_useful => (),\n-                              u => return u,\n-                          }\n-                      }\n-                      not_useful\n-                  }\n-                  _ => {\n-                      let arity = ctor_arity(cx, &single, left_ty);\n-                      is_useful_specialized(cx, m, v, single, arity, left_ty)\n-                  }\n-              },\n-              _ => {\n-                  let arity = ctor_arity(cx, &single, left_ty);\n-                  is_useful_specialized(cx, m, v, single, arity, left_ty)\n-              }\n-            }\n-          }\n-          Some(ctor) => {\n-            match is_useful(cx,\n-                            &m.iter().filter_map(|r| {\n-                                default(cx, r.as_slice())\n-                            }).collect::<matrix>(),\n-                            v.tail()) {\n-              useful_ => useful(left_ty, ctor),\n-              u => u,\n+    let left_ty = if real_pat.id == 0 {\n+        ty::mk_nil()\n+    } else {\n+        ty::pat_ty(cx.tcx, &*real_pat)\n+    };\n+\n+    match pat_ctor_id(cx, left_ty, v[0]) {\n+        None => match missing_constructor(cx, m, left_ty) {\n+            None => {\n+                all_constructors(cx, m, left_ty).move_iter().filter_map(|c| {\n+                    is_useful_specialized(cx, m, v, c.clone(),\n+                                          left_ty, witness).useful().map(|pats| {\n+                        Useful(match witness {\n+                            ConstructWitness => {\n+                                let arity = constructor_arity(cx, &c, left_ty);\n+                                let subpats = {\n+                                    let pat_slice = pats.as_slice();\n+                                    Vec::from_fn(arity, |i| {\n+                                        pat_slice.get(i).map(|p| p.clone())\n+                                            .unwrap_or_else(|| wild())\n+                                    })\n+                                };\n+                                let mut result = vec!(construct_witness(cx, &c, subpats, left_ty));\n+                                result.extend(pats.move_iter().skip(arity));\n+                                result\n+                            }\n+                            LeaveOutWitness => vec!()\n+                        })\n+                    })\n+                }).nth(0).unwrap_or(NotUseful)\n+            },\n+\n+            Some(ctor) => {\n+                let matrix = m.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+                match is_useful(cx, &matrix, v.tail(), witness) {\n+                    Useful(pats) => Useful(match witness {\n+                        ConstructWitness => {\n+                            let arity = constructor_arity(cx, &ctor, left_ty);\n+                            let wild_pats = Vec::from_elem(arity, wild());\n+                            let enum_pat = construct_witness(cx, &ctor, wild_pats, left_ty);\n+                            (vec!(enum_pat)).append(pats.as_slice())\n+                        }\n+                        LeaveOutWitness => vec!()\n+                    }),\n+                    result => result\n+                }\n             }\n-          }\n-        }\n-      }\n-      Some(v0_ctor) => {\n-        let arity = ctor_arity(cx, &v0_ctor, left_ty);\n-        is_useful_specialized(cx, m, v, v0_ctor, arity, left_ty)\n-      }\n+        },\n+\n+        Some(v0_ctor) => is_useful_specialized(cx, m, v, v0_ctor, left_ty, witness)\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt,\n-                             m: &matrix,\n-                             v: &[Gc<Pat>],\n-                             ctor: ctor,\n-                             arity: uint,\n-                             lty: ty::t)\n-                             -> useful {\n-    let ms = m.iter().filter_map(|r| {\n-        specialize(cx, r.as_slice(), &ctor, arity, lty)\n-    }).collect::<matrix>();\n-    let could_be_useful = match specialize(cx, v, &ctor, arity, lty) {\n-        Some(v) => is_useful(cx, &ms, v.as_slice()),\n-        None => return not_useful,\n-    };\n-    match could_be_useful {\n-      useful_ => useful(lty, ctor),\n-      u => u,\n+fn is_useful_specialized(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n+                         ctor: ctor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n+    let arity = constructor_arity(cx, &ctor, lty);\n+    let matrix = m.iter().filter_map(|r| {\n+        specialize(cx, r.as_slice(), &ctor, arity)\n+    }).collect();\n+    match specialize(cx, v, &ctor, arity) {\n+        Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n+        None => NotUseful\n     }\n }\n \n-fn pat_ctor_id(cx: &MatchCheckCtxt, p: Gc<Pat>) -> Option<ctor> {\n+fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-      PatWild | PatWildMulti => { None }\n-      PatIdent(_, _, _) | PatEnum(_, _) => {\n-        let opt_def = cx.tcx.def_map.borrow().find_copy(&pat.id);\n-        match opt_def {\n-          Some(DefVariant(_, id, _)) => Some(variant(id)),\n-          Some(DefStatic(did, false)) => {\n-            let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-            Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n-          }\n-          _ => None\n-        }\n-      }\n-      PatLit(ref expr) => { Some(val(eval_const_expr(cx.tcx, &**expr))) }\n-      PatRange(ref lo, ref hi) => {\n-        Some(range(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi)))\n-      }\n-      PatStruct(..) => {\n-        match cx.tcx.def_map.borrow().find(&pat.id) {\n-          Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-          _ => Some(single)\n-        }\n-      }\n-      PatBox(_) | PatTup(_) | PatRegion(..) => {\n-        Some(single)\n-      }\n-      PatVec(ref before, slice, ref after) => {\n-        match slice {\n-          Some(_) => None,\n-          None => Some(vec(before.len() + after.len()))\n-        }\n-      }\n-      PatMac(_) => cx.tcx.sess.bug(\"unexpanded macro\"),\n+        PatIdent(..) =>\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefStatic(did, false)) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                },\n+                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                _ => None\n+            },\n+        PatEnum(..) =>\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefStatic(did, false)) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                },\n+                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                _ => Some(single)\n+            },\n+        PatStruct(..) =>\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                _ => Some(single)\n+            },\n+        PatLit(expr) =>\n+            Some(val(eval_const_expr(cx.tcx, &*expr))),\n+        PatRange(lo, hi) =>\n+            Some(range(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n+        PatVec(ref before, _, ref after) => match ty::get(left_ty).sty {\n+            ty::ty_vec(_, Some(n)) =>\n+                Some(vec(n)),\n+            _ =>\n+                Some(vec(before.len() + after.len()))\n+        },\n+        PatBox(_) | PatTup(_) | PatRegion(..) =>\n+            Some(single),\n+        PatWild | PatWildMulti =>\n+            None,\n+        PatMac(_) =>\n+            cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n-      PatWild | PatWildMulti => { true }\n-      PatIdent(_, _, _) => {\n-        match cx.tcx.def_map.borrow().find(&pat.id) {\n-          Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => { false }\n-          _ => { true }\n-        }\n-      }\n-      _ => { false }\n-    }\n-}\n-\n-fn missing_ctor(cx: &MatchCheckCtxt,\n-                m: &matrix,\n-                left_ty: ty::t)\n-                -> Option<ctor> {\n-    return match ty::get(left_ty).sty {\n-      ty::ty_box(_) | ty::ty_tup(_) |\n-      ty::ty_struct(..) => check_matrix_for_wild(cx, m),\n-      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n-          ty::ty_vec(_, None) => ctor_for_slice(m),\n-          ty::ty_str => Some(single),\n-          _ => check_matrix_for_wild(cx, m),\n-      },\n-      ty::ty_enum(eid, _) => {\n-        let pat_ctors: Vec<ctor> = m\n-          .iter()\n-          .filter_map(|r| pat_ctor_id(cx, *r.get(0)))\n-          .collect();\n-        let variants = ty::enum_variants(cx.tcx, eid);\n-        variants.iter().map(|v| variant(v.id)).find(|c| !pat_ctors.contains(c))\n-      }\n-      ty::ty_nil => None,\n-      ty::ty_bool => {\n-        let mut true_found = false;\n-        let mut false_found = false;\n-        for r in m.iter() {\n-            match pat_ctor_id(cx, *r.get(0)) {\n-              None => (),\n-              Some(val(const_bool(true))) => true_found = true,\n-              Some(val(const_bool(false))) => false_found = true,\n-              _ => fail!(\"impossible case\")\n+        PatWild | PatWildMulti => true,\n+        PatIdent(_, _, _) => {\n+            match cx.tcx.def_map.borrow().find(&pat.id) {\n+                Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => false,\n+                _ => true\n             }\n         }\n-        if true_found && false_found { None }\n-        else if true_found { Some(val(const_bool(false))) }\n-        else { Some(val(const_bool(true))) }\n-      }\n-      ty::ty_vec(_, Some(n)) => {\n-        let mut missing = true;\n-        let mut wrong = false;\n-        for r in m.iter() {\n-          match r.get(0).node {\n-            PatVec(ref before, ref slice, ref after) => {\n-              let count = before.len() + after.len();\n-              if (count < n && slice.is_none()) || count > n {\n-                wrong = true;\n-              }\n-              if count == n || (count < n && slice.is_some()) {\n-                missing = false;\n-              }\n-            }\n-            _ => {}\n-          }\n-        }\n-        match (wrong, missing) {\n-          (true, _) => Some(vec(n)), // should be compile-time error\n-          (_, true) => Some(vec(n)),\n-          _         => None\n-        }\n-      }\n-      ty::ty_vec(..) => fail!(\"impossible case\"),\n-      _ => Some(single)\n-    };\n-\n-    fn check_matrix_for_wild(cx: &MatchCheckCtxt, m: &matrix) -> Option<ctor> {\n-        for r in m.iter() {\n-            if !is_wild(cx, *r.get(0)) { return None; }\n-        }\n-        return Some(single);\n-    }\n-\n-    // For slice and ~[T].\n-    fn ctor_for_slice(m: &matrix) -> Option<ctor> {\n-        // Find the lengths and slices of all vector patterns.\n-        let mut vec_pat_lens = m.iter().filter_map(|r| {\n-            match r.get(0).node {\n-                PatVec(ref before, ref slice, ref after) => {\n-                    Some((before.len() + after.len(), slice.is_some()))\n-                }\n-                _ => None\n-            }\n-        }).collect::<Vec<(uint, bool)> >();\n-\n-        // Sort them by length such that for patterns of the same length,\n-        // those with a destructured slice come first.\n-        vec_pat_lens.sort_by(|&(len1, slice1), &(len2, slice2)| {\n-                    if len1 == len2 {\n-                        slice2.cmp(&slice1)\n-                    } else {\n-                        len1.cmp(&len2)\n-                    }\n-                });\n-        vec_pat_lens.dedup();\n-\n-        let mut found_slice = false;\n-        let mut next = 0;\n-        let mut missing = None;\n-        for &(length, slice) in vec_pat_lens.iter() {\n-            if length != next {\n-                missing = Some(next);\n-                break;\n-            }\n-            if slice {\n-                found_slice = true;\n-                break;\n-            }\n-            next += 1;\n-        }\n-\n-        // We found patterns of all lengths within <0, next), yet there was no\n-        // pattern with a slice - therefore, we report vec(next) as missing.\n-        if !found_slice {\n-            missing = Some(next);\n-        }\n-        match missing {\n-          Some(k) => Some(vec(k)),\n-          None => None\n-        }\n+        _ => false\n     }\n }\n \n-fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n-    fn vec_ctor_arity(ctor: &ctor) -> uint {\n-        match *ctor {\n-            vec(n) => n,\n-            _ => 0u\n-        }\n-    }\n-\n+fn constructor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n         ty::ty_tup(ref fs) => fs.len(),\n-        ty::ty_box(_) => 1u,\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty: ty, ..}) => match ty::get(ty).sty {\n-            ty::ty_vec(_, None) => vec_ctor_arity(ctor),\n-            _ => 1u,\n+        ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n+        ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n+            ty::ty_vec(_, None) => match *ctor {\n+                vec(n) => n,\n+                _ => 0u\n+            },\n+            ty::ty_str => 0u,\n+            _ => 1u\n         },\n         ty::ty_enum(eid, _) => {\n-            let id = match *ctor {\n-                variant(id) => id,\n-                _ => fail!(\"impossible case\")\n-            };\n-            match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n-                Some(v) => v.args.len(),\n-                None => fail!(\"impossible case\")\n+            match *ctor {\n+                variant(id, _) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                _ => unreachable!()\n             }\n         }\n         ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-        ty::ty_vec(_, Some(_)) => vec_ctor_arity(ctor),\n+        ty::ty_vec(_, _) => match *ctor {\n+            vec(n) => n,\n+            _ => 0u\n+        },\n         _ => 0u\n     }\n }\n@@ -553,10 +515,6 @@ fn wild() -> Gc<Pat> {\n     box(GC) Pat {id: 0, node: PatWild, span: DUMMY_SP}\n }\n \n-fn wild_multi() -> Gc<Pat> {\n-    box(GC) Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n-}\n-\n fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n     let (c_from, c_to) = match *ctor_id {\n         val(ref value)          => (value, value),\n@@ -572,164 +530,150 @@ fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val\n     }\n }\n \n-fn specialize(cx: &MatchCheckCtxt,\n-                  r: &[Gc<Pat>],\n-                  ctor_id: &ctor,\n-                  arity: uint,\n-                  left_ty: ty::t)\n-               -> Option<Vec<Gc<Pat>>> {\n-    let &Pat{id: ref pat_id, node: ref n, span: ref pat_span} = &(*raw_pat(r[0]));\n+fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n+              ctor_id: &ctor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+    let &Pat {\n+        id: ref pat_id, node: ref n, span: ref pat_span\n+    } = &(*raw_pat(r[0]));\n     let head: Option<Vec<Gc<Pat>>> = match n {\n-            &PatWild => {\n-                Some(Vec::from_elem(arity, wild()))\n-            }\n-            &PatWildMulti => {\n-                Some(Vec::from_elem(arity, wild_multi()))\n-            }\n-            &PatIdent(_, _, _) => {\n-                let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n-                match opt_def {\n-                    Some(DefVariant(_, id, _)) => {\n-                        if variant(id) == *ctor_id {\n-                            Some(vec!())\n-                        } else {\n+        &PatWild => {\n+            Some(Vec::from_elem(arity, wild()))\n+        }\n+        &PatWildMulti => {\n+            Some(Vec::from_elem(arity, wild()))\n+        }\n+        &PatIdent(_, _, _) => {\n+            let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n+            match opt_def {\n+                Some(DefVariant(_, id, _)) => match *ctor_id {\n+                    variant(vid, _) if vid == id => Some(vec!()),\n+                    _ => None\n+                },\n+                Some(DefStatic(did, _)) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    let e_v = eval_const_expr(cx.tcx, &*const_expr);\n+                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                        Some(true) => Some(vec!()),\n+                        Some(false) => None,\n+                        None => {\n+                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                             None\n                         }\n                     }\n-                    Some(DefStatic(did, _)) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n-                           Some(true) => Some(vec!()),\n-                           Some(false) => None,\n-                           None => {\n-                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n-                              None\n-                           }\n-                        }\n-                    }\n-                    _ => {\n-                        Some(Vec::from_elem(arity, wild()))\n-                    }\n+                }\n+                _ => {\n+                    Some(Vec::from_elem(arity, wild()))\n                 }\n             }\n-            &PatEnum(_, ref args) => {\n-                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n-                match def {\n-                    DefStatic(did, _) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                        let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                        match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n-                           Some(true) => Some(vec!()),\n-                           Some(false) => None,\n-                           None => {\n-                              cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n-                              None\n-                           }\n+        }\n+        &PatEnum(_, ref args) => {\n+            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            match def {\n+                DefStatic(did, _) => {\n+                    let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n+                    let e_v = eval_const_expr(cx.tcx, &*const_expr);\n+                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                        Some(true) => Some(vec!()),\n+                        Some(false) => None,\n+                        None => {\n+                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            None\n                         }\n                     }\n-                    DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n-                    DefVariant(..) | DefFn(..) | DefStruct(..) => {\n-                        Some(match args {\n-                            &Some(ref args) => args.clone(),\n-                            &None => Vec::from_elem(arity, wild())\n-                        })\n-                    }\n-                    _ => None\n                 }\n+                DefVariant(_, id, _) if variant(id, false) != *ctor_id => None,\n+                DefVariant(..) | DefFn(..) | DefStruct(..) => {\n+                    Some(match args {\n+                        &Some(ref args) => args.clone(),\n+                        &None => Vec::from_elem(arity, wild())\n+                    })\n+                }\n+                _ => None\n             }\n-            &PatStruct(_, ref pattern_fields, _) => {\n-                // Is this a struct or an enum variant?\n-                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n-                let class_id = match def {\n-                    DefVariant(_, variant_id, _) => {\n-                      if variant(variant_id) == *ctor_id {\n-                        Some(variant_id)\n-                      } else {\n-                        None\n-                      }\n-                    }\n-                    _ => {\n-                        match ty::get(left_ty).sty {\n-                            ty::ty_struct(cid, _) => Some(cid),\n-                            _ => {\n-                                cx.tcx.sess.span_bug(\n-                                    *pat_span,\n-                                    format!(\"struct pattern resolved to {}, \\\n-                                          not a struct\",\n-                                         ty_to_str(cx.tcx,\n-                                                   left_ty)).as_slice());\n-                            }\n-                        }\n+        }\n+\n+        &PatStruct(_, ref pattern_fields, _) => {\n+            // Is this a struct or an enum variant?\n+            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            let class_id = match def {\n+                DefVariant(_, variant_id, _) => if *ctor_id == variant(variant_id, true) {\n+                    Some(variant_id)\n+                } else {\n+                    None\n+                },\n+                DefStruct(struct_id) => Some(struct_id),\n+                _ => None\n+            };\n+            class_id.map(|variant_id| {\n+                let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                let args = struct_fields.iter().map(|sf| {\n+                    match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n+                        Some(f) => f.pat,\n+                        _ => wild()\n                     }\n-                };\n-                class_id.map(|variant_id| {\n-                  let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n-                  let args = struct_fields.iter().map(|sf| {\n-                      match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n-                          Some(f) => f.pat,\n-                          _ => wild()\n-                      }\n-                  }).collect();\n-                  args\n-                })\n+                }).collect();\n+                args\n+            })\n+        }\n \n-            }\n-            &PatTup(ref args) => {\n-                Some(args.clone())\n-            }\n-            &PatBox(ref inner) | &PatRegion(ref inner) => {\n-                Some(vec!(inner.clone()))\n-            }\n-            &PatLit(ref expr) => {\n-              let expr_value = eval_const_expr(cx.tcx, &**expr);\n-              match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n-                 Some(true) => Some(vec!()),\n-                 Some(false) => None,\n-                 None => {\n+        &PatTup(ref args) =>\n+            Some(args.clone()),\n+\n+        &PatBox(ref inner) | &PatRegion(ref inner) =>\n+            Some(vec!(inner.clone())),\n+\n+        &PatLit(ref expr) => {\n+            let expr_value = eval_const_expr(cx.tcx, &**expr);\n+            match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n+                Some(true) => Some(vec!()),\n+                Some(false) => None,\n+                None => {\n                     cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                     None\n-                 }\n-              }\n+                }\n             }\n-            &PatRange(ref from, ref to) => {\n-              let from_value = eval_const_expr(cx.tcx, &**from);\n-              let to_value = eval_const_expr(cx.tcx, &**to);\n-              match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n-                 Some(true) => Some(vec!()),\n-                 Some(false) => None,\n-                 None => {\n+        }\n+\n+        &PatRange(ref from, ref to) => {\n+            let from_value = eval_const_expr(cx.tcx, &**from);\n+            let to_value = eval_const_expr(cx.tcx, &**to);\n+            match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n+                Some(true) => Some(vec!()),\n+                Some(false) => None,\n+                None => {\n                     cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n                     None\n-                 }\n-              }\n+                }\n             }\n-            &PatVec(ref before, ref slice, ref after) => {\n-                match *ctor_id {\n-                    vec(_) => {\n-                        let num_elements = before.len() + after.len();\n-                        if num_elements < arity && slice.is_some() {\n-                            let mut result = Vec::new();\n-                            result.push_all(before.as_slice());\n-                            result.grow_fn(arity - num_elements, |_| wild());\n-                            result.push_all(after.as_slice());\n-                            Some(result)\n-                        } else if num_elements == arity {\n-                            let mut result = Vec::new();\n-                            result.push_all(before.as_slice());\n-                            result.push_all(after.as_slice());\n-                            Some(result)\n-                        } else {\n-                            None\n-                        }\n+        }\n+\n+        &PatVec(ref before, ref slice, ref after) => {\n+            match *ctor_id {\n+                vec(_) => {\n+                    let num_elements = before.len() + after.len();\n+                    if num_elements < arity && slice.is_some() {\n+                        let mut result = Vec::new();\n+                        result.push_all(before.as_slice());\n+                        result.grow_fn(arity - num_elements, |_| wild());\n+                        result.push_all(after.as_slice());\n+                        Some(result)\n+                    } else if num_elements == arity {\n+                        let mut result = Vec::new();\n+                        result.push_all(before.as_slice());\n+                        result.push_all(after.as_slice());\n+                        Some(result)\n+                    } else {\n+                        None\n                     }\n-                    _ => None\n                 }\n+                _ => None\n             }\n-            &PatMac(_) => {\n-                cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n-                None\n-            }\n+        }\n+\n+        &PatMac(_) => {\n+            cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n+            None\n+        }\n     };\n     head.map(|head| head.append(r.tail()))\n }\n@@ -750,12 +694,15 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n         LocalFor => \"`for` loop\"\n     };\n \n-    let mut spans = vec![];\n-    find_refutable(cx, &*loc.pat, &mut spans);\n-\n-    for span in spans.iter() {\n-        cx.tcx.sess.span_err(*span,\n-                             format!(\"refutable pattern in {} binding\", name).as_slice());\n+    match is_refutable(cx, loc.pat) {\n+        Some(pat) => {\n+            let msg = format!(\n+                \"refutable pattern in {} binding: `{}` not covered\",\n+                name, pat_to_str(&*pat)\n+            );\n+            cx.tcx.sess.span_err(loc.pat.span, msg.as_slice());\n+        },\n+        None => ()\n     }\n \n     // Check legality of move bindings.\n@@ -769,67 +716,27 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             sp: Span) {\n     visit::walk_fn(cx, kind, decl, body, sp, ());\n     for input in decl.inputs.iter() {\n-        let mut spans = vec![];\n-        find_refutable(cx, &*input.pat, &mut spans);\n-\n-        for span in spans.iter() {\n-            cx.tcx.sess.span_err(*span,\n-                                 \"refutable pattern in function argument\");\n+        match is_refutable(cx, input.pat) {\n+            Some(pat) => {\n+                let msg = format!(\n+                    \"refutable pattern in function argument: `{}` not covered\",\n+                    pat_to_str(&*pat)\n+                );\n+                cx.tcx.sess.span_err(input.pat.span, msg.as_slice());\n+            },\n+            None => ()\n         }\n     }\n }\n \n-fn find_refutable(cx: &MatchCheckCtxt, pat: &Pat, spans: &mut Vec<Span>) {\n-    macro_rules! this_pattern {\n-        () => {\n-            {\n-                spans.push(pat.span);\n-                return\n-            }\n-        }\n-    }\n-    let opt_def = cx.tcx.def_map.borrow().find_copy(&pat.id);\n-    match opt_def {\n-      Some(DefVariant(enum_id, _, _)) => {\n-        if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n-            this_pattern!()\n-        }\n-      }\n-      Some(DefStatic(..)) => this_pattern!(),\n-      _ => ()\n-    }\n-\n-    match pat.node {\n-      PatBox(ref sub) | PatRegion(ref sub) | PatIdent(_, _, Some(ref sub)) => {\n-        find_refutable(cx, &**sub, spans)\n-      }\n-      PatWild | PatWildMulti | PatIdent(_, _, None) => {}\n-      PatLit(lit) => {\n-          match lit.node {\n-            ExprLit(lit) => {\n-                match lit.node {\n-                    LitNil => {}    // `()`\n-                    _ => this_pattern!(),\n-                }\n-            }\n-            _ => this_pattern!(),\n-          }\n-      }\n-      PatRange(_, _) => { this_pattern!() }\n-      PatStruct(_, ref fields, _) => {\n-          for f in fields.iter() {\n-              find_refutable(cx, &*f.pat, spans);\n-          }\n-      }\n-      PatTup(ref elts) | PatEnum(_, Some(ref elts))=> {\n-          for elt in elts.iter() {\n-              find_refutable(cx, &**elt, spans)\n-          }\n-      }\n-      PatEnum(_,_) => {}\n-      PatVec(..) => { this_pattern!() }\n-      PatMac(_) => cx.tcx.sess.bug(\"unexpanded macro\"),\n-    }\n+fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n+    let pats = vec!(vec!(pat));\n+    is_useful(cx, &pats, [wild()], ConstructWitness)\n+        .useful()\n+        .map(|pats| {\n+            assert_eq!(pats.len(), 1);\n+            pats.get(0).clone()\n+        })\n }\n \n // Legality of move bindings checking"}, {"sha": "5b9c89f6250931f4f8a8713263bebcaeb776e1e4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -988,8 +988,7 @@ fn extract_vec_elems<'a>(\n                      pat_id: ast::NodeId,\n                      elem_count: uint,\n                      slice: Option<uint>,\n-                     val: ValueRef,\n-                     count: ValueRef)\n+                     val: ValueRef)\n                      -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n@@ -1003,7 +1002,7 @@ fn extract_vec_elems<'a>(\n             Some(n) if i < n => GEPi(bcx, base, [i]),\n             Some(n) if i > n => {\n                 InBoundsGEP(bcx, base, [\n-                    Sub(bcx, count,\n+                    Sub(bcx, len,\n                         C_int(bcx.ccx(), (elem_count - i) as int))])\n             }\n             _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n@@ -1765,7 +1764,7 @@ fn compile_submatch_continue<'a, 'b>(\n                     vec_len_eq => (n, None)\n                 };\n                 let args = extract_vec_elems(opt_cx, pat_id, n,\n-                                             slice, val, test_val);\n+                                             slice, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n@@ -2264,9 +2263,21 @@ fn bind_irrefutable_pat<'a>(\n             let loaded_val = Load(bcx, val);\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n         }\n-        ast::PatVec(..) => {\n-            bcx.sess().span_bug(pat.span,\n-                                \"vector patterns are never irrefutable!\");\n+        ast::PatVec(ref before, ref slice, ref after) => {\n+            let extracted = extract_vec_elems(\n+                bcx, pat.id, before.len() + 1u + after.len(),\n+                slice.map(|_| before.len()), val\n+            );\n+            bcx = before\n+                .iter().map(|v| Some(*v))\n+                .chain(Some(*slice).move_iter())\n+                .chain(after.iter().map(|v| Some(*v)))\n+                .zip(extracted.vals.iter())\n+                .fold(bcx, |bcx, (inner, elem)| {\n+                    inner.map_or(bcx, |inner| {\n+                        bind_irrefutable_pat(bcx, inner, *elem, binding_mode, cleanup_scope)\n+                    })\n+                });\n         }\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");"}, {"sha": "e198653165a61a5e1216ae67cd66ee83a7e9e766", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -632,9 +632,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n-        let check_err = || {\n-            for elt in before.iter() {\n-                check_pat(pcx, &**elt, ty::mk_err());\n+        let check_err = |found: String| {\n+            for &elt in before.iter() {\n+                check_pat(pcx, &*elt, ty::mk_err());\n             }\n             for elt in slice.iter() {\n                 check_pat(pcx, &**elt, ty::mk_err());\n@@ -653,15 +653,16 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                     })\n                 },\n                 Some(expected),\n-                \"a vector pattern\".to_string(),\n+                found,\n                 None);\n             fcx.write_error(pat.id);\n         };\n \n-        let (elt_type, region_var, mutbl) = match *structure_of(fcx,\n+        let (elt_type, region_var, mutbl, fixed) = match *structure_of(fcx,\n                                                                 pat.span,\n                                                                 expected) {\n-          ty::ty_vec(mt, Some(_)) => (mt.ty, default_region_var, ast::MutImmutable),\n+          ty::ty_vec(mt, Some(fixed)) =>\n+            (mt.ty, default_region_var, ast::MutImmutable, Some(fixed)),\n           ty::ty_uniq(t) => match ty::get(t).sty {\n               ty::ty_vec(mt, None) => {\n                   fcx.type_error_message(pat.span,\n@@ -671,25 +672,37 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                          },\n                                          expected,\n                                          None);\n-                  (mt.ty, default_region_var, ast::MutImmutable)\n+                  (mt.ty, default_region_var, ast::MutImmutable, None)\n               }\n               _ => {\n-                  check_err();\n+                  check_err(\"a vector pattern\".to_string());\n                   return;\n               }\n           },\n           ty::ty_rptr(r, mt) => match ty::get(mt.ty).sty {\n-              ty::ty_vec(mt, None) => (mt.ty, r, mt.mutbl),\n+              ty::ty_vec(mt, None) => (mt.ty, r, mt.mutbl, None),\n               _ => {\n-                  check_err();\n+                  check_err(\"a vector pattern\".to_string());\n                   return;\n               }\n           },\n           _ => {\n-              check_err();\n+              check_err(\"a vector pattern\".to_string());\n               return;\n           }\n         };\n+\n+        let min_len = before.len() + after.len();\n+        fixed.and_then(|count| match slice {\n+            Some(_) if count < min_len =>\n+                Some(format!(\"a fixed vector pattern of size at least {}\", min_len)),\n+\n+            None if count != min_len =>\n+                Some(format!(\"a fixed vector pattern of size {}\", min_len)),\n+\n+            _ => None\n+        }).map(check_err);\n+\n         for elt in before.iter() {\n             check_pat(pcx, &**elt, elt_type);\n         }"}, {"sha": "2b769b9e499ea2cf11123736483987a5881c9bd1", "filename": "src/test/compile-fail/issue-13482.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+  let x = [1,2];\n+  let y = match x {\n+    [] => None,\n+//~^ ERROR expected `[<generic integer #1>, .. 2]` but found a fixed vector pattern of size 0\n+    [a,_] => Some(a)\n+  };\n+}"}, {"sha": "3d9c7401ded24d92d4acc5c3dc511b086b0c8e51", "filename": "src/test/compile-fail/issue-2111.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n fn foo(a: Option<uint>, b: Option<uint>) {\n-  match (a,b) { //~ ERROR: non-exhaustive patterns: None not covered\n+  match (a,b) {\n+  //~^ ERROR: non-exhaustive patterns: `(None, None)` not covered\n     (Some(a), Some(b)) if a == b => { }\n     (Some(_), None) |\n     (None, Some(_)) => { }"}, {"sha": "d589680b0ecdac43dc1aed0f8a0e17fd4caff860", "filename": "src/test/compile-fail/issue-4321.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4321.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let tup = (true, true);\n+    println!(\"foo {:}\", match tup { //~ ERROR non-exhaustive patterns: `(true, false)` not covered\n+        (false, false) => \"foo\",\n+        (false, true) => \"bar\",\n+        (true, true) => \"baz\"\n+    });\n+}"}, {"sha": "483168bb8bcfa1ed1585feb453b5506a3d2fdad8", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: non-exhaustive patterns\n enum t { a(u), b }\n enum u { c, d }\n \n fn main() {\n   let x = a(c);\n-  match x {\n+  match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n       a(d) => { fail!(\"hello\"); }\n       b => { fail!(\"goodbye\"); }\n     }"}, {"sha": "cd78419439a96952db491d31ac1cfeb00be9850d", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -12,21 +12,21 @@ enum t { a, b, }\n \n fn main() {\n     let x = a;\n-    match x { b => { } } //~ ERROR non-exhaustive patterns\n-    match true { //~ ERROR non-exhaustive patterns\n+    match x { b => { } } //~ ERROR non-exhaustive patterns: `a` not covered\n+    match true { //~ ERROR non-exhaustive patterns: `false` not covered\n       true => {}\n     }\n-    match Some(10) { //~ ERROR non-exhaustive patterns\n+    match Some(10) { //~ ERROR non-exhaustive patterns: `Some(_)` not covered\n       None => {}\n     }\n-    match (2, 3, 4) { //~ ERROR non-exhaustive patterns\n+    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, _)` not covered\n       (_, _, 4) => {}\n     }\n-    match (a, a) { //~ ERROR non-exhaustive patterns\n+    match (a, a) { //~ ERROR non-exhaustive patterns: `(a, a)` not covered\n       (a, b) => {}\n       (b, a) => {}\n     }\n-    match a { //~ ERROR b not covered\n+    match a { //~ ERROR non-exhaustive patterns: `b` not covered\n       a => {}\n     }\n     // This is exhaustive, though the algorithm got it wrong at one point\n@@ -37,8 +37,7 @@ fn main() {\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<int>] = vec.as_slice();\n-    match vec {\n-        //~^ ERROR non-exhaustive patterns: vectors of length 0 not covered\n+    match vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n         [Some(..), None, ..tail] => {}\n         [Some(..), Some(..), ..tail] => {}\n         [None] => {}\n@@ -51,7 +50,7 @@ fn main() {\n     }\n     let vec = vec!(0.5);\n     let vec: &[f32] = vec.as_slice();\n-    match vec { //~ ERROR non-exhaustive patterns: vectors of length 4 not covered\n+    match vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),"}, {"sha": "22e93d70858e4deb68220fabdfd0f9cc6adbea50", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+\n+struct Foo {\n+    first: bool,\n+    second: Option<[uint, ..4]>\n+}\n+\n+enum Color {\n+    Red,\n+    Green,\n+    CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n+}\n+\n+fn struct_with_a_nested_enum_and_vector() {\n+    match Foo { first: true, second: None } {\n+    //~^ ERROR non-exhaustive patterns: `Foo{first: false, second: Some([_, _, _, _])}` not covered\n+        Foo { first: true, second: None } => (),\n+        Foo { first: true, second: Some(_) } => (),\n+        Foo { first: false, second: None } => (),\n+        Foo { first: false, second: Some([1u, 2u, 3u, 4u]) } => ()\n+    }\n+}\n+\n+fn enum_with_multiple_missing_variants() {\n+    match Red {\n+    //~^ ERROR non-exhaustive patterns: `Red` not covered\n+        CustomRGBA { .. } => ()\n+    }\n+}\n+\n+fn enum_struct_variant() {\n+    match Red {\n+    //~^ ERROR non-exhaustive patterns: `CustomRGBA{a: true, r: _, g: _, b: _}` not covered\n+        Red => (),\n+        Green => (),\n+        CustomRGBA { a: false, r: _, g: _, b: 0 } => (),\n+        CustomRGBA { a: false, r: _, g: _, b: _ } => ()\n+    }\n+}\n+\n+enum Enum {\n+    First,\n+    Second(bool)\n+}\n+\n+fn vectors_with_nested_enums() {\n+    let x: &'static [Enum] = [First, Second(false)];\n+    match x {\n+    //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n+        [] => (),\n+        [_] => (),\n+        [First, _] => (),\n+        [Second(true), First] => (),\n+        [Second(true), Second(true)] => (),\n+        [Second(false), _] => (),\n+        [_, _, ..tail, _] => ()\n+    }\n+}\n+\n+fn main() {\n+    struct_with_a_nested_enum_and_vector();\n+    enum_with_multiple_missing_variants();\n+    enum_struct_variant();\n+}\n\\ No newline at end of file"}, {"sha": "efa2dbad83fdaa9f65c747fc3f61ad2fea730443", "filename": "src/test/compile-fail/precise-refutable-pattern-errors.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2563481ca93877551116b11cde3cc7e21f1d6048/src%2Ftest%2Fcompile-fail%2Fprecise-refutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2563481ca93877551116b11cde3cc7e21f1d6048/src%2Ftest%2Fcompile-fail%2Fprecise-refutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprecise-refutable-pattern-errors.rs?ref=2563481ca93877551116b11cde3cc7e21f1d6048", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-fn func(\n-    (\n-        1, //~ ERROR refutable pattern in function argument\n-        (\n-            Some( //~ ERROR refutable pattern in function argument\n-                1), // nested, so no warning.\n-            2..3 //~ ERROR refutable pattern in function argument\n-            )\n-        ): (int, (Option<int>, int))\n-        ) {}\n-\n-fn main() {\n-    let (\n-        1, //~ ERROR refutable pattern in local binding\n-        (\n-            Some( //~ ERROR refutable pattern in local binding\n-                1), // nested, so no warning.\n-            2..3 //~ ERROR refutable pattern in local binding\n-            )\n-        ) = (1, (None, 2));\n-}"}, {"sha": "9128ee68e26c5baec9c95c42620f8b62799c2898", "filename": "src/test/compile-fail/refutable-pattern-errors.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-errors.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+fn func((1, (Some(1), 2..3)): (int, (Option<int>, int))) { }\n+//~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n+\n+fn main() {\n+    let (1, (Some(1), 2..3)) = (1, (None, 2));\n+    //~^ ERROR refutable pattern in local binding: `(_, _)` not covered\n+}"}, {"sha": "954d4b23e30faa942734b7a752d885591b0116d4", "filename": "src/test/compile-fail/refutable-pattern-in-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frefutable-pattern-in-fn-arg.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let f = |3: int| println!(\"hello\");  //~ ERROR refutable pattern\n+    let f = |3: int| println!(\"hello\");\n+    //~^ ERROR refutable pattern in function argument: `_` not covered\n     f(4);\n }"}, {"sha": "87108294ff36278f5d4bbe7eabe5db2556556c12", "filename": "src/test/run-pass/issue-14393.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Frun-pass%2Fissue-14393.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Frun-pass%2Fissue-14393.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14393.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-win32: FIXME #13793\n+\n+fn main() {\n+    match (\"\", 1u) {\n+        (_, 42u) => (),\n+        (\"\", _) => (),\n+        _ => ()\n+    }\n+}"}, {"sha": "52c2d57753a14abe514a1b60282ce5422dc3b7e3", "filename": "src/test/run-pass/issue-7784.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1646cbfd908dc948b251e362669af421100647a/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=b1646cbfd908dc948b251e362669af421100647a", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T: Add<T, T> + Clone>([x, y, z]: [T, ..3]) -> (T, T, T) {\n+    (x.clone(), x.clone() + y.clone(), x + y + z)\n+}\n+fn bar(a: &'static str, b: &'static str) -> [&'static str, ..4] {\n+    [a, b, b, a]\n+}\n+\n+fn main() {\n+    assert_eq!(foo([1, 2, 3]), (1, 3, 6));\n+\n+    let [a, b, c, d] = bar(\"foo\", \"bar\");\n+    assert_eq!(a, \"foo\");\n+    assert_eq!(b, \"bar\");\n+    assert_eq!(c, \"bar\");\n+    assert_eq!(d, \"foo\");\n+\n+    let [a, _, _, d] = bar(\"baz\", \"foo\");\n+    assert_eq!(a, \"baz\");\n+    assert_eq!(d, \"baz\");\n+\n+    let out = bar(\"baz\", \"foo\");\n+    let [a, ..xs, d] = out;\n+    assert_eq!(a, \"baz\");\n+    assert!(xs == [\"foo\", \"foo\"]);\n+    assert_eq!(d, \"baz\");\n+}\n\\ No newline at end of file"}]}