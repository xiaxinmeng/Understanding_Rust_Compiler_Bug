{"sha": "a324fc19d4b4bd6ecb34abf318aea2e65f98c241", "node_id": "C_kwDOAAsO6NoAKGEzMjRmYzE5ZDRiNGJkNmVjYjM0YWJmMzE4YWVhMmU2NWY5OGMyNDE", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T01:27:28Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T19:48:47Z"}, "message": "Only check for conflicting anchors in one place\n\nThis coalesces the checks into one place.", "tree": {"sha": "b44b2047b75318908d4dedbba4599f99011f87fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b44b2047b75318908d4dedbba4599f99011f87fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a324fc19d4b4bd6ecb34abf318aea2e65f98c241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a324fc19d4b4bd6ecb34abf318aea2e65f98c241", "html_url": "https://github.com/rust-lang/rust/commit/a324fc19d4b4bd6ecb34abf318aea2e65f98c241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a324fc19d4b4bd6ecb34abf318aea2e65f98c241/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b50a4e286e81426862867d8ce31ebbd9bcc930c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b50a4e286e81426862867d8ce31ebbd9bcc930c", "html_url": "https://github.com/rust-lang/rust/commit/3b50a4e286e81426862867d8ce31ebbd9bcc930c"}], "stats": {"total": 58, "additions": 34, "deletions": 24}, "files": [{"sha": "7c9de76a0b6880a48e104fb022658414694a4742", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a324fc19d4b4bd6ecb34abf318aea2e65f98c241/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a324fc19d4b4bd6ecb34abf318aea2e65f98c241/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a324fc19d4b4bd6ecb34abf318aea2e65f98c241", "patch": "@@ -513,7 +513,31 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         ns: Namespace,\n         module_id: DefId,\n-        extra_fragment: &Option<UrlFragment>,\n+        user_fragment: &Option<UrlFragment>,\n+    ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n+        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, module_id)?;\n+        let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n+            (Some(_), Some(r_frag)) => {\n+                let diag_res = match r_frag {\n+                    UrlFragment::Def(_, did) => Res::Def(self.cx.tcx.def_kind(did), did),\n+                    // FIXME: eliminate this branch somehow\n+                    UrlFragment::UserWritten(_) => unreachable!(),\n+                };\n+                let failure = AnchorFailure::RustdocAnchorConflict(diag_res);\n+                return Err(ErrorKind::AnchorFailure(failure));\n+            }\n+            (Some(u_frag), None) => Some(u_frag.clone()),\n+            (None, Some(r_frag)) => Some(r_frag),\n+            (None, None) => None,\n+        };\n+        Ok((res, chosen_fragment))\n+    }\n+\n+    fn resolve_inner<'path>(\n+        &mut self,\n+        path_str: &'path str,\n+        ns: Namespace,\n+        module_id: DefId,\n     ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n@@ -522,17 +546,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 Res::Def(DefKind::AssocFn | DefKind::AssocConst, _) => assert_eq!(ns, ValueNS),\n                 Res::Def(DefKind::AssocTy, _) => assert_eq!(ns, TypeNS),\n                 Res::Def(DefKind::Variant, _) => {\n-                    if extra_fragment.is_some() {\n-                        // NOTE: `res` can never be a primitive since this match arm means\n-                        //       `tcx.def_kind(res) == DefKind::Variant`.\n-                        return Err(ErrorKind::AnchorFailure(\n-                            AnchorFailure::RustdocAnchorConflict(res),\n-                        ));\n-                    }\n                     return handle_variant(self.cx, res);\n                 }\n                 // Not a trait item; just return what we found.\n-                _ => return Ok((res, extra_fragment.clone())),\n+                _ => return Ok((res, None)),\n             }\n         }\n \n@@ -565,21 +582,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .and_then(|ty_res| {\n                 let (res, fragment, side_channel) =\n                     self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n-                let result = if extra_fragment.is_some() {\n-                    // NOTE: can never be a primitive since `side_channel.is_none()` only when `res`\n-                    // is a trait (and the side channel DefId is always an associated item).\n-                    let diag_res = side_channel.map_or(res, |(k, r)| Res::Def(k, r));\n-                    Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(diag_res)))\n-                } else {\n-                    // HACK(jynelson): `clean` expects the type, not the associated item\n-                    // but the disambiguator logic expects the associated item.\n-                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                    if let Some((kind, id)) = side_channel {\n-                        self.kind_side_channel.set(Some((kind, id)));\n-                    }\n-                    Ok((res, Some(fragment)))\n-                };\n-                Some(result)\n+\n+                // HACK(jynelson): `clean` expects the type, not the associated item\n+                // but the disambiguator logic expects the associated item.\n+                // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                if let Some((kind, id)) = side_channel {\n+                    self.kind_side_channel.set(Some((kind, id)));\n+                }\n+                Some(Ok((res, Some(fragment))))\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {"}]}