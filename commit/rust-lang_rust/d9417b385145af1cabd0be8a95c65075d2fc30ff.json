{"sha": "d9417b385145af1cabd0be8a95c65075d2fc30ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDE3YjM4NTE0NWFmMWNhYmQwYmU4YTk1YzY1MDc1ZDJmYzMwZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T22:14:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T22:14:26Z"}, "message": "Auto merge of #72433 - RalfJung:rollup-srft8nx, r=RalfJung\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #72055 (Intern predicates)\n - #72149 (Don't `type_of` on trait assoc ty without default)\n - #72347 (Make intra-link resolve links for both trait and impl items)\n - #72350 (Improve documentation of `slice::from_raw_parts`)\n - #72382 (Show default values for debug-assertions & debug-assertions-std)\n - #72421 (Fix anchor display when hovering impl)\n - #72425 (fix discriminant_value sign extension)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9a6348569c253000ec5edea9c6f15677687d26a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a6348569c253000ec5edea9c6f15677687d26a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9417b385145af1cabd0be8a95c65075d2fc30ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9417b385145af1cabd0be8a95c65075d2fc30ff", "html_url": "https://github.com/rust-lang/rust/commit/d9417b385145af1cabd0be8a95c65075d2fc30ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9417b385145af1cabd0be8a95c65075d2fc30ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9310e3bd4f425f84fc27878ebf2bda1f30935a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/9310e3bd4f425f84fc27878ebf2bda1f30935a63", "html_url": "https://github.com/rust-lang/rust/commit/9310e3bd4f425f84fc27878ebf2bda1f30935a63"}, {"sha": "74b5c50214c0edd9582d75fa472ed9a7ea25c0e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b5c50214c0edd9582d75fa472ed9a7ea25c0e5", "html_url": "https://github.com/rust-lang/rust/commit/74b5c50214c0edd9582d75fa472ed9a7ea25c0e5"}], "stats": {"total": 1623, "additions": 941, "deletions": 682}, "files": [{"sha": "cf8fe4e082ac3928162140fc6d1fce74ddb6e998", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -312,11 +312,11 @@\n \n # Whether or not debug assertions are enabled for the compiler and standard\n # library.\n-#debug-assertions = false\n+#debug-assertions = debug\n \n # Whether or not debug assertions are enabled for the standard library.\n # Overrides the `debug-assertions` option, if defined.\n-#debug-assertions-std = false\n+#debug-assertions-std = debug-assertions\n \n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info"}, {"sha": "b5ce165cb43db352c4f945a9df5cc7ff1e9fb97d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -5740,7 +5740,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n ///   and it must be properly aligned. This means in particular:\n ///\n ///     * The entire memory range of this slice must be contained within a single allocated object!\n-///       Slices can never span across multiple allocated objects.\n+///       Slices can never span across multiple allocated objects. See [below](#incorrect-usage)\n+///       for an example incorrectly not taking this into account.\n ///     * `data` must be non-null and aligned even for zero-length slices. One\n ///       reason for this is that enum layout optimizations may rely on references\n ///       (including slices of any length) being aligned and non-null to distinguish\n@@ -5773,6 +5774,34 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n /// assert_eq!(slice[0], 42);\n /// ```\n ///\n+/// ### Incorrect usage\n+///\n+/// The following `join_slices` function is **unsound** \u26a0\ufe0f\n+///\n+/// ```rust,no_run\n+/// use std::slice;\n+///\n+/// fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n+///     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n+///     let snd_start = snd.as_ptr();\n+///     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n+///     unsafe {\n+///         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n+///         // still be contained within _different allocated objects_, in which case\n+///         // creating this slice is undefined behavior.\n+///         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     // `a` and `b` are different allocated objects...\n+///     let a = 42;\n+///     let b = 27;\n+///     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n+///     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n+/// }\n+/// ```\n+///\n /// [valid]: ../../std/ptr/index.html#safety\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset"}, {"sha": "23c9eeb21bb8dc30c3216edf8d7e28137802c212", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n use std::fmt::Debug;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -532,12 +532,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 cause.clone(),\n                 param_env,\n                 match k1.unpack() {\n-                    GenericArgKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                    GenericArgKind::Lifetime(r1) => ty::PredicateKind::RegionOutlives(\n                         ty::Binder::bind(ty::OutlivesPredicate(r1, r2)),\n-                    ),\n-                    GenericArgKind::Type(t1) => {\n-                        ty::Predicate::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(t1, r2)))\n-                    }\n+                    )\n+                    .to_predicate(self.tcx),\n+                    GenericArgKind::Type(t1) => ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n+                        ty::OutlivesPredicate(t1, r2),\n+                    ))\n+                    .to_predicate(self.tcx),\n                     GenericArgKind::Const(..) => {\n                         // Consts cannot outlive one another, so we don't expect to\n                         // ecounter this branch.\n@@ -664,9 +666,10 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::Predicate::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+            predicate: ty::PredicateKind::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                 sup, sub,\n-            ))),\n+            )))\n+            .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });\n     }"}, {"sha": "75f288f1cdcd23a3a16556c64b1cd543c8f8498b", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -39,7 +39,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, InferConst, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -307,7 +307,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::Predicate::WellFormed(b_ty),\n+                ty::PredicateKind::WellFormed(b_ty).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -398,11 +398,15 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::Predicate::ConstEquate(a, b)\n+            ty::PredicateKind::ConstEquate(a, b)\n         } else {\n-            ty::Predicate::ConstEquate(b, a)\n+            ty::PredicateKind::ConstEquate(b, a)\n         };\n-        self.obligations.push(Obligation::new(self.trace.cause.clone(), self.param_env, predicate));\n+        self.obligations.push(Obligation::new(\n+            self.trace.cause.clone(),\n+            self.param_env,\n+            predicate.to_predicate(self.tcx()),\n+        ));\n     }\n }\n "}, {"sha": "fd3b38e9d67b0e3b670f41c432ed836556d2c87f", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -11,17 +11,17 @@ pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");\n-    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate {\n-        ty::Predicate::Projection(..)\n-        | ty::Predicate::Trait(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => None,\n-        ty::Predicate::RegionOutlives(ref data) => data\n+    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate.kind() {\n+        ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::Trait(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::TypeOutlives(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => None,\n+        ty::PredicateKind::RegionOutlives(ref data) => data\n             .no_bound_vars()\n             .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n     })"}, {"sha": "b51af19883fdd82e4be7f0347b052d589e6a2e73", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -6,7 +6,7 @@ use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -100,11 +100,12 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::Predicate::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n+                    ty::PredicateKind::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,\n-                    })),\n+                    }))\n+                    .to_predicate(self.tcx()),\n                 ));\n \n                 Ok(a)"}, {"sha": "2710debea9478b44e2106bcd26b37726d7768104", "filename": "src/librustc_infer/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -33,7 +33,7 @@ pub trait TraitEngine<'tcx>: 'tcx {\n                 cause,\n                 recursion_depth: 0,\n                 param_env,\n-                predicate: trait_ref.without_const().to_predicate(),\n+                predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n             },\n         );\n     }"}, {"sha": "892a62855a0a2e2cac46e69ea40df84464be876b", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -59,7 +59,7 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateObligation<'_>, 112);\n+static_assert_size!(PredicateObligation<'_>, 88);\n \n pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;"}, {"sha": "88fc1460475df1e9c346ea57067c77c59f175484", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -10,40 +10,49 @@ pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pred: &ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    match *pred {\n-        ty::Predicate::Trait(ref data, constness) => {\n-            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+    match pred.kind() {\n+        &ty::PredicateKind::Trait(ref data, constness) => {\n+            ty::PredicateKind::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+                .to_predicate(tcx)\n         }\n \n-        ty::Predicate::RegionOutlives(ref data) => {\n-            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::RegionOutlives(data) => {\n+            ty::PredicateKind::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+                .to_predicate(tcx)\n         }\n \n-        ty::Predicate::TypeOutlives(ref data) => {\n-            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::TypeOutlives(data) => {\n+            ty::PredicateKind::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+                .to_predicate(tcx)\n         }\n \n-        ty::Predicate::Projection(ref data) => {\n-            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::Projection(data) => {\n+            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data)).to_predicate(tcx)\n         }\n \n-        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n+        &ty::PredicateKind::WellFormed(data) => {\n+            ty::PredicateKind::WellFormed(data).to_predicate(tcx)\n+        }\n \n-        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n+        &ty::PredicateKind::ObjectSafe(data) => {\n+            ty::PredicateKind::ObjectSafe(data).to_predicate(tcx)\n+        }\n \n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+        &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind).to_predicate(tcx)\n         }\n \n-        ty::Predicate::Subtype(ref data) => {\n-            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::Subtype(data) => {\n+            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data)).to_predicate(tcx)\n         }\n \n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            ty::Predicate::ConstEvaluatable(def_id, substs)\n+        &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(tcx)\n         }\n \n-        ty::Predicate::ConstEquate(c1, c2) => ty::Predicate::ConstEquate(c1, c2),\n+        ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2).to_predicate(tcx)\n+        }\n     }\n }\n \n@@ -99,14 +108,14 @@ pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate()))\n+    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate());\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate(tcx));\n     elaborate_predicates(tcx, predicates)\n }\n \n@@ -145,8 +154,8 @@ impl Elaborator<'tcx> {\n \n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -167,36 +176,36 @@ impl Elaborator<'tcx> {\n \n                 self.stack.extend(obligations);\n             }\n-            ty::Predicate::WellFormed(..) => {\n+            ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::Predicate::ObjectSafe(..) => {\n+            ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::Predicate::Subtype(..) => {\n+            ty::PredicateKind::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::Predicate::Projection(..) => {\n+            ty::PredicateKind::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::Predicate::ClosureKind(..) => {\n+            ty::PredicateKind::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::Predicate::ConstEvaluatable(..) => {\n+            ty::PredicateKind::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::Predicate::ConstEquate(..) => {\n+            ty::PredicateKind::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::Predicate::RegionOutlives(..) => {\n+            ty::PredicateKind::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::Predicate::TypeOutlives(ref data) => {\n+            ty::PredicateKind::TypeOutlives(ref data) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -228,15 +237,15 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                    Some(ty::PredicateKind::RegionOutlives(ty::Binder::dummy(\n                                         ty::OutlivesPredicate(r, r_min),\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n+                                Some(ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n                                     ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n@@ -250,8 +259,9 @@ impl Elaborator<'tcx> {\n                                 None\n                             }\n                         })\n-                        .filter(|p| visited.insert(p))\n-                        .map(|p| predicate_obligation(p, None)),\n+                        .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n+                        .filter(|predicate| visited.insert(predicate))\n+                        .map(|predicate| predicate_obligation(predicate, None)),\n                 );\n             }\n         }\n@@ -317,7 +327,7 @@ impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToT\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(data, _) = obligation.predicate.kind() {\n                 return Some(data.to_poly_trait_ref());\n             }\n         }"}, {"sha": "e17e8b7b9640e8e8dfd334f088859da67a06d1b3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1202,13 +1202,13 @@ declare_lint_pass!(\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::Predicate::*;\n+        use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n-                let predicate_kind_name = match predicate {\n+                let predicate_kind_name = match predicate.kind() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1497,8 +1497,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred {\n-                ty::Predicate::RegionOutlives(outlives) => {\n+            .filter_map(|(pred, _)| match pred.kind() {\n+                ty::PredicateKind::RegionOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     match outlives.0 {\n                         ty::ReEarlyBound(ebr) if ebr.index == index => Some(outlives.1),\n@@ -1516,8 +1516,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred {\n-                ty::Predicate::TypeOutlives(outlives) => {\n+            .filter_map(|(pred, _)| match pred.kind() {\n+                ty::PredicateKind::TypeOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     outlives.0.is_param(index).then_some(outlives.1)\n                 }"}, {"sha": "dea829343137064da7097f6781cb76c9c859d7e7", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -146,7 +146,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n-                        if let ty::Predicate::Trait(ref poly_trait_predicate, _) = predicate {\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n+                            predicate.kind()\n+                        {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "c4d5bd7e60255248049a3e8a52a03063c3594765", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -10,7 +10,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::mir::{self, interpret::Allocation};\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, List, Ty, TyCtxt};\n+use crate::ty::{self, List, ToPredicate, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n@@ -200,15 +200,16 @@ where\n         (0..decoder.read_usize()?)\n             .map(|_| {\n                 // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate = if decoder.positioned_at_shorthand() {\n+                let predicate_kind = if decoder.positioned_at_shorthand() {\n                     let pos = decoder.read_usize()?;\n                     assert!(pos >= SHORTHAND_OFFSET);\n                     let shorthand = pos - SHORTHAND_OFFSET;\n \n-                    decoder.with_position(shorthand, ty::Predicate::decode)\n+                    decoder.with_position(shorthand, ty::PredicateKind::decode)\n                 } else {\n-                    ty::Predicate::decode(decoder)\n+                    ty::PredicateKind::decode(decoder)\n                 }?;\n+                let predicate = predicate_kind.to_predicate(tcx);\n                 Ok((predicate, Decodable::decode(decoder)?))\n             })\n             .collect::<Result<Vec<_>, _>>()?,"}, {"sha": "5d48b3445e8a1a58a1e34f02400428ce975ffe07", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -29,8 +29,9 @@ use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{AdtDef, AdtKind, Const, Region};\n use crate::ty::{BindingMode, BoundVar};\n use crate::ty::{ConstVid, FloatVar, FloatVid, IntVar, IntVid, TyVar, TyVid};\n-use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, ProjectionTy};\n+use crate::ty::{ExistentialPredicate, Predicate, PredicateKind};\n use crate::ty::{InferConst, ParamConst};\n+use crate::ty::{InferTy, ParamTy, PolyFnSig, ProjectionTy};\n use crate::ty::{List, TyKind, TyS};\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -89,6 +90,7 @@ pub struct CtxtInterners<'tcx> {\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n+    predicate_kind: InternedSet<'tcx, PredicateKind<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -107,6 +109,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             region: Default::default(),\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n+            predicate_kind: Default::default(),\n             predicates: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n@@ -1574,6 +1577,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift! {predicate_kind; &'a PredicateKind<'a> => &'tcx PredicateKind<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n@@ -2012,8 +2016,14 @@ impl<'tcx> Borrow<[traits::ChalkEnvironmentClause<'tcx>]>\n     }\n }\n \n+impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateKind<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n+        &self.0\n+    }\n+}\n+\n macro_rules! direct_interners {\n-    ($($name:ident: $method:ident($ty:ty)),+) => {\n+    ($($name:ident: $method:ident($ty:ty),)+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n@@ -2038,7 +2048,11 @@ macro_rules! direct_interners {\n     }\n }\n \n-direct_interners!(region: mk_region(RegionKind), const_: mk_const(Const<'tcx>));\n+direct_interners!(\n+    region: mk_region(RegionKind),\n+    const_: mk_const(Const<'tcx>),\n+    predicate_kind: intern_predicate_kind(PredicateKind<'tcx>),\n+);\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n@@ -2100,6 +2114,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(st)\n     }\n \n+    #[inline]\n+    pub fn mk_predicate(&self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n+        let kind = self.intern_predicate_kind(kind);\n+        Predicate { kind }\n+    }\n+\n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n             ast::IntTy::Isize => self.types.isize,"}, {"sha": "480420dfdcf5e0a67df8dac6ecc4538b8a0b4e23", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -815,19 +815,18 @@ fn foo(&self) -> Self::T { String::new() }\n                 for item in &items[..] {\n                     match item.kind {\n                         hir::AssocItemKind::Type | hir::AssocItemKind::OpaqueTy => {\n-                            if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n-                                if let hir::Defaultness::Default { has_value: true } =\n-                                    item.defaultness\n-                                {\n+                            // FIXME: account for returning some type in a trait fn impl that has\n+                            // an assoc type as a return type (#72076).\n+                            if let hir::Defaultness::Default { has_value: true } = item.defaultness\n+                            {\n+                                if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n                                     db.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n                                             trait defining them\",\n                                     );\n-                                } else {\n-                                    db.span_label(item.span, \"expected this associated type\");\n+                                    return true;\n                                 }\n-                                return true;\n                             }\n                         }\n                         _ => {}"}, {"sha": "9e8456689094f3acafac772a29cc5c1b9f3f80b4", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 95, "deletions": 62, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1016,9 +1016,30 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Hash, RustcEncodable, RustcDecodable, Lift)]\n+#[derive(HashStable)]\n+pub struct Predicate<'tcx> {\n+    kind: &'tcx PredicateKind<'tcx>,\n+}\n+\n+impl<'tcx> PartialEq for Predicate<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        // `self.kind` is always interned.\n+        ptr::eq(self.kind, other.kind)\n+    }\n+}\n+\n+impl<'tcx> Eq for Predicate<'tcx> {}\n+\n+impl<'tcx> Predicate<'tcx> {\n+    pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n+        self.kind\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n-pub enum Predicate<'tcx> {\n+pub enum PredicateKind<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -1086,7 +1107,7 @@ impl<'tcx> Predicate<'tcx> {\n     /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n     pub fn subst_supertrait(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> ty::Predicate<'tcx> {\n@@ -1151,34 +1172,36 @@ impl<'tcx> Predicate<'tcx> {\n         // this trick achieves that).\n \n         let substs = &trait_ref.skip_binder().substs;\n-        match *self {\n-            Predicate::Trait(ref binder, constness) => {\n-                Predicate::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n+        let predicate = match self.kind() {\n+            &PredicateKind::Trait(ref binder, constness) => {\n+                PredicateKind::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n             }\n-            Predicate::Subtype(ref binder) => {\n-                Predicate::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::Subtype(binder) => {\n+                PredicateKind::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::RegionOutlives(ref binder) => {\n-                Predicate::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::RegionOutlives(binder) => {\n+                PredicateKind::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::TypeOutlives(ref binder) => {\n-                Predicate::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::TypeOutlives(binder) => {\n+                PredicateKind::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::Projection(ref binder) => {\n-                Predicate::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::Projection(binder) => {\n+                PredicateKind::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::WellFormed(data) => Predicate::WellFormed(data.subst(tcx, substs)),\n-            Predicate::ObjectSafe(trait_def_id) => Predicate::ObjectSafe(trait_def_id),\n-            Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                Predicate::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n+            &PredicateKind::WellFormed(data) => PredicateKind::WellFormed(data.subst(tcx, substs)),\n+            &PredicateKind::ObjectSafe(trait_def_id) => PredicateKind::ObjectSafe(trait_def_id),\n+            &PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                PredicateKind::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n             }\n-            Predicate::ConstEvaluatable(def_id, const_substs) => {\n-                Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n+            &PredicateKind::ConstEvaluatable(def_id, const_substs) => {\n+                PredicateKind::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n             }\n-            Predicate::ConstEquate(c1, c2) => {\n-                Predicate::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n+            PredicateKind::ConstEquate(c1, c2) => {\n+                PredicateKind::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n             }\n-        }\n+        };\n+\n+        predicate.to_predicate(tcx)\n     }\n }\n \n@@ -1293,85 +1316,95 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n }\n \n pub trait ToPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx>;\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n+}\n+\n+impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        tcx.mk_predicate(*self)\n+    }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value }),\n             self.constness,\n         )\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n         )\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::RegionOutlives(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::RegionOutlives(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::TypeOutlives(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::TypeOutlives(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::Projection(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::Projection(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n-    pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n-        match *self {\n-            Predicate::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n-            Predicate::Projection(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::RegionOutlives(..)\n-            | Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::TypeOutlives(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => None,\n+    pub fn to_opt_poly_trait_ref(self) -> Option<PolyTraitRef<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n+            PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n \n-    pub fn to_opt_type_outlives(&self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match *self {\n-            Predicate::TypeOutlives(data) => Some(data),\n-            Predicate::Trait(..)\n-            | Predicate::Projection(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::RegionOutlives(..)\n-            | Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => None,\n+    pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::TypeOutlives(data) => Some(data),\n+            PredicateKind::Trait(..)\n+            | PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n }\n@@ -1617,7 +1650,7 @@ pub struct ConstnessAnd<T> {\n     pub value: T,\n }\n \n-// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate()` to ensure that\n+// FIXME(ecstaticmorse): Audit all occurrences of `without_const().to_predicate(tcx)` to ensure that\n // the constness of trait bounds is being propagated correctly.\n pub trait WithConstness: Sized {\n     #[inline]"}, {"sha": "f4b795e548867c1086a1f086a97ea140203c328b", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -2031,34 +2031,34 @@ define_print_and_forward_display! {\n     }\n \n     ty::Predicate<'tcx> {\n-        match *self {\n-            ty::Predicate::Trait(ref data, constness) => {\n+        match self.kind() {\n+            &ty::PredicateKind::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n                     p!(write(\"const \"));\n                 }\n                 p!(print(data))\n             }\n-            ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n                    print_def_path(trait_def_id, &[]),\n                    write(\"` is object-safe\"))\n             }\n-            ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+            &ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"),\n                    print_value_path(closure_def_id, &[]),\n                    write(\"` implements the trait `{}`\", kind))\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 p!(write(\"the constant `\"),\n                    print_value_path(def_id, substs),\n                    write(\"` can be evaluated\"))\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 p!(write(\"the constant `\"),\n                    print(c1),\n                    write(\"` equals `\"),"}, {"sha": "babe0c54801e82d51ec2f2ca6c7b966746a0a146", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -220,27 +220,35 @@ impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n }\n \n impl fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind())\n+    }\n+}\n+\n+impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::Predicate::Trait(ref a, constness) => {\n+            ty::PredicateKind::Trait(ref a, constness) => {\n                 if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)\n             }\n-            ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n-            ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::Predicate::Projection(ref pair) => pair.fmt(f),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => write!(f, \"ObjectSafe({:?})\", trait_def_id),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n         }\n     }\n }\n@@ -467,37 +475,39 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n-    type Lifted = ty::Predicate<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n+    type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::Predicate::Trait(ref binder, constness) => {\n-                tcx.lift(binder).map(|binder| ty::Predicate::Trait(binder, constness))\n+            ty::PredicateKind::Trait(ref binder, constness) => {\n+                tcx.lift(binder).map(|binder| ty::PredicateKind::Trait(binder, constness))\n+            }\n+            ty::PredicateKind::Subtype(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::Subtype)\n             }\n-            ty::Predicate::Subtype(ref binder) => tcx.lift(binder).map(ty::Predicate::Subtype),\n-            ty::Predicate::RegionOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::RegionOutlives)\n+            ty::PredicateKind::RegionOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::RegionOutlives)\n             }\n-            ty::Predicate::TypeOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::TypeOutlives)\n+            ty::PredicateKind::TypeOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::TypeOutlives)\n             }\n-            ty::Predicate::Projection(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::Projection)\n+            ty::PredicateKind::Projection(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::Projection)\n             }\n-            ty::Predicate::WellFormed(ty) => tcx.lift(&ty).map(ty::Predicate::WellFormed),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateKind::WellFormed),\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 tcx.lift(&closure_substs).map(|closure_substs| {\n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                Some(ty::Predicate::ObjectSafe(trait_def_id))\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::Predicate::ConstEvaluatable(def_id, substs))\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::Predicate::ConstEquate(c1, c2))\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n+                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n             }\n         }\n     }\n@@ -977,6 +987,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.tcx().mk_predicate(ty::PredicateKind::super_fold_with(self.kind, folder))\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        ty::PredicateKind::super_visit_with(self.kind, visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))"}, {"sha": "0c9eef8093f33da4f16b9efc08597052f5b816f9", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -612,15 +612,16 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n-                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate()\n+                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n             ExistentialPredicate::Projection(p) => {\n-                ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n+                ty::PredicateKind::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n+                    .to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref =\n                     Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n-                trait_ref.without_const().to_predicate()\n+                trait_ref.without_const().to_predicate(tcx)\n             }\n         }\n     }"}, {"sha": "ebc8021a3c577b5d23f1b70cd0509fbc8db72649", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::Predicate::TypeOutlives(binder) = predicate {\n+                        if let ty::PredicateKind::TypeOutlives(binder) = predicate.kind() {\n                             if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n                                 binder.skip_binder()\n                             {"}, {"sha": "bdbce1de745ad11164f44fda7a0f4eacef5af2f1", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -27,8 +27,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef, Ty,\n-    TyCtxt, UserType, UserTypeAnnotationIndex,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef,\n+    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::Predicate::WellFormed(inferred_ty),\n+                        ty::PredicateKind::WellFormed(inferred_ty).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::Predicate::WellFormed(revealed_ty),\n+                        ty::PredicateKind::WellFormed(revealed_ty).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::Predicate::WellFormed(ty)),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty)),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -2017,7 +2017,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,\n-                                    ty::Predicate::Trait(\n+                                    ty::PredicateKind::Trait(\n                                         ty::Binder::bind(ty::TraitPredicate {\n                                             trait_ref: ty::TraitRef::new(\n                                                 self.tcx().require_lang_item(\n@@ -2028,7 +2028,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                             ),\n                                         }),\n                                         hir::Constness::NotConst,\n-                                    ),\n+                                    )\n+                                    .to_predicate(self.tcx()),\n                                 ),\n                                 &traits::SelectionError::Unimplemented,\n                                 false,\n@@ -2686,7 +2687,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::Predicate::Trait(\n+            Some(ty::PredicateKind::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n                 hir::Constness::NotConst,\n             )),\n@@ -2708,11 +2709,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     fn prove_predicates(\n         &mut self,\n-        predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n+            let predicate = predicate.to_predicate(self.tcx());\n             debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n \n             self.prove_predicate(predicate, locations, category);"}, {"sha": "fc4be82ad90ad04a95ef54394c8f3fbed1a279e1", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -219,7 +219,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n                 let scalar = match dest.layout.ty.kind {\n-                    ty::Int(_) => Scalar::from_int(discr_val as i128, dest.layout.size),\n+                    ty::Int(_) => Scalar::from_int(\n+                        self.sign_extend(discr_val, dest.layout) as i128,\n+                        dest.layout.size,\n+                    ),\n                     ty::Uint(_) => Scalar::from_uint(discr_val, dest.layout.size),\n                     _ => bug!(\"invalid `discriminant_value` return layout: {:?}\", dest.layout),\n                 };"}, {"sha": "ead530bded861ab1fee39e48cb567c64645ecaf5", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, adjustment::PointerCast, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -23,28 +23,30 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate {\n-                Predicate::RegionOutlives(_)\n-                | Predicate::TypeOutlives(_)\n-                | Predicate::WellFormed(_)\n-                | Predicate::Projection(_)\n-                | Predicate::ConstEvaluatable(..)\n-                | Predicate::ConstEquate(..) => continue,\n-                Predicate::ObjectSafe(_) => {\n+            match predicate.kind() {\n+                ty::PredicateKind::RegionOutlives(_)\n+                | ty::PredicateKind::TypeOutlives(_)\n+                | ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::Projection(_)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => continue,\n+                ty::PredicateKind::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n                 }\n-                Predicate::ClosureKind(..) => {\n+                ty::PredicateKind::ClosureKind(..) => {\n                     bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n-                Predicate::Subtype(_) => bug!(\"subtype predicate on function: {:#?}\", predicate),\n-                Predicate::Trait(pred, constness) => {\n+                ty::PredicateKind::Subtype(_) => {\n+                    bug!(\"subtype predicate on function: {:#?}\", predicate)\n+                }\n+                &ty::PredicateKind::Trait(pred, constness) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n                     match pred.skip_binder().self_ty().kind {\n                         ty::Param(ref p) => {\n                             // Allow `T: ?const Trait`\n-                            if *constness == hir::Constness::NotConst\n+                            if constness == hir::Constness::NotConst\n                                 && feature_allowed(tcx, def_id, sym::const_trait_bound_opt_out)\n                             {\n                                 continue;"}, {"sha": "9a63e39f535c12e8af4947a3b21064aec42542b0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -90,14 +90,14 @@ where\n     fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n         for (predicate, _span) in predicates {\n-            match predicate {\n-                ty::Predicate::Trait(poly_predicate, _) => {\n+            match predicate.kind() {\n+                ty::PredicateKind::Trait(poly_predicate, _) => {\n                     let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n                     if self.visit_trait(trait_ref) {\n                         return true;\n                     }\n                 }\n-                ty::Predicate::Projection(poly_predicate) => {\n+                ty::PredicateKind::Projection(poly_predicate) => {\n                     let ty::ProjectionPredicate { projection_ty, ty } =\n                         *poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n@@ -107,13 +107,13 @@ where\n                         return true;\n                     }\n                 }\n-                ty::Predicate::TypeOutlives(poly_predicate) => {\n+                ty::PredicateKind::TypeOutlives(poly_predicate) => {\n                     let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n                 }\n-                ty::Predicate::RegionOutlives(..) => {}\n+                ty::PredicateKind::RegionOutlives(..) => {}\n                 _ => bug!(\"unexpected predicate: {:?}\", predicate),\n             }\n         }"}, {"sha": "2544e4ddea2ecf25029a7a86f30ae31c03bb0af1", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1168,7 +1168,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds.predicates {\n-            if let ty::Predicate::Projection(projection) = &predicate {\n+            if let ty::PredicateKind::Projection(projection) = predicate.kind() {\n                 if projection.skip_binder().ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n@@ -1269,17 +1269,17 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate {\n-                ty::Predicate::Projection(..)\n-                | ty::Predicate::Trait(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::WellFormed(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::RegionOutlives(..)\n-                | ty::Predicate::ConstEvaluatable(..)\n-                | ty::Predicate::ConstEquate(..) => None,\n-                ty::Predicate::TypeOutlives(predicate) => {\n+            match obligation.predicate.kind() {\n+                ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => None,\n+                ty::PredicateKind::TypeOutlives(predicate) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a"}, {"sha": "716cbce60dcc9525fbb0a34bf8772a491273aa4d", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -341,7 +341,8 @@ impl AutoTraitFinder<'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::Predicate::Trait(pred, hir::Constness::NotConst),\n+                            ty::PredicateKind::Trait(pred, hir::Constness::NotConst)\n+                                .to_predicate(self.tcx),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -411,8 +412,10 @@ impl AutoTraitFinder<'tcx> {\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n-            if let (&ty::Predicate::Trait(new_trait, _), ty::Predicate::Trait(old_trait, _)) =\n-                (&new_pred, old_pred)\n+            if let (\n+                ty::PredicateKind::Trait(new_trait, _),\n+                ty::PredicateKind::Trait(old_trait, _),\n+            ) = (new_pred.kind(), old_pred.kind())\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.skip_binder().trait_ref.substs;\n@@ -630,8 +633,8 @@ impl AutoTraitFinder<'tcx> {\n             //\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n-            match &predicate {\n-                &ty::Predicate::Trait(p, _) => {\n+            match predicate.kind() {\n+                &ty::PredicateKind::Trait(p, _) => {\n                     if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n@@ -640,7 +643,7 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                     predicates.push_back(p);\n                 }\n-                &ty::Predicate::Projection(p) => {\n+                &ty::PredicateKind::Projection(p) => {\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -765,12 +768,12 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                &ty::Predicate::RegionOutlives(ref binder) => {\n+                ty::PredicateKind::RegionOutlives(ref binder) => {\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                &ty::Predicate::TypeOutlives(ref binder) => {\n+                ty::PredicateKind::TypeOutlives(ref binder) => {\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "2aef8aaf0e30386562c0db6fd0abc181ccc3f768", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -252,8 +252,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .emit();\n                     return;\n                 }\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate, _) => {\n+                match obligation.predicate.kind() {\n+                    ty::PredicateKind::Trait(ref trait_predicate, _) => {\n                         let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -308,7 +308,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             \"{}\",\n                             message.unwrap_or_else(|| format!(\n                                 \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.without_const().to_predicate(),\n+                                trait_ref.without_const().to_predicate(tcx),\n                                 post_message,\n                             ))\n                         );\n@@ -468,10 +468,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 trait_pred\n                             });\n                             let unit_obligation = Obligation {\n-                                predicate: ty::Predicate::Trait(\n+                                predicate: ty::PredicateKind::Trait(\n                                     predicate,\n                                     hir::Constness::NotConst,\n-                                ),\n+                                )\n+                                .to_predicate(self.tcx),\n                                 ..obligation.clone()\n                             };\n                             if self.predicate_may_hold(&unit_obligation) {\n@@ -489,14 +490,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err\n                     }\n \n-                    ty::Predicate::Subtype(ref predicate) => {\n+                    ty::PredicateKind::Subtype(ref predicate) => {\n                         // Errors for Subtype predicates show up as\n                         // `FulfillmentErrorCode::CodeSubtypeError`,\n                         // not selection error.\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                    ty::PredicateKind::RegionOutlives(ref predicate) => {\n                         let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, &predicate)\n@@ -512,7 +513,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                    ty::PredicateKind::Projection(..) | ty::PredicateKind::TypeOutlives(..) => {\n                         let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -523,12 +524,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n                         report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                    &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n                         let closure_span =\n                             self.tcx.sess.source_map().guess_head_span(\n@@ -587,7 +588,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return;\n                     }\n \n-                    ty::Predicate::WellFormed(ty) => {\n+                    ty::PredicateKind::WellFormed(ty) => {\n                         if !self.tcx.sess.opts.debugging_opts.chalk {\n                             // WF predicates cannot themselves make\n                             // errors. They can only block due to\n@@ -605,7 +606,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    ty::Predicate::ConstEvaluatable(..) => {\n+                    ty::PredicateKind::ConstEvaluatable(..) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -616,7 +617,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::ConstEquate(..) => {\n+                    ty::PredicateKind::ConstEquate(..) => {\n                         // Errors for `ConstEquate` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -1021,13 +1022,13 @@ trait InferCtxtPrivExt<'tcx> {\n \n     fn note_obligation_cause(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n     fn suggest_unsized_bound_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -1046,16 +1047,16 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return true;\n         }\n \n-        let (cond, error) = match (cond, error) {\n-            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n+        let (cond, error) = match (cond.kind(), error.kind()) {\n+            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error, _)) => (cond, error),\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n             }\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(*cond)) {\n-            if let ty::Predicate::Trait(implication, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(implication, _) = obligation.predicate.kind() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1135,7 +1136,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::Predicate::Projection(ref data) = predicate {\n+            if let ty::PredicateKind::Projection(ref data) = predicate.kind() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n@@ -1388,7 +1389,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> PredicateObligation<'tcx> {\n         let new_trait_ref =\n             ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n-        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate())\n+        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate(self.tcx))\n     }\n \n     fn maybe_report_ambiguity(\n@@ -1415,8 +1416,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+        let mut err = match predicate.kind() {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n@@ -1515,7 +1516,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::Predicate::WellFormed(ty) => {\n+            ty::PredicateKind::WellFormed(ty) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if ty.references_error() || self.tcx.sess.has_errors() {\n@@ -1524,7 +1525,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n             }\n \n-            ty::Predicate::Subtype(ref data) => {\n+            ty::PredicateKind::Subtype(ref data) => {\n                 if data.references_error() || self.tcx.sess.has_errors() {\n                     // no need to overload user in such cases\n                     return;\n@@ -1534,7 +1535,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n             }\n-            ty::Predicate::Projection(ref data) => {\n+            ty::PredicateKind::Projection(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.self_ty();\n                 let ty = data.skip_binder().ty;\n@@ -1627,7 +1628,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let obligation = Obligation::new(\n                 ObligationCause::dummy(),\n                 param_env,\n-                cleaned_pred.without_const().to_predicate(),\n+                cleaned_pred.without_const().to_predicate(selcx.tcx()),\n             );\n \n             self.predicate_may_hold(&obligation)\n@@ -1636,7 +1637,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn note_obligation_cause(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         // First, attempt to add note to this error with an async-await-specific\n@@ -1654,13 +1655,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn suggest_unsized_bound_if_applicable(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         if let (\n-            ty::Predicate::Trait(pred, _),\n+            ty::PredicateKind::Trait(pred, _),\n             ObligationCauseCode::BindingObligation(item_def_id, span),\n-        ) = (&obligation.predicate, &obligation.cause.code)\n+        ) = (obligation.predicate.kind(), &obligation.cause.code)\n         {\n             if let (Some(generics), true) = (\n                 self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),"}, {"sha": "6167412642eab20fae0f62888feae7e48bea49a2", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -38,14 +38,14 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         body_id: hir::HirId,\n     );\n \n     fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n     );\n \n     fn get_closure_name(\n@@ -66,7 +66,7 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n         has_custom_message: bool,\n@@ -75,22 +75,22 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     );\n \n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     );\n \n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     );\n@@ -99,15 +99,15 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn suggest_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -138,11 +138,11 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n-        inner_generator_body: Option<&hir::Body<'_>>,\n+        inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'_>,\n+        trait_ref: ty::TraitRef<'tcx>,\n         target_ty: Ty<'tcx>,\n-        tables: &ty::TypeckTables<'_>,\n+        tables: &ty::TypeckTables<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n     );\n@@ -183,12 +183,13 @@ fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, St\n /// it can also be an `impl Trait` param that needs to be decomposed to a type\n /// param for cleaner code.\n fn suggest_restriction(\n-    generics: &hir::Generics<'_>,\n+    tcx: TyCtxt<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n     msg: &str,\n     err: &mut DiagnosticBuilder<'_>,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n-    trait_ref: ty::PolyTraitRef<'_>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n     super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n ) {\n     // When we are dealing with a trait, `super_traits` will be `Some`:\n@@ -243,7 +244,7 @@ fn suggest_restriction(\n \n         // FIXME: modify the `trait_ref` instead of string shenanigans.\n         // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-        let pred = trait_ref.without_const().to_predicate().to_string();\n+        let pred = trait_ref.without_const().to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n             match generics\n@@ -285,9 +286,10 @@ fn suggest_restriction(\n     } else {\n         // Trivial case: `T` needs an extra bound: `T: Bound`.\n         let (sp, suggestion) = match super_traits {\n-            None => {\n-                predicate_constraint(generics, trait_ref.without_const().to_predicate().to_string())\n-            }\n+            None => predicate_constraint(\n+                generics,\n+                trait_ref.without_const().to_predicate(tcx).to_string(),\n+            ),\n             Some((ident, bounds)) => match bounds {\n                 [.., bound] => (\n                     bound.span().shrink_to_hi(),\n@@ -313,7 +315,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'_>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         body_id: hir::HirId,\n     ) {\n         let self_ty = trait_ref.self_ty();\n@@ -336,6 +338,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n+                        self.tcx,\n                         &generics,\n                         \"`Self`\",\n                         err,\n@@ -355,7 +358,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        &generics, \"`Self`\", err, None, projection, trait_ref, None,\n+                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_ref, None,\n                     );\n                     return;\n                 }\n@@ -375,6 +378,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }) if projection.is_some() => {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n+                        self.tcx,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -393,6 +397,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }) if projection.is_some() => {\n                     // Missing restriction on associated type of type parameter (unmet projection).\n                     suggest_restriction(\n+                        self.tcx,\n                         &generics,\n                         \"the associated type\",\n                         err,\n@@ -450,7 +455,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let &ObligationCauseCode::VariableType(hir_id) = code {\n             let parent_node = self.tcx.hir().get_parent_node(hir_id);\n@@ -601,7 +606,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n         has_custom_message: bool,\n@@ -624,7 +629,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let new_obligation = Obligation::new(\n                 ObligationCause::dummy(),\n                 param_env,\n-                new_trait_ref.without_const().to_predicate(),\n+                new_trait_ref.without_const().to_predicate(self.tcx),\n             );\n             if self.predicate_must_hold_modulo_regions(&new_obligation) {\n                 if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -673,7 +678,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let trait_ref = trait_ref.skip_binder();\n@@ -735,7 +740,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n@@ -806,7 +811,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n@@ -852,7 +857,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// emitted.\n     fn suggest_impl_trait(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n@@ -1048,7 +1053,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut DiagnosticBuilder<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         match obligation.cause.code.peel_derives() {\n@@ -1237,8 +1242,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // the type. The last generator (`outer_generator` below) has information about where the\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n-        let (mut trait_ref, mut target_ty) = match obligation.predicate {\n-            ty::Predicate::Trait(p, _) => {\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(p, _) => {\n                 (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n             }\n             _ => (None, None),\n@@ -1430,11 +1435,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n-        inner_generator_body: Option<&hir::Body<'_>>,\n+        inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'_>,\n+        trait_ref: ty::TraitRef<'tcx>,\n         target_ty: Ty<'tcx>,\n-        tables: &ty::TypeckTables<'_>,\n+        tables: &ty::TypeckTables<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n     ) {\n@@ -1788,7 +1793,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n \n-                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n                     self.note_obligation_cause_code(\n                         err,\n@@ -1805,7 +1810,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     parent_trait_ref.print_only_trait_path(),\n                     parent_trait_ref.skip_binder().self_ty()\n                 ));\n-                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 self.note_obligation_cause_code(\n                     err,\n                     &parent_predicate,\n@@ -1815,7 +1820,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             ObligationCauseCode::DerivedObligation(ref data) => {\n                 let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-                let parent_predicate = parent_trait_ref.without_const().to_predicate();\n+                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n                 self.note_obligation_cause_code(\n                     err,\n                     &parent_predicate,\n@@ -2061,7 +2066,7 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n }\n \n fn suggest_trait_object_return_type_alternatives(\n-    err: &mut DiagnosticBuilder<'tcx>,\n+    err: &mut DiagnosticBuilder<'_>,\n     ret_ty: Span,\n     trait_obj: &str,\n     is_object_safe: bool,"}, {"sha": "e44163f7bb1a4a74e848c6e0007ad4ee03f48f50", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -83,7 +83,7 @@ pub struct PendingPredicateObligation<'tcx> {\n \n // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PendingPredicateObligation<'_>, 136);\n+static_assert_size!(PendingPredicateObligation<'_>, 112);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n@@ -322,8 +322,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         let infcx = self.selcx.infcx();\n \n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(*data);\n \n                 if data.is_global() {\n@@ -378,14 +378,14 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::RegionOutlives(ref binder) => {\n+            ty::PredicateKind::RegionOutlives(ref binder) => {\n                 match infcx.region_outlives_predicate(&obligation.cause, binder) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n             }\n \n-            ty::Predicate::TypeOutlives(ref binder) => {\n+            ty::PredicateKind::TypeOutlives(ref binder) => {\n                 // Check if there are higher-ranked vars.\n                 match binder.no_bound_vars() {\n                     // If there are, inspect the underlying type further.\n@@ -429,7 +429,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::Projection(ref data) => {\n+            ty::PredicateKind::Projection(ref data) => {\n                 let project_obligation = obligation.with(*data);\n                 match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n                     Ok(None) => {\n@@ -443,15 +443,15 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 if !self.selcx.tcx().is_object_safe(trait_def_id) {\n                     ProcessResult::Error(CodeSelectionError(Unimplemented))\n                 } else {\n                     ProcessResult::Changed(vec![])\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(_, closure_substs, kind) => {\n+            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                 match self.selcx.infcx().closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -464,7 +464,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::WellFormed(ty) => {\n+            &ty::PredicateKind::WellFormed(ty) => {\n                 match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n@@ -481,7 +481,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::Subtype(ref subtype) => {\n+            ty::PredicateKind::Subtype(subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,\n                     obligation.param_env,\n@@ -510,7 +510,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 match self.selcx.infcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -523,7 +523,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n \n                 let stalled_on = &mut pending_obligation.stalled_on;"}, {"sha": "3daa9109aafe8141f02e4051716d551610f89a78", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -143,7 +143,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         param_env,\n         cause: ObligationCause::misc(span, hir::CRATE_HIR_ID),\n         recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n     };\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n@@ -333,8 +333,8 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate {\n-            ty::Predicate::TypeOutlives(..) => true,\n+        .drain_filter(|predicate| match predicate.kind() {\n+            ty::PredicateKind::TypeOutlives(..) => true,\n             _ => false,\n         })\n         .collect();\n@@ -557,7 +557,7 @@ fn type_implements_trait<'tcx>(\n         cause: ObligationCause::dummy(),\n         param_env,\n         recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(tcx),\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n }"}, {"sha": "b2d684e674f02ba736b4559559c196acc7c22e9a", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -245,16 +245,16 @@ fn predicates_reference_self(\n         .iter()\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n-            match predicate {\n-                ty::Predicate::Trait(ref data, _) => {\n+            match predicate.kind() {\n+                ty::PredicateKind::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n                     if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n                         Some(sp)\n                     } else {\n                         None\n                     }\n                 }\n-                ty::Predicate::Projection(ref data) => {\n+                ty::PredicateKind::Projection(ref data) => {\n                     // And similarly for projections. This should be redundant with\n                     // the previous check because any projection should have a\n                     // matching `Trait` predicate with the same inputs, but we do\n@@ -276,14 +276,14 @@ fn predicates_reference_self(\n                         None\n                     }\n                 }\n-                ty::Predicate::WellFormed(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::TypeOutlives(..)\n-                | ty::Predicate::RegionOutlives(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::ConstEvaluatable(..)\n-                | ty::Predicate::ConstEquate(..) => None,\n+                ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => None,\n             }\n         })\n         .collect()\n@@ -304,19 +304,22 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| match obligation.predicate {\n-        ty::Predicate::Trait(ref trait_pred, _) => {\n-            trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n+    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(ref trait_pred, _) => {\n+                trait_pred.def_id() == sized_def_id\n+                    && trait_pred.skip_binder().self_ty().is_param(0)\n+            }\n+            ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::RegionOutlives(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => false,\n         }\n-        ty::Predicate::Projection(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::RegionOutlives(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => false,\n     })\n }\n \n@@ -636,7 +639,7 @@ fn receiver_is_dispatchable<'tcx>(\n             substs: tcx.mk_substs_trait(tcx.types.self_param, &[unsized_self_ty.into()]),\n         }\n         .without_const()\n-        .to_predicate();\n+        .to_predicate(tcx);\n \n         // U: Trait<Arg1, ..., ArgN>\n         let trait_predicate = {\n@@ -649,7 +652,7 @@ fn receiver_is_dispatchable<'tcx>(\n                     }\n                 });\n \n-            ty::TraitRef { def_id: unsize_did, substs }.without_const().to_predicate()\n+            ty::TraitRef { def_id: unsize_did, substs }.without_const().to_predicate(tcx)\n         };\n \n         let caller_bounds: Vec<Predicate<'tcx>> = param_env\n@@ -672,7 +675,7 @@ fn receiver_is_dispatchable<'tcx>(\n             substs: tcx.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n         }\n         .without_const()\n-        .to_predicate();\n+        .to_predicate(tcx);\n \n         Obligation::new(ObligationCause::dummy(), param_env, predicate)\n     };"}, {"sha": "9b63cbdd83cac8aa963b35e5b7085e2bf5f575b2", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -436,7 +436,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         });\n         let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n         let obligation =\n-            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate());\n+            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate(tcx));\n         obligations.push(obligation);\n         ty_var\n     })\n@@ -665,7 +665,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n     let mut obligations: Vec<_> = result\n         .obligations\n         .iter()\n-        .filter(|obligation| match obligation.predicate {\n+        .filter(|obligation| match obligation.predicate.kind() {\n             // We found a `T: Foo<X = U>` predicate, let's check\n             // if `U` references any unresolved type\n             // variables. In principle, we only care if this\n@@ -675,7 +675,9 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n             // indirect obligations (e.g., we project to `?0`,\n             // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n             // ?0>`).\n-            ty::Predicate::Projection(ref data) => infcx.unresolved_type_vars(&data.ty()).is_some(),\n+            ty::PredicateKind::Projection(ref data) => {\n+                infcx.unresolved_type_vars(&data.ty()).is_some()\n+            }\n \n             // We are only interested in `T: Foo<X = U>` predicates, whre\n             // `U` references one of `unresolved_type_vars`. =)\n@@ -724,7 +726,7 @@ fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n         cause,\n         recursion_depth: depth,\n         param_env,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n     }\n }\n \n@@ -759,7 +761,7 @@ fn normalize_to_error<'a, 'tcx>(\n         cause,\n         recursion_depth: depth,\n         param_env,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(selcx.tcx()),\n     };\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n@@ -932,7 +934,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let ty::Predicate::Projection(data) = predicate {\n+        if let &ty::PredicateKind::Projection(data) = predicate.kind() {\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id\n@@ -1202,20 +1204,19 @@ fn confirm_object_candidate<'cx, 'tcx>(\n             object_ty\n         ),\n     };\n-    let env_predicates =\n-        data.projection_bounds().map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate());\n+    let env_predicates = data\n+        .projection_bounds()\n+        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate(selcx.tcx()));\n     let env_predicate = {\n         let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n \n         // select only those projections that are actually projecting an\n         // item with the correct name\n-        let env_predicates = env_predicates.filter_map(|o| match o.predicate {\n-            ty::Predicate::Projection(data) => {\n-                if data.projection_def_id() == obligation.predicate.item_def_id {\n-                    Some(data)\n-                } else {\n-                    None\n-                }\n+        let env_predicates = env_predicates.filter_map(|o| match o.predicate.kind() {\n+            &ty::PredicateKind::Projection(data)\n+                if data.projection_def_id() == obligation.predicate.item_def_id =>\n+            {\n+                Some(data)\n             }\n             _ => None,\n         });"}, {"sha": "5c8719da14e6fcabe9eb58520a45458a3535b551", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use rustc_middle::ty::{ParamEnvAnd, Predicate, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::ProvePredicate;\n \n@@ -15,7 +15,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let Predicate::Trait(trait_ref, _) = key.value.predicate {\n+        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate.kind() {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.skip_binder().self_ty().is_trivially_sized(tcx) {"}, {"sha": "6110d6470df90205a057a2fd34b8c6870f75e3fc", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -414,14 +414,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref t, _) => {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(t, _) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(*t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            ty::Predicate::Subtype(ref p) => {\n+            ty::PredicateKind::Subtype(p) => {\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -436,7 +436,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::WellFormed(ty) => match wf::obligations(\n+            &ty::PredicateKind::WellFormed(ty) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n@@ -450,20 +450,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 None => Ok(EvaluatedToAmbig),\n             },\n \n-            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n+            ty::PredicateKind::TypeOutlives(..) | ty::PredicateKind::RegionOutlives(..) => {\n                 // We do not consider region relationships when evaluating trait matches.\n                 Ok(EvaluatedToOkModuloRegions)\n             }\n \n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n                     Ok(EvaluatedToOk)\n                 } else {\n                     Ok(EvaluatedToErr)\n                 }\n             }\n \n-            ty::Predicate::Projection(ref data) => {\n+            ty::PredicateKind::Projection(data) => {\n                 let project_obligation = obligation.with(*data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(mut subobligations)) => {\n@@ -484,7 +484,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(_, closure_substs, kind) => {\n+            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                 match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -497,7 +497,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 match self.tcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -511,7 +511,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 debug!(\"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\", c1, c2);\n \n                 let evaluate = |c: &'tcx ty::Const<'tcx>| {\n@@ -676,8 +676,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // trait refs. This is important because it's only a cycle\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n+            let tcx = self.tcx();\n             let cycle = cycle.map(|stack| {\n-                ty::Predicate::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n+                ty::PredicateKind::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n+                    .to_predicate(tcx)\n             });\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n@@ -792,8 +794,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate {\n-            ty::Predicate::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n+        let result = match predicate.kind() {\n+            ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n@@ -2926,7 +2928,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n+                    .to_predicate(self.tcx()),\n             ));\n         }\n \n@@ -3036,7 +3039,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     cause,\n                     obligation.recursion_depth + 1,\n                     obligation.param_env,\n-                    ty::Binder::bind(outlives).to_predicate(),\n+                    ty::Binder::bind(outlives).to_predicate(tcx),\n                 ));\n             }\n \n@@ -3079,12 +3082,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     tcx.mk_substs_trait(source, &[]),\n                 );\n-                nested.push(predicate_to_obligation(tr.without_const().to_predicate()));\n+                nested.push(predicate_to_obligation(tr.without_const().to_predicate(tcx)));\n \n                 // If the type is `Foo + 'a`, ensure that the type\n                 // being cast to `Foo + 'a` outlives `'a`:\n                 let outlives = ty::OutlivesPredicate(source, r);\n-                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate()));\n+                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate(tcx)));\n             }\n \n             // `[T; n]` -> `[T]`"}, {"sha": "f2d3f0e1116e2fb03f8f41602816c7ef72d6df9a", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -97,7 +97,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n     fn expand(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n         let tcx = self.tcx;\n         let trait_ref = item.trait_ref();\n-        let pred = trait_ref.without_const().to_predicate();\n+        let pred = trait_ref.without_const().to_predicate(tcx);\n \n         debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n \n@@ -110,7 +110,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n         // Don't recurse if this trait alias is already on the stack for the DFS search.\n         let anon_pred = anonymize_predicate(tcx, &pred);\n         if item.path.iter().rev().skip(1).any(|(tr, _)| {\n-            anonymize_predicate(tcx, &tr.without_const().to_predicate()) == anon_pred\n+            anonymize_predicate(tcx, &tr.without_const().to_predicate(tcx)) == anon_pred\n         }) {\n             return false;\n         }\n@@ -234,6 +234,7 @@ pub fn predicates_for_generics<'tcx>(\n }\n \n pub fn predicate_for_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n@@ -243,7 +244,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n         cause,\n         param_env,\n         recursion_depth,\n-        predicate: trait_ref.without_const().to_predicate(),\n+        predicate: trait_ref.without_const().to_predicate(tcx),\n     }\n }\n \n@@ -258,7 +259,7 @@ pub fn predicate_for_trait_def(\n ) -> PredicateObligation<'tcx> {\n     let trait_ref =\n         ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(self_ty, params) };\n-    predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n+    predicate_for_trait_ref(tcx, cause, param_env, trait_ref, recursion_depth)\n }\n \n /// Casts a trait reference into a reference to one of its super"}, {"sha": "5118859765ed703eccd64a68315cf5b1d3d9472f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -72,37 +72,37 @@ pub fn predicate_obligations<'a, 'tcx>(\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n-    match *predicate {\n-        ty::Predicate::Trait(ref t, _) => {\n+    match predicate.kind() {\n+        ty::PredicateKind::Trait(t, _) => {\n             wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n-        ty::Predicate::RegionOutlives(..) => {}\n-        ty::Predicate::TypeOutlives(ref t) => {\n+        ty::PredicateKind::RegionOutlives(..) => {}\n+        ty::PredicateKind::TypeOutlives(t) => {\n             wf.compute(t.skip_binder().0);\n         }\n-        ty::Predicate::Projection(ref t) => {\n+        ty::PredicateKind::Projection(t) => {\n             let t = t.skip_binder(); // (*)\n             wf.compute_projection(t.projection_ty);\n             wf.compute(t.ty);\n         }\n-        ty::Predicate::WellFormed(t) => {\n+        &ty::PredicateKind::WellFormed(t) => {\n             wf.compute(t);\n         }\n-        ty::Predicate::ObjectSafe(_) => {}\n-        ty::Predicate::ClosureKind(..) => {}\n-        ty::Predicate::Subtype(ref data) => {\n+        ty::PredicateKind::ObjectSafe(_) => {}\n+        ty::PredicateKind::ClosureKind(..) => {}\n+        ty::PredicateKind::Subtype(data) => {\n             wf.compute(data.skip_binder().a); // (*)\n             wf.compute(data.skip_binder().b); // (*)\n         }\n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+        &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n             let obligations = wf.nominal_obligations(def_id, substs);\n             wf.out.extend(obligations);\n \n             for ty in substs.types() {\n                 wf.compute(ty);\n             }\n         }\n-        ty::Predicate::ConstEquate(c1, c2) => {\n+        ty::PredicateKind::ConstEquate(c1, c2) => {\n             wf.compute(c1.ty);\n             wf.compute(c2.ty);\n         }\n@@ -170,8 +170,8 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             hir::ImplItemKind::Const(ty, _) | hir::ImplItemKind::TyAlias(ty) => ty.span,\n             _ => impl_item_ref.span,\n         };\n-    match pred {\n-        ty::Predicate::Projection(proj) => {\n+    match pred.kind() {\n+        ty::PredicateKind::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being\n             // implemented, but rather from a \"second order\" obligation, like in\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`.\n@@ -194,7 +194,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 }\n             }\n         }\n-        ty::Predicate::Trait(pred, _) => {\n+        ty::PredicateKind::Trait(pred, _) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n@@ -216,6 +216,10 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n }\n \n impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n@@ -275,8 +279,15 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             self.out.extend(obligations);\n         }\n \n+        let tcx = self.tcx();\n         self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n-            |ty| traits::Obligation::new(cause.clone(), param_env, ty::Predicate::WellFormed(ty)),\n+            |ty| {\n+                traits::Obligation::new(\n+                    cause.clone(),\n+                    param_env,\n+                    ty::PredicateKind::WellFormed(ty).to_predicate(tcx),\n+                )\n+            },\n         ));\n     }\n \n@@ -290,7 +301,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n         if !data.has_escaping_bound_vars() {\n-            let predicate = trait_ref.without_const().to_predicate();\n+            let predicate = trait_ref.without_const().to_predicate(self.infcx.tcx);\n             let cause = self.cause(traits::ProjectionWf(data));\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -305,7 +316,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n \n-            let predicate = ty::Predicate::ConstEvaluatable(def_id, substs);\n+            let predicate =\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx());\n             let cause = self.cause(traits::MiscObligation);\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -321,7 +333,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             self.out.push(traits::Obligation::new(\n                 cause,\n                 self.param_env,\n-                trait_ref.without_const().to_predicate(),\n+                trait_ref.without_const().to_predicate(self.infcx.tcx),\n             ));\n         }\n     }\n@@ -411,9 +423,10 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                                rty, r,\n-                            ))),\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n+                                ty::OutlivesPredicate(rty, r),\n+                            ))\n+                            .to_predicate(self.tcx()),\n                         ));\n                     }\n                 }\n@@ -493,16 +506,17 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // obligations that don't refer to Self and\n                     // checking those\n \n-                    let defer_to_coercion = self.infcx.tcx.features().object_safe_for_dispatch;\n+                    let defer_to_coercion = self.tcx().features().object_safe_for_dispatch;\n \n                     if !defer_to_coercion {\n                         let cause = self.cause(traits::MiscObligation);\n                         let component_traits = data.auto_traits().chain(data.principal_def_id());\n+                        let tcx = self.tcx();\n                         self.out.extend(component_traits.map(|did| {\n                             traits::Obligation::new(\n                                 cause.clone(),\n                                 param_env,\n-                                ty::Predicate::ObjectSafe(did),\n+                                ty::PredicateKind::ObjectSafe(did).to_predicate(tcx),\n                             )\n                         }));\n                     }\n@@ -528,7 +542,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::Predicate::WellFormed(ty),\n+                            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result.\n@@ -608,7 +622,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 self.out.push(traits::Obligation::new(\n                     cause,\n                     self.param_env,\n-                    outlives.to_predicate(),\n+                    outlives.to_predicate(self.infcx.tcx),\n                 ));\n             }\n         }"}, {"sha": "7d48b4575381054392e7adf24a230b038509d6a2", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -38,8 +38,7 @@ use rustc_middle::traits::{\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::{\n-    self, Binder, BoundRegion, Predicate, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable,\n-    TypeVisitor,\n+    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n };\n use rustc_span::def_id::DefId;\n \n@@ -78,8 +77,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                match predicate {\n-                    ty::Predicate::Trait(predicate, _) => {\n+                match &predicate.kind() {\n+                    ty::PredicateKind::Trait(predicate, _) => {\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -100,9 +99,9 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                         )\n                     }\n                     // FIXME(chalk): need to add RegionOutlives/TypeOutlives\n-                    ty::Predicate::RegionOutlives(_) => None,\n-                    ty::Predicate::TypeOutlives(_) => None,\n-                    ty::Predicate::Projection(predicate) => {\n+                    ty::PredicateKind::RegionOutlives(_) => None,\n+                    ty::PredicateKind::TypeOutlives(_) => None,\n+                    ty::PredicateKind::Projection(predicate) => {\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -122,12 +121,14 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..)\n-                    | ty::Predicate::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n+                    ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::ObjectSafe(..)\n+                    | ty::PredicateKind::ClosureKind(..)\n+                    | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..) => {\n+                        bug!(\"unexpected predicate {}\", predicate)\n+                    }\n                 }\n             }\n             ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n@@ -154,17 +155,17 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        match self {\n-            Predicate::Trait(predicate, _) => predicate.lower_into(interner),\n+        match self.kind() {\n+            ty::PredicateKind::Trait(predicate, _) => predicate.lower_into(interner),\n             // FIXME(chalk): we need to register constraints.\n-            Predicate::RegionOutlives(_predicate) => {\n+            ty::PredicateKind::RegionOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            Predicate::TypeOutlives(_predicate) => {\n+            ty::PredicateKind::TypeOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            Predicate::Projection(predicate) => predicate.lower_into(interner),\n-            Predicate::WellFormed(ty) => match ty.kind {\n+            ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n+            ty::PredicateKind::WellFormed(ty) => match ty.kind {\n                 // These types are always WF.\n                 ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n                     chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n@@ -188,11 +189,13 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n-            Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n+            ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n         }\n     }\n }\n@@ -439,8 +442,8 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        match &self {\n-            Predicate::Trait(predicate, _) => {\n+        match &self.kind() {\n+            ty::PredicateKind::Trait(predicate, _) => {\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -449,16 +452,16 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            Predicate::RegionOutlives(_predicate) => None,\n-            Predicate::TypeOutlives(_predicate) => None,\n-            Predicate::Projection(_predicate) => None,\n-            Predicate::WellFormed(_ty) => None,\n-\n-            Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n+            ty::PredicateKind::RegionOutlives(_predicate) => None,\n+            ty::PredicateKind::TypeOutlives(_predicate) => None,\n+            ty::PredicateKind::Projection(_predicate) => None,\n+            ty::PredicateKind::WellFormed(_ty) => None,\n+\n+            ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n         }\n     }\n }"}, {"sha": "5dee71a2338ccec8651df4f8fb90cf49eb4e9368", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -94,28 +94,28 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // region relationships.\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n-            match obligation.predicate {\n-                ty::Predicate::Trait(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::Projection(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ConstEvaluatable(..)\n-                | ty::Predicate::ConstEquate(..) => vec![],\n+            match obligation.predicate.kind() {\n+                ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => vec![],\n \n-                ty::Predicate::WellFormed(subty) => {\n+                ty::PredicateKind::WellFormed(subty) => {\n                     wf_types.push(subty);\n                     vec![]\n                 }\n \n-                ty::Predicate::RegionOutlives(ref data) => match data.no_bound_vars() {\n+                ty::PredicateKind::RegionOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                         vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                     }\n                 },\n \n-                ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n+                ty::PredicateKind::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_vars_if_possible(&ty_a);"}, {"sha": "fcb75142269df50250985f933087c3093538a7d7", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -40,15 +40,15 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n }\n \n fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n-    match p {\n-        ty::Predicate::RegionOutlives(..) | ty::Predicate::TypeOutlives(..) => false,\n-        ty::Predicate::Trait(..)\n-        | ty::Predicate::Projection(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => true,\n+    match p.kind() {\n+        ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n+        ty::PredicateKind::Trait(..)\n+        | ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => true,\n     }\n }"}, {"sha": "22077b49c3b775de71d3e2280a2861ea1ffc76b7", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -6,9 +6,8 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n-use rustc_middle::ty::{\n-    FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n-};\n+use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable, Variance};\n+use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Predicate, ToPredicate};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -140,7 +139,9 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n \n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n-            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+            self.prove_predicate(\n+                ty::PredicateKind::WellFormed(impl_self_ty).to_predicate(self.tcx()),\n+            );\n         }\n \n         // In addition to proving the predicates, we have to\n@@ -154,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(Predicate::WellFormed(ty));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "3da5da2d9efb8f62c8fbc6f597be2d0d38e20aab", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -61,7 +61,7 @@ fn sized_constraint_for_ty<'tcx>(\n                 substs: tcx.mk_substs_trait(ty, &[]),\n             })\n             .without_const()\n-            .to_predicate();\n+            .to_predicate(tcx);\n             let predicates = tcx.predicates_of(adtdef.did).predicates;\n             if predicates.iter().any(|(p, _)| *p == sized_predicate) { vec![] } else { vec![ty] }\n         }"}, {"sha": "9a5fe9552d35a014e94e6bf000ae818980e95af4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1596,16 +1596,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n                     obligation.predicate\n                 );\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(pred, _) => {\n+                match obligation.predicate.kind() {\n+                    ty::PredicateKind::Trait(pred, _) => {\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    ty::Predicate::Projection(pred) => {\n+                    &ty::PredicateKind::Projection(pred) => {\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self =\n@@ -3042,7 +3042,7 @@ impl<'tcx> Bounds<'tcx> {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[]),\n                 });\n-                (trait_ref.without_const().to_predicate(), span)\n+                (trait_ref.without_const().to_predicate(tcx), span)\n             })\n         });\n \n@@ -3057,16 +3057,16 @@ impl<'tcx> Bounds<'tcx> {\n                         // or it's a generic associated type that deliberately has escaping bound vars.\n                         let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                         let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                        (ty::Binder::bind(outlives).to_predicate(), span)\n+                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n                     })\n                     .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n-                        let predicate = bound_trait_ref.with_constness(constness).to_predicate();\n+                        let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n                         (predicate, span)\n                     }))\n                     .chain(\n                         self.projection_bounds\n                             .iter()\n-                            .map(|&(projection, span)| (projection.to_predicate(), span)),\n+                            .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n                     ),\n             )\n             .collect()"}, {"sha": "8ca0861090605e1e5a00d6ae8616bb23b1bb90d7", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         let obligation = traits::Obligation::new(\n             cause.clone(),\n             self.param_env,\n-            trait_ref.without_const().to_predicate(),\n+            trait_ref.without_const().to_predicate(tcx),\n         );\n         if !self.infcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");"}, {"sha": "f393121a0adb827775f0268981df9c5f54322b41", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n@@ -206,7 +206,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n+                if let ty::PredicateKind::Projection(ref proj_predicate) =\n+                    obligation.predicate.kind()\n+                {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     self.deduce_sig_from_projection(Some(obligation.cause.span), proj_predicate)\n@@ -526,10 +528,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.push(Obligation::new(\n                     cause,\n                     self.param_env,\n-                    ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+                    ty::PredicateKind::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                         supplied_ty,\n                         closure_body_region,\n-                    ))),\n+                    )))\n+                    .to_predicate(self.tcx),\n                 ));\n             }\n \n@@ -641,7 +644,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n+            if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate.kind() {\n                 self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n             } else {\n                 None"}, {"sha": "2a1c6b895ce20b55c5e8505251a5aef87bdaf058", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -596,8 +596,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate {\n-                ty::Predicate::Trait(trait_pred, _) if traits.contains(&trait_pred.def_id()) => {\n+            let trait_pred = match obligation.predicate.kind() {\n+                &ty::PredicateKind::Trait(trait_pred, _)\n+                    if traits.contains(&trait_pred.def_id()) =>\n+                {\n                     if unsize_did == trait_pred.def_id() {\n                         let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n                         if let ty::Tuple(..) = unsize_ty.kind {"}, {"sha": "fc7a9c1d59b76a4ccfd95d7f7d2cafbb3fdfbfee", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -10,7 +10,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::{CloneTraitLangItem, DerefTraitLangItem};\n use rustc_hir::{is_range_literal, Node};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::{self, AssocItem, ToPredicate, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -644,7 +644,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .unwrap()\n                     .def_id;\n                 let predicate =\n-                    ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n+                    ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         // `<T as Deref>::Output`\n                         projection_ty: ty::ProjectionTy {\n                             // `T`\n@@ -654,7 +654,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         // `U`\n                         ty: expected,\n-                    }));\n+                    }))\n+                    .to_predicate(self.tcx);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n                 let impls_deref = self.infcx.predicate_may_hold(&obligation);\n "}, {"sha": "594cdab852fdafcf07c6d97822fe070c11eafaee", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -230,9 +230,11 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (predicate, p) {\n-                (Predicate::Trait(a, _), Predicate::Trait(b, _)) => relator.relate(a, b).is_ok(),\n-                (Predicate::Projection(a), Predicate::Projection(b)) => {\n+            match (predicate.kind(), p.kind()) {\n+                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n+                    relator.relate(a, b).is_ok()\n+                }\n+                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n                 _ => predicate == p,"}, {"sha": "410c5efdf37d4ef0e241ddce6762a64e0a290740", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -574,8 +574,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n-            .filter_map(|obligation| match obligation.predicate {\n-                ty::Predicate::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n+            .filter_map(|obligation| match obligation.predicate.kind() {\n+                ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     let span = predicates\n                         .predicates\n                         .iter()"}, {"sha": "aae02ea0273f9a5b15d89bd15202080b6100df88", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             self.body_id,\n             self.param_env,\n-            poly_trait_ref.without_const().to_predicate(),\n+            poly_trait_ref.without_const().to_predicate(self.tcx),\n         );\n \n         // Now we want to know if this can be matched\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::Predicate::WellFormed(method_ty),\n+            ty::PredicateKind::WellFormed(method_ty).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "91562d576ea809e3d34598fbe5e4b6f531f6d162", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -796,23 +796,26 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n         // FIXME: do we want to commit to this behavior for param bounds?\n \n-        let bounds = self.param_env.caller_bounds.iter().filter_map(|predicate| match *predicate {\n-            ty::Predicate::Trait(ref trait_predicate, _) => {\n-                match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n-                    ty::Param(ref p) if *p == param_ty => Some(trait_predicate.to_poly_trait_ref()),\n-                    _ => None,\n+        let bounds =\n+            self.param_env.caller_bounds.iter().filter_map(|predicate| match predicate.kind() {\n+                ty::PredicateKind::Trait(ref trait_predicate, _) => {\n+                    match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n+                        ty::Param(ref p) if *p == param_ty => {\n+                            Some(trait_predicate.to_poly_trait_ref())\n+                        }\n+                        _ => None,\n+                    }\n                 }\n-            }\n-            ty::Predicate::Subtype(..)\n-            | ty::Predicate::Projection(..)\n-            | ty::Predicate::RegionOutlives(..)\n-            | ty::Predicate::WellFormed(..)\n-            | ty::Predicate::ObjectSafe(..)\n-            | ty::Predicate::ClosureKind(..)\n-            | ty::Predicate::TypeOutlives(..)\n-            | ty::Predicate::ConstEvaluatable(..)\n-            | ty::Predicate::ConstEquate(..) => None,\n-        });\n+                ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => None,\n+            });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);\n@@ -1374,7 +1377,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n \n                 TraitCandidate(trait_ref) => {\n-                    let predicate = trait_ref.without_const().to_predicate();\n+                    let predicate = trait_ref.without_const().to_predicate(self.tcx);\n                     let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n                         result = ProbeResult::NoMatch;"}, {"sha": "7ca3eb884d88fc5d82eee63b5099f214946dfa39", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             span,\n                             self.body_id,\n                             self.param_env,\n-                            poly_trait_ref.without_const().to_predicate(),\n+                            poly_trait_ref.without_const().to_predicate(tcx),\n                         );\n                         self.predicate_may_hold(&obligation)\n                     })\n@@ -574,8 +574,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut bound_spans = vec![];\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'_>, parent_pred: &ty::Predicate<'_>, obligation: &str| {\n-                            if let (ty::Param(_), ty::Predicate::Trait(p, _)) =\n-                                (&self_ty.kind, parent_pred)\n+                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n+                                (&self_ty.kind, parent_pred.kind())\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n@@ -626,9 +626,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => {}\n                         }\n                     };\n-                    let mut format_pred = |pred| {\n-                        match pred {\n-                            ty::Predicate::Projection(pred) => {\n+                    let mut format_pred = |pred: ty::Predicate<'tcx>| {\n+                        match pred.kind() {\n+                            ty::PredicateKind::Projection(pred) => {\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n-                            ty::Predicate::Trait(poly_trait_ref, _) => {\n+                            ty::PredicateKind::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.skip_binder().trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -946,11 +946,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                unsatisfied_predicates.iter().all(|(p, _)| match p {\n+                unsatisfied_predicates.iter().all(|(p, _)| match p.kind() {\n                     // Hide traits if they are present in predicates as they can be fixed without\n                     // having to implement them.\n-                    ty::Predicate::Trait(t, _) => t.def_id() == info.def_id,\n-                    ty::Predicate::Projection(p) => p.item_def_id() == info.def_id,\n+                    ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n+                    ty::PredicateKind::Projection(p) => p.item_def_id() == info.def_id,\n                     _ => false,\n                 }) && (type_is_local || info.def_id.is_local())\n                     && self"}, {"sha": "c452859414cfbdfbfd6e728f606c498c673af675", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1458,7 +1458,7 @@ fn check_fn<'a, 'tcx>(\n                 inherited.register_predicate(traits::Obligation::new(\n                     cause,\n                     param_env,\n-                    trait_ref.without_const().to_predicate(),\n+                    trait_ref.without_const().to_predicate(tcx),\n                 ));\n             }\n         }\n@@ -2223,8 +2223,8 @@ fn bounds_from_generic_predicates(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate {\n-            ty::Predicate::Trait(trait_predicate, _) => {\n+        match predicate.kind() {\n+            ty::PredicateKind::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.skip_binder().self_ty()).or_default();\n                 let def_id = trait_predicate.skip_binder().def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n@@ -2233,7 +2233,7 @@ fn bounds_from_generic_predicates(\n                     entry.push(trait_predicate.skip_binder().def_id());\n                 }\n             }\n-            ty::Predicate::Projection(projection_pred) => {\n+            ty::PredicateKind::Projection(projection_pred) => {\n                 projections.push(projection_pred);\n             }\n             _ => {}\n@@ -2769,8 +2769,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         ty::GenericPredicates {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(self.param_env.caller_bounds.iter().filter_map(\n-                |&predicate| match predicate {\n-                    ty::Predicate::Trait(ref data, _)\n+                |&predicate| match predicate.kind() {\n+                    ty::PredicateKind::Trait(ref data, _)\n                         if data.skip_binder().self_ty().is_param(index) =>\n                     {\n                         // HACK(eddyb) should get the original `Span`.\n@@ -3379,7 +3379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.register_predicate(traits::Obligation::new(\n                 cause,\n                 self.param_env,\n-                ty::Predicate::ConstEvaluatable(def_id, substs),\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx),\n             ));\n         }\n \n@@ -3428,7 +3428,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::Predicate::WellFormed(ty),\n+            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx),\n         ));\n     }\n \n@@ -3857,18 +3857,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .borrow()\n             .pending_obligations()\n             .into_iter()\n-            .filter_map(move |obligation| match obligation.predicate {\n-                ty::Predicate::Projection(ref data) => {\n+            .filter_map(move |obligation| match obligation.predicate.kind() {\n+                ty::PredicateKind::Projection(ref data) => {\n                     Some((data.to_poly_trait_ref(self.tcx), obligation))\n                 }\n-                ty::Predicate::Trait(ref data, _) => Some((data.to_poly_trait_ref(), obligation)),\n-                ty::Predicate::Subtype(..) => None,\n-                ty::Predicate::RegionOutlives(..) => None,\n-                ty::Predicate::TypeOutlives(..) => None,\n-                ty::Predicate::WellFormed(..) => None,\n-                ty::Predicate::ObjectSafe(..) => None,\n-                ty::Predicate::ConstEvaluatable(..) => None,\n-                ty::Predicate::ConstEquate(..) => None,\n+                ty::PredicateKind::Trait(ref data, _) => {\n+                    Some((data.to_poly_trait_ref(), obligation))\n+                }\n+                ty::PredicateKind::Subtype(..) => None,\n+                ty::PredicateKind::RegionOutlives(..) => None,\n+                ty::PredicateKind::TypeOutlives(..) => None,\n+                ty::PredicateKind::WellFormed(..) => None,\n+                ty::PredicateKind::ObjectSafe(..) => None,\n+                ty::PredicateKind::ConstEvaluatable(..) => None,\n+                ty::PredicateKind::ConstEquate(..) => None,\n                 // N.B., this predicate is created by breaking down a\n                 // `ClosureType: FnFoo()` predicate, where\n                 // `ClosureType` represents some `Closure`. It can't\n@@ -3877,7 +3879,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this closure yet; this is exactly why the other\n                 // code is looking for a self type of a unresolved\n                 // inference variable.\n-                ty::Predicate::ClosureKind(..) => None,\n+                ty::PredicateKind::ClosureKind(..) => None,\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n@@ -4206,7 +4208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::Predicate::Trait(predicate, _) = error.obligation.predicate {\n+            if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate.kind() {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n@@ -4253,7 +4255,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::Predicate::Trait(predicate, _) = error.obligation.predicate {\n+                        if let ty::PredicateKind::Trait(predicate, _) =\n+                            error.obligation.predicate.kind()\n+                        {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n                             for arg in path\n@@ -5322,10 +5326,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n \n                 let predicate =\n-                    ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n+                    ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         projection_ty,\n                         ty: expected,\n-                    }));\n+                    }))\n+                    .to_predicate(self.tcx);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n \n                 debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);"}, {"sha": "d5db613d9dcad33b03713fcf3d52bda98c4945db", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -425,7 +425,8 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::Predicate::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs),\n+                    ty::PredicateKind::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs)\n+                        .to_predicate(fcx.tcx),\n                 ));\n             }\n         }\n@@ -1174,8 +1175,11 @@ fn receiver_is_implemented(\n         substs: fcx.tcx.mk_substs_trait(receiver_ty, &[]),\n     };\n \n-    let obligation =\n-        traits::Obligation::new(cause, fcx.param_env, trait_ref.without_const().to_predicate());\n+    let obligation = traits::Obligation::new(\n+        cause,\n+        fcx.param_env,\n+        trait_ref.without_const().to_predicate(fcx.tcx),\n+    );\n \n     if fcx.predicate_must_hold_modulo_regions(&obligation) {\n         true"}, {"sha": "355b4fc413f424e6d1df221cc52b14acfd9533d1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -528,7 +528,7 @@ fn type_param_predicates(\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n                         extend =\n-                            Some((identity_trait_ref.without_const().to_predicate(), item.span));\n+                            Some((identity_trait_ref.without_const().to_predicate(tcx), item.span));\n                     }\n                     generics\n                 }\n@@ -548,8 +548,10 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate {\n-                ty::Predicate::Trait(ref data, _) => data.skip_binder().self_ty().is_param(index),\n+            .filter(|(predicate, _)| match predicate.kind() {\n+                ty::PredicateKind::Trait(ref data, _) => {\n+                    data.skip_binder().self_ty().is_param(index)\n+                }\n                 _ => false,\n             }),\n     );\n@@ -994,7 +996,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::Predicate::Trait(bound, _) = pred {\n+        if let ty::PredicateKind::Trait(bound, _) = pred.kind() {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1655,7 +1657,7 @@ fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n         let span = tcx.sess.source_map().guess_head_span(tcx.def_span(def_id));\n         result.predicates =\n             tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(std::iter::once((\n-                ty::TraitRef::identity(tcx, def_id).without_const().to_predicate(),\n+                ty::TraitRef::identity(tcx, def_id).without_const().to_predicate(tcx),\n                 span,\n             ))));\n     }\n@@ -1830,7 +1832,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n         predicates.push((\n-            trait_ref.to_poly_trait_ref().without_const().to_predicate(),\n+            trait_ref.to_poly_trait_ref().without_const().to_predicate(tcx),\n             tcx.def_span(def_id),\n         ));\n     }\n@@ -1853,7 +1855,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n                         let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n-                        predicates.push((outlives.to_predicate(), lt.span));\n+                        predicates.push((outlives.to_predicate(tcx), lt.span));\n                     }\n                     _ => bug!(),\n                 });\n@@ -1899,7 +1901,8 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n-                            ty::Predicate::TypeOutlives(ty::Binder::dummy(predicate)),\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(predicate))\n+                                .to_predicate(tcx),\n                             span,\n                         ));\n                     }\n@@ -1928,7 +1931,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n-                            predicates.push((ty::Predicate::TypeOutlives(pred), lifetime.span))\n+                            predicates.push((\n+                                ty::PredicateKind::TypeOutlives(pred).to_predicate(tcx),\n+                                lifetime.span,\n+                            ))\n                         }\n                     }\n                 }\n@@ -1945,7 +1951,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n \n-                    (ty::Predicate::RegionOutlives(pred), span)\n+                    (ty::PredicateKind::RegionOutlives(pred).to_predicate(icx.tcx), span)\n                 }))\n             }\n \n@@ -2116,7 +2122,7 @@ fn predicates_from_bound<'tcx>(\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![(ty::Predicate::TypeOutlives(pred), lifetime.span)]\n+            vec![(ty::PredicateKind::TypeOutlives(pred).to_predicate(astconv.tcx()), lifetime.span)]\n         }\n     }\n }"}, {"sha": "34497d12a4ecefec6a8608f34ce5efa9d41286ad", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -180,7 +180,7 @@ pub fn setup_constraining_predicates<'tcx>(\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::Predicate::Projection(ref poly_projection) = predicates[j].0 {\n+            if let ty::PredicateKind::Projection(ref poly_projection) = predicates[j].0.kind() {\n                 // Note that we can skip binder here because the impl\n                 // trait ref never contains any late-bound regions.\n                 let projection = poly_projection.skip_binder();"}, {"sha": "d30dc1b7a475e4aac235c99c62eb65e95ab1e05e", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -204,7 +204,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::Predicate::Projection(proj) = predicate {\n+        if let ty::PredicateKind::Projection(proj) = predicate.kind() {\n             let projection_ty = proj.skip_binder().projection_ty;\n             let projected_ty = proj.skip_binder().ty;\n \n@@ -368,13 +368,13 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate {\n+    match predicate.kind() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -401,19 +401,19 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: &ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate {\n-        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+    match predicate.kind() {\n+        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }\n-        ty::Predicate::Trait(_, hir::Constness::Const)\n-        | ty::Predicate::RegionOutlives(_)\n-        | ty::Predicate::TypeOutlives(_)\n-        | ty::Predicate::Projection(_)\n-        | ty::Predicate::WellFormed(_)\n-        | ty::Predicate::Subtype(_)\n-        | ty::Predicate::ObjectSafe(_)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => None,\n+        ty::PredicateKind::Trait(_, hir::Constness::Const)\n+        | ty::PredicateKind::RegionOutlives(_)\n+        | ty::PredicateKind::TypeOutlives(_)\n+        | ty::PredicateKind::Projection(_)\n+        | ty::PredicateKind::WellFormed(_)\n+        | ty::PredicateKind::Subtype(_)\n+        | ty::PredicateKind::ObjectSafe(_)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => None,\n     }\n }"}, {"sha": "5740cc224cc572f7615f73845839d82c9cf396ab", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -29,8 +29,8 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate {\n-                    ty::Predicate::TypeOutlives(predicate) => {\n+                match predicate.kind() {\n+                    ty::PredicateKind::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n                         insert_outlives_predicate(\n                             tcx,\n@@ -41,7 +41,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::RegionOutlives(predicate) => {\n+                    ty::PredicateKind::RegionOutlives(predicate) => {\n                         let OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n                         insert_outlives_predicate(\n                             tcx,\n@@ -52,14 +52,14 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::Trait(..)\n-                    | ty::Predicate::Projection(..)\n-                    | ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..)\n-                    | ty::Predicate::ConstEquate(..) => (),\n+                    ty::PredicateKind::Trait(..)\n+                    | ty::PredicateKind::Projection(..)\n+                    | ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::ObjectSafe(..)\n+                    | ty::PredicateKind::ClosureKind(..)\n+                    | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..) => (),\n                 }\n             }\n "}, {"sha": "1b2b08a2e62eec6a7351469069bfa92eb2a2bf26", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -30,9 +30,9 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|(out_pred, _)| match out_pred {\n-                            ty::Predicate::RegionOutlives(p) => p.to_string(),\n-                            ty::Predicate::TypeOutlives(p) => p.to_string(),\n+                        .map(|(out_pred, _)| match out_pred.kind() {\n+                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -82,22 +82,26 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n         .iter()\n         .map(|(&def_id, set)| {\n             let predicates = &*tcx.arena.alloc_from_iter(set.iter().filter_map(\n-                |(ty::OutlivesPredicate(kind1, region2), &span)| match kind1.unpack() {\n-                    GenericArgKind::Type(ty1) => Some((\n-                        ty::Predicate::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n-                            ty1, region2,\n-                        ))),\n-                        span,\n-                    )),\n-                    GenericArgKind::Lifetime(region1) => Some((\n-                        ty::Predicate::RegionOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n-                            region1, region2,\n-                        ))),\n-                        span,\n-                    )),\n-                    GenericArgKind::Const(_) => {\n-                        // Generic consts don't impose any constraints.\n-                        None\n+                |(ty::OutlivesPredicate(kind1, region2), &span)| {\n+                    match kind1.unpack() {\n+                        GenericArgKind::Type(ty1) => Some((\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n+                                ty::OutlivesPredicate(ty1, region2),\n+                            ))\n+                            .to_predicate(tcx),\n+                            span,\n+                        )),\n+                        GenericArgKind::Lifetime(region1) => Some((\n+                            ty::PredicateKind::RegionOutlives(ty::Binder::bind(\n+                                ty::OutlivesPredicate(region1, region2),\n+                            ))\n+                            .to_predicate(tcx),\n+                            span,\n+                        )),\n+                        GenericArgKind::Const(_) => {\n+                            // Generic consts don't impose any constraints.\n+                            None\n+                        }\n                     }\n                 },\n             ));"}, {"sha": "423160f3a9e01eea1ee1bbb54980e90e696ac0d9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -315,11 +315,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let regions = match pred {\n-            ty::Predicate::Trait(poly_trait_pred, _) => {\n+        let regions = match pred.kind() {\n+            ty::PredicateKind::Trait(poly_trait_pred, _) => {\n                 tcx.collect_referenced_late_bound_regions(&poly_trait_pred)\n             }\n-            ty::Predicate::Projection(poly_proj_pred) => {\n+            ty::PredicateKind::Projection(poly_proj_pred) => {\n                 tcx.collect_referenced_late_bound_regions(&poly_proj_pred)\n             }\n             _ => return FxHashSet::default(),\n@@ -465,8 +465,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .iter()\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n-                    || match p {\n-                        ty::Predicate::Trait(pred, _) => pred.def_id() == sized_trait,\n+                    || match p.kind() {\n+                        ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "3d2785541beead356ebe8452800deb9897fe3a31", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         match infcx.evaluate_obligation(&traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            trait_ref.without_const().to_predicate(),\n+                            trait_ref.without_const().to_predicate(infcx.tcx),\n                         )) {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no"}, {"sha": "cf1a39232bc787b98ab119cc96251a3ba30847c7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -481,20 +481,18 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        use rustc_middle::ty::Predicate;\n+        match self.kind() {\n+            ty::PredicateKind::Trait(ref pred, _) => Some(pred.clean(cx)),\n+            ty::PredicateKind::Subtype(ref pred) => Some(pred.clean(cx)),\n+            ty::PredicateKind::RegionOutlives(ref pred) => pred.clean(cx),\n+            ty::PredicateKind::TypeOutlives(ref pred) => pred.clean(cx),\n+            ty::PredicateKind::Projection(ref pred) => Some(pred.clean(cx)),\n \n-        match *self {\n-            Predicate::Trait(ref pred, _) => Some(pred.clean(cx)),\n-            Predicate::Subtype(ref pred) => Some(pred.clean(cx)),\n-            Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n-            Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n-            Predicate::Projection(ref pred) => Some(pred.clean(cx)),\n-\n-            Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => panic!(\"not user writable\"),\n+            ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -765,7 +763,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                         if let ty::Param(param) = outlives.skip_binder().0.kind {\n                             return Some(param.index);\n                         }\n-                    } else if let ty::Predicate::Projection(p) = p {\n+                    } else if let ty::PredicateKind::Projection(p) = p.kind() {\n                         if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().kind {\n                             projection = Some(p);\n                             return Some(param.index);\n@@ -1663,7 +1661,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|predicate| {\n                         let trait_ref = if let Some(tr) = predicate.to_opt_poly_trait_ref() {\n                             tr\n-                        } else if let ty::Predicate::TypeOutlives(pred) = *predicate {\n+                        } else if let ty::PredicateKind::TypeOutlives(pred) = predicate.kind() {\n                             // these should turn up at the end\n                             if let Some(r) = pred.skip_binder().1.clean(cx) {\n                                 regions.push(GenericBound::Outlives(r));\n@@ -1684,7 +1682,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n-                                if let ty::Predicate::Projection(proj) = *pred {\n+                                if let ty::PredicateKind::Projection(proj) = pred.kind() {\n                                     let proj = proj.skip_binder();\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == *trait_ref.skip_binder()"}, {"sha": "37c613f41224aad0900bff5ca30fcaeee12e47d8", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -141,7 +141,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::Predicate::Trait(ref pred, _) = *pred {\n+            if let ty::PredicateKind::Trait(ref pred, _) = pred.kind() {\n                 if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                     Some(pred.def_id())\n                 } else {"}, {"sha": "2cb3347135c1b4de185c3a1e84bd1d0f14419229", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -625,7 +625,7 @@ a {\n \tdisplay: initial;\n }\n \n-.in-band:hover > .anchor {\n+.in-band:hover > .anchor, .impl:hover > .anchor {\n \tdisplay: inline-block;\n \tposition: absolute;\n }"}, {"sha": "05f3b598ecdf4d1d672b0f4bc3641c4f0024b839", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -232,37 +232,46 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n                     did,\n                 ) => {\n-                    // We need item's parent to know if it's\n-                    // trait impl or struct/enum/etc impl\n-                    let item_parent = item_opt\n+                    // Checks if item_name belongs to `impl SomeItem`\n+                    let impl_item = cx\n+                        .tcx\n+                        .inherent_impls(did)\n+                        .iter()\n+                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n+                        .find(|item| item.ident.name == item_name);\n+                    let trait_item = item_opt\n                         .and_then(|item| self.cx.as_local_hir_id(item.def_id))\n                         .and_then(|item_hir| {\n+                            // Checks if item_name belongs to `impl SomeTrait for SomeItem`\n                             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-                            self.cx.tcx.hir().find(parent_hir)\n+                            let item_parent = self.cx.tcx.hir().find(parent_hir);\n+                            match item_parent {\n+                                Some(hir::Node::Item(hir::Item {\n+                                    kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n+                                    ..\n+                                })) => cx\n+                                    .tcx\n+                                    .associated_item_def_ids(self_ty.hir_id.owner)\n+                                    .iter()\n+                                    .map(|child| {\n+                                        let associated_item = cx.tcx.associated_item(*child);\n+                                        associated_item\n+                                    })\n+                                    .find(|child| child.ident.name == item_name),\n+                                _ => None,\n+                            }\n                         });\n-                    let item = match item_parent {\n-                        Some(hir::Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n-                            ..\n-                        })) => {\n-                            // trait impl\n-                            cx.tcx\n-                                .associated_item_def_ids(self_ty.hir_id.owner)\n-                                .iter()\n-                                .map(|child| {\n-                                    let associated_item = cx.tcx.associated_item(*child);\n-                                    associated_item\n-                                })\n-                                .find(|child| child.ident.name == item_name)\n-                        }\n-                        _ => {\n-                            // struct/enum/etc. impl\n-                            cx.tcx\n-                                .inherent_impls(did)\n-                                .iter()\n-                                .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n-                                .find(|item| item.ident.name == item_name)\n+                    let item = match (impl_item, trait_item) {\n+                        (Some(from_impl), Some(_)) => {\n+                            // Although it's ambiguous, return impl version for compat. sake.\n+                            // To handle that properly resolve() would have to support\n+                            // something like\n+                            // [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                            Some(from_impl)\n                         }\n+                        (None, Some(from_trait)) => Some(from_trait),\n+                        (Some(from_impl), None) => Some(from_impl),\n+                        _ => None,\n                     };\n \n                     if let Some(item) = item {"}, {"sha": "6ed3bfbe3e54bdcd64f54c9d89bdb4ebe39f43bc", "filename": "src/test/rustdoc/issue-72340.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-72340.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -0,0 +1,19 @@\n+#![crate_name = \"foo\"]\n+\n+pub struct Body;\n+\n+impl Body {\n+    pub fn empty() -> Self {\n+        Body\n+    }\n+\n+}\n+\n+impl Default for Body {\n+    // @has foo/struct.Body.html '//a/@href' '../foo/struct.Body.html#method.empty'\n+\n+    /// Returns [`Body::empty()`](Body::empty).\n+    fn default() -> Body {\n+        Body::empty()\n+    }\n+}"}, {"sha": "1659044a64fe1184c2eb54c936acc783b5e0e9db", "filename": "src/test/ui/issues/issue-72076.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fissues%2Fissue-72076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fissues%2Fissue-72076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72076.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -0,0 +1,6 @@\n+trait X {\n+    type S;\n+    fn f() -> Self::S {} //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "b942cf75b06a7d94be864744d8532b494b441e0a", "filename": "src/test/ui/issues/issue-72076.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fissues%2Fissue-72076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fissues%2Fissue-72076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72076.stderr?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-72076.rs:3:23\n+   |\n+LL |     fn f() -> Self::S {}\n+   |                       ^^ expected associated type, found `()`\n+   |\n+   = note: expected associated type `<Self as X>::S`\n+                    found unit type `()`\n+   = help: consider constraining the associated type `<Self as X>::S` to `()` or calling a method that returns `<Self as X>::S`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0d90e449523a3544fd1605f233815208e158e550", "filename": "src/test/ui/suggestions/trait-with-missing-associated-type-restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fsuggestions%2Ftrait-with-missing-associated-type-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fsuggestions%2Ftrait-with-missing-associated-type-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftrait-with-missing-associated-type-restriction.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -7,6 +7,7 @@ trait Trait<T = Self> {\n \n     fn func(&self) -> Self::A;\n     fn funk(&self, _: Self::A);\n+    fn funq(&self) -> Self::A {} //~ ERROR mismatched types\n }\n \n fn foo(_: impl Trait, x: impl Trait) {"}, {"sha": "e629f8f970d320d5e18617dd598f08913324250e", "filename": "src/test/ui/suggestions/trait-with-missing-associated-type-restriction.stderr", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fsuggestions%2Ftrait-with-missing-associated-type-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftest%2Fui%2Fsuggestions%2Ftrait-with-missing-associated-type-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftrait-with-missing-associated-type-restriction.stderr?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1,5 +1,19 @@\n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:13:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:10:31\n+   |\n+LL |     fn funq(&self) -> Self::A {}\n+   |                               ^^ expected associated type, found `()`\n+   |\n+   = note: expected associated type `<Self as Trait<T>>::A`\n+                    found unit type `()`\n+help: a method is available that returns `<Self as Trait<T>>::A`\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:8:5\n+   |\n+LL |     fn func(&self) -> Self::A;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `Trait::func`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:14:9\n    |\n LL |     qux(x.func())\n    |         ^^^^^^^^ expected `usize`, found associated type\n@@ -12,7 +26,7 @@ LL | fn foo(_: impl Trait, x: impl Trait<A = usize>) {\n    |                                    ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:17:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:18:9\n    |\n LL |     qux(x.func())\n    |         ^^^^^^^^ expected `usize`, found associated type\n@@ -25,7 +39,7 @@ LL | fn bar<T: Trait<A = usize>>(x: T) {\n    |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:21:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:22:9\n    |\n LL |     qux(x.func())\n    |         ^^^^^^^^ expected `usize`, found associated type\n@@ -38,25 +52,28 @@ LL | fn foo2(x: impl Trait<i32, A = usize>) {\n    |                          ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:25:12\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:26:12\n    |\n LL |     x.funk(3);\n    |            ^ expected associated type, found integer\n    |\n    = note: expected associated type `<T as Trait<i32>>::A`\n                          found type `{integer}`\n-help: a method is available that returns `<T as Trait<i32>>::A`\n+help: some methods are available that return `<T as Trait<i32>>::A`\n   --> $DIR/trait-with-missing-associated-type-restriction.rs:8:5\n    |\n LL |     fn func(&self) -> Self::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `Trait::func`\n+LL |     fn funk(&self, _: Self::A);\n+LL |     fn funq(&self) -> Self::A {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ consider calling `Trait::funq`\n help: consider constraining the associated type `<T as Trait<i32>>::A` to `{integer}`\n    |\n LL | fn bar2<T: Trait<i32, A = {integer}>>(x: T) {\n    |                     ^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:26:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:27:9\n    |\n LL |     qux(x.func())\n    |         ^^^^^^^^ expected `usize`, found associated type\n@@ -69,7 +86,7 @@ LL | fn bar2<T: Trait<i32, A = usize>>(x: T) {\n    |                     ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:30:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:31:9\n    |\n LL | fn baz<D: std::fmt::Debug, T: Trait<A = D>>(x: T) {\n    |        - this type parameter\n@@ -80,13 +97,13 @@ LL |     qux(x.func())\n            found type parameter `D`\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:34:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:35:9\n    |\n LL |     qux(x.func())\n    |         ^^^^^^^^ expected `usize`, found `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/trait-with-missing-associated-type-restriction.rs:38:9\n+  --> $DIR/trait-with-missing-associated-type-restriction.rs:39:9\n    |\n LL |     qux(x.func())\n    |         ^^^^^^^^ expected `usize`, found associated type\n@@ -98,6 +115,6 @@ help: consider constraining the associated type `<T as Trait>::A` to `usize`\n LL | fn ban<T>(x: T) where T: Trait<A = usize> {\n    |                               ^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "0a02aa7533c176e4ebd13ec012f192e379a599f0", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Opaque, Predicate::Trait, ToPolyTraitRef};\n+use rustc_middle::ty::{Opaque, PredicateKind::Trait, ToPolyTraitRef};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FutureNotSend {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n                                     infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate {\n+                                    if let Trait(trait_pred, _) = obligation.predicate.kind() {\n                                         let trait_ref = trait_pred.to_poly_trait_ref();\n                                         db.note(&*format!(\n                                             \"`{}` doesn't implement `{}`\","}, {"sha": "810a226b50d2a1e454834042404d54efce7a7639", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -18,7 +18,7 @@ use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Predicate, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n@@ -1496,8 +1496,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             if let ty::Opaque(def_id, _) = ret_ty.kind {\n                 // one of the associated types must be Self\n                 for predicate in cx.tcx.predicates_of(def_id).predicates {\n-                    match predicate {\n-                        (Predicate::Projection(poly_projection_predicate), _) => {\n+                    match predicate.0.kind() {\n+                        ty::PredicateKind::Projection(poly_projection_predicate) => {\n                             let binder = poly_projection_predicate.ty();\n                             let associated_type = binder.skip_binder();\n \n@@ -1506,7 +1506,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                                 return;\n                             }\n                         },\n-                        (_, _) => {},\n+                        _ => {},\n                     }\n                 }\n             }"}, {"sha": "60c5360054334123628cb87edd9c14ec74b60000", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.iter().copied())\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n-                if let ty::Predicate::Trait(poly_trait_ref, _) = obligation.predicate {\n+                if let ty::PredicateKind::Trait(poly_trait_ref, _) = obligation.predicate.kind() {\n                     if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_bound_vars()\n                     {\n                         return None;"}, {"sha": "f22473275c466ea3bb020f3dac3c123150e9ac6b", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9417b385145af1cabd0be8a95c65075d2fc30ff/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d9417b385145af1cabd0be8a95c65075d2fc30ff", "patch": "@@ -1299,7 +1299,7 @@ pub fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> boo\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.predicates_of(*def_id).predicates {\n-                if let ty::Predicate::Trait(ref poly_trait_predicate, _) = predicate {\n+                if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate.kind() {\n                     if must_use_attr(&cx.tcx.get_attrs(poly_trait_predicate.skip_binder().trait_ref.def_id)).is_some() {\n                         return true;\n                     }"}]}