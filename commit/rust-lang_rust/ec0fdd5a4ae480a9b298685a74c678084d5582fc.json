{"sha": "ec0fdd5a4ae480a9b298685a74c678084d5582fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMGZkZDVhNGFlNDgwYTliMjk4Njg1YTc0YzY3ODA4NGQ1NTgyZmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-25T01:55:54Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-26T00:37:14Z"}, "message": "Lay the groundwork for privacy checking in typeck", "tree": {"sha": "34686a229ce27c23bbd49e7506133560a804907e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34686a229ce27c23bbd49e7506133560a804907e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec0fdd5a4ae480a9b298685a74c678084d5582fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec0fdd5a4ae480a9b298685a74c678084d5582fc", "html_url": "https://github.com/rust-lang/rust/commit/ec0fdd5a4ae480a9b298685a74c678084d5582fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec0fdd5a4ae480a9b298685a74c678084d5582fc/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9852e2e550306a738653a5d4d16cab43454776f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9852e2e550306a738653a5d4d16cab43454776f", "html_url": "https://github.com/rust-lang/rust/commit/c9852e2e550306a738653a5d4d16cab43454776f"}], "stats": {"total": 122, "additions": 72, "deletions": 50}, "files": [{"sha": "44f588c2e9ca0e9d379d3f47f7f561cf901bd188", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=ec0fdd5a4ae480a9b298685a74c678084d5582fc", "patch": "@@ -495,6 +495,30 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// module parent is in this map.\n+    fn get_module_parent(&self, id: NodeId) -> NodeId {\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => id,\n+            Err(id) => id,\n+        }\n+    }\n+\n+    pub fn private_item_is_visible_from(&self, item: NodeId, block: NodeId) -> bool {\n+        // A private item is visible from everything in its nearest module parent.\n+        let visibility = self.get_module_parent(item);\n+        let mut block_ancestor = self.get_module_parent(block);\n+        loop {\n+            if block_ancestor == visibility { return true }\n+            let block_ancestor_parent = self.get_module_parent(block_ancestor);\n+            if block_ancestor_parent == block_ancestor { return false }\n+            block_ancestor = block_ancestor_parent;\n+        }\n+    }\n+\n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n     /// and associated types probably shouldn't, for example. Behaviour in this"}, {"sha": "c0a5d27a506ff7aae9d955acf73ab92190237c2a", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=ec0fdd5a4ae480a9b298685a74c678084d5582fc", "patch": "@@ -152,4 +152,29 @@ impl Def {\n             _ => None\n         }\n     }\n+\n+    pub fn kind_name(&self) -> &'static str {\n+        match *self {\n+            Def::Fn(..) => \"function\",\n+            Def::Mod(..) => \"module\",\n+            Def::ForeignMod(..) => \"foreign module\",\n+            Def::Static(..) => \"static\",\n+            Def::Variant(..) => \"variant\",\n+            Def::Enum(..) => \"enum\",\n+            Def::TyAlias(..) => \"type\",\n+            Def::AssociatedTy(..) => \"associated type\",\n+            Def::Struct(..) => \"struct\",\n+            Def::Trait(..) => \"trait\",\n+            Def::Method(..) => \"method\",\n+            Def::Const(..) => \"const\",\n+            Def::AssociatedConst(..) => \"associated const\",\n+            Def::TyParam(..) => \"type parameter\",\n+            Def::PrimTy(..) => \"builtin type\",\n+            Def::Local(..) => \"local variable\",\n+            Def::Upvar(..) => \"closure capture\",\n+            Def::Label(..) => \"label\",\n+            Def::SelfTy(..) => \"self type\",\n+            Def::Err => \"unresolved item\",\n+        }\n+    }\n }"}, {"sha": "b6e8a670182330837af4f39d4588b95a9f8834a9", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=ec0fdd5a4ae480a9b298685a74c678084d5582fc", "patch": "@@ -173,6 +173,14 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n+    pub fn def(&self) -> Def {\n+        match *self {\n+            ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n+            MethodTraitItem(ref method) => Def::Method(method.def_id),\n+            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.container.id(), ty.def_id),\n+        }\n+    }\n+\n     pub fn def_id(&self) -> DefId {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.def_id,"}, {"sha": "9f0afb7b98a59d22a19acd835ae6c66fb792c840", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ec0fdd5a4ae480a9b298685a74c678084d5582fc", "patch": "@@ -692,32 +692,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = *self.parents.get(&id).unwrap();\n-        debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n-\n-        // After finding `did`'s closest private member, we roll ourselves back\n-        // to see if this private member's parent is anywhere in our ancestry.\n-        // By the privacy rules, we can access all of our ancestor's private\n-        // members, so that's why we test the parent, and not the did itself.\n-        let mut cur = self.curitem;\n-        loop {\n-            debug!(\"privacy - questioning {}, {}\", self.nodestr(cur), cur);\n-            match cur {\n-                // If the relevant parent is in our history, then we're allowed\n-                // to look inside any of our ancestor's immediate private items,\n-                // so this access is valid.\n-                x if x == parent => return true,\n-\n-                // If we've reached the root, then we couldn't access this item\n-                // in the first place\n-                ast::DUMMY_NODE_ID => return false,\n-\n-                // Keep going up\n-                _ => {}\n-            }\n-\n-            cur = *self.parents.get(&cur).unwrap();\n-        }\n+        self.tcx.map.private_item_is_visible_from(id, self.curitem)\n     }\n \n     fn report_error(&self, result: CheckResult) -> bool {\n@@ -835,7 +810,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             UnnamedField(idx) => &v.fields[idx]\n         };\n-        if field.vis == hir::Public || self.local_private_accessible(field.did) {\n+        if field.vis == hir::Public || self.local_private_accessible(def.did) {\n             return;\n         }\n \n@@ -945,19 +920,9 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // def map is not. Therefore the names we work out below will not always\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n-        match path_res.full_def() {\n-            Def::Fn(..) => ck(\"function\"),\n-            Def::Static(..) => ck(\"static\"),\n-            Def::Const(..) => ck(\"const\"),\n-            Def::AssociatedConst(..) => ck(\"associated const\"),\n-            Def::Variant(..) => ck(\"variant\"),\n-            Def::TyAlias(..) => ck(\"type\"),\n-            Def::Enum(..) => ck(\"enum\"),\n-            Def::Trait(..) => ck(\"trait\"),\n-            Def::Struct(..) => ck(\"struct\"),\n-            Def::Method(..) => ck(\"method\"),\n-            Def::Mod(..) => ck(\"module\"),\n-            _ => {}\n+        let def = path_res.full_def();\n+        if def != Def::Err {\n+            ck(def.kind_name());\n         }\n     }\n \n@@ -1036,7 +1001,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.local_private_accessible(f.did)\n+                        f.vis != hir::Public && !self.local_private_accessible(def.did)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,"}, {"sha": "f680607eb99580f0d7853e3a21d086a2690bcf70", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ec0fdd5a4ae480a9b298685a74c678084d5582fc", "patch": "@@ -338,20 +338,13 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    let def_id = pick.item.def_id();\n+    let def_result = pick.item.def();\n     let mut lp = LastMod(AllPublic);\n     if let probe::InherentImplPick = pick.kind {\n         if pick.item.vis() != hir::Public {\n-            lp = LastMod(DependsOn(def_id));\n+            lp = LastMod(DependsOn(def_result.def_id()));\n         }\n     }\n-    let def_result = match pick.item {\n-        ty::ImplOrTraitItem::MethodTraitItem(..) => Def::Method(def_id),\n-        ty::ImplOrTraitItem::ConstTraitItem(..) => Def::AssociatedConst(def_id),\n-        ty::ImplOrTraitItem::TypeTraitItem(..) => {\n-            fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n-        }\n-    };\n     Ok((def_result, lp))\n }\n "}, {"sha": "9170c00a261d636fac4081fce2c89753b6ead397", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec0fdd5a4ae480a9b298685a74c678084d5582fc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ec0fdd5a4ae480a9b298685a74c678084d5582fc", "patch": "@@ -2022,6 +2022,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n+\n+    fn private_item_is_visible(&self, def_id: DefId) -> bool {\n+        match self.tcx().map.as_local_node_id(def_id) {\n+            Some(node_id) => self.tcx().map.private_item_is_visible_from(node_id, self.body_id),\n+            None => false, // Private items from other crates are never visible\n+        }\n+    }\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {"}]}