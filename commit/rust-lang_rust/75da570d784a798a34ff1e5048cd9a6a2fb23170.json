{"sha": "75da570d784a798a34ff1e5048cd9a6a2fb23170", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZGE1NzBkNzg0YTc5OGEzNGZmMWU1MDQ4Y2Q5YTZhMmZiMjMxNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-14T12:58:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-14T12:58:58Z"}, "message": "Auto merge of #83640 - bjorn3:shared_metadata_reader, r=nagisa\n\nUse the object crate for metadata reading\n\nThis allows sharing the metadata reader between cg_llvm, cg_clif and other codegen backends.\n\nThis is not currently useful for rlib reading with cg_spirv ([rust-gpu](https://github.com/EmbarkStudios/rust-gpu/)) as it uses tar rather than ar as .rlib format, but it is useful for dylib reading required for loading proc macros. (cc `@eddyb)`\n\nThe object crate is already trusted as dependency of libstd through backtrace. As far as I know it supports reading all object file formats used by targets for which we support rust dylibs with crate metadata, but I am not certain. If this happens to not be the case, I could keep using LLVM for reading dylib metadata.\n\nMarked as WIP for a perf run and as it is based on #83637.", "tree": {"sha": "7e2ffecffbd250a725092db3d0bc5190c52b4fdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e2ffecffbd250a725092db3d0bc5190c52b4fdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75da570d784a798a34ff1e5048cd9a6a2fb23170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75da570d784a798a34ff1e5048cd9a6a2fb23170", "html_url": "https://github.com/rust-lang/rust/commit/75da570d784a798a34ff1e5048cd9a6a2fb23170", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75da570d784a798a34ff1e5048cd9a6a2fb23170/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a4d14c7edba21bba14df00b9e6e4a111dfc6f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a4d14c7edba21bba14df00b9e6e4a111dfc6f2", "html_url": "https://github.com/rust-lang/rust/commit/36a4d14c7edba21bba14df00b9e6e4a111dfc6f2"}, {"sha": "6381aaf8ae2df01cdb70b6f3123153cf4f1e03cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6381aaf8ae2df01cdb70b6f3123153cf4f1e03cd", "html_url": "https://github.com/rust-lang/rust/commit/6381aaf8ae2df01cdb70b6f3123153cf4f1e03cd"}], "stats": {"total": 293, "additions": 98, "deletions": 195}, "files": [{"sha": "e92b7287f3eb60a5c76680605fb08b5718f3e3a1", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -3695,6 +3695,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n+ \"object\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\","}, {"sha": "ff6e1856059af0066f85b7f8023f9ec5e03990c8", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -165,7 +165,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     }\n \n     fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n-        Box::new(crate::metadata::CraneliftMetadataLoader)\n+        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n     }\n \n     fn provide(&self, _providers: &mut Providers) {}"}, {"sha": "ab238244d68d504c983bfff1ffea366fd6eb7c5f", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -1,73 +1,9 @@\n-//! Reading and writing of the rustc metadata for rlibs and dylibs\n+//! Writing of the rustc metadata for dylibs\n \n-use std::fs::File;\n-use std::path::Path;\n-\n-use rustc_codegen_ssa::METADATA_FILENAME;\n-use rustc_data_structures::memmap::Mmap;\n-use rustc_data_structures::owning_ref::OwningRef;\n-use rustc_data_structures::rustc_erase_owner;\n-use rustc_data_structures::sync::MetadataRef;\n-use rustc_middle::middle::cstore::MetadataLoader;\n use rustc_middle::ty::TyCtxt;\n-use rustc_target::spec::Target;\n \n use crate::backend::WriteMetadata;\n \n-/// The metadata loader used by cg_clif.\n-///\n-/// The metadata is stored in the same format as cg_llvm.\n-///\n-/// # Metadata location\n-///\n-/// <dl>\n-/// <dt>rlib</dt>\n-/// <dd>The metadata can be found in the `lib.rmeta` file inside of the ar archive.</dd>\n-/// <dt>dylib</dt>\n-/// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n-/// </dl>\n-pub(crate) struct CraneliftMetadataLoader;\n-\n-fn load_metadata_with(\n-    path: &Path,\n-    f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n-) -> Result<MetadataRef, String> {\n-    let file = File::open(path).map_err(|e| format!(\"{:?}\", e))?;\n-    let data = unsafe { Mmap::map(file) }.map_err(|e| format!(\"{:?}\", e))?;\n-    let metadata = OwningRef::new(data).try_map(f)?;\n-    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n-}\n-\n-impl MetadataLoader for CraneliftMetadataLoader {\n-    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        load_metadata_with(path, |data| {\n-            let archive = object::read::archive::ArchiveFile::parse(&*data)\n-                .map_err(|e| format!(\"{:?}\", e))?;\n-\n-            for entry_result in archive.members() {\n-                let entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n-                if entry.name() == METADATA_FILENAME.as_bytes() {\n-                    return Ok(entry.data());\n-                }\n-            }\n-\n-            Err(\"couldn't find metadata entry\".to_string())\n-        })\n-    }\n-\n-    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        use object::{Object, ObjectSection};\n-\n-        load_metadata_with(path, |data| {\n-            let file = object::File::parse(&data).map_err(|e| format!(\"parse: {:?}\", e))?;\n-            file.section_by_name(\".rustc\")\n-                .ok_or(\"no .rustc section\")?\n-                .data()\n-                .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))\n-        })\n-    }\n-}\n-\n // Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n pub(crate) fn write_metadata<O: WriteMetadata>(tcx: TyCtxt<'_>, object: &mut O) {\n     use snap::write::FrameEncoder;"}, {"sha": "893c909b204166eb09dd226a830bb0197ae2fdbe", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -18,7 +18,6 @@ use crate::builder::Builder;\n use crate::common;\n use crate::context::CodegenCx;\n use crate::llvm;\n-use crate::metadata;\n use crate::value::Value;\n \n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -47,6 +46,22 @@ pub fn write_compressed_metadata<'tcx>(\n     use snap::write::FrameEncoder;\n     use std::io::Write;\n \n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8\u00a0characters\n+    //\n+    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, see\n+    // https://github.com/llvm/llvm-project/blob/llvmorg-12.0.0/lld/COFF/Writer.cpp#L1190-L1197\n+    let section_name = if tcx.sess.target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" };\n+\n     let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n     let mut compressed = tcx.metadata_encoding_version();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n@@ -59,7 +74,6 @@ pub fn write_compressed_metadata<'tcx>(\n         unsafe { llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr()) };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name = metadata::metadata_section_name(&tcx.sess.target);\n         let name = SmallCStr::new(section_name);\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n "}, {"sha": "329458773ffaff3fbf0afca8815d19a348a9fef8", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -69,7 +69,6 @@ pub mod llvm {\n }\n \n mod llvm_util;\n-mod metadata;\n mod mono_item;\n mod type_;\n mod type_of;\n@@ -251,7 +250,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n-        Box::new(metadata::LlvmMetadataLoader)\n+        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n     }\n \n     fn provide(&self, _providers: &mut ty::query::Providers) {}"}, {"sha": "decc1e1f70007e2223f54d0d4d853b21d5c43120", "filename": "compiler/rustc_codegen_llvm/src/metadata.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/36a4d14c7edba21bba14df00b9e6e4a111dfc6f2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a4d14c7edba21bba14df00b9e6e4a111dfc6f2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs?ref=36a4d14c7edba21bba14df00b9e6e4a111dfc6f2", "patch": "@@ -1,112 +0,0 @@\n-use crate::llvm;\n-use crate::llvm::archive_ro::ArchiveRO;\n-use crate::llvm::{mk_section_iter, False, ObjectFile};\n-use rustc_middle::middle::cstore::MetadataLoader;\n-use rustc_target::spec::Target;\n-\n-use rustc_codegen_ssa::METADATA_FILENAME;\n-use rustc_data_structures::owning_ref::OwningRef;\n-use rustc_data_structures::rustc_erase_owner;\n-use tracing::debug;\n-\n-use rustc_fs_util::path_to_c_string;\n-use std::path::Path;\n-use std::slice;\n-\n-pub use rustc_data_structures::sync::MetadataRef;\n-\n-pub struct LlvmMetadataLoader;\n-\n-impl MetadataLoader for LlvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n-        // internally to read the file. We also avoid even using a memcpy by\n-        // just keeping the archive along while the metadata is in use.\n-        let archive =\n-            ArchiveRO::open(filename).map(|ar| OwningRef::new(Box::new(ar))).map_err(|e| {\n-                debug!(\"llvm didn't like `{}`: {}\", filename.display(), e);\n-                format!(\"failed to read rlib metadata in '{}': {}\", filename.display(), e)\n-            })?;\n-        let buf: OwningRef<_, [u8]> = archive.try_map(|ar| {\n-            ar.iter()\n-                .filter_map(|s| s.ok())\n-                .find(|sect| sect.name() == Some(METADATA_FILENAME))\n-                .map(|s| s.data())\n-                .ok_or_else(|| {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    format!(\"failed to read rlib metadata: '{}'\", filename.display())\n-                })\n-        })?;\n-        Ok(rustc_erase_owner!(buf))\n-    }\n-\n-    fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        unsafe {\n-            let buf = path_to_c_string(filename);\n-            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr())\n-                .ok_or_else(|| format!(\"error reading library: '{}'\", filename.display()))?;\n-            let of =\n-                ObjectFile::new(mb).map(|of| OwningRef::new(Box::new(of))).ok_or_else(|| {\n-                    format!(\"provided path not an object file: '{}'\", filename.display())\n-                })?;\n-            let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n-            Ok(rustc_erase_owner!(buf))\n-        }\n-    }\n-}\n-\n-fn search_meta_section<'a>(\n-    of: &'a ObjectFile,\n-    target: &Target,\n-    filename: &Path,\n-) -> Result<&'a [u8], String> {\n-    unsafe {\n-        let si = mk_section_iter(of.llof);\n-        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-            let mut name_buf = None;\n-            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = name_buf.map_or_else(\n-                String::new, // We got a null ptr, ignore `name_len`.\n-                |buf| {\n-                    String::from_utf8(\n-                        slice::from_raw_parts(buf.as_ptr() as *const u8, name_len as usize)\n-                            .to_vec(),\n-                    )\n-                    .unwrap()\n-                },\n-            );\n-            debug!(\"get_metadata_section: name {}\", name);\n-            if read_metadata_section_name(target) == name {\n-                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n-                // The buffer is valid while the object file is around\n-                let buf: &'a [u8] = slice::from_raw_parts(cbuf as *const u8, csz);\n-                return Ok(buf);\n-            }\n-            llvm::LLVMMoveToNextSection(si.llsi);\n-        }\n-    }\n-    Err(format!(\"metadata not found: '{}'\", filename.display()))\n-}\n-\n-pub fn metadata_section_name(target: &Target) -> &'static str {\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8\u00a0characters\n-    //\n-    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, that's another good question...\n-\n-    if target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" }\n-}\n-\n-fn read_metadata_section_name(_target: &Target) -> &'static str {\n-    \".rustc\"\n-}"}, {"sha": "68f40d5f8639593c86dd35f092ad3c1895f80463", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -33,3 +33,8 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n+\n+[dependencies.object]\n+version = \"0.22.0\"\n+default-features = false\n+features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\"]"}, {"sha": "37d1f8ecc8328367aaac17c6f3d4568bc0a70233", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -0,0 +1,71 @@\n+//! Reading of the rustc metadata for rlibs and dylibs\n+\n+use std::fs::File;\n+use std::path::Path;\n+\n+use rustc_data_structures::memmap::Mmap;\n+use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::rustc_erase_owner;\n+use rustc_data_structures::sync::MetadataRef;\n+use rustc_middle::middle::cstore::MetadataLoader;\n+use rustc_target::spec::Target;\n+\n+use crate::METADATA_FILENAME;\n+\n+/// The default metadata loader. This is used by cg_llvm and cg_clif.\n+///\n+/// # Metadata location\n+///\n+/// <dl>\n+/// <dt>rlib</dt>\n+/// <dd>The metadata can be found in the `lib.rmeta` file inside of the ar archive.</dd>\n+/// <dt>dylib</dt>\n+/// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n+/// </dl>\n+pub struct DefaultMetadataLoader;\n+\n+fn load_metadata_with(\n+    path: &Path,\n+    f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n+) -> Result<MetadataRef, String> {\n+    let file =\n+        File::open(path).map_err(|e| format!(\"failed to open file '{}': {}\", path.display(), e))?;\n+    let data = unsafe { Mmap::map(file) }\n+        .map_err(|e| format!(\"failed to mmap file '{}': {}\", path.display(), e))?;\n+    let metadata = OwningRef::new(data).try_map(f)?;\n+    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n+}\n+\n+impl MetadataLoader for DefaultMetadataLoader {\n+    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n+        load_metadata_with(path, |data| {\n+            let archive = object::read::archive::ArchiveFile::parse(&*data)\n+                .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n+\n+            for entry_result in archive.members() {\n+                let entry = entry_result\n+                    .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n+                if entry.name() == METADATA_FILENAME.as_bytes() {\n+                    return Ok(entry.data());\n+                }\n+            }\n+\n+            Err(format!(\"metadata not found in rlib '{}'\", path.display()))\n+        })\n+    }\n+\n+    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n+        use object::{Object, ObjectSection};\n+\n+        load_metadata_with(path, |data| {\n+            let file = object::File::parse(&data)\n+                .map_err(|e| format!(\"failed to parse dylib '{}': {}\", path.display(), e))?;\n+            file.section_by_name(\".rustc\")\n+                .ok_or_else(|| format!(\"no .rustc section in '{}'\", path.display()))?\n+                .data()\n+                .map_err(|e| {\n+                    format!(\"failed to read .rustc section in '{}': {}\", path.display(), e)\n+                })\n+        })\n+    }\n+}"}, {"sha": "d11ed54eb209f969ffe88f1709379ab7b6fac785", "filename": "compiler/rustc_codegen_ssa/src/back/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -3,6 +3,7 @@ pub mod command;\n pub mod link;\n pub mod linker;\n pub mod lto;\n+pub mod metadata;\n pub mod rpath;\n pub mod symbol_export;\n pub mod write;"}, {"sha": "a9e99d3c10ecc6b0614e4a5b6d5dad90f0dcc358", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75da570d784a798a34ff1e5048cd9a6a2fb23170/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75da570d784a798a34ff1e5048cd9a6a2fb23170/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=75da570d784a798a34ff1e5048cd9a6a2fb23170", "patch": "@@ -28,23 +28,11 @@ use rustc_target::spec::Target;\n use std::any::Any;\n use std::path::Path;\n \n-pub struct NoLlvmMetadataLoader;\n-\n-impl MetadataLoader for NoLlvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        unreachable!(\"some_crate.rs shouldn't depend on any external crates\");\n-    }\n-\n-    fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        unreachable!(\"some_crate.rs shouldn't depend on any external crates\");\n-    }\n-}\n-\n struct TheBackend;\n \n impl CodegenBackend for TheBackend {\n     fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n-        Box::new(NoLlvmMetadataLoader)\n+        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n     }\n \n     fn provide(&self, providers: &mut Providers) {}"}]}