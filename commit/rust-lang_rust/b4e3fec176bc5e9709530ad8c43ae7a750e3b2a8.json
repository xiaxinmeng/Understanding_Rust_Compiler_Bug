{"sha": "b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8", "node_id": "C_kwDOAAsO6NoAKGI0ZTNmZWMxNzZiYzVlOTcwOTUzMGFkOGM0M2FlN2E3NTBlM2IyYTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T10:01:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T10:01:11Z"}, "message": "Auto merge of #14895 - lowr:fix/goto-type-def-tokens-in-tt, r=Veykril\n\nfix: don't try determining type of token inside macro calls\n\nWhen we're requested `Go to Type Definition`, we first downmap the token in question to tokens in every macro call expansion involved, and then determine the type of those mapped tokens by looking for the nearest ancestor node that is either expression or pattern (or a few others). This procedure has one flaw: When the downmapped token is inside another macro call, the nearest ancestor node to retrieve the type of is *that* macro call. That's not what we should return in general and therefore we should disregard it.\n\nNotably, now that we expand built-in `format_arg!` and its family macros, we're always returning [`Arguments`] when one `Go to Type Definition` at `dbg!(variable$0)` along with the actual type of `variable` without this patch.\n\n[`Arguments`]: https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html", "tree": {"sha": "9a222f7f5e7c17407f558156a7527a894cbbdbfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a222f7f5e7c17407f558156a7527a894cbbdbfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8", "html_url": "https://github.com/rust-lang/rust/commit/b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "615aaa47510fae3a95d95cbd8b607c3695878161", "url": "https://api.github.com/repos/rust-lang/rust/commits/615aaa47510fae3a95d95cbd8b607c3695878161", "html_url": "https://github.com/rust-lang/rust/commit/615aaa47510fae3a95d95cbd8b607c3695878161"}, {"sha": "397c8e51480cc6c350433deefd8548e1455506c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/397c8e51480cc6c350433deefd8548e1455506c6", "html_url": "https://github.com/rust-lang/rust/commit/397c8e51480cc6c350433deefd8548e1455506c6"}], "stats": {"total": 87, "additions": 61, "deletions": 26}, "files": [{"sha": "6048990f7492c5151d77c972e14948d1391d9b5d", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=b4e3fec176bc5e9709530ad8c43ae7a750e3b2a8", "patch": "@@ -38,32 +38,41 @@ pub(crate) fn goto_type_definition(\n     };\n     let range = token.text_range();\n     sema.descend_into_macros(token)\n-        .iter()\n+        .into_iter()\n         .filter_map(|token| {\n-            let ty = sema.token_ancestors_with_macros(token.clone()).find_map(|node| {\n-                let ty = match_ast! {\n-                    match node {\n-                        ast::Expr(it) => sema.type_of_expr(&it)?.original,\n-                        ast::Pat(it) => sema.type_of_pat(&it)?.original,\n-                        ast::SelfParam(it) => sema.type_of_self(&it)?,\n-                        ast::Type(it) => sema.resolve_type(&it)?,\n-                        ast::RecordField(it) => sema.to_def(&it).map(|d| d.ty(db.upcast()))?,\n-                        // can't match on RecordExprField directly as `ast::Expr` will match an iteration too early otherwise\n-                        ast::NameRef(it) => {\n-                            if let Some(record_field) = ast::RecordExprField::for_name_ref(&it) {\n-                                let (_, _, ty) = sema.resolve_record_field(&record_field)?;\n-                                ty\n-                            } else {\n-                                let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n-                                sema.resolve_record_pat_field(&record_field)?.1\n-                            }\n-                        },\n-                        _ => return None,\n-                    }\n-                };\n+            let ty = sema\n+                .token_ancestors_with_macros(token)\n+                // When `token` is within a macro call, we can't determine its type. Don't continue\n+                // this traversal because otherwise we'll end up returning the type of *that* macro\n+                // call, which is not what we want in general.\n+                //\n+                // Macro calls always wrap `TokenTree`s, so it's sufficient and efficient to test\n+                // if the current node is a `TokenTree`.\n+                .take_while(|node| !ast::TokenTree::can_cast(node.kind()))\n+                .find_map(|node| {\n+                    let ty = match_ast! {\n+                        match node {\n+                            ast::Expr(it) => sema.type_of_expr(&it)?.original,\n+                            ast::Pat(it) => sema.type_of_pat(&it)?.original,\n+                            ast::SelfParam(it) => sema.type_of_self(&it)?,\n+                            ast::Type(it) => sema.resolve_type(&it)?,\n+                            ast::RecordField(it) => sema.to_def(&it)?.ty(db.upcast()),\n+                            // can't match on RecordExprField directly as `ast::Expr` will match an iteration too early otherwise\n+                            ast::NameRef(it) => {\n+                                if let Some(record_field) = ast::RecordExprField::for_name_ref(&it) {\n+                                    let (_, _, ty) = sema.resolve_record_field(&record_field)?;\n+                                    ty\n+                                } else {\n+                                    let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n+                                    sema.resolve_record_pat_field(&record_field)?.1\n+                                }\n+                            },\n+                            _ => return None,\n+                        }\n+                    };\n \n-                Some(ty)\n-            });\n+                    Some(ty)\n+                });\n             ty\n         })\n         .for_each(|ty| {\n@@ -94,7 +103,7 @@ mod tests {\n     fn check(ra_fixture: &str) {\n         let (analysis, position, expected) = fixture::annotations(ra_fixture);\n         let navs = analysis.goto_type_definition(position).unwrap().unwrap().info;\n-        assert_ne!(navs.len(), 0);\n+        assert!(!navs.is_empty(), \"navigation is empty\");\n \n         let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n         let navs = navs\n@@ -104,7 +113,7 @@ mod tests {\n             .collect::<Vec<_>>();\n         let expected = expected\n             .into_iter()\n-            .map(|(FileRange { file_id, range }, _)| FileRange { file_id, range })\n+            .map(|(file_range, _)| file_range)\n             .sorted_by_key(cmp)\n             .collect::<Vec<_>>();\n         assert_eq!(expected, navs);\n@@ -198,6 +207,32 @@ id! {\n         );\n     }\n \n+    #[test]\n+    fn dont_collect_type_from_token_in_macro_call() {\n+        check(\n+            r#\"\n+struct DontCollectMe;\n+struct S;\n+     //^\n+\n+macro_rules! inner {\n+    ($t:tt) => { DontCollectMe }\n+}\n+macro_rules! m {\n+    ($t:ident) => {\n+        match $t {\n+            _ => inner!($t);\n+        }\n+    }\n+}\n+\n+fn test() {\n+    m!($0S);\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn goto_type_definition_for_param() {\n         check("}]}