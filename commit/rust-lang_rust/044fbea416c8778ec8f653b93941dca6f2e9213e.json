{"sha": "044fbea416c8778ec8f653b93941dca6f2e9213e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NGZiZWE0MTZjODc3OGVjOGY2NTNiOTM5NDFkY2E2ZjJlOTIxM2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-14T19:01:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-14T19:03:28Z"}, "message": "Adapt callee to avoid intermediary for move/copy arguments (cc #3402)", "tree": {"sha": "0fce008bd25b7d137873a205eb08dd077c1b6c2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fce008bd25b7d137873a205eb08dd077c1b6c2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044fbea416c8778ec8f653b93941dca6f2e9213e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044fbea416c8778ec8f653b93941dca6f2e9213e", "html_url": "https://github.com/rust-lang/rust/commit/044fbea416c8778ec8f653b93941dca6f2e9213e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044fbea416c8778ec8f653b93941dca6f2e9213e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbfc6f89455b207b65972181ae4401941215b6a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbfc6f89455b207b65972181ae4401941215b6a9", "html_url": "https://github.com/rust-lang/rust/commit/bbfc6f89455b207b65972181ae4401941215b6a9"}], "stats": {"total": 168, "additions": 88, "deletions": 80}, "files": [{"sha": "b812b3deb37e0009579ea2759d3738f6d1640c2b", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 88, "deletions": 80, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/044fbea416c8778ec8f653b93941dca6f2e9213e/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044fbea416c8778ec8f653b93941dca6f2e9213e/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=044fbea416c8778ec8f653b93941dca6f2e9213e", "patch": "@@ -484,6 +484,7 @@ fn trans_arg_expr(bcx: block,\n {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n \n     debug!(\"trans_arg_expr(formal_ty=(%?,%s), arg_expr=%s, \\\n             ret_flag=%?)\",\n@@ -492,97 +493,104 @@ fn trans_arg_expr(bcx: block,\n            ret_flag.map(|v| bcx.val_str(v)));\n     let _indenter = indenter();\n \n-    // translate the arg expr to a datum\n-    let arg_datumblock = match ret_flag {\n-        None => expr::trans_to_datum(bcx, arg_expr),\n-\n-        // If there is a ret_flag, this *must* be a loop body\n-        Some(_) => {\n-            match arg_expr.node {\n-                ast::expr_loop_body(\n-                    blk @ @{node:ast::expr_fn_block(decl, body, cap), _}) =>\n-                {\n-                    let scratch_ty = expr_ty(bcx, blk);\n-                    let scratch = alloc_ty(bcx, scratch_ty);\n-                    let arg_ty = expr_ty(bcx, arg_expr);\n-                    let proto = ty::ty_fn_proto(arg_ty);\n-                    let bcx = closure::trans_expr_fn(\n-                        bcx, proto, decl, body, blk.id,\n-                        cap, Some(ret_flag), expr::SaveIn(scratch));\n-                    DatumBlock {bcx: bcx,\n-                                datum: Datum {val: scratch,\n-                                              ty: scratch_ty,\n-                                              mode: ByRef,\n-                                              source: FromRvalue}}\n-                }\n-                _ => {\n-                    bcx.sess().impossible_case(\n-                        arg_expr.span, ~\"ret_flag with non-loop-\\\n-                                         body expr\");\n-                }\n-            }\n-        }\n-    };\n-    let mut arg_datum = arg_datumblock.datum;\n-    let mut bcx = arg_datumblock.bcx;\n-\n-    debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n-\n     // finally, deal with the various modes\n     let arg_mode = ty::resolved_mode(ccx.tcx, formal_ty.mode);\n     let mut val;\n-    if ty::type_is_bot(arg_datum.ty) {\n-        // For values of type _|_, we generate an\n-        // \"undef\" value, as such a value should never\n-        // be inspected. It's important for the value\n-        // to have type lldestty (the callee's expected type).\n-        let llformal_ty = type_of::type_of(ccx, formal_ty.ty);\n-        val = llvm::LLVMGetUndef(llformal_ty);\n-    } else {\n-        match arg_mode {\n-            ast::by_ref | ast::by_mutbl_ref => {\n-                val = arg_datum.to_ref_llval(bcx);\n-            }\n+    match arg_mode {\n+        ast::by_ref | ast::by_mutbl_ref => {\n+            let datum = unpack_datum!(bcx, {\n+                trans_arg_expr_to_datum(bcx, arg_expr, ret_flag)\n+            });\n+            val = datum.to_ref_llval(bcx);\n+        }\n \n-            ast::by_val => {\n-                // NB: avoid running the take glue.\n-                val = arg_datum.to_value_llval(bcx);\n-            }\n+        ast::by_val => {\n+            let datum = unpack_datum!(bcx, {\n+                trans_arg_expr_to_datum(bcx, arg_expr, ret_flag)\n+            });\n+            val = datum.to_value_llval(bcx);\n+        }\n \n-            ast::by_copy | ast::by_move => {\n-                let scratch = scratch_datum(bcx, arg_datum.ty, false);\n+        ast::by_copy | ast::by_move => {\n+            let scratch = scratch_datum(bcx, formal_ty.ty, false);\n+            bcx = trans_arg_expr_into(bcx, arg_expr, ret_flag,\n+                                      expr::SaveIn(scratch.val));\n+\n+            // Technically, ownership of val passes to the callee.\n+            // However, we must cleanup should we fail before the\n+            // callee is actually invoked.\n+            scratch.add_clean(bcx);\n+            vec::push(*temp_cleanups, scratch.val);\n+            val = scratch.val;\n+        }\n+    }\n \n-                if arg_mode == ast::by_move {\n-                    // NDM---Doesn't seem like this should be necessary\n-                    if !arg_datum.store_will_move() {\n-                        bcx.sess().span_bug(\n-                            arg_expr.span,\n-                            fmt!(\"move mode but datum will not store: %s\",\n-                                 arg_datum.to_str(bcx.ccx())));\n-                    }\n-                }\n+    /*\n+    if formal_ty.ty != arg_datum.ty {\n+        // this could happen due to e.g. subtyping\n+        let llformal_ty = type_of::type_of_explicit_arg(ccx, formal_ty);\n+        debug!(\"casting actual type (%s) to match formal (%s)\",\n+               bcx.val_str(val), bcx.llty_str(llformal_ty));\n+        val = PointerCast(bcx, val, llformal_ty);\n+    }\n+    */\n \n-                arg_datum.store_to_datum(bcx, INIT, scratch);\n+    debug!(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n+    return rslt(bcx, val);\n \n-                // Technically, ownership of val passes to the callee.\n-                // However, we must cleanup should we fail before the\n-                // callee is actually invoked.\n-                scratch.add_clean(bcx);\n-                vec::push(*temp_cleanups, scratch.val);\n-                val = scratch.val;\n-          }\n-        }\n+    fn trans_arg_expr_to_datum(bcx: block,\n+                               arg_expr: @ast::expr,\n+                               ret_flag: Option<ValueRef>) -> DatumBlock {\n+        match ret_flag {\n+            None => {\n+                expr::trans_to_datum(bcx, arg_expr)\n+            }\n \n-        if formal_ty.ty != arg_datum.ty {\n-            // this could happen due to e.g. subtyping\n-            let llformal_ty = type_of::type_of_explicit_arg(ccx, formal_ty);\n-            debug!(\"casting actual type (%s) to match formal (%s)\",\n-                   bcx.val_str(val), bcx.llty_str(llformal_ty));\n-            val = PointerCast(bcx, val, llformal_ty);\n+            // If there is a ret_flag, this *must* be a loop body\n+            Some(_) => {\n+                match arg_expr.node {\n+                    ast::expr_loop_body(\n+                        blk @ @{node:ast::expr_fn_block(decl, body,\n+                                                        cap), _}) =>\n+                    {\n+                        let scratch_ty = expr_ty(bcx, blk);\n+                        let scratch = alloc_ty(bcx, scratch_ty);\n+                        let arg_ty = expr_ty(bcx, arg_expr);\n+                        let proto = ty::ty_fn_proto(arg_ty);\n+                        let bcx = closure::trans_expr_fn(\n+                            bcx, proto, decl, body, blk.id,\n+                            cap, Some(ret_flag), expr::SaveIn(scratch));\n+                        DatumBlock {bcx: bcx,\n+                                    datum: Datum {val: scratch,\n+                                                  ty: scratch_ty,\n+                                                  mode: ByRef,\n+                                                  source: FromRvalue}}\n+                    }\n+                    _ => {\n+                        bcx.sess().impossible_case(\n+                            arg_expr.span, ~\"ret_flag with non-loop-\\\n+                                             body expr\");\n+                    }\n+                }\n+            }\n         }\n     }\n \n-    debug!(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n-    return rslt(bcx, val);\n+    fn trans_arg_expr_into(bcx: block,\n+                           arg_expr: @ast::expr,\n+                           ret_flag: Option<ValueRef>,\n+                           dest: expr::Dest) -> block {\n+        match ret_flag {\n+            None => {\n+                expr::trans_into(bcx, arg_expr, dest)\n+            }\n+\n+            Some(_) => {\n+                let DatumBlock {bcx, datum} =\n+                    trans_arg_expr_to_datum(bcx, arg_expr, ret_flag);\n+                datum.store_to_dest(bcx, dest)\n+            }\n+        }\n+    }\n }\n "}]}