{"sha": "f6f945fed5c8d1061d80b444331910df29afa392", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2Zjk0NWZlZDVjOGQxMDYxZDgwYjQ0NDMzMTkxMGRmMjlhZmEzOTI=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-24T23:50:06Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-28T23:12:33Z"}, "message": "Moved thread management to rust_kernel.", "tree": {"sha": "1ee8908830878e916d26cbae145b00771d5c9c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee8908830878e916d26cbae145b00771d5c9c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f945fed5c8d1061d80b444331910df29afa392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f945fed5c8d1061d80b444331910df29afa392", "html_url": "https://github.com/rust-lang/rust/commit/f6f945fed5c8d1061d80b444331910df29afa392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f945fed5c8d1061d80b444331910df29afa392/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6d83248301b4aed366b9bef682d200381324c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d83248301b4aed366b9bef682d200381324c01", "html_url": "https://github.com/rust-lang/rust/commit/c6d83248301b4aed366b9bef682d200381324c01"}], "stats": {"total": 177, "additions": 91, "deletions": 86}, "files": [{"sha": "2a491b611509dbdbe760fb9c3027bb758bba7bfe", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -111,7 +111,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     DLOG(dom, dom, \"Using %d worker threads.\", num_threads);\n \n-    int ret = dom->start_main_loops(num_threads);\n+    int ret = kernel->start_task_threads(num_threads);\n     delete args;\n     delete kernel;\n     delete srv;"}, {"sha": "2a724ee17913486968083258da9836666098397b", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -391,16 +391,16 @@ task_yield(rust_task *task) {\n \n extern \"C\" CDECL void\n task_join(rust_task *task, rust_task *join_task) {\n-    task->dom->scheduler_lock.lock();\n+    task->kernel->scheduler_lock.lock();\n     // If the other task is already dying, we don't have to wait for it.\n     if (join_task->dead() == false) {\n         join_task->tasks_waiting_to_join.push(task);\n         task->block(join_task, \"joining local task\");\n-        task->dom->scheduler_lock.unlock();\n+        task->kernel->scheduler_lock.unlock();\n         task->yield(2);\n     }\n     else {\n-        task->dom->scheduler_lock.unlock();\n+        task->kernel->scheduler_lock.unlock();\n     }\n }\n "}, {"sha": "65ccf158b64a37866760e19138b138914630bab8", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -51,9 +51,9 @@ rust_dom::activate(rust_task *task) {\n \n     task->ctx.next = &ctx;\n     DLOG(this, task, \"descheduling...\");\n-    scheduler_lock.unlock();\n+    kernel->scheduler_lock.unlock();\n     task->ctx.swap(ctx);\n-    scheduler_lock.lock();\n+    kernel->scheduler_lock.lock();\n     DLOG(this, task, \"task has returned\");\n }\n \n@@ -167,7 +167,7 @@ rust_dom::number_of_live_tasks() {\n  */\n void\n rust_dom::reap_dead_tasks() {\n-    I(this, scheduler_lock.lock_held_by_current_thread());\n+    I(this, kernel->scheduler_lock.lock_held_by_current_thread());\n     for (size_t i = 0; i < dead_tasks.length(); ) {\n         rust_task *task = dead_tasks[i];\n         // Make sure this task isn't still running somewhere else...\n@@ -266,7 +266,7 @@ rust_dom::log_state() {\n  */\n int\n rust_dom::start_main_loop(int id) {\n-    scheduler_lock.lock();\n+    kernel->scheduler_lock.lock();\n \n     // Make sure someone is watching, to pull us out of infinite loops.\n     //\n@@ -296,9 +296,9 @@ rust_dom::start_main_loop(int id) {\n             DLOG(this, task,\n                  \"all tasks are blocked, scheduler id %d yielding ...\",\n                  id);\n-            scheduler_lock.unlock();\n+            kernel->scheduler_lock.unlock();\n             sync::sleep(100);\n-            scheduler_lock.lock();\n+            kernel->scheduler_lock.lock();\n             DLOG(this, task,\n                 \"scheduler resuming ...\");\n             continue;\n@@ -349,9 +349,9 @@ rust_dom::start_main_loop(int id) {\n                 \"scheduler yielding ...\",\n                 dead_tasks.length());\n             log_state();\n-            scheduler_lock.unlock();\n+            kernel->scheduler_lock.unlock();\n             sync::yield();\n-            scheduler_lock.lock();\n+            kernel->scheduler_lock.lock();\n         } else {\n             drain_incoming_message_queue(true);\n         }\n@@ -360,28 +360,7 @@ rust_dom::start_main_loop(int id) {\n \n     DLOG(this, dom, \"finished main-loop %d (dom.rval = %d)\", id, rval);\n \n-    scheduler_lock.unlock();\n-    return rval;\n-}\n-\n-int rust_dom::start_main_loops(int num_threads)\n-{\n-    dom_worker *worker = NULL;\n-\n-    // -1, because this thread will also be a worker.\n-    for(int i = 0; i < num_threads - 1; ++i) {\n-        worker = new dom_worker(i + 1, this);\n-        worker->start();\n-        threads.push(worker);\n-    }\n-\n-    start_main_loop(0);\n-\n-    while(threads.pop(&worker)) {\n-        worker->join();\n-        delete worker;\n-    }\n-\n+    kernel->scheduler_lock.unlock();\n     return rval;\n }\n \n@@ -392,26 +371,14 @@ rust_dom::get_cache() {\n \n rust_task *\n rust_dom::create_task(rust_task *spawner, const char *name) {\n-    //scheduler_lock.lock();\n     rust_task *task =\n         new (this) rust_task (this, &newborn_tasks, spawner, name);\n     DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",\n                         task, spawner ? spawner->name : \"null\", name);\n     newborn_tasks.append(task);\n-    //scheduler_lock.unlock();\n     return task;\n }\n \n-rust_dom::dom_worker::dom_worker(int id, rust_dom *owner)\n-    : id(id), owner(owner)\n-{\n-}\n-\n-void rust_dom::dom_worker::run()\n-{\n-    owner->start_main_loop(id);\n-}\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "dfc0960a9ea90bc1da698fae6fe6ce010c0d90e8", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -97,24 +97,10 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n     rust_task *schedule_task();\n \n     int start_main_loop(int id);\n-    int start_main_loops(int num_threads);\n \n     void log_state();\n \n     rust_task *create_task(rust_task *spawner, const char *name);\n-\n-    class dom_worker : public rust_thread {\n-        int id;\n-        rust_dom *owner;\n-\n-    public:\n-        dom_worker(int id, rust_dom *owner);\n-\n-        virtual void run();\n-    };\n-\n-    lock_and_signal scheduler_lock;\n-    array_list<dom_worker *> threads;\n };\n \n inline rust_log &"}, {"sha": "5e495b8c822b2e9ec77f07c596b1fd812601a5fc", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -224,6 +224,37 @@ rust_kernel::signal_kernel_lock() {\n     _kernel_lock.unlock();\n }\n \n+int rust_kernel::start_task_threads(int num_threads)\n+{\n+    rust_task_thread *thread = NULL;\n+    \n+    // -1, because this thread will also be a thread.\n+    for(int i = 0; i < num_threads - 1; ++i) {\n+        thread = new rust_task_thread(i + 1, this);\n+        thread->start();\n+        threads.push(thread);\n+    }\n+    \n+    dom->start_main_loop(0);\n+\n+    while(threads.pop(&thread)) {\n+        thread->join();\n+        delete thread;\n+    }\n+\n+    return dom->rval;\n+}\n+\n+rust_task_thread::rust_task_thread(int id, rust_kernel *owner)\n+    : id(id), owner(owner)\n+{\n+}\n+\n+void rust_task_thread::run()\n+{\n+    owner->dom->start_main_loop(id);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "ee5cf99ef5d4cd8b39867a06a30c2109ddfb77fe", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -34,6 +34,9 @@ rust_handle :\n     }\n };\n \n+class rust_task_thread;\n+\n+\n /**\n  * A global object shared by all thread domains. Most of the data structures\n  * in this class are synchronized since they are accessed from multiple\n@@ -44,8 +47,6 @@ class rust_kernel : public rust_thread {\n     rust_log _log;\n     rust_srv *_srv;\n \n-    rust_dom *dom;\n-\n     /**\n      * Task proxy objects are kernel owned handles to Rust objects.\n      */\n@@ -69,7 +70,11 @@ class rust_kernel : public rust_thread {\n     rust_dom *create_domain(const char *name);\n     void destroy_domain();\n \n+    array_list<rust_task_thread *> threads;\n+\n public:\n+    rust_dom *dom;\n+    lock_and_signal scheduler_lock;\n \n     /**\n      * Message queues are kernel objects and are associated with domains.\n@@ -105,7 +110,10 @@ class rust_kernel : public rust_thread {\n     void *malloc(size_t size);\n     void free(void *mem);\n \n+    // TODO: this should go away\n     inline rust_dom *get_domain() const { return dom; }\n+\n+    int start_task_threads(int num_threads);\n };\n \n inline void *operator new(size_t size, rust_kernel *kernel) {\n@@ -116,4 +124,15 @@ inline void *operator new(size_t size, rust_kernel &kernel) {\n     return kernel.malloc(size);\n }\n \n+\n+class rust_task_thread : public rust_thread {\n+    int id;\n+    rust_kernel *owner;\n+    \n+public:\n+    rust_task_thread(int id, rust_kernel *owner);\n+    \n+    virtual void run();\n+};\n+\n #endif /* RUST_KERNEL_H */"}, {"sha": "325bb560502c5509316cd07cd6993414182297d5", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -61,6 +61,7 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n     gc_alloc_chain(0),\n     dom(dom),\n     cache(NULL),\n+    kernel(dom->kernel),\n     name(name),\n     state(state),\n     cond(NULL),\n@@ -134,7 +135,7 @@ void task_start_wrapper(spawn_args *a)\n     LOG(task, task, \"task exited with value %d\", rval);\n \n     {\n-        scoped_lock with(task->dom->scheduler_lock);\n+        scoped_lock with(task->kernel->scheduler_lock);\n \n         // FIXME: the old exit glue does some magical argument copying\n         // stuff. This is probably still needed.\n@@ -158,9 +159,9 @@ rust_task::start(uintptr_t spawnee_fn,\n     LOGPTR(dom, \"from spawnee\", spawnee_fn);\n \n     I(dom, stk->data != NULL);\n-    I(dom, !dom->scheduler_lock.lock_held_by_current_thread());\n-\n-    scoped_lock with(dom->scheduler_lock);\n+    I(dom, !kernel->scheduler_lock.lock_held_by_current_thread());\n+    \n+    scoped_lock with(kernel->scheduler_lock);\n \n     char *sp = (char *)rust_sp;\n \n@@ -412,7 +413,7 @@ rust_task::free(void *p, bool is_gc)\n \n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n-    I(dom, dom->scheduler_lock.lock_held_by_current_thread());\n+    I(dom, kernel->scheduler_lock.lock_held_by_current_thread());\n     DLOG(dom, task,\n          \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n          name, (uintptr_t)this, src->name, dst->name, state->name);"}, {"sha": "62a725a98d5e9cb467a2db8205bab6221372c7ca", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -22,6 +22,7 @@ rust_task : public maybe_proxy<rust_task>,\n     rust_crate_cache *cache;\n \n     // Fields known only to the runtime.\n+    rust_kernel *kernel;\n     const char *const name;\n     rust_task_list *state;\n     rust_cond *cond;"}, {"sha": "ccb35958a8095884ca9d6b308433d6617b6c5cd6", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f945fed5c8d1061d80b444331910df29afa392/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f6f945fed5c8d1061d80b444331910df29afa392", "patch": "@@ -75,7 +75,7 @@ extern \"C\" CDECL rust_port*\n upcall_new_port(rust_task *task, size_t unit_sz) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    scoped_lock with(dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     LOG(task, comm, \"upcall_new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n         (uintptr_t) task, task->name, unit_sz);\n     return new (dom) rust_port(task, unit_sz);\n@@ -84,7 +84,7 @@ upcall_new_port(rust_task *task, size_t unit_sz) {\n extern \"C\" CDECL void\n upcall_del_port(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     LOG(task, comm, \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     I(task->dom, !port->ref_count);\n     delete port;\n@@ -124,7 +124,7 @@ upcall_flush_chan(rust_task *task, rust_chan *chan) {\n extern \"C\" CDECL\n void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n \n     LOG(task, comm, \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n \n@@ -166,7 +166,7 @@ extern \"C\" CDECL rust_chan *\n upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n                   rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     size_t unit_sz = chan->buffer.unit_sz;\n     maybe_proxy<rust_port> *port = chan->port;\n     rust_task *target_task = NULL;\n@@ -208,7 +208,7 @@ upcall_sleep(rust_task *task, size_t time_in_us) {\n extern \"C\" CDECL void\n upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     chan->send(sptr);\n     LOG(task, comm, \"=== sent data ===>\");\n }\n@@ -217,7 +217,7 @@ extern \"C\" CDECL void\n upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     {\n         LOG_UPCALL_ENTRY(task);\n-        scoped_lock with(task->dom->scheduler_lock);\n+        scoped_lock with(task->kernel->scheduler_lock);\n \n         LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n             \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n@@ -255,7 +255,7 @@ upcall_fail(rust_task *task,\n extern \"C\" CDECL void\n upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     if (target->is_proxy()) {\n         notify_message::\n         send(notify_message::KILL, \"kill\", task->get_handle(),\n@@ -274,7 +274,7 @@ extern \"C\" CDECL void\n upcall_exit(rust_task *task) {\n     {\n         LOG_UPCALL_ENTRY(task);\n-        scoped_lock with(task->dom->scheduler_lock);\n+        scoped_lock with(task->kernel->scheduler_lock);\n         LOG(task, task, \"task ref_count: %d\", task->ref_count);\n         A(task->dom, task->ref_count >= 0,\n           \"Task ref_count should not be negative on exit!\");\n@@ -287,7 +287,7 @@ upcall_exit(rust_task *task) {\n extern \"C\" CDECL uintptr_t\n upcall_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n \n     LOG(task, mem,\n                    \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\"\n@@ -308,7 +308,7 @@ upcall_malloc(rust_task *task, size_t nbytes, type_desc *td) {\n extern \"C\" CDECL void\n upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     rust_dom *dom = task->dom;\n     DLOG(dom, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n@@ -319,7 +319,7 @@ upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n extern \"C\" CDECL uintptr_t\n upcall_mark(rust_task *task, void* ptr) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n \n     rust_dom *dom = task->dom;\n     if (ptr) {\n@@ -350,23 +350,23 @@ rust_str *make_str(rust_task *task, char const *s, size_t fill) {\n extern \"C\" CDECL rust_str *\n upcall_new_str(rust_task *task, char const *s, size_t fill) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     \n     return make_str(task, s, fill);\n }\n \n extern \"C\" CDECL rust_str *\n upcall_dup_str(rust_task *task, rust_str *str) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n \n     return make_str(task, (char const *)str->data, str->fill);\n }\n \n extern \"C\" CDECL rust_vec *\n upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     rust_dom *dom = task->dom;\n     DLOG(dom, mem, \"upcall new_vec(%\" PRIdPTR \")\", fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n@@ -471,7 +471,7 @@ upcall_vec_append(rust_task *task, type_desc *t, type_desc *elem_t,\n                   rust_vec **dst_ptr, rust_vec *src, bool skip_null)\n {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     rust_vec *dst = *dst_ptr;\n     uintptr_t need_copy;\n     size_t n_src_bytes = skip_null ? src->fill - 1 : src->fill;\n@@ -507,7 +507,7 @@ upcall_get_type_desc(rust_task *task,\n                      size_t n_descs,\n                      type_desc const **descs) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     LOG(task, cache, \"upcall get_type_desc with size=%\" PRIdPTR\n         \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n         n_descs);\n@@ -521,7 +521,7 @@ extern \"C\" CDECL rust_task *\n upcall_new_task(rust_task *spawner, rust_vec *name) {\n     // name is a rust string structure.\n     LOG_UPCALL_ENTRY(spawner);\n-    scoped_lock with(spawner->dom->scheduler_lock);\n+    scoped_lock with(spawner->kernel->scheduler_lock);\n     rust_dom *dom = spawner->dom;\n     rust_task *task = dom->create_task(spawner, (const char *)name->data);\n     return task;\n@@ -563,7 +563,7 @@ extern \"C\" CDECL void\n upcall_ivec_resize(rust_task *task,\n                    rust_ivec *v,\n                    size_t newsz) {\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     I(task->dom, !v->fill);\n \n     size_t new_alloc = next_power_of_two(newsz);\n@@ -582,7 +582,7 @@ extern \"C\" CDECL void\n upcall_ivec_spill(rust_task *task,\n                   rust_ivec *v,\n                   size_t newsz) {\n-    scoped_lock with(task->dom->scheduler_lock);\n+    scoped_lock with(task->kernel->scheduler_lock);\n     size_t new_alloc = next_power_of_two(newsz);\n \n     rust_ivec_heap *heap_part = (rust_ivec_heap *)"}]}