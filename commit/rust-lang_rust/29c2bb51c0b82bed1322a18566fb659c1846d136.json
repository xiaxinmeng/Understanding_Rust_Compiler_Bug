{"sha": "29c2bb51c0b82bed1322a18566fb659c1846d136", "node_id": "C_kwDOAAsO6NoAKDI5YzJiYjUxYzBiODJiZWQxMzIyYTE4NTY2ZmI2NTljMTg0NmQxMzY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-08T06:37:32Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-11T20:45:51Z"}, "message": "rework borrowck errors so that it's harder to not set tainted", "tree": {"sha": "f92a08a1beabff825f6180e1f173f27d1ef505f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f92a08a1beabff825f6180e1f173f27d1ef505f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29c2bb51c0b82bed1322a18566fb659c1846d136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29c2bb51c0b82bed1322a18566fb659c1846d136", "html_url": "https://github.com/rust-lang/rust/commit/29c2bb51c0b82bed1322a18566fb659c1846d136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29c2bb51c0b82bed1322a18566fb659c1846d136/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b7b0a0e49cf3e313d0432d1f6e8ce20253fef0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7b0a0e49cf3e313d0432d1f6e8ce20253fef0a", "html_url": "https://github.com/rust-lang/rust/commit/8b7b0a0e49cf3e313d0432d1f6e8ce20253fef0a"}], "stats": {"total": 193, "additions": 119, "deletions": 74}, "files": [{"sha": "7140cda8e4e51d42e7b9fa5850962f15460a80ea", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -327,7 +327,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         verb: &str,\n         optional_adverb_for_moved: &str,\n         moved_path: Option<String>,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         let moved_path = moved_path.map(|mp| format!(\": `{}`\", mp)).unwrap_or_default();\n \n         struct_span_err!("}, {"sha": "7b8b5974fe758c2eaa103efea01391ef0e6ac807", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -77,7 +77,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if move_out_indices.is_empty() {\n             let root_place = PlaceRef { projection: &[], ..used_place };\n \n-            self.set_tainted_by_errors();\n             if !self.uninitialized_error_reported.insert(root_place) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n@@ -107,7 +106,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             self.buffer_error(err);\n         } else {\n-            if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n+            if let Some((reported_place, _)) = self.has_move_error(&move_out_indices) {\n                 if self.prefixes(*reported_place, PrefixSet::All).any(|p| p == used_place) {\n                     debug!(\n                         \"report_use_of_moved_or_uninitialized place: error suppressed \\\n@@ -217,7 +216,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     place_name, partially_str, loop_message\n                                 ),\n                             );\n-                            self.set_tainted_by_errors();\n                             if self.fn_self_span_reported.insert(fn_span) {\n                                 err.span_note(\n                                     // Check whether the source is accessible\n@@ -299,7 +297,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                             // Avoid pointing to the same function in multiple different\n                             // error messages.\n-                            self.set_tainted_by_errors();\n                             if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span)\n                             {\n                                 err.span_note(\n@@ -452,13 +449,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            self.set_tainted_by_errors();\n-            if let Some((_, mut old_err)) =\n-                self.move_error_reported.insert(move_out_indices, (used_place, err))\n-            {\n-                // Cancel the old error so it doesn't ICE.\n-                old_err.cancel();\n-            }\n+            self.buffer_move_error(move_out_indices, (used_place, err));\n         }\n     }\n \n@@ -1016,7 +1007,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             return;\n         }\n \n-        self.set_tainted_by_errors();\n         self.access_place_error_reported.insert((\n             Place { local: root_place.local, projection: root_place_projection },\n             borrow_span,"}, {"sha": "459b03b0fad65017746ed5c33738f6cf5aa5b335", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 107, "deletions": 52, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -175,10 +175,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n         }\n     }\n \n+    let mut errors = error::BorrowckErrors::new();\n+\n     // Gather the upvars of a closure, if any.\n     let tables = tcx.typeck_opt_const_arg(def);\n     if let Some(ErrorReported) = tables.tainted_by_errors {\n         infcx.set_tainted_by_errors();\n+        errors.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n         .closure_min_captures_flattened(def.did.to_def_id())\n@@ -205,7 +208,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let location_table_owned = LocationTable::new(body);\n     let location_table = &location_table_owned;\n \n-    let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>) =\n         match MoveData::gather_moves(&body, tcx, param_env) {\n             Ok(move_data) => (move_data, Vec::new()),\n@@ -263,7 +265,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         &regioncx,\n         &opt_closure_req,\n         &opaque_type_values,\n-        &mut errors_buffer,\n+        &mut errors,\n     );\n \n     // The various `flow_*` structures can be large. We drop `flow_inits` here\n@@ -310,10 +312,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 access_place_error_reported: Default::default(),\n                 reservation_error_reported: Default::default(),\n                 reservation_warnings: Default::default(),\n-                move_error_reported: BTreeMap::new(),\n                 uninitialized_error_reported: Default::default(),\n-                errors_buffer,\n-                tainted_by_errors: false,\n                 regioncx: regioncx.clone(),\n                 used_mut: Default::default(),\n                 used_mut_upvars: SmallVec::new(),\n@@ -324,9 +323,10 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 region_names: RefCell::default(),\n                 next_region_name: RefCell::new(1),\n                 polonius_output: None,\n+                errors,\n             };\n             promoted_mbcx.report_move_errors(move_errors);\n-            errors_buffer = promoted_mbcx.errors_buffer;\n+            errors = promoted_mbcx.errors;\n         };\n     }\n \n@@ -344,10 +344,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         access_place_error_reported: Default::default(),\n         reservation_error_reported: Default::default(),\n         reservation_warnings: Default::default(),\n-        move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n-        errors_buffer,\n-        tainted_by_errors: false,\n         regioncx: Rc::clone(&regioncx),\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n@@ -358,6 +355,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         region_names: RefCell::default(),\n         next_region_name: RefCell::new(1),\n         polonius_output,\n+        errors,\n     };\n \n     // Compute and report region errors, if any.\n@@ -462,24 +460,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n         })\n     }\n \n-    // Buffer any move errors that we collected and de-duplicated.\n-    for (_, (_, diag)) in std::mem::take(&mut mbcx.move_error_reported) {\n-        mbcx.buffer_error(diag);\n-    }\n-\n-    if !mbcx.errors_buffer.is_empty() {\n-        mbcx.errors_buffer.sort_by_key(|diag| diag.sort_span);\n-\n-        for diag in mbcx.errors_buffer.drain(..) {\n-            mbcx.infcx.tcx.sess.diagnostic().emit_diagnostic(&diag);\n-        }\n-    }\n+    let tainted_by_errors = mbcx.emit_errors();\n \n     let result = BorrowCheckResult {\n         concrete_opaque_types: opaque_type_values,\n         closure_requirements: opt_closure_req,\n         used_mut_upvars: mbcx.used_mut_upvars,\n-        tainted_by_errors: mbcx.tainted_by_errors,\n+        tainted_by_errors,\n     };\n \n     let body_with_facts = if return_body_with_facts {\n@@ -556,28 +543,9 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// for the activation of the borrow.\n     reservation_warnings:\n         FxHashMap<BorrowIndex, (Place<'tcx>, Span, Location, BorrowKind, BorrowData<'tcx>)>,\n-    /// This field keeps track of move errors that are to be reported for given move indices.\n-    ///\n-    /// There are situations where many errors can be reported for a single move out (see #53807)\n-    /// and we want only the best of those errors.\n-    ///\n-    /// The `report_use_of_moved_or_uninitialized` function checks this map and replaces the\n-    /// diagnostic (if there is one) if the `Place` of the error being reported is a prefix of the\n-    /// `Place` of the previous most diagnostic. This happens instead of buffering the error. Once\n-    /// all move errors have been reported, any diagnostics in this map are added to the buffer\n-    /// to be emitted.\n-    ///\n-    /// `BTreeMap` is used to preserve the order of insertions when iterating. This is necessary\n-    /// when errors in the map are being re-added to the error buffer so that errors with the\n-    /// same primary span come out in a consistent order.\n-    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'cx>)>,\n     /// This field keeps track of errors reported in the checking of uninitialized variables,\n     /// so that we don't report seemingly duplicate errors.\n     uninitialized_error_reported: FxHashSet<PlaceRef<'tcx>>,\n-    /// Errors to be reported buffer\n-    errors_buffer: Vec<Diagnostic>,\n-    /// Set to true if we emit an error during borrowck\n-    tainted_by_errors: bool,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n     /// Used for the warning issued by an unused mutable local variable.\n     used_mut: FxHashSet<Local>,\n@@ -609,6 +577,8 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Results of Polonius analysis.\n     polonius_output: Option<Rc<PoloniusOutput>>,\n+\n+    errors: error::BorrowckErrors<'tcx>,\n }\n \n // Check that:\n@@ -1032,8 +1002,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if conflict_error || mutability_error {\n             debug!(\"access_place: logging error place_span=`{:?}` kind=`{:?}`\", place_span, kind);\n-\n-            self.set_tainted_by_errors();\n             self.access_place_error_reported.insert((place_span.0, place_span.1));\n         }\n     }\n@@ -2055,10 +2023,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 | WriteKind::MutableBorrow(BorrowKind::Shared)\n                 | WriteKind::MutableBorrow(BorrowKind::Shallow),\n             ) => {\n-                if let (Err(_), true) = (\n-                    self.is_mutable(place.as_ref(), is_local_mutation_allowed),\n-                    self.errors_buffer.is_empty(),\n-                ) {\n+                if self.is_mutable(place.as_ref(), is_local_mutation_allowed).is_err()\n+                    && !self.has_buffered_errors()\n+                {\n                     // rust-lang/rust#46908: In pure NLL mode this code path should be\n                     // unreachable, but we use `delay_span_bug` because we can hit this when\n                     // dereferencing a non-Copy raw pointer *and* have `-Ztreat-err-as-bug`\n@@ -2308,14 +2275,102 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n         path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())\n     }\n+}\n+\n+mod error {\n+    use super::*;\n+\n+    pub struct BorrowckErrors<'tcx> {\n+        /// This field keeps track of move errors that are to be reported for given move indices.\n+        ///\n+        /// There are situations where many errors can be reported for a single move out (see #53807)\n+        /// and we want only the best of those errors.\n+        ///\n+        /// The `report_use_of_moved_or_uninitialized` function checks this map and replaces the\n+        /// diagnostic (if there is one) if the `Place` of the error being reported is a prefix of the\n+        /// `Place` of the previous most diagnostic. This happens instead of buffering the error. Once\n+        /// all move errors have been reported, any diagnostics in this map are added to the buffer\n+        /// to be emitted.\n+        ///\n+        /// `BTreeMap` is used to preserve the order of insertions when iterating. This is necessary\n+        /// when errors in the map are being re-added to the error buffer so that errors with the\n+        /// same primary span come out in a consistent order.\n+        buffered_move_errors:\n+            BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'tcx>)>,\n+        /// Errors to be reported buffer\n+        buffered: Vec<Diagnostic>,\n+        /// Set to Some if we emit an error during borrowck\n+        tainted_by_errors: Option<ErrorReported>,\n+    }\n+\n+    impl BorrowckErrors<'_> {\n+        pub fn new() -> Self {\n+            BorrowckErrors {\n+                buffered_move_errors: BTreeMap::new(),\n+                buffered: Default::default(),\n+                tainted_by_errors: None,\n+            }\n+        }\n+\n+        pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_>) {\n+            self.tainted_by_errors = Some(ErrorReported {});\n+            t.buffer(&mut self.buffered);\n+        }\n \n-    pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_>) {\n-        self.tainted_by_errors = true;\n-        t.buffer(&mut self.errors_buffer);\n+        pub fn set_tainted_by_errors(&mut self) {\n+            self.tainted_by_errors = Some(ErrorReported {});\n+        }\n     }\n \n-    pub fn set_tainted_by_errors(&mut self) {\n-        self.tainted_by_errors = true;\n+    impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+        pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_>) {\n+            self.errors.buffer_error(t);\n+        }\n+\n+        pub fn buffer_move_error(\n+            &mut self,\n+            move_out_indices: Vec<MoveOutIndex>,\n+            place_and_err: (PlaceRef<'tcx>, DiagnosticBuilder<'tcx>),\n+        ) -> bool {\n+            if let Some((_, mut diag)) =\n+                self.errors.buffered_move_errors.insert(move_out_indices, place_and_err)\n+            {\n+                // Cancel the old diagnostic so we don't ICE\n+                diag.cancel();\n+                false\n+            } else {\n+                true\n+            }\n+        }\n+\n+        pub fn emit_errors(&mut self) -> Option<ErrorReported> {\n+            // Buffer any move errors that we collected and de-duplicated.\n+            for (_, (_, diag)) in std::mem::take(&mut self.errors.buffered_move_errors) {\n+                // We have already set tainted for this error, so just buffer it.\n+                diag.buffer(&mut self.errors.buffered);\n+            }\n+\n+            if !self.errors.buffered.is_empty() {\n+                self.errors.buffered.sort_by_key(|diag| diag.sort_span);\n+\n+                for diag in self.errors.buffered.drain(..) {\n+                    self.infcx.tcx.sess.diagnostic().emit_diagnostic(&diag);\n+                }\n+            }\n+\n+            self.errors.tainted_by_errors\n+        }\n+\n+        pub fn has_buffered_errors(&self) -> bool {\n+            self.errors.buffered.is_empty()\n+        }\n+\n+        pub fn has_move_error(\n+            &self,\n+            move_out_indices: &[MoveOutIndex],\n+        ) -> Option<&(PlaceRef<'tcx>, DiagnosticBuilder<'cx>)> {\n+            self.errors.buffered_move_errors.get(move_out_indices)\n+        }\n     }\n }\n "}, {"sha": "7fc1fe1130b1446d62fe1551e5403a48bb48e798", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -1,7 +1,6 @@\n //! The entry point of the NLL borrow checker.\n \n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::Diagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n@@ -373,7 +372,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n     opaque_type_values: &VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n-    errors_buffer: &mut Vec<Diagnostic>,\n+    errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n     let tcx = infcx.tcx;\n     let base_def_id = tcx.typeck_root_def_id(body.source.def_id());\n@@ -418,8 +417,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n         err.note(&format!(\"Inferred opaque type values:\\n{:#?}\", opaque_type_values));\n     }\n \n-    // FIXME(compiler-errors): Maybe we need to set tainted here\n-    err.buffer(errors_buffer);\n+    errors.buffer_error(err);\n }\n \n fn for_each_region_constraint("}, {"sha": "df08b541801dd318e86fd147bb39402109b398b6", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -287,8 +287,8 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n             if let Some(error_reported) = tcx.typeck_opt_const_arg(def).tainted_by_errors {\n                 return Err(ErrorHandled::Reported(error_reported));\n             }\n-            if tcx.mir_borrowck_opt_const_arg(def).tainted_by_errors {\n-                return Err(ErrorHandled::Reported(ErrorReported {}));\n+            if let Some(error_reported) = tcx.mir_borrowck_opt_const_arg(def).tainted_by_errors {\n+                return Err(ErrorHandled::Reported(error_reported));\n             }\n         }\n         if !tcx.is_mir_available(def.did) {"}, {"sha": "022127de65a674f2ea0e4595d72116b5c6823db2", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -516,8 +516,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if let Some(error_reported) = self.tcx.typeck_opt_const_arg(def).tainted_by_errors {\n                     throw_inval!(AlreadyReported(error_reported));\n                 }\n-                if self.tcx.mir_borrowck_opt_const_arg(def).tainted_by_errors {\n-                    throw_inval!(AlreadyReported(rustc_errors::ErrorReported {}));\n+                if let Some(error_reported) =\n+                    self.tcx.mir_borrowck_opt_const_arg(def).tainted_by_errors\n+                {\n+                    throw_inval!(AlreadyReported(error_reported));\n                 }\n             }\n         }"}, {"sha": "5c22bfd09a3966eadf83efc3b192975a753cd32c", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c2bb51c0b82bed1322a18566fb659c1846d136/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=29c2bb51c0b82bed1322a18566fb659c1846d136", "patch": "@@ -214,7 +214,7 @@ pub struct BorrowCheckResult<'tcx> {\n     pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n-    pub tainted_by_errors: bool,\n+    pub tainted_by_errors: Option<ErrorReported>,\n }\n \n /// The result of the `mir_const_qualif` query."}]}