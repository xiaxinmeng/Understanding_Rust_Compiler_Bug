{"sha": "d35181ad8785fa958e43580a29a982afe02c728f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNTE4MWFkODc4NWZhOTU4ZTQzNTgwYTI5YTk4MmFmZTAyYzcyOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T15:05:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T15:05:04Z"}, "message": "Auto merge of #60445 - RalfJung:maybe-uninit, r=Centril\n\nstabilize core parts of MaybeUninit\n\nand deprecate mem::uninitialized in the future (1.40.0). This is part of implementing https://github.com/rust-lang/rfcs/pull/1892.\n\nAlso expand the documentation a bit.\n\nThis type is currently primarily useful when dealing with partially initialized arrays. In libstd, it is used e.g. in `BTreeMap` (with some unstable APIs that however can all be replaced, less ergonomically, by stable ones). What we stabilize should also be enough for `SmallVec` (Cc @bluss).\n\nMaking this useful for structs requires https://github.com/rust-lang/rfcs/pull/2582 or a commitment that references to uninitialized data are not insta-UB.", "tree": {"sha": "b069d7b91879da1f58f1fd61c7a9f14896ec6915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b069d7b91879da1f58f1fd61c7a9f14896ec6915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d35181ad8785fa958e43580a29a982afe02c728f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d35181ad8785fa958e43580a29a982afe02c728f", "html_url": "https://github.com/rust-lang/rust/commit/d35181ad8785fa958e43580a29a982afe02c728f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d35181ad8785fa958e43580a29a982afe02c728f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "589beb979c0f1a9736e02e578913db88398c3ba5", "url": "https://api.github.com/repos/rust-lang/rust/commits/589beb979c0f1a9736e02e578913db88398c3ba5", "html_url": "https://github.com/rust-lang/rust/commit/589beb979c0f1a9736e02e578913db88398c3ba5"}, {"sha": "1916391ea8b97389a9ed690b4df614a2b96069fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1916391ea8b97389a9ed690b4df614a2b96069fd", "html_url": "https://github.com/rust-lang/rust/commit/1916391ea8b97389a9ed690b4df614a2b96069fd"}], "stats": {"total": 430, "additions": 198, "deletions": 232}, "files": [{"sha": "d90036eaf49b8f3da6389d23e8f978f69fe5984e", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -109,7 +109,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(iter_nth_back)]"}, {"sha": "4a70329b64bc983a7d43b0b4214be77d892c8447", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -125,7 +125,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_slice, maybe_uninit_array)]\n #![feature(external_doc)]\n \n #[prelude_import]"}, {"sha": "24bee6355a7ccfe41f9e868b32a71718b52a2fcb", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 190, "deletions": 222, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -63,62 +63,6 @@ pub use crate::intrinsics::transmute;\n /// The practical use cases for `forget` are rather specialized and mainly come\n /// up in unsafe or FFI code.\n ///\n-/// ## Use case 1\n-///\n-/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n-/// You must either initialize or `forget` it on every computation path before\n-/// Rust drops it automatically, like at the end of a scope or after a panic.\n-/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # let some_condition = false;\n-/// unsafe {\n-///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n-///\n-///     if some_condition {\n-///         // Initialize the variable.\n-///         ptr::write(&mut uninit_vec, Vec::new());\n-///     } else {\n-///         // Forget the uninitialized value so its destructor doesn't run.\n-///         mem::forget(uninit_vec);\n-///     }\n-/// }\n-/// ```\n-///\n-/// ## Use case 2\n-///\n-/// You have duplicated the bytes making up a value, without doing a proper\n-/// [`Clone`][clone]. You need the value's destructor to run only once,\n-/// because a double `free` is undefined behavior.\n-///\n-/// An example is a possible implementation of [`mem::swap`][swap]:\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// # #[allow(dead_code)]\n-/// fn swap<T>(x: &mut T, y: &mut T) {\n-///     unsafe {\n-///         // Give ourselves some scratch space to work with\n-///         let mut t: T = mem::uninitialized();\n-///\n-///         // Perform the swap, `&mut` pointers never alias\n-///         ptr::copy_nonoverlapping(&*x, &mut t, 1);\n-///         ptr::copy_nonoverlapping(&*y, x, 1);\n-///         ptr::copy_nonoverlapping(&t, y, 1);\n-///\n-///         // y and t now point to the same thing, but we need to completely\n-///         // forget `t` because we do not want to run the destructor for `T`\n-///         // on its value, which is still owned somewhere outside this function.\n-///         mem::forget(t);\n-///     }\n-/// }\n-/// ```\n-///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html\n /// [clone]: ../clone/trait.Clone.html\n@@ -465,29 +409,37 @@ pub const fn needs_drop<T>() -> bool {\n \n /// Creates a value whose bytes are all zero.\n ///\n-/// This has the same effect as allocating space with\n-/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n-/// FFI sometimes, but should generally be avoided.\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n ///\n /// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n-/// a panic or the end of a scope) before being initialized, then the destructor\n-/// will run on zeroed data, likely leading to [undefined behavior][ub].\n-///\n-/// See also the documentation for [`mem::uninitialized`][uninit], which has\n-/// many of the same caveats.\n+/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n+/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n+/// that there always is a valid value in a variable it considers initialized.\n ///\n-/// [uninit]: fn.uninitialized.html\n+/// [zeroed]: union.MaybeUninit.html#method.zeroed\n /// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n ///\n /// # Examples\n ///\n+/// Correct usage of this function: initializing an integer with zero.\n+///\n /// ```\n /// use std::mem;\n ///\n /// let x: i32 = unsafe { mem::zeroed() };\n /// assert_eq!(0, x);\n /// ```\n+///\n+/// *Incorrect* usage of this function: initializing a reference with zero.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n@@ -498,130 +450,23 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This is incredibly dangerous and should not be done lightly. Deeply\n-/// consider initializing your memory with a default value instead.**\n-///\n-/// This is useful for FFI functions and initializing arrays sometimes,\n-/// but should generally be avoided.\n-///\n-/// # Undefined behavior\n-///\n-/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n-/// uninitialized boolean. For instance, if you branch on the value of such\n-/// a boolean, your program may take one, both, or neither of the branches.\n-///\n-/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n-/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n-/// value and its fields if you try to overwrite it in a normal manner. The only way\n-/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n-/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n-///\n-/// If the value does implement [`Drop`], it must be initialized before\n-/// it goes out of scope (and therefore would be dropped). Note that this\n-/// includes a `panic` occurring and unwinding the stack suddenly.\n+/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n ///\n-/// If you partially initialize an array, you may need to use\n-/// [`ptr::drop_in_place`][drop_in_place] to remove the elements you have fully\n-/// initialized followed by [`mem::forget`][mem_forget] to prevent drop running\n-/// on the array. If a partially allocated array is dropped this will lead to\n-/// undefined behaviour.\n-///\n-/// # Examples\n-///\n-/// Here's how to safely initialize an array of [`Vec`]s.\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// // Only declare the array. This safely leaves it\n-/// // uninitialized in a way that Rust will track for us.\n-/// // However we can't initialize it element-by-element\n-/// // safely, and we can't use the `[value; 1000]`\n-/// // constructor because it only works with `Copy` data.\n-/// let mut data: [Vec<u32>; 1000];\n-///\n-/// unsafe {\n-///     // So we need to do this to initialize it.\n-///     data = mem::uninitialized();\n-///\n-///     // DANGER ZONE: if anything panics or otherwise\n-///     // incorrectly reads the array here, we will have\n-///     // Undefined Behavior.\n-///\n-///     // It's ok to mutably iterate the data, since this\n-///     // doesn't involve reading it at all.\n-///     // (ptr and len are statically known for arrays)\n-///     for elem in &mut data[..] {\n-///         // *elem = Vec::new() would try to drop the\n-///         // uninitialized memory at `elem` -- bad!\n-///         //\n-///         // Vec::new doesn't allocate or do really\n-///         // anything. It's only safe to call here\n-///         // because we know it won't panic.\n-///         ptr::write(elem, Vec::new());\n-///     }\n-///\n-///     // SAFE ZONE: everything is initialized.\n-/// }\n-///\n-/// println!(\"{:?}\", &data[0]);\n-/// ```\n-///\n-/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n-/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n-/// value that is only [`Clone`], so the following is semantically equivalent and\n-/// vastly less dangerous, as long as you can live with an extra heap\n-/// allocation:\n-///\n-/// ```\n-/// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n-/// println!(\"{:?}\", &data[0]);\n-/// ```\n-///\n-/// This example shows how to handle partially initialized arrays, which could\n-/// be found in low-level datastructures.\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// // Count the number of elements we have assigned.\n-/// let mut data_len: usize = 0;\n-/// let mut data: [String; 1000];\n-///\n-/// unsafe {\n-///     data = mem::uninitialized();\n-///\n-///     for elem in &mut data[0..500] {\n-///         ptr::write(elem, String::from(\"hello\"));\n-///         data_len += 1;\n-///     }\n-///\n-///     // For each item in the array, drop if we allocated it.\n-///     for i in &mut data[0..data_len] {\n-///         ptr::drop_in_place(i);\n-///     }\n-/// }\n-/// // Forget the data. If this is allowed to drop, you may see a crash such as:\n-/// // 'mem_uninit_test(2457,0x7fffb55dd380) malloc: *** error for object\n-/// // 0x7ff3b8402920: pointer being freed was not allocated'\n-/// mem::forget(data);\n-/// ```\n+/// The reason for deprecation is that the function basically cannot be used\n+/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n+/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n+/// undefined behavior for returning a `bool` that is not definitely either `true`\n+/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+/// is special in that the compiler knows that it does not have a fixed value.\n+/// This makes it undefined behavior to have uninitialized data in a variable even\n+/// if that variable has an integer type.\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n ///\n-/// [`Vec`]: ../../std/vec/struct.Vec.html\n-/// [`vec!`]: ../../std/macro.vec.html\n-/// [`Clone`]: ../../std/clone/trait.Clone.html\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [write]: ../ptr/fn.write.html\n-/// [drop_in_place]: ../ptr/fn.drop_in_place.html\n-/// [mem_zeroed]: fn.zeroed.html\n-/// [mem_forget]: fn.forget.html\n-/// [copy]: ../intrinsics/fn.copy.html\n-/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n-/// [`Drop`]: ../ops/trait.Drop.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n #[inline]\n-#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninit` instead\")]\n+#[rustc_deprecated(since = \"1.40.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n@@ -899,7 +744,6 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     }\n }\n \n-// FIXME: Reference `MaybeUninit` from these docs, once that is stable.\n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///\n /// This wrapper is 0-cost.\n@@ -908,6 +752,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// As a consequence, it has *no effect* on the assumptions that the compiler makes\n /// about all values being initialized at their type.  In particular, initializing\n /// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n ///\n /// # Examples\n ///\n@@ -942,6 +787,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// ```\n ///\n /// [`mem::zeroed`]: fn.zeroed.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -1042,17 +888,18 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A wrapper to construct uninitialized instances of `T`.\n+/// A wrapper type to construct uninitialized instances of `T`.\n+///\n+/// # Initialization invariant\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n /// at their respective type. For example, a variable of reference type must\n /// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n /// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous undefined behavior, no matter whether that reference\n+/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n@@ -1067,7 +914,6 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -1078,10 +924,9 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// Moreover, uninitialized memory is special in that the compiler knows that\n /// it does not have a fixed value. This makes it undefined behavior to have\n /// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any bit pattern:\n+/// which otherwise can hold any *fixed* bit pattern:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -1091,37 +936,154 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n ///\n+/// On top of that, remember that most types have additional invariants beyond merely\n+/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+/// is considered initialized because the only requirement the compiler knows about it\n+/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+/// *immediate* undefined behavior, but will cause undefined behavior with most\n+/// safe operations (including dropping it).\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+///\n+/// # Examples\n+///\n /// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n /// It is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n ///\n /// ```rust\n-/// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n /// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninit();\n /// // Set it to a valid value.\n-/// x.write(&0);\n+/// unsafe { x.as_mut_ptr().write(&0); }\n /// // Extract the initialized data -- this is only allowed *after* properly\n /// // initializing `x`!\n /// let x = unsafe { x.assume_init() };\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n-//\n-// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n+///\n+/// ## out-pointers\n+///\n+/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n+/// from a function, pass it a pointer to some (uninitialized) memory to put the\n+/// result into. This can be useful when it is important for the caller to control\n+/// how the memory the result is stored in gets allocated, and you want to avoid\n+/// unnecessary moves.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+///\n+/// unsafe fn make_vec(out: *mut Vec<i32>) {\n+///     // `write` does not drop the old contents, which is important.\n+///     out.write(vec![1, 2, 3]);\n+/// }\n+///\n+/// let mut v: MaybeUninit<Vec<i32>> = MaybeUninit::uninit();\n+/// unsafe { make_vec(v.as_mut_ptr()); }\n+/// // Now we know `v` is initialized! This also makes sure the vector gets\n+/// // properly dropped.\n+/// let v = unsafe { v.assume_init() };\n+/// assert_eq!(&v, &[1, 2, 3]);\n+/// ```\n+///\n+/// ## Initializing an array element-by-element\n+///\n+/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n+///\n+/// ```\n+/// use std::mem::{self, MaybeUninit};\n+/// use std::ptr;\n+///\n+/// let data = {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n+///         MaybeUninit::uninit().assume_init()\n+///     };\n+///\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n+///     for elem in &mut data[..] {\n+///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n+///     }\n+///\n+///     // Everything is initialized. Transmute the array to the\n+///     // initialized type.\n+///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n+/// };\n+///\n+/// assert_eq!(&data[0], &[42]);\n+/// ```\n+///\n+/// You can also work with partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr;\n+///\n+/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+/// // safe because the type we are claiming to have initialized here is a\n+/// // bunch of `MaybeUninit`s, which do not require initialization.\n+/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n+///\n+/// for elem in &mut data[0..500] {\n+///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n+///     data_len += 1;\n+/// }\n+///\n+/// // For each item in the array, drop if we allocated it.\n+/// for elem in &mut data[0..data_len] {\n+///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+/// }\n+/// ```\n+///\n+/// ## Initializing a struct field-by-field\n+///\n+/// There is currently no supported way to create a raw pointer or reference\n+/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n+/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n+/// to its fields.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Layout\n+///\n+/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+///\n+/// ```rust\n+/// use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n+/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n+/// ```\n+///\n+/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n+/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n+/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n+/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n+/// optimizations, potentially resulting in a larger size:\n+///\n+/// ```rust\n+/// # use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<Option<bool>>(), 1);\n+/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n+/// ```\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n #[derive(Copy)]\n-// NOTE: after stabilizing `MaybeUninit`, proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n }\n \n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n impl<T: Copy> Clone for MaybeUninit<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n@@ -1132,10 +1094,13 @@ impl<T: Copy> Clone for MaybeUninit<T> {\n \n impl<T> MaybeUninit<T> {\n     /// Creates a new `MaybeUninit<T>` initialized with the given value.\n+    /// It is safe to call [`assume_init`] on the return value of this function.\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    ///\n+    /// [`assume_init`]: #method.assume_init\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub const fn new(val: T) -> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n@@ -1145,7 +1110,11 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    ///\n+    /// See the [type-level documentation][type] for some examples.\n+    ///\n+    /// [type]: union.MaybeUninit.html\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub const fn uninit() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n@@ -1166,7 +1135,6 @@ impl<T> MaybeUninit<T> {\n     /// fields of the struct can hold the bit-pattern 0 as a valid value.\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n@@ -1178,7 +1146,6 @@ impl<T> MaybeUninit<T> {\n     /// cannot hold 0 as a valid value.\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// enum NotZero { One = 1, Two = 2 };\n@@ -1188,7 +1155,7 @@ impl<T> MaybeUninit<T> {\n     /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n     /// // This is undefined behavior.\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n@@ -1202,7 +1169,7 @@ impl<T> MaybeUninit<T> {\n     /// without dropping it, so be careful not to use this twice unless you want to\n     /// skip running the destructor. For your convenience, this also returns a mutable\n     /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n@@ -1213,13 +1180,14 @@ impl<T> MaybeUninit<T> {\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n+    /// (except inside an `UnsafeCell<T>`).\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1232,7 +1200,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1242,7 +1209,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n@@ -1256,7 +1223,6 @@ impl<T> MaybeUninit<T> {\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1271,7 +1237,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1281,7 +1246,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n@@ -1294,15 +1259,17 @@ impl<T> MaybeUninit<T> {\n     /// # Safety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// [inv]: #initialization-invariant\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<bool>::uninit();\n@@ -1314,14 +1281,13 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_init = unsafe { x.assume_init() };\n     /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub unsafe fn assume_init(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n@@ -1338,21 +1304,23 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n     ///\n     /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n     /// multiple copies of the data (by calling `read` multiple times, or first\n     /// calling `read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n+    /// [inv]: #initialization-invariant\n     /// [`assume_init`]: #method.assume_init\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n+    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<u32>::uninit();\n@@ -1373,7 +1341,7 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n+    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n@@ -1383,7 +1351,7 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();"}, {"sha": "dd321dcdfae6c8ab200a688aff273c8eb940854f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -155,12 +155,12 @@ pub use crate::intrinsics::write_bytes;\n /// location first:\n /// ```\n /// use std::ptr;\n-/// use std::mem;\n+/// use std::mem::{self, MaybeUninit};\n ///\n /// unsafe fn drop_after_copy<T>(to_drop: *mut T) {\n-///     let mut copy: T = mem::uninitialized();\n-///     ptr::copy(to_drop, &mut copy, 1);\n-///     drop(copy);\n+///     let mut copy: MaybeUninit<T> = MaybeUninit::uninit();\n+///     ptr::copy(to_drop, copy.as_mut_ptr(), 1);\n+///     drop(copy.assume_init());\n /// }\n ///\n /// #[repr(packed, C)]"}, {"sha": "e044b46e0d0763252baf5254a69fe57f88d1e5b8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -272,7 +272,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n-#![feature(maybe_uninit)]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]"}, {"sha": "5004f787cde190725b2b5d3b69a117a319fcb0a6", "filename": "src/test/codegen/box-maybe-uninit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -1,6 +1,5 @@\n // compile-flags: -O\n #![crate_type=\"lib\"]\n-#![feature(maybe_uninit)]\n \n use std::mem::MaybeUninit;\n "}, {"sha": "4ca4b407bd4ff2b70ca60e3aed042874bc8efcec", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d35181ad8785fa958e43580a29a982afe02c728f/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d35181ad8785fa958e43580a29a982afe02c728f/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -2,7 +2,7 @@\n // This test checks that instantiating an uninhabited type via `mem::{uninitialized,zeroed}` results\n // in a runtime panic.\n \n-#![feature(never_type, maybe_uninit)]\n+#![feature(never_type)]\n \n use std::{mem, panic};\n "}, {"sha": "0c85dbf3df0f545133dca24eccfc9f0f6107c7f8", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=d35181ad8785fa958e43580a29a982afe02c728f", "patch": "@@ -1 +1 @@\n-Subproject commit 37b2eea7144d022702f0d2eedcc4c776db15d078\n+Subproject commit 0c85dbf3df0f545133dca24eccfc9f0f6107c7f8"}]}