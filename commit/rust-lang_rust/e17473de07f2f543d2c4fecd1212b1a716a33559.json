{"sha": "e17473de07f2f543d2c4fecd1212b1a716a33559", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNzQ3M2RlMDdmMmY1NDNkMmM0ZmVjZDEyMTJiMWE3MTZhMzM1NTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-15T23:10:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-15T23:10:41Z"}, "message": "rustc: Move next_var_id back to the crate context in typechecking; we'll need it when collecting item types", "tree": {"sha": "efa8d88643ef3c53dc8511b7bfac936b05e384ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efa8d88643ef3c53dc8511b7bfac936b05e384ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e17473de07f2f543d2c4fecd1212b1a716a33559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e17473de07f2f543d2c4fecd1212b1a716a33559", "html_url": "https://github.com/rust-lang/rust/commit/e17473de07f2f543d2c4fecd1212b1a716a33559", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e17473de07f2f543d2c4fecd1212b1a716a33559/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1b236698386f4357f31068d624047c8b9037184", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b236698386f4357f31068d624047c8b9037184", "html_url": "https://github.com/rust-lang/rust/commit/d1b236698386f4357f31068d624047c8b9037184"}], "stats": {"total": 61, "additions": 39, "deletions": 22}, "files": [{"sha": "c3fafd570be8490ae9f9bb4f1259a994e1f7c424", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e17473de07f2f543d2c4fecd1212b1a716a33559/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17473de07f2f543d2c4fecd1212b1a716a33559/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e17473de07f2f543d2c4fecd1212b1a716a33559", "patch": "@@ -18,11 +18,11 @@ import std.option.some;\n \n type ty_table = hashmap[ast.def_id, @ty];\n type crate_ctxt = rec(session.session sess,\n-                      @ty_table item_types);\n+                      @ty_table item_types,\n+                      mutable int next_var_id);\n \n type fn_ctxt = rec(@ty ret_ty,\n                    @ty_table locals,\n-                   mutable int next_var_id,\n                    @crate_ctxt ccx);\n \n type arg = rec(ast.mode mode, @ty ty);\n@@ -49,7 +49,7 @@ tag sty {\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n-    // TODO: ty_param(ast.def_id), for fn type params\n+    ty_param(ast.def_id);                           // fn type param\n     // TODO: ty_fn_arg(@ty), for a possibly-aliased function argument\n }\n \n@@ -249,6 +249,11 @@ fn ty_to_str(&@ty typ) -> str {\n         case (ty_var(?v)) {\n             s = \"<T\" + util.common.istr(v) + \">\";\n         }\n+\n+        case (ty_param(?id)) {\n+            s = \"<P\" + util.common.istr(id._0) + \":\" + util.common.istr(id._1)\n+                + \">\";\n+        }\n     }\n \n     ret s;\n@@ -299,16 +304,17 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n-            auto def_id;\n             check (def != none[ast.def]);\n             alt (option.get[ast.def](def)) {\n-                case (ast.def_ty(?id)) { def_id = id; }\n-                case (_) { fail; }\n+                case (ast.def_ty(?id)) {\n+                    // TODO: maybe record cname chains so we can do\n+                    // \"foo = int\" like OCaml?\n+                    sty = getter(id).struct;\n+                }\n+                case (ast.def_ty_arg(?id))  { sty = ty_param(id); }\n+                case (_)                    { fail; }\n             }\n \n-            // TODO: maybe record cname chains so we can do \"foo = int\" like\n-            // OCaml?\n-            sty = getter(def_id).struct;\n             cname = some(path_to_str(path));\n         }\n \n@@ -1184,6 +1190,20 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n                 ret result;\n             }\n+\n+            case (ty_param(?expected_id)) {\n+                alt (actual.struct) {\n+                    case (ty_param(?actual_id)) {\n+                        if (expected_id._0 == actual_id._0 &&\n+                                expected_id._1 == actual_id._1) {\n+                            ret ures_ok(expected);\n+                        }\n+                    }\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n         }\n \n         // TODO: remove me once match-exhaustiveness checking works\n@@ -1495,10 +1515,10 @@ fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {\n-            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx)));\n+            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx.ccx)));\n         }\n         case (ast.pat_bind(?id, ?def_id, _)) {\n-            auto ann = ast.ann_type(next_ty_var(fcx));\n+            auto ann = ast.ann_type(next_ty_var(fcx.ccx));\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, _)) {\n@@ -1760,7 +1780,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n \n             // Now typecheck the blocks.\n-            auto result_ty = next_ty_var(fcx);\n+            auto result_ty = next_ty_var(fcx.ccx);\n \n             let vec[ast.block] blocks_0 = vec();\n             for (ast.arm arm in arms) {\n@@ -1802,7 +1822,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 // FIXME: this breaks aliases. We need a ty_fn_arg.\n                 append[arg](arg_tys_0, rec(mode=ast.val, ty=expr_ty(a_0)));\n             }\n-            auto rt_0 = next_ty_var(fcx);\n+            auto rt_0 = next_ty_var(fcx.ccx);\n             auto t_0 = plain_ty(ty_fn(arg_tys_0, rt_0));\n \n             // Unify and write back to the function.\n@@ -1866,7 +1886,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             let @ty t;\n             if (_vec.len[@ast.expr](args) == 0u) {\n-                t = next_ty_var(fcx);\n+                t = next_ty_var(fcx.ccx);\n             } else {\n                 auto expr_1 = check_expr(fcx, args.(0));\n                 t = expr_ty(expr_1);\n@@ -2013,9 +2033,9 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     }\n }\n \n-fn next_ty_var(&fn_ctxt fcx) -> @ty {\n-    auto t = plain_ty(ty_var(fcx.next_var_id));\n-    fcx.next_var_id += 1;\n+fn next_ty_var(@crate_ctxt ccx) -> @ty {\n+    auto t = plain_ty(ty_var(ccx.next_var_id));\n+    ccx.next_var_id += 1;\n     ret t;\n }\n \n@@ -2030,7 +2050,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n                     alt (local.ty) {\n                         case (none[@ast.ty]) {\n                             // Auto slot. Assign a ty_var.\n-                            local_ty = next_ty_var(fcx);\n+                            local_ty = next_ty_var(fcx.ccx);\n                         }\n \n                         case (some[@ast.ty](?ast_ty)) {\n@@ -2133,7 +2153,6 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     auto rty = ann_to_type(ann);\n     let fn_ctxt fcx = rec(ret_ty = rty,\n                           locals = @common.new_def_hash[@ty](),\n-                          mutable next_var_id = 0,\n                           ccx = ccx);\n     auto e_ = check_expr(fcx, e);\n     // FIXME: necessary? Correct sequence?\n@@ -2165,7 +2184,6 @@ fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n \n     let fn_ctxt fcx = rec(ret_ty = output_ty,\n                           locals = local_ty_table,\n-                          mutable next_var_id = 0,\n                           ccx = ccx);\n \n     // TODO: Make sure the type of the block agrees with the function type.\n@@ -2181,8 +2199,7 @@ fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto result = collect_item_types(crate);\n \n-    auto ccx = @rec(sess=sess,\n-                    item_types=result._1);\n+    auto ccx = @rec(sess=sess, item_types=result._1, mutable next_var_id=0);\n \n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n     auto f = check_fn;  // FIXME: trans_const_lval bug"}]}