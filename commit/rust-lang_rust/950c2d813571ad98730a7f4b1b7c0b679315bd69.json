{"sha": "950c2d813571ad98730a7f4b1b7c0b679315bd69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MGMyZDgxMzU3MWFkOTg3MzBhN2Y0YjFiN2MwYjY3OTMxNWJkNjk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-11T10:41:02Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-07-23T07:19:24Z"}, "message": "Add huge explanation for E0038 (object safety)", "tree": {"sha": "bfe21bc61afd4e449b5c4cee15fb4db745c791a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe21bc61afd4e449b5c4cee15fb4db745c791a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/950c2d813571ad98730a7f4b1b7c0b679315bd69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/950c2d813571ad98730a7f4b1b7c0b679315bd69", "html_url": "https://github.com/rust-lang/rust/commit/950c2d813571ad98730a7f4b1b7c0b679315bd69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/950c2d813571ad98730a7f4b1b7c0b679315bd69/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a84bc82169bfdd0c67c519e710ba4488b82d55", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a84bc82169bfdd0c67c519e710ba4488b82d55", "html_url": "https://github.com/rust-lang/rust/commit/37a84bc82169bfdd0c67c519e710ba4488b82d55"}], "stats": {"total": 251, "additions": 250, "deletions": 1}, "files": [{"sha": "949f4457aa3240fcf58d04b13a27f09d710940ec", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 250, "deletions": 1, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/950c2d813571ad98730a7f4b1b7c0b679315bd69/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/950c2d813571ad98730a7f4b1b7c0b679315bd69/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=950c2d813571ad98730a7f4b1b7c0b679315bd69", "patch": "@@ -428,6 +428,256 @@ match 5u32 {\n ```\n \"##,\n \n+E0038: r####\"\n+\n+Trait objects like `Box<Trait>`, can only be constructed when certain\n+requirements are obeyed by the trait in question.\n+\n+Trait objects are a form of dynamic dispatch and use dynamically sized types.\n+So, for a given trait `Trait`, when `Trait` is treated as a type, as in\n+`Box<Trait>`, the inner type is \"unsized\". In such cases the boxed pointer is a\n+\"fat pointer\" and contains an extra pointer to a method table for dynamic\n+dispatch. This design mandates some restrictions on the types of traits that are\n+allowed to be used in trait objects, which are collectively termed as \"object\n+safety\" rules.\n+\n+Attempting to create a trait object for a non object-safe trait will trigger\n+this error.\n+\n+\n+There are various rules:\n+\n+### The trait cannot require `Self: Sized`\n+\n+When `Trait` is treated as a type, the type does not implement the special\n+`Sized` trait, because the type does not have a known size at compile time and\n+can only be accessed behind a pointer. Thus, if we have a trait like the\n+following:\n+\n+```\n+trait Foo where Self: Sized {\n+\n+}\n+```\n+\n+we cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+`Self` would not be `Sized`.\n+\n+Generally `Self : Sized` is used to indicate that the trait should not be used\n+as a trait object. If the trait comes from your own crate, consider removing\n+this restriction.\n+\n+### Method references the `Self` type in its arguments or return type\n+\n+This happens when a trait has a method like the following:\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+impl Trait for String {\n+    fn foo(&self) -> Self {\n+        \"hi\".to_owned()\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) -> Self {\n+        1\n+    }\n+}\n+```\n+\n+In such a case, the compiler cannot predict the return type of `foo()` in a case\n+like the following:\n+\n+```\n+fn call_foo(x: Box<Trait>) {\n+    let y = x.foo(); // What type is y?\n+    // ...\n+}\n+```\n+\n+If the offending method isn't actually being called on the trait object, you can\n+add a `where Self: Sized` bound on the method:\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self where Self: Sized;\n+    // more functions\n+}\n+```\n+\n+Now, `foo()` can no longer be called on the trait object, but you will be\n+allowed to call other trait methods and construct the trait objects. With such a\n+bound, one can still call `foo()` on types implementing that trait that aren't\n+behind trait objects.\n+\n+### Method has generic type parameters\n+\n+As mentioned before, trait objects contain pointers to method tables. So, if we\n+have\n+\n+```\n+trait Trait {\n+    fn foo(&self);\n+}\n+impl Trait for String {\n+    fn foo(&self) {\n+        // implementation 1\n+    }\n+}\n+impl Trait for u8 {\n+    fn foo(&self) {\n+        // implementation 2\n+    }\n+}\n+// ...\n+```\n+\n+at compile time a table of all implementations of `Trait`, containing pointers\n+to the implementation of `foo()` would be generated.\n+\n+This works fine, but when we the method gains generic parameters, we can have a\n+problem.\n+\n+Usually, generic parameters get _monomorphized_. For example, if I have\n+\n+```\n+fn foo<T>(x: T) {\n+    // ...\n+}\n+```\n+\n+the machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n+other type substitution is different. Hence the compiler generates the\n+implementation on-demand. If you call `foo()` with a `bool` parameter, the\n+compiler will only generate code for `foo::<bool>()`. When we have additional\n+type parameters, the number of monomorphized implementations the compiler\n+generates does not grow drastically, since the compiler will only generate an\n+implementation if the function is called with hard substitutions.\n+\n+However, with trait objects we have to make a table containing _every object\n+that implements the trait_. Now, if it has type parameters, we need to add\n+implementations for every type that implements the trait, bloating the table\n+quickly.\n+\n+For example, with\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T);\n+    // more methods\n+}\n+impl Trait for String {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 1\n+    }\n+}\n+impl Trait for u8 {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 2\n+    }\n+}\n+// 8 more implementations\n+```\n+\n+Now, if I have the following code:\n+\n+```\n+fn call_foo(thing: Box<Trait>) {\n+    thing.foo(true); // this could be any one of the 8 types above\n+    thing.foo(1);\n+    thing.foo(\"hello\");\n+}\n+```\n+\n+we don't just need to create a table of all implementations of all methods of\n+`Trait`, we need to create a table of all implementations of `foo()`, _for each\n+different type fed to `foo()`_. In this case this turns out to be (10 types\n+implementing `Trait`)*(3 types being fed to `foo()`) = 30 implementations!\n+\n+With real world traits these numbers can grow drastically.\n+\n+To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n+fix for the sub-error above if you do not intend to call the method with type\n+parameters:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T) where Self: Sized;\n+    // more methods\n+}\n+```\n+\n+If this is not an option, consider replacing the type parameter with another\n+trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number\n+of types you intend to feed to this method is limited, consider manually listing\n+out the methods of different types.\n+\n+### Method has no receiver\n+\n+Methods that do not take a `self` parameter can't be called since there won't be\n+a way to get a pointer to the method table for them\n+\n+```\n+trait Foo {\n+    fn foo() -> u8;\n+}\n+```\n+\n+This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n+an implementation.\n+\n+Adding a `Self: Sized` bound to these methods will generally make this compile.\n+\n+\n+```\n+trait Foo {\n+    fn foo() -> u8 where Self: Sized;\n+}\n+```\n+\n+### The trait cannot use `Self` as a type parameter in the supertrait listing\n+\n+This is similar to the second sub-error, but subtler. It happens in situations\n+like the following:\n+\n+```\n+trait Super<A> {}\n+\n+trait Trait: Super<Self> {\n+}\n+\n+struct Foo;\n+\n+impl Super<Foo> for Foo{}\n+\n+impl Trait for Foo {}\n+```\n+\n+Here, the supertrait might have methods as follows:\n+\n+```\n+trait Super<A> {\n+    fn get_a(&self) -> A; // note that this is object safe!\n+}\n+```\n+\n+If the trait `Foo` was deriving from something like `Super<String>` or\n+`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n+`get_a()` will definitely return an object of that type.\n+\n+However, if it derives from `Super<Self>`, the method `get_a()` would return an\n+object of unknown type when called on the function, _even though `Super` is\n+object safe_. `Self` type parameters let us make object safe traits no longer\n+safe, so they are forbidden when specifying supertraits.\n+\n+There's no easy fix for this, generally code will need to be refactored so that\n+you no longer need to derive from `Super<Self>`.\n+\n+\"####,\n+\n E0079: r##\"\n Enum variants which contain no data can be given a custom integer\n representation. This error indicates that the value provided is not an\n@@ -1295,7 +1545,6 @@ contain references (with a maximum lifetime of `'a`).\n \n register_diagnostics! {\n     // E0006 // merged with E0005\n-    E0038,\n //  E0134,\n //  E0135,\n     E0136,"}]}