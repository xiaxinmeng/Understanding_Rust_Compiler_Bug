{"sha": "1301422a6c2e8916560b8cc2f0564f38d8858a75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMDE0MjJhNmMyZTg5MTY1NjBiOGNjMmYwNTY0ZjM4ZDg4NThhNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-21T03:25:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-21T03:25:05Z"}, "message": "Auto merge of #60913 - spastorino:place2_4, r=oli-obk\n\nPlace 2.0 change from enum to struct\n\nr? @oli-obk", "tree": {"sha": "90b9983673a3961a15ad90e87674f50e9c80b5b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90b9983673a3961a15ad90e87674f50e9c80b5b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1301422a6c2e8916560b8cc2f0564f38d8858a75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1301422a6c2e8916560b8cc2f0564f38d8858a75", "html_url": "https://github.com/rust-lang/rust/commit/1301422a6c2e8916560b8cc2f0564f38d8858a75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1301422a6c2e8916560b8cc2f0564f38d8858a75/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b1fe560d2bd8472f250fb8cfd2168520a58405", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b1fe560d2bd8472f250fb8cfd2168520a58405", "html_url": "https://github.com/rust-lang/rust/commit/95b1fe560d2bd8472f250fb8cfd2168520a58405"}, {"sha": "a8ceeeb5a0f4a5d274ef7a0f434c5d16e09f864b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ceeeb5a0f4a5d274ef7a0f434c5d16e09f864b", "html_url": "https://github.com/rust-lang/rust/commit/a8ceeeb5a0f4a5d274ef7a0f434c5d16e09f864b"}], "stats": {"total": 2724, "additions": 1735, "deletions": 989}, "files": [{"sha": "d8b641fbe31f483dc1649f5aec61aa8d0dca704d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 101, "deletions": 40, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -1718,11 +1718,11 @@ impl<'tcx> Debug for Statement<'tcx> {\n #[derive(\n     Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n-pub enum Place<'tcx> {\n-    Base(PlaceBase<'tcx>),\n+pub struct Place<'tcx> {\n+    pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    Projection(Box<Projection<'tcx>>),\n+    pub projection: Option<Box<Projection<'tcx>>>,\n }\n \n #[derive(\n@@ -1761,7 +1761,7 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n pub struct Projection<'tcx> {\n-    pub base: Place<'tcx>,\n+    pub base: Option<Box<Projection<'tcx>>>,\n     pub elem: PlaceElem<'tcx>,\n }\n \n@@ -1826,8 +1826,17 @@ newtype_index! {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct PlaceRef<'a, 'tcx> {\n+    pub base: &'a PlaceBase<'tcx>,\n+    pub projection: &'a Option<Box<Projection<'tcx>>>,\n+}\n+\n impl<'tcx> Place<'tcx> {\n-    pub const RETURN_PLACE: Place<'tcx> = Place::Base(PlaceBase::Local(RETURN_PLACE));\n+    pub const RETURN_PLACE: Place<'tcx> = Place {\n+        base: PlaceBase::Local(RETURN_PLACE),\n+        projection: None,\n+    };\n \n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n@@ -1853,7 +1862,10 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n-        Place::Projection(Box::new(Projection { base: self, elem }))\n+        Place {\n+            base: self.base,\n+            projection: Some(Box::new(Projection { base: self.projection, elem })),\n+        }\n     }\n \n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n@@ -1862,54 +1874,77 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n-            Place::Base(PlaceBase::Local(local))\n-            | Place::Projection(box Projection {\n-                base: Place::Base(PlaceBase::Local(local)),\n-                elem: ProjectionElem::Deref,\n-            }) => Some(*local),\n+            Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } |\n+            Place {\n+                base: PlaceBase::Local(local),\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } => Some(*local),\n             _ => None,\n         }\n     }\n \n-    /// Finds the innermost `Local` from this `Place`.\n-    pub fn base_local(&self) -> Option<Local> {\n-        let mut place = self;\n-        loop {\n-            match place {\n-                Place::Projection(proj) => place = &proj.base,\n-                Place::Base(PlaceBase::Static(_)) => return None,\n-                Place::Base(PlaceBase::Local(local)) => return Some(*local),\n-            }\n-        }\n-    }\n-\n     /// Recursively \"iterates\" over place components, generating a `PlaceBase` and\n     /// `Projections` list and invoking `op` with a `ProjectionsIter`.\n     pub fn iterate<R>(\n         &self,\n         op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n     ) -> R {\n-        self.iterate2(&Projections::Empty, op)\n+        Place::iterate_over(&self.base, &self.projection, op)\n     }\n \n-    fn iterate2<R>(\n-        &self,\n-        next: &Projections<'_, 'tcx>,\n+    pub fn iterate_over<R>(\n+        place_base: &PlaceBase<'tcx>,\n+        place_projection: &Option<Box<Projection<'tcx>>>,\n         op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n     ) -> R {\n-        match self {\n-            Place::Projection(interior) => {\n-                interior.base.iterate2(&Projections::List { projection: interior, next }, op)\n+        fn iterate_over2<'tcx, R>(\n+            place_base: &PlaceBase<'tcx>,\n+            place_projection: &Option<Box<Projection<'tcx>>>,\n+            next: &Projections<'_, 'tcx>,\n+            op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n+        ) -> R {\n+            match place_projection {\n+                None => {\n+                    op(place_base, next.iter())\n+                }\n+\n+                Some(interior) => {\n+                    iterate_over2(\n+                        place_base,\n+                        &interior.base,\n+                        &Projections::List {\n+                            projection: interior,\n+                            next,\n+                        },\n+                        op,\n+                    )\n+                }\n             }\n+        }\n \n-            Place::Base(base) => op(base, next.iter()),\n+        iterate_over2(place_base, place_projection, &Projections::Empty, op)\n+    }\n+\n+    pub fn as_place_ref(&self) -> PlaceRef<'_, 'tcx> {\n+        PlaceRef {\n+            base: &self.base,\n+            projection: &self.projection,\n         }\n     }\n }\n \n impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n-        Place::Base(local.into())\n+        Place {\n+            base: local.into(),\n+            projection: None,\n+        }\n     }\n }\n \n@@ -1919,6 +1954,36 @@ impl From<Local> for PlaceBase<'_> {\n     }\n }\n \n+impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n+    pub fn iterate<R>(\n+        &self,\n+        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n+    ) -> R {\n+        Place::iterate_over(self.base, self.projection, op)\n+    }\n+\n+    /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n+    /// a single deref of a local.\n+    //\n+    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n+    pub fn local_or_deref_local(&self) -> Option<Local> {\n+        match self {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } |\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } => Some(*local),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// A linked list of projections running up the stack; begins with the\n /// innermost projection and extends to the outermost (e.g., `a.b.c`\n /// would have the place `b` with a \"next\" pointer to `b.c`).\n@@ -3155,18 +3220,14 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match self {\n-            &Place::Projection(ref p) => Place::Projection(p.fold_with(folder)),\n-            _ => self.clone(),\n+        Place {\n+            base: self.base.clone(),\n+            projection: self.projection.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        if let &Place::Projection(ref p) = self {\n-            p.visit_with(visitor)\n-        } else {\n-            false\n-        }\n+        self.projection.visit_with(visitor)\n     }\n }\n "}, {"sha": "e2f5d192281a7e5153da64fd3f8a2f2ecb11dd74", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -118,11 +118,15 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n-    where\n-        D: HasLocalDecls<'tcx>,\n+    pub fn ty_from<D>(\n+        base: &PlaceBase<'tcx>,\n+        projection: &Option<Box<Projection<'tcx>>>,\n+        local_decls: &D,\n+        tcx: TyCtxt<'tcx>\n+    ) -> PlaceTy<'tcx>\n+        where D: HasLocalDecls<'tcx>\n     {\n-        self.iterate(|place_base, place_projections| {\n+        Place::iterate_over(base, projection, |place_base, place_projections| {\n             let mut place_ty = place_base.ty(local_decls);\n \n             for proj in place_projections {\n@@ -132,6 +136,13 @@ impl<'tcx> Place<'tcx> {\n             place_ty\n         })\n     }\n+\n+    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n+    {\n+        Place::ty_from(&self.base, &self.projection, local_decls, tcx)\n+    }\n }\n \n impl<'tcx> PlaceBase<'tcx> {"}, {"sha": "c3a4566b5aee3834ac5d1974c26b82a80fb5abca", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -159,10 +159,11 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_projection(&mut self,\n+                                place_base: & $($mutability)? PlaceBase<'tcx>,\n                                 place: & $($mutability)? Projection<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place, context, location);\n+                self.super_projection(place_base, place, context, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -676,19 +677,20 @@ macro_rules! make_mir_visitor {\n                             place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext,\n                             location: Location) {\n-                match place {\n-                    Place::Base(place_base) => {\n-                        self.visit_place_base(place_base, context, location);\n-                    }\n-                    Place::Projection(proj) => {\n-                        let context = if context.is_mutating_use() {\n-                            PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                        } else {\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                        };\n+                let mut context = context;\n+\n+                if place.projection.is_some() {\n+                    context = if context.is_mutating_use() {\n+                        PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+                    } else {\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+                    };\n+                }\n \n-                        self.visit_projection(proj, context, location);\n-                    }\n+                self.visit_place_base(& $($mutability)? place.base, context, location);\n+\n+                if let Some(box proj) = & $($mutability)? place.projection {\n+                    self.visit_projection(& $($mutability)? place.base, proj, context, location);\n                 }\n             }\n \n@@ -707,13 +709,14 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection(&mut self,\n+                                place_base: & $($mutability)? PlaceBase<'tcx>,\n                                 proj: & $($mutability)? Projection<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                // this is calling `super_place` in preparation for changing `Place` to be\n-                // a struct with a base and a slice of projections. `visit_place` should only ever\n-                // be called for the outermost place now.\n-                self.super_place(& $($mutability)? proj.base, context, location);\n+                if let Some(box proj_base) = & $($mutability)? proj.base {\n+                    self.visit_projection(place_base, proj_base, context, location);\n+                }\n+\n                 match & $($mutability)? proj.elem {\n                     ProjectionElem::Deref => {\n                     }"}, {"sha": "09c346117f9d92ee14a6da3d7aefd21b872bf1ad", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 85, "deletions": 46, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -92,6 +92,86 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             self.first_assignment[local] = location;\n         }\n     }\n+\n+    fn process_place(&mut self,\n+                     place_ref: &mir::PlaceRef<'_, 'tcx>,\n+                     context: PlaceContext,\n+                     location: Location) {\n+        let cx = self.fx.cx;\n+\n+        if let Some(proj) = place_ref.projection {\n+            // Allow uses of projections that are ZSTs or from scalar fields.\n+            let is_consume = match context {\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n+                _ => false\n+            };\n+            if is_consume {\n+                let base_ty =\n+                    mir::Place::ty_from(place_ref.base, &proj.base, self.fx.mir, cx.tcx());\n+                let base_ty = self.fx.monomorphize(&base_ty);\n+\n+                // ZSTs don't require any actual memory access.\n+                let elem_ty = base_ty\n+                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .ty;\n+                let elem_ty = self.fx.monomorphize(&elem_ty);\n+                if cx.layout_of(elem_ty).is_zst() {\n+                    return;\n+                }\n+\n+                if let mir::ProjectionElem::Field(..) = proj.elem {\n+                    let layout = cx.layout_of(base_ty.ty);\n+                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n+                        // Recurse with the same context, instead of `Projection`,\n+                        // potentially stopping at non-operand projections,\n+                        // which would trigger `not_ssa` on locals.\n+                        self.process_place(\n+                            &mir::PlaceRef {\n+                                base: place_ref.base,\n+                                projection: &proj.base,\n+                            },\n+                            context,\n+                            location,\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            // A deref projection only reads the pointer, never needs the place.\n+            if let mir::ProjectionElem::Deref = proj.elem {\n+                self.process_place(\n+                    &mir::PlaceRef {\n+                        base: place_ref.base,\n+                        projection: &proj.base,\n+                    },\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                    location\n+                );\n+                return;\n+            }\n+        }\n+\n+        // FIXME this is super_place code, is repeated here to avoid cloning place or changing\n+        // visit_place API\n+        let mut context = context;\n+\n+        if place_ref.projection.is_some() {\n+            context = if context.is_mutating_use() {\n+                PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+            } else {\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n+            };\n+        }\n+\n+        self.visit_place_base(place_ref.base, context, location);\n+\n+        if let Some(box proj) = place_ref.projection {\n+            self.visit_projection(place_ref.base, proj, context, location);\n+        }\n+    }\n+\n }\n \n impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n@@ -103,7 +183,10 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     location: Location) {\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n+        if let mir::Place {\n+            base: mir::PlaceBase::Local(index),\n+            projection: None,\n+        } = *place {\n             self.assign(index, location);\n             if !self.fx.rvalue_creates_operand(rvalue) {\n                 self.not_ssa(index);\n@@ -155,51 +238,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                    context: PlaceContext,\n                    location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n-        let cx = self.fx.cx;\n-\n-        if let mir::Place::Projection(ref proj) = *place {\n-            // Allow uses of projections that are ZSTs or from scalar fields.\n-            let is_consume = match context {\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n-                _ => false\n-            };\n-            if is_consume {\n-                let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n-                let base_ty = self.fx.monomorphize(&base_ty);\n-\n-                // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty\n-                    .projection_ty(cx.tcx(), &proj.elem)\n-                    .ty;\n-                let elem_ty = self.fx.monomorphize(&elem_ty);\n-                if cx.layout_of(elem_ty).is_zst() {\n-                    return;\n-                }\n-\n-                if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.ty);\n-                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n-                        // Recurse with the same context, instead of `Projection`,\n-                        // potentially stopping at non-operand projections,\n-                        // which would trigger `not_ssa` on locals.\n-                        self.visit_place(&proj.base, context, location);\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            // A deref projection only reads the pointer, never needs the place.\n-            if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_place(\n-                    &proj.base,\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                    location\n-                );\n-            }\n-        }\n-\n-        self.super_place(place, context, location);\n+        self.process_place(&place.as_place_ref(), context, location);\n     }\n \n     fn visit_local(&mut self,"}, {"sha": "d4b434ffe809c217b8807f546991a407bab43c4c", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n-                    self.codegen_consume(&mut bx, &mir::Place::RETURN_PLACE);\n+                    self.codegen_consume(&mut bx, &mir::Place::RETURN_PLACE.as_place_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -314,7 +314,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return\n         }\n \n-        let place = self.codegen_place(&mut bx, location);\n+        let place = self.codegen_place(&mut bx, &location.as_place_ref());\n         let (args1, args2);\n         let mut args = if let Some(llextra) = place.llextra {\n             args2 = [place.llval, llextra];\n@@ -607,18 +607,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n                         mir::Operand::Copy(\n-                            Place::Base(\n-                                PlaceBase::Static(\n-                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n-                                )\n-                            )\n+                            Place {\n+                                base: PlaceBase::Static(box Static {\n+                                    kind: StaticKind::Promoted(promoted),\n+                                    ty,\n+                                }),\n+                                projection: None,\n+                            }\n                         ) |\n                         mir::Operand::Move(\n-                            Place::Base(\n-                                PlaceBase::Static(\n-                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n-                                )\n-                            )\n+                            Place {\n+                                base: PlaceBase::Static(box Static {\n+                                    kind: StaticKind::Promoted(promoted),\n+                                    ty,\n+                                }),\n+                                projection: None,\n+                            }\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n                             let cid = mir::interpret::GlobalId {\n@@ -1098,7 +1102,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let mir::Place::Base(mir::PlaceBase::Local(index)) = *dest {\n+        let dest = if let mir::Place {\n+            base: mir::PlaceBase::Local(index),\n+            projection: None,\n+        } = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n@@ -1128,7 +1135,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n         } else {\n-            self.codegen_place(bx, dest)\n+            self.codegen_place(bx, &mir::PlaceRef {\n+                base: &dest.base,\n+                projection: &dest.projection,\n+            })\n         };\n         if fn_ret.is_indirect() {\n             if dest.align < dest.layout.align.abi {\n@@ -1153,12 +1163,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         src: &mir::Operand<'tcx>,\n         dst: &mir::Place<'tcx>\n     ) {\n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *dst {\n+        if let mir::Place {\n+            base: mir::PlaceBase::Local(index),\n+            projection: None,\n+        } = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(dst));\n+                    let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_place_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n                     place.storage_live(bx);\n@@ -1173,7 +1186,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n         } else {\n-            let dst = self.codegen_place(bx, dst);\n+            let dst = self.codegen_place(bx, &dst.as_place_ref());\n             self.codegen_transmute_into(bx, src, dst);\n         }\n     }"}, {"sha": "0f6a95c1968b8cc0da05db2d0ceab443ced761cf", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -380,11 +380,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn maybe_codegen_consume_direct(\n         &mut self,\n         bx: &mut Bx,\n-        place: &mir::Place<'tcx>\n+        place_ref: &mir::PlaceRef<'_, 'tcx>\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n-        debug!(\"maybe_codegen_consume_direct(place={:?})\", place);\n+        debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        place.iterate(|place_base, place_projection| {\n+        place_ref.iterate(|place_base, place_projection| {\n             if let mir::PlaceBase::Local(index) = place_base {\n                 match self.locals[*index] {\n                     LocalRef::Operand(Some(mut o)) => {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         Some(o)\n                     }\n                     LocalRef::Operand(None) => {\n-                        bug!(\"use of {:?} before def\", place);\n+                        bug!(\"use of {:?} before def\", place_ref);\n                     }\n                     LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n                         // watch out for locals that do not have an\n@@ -430,25 +430,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_consume(\n         &mut self,\n         bx: &mut Bx,\n-        place: &mir::Place<'tcx>\n+        place_ref: &mir::PlaceRef<'_, 'tcx>\n     ) -> OperandRef<'tcx, Bx::Value> {\n-        debug!(\"codegen_consume(place={:?})\", place);\n+        debug!(\"codegen_consume(place_ref={:?})\", place_ref);\n \n-        let ty = self.monomorphized_place_ty(place);\n+        let ty = self.monomorphized_place_ty(place_ref);\n         let layout = bx.cx().layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n             return OperandRef::new_zst(bx, layout);\n         }\n \n-        if let Some(o) = self.maybe_codegen_consume_direct(bx, place) {\n+        if let Some(o) = self.maybe_codegen_consume_direct(bx, place_ref) {\n             return o;\n         }\n \n         // for most places, to consume them we just load them\n         // out from their home\n-        let place = self.codegen_place(bx, place);\n+        let place = self.codegen_place(bx, place_ref);\n         bx.load_operand(place)\n     }\n \n@@ -462,7 +462,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match *operand {\n             mir::Operand::Copy(ref place) |\n             mir::Operand::Move(ref place) => {\n-                self.codegen_consume(bx, place)\n+                self.codegen_consume(bx, &place.as_place_ref())\n             }\n \n             mir::Operand::Constant(ref constant) => {"}, {"sha": "b38e58baaf6a4982c4df030d0d821b50900dcf44", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -428,36 +428,40 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,\n-        place: &mir::Place<'tcx>\n+        place_ref: &mir::PlaceRef<'_, 'tcx>\n     ) -> PlaceRef<'tcx, Bx::Value> {\n-        debug!(\"codegen_place(place={:?})\", place);\n-\n+        debug!(\"codegen_place(place_ref={:?})\", place_ref);\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        let result = match *place {\n-            mir::Place::Base(mir::PlaceBase::Local(index)) => {\n-                match self.locals[index] {\n+        let result = match &place_ref {\n+            mir::PlaceRef {\n+                base: mir::PlaceBase::Local(index),\n+                projection: None,\n+            } => {\n+                match self.locals[*index] {\n                     LocalRef::Place(place) => {\n                         return place;\n                     }\n                     LocalRef::UnsizedPlace(place) => {\n                         return bx.load_operand(place).deref(cx);\n                     }\n                     LocalRef::Operand(..) => {\n-                        bug!(\"using operand local {:?} as place\", place);\n+                        bug!(\"using operand local {:?} as place\", place_ref);\n                     }\n                 }\n             }\n-            mir::Place::Base(\n-                mir::PlaceBase::Static(\n-                    box mir::Static { ty, kind: mir::StaticKind::Promoted(promoted) }\n-                )\n-            ) => {\n+            mir::PlaceRef {\n+                base: mir::PlaceBase::Static(box mir::Static {\n+                    ty,\n+                    kind: mir::StaticKind::Promoted(promoted),\n+                }),\n+                projection: None,\n+            } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let cid = mir::interpret::GlobalId {\n                     instance: self.instance,\n-                    promoted: Some(promoted),\n+                    promoted: Some(*promoted),\n                 };\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n@@ -480,26 +484,41 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n             }\n-            mir::Place::Base(\n-                mir::PlaceBase::Static(\n-                    box mir::Static { ty, kind: mir::StaticKind::Static(def_id) }\n-                )\n-            ) => {\n+            mir::PlaceRef {\n+                base: mir::PlaceBase::Static(box mir::Static {\n+                    ty,\n+                    kind: mir::StaticKind::Static(def_id),\n+                }),\n+                projection: None,\n+            } => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n-                let static_ = bx.get_static(def_id);\n+                let static_ = bx.get_static(*def_id);\n                 PlaceRef::new_thin_place(bx, static_, layout, layout.align.abi)\n             },\n-            mir::Place::Projection(box mir::Projection {\n-                ref base,\n-                elem: mir::ProjectionElem::Deref\n-            }) => {\n+            mir::PlaceRef {\n+                base,\n+                projection: Some(box mir::Projection {\n+                    base: proj_base,\n+                    elem: mir::ProjectionElem::Deref,\n+                }),\n+            } => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(bx, base).deref(bx.cx())\n+                self.codegen_consume(bx, &mir::PlaceRef {\n+                    base,\n+                    projection: proj_base,\n+                }).deref(bx.cx())\n             }\n-            mir::Place::Projection(ref projection) => {\n-                let cg_base = self.codegen_place(bx, &projection.base);\n+            mir::PlaceRef {\n+                base,\n+                projection: Some(projection),\n+            } => {\n+                // FIXME turn this recursion into iteration\n+                let cg_base = self.codegen_place(bx, &mir::PlaceRef {\n+                    base,\n+                    projection: &projection.base,\n+                });\n \n                 match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n@@ -553,13 +572,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n         };\n-        debug!(\"codegen_place(place={:?}) => {:?}\", place, result);\n+        debug!(\"codegen_place(place={:?}) => {:?}\", place_ref, result);\n         result\n     }\n \n-    pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n+    pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = place.ty(self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "cfb7db7365802e3c8dc254ca718f19309640eb77", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -355,7 +355,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Ref(_, bk, ref place) => {\n-                let cg_place = self.codegen_place(&mut bx, place);\n+                let cg_place = self.codegen_place(&mut bx, &place.as_place_ref());\n \n                 let ty = cg_place.layout.ty;\n \n@@ -446,7 +446,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::Rvalue::Discriminant(ref place) => {\n                 let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n-                let discr =  self.codegen_place(&mut bx, place)\n+                let discr =  self.codegen_place(&mut bx, &place.as_place_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n@@ -515,7 +515,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n+        if let mir::Place {\n+            base: mir::PlaceBase::Local(index),\n+            projection: None,\n+        } = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx().tcx());\n@@ -524,8 +527,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let cg_value = self.codegen_place(bx, place);\n-        return cg_value.len(bx.cx());\n+        let cg_value = self.codegen_place(bx, &place.as_place_ref());\n+        cg_value.len(bx.cx())\n     }\n \n     pub fn codegen_scalar_binop("}, {"sha": "499cda1cf8449b02e0cc359755490cf3ea4e4f41", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -17,7 +17,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(ref place, ref rvalue) => {\n-                if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n+                if let mir::Place {\n+                    base: mir::PlaceBase::Local(index),\n+                    projection: None,\n+                } = *place {\n                     match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n@@ -43,12 +46,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                 } else {\n-                    let cg_dest = self.codegen_place(&mut bx, place);\n+                    let cg_dest = self.codegen_place(&mut bx, &place.as_place_ref());\n                     self.codegen_rvalue(bx, cg_dest, rvalue)\n                 }\n             }\n             mir::StatementKind::SetDiscriminant{ref place, variant_index} => {\n-                self.codegen_place(&mut bx, place)\n+                self.codegen_place(&mut bx, &place.as_place_ref())\n                     .codegen_set_discr(&mut bx, variant_index);\n                 bx\n             }\n@@ -70,7 +73,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             mir::StatementKind::InlineAsm(ref asm) => {\n                 let outputs = asm.outputs.iter().map(|output| {\n-                    self.codegen_place(&mut bx, output)\n+                    self.codegen_place(&mut bx, &output.as_place_ref())\n                 }).collect();\n \n                 let input_vals = asm.inputs.iter()"}, {"sha": "c9e6e7f70a2b48b55a7376f5a0f5abd9d633eab5", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n \n             self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n-            if let Some(local) = borrowed_place.base_local() {\n+            if let mir::PlaceBase::Local(local) = borrowed_place.base {\n                 self.local_map.entry(local).or_default().insert(idx);\n             }\n         }\n@@ -315,7 +315,10 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         //    TEMP = &foo\n         //\n         // so extract `temp`.\n-        let temp = if let &mir::Place::Base(mir::PlaceBase::Local(temp)) = assigned_place {\n+        let temp = if let &mir::Place {\n+            base: mir::PlaceBase::Local(temp),\n+            projection: None,\n+        } = assigned_place {\n             temp\n         } else {\n             span_bug!("}, {"sha": "95fc22dc5eb766c6636314341cf97e829745c07e", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 130, "deletions": 69, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n@@ -48,7 +48,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n+        (moved_place, used_place, span): (PlaceRef<'cx, 'tcx>, PlaceRef<'cx, 'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n@@ -72,17 +72,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .collect();\n \n         if move_out_indices.is_empty() {\n-            let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n+            let root_place = self\n+                .prefixes(used_place, PrefixSet::All)\n+                .last()\n+                .unwrap();\n \n-            if self.uninitialized_error_reported.contains(root_place) {\n+            if self.uninitialized_error_reported.contains(&root_place) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n                 );\n                 return;\n             }\n \n-            self.uninitialized_error_reported.insert(root_place.clone());\n+            self.uninitialized_error_reported.insert(root_place);\n \n             let item_msg = match self.describe_place_with_options(used_place,\n                                                                   IncludingDowncast(true)) {\n@@ -105,7 +108,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.buffer(&mut self.errors_buffer);\n         } else {\n             if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n-                if self.prefixes(&reported_place, PrefixSet::All)\n+                if self.prefixes(*reported_place, PrefixSet::All)\n                     .any(|p| p == used_place)\n                 {\n                     debug!(\n@@ -123,7 +126,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n-                self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n+                self.describe_place_with_options(moved_place, IncludingDowncast(true)),\n             );\n \n             self.add_moved_or_invoked_closure_note(\n@@ -136,13 +139,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let is_partial_move = move_site_vec.iter().any(|move_site| {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n-                used_place != moved_place && used_place.is_prefix_of(moved_place)\n+                used_place != moved_place.as_place_ref()\n+                    && used_place.is_prefix_of(moved_place.as_place_ref())\n             });\n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n \n-                let move_spans = self.move_spans(moved_place, move_out.source);\n+                let move_spans = self.move_spans(moved_place.as_place_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n \n                 let move_msg = if move_spans.for_closure() {\n@@ -200,7 +204,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n+            let ty =\n+                Place::ty_from(used_place.base, used_place.projection, self.body, self.infcx.tcx)\n+                    .ty;\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -216,7 +222,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let place = &self.move_data.move_paths[mpi].place;\n \n                 let ty = place.ty(self.body, self.infcx.tcx).ty;\n-                let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n+                let opt_name =\n+                    self.describe_place_with_options(place.as_place_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n                     Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n@@ -232,7 +239,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                 }\n-                let span = if let Place::Base(PlaceBase::Local(local)) = place {\n+                let span = if let Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                } = place {\n                     let decl = &self.body.local_decls[*local];\n                     Some(decl.source_info.span)\n                 } else {\n@@ -247,7 +257,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if let Some((_, mut old_err)) = self.move_error_reported\n-                .insert(move_out_indices, (used_place.clone(), err))\n+                .insert(move_out_indices, (used_place, err))\n             {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();\n@@ -265,24 +275,24 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n             location, place, span, borrow\n         );\n-        let value_msg = match self.describe_place(place) {\n+        let value_msg = match self.describe_place(place.as_place_ref()) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n-        let borrow_msg = match self.describe_place(&borrow.borrowed_place) {\n+        let borrow_msg = match self.describe_place(borrow.borrowed_place.as_place_ref()) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n-        let move_spans = self.move_spans(place, location);\n+        let move_spans = self.move_spans(place.as_place_ref(), location);\n         let span = move_spans.args_or_use();\n \n         let mut err = self.cannot_move_when_borrowed(\n             span,\n-            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_place(place.as_place_ref()).unwrap_or_else(|| \"_\".to_owned()),\n         );\n         err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n@@ -316,20 +326,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // Conflicting borrows are reported separately, so only check for move\n         // captures.\n-        let use_spans = self.move_spans(place, location);\n+        let use_spans = self.move_spans(place.as_place_ref(), location);\n         let span = use_spans.var_or_use();\n \n         let mut err = self.cannot_use_when_mutably_borrowed(\n             span,\n-            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_place(place.as_place_ref()).unwrap_or_else(|| \"_\".to_owned()),\n             borrow_span,\n-            &self.describe_place(&borrow.borrowed_place)\n+            &self.describe_place(borrow.borrowed_place.as_place_ref())\n                 .unwrap_or_else(|| \"_\".to_owned()),\n         );\n \n         borrow_spans.var_span_label(&mut err, {\n             let place = &borrow.borrowed_place;\n-            let desc_place = self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n+            let desc_place =\n+                self.describe_place(place.as_place_ref()).unwrap_or_else(|| \"_\".to_owned());\n \n             format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n         });\n@@ -506,7 +517,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n         } else {\n             let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc = self.describe_place(borrow_place)\n+            let borrow_place_desc = self.describe_place(borrow_place.as_place_ref())\n                                         .unwrap_or_else(|| \"_\".to_owned());\n             issued_spans.var_span_label(\n                 &mut err,\n@@ -575,8 +586,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> (String, String, String, String) {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n-        let union_ty = |place: &Place<'tcx>| -> Option<Ty<'tcx>> {\n-            let ty = place.ty(self.body, self.infcx.tcx).ty;\n+        let union_ty = |place_base, place_projection| {\n+            let ty = Place::ty_from(place_base, place_projection, self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n         let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n@@ -595,44 +606,67 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // field access to a union. If we find that, then we will keep the place of the\n                 // union being accessed and the field that was being accessed so we can check the\n                 // second borrowed place for the same union and a access to a different field.\n-                let mut current = first_borrowed_place;\n-                while let Place::Projection(box Projection { base, elem }) = current {\n+                let Place {\n+                    base,\n+                    projection,\n+                } = first_borrowed_place;\n+\n+                let mut current = projection;\n+\n+                while let Some(box Projection { base: base_proj, elem }) = current {\n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(base).is_some() => {\n-                            return Some((base, field));\n+                        ProjectionElem::Field(field, _) if union_ty(base, base_proj).is_some() => {\n+                            return Some((PlaceRef {\n+                                base: base,\n+                                projection: base_proj,\n+                            }, field));\n                         },\n-                        _ => current = base,\n+                        _ => current = base_proj,\n                     }\n                 }\n                 None\n             })\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let mut current = second_borrowed_place;\n-                while let Place::Projection(box Projection { base, elem }) = current {\n+                let Place {\n+                    base,\n+                    projection,\n+                } = second_borrowed_place;\n+\n+                let mut current = projection;\n+\n+                while let Some(box Projection { base: proj_base, elem }) = current {\n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(base) {\n-                            if field != target_field && base == target_base {\n+                        if let Some(union_ty) = union_ty(base, proj_base) {\n+                            if field != target_field\n+                                && base == target_base.base\n+                                && proj_base == target_base.projection {\n+                                // FIXME when we avoid clone reuse describe_place closure\n+                                let describe_base_place =  self.describe_place(PlaceRef {\n+                                    base: base,\n+                                    projection: proj_base,\n+                                }).unwrap_or_else(|| \"_\".to_owned());\n+\n                                 return Some((\n-                                    describe_place(base),\n-                                    describe_place(first_borrowed_place),\n-                                    describe_place(second_borrowed_place),\n+                                    describe_base_place,\n+                                    describe_place(first_borrowed_place.as_place_ref()),\n+                                    describe_place(second_borrowed_place.as_place_ref()),\n                                     union_ty.to_string(),\n                                 ));\n                             }\n                         }\n                     }\n \n-                    current = base;\n+                    current = proj_base;\n                 }\n                 None\n             })\n             .unwrap_or_else(|| {\n                 // If we didn't find a field access into a union, or both places match, then\n                 // only return the description of the first place.\n                 (\n-                    describe_place(first_borrowed_place),\n+                    describe_place(first_borrowed_place.as_place_ref()),\n                     \"\".to_string(),\n                     \"\".to_string(),\n                     \"\".to_string(),\n@@ -663,20 +697,24 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let drop_span = place_span.1;\n-        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+        let root_place = self.prefixes(borrow.borrowed_place.as_place_ref(), PrefixSet::All)\n             .last()\n             .unwrap();\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        let proper_span = match *root_place {\n-            Place::Base(PlaceBase::Local(local)) => self.body.local_decls[local].source_info.span,\n+        assert!(root_place.projection.is_none());\n+        let proper_span = match root_place.base {\n+            PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n             _ => drop_span,\n         };\n \n         if self.access_place_error_reported\n-            .contains(&(root_place.clone(), borrow_span))\n+            .contains(&(Place {\n+                base: root_place.base.clone(),\n+                projection: root_place.projection.clone(),\n+            }, borrow_span))\n         {\n             debug!(\n                 \"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n@@ -686,24 +724,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         self.access_place_error_reported\n-            .insert((root_place.clone(), borrow_span));\n+            .insert((Place {\n+                base: root_place.base.clone(),\n+                projection: root_place.projection.clone(),\n+            }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n-            self.classify_drop_access_kind(&borrow.borrowed_place)\n+            self.classify_drop_access_kind(borrow.borrowed_place.as_place_ref())\n         {\n             // If a borrow of path `B` conflicts with drop of `D` (and\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n-            if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n+            if !borrow.borrowed_place.as_place_ref().is_prefix_of(place_span.0.as_place_ref()) {\n                 self.report_borrow_conflicts_with_destructor(\n                     location, borrow, place_span, kind, dropped_ty,\n                 );\n                 return;\n             }\n         }\n \n-        let place_desc = self.describe_place(&borrow.borrowed_place);\n+        let place_desc = self.describe_place(borrow.borrowed_place.as_place_ref());\n \n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n         let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n@@ -910,12 +951,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut err = self.cannot_borrow_across_destructor(borrow_span);\n \n-        let what_was_dropped = match self.describe_place(place) {\n+        let what_was_dropped = match self.describe_place(place.as_place_ref()) {\n             Some(name) => format!(\"`{}`\", name.as_str()),\n             None => String::from(\"temporary value\"),\n         };\n \n-        let label = match self.describe_place(&borrow.borrowed_place) {\n+        let label = match self.describe_place(borrow.borrowed_place.as_place_ref()) {\n             Some(borrowed) => format!(\n                 \"here, drop of {D} needs exclusive access to `{B}`, \\\n                  because the type `{T}` implements the `Drop` trait\",\n@@ -1061,7 +1102,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = match borrow.borrowed_place {\n-                Place::Base(PlaceBase::Local(local)) => {\n+                Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                } => {\n                     match self.body.local_kind(local) {\n                         LocalKind::ReturnPointer\n                         | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n@@ -1083,15 +1127,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` is borrowed here\", place_desc),\n             )\n         } else {\n-            let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+            let root_place = self.prefixes(borrow.borrowed_place.as_place_ref(),\n+                                           PrefixSet::All)\n                 .last()\n                 .unwrap();\n-            let local = if let Place::Base(PlaceBase::Local(local)) = *root_place {\n+            let local = if let PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } = root_place {\n                 local\n             } else {\n                 bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n             };\n-            match self.body.local_kind(local) {\n+            match self.body.local_kind(*local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n                     (\n                         \"temporary value\".to_string(),\n@@ -1342,7 +1390,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut err = self.cannot_mutate_in_match_guard(\n                 span,\n                 loan_span,\n-                &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+                &self.describe_place(place.as_place_ref()).unwrap_or_else(|| \"_\".to_owned()),\n                 \"assign\",\n             );\n             loan_spans.var_span_label(\n@@ -1358,7 +1406,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut err = self.cannot_assign_to_borrowed(\n             span,\n             loan_span,\n-            &self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_place(place.as_place_ref()).unwrap_or_else(|| \"_\".to_owned()),\n         );\n \n         loan_spans.var_span_label(\n@@ -1385,7 +1433,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assigned_span: Span,\n         err_place: &Place<'tcx>,\n     ) {\n-        let (from_arg, local_decl) = if let Place::Base(PlaceBase::Local(local)) = *err_place {\n+        let (from_arg, local_decl) = if let Place {\n+            base: PlaceBase::Local(local),\n+            projection: None,\n+        } = *err_place {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n             } else {\n@@ -1415,8 +1466,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 is_user_variable: None,\n                 ..\n             })\n-            | None => (self.describe_place(place), assigned_span),\n-            Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n+            | None => (self.describe_place(place.as_place_ref()), assigned_span),\n+            Some(decl) => (self.describe_place(err_place.as_place_ref()), decl.source_info.span),\n         };\n \n         let mut err = self.cannot_reassign_immutable(\n@@ -1454,29 +1505,31 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err.buffer(&mut self.errors_buffer);\n     }\n \n-    fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n+    fn classify_drop_access_kind(&self, place: PlaceRef<'cx, 'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n-        match place {\n-            Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Static(_)) => {\n+        match place.projection {\n+            None => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n-            Place::Projection(box Projection { base, elem }) => {\n-                let base_access = self.classify_drop_access_kind(base);\n+            Some(box Projection { ref base, ref elem }) => {\n+                let base_access = self.classify_drop_access_kind(PlaceRef {\n+                    base: place.base,\n+                    projection: base,\n+                });\n                 match elem {\n                     ProjectionElem::Deref => match base_access {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                base.ty(self.body, tcx).ty.is_box(),\n+                                Place::ty_from(&place.base, base, self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = base.ty(self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1543,8 +1596,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n             let mut target = *match reservation {\n-                Place::Base(PlaceBase::Local(local))\n-                    if self.body.local_kind(*local) == LocalKind::Temp => local,\n+                Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                } if self.body.local_kind(*local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n@@ -1557,7 +1612,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     target, stmt\n                 );\n                 if let StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(assigned_to)),\n+                    Place {\n+                        base: PlaceBase::Local(assigned_to),\n+                        projection: None,\n+                    },\n                     box rvalue\n                 ) = &stmt.kind {\n                     debug!(\n@@ -1682,7 +1740,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 target, terminator\n             );\n             if let TerminatorKind::Call {\n-                destination: Some((Place::Base(PlaceBase::Local(assigned_to)), _)),\n+                destination: Some((Place {\n+                    base: PlaceBase::Local(assigned_to),\n+                    projection: None,\n+                }, _)),\n                 args,\n                 ..\n             } = &terminator.kind"}, {"sha": "156897aedb70acb18fda91793b98ec3f71362fba", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 143, "deletions": 64, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -3,8 +3,8 @@ use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n-    Place, PlaceBase, ProjectionElem, Rvalue, Statement, StatementKind, Static,\n-    StaticKind, Terminator, TerminatorKind,\n+    Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind,\n+    Static, StaticKind, Terminator, TerminatorKind,\n };\n use rustc::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n@@ -34,7 +34,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     pub(super) fn add_moved_or_invoked_closure_note(\n         &self,\n         location: Location,\n-        place: &Place<'tcx>,\n+        place: PlaceRef<'cx, 'tcx>,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n@@ -121,8 +121,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// End-user visible description of `place` if one can be found. If the\n     /// place is a temporary for instance, None will be returned.\n-    pub(super) fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n-        self.describe_place_with_options(place, IncludingDowncast(false))\n+    pub(super) fn describe_place(&self, place_ref: PlaceRef<'cx, 'tcx>) -> Option<String> {\n+        self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }\n \n     /// End-user visible description of `place` if one can be found. If the\n@@ -131,7 +131,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// `Downcast` and `IncludingDowncast` is true\n     pub(super) fn describe_place_with_options(\n         &self,\n-        place: &Place<'tcx>,\n+        place: PlaceRef<'cx, 'tcx>,\n         including_downcast: IncludingDowncast,\n     ) -> Option<String> {\n         let mut buf = String::new();\n@@ -144,22 +144,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Appends end-user visible description of `place` to `buf`.\n     fn append_place_to_string(\n         &self,\n-        place: &Place<'tcx>,\n+        place: PlaceRef<'cx, 'tcx>,\n         buf: &mut String,\n         mut autoderef: bool,\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n-        match *place {\n-            Place::Base(PlaceBase::Local(local)) => {\n-                self.append_local_to_string(local, buf)?;\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => {\n+                self.append_local_to_string(*local, buf)?;\n             }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+            PlaceRef {\n+                base:\n+                    PlaceBase::Static(box Static {\n+                        kind: StaticKind::Promoted(_),\n+                        ..\n+                    }),\n+                projection: None,\n+            } => {\n                 buf.push_str(\"promoted\");\n             }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n-                buf.push_str(&self.infcx.tcx.item_name(def_id).to_string());\n+            PlaceRef {\n+                base:\n+                    PlaceBase::Static(box Static {\n+                        kind: StaticKind::Static(def_id),\n+                        ..\n+                    }),\n+                projection: None,\n+            } => {\n+                buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n-            Place::Projection(ref proj) => {\n+            PlaceRef {\n+                ref base,\n+                projection: Some(ref proj),\n+            } => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n@@ -174,43 +194,66 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         } else {\n                             if autoderef {\n+                                // FIXME turn this recursion into iteration\n                                 self.append_place_to_string(\n-                                    &proj.base,\n+                                    PlaceRef {\n+                                        base: &base,\n+                                        projection: &proj.base,\n+                                    },\n                                     buf,\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n-                            } else if let Place::Base(PlaceBase::Local(local)) = proj.base {\n-                                if self.body.local_decls[local].is_ref_for_guard() {\n-                                    self.append_place_to_string(\n-                                        &proj.base,\n-                                        buf,\n-                                        autoderef,\n-                                        &including_downcast,\n-                                    )?;\n-                                } else {\n-                                    buf.push_str(&\"*\");\n-                                    self.append_place_to_string(\n-                                        &proj.base,\n-                                        buf,\n-                                        autoderef,\n-                                        &including_downcast,\n-                                    )?;\n-                                }\n                             } else {\n-                                buf.push_str(&\"*\");\n-                                self.append_place_to_string(\n-                                    &proj.base,\n-                                    buf,\n-                                    autoderef,\n-                                    &including_downcast,\n-                                )?;\n+                                match (&proj.base, base) {\n+                                    (None, PlaceBase::Local(local)) => {\n+                                        if self.body.local_decls[*local].is_ref_for_guard() {\n+                                            self.append_place_to_string(\n+                                                PlaceRef {\n+                                                    base: &base,\n+                                                    projection: &proj.base,\n+                                                },\n+                                                buf,\n+                                                autoderef,\n+                                                &including_downcast,\n+                                            )?;\n+                                        } else {\n+                                            // FIXME deduplicate this and the _ => body below\n+                                            buf.push_str(&\"*\");\n+                                            self.append_place_to_string(\n+                                                PlaceRef {\n+                                                    base: &base,\n+                                                    projection: &proj.base,\n+                                                },\n+                                                buf,\n+                                                autoderef,\n+                                                &including_downcast,\n+                                            )?;\n+                                        }\n+                                    }\n+\n+                                    _ => {\n+                                        buf.push_str(&\"*\");\n+                                        self.append_place_to_string(\n+                                            PlaceRef {\n+                                                base: &base,\n+                                                projection: &proj.base,\n+                                            },\n+                                            buf,\n+                                            autoderef,\n+                                            &including_downcast,\n+                                        )?;\n+                                    }\n+                                }\n                             }\n                         }\n                     }\n                     ProjectionElem::Downcast(..) => {\n                         self.append_place_to_string(\n-                            &proj.base,\n+                            PlaceRef {\n+                                base: &base,\n+                                projection: &proj.base,\n+                            },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -229,9 +272,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             let name = self.upvars[var_index].name.to_string();\n                             buf.push_str(&name);\n                         } else {\n-                            let field_name = self.describe_field(&proj.base, field);\n+                            let field_name = self.describe_field(PlaceRef {\n+                                base: base,\n+                                projection: &proj.base,\n+                            }, field);\n                             self.append_place_to_string(\n-                                &proj.base,\n+                                PlaceRef {\n+                                    base: &base,\n+                                    projection: &proj.base,\n+                                },\n                                 buf,\n                                 autoderef,\n                                 &including_downcast,\n@@ -243,7 +292,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         autoderef = true;\n \n                         self.append_place_to_string(\n-                            &proj.base,\n+                            PlaceRef {\n+                                base: &base,\n+                                projection: &proj.base,\n+                            },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -260,7 +312,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // then use another while the borrow is held, don't output indices details\n                         // to avoid confusing the end-user\n                         self.append_place_to_string(\n-                            &proj.base,\n+                            PlaceRef {\n+                                base: &base,\n+                                projection: &proj.base,\n+                            },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n@@ -288,18 +343,32 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Place<'tcx>, field: Field) -> String {\n-        match *base {\n-            Place::Base(PlaceBase::Local(local)) => {\n-                let local = &self.body.local_decls[local];\n+    fn describe_field(&self, place: PlaceRef<'cx, 'tcx>, field: Field) -> String {\n+        // FIXME Place2 Make this work iteratively\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => {\n+                let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n-            Place::Base(PlaceBase::Static(ref static_)) =>\n+            PlaceRef {\n+                base: PlaceBase::Static(static_),\n+                projection: None,\n+            } =>\n                 self.describe_field_from_ty(&static_.ty, field, None),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Deref => self.describe_field(&proj.base, field),\n+            PlaceRef {\n+                base,\n+                projection: Some(proj),\n+            } => match proj.elem {\n+                ProjectionElem::Deref => self.describe_field(PlaceRef {\n+                    base,\n+                    projection: &proj.base,\n+                }, field),\n                 ProjectionElem::Downcast(_, variant_index) => {\n-                    let base_ty = base.ty(self.body, self.infcx.tcx).ty;\n+                    let base_ty =\n+                        Place::ty_from(place.base, place.projection, self.body, self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -308,7 +377,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {\n-                    self.describe_field(&proj.base, field)\n+                    self.describe_field(PlaceRef {\n+                        base,\n+                        projection: &proj.base,\n+                    }, field)\n                 }\n             },\n         }\n@@ -365,10 +437,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// Checks if a place is a thread-local static.\n-    pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n-        if let Place::Base(\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n-        ) = place {\n+    pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n+        if let PlaceRef {\n+            base: PlaceBase::Static(box Static {\n+                kind: StaticKind::Static(def_id),\n+                ..\n+            }),\n+            projection: None,\n+        } = place_ref {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n \n@@ -405,7 +481,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     pub(super) fn borrowed_content_source(\n         &self,\n-        deref_base: &Place<'tcx>,\n+        deref_base: PlaceRef<'cx, 'tcx>,\n     ) -> BorrowedContentSource<'tcx> {\n         let tcx = self.infcx.tcx;\n \n@@ -457,7 +533,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = deref_base.ty(self.body, tcx).ty;\n+        let base_ty = Place::ty_from(deref_base.base, deref_base.projection, self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_pointer() {\n@@ -700,7 +776,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n         &self,\n-        moved_place: &Place<'tcx>, // Could also be an upvar.\n+        moved_place: PlaceRef<'cx, 'tcx>, // Could also be an upvar.\n         location: Location,\n     ) -> UseSpans {\n         use self::UseSpans::*;\n@@ -750,7 +826,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _),\n+                kind: StatementKind::Assign(Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                }, _),\n                 ..\n             }) => local,\n             _ => return OtherUse(use_span),\n@@ -776,7 +855,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id, is_generator, places\n                 );\n                 if let Some((args_span, var_span)) = self.closure_span(\n-                    *def_id, &Place::from(target), places\n+                    *def_id, Place::from(target).as_place_ref(), places\n                 ) {\n                     return ClosureUse {\n                         is_generator,\n@@ -800,7 +879,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn closure_span(\n         &self,\n         def_id: DefId,\n-        target_place: &Place<'tcx>,\n+        target_place: PlaceRef<'cx, 'tcx>,\n         places: &Vec<Operand<'tcx>>,\n     ) -> Option<(Span, Span)> {\n         debug!(\n@@ -816,7 +895,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             for (upvar, place) in self.infcx.tcx.upvars(def_id)?.values().zip(places) {\n                 match place {\n                     Operand::Copy(place) |\n-                    Operand::Move(place) if target_place == place => {\n+                    Operand::Move(place) if target_place == place.as_place_ref() => {\n                         debug!(\"closure_span: found captured local {:?}\", place);\n                         return Some((*args_span, upvar.span));\n                     },"}, {"sha": "cfc7e77f4e5a87417c60a2b49756f866ca2bcc13", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 242, "deletions": 189, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -10,9 +10,8 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, Static,\n-\n-    StaticKind\n+    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n+    Static, StaticKind\n };\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -474,10 +473,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// `BTreeMap` is used to preserve the order of insertions when iterating. This is necessary\n     /// when errors in the map are being re-added to the error buffer so that errors with the\n     /// same primary span come out in a consistent order.\n-    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (Place<'tcx>, DiagnosticBuilder<'cx>)>,\n+    move_error_reported: BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'cx, 'tcx>, DiagnosticBuilder<'cx>)>,\n     /// This field keeps track of errors reported in the checking of uninitialized variables,\n     /// so that we don't report seemingly duplicate errors.\n-    uninitialized_error_reported: FxHashSet<Place<'tcx>>,\n+    uninitialized_error_reported: FxHashSet<PlaceRef<'cx, 'tcx>>,\n     /// Errors to be reported buffer\n     errors_buffer: Vec<Diagnostic>,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n@@ -520,7 +519,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     fn visit_statement_entry(\n         &mut self,\n         location: Location,\n-        stmt: &Statement<'tcx>,\n+        stmt: &'cx Statement<'tcx>,\n         flow_state: &Self::FlowState,\n     ) {\n         debug!(\n@@ -561,7 +560,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -592,7 +591,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                         self.check_if_path_or_subpath_is_moved(\n                             location,\n                             InitializationRequiringAction::Use,\n-                            (output, o.span),\n+                            (output.as_place_ref(), o.span),\n                             flow_state,\n                         );\n                     } else {\n@@ -631,7 +630,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     fn visit_terminator_entry(\n         &mut self,\n         location: Location,\n-        term: &Terminator<'tcx>,\n+        term: &'cx Terminator<'tcx>,\n         flow_state: &Self::FlowState,\n     ) {\n         let loc = location;\n@@ -890,7 +889,8 @@ enum InitializationRequiringAction {\n }\n \n struct RootPlace<'d, 'tcx> {\n-    place: &'d Place<'tcx>,\n+    place_base: &'d PlaceBase<'tcx>,\n+    place_projection: &'d Option<Box<Projection<'tcx>>>,\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n \n@@ -1143,7 +1143,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn mutate_place(\n         &mut self,\n         location: Location,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (&'cx Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n         flow_state: &Flows<'cx, 'tcx>,\n@@ -1154,7 +1154,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Update,\n-                    place_span,\n+                    (place_span.0.as_place_ref(), place_span.1),\n                     flow_state,\n                 );\n             }\n@@ -1166,12 +1166,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Special case: you can assign a immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n-        if let &Place::Base(PlaceBase::Local(local)) = place_span.0 {\n-            if let Mutability::Not = self.body.local_decls[local].mutability {\n+        if let Place {\n+            base: PlaceBase::Local(local),\n+            projection: None,\n+        } = place_span.0 {\n+            if let Mutability::Not = self.body.local_decls[*local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n-                    local,\n+                    *local,\n                     place_span,\n                     flow_state,\n                 );\n@@ -1192,7 +1195,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn consume_rvalue(\n         &mut self,\n         location: Location,\n-        (rvalue, span): (&Rvalue<'tcx>, Span),\n+        (rvalue, span): (&'cx Rvalue<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *rvalue {\n@@ -1229,7 +1232,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     action,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1257,7 +1260,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1305,27 +1308,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n-            match *place {\n-                Place::Projection { .. } => {\n-                    if let Some(field) = this.is_upvar_field_projection(place) {\n-                        this.used_mut_upvars.push(field);\n-                    }\n-                }\n-                Place::Base(PlaceBase::Local(local)) => {\n-                    this.used_mut.insert(local);\n+            if place.projection.is_some() {\n+                if let Some(field) = this.is_upvar_field_projection(place.as_place_ref()) {\n+                    this.used_mut_upvars.push(field);\n                 }\n-                Place::Base(PlaceBase::Static(_)) => {}\n+            } else if let PlaceBase::Local(local) = place.base {\n+                this.used_mut.insert(local);\n             }\n         };\n \n         // This relies on the current way that by-value\n         // captures of a closure are copied/moved directly\n         // when generating MIR.\n         match *operand {\n-            Operand::Move(Place::Base(PlaceBase::Local(local)))\n-            | Operand::Copy(Place::Base(PlaceBase::Local(local)))\n-                if self.body.local_decls[local].is_user_variable.is_none() =>\n-            {\n+            Operand::Move(Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            }) |\n+            Operand::Copy(Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            }) if self.body.local_decls[local].is_user_variable.is_none() => {\n                 if self.body.local_decls[local].ty.is_mutable_pointer() {\n                     // The variable will be marked as mutable by the borrow.\n                     return;\n@@ -1379,7 +1382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn consume_operand(\n         &mut self,\n         location: Location,\n-        (operand, span): (&Operand<'tcx>, Span),\n+        (operand, span): (&'cx Operand<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         match *operand {\n@@ -1398,7 +1401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1416,7 +1419,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.check_if_path_or_subpath_is_moved(\n                     location,\n                     InitializationRequiringAction::Use,\n-                    (place, span),\n+                    (place.as_place_ref(), span),\n                     flow_state,\n                 );\n             }\n@@ -1434,30 +1437,35 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n-        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n+        let root_place = self.prefixes(place.as_place_ref(), PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n-        let (might_be_alive, will_be_dropped) = match root_place {\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+\n+        assert!(root_place.projection.is_none());\n+        let (might_be_alive, will_be_dropped) = match root_place.base {\n+            PlaceBase::Static(box Static {\n+                kind: StaticKind::Promoted(_),\n+                ..\n+            }) => {\n                 (true, false)\n             }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(_), .. })) => {\n+            PlaceBase::Static(box Static {\n+                kind: StaticKind::Static(_),\n+                ..\n+            }) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n-                (true, self.is_place_thread_local(&root_place))\n+                (true, self.is_place_thread_local(root_place))\n             }\n-            Place::Base(PlaceBase::Local(_)) => {\n+            PlaceBase::Local(_) => {\n                 // Locals are always dropped at function exit, and if they\n                 // have a destructor it would've been called already.\n                 (false, self.locals_are_invalidated_at_exit)\n             }\n-            Place::Projection(..) => {\n-                bug!(\"root of {:?} is a projection ({:?})?\", place, root_place)\n-            }\n         };\n \n         if !will_be_dropped {\n@@ -1563,7 +1571,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (PlaceRef<'cx, 'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n@@ -1631,7 +1639,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &mut self,\n         location: Location,\n         desired_action: InitializationRequiringAction,\n-        place_span: (&Place<'tcx>, Span),\n+        place_span: (PlaceRef<'cx, 'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         let maybe_uninits = &flow_state.uninits;\n@@ -1686,25 +1694,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currently this can only occur if the place is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to<'a>(\n+    fn move_path_closest_to(\n         &mut self,\n-        place: &'a Place<'tcx>,\n-    ) -> Result<(&'a Place<'tcx>, MovePathIndex), NoMovePathFound> where 'cx: 'a {\n-        let mut last_prefix = place;\n+        place: PlaceRef<'cx, 'tcx>,\n+    ) -> Result<(PlaceRef<'cx, 'tcx>, MovePathIndex), NoMovePathFound> {\n+        let mut last_prefix = place.base;\n+\n         for prefix in self.prefixes(place, PrefixSet::All) {\n             if let Some(mpi) = self.move_path_for_place(prefix) {\n                 return Ok((prefix, mpi));\n             }\n-            last_prefix = prefix;\n+\n+            last_prefix = prefix.base;\n         }\n-        match *last_prefix {\n-            Place::Base(PlaceBase::Local(_)) => panic!(\"should have move path for every Local\"),\n-            Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n-            Place::Base(PlaceBase::Static(_)) => Err(NoMovePathFound::ReachedStatic),\n+\n+        match last_prefix {\n+            PlaceBase::Local(_) => panic!(\"should have move path for every Local\"),\n+            PlaceBase::Static(_) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n \n-    fn move_path_for_place(&mut self, place: &Place<'tcx>) -> Option<MovePathIndex> {\n+    fn move_path_for_place(&mut self, place: PlaceRef<'cx, 'tcx>) -> Option<MovePathIndex> {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `place` (which means there is nothing\n         // that borrowck tracks for its analysis).\n@@ -1718,94 +1728,97 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn check_if_assigned_path_is_moved(\n         &mut self,\n         location: Location,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, span): (&'cx Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n         // recur down place; dispatch to external checks when necessary\n-        let mut place = place;\n-        loop {\n-            match *place {\n-                Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n-                    // assigning to `x` does not require `x` be initialized.\n+        let mut place_projection = &place.projection;\n+\n+        // None case => assigning to `x` does not require `x` be initialized.\n+        while let Some(proj) = place_projection {\n+            let Projection { ref base, ref elem } = **proj;\n+            match *elem {\n+                ProjectionElem::Index(_/*operand*/) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                // assigning to P[i] requires P to be valid.\n+                ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n+                // assigning to (P->variant) is okay if assigning to `P` is okay\n+                //\n+                // FIXME: is this true even if P is a adt with a dtor?\n+                { }\n+\n+                // assigning to (*P) requires P to be initialized\n+                ProjectionElem::Deref => {\n+                    self.check_if_full_path_is_moved(\n+                        location, InitializationRequiringAction::Use,\n+                        (PlaceRef {\n+                            base: &place.base,\n+                            projection: base,\n+                        }, span), flow_state);\n+                    // (base initialized; no need to\n+                    // recur further)\n                     break;\n                 }\n-                Place::Projection(ref proj) => {\n-                    let Projection { ref base, ref elem } = **proj;\n-                    match *elem {\n-                        ProjectionElem::Index(_/*operand*/) |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        // assigning to P[i] requires P to be valid.\n-                        ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n-                        // assigning to (P->variant) is okay if assigning to `P` is okay\n-                        //\n-                        // FIXME: is this true even if P is a adt with a dtor?\n-                        { }\n-\n-                        // assigning to (*P) requires P to be initialized\n-                        ProjectionElem::Deref => {\n-                            self.check_if_full_path_is_moved(\n-                                location, InitializationRequiringAction::Use,\n-                                (base, span), flow_state);\n+\n+                ProjectionElem::Subslice { .. } => {\n+                    panic!(\"we don't allow assignments to subslices, location: {:?}\",\n+                           location);\n+                }\n+\n+                ProjectionElem::Field(..) => {\n+                    // if type of `P` has a dtor, then\n+                    // assigning to `P.f` requires `P` itself\n+                    // be already initialized\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n+                    match base_ty.sty {\n+                        ty::Adt(def, _) if def.has_dtor(tcx) => {\n+                            self.check_if_path_or_subpath_is_moved(\n+                                location, InitializationRequiringAction::Assignment,\n+                                (PlaceRef {\n+                                    base: &place.base,\n+                                    projection: base,\n+                                }, span), flow_state);\n+\n                             // (base initialized; no need to\n                             // recur further)\n                             break;\n                         }\n \n-                        ProjectionElem::Subslice { .. } => {\n-                            panic!(\"we don't allow assignments to subslices, location: {:?}\",\n-                                   location);\n-                        }\n-\n-                        ProjectionElem::Field(..) => {\n-                            // if type of `P` has a dtor, then\n-                            // assigning to `P.f` requires `P` itself\n-                            // be already initialized\n-                            let tcx = self.infcx.tcx;\n-                            match base.ty(self.body, tcx).ty.sty {\n-                                ty::Adt(def, _) if def.has_dtor(tcx) => {\n-                                    self.check_if_path_or_subpath_is_moved(\n-                                        location, InitializationRequiringAction::Assignment,\n-                                        (base, span), flow_state);\n-\n-                                    // (base initialized; no need to\n-                                    // recur further)\n-                                    break;\n-                                }\n-\n-\n-                                // Once `let s; s.x = V; read(s.x);`,\n-                                // is allowed, remove this match arm.\n-                                ty::Adt(..) | ty::Tuple(..) => {\n-                                    check_parent_of_field(self, location, base, span, flow_state);\n-\n-                                    if let Some(local) = place.base_local() {\n-                                        // rust-lang/rust#21232,\n-                                        // #54499, #54986: during\n-                                        // period where we reject\n-                                        // partial initialization, do\n-                                        // not complain about\n-                                        // unnecessary `mut` on an\n-                                        // attempt to do a partial\n-                                        // initialization.\n-                                        self.used_mut.insert(local);\n-                                    }\n-                                }\n-\n-                                _ => {}\n+                        // Once `let s; s.x = V; read(s.x);`,\n+                        // is allowed, remove this match arm.\n+                        ty::Adt(..) | ty::Tuple(..) => {\n+                            check_parent_of_field(self, location, PlaceRef {\n+                                base: &place.base,\n+                                projection: base,\n+                            }, span, flow_state);\n+\n+                            if let PlaceBase::Local(local) = place.base {\n+                                // rust-lang/rust#21232,\n+                                // #54499, #54986: during\n+                                // period where we reject\n+                                // partial initialization, do\n+                                // not complain about\n+                                // unnecessary `mut` on an\n+                                // attempt to do a partial\n+                                // initialization.\n+                                self.used_mut.insert(local);\n                             }\n                         }\n-                    }\n \n-                    place = base;\n+                        _ => {}\n+                    }\n                 }\n             }\n+\n+            place_projection = base;\n         }\n \n         fn check_parent_of_field<'cx, 'tcx>(\n             this: &mut MirBorrowckCtxt<'cx, 'tcx>,\n             location: Location,\n-            base: &Place<'tcx>,\n+            base: PlaceRef<'cx, 'tcx>,\n             span: Span,\n             flow_state: &Flows<'cx, 'tcx>,\n         ) {\n@@ -1866,7 +1879,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::Adt(def, _) = base.ty(this.body, tcx).ty.sty {\n+                if let ty::Adt(def, _) =\n+                    Place::ty_from(base.base, base.projection, this.body, tcx).ty.sty\n+                {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n@@ -1911,7 +1926,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // partial initialization, do not complain about mutability\n         // errors except for actual mutation (as opposed to an attempt\n         // to do a partial initialization).\n-        let previously_initialized = if let Some(local) = place.base_local() {\n+        let previously_initialized = if let PlaceBase::Local(local) = place.base {\n             self.is_local_ever_initialized(local, flow_state).is_some()\n         } else {\n             true\n@@ -1927,7 +1942,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     BorrowKind::Mut { .. } => is_local_mutation_allowed,\n                     BorrowKind::Shared | BorrowKind::Shallow => unreachable!(),\n                 };\n-                match self.is_mutable(place, is_local_mutation_allowed) {\n+                match self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed) {\n                     Ok(root_place) => {\n                         self.add_used_mut(root_place, flow_state);\n                         return false;\n@@ -1939,7 +1954,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n             Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-                match self.is_mutable(place, is_local_mutation_allowed) {\n+                match self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed) {\n                     Ok(root_place) => {\n                         self.add_used_mut(root_place, flow_state);\n                         return false;\n@@ -1960,7 +1975,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow)) => {\n                 if let (Err(_place_err), true) = (\n-                    self.is_mutable(place, is_local_mutation_allowed),\n+                    self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed),\n                     self.errors_buffer.is_empty()\n                 ) {\n                     if self.infcx.tcx.migrate_borrowck() {\n@@ -1981,7 +1996,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.report_mutability_error(\n                             place,\n                             span,\n-                            _place_err,\n+                            PlaceRef {\n+                                base: _place_err.0,\n+                                projection: _place_err.1,\n+                            },\n                             error_access,\n                             location,\n                         );\n@@ -2015,7 +2033,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             self.report_mutability_error(\n                 place,\n                 span,\n-                the_place_err,\n+                PlaceRef {\n+                    base: the_place_err.0,\n+                    projection: the_place_err.1,\n+                },\n                 error_access,\n                 location,\n             );\n@@ -2044,7 +2065,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn add_used_mut<'d>(&mut self, root_place: RootPlace<'d, 'tcx>, flow_state: &Flows<'cx, 'tcx>) {\n         match root_place {\n             RootPlace {\n-                place: Place::Base(PlaceBase::Local(local)),\n+                place_base: PlaceBase::Local(local),\n+                place_projection: None,\n                 is_local_mutation_allowed,\n             } => {\n                 // If the local may have been initialized, and it is now currently being\n@@ -2057,19 +2079,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n             RootPlace {\n-                place: _,\n+                place_base: _,\n+                place_projection: _,\n                 is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n             } => {}\n             RootPlace {\n-                place: place @ Place::Projection(_),\n+                place_base,\n+                place_projection: place_projection @ Some(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = self.is_upvar_field_projection(place) {\n+                if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n+                    base: &place_base,\n+                    projection: &place_projection,\n+                }) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n             RootPlace {\n-                place: Place::Base(PlaceBase::Static(..)),\n+                place_base: PlaceBase::Static(..),\n+                place_projection: None,\n                 is_local_mutation_allowed: _,\n             } => {}\n         }\n@@ -2079,62 +2107,78 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n-        place: &'d Place<'tcx>,\n+        place_base: &'d PlaceBase<'tcx>,\n+        place_projection: &'d Option<Box<Projection<'tcx>>>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<RootPlace<'d, 'tcx>, &'d Place<'tcx>> {\n-        match *place {\n-            Place::Base(PlaceBase::Local(local)) => {\n-                let local = &self.body.local_decls[local];\n+    ) -> Result<RootPlace<'d, 'tcx>, (&'d PlaceBase<'tcx>, &'d Option<Box<Projection<'tcx>>>)> {\n+        match (place_base, place_projection) {\n+            (PlaceBase::Local(local), None) => {\n+                let local = &self.body.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n-                            place,\n+                            place_base,\n+                            place_projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n                         }),\n                         LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n-                            place,\n+                            place_base,\n+                            place_projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n                         }),\n-                        LocalMutationIsAllowed::No => Err(place),\n+                        LocalMutationIsAllowed::No => Err((place_base, place_projection)),\n                     },\n                     Mutability::Mut => Ok(RootPlace {\n-                        place,\n+                        place_base,\n+                        place_projection,\n                         is_local_mutation_allowed,\n                     }),\n                 }\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            Place::Base(PlaceBase::Static(box Static{kind: StaticKind::Promoted(_), ..})) =>\n+            (PlaceBase::Static(box Static {\n+                kind: StaticKind::Promoted(_),\n+                ..\n+            }), None) =>\n                 Ok(RootPlace {\n-                    place,\n+                    place_base,\n+                    place_projection,\n                     is_local_mutation_allowed,\n                 }),\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n-                if !self.infcx.tcx.is_mutable_static(def_id) {\n-                    Err(place)\n+            (PlaceBase::Static(box Static {\n+                kind: StaticKind::Static(def_id),\n+                ..\n+            }), None) => {\n+                if !self.infcx.tcx.is_mutable_static(*def_id) {\n+                    Err((place_base, place_projection))\n                 } else {\n                     Ok(RootPlace {\n-                        place,\n+                        place_base,\n+                        place_projection,\n                         is_local_mutation_allowed,\n                     })\n                 }\n             }\n-            Place::Projection(ref proj) => {\n+            (_, Some(ref proj)) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.body, self.infcx.tcx).ty;\n+                        let base_ty =\n+                            Place::ty_from(place_base, &proj.base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::MutImmutable => Err((place_base, place_projection)),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(place) {\n+                                        let mode = match self.is_upvar_field_projection(PlaceRef {\n+                                            base: &place_base,\n+                                            projection: &place_projection,\n+                                        }) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n                                             {\n@@ -2143,27 +2187,28 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             _ => LocalMutationIsAllowed::Yes,\n                                         };\n \n-                                        self.is_mutable(&proj.base, mode)\n+                                        self.is_mutable(place_base, &proj.base, mode)\n                                     }\n                                 }\n                             }\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::MutImmutable => Err((place_base, place_projection)),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n                                         Ok(RootPlace {\n-                                            place,\n+                                            place_base,\n+                                            place_projection,\n                                             is_local_mutation_allowed,\n                                         })\n                                     }\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => {\n-                                self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                self.is_mutable(place_base, &proj.base, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n@@ -2176,17 +2221,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(place);\n+                        let upvar_field_projection = self.is_upvar_field_projection(PlaceRef {\n+                            base: &place_base,\n+                            projection: &place_projection,\n+                        });\n                         if let Some(field) = upvar_field_projection {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n-                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                upvar, is_local_mutation_allowed, place\n+                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n+                                place={:?} {:?}\",\n+                                upvar, is_local_mutation_allowed, place_base, place_projection\n                             );\n                             match (upvar.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n                                 | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n-                                    Err(place)\n+                                    Err((place_base, place_projection))\n                                 }\n                                 (Mutability::Not, LocalMutationIsAllowed::Yes)\n                                 | (Mutability::Mut, _) => {\n@@ -2216,15 +2265,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     //     });\n                                     // }\n                                     // ```\n-                                    let _ = self.is_mutable(&proj.base, is_local_mutation_allowed)?;\n+                                    let _ = self.is_mutable(place_base,\n+                                                            &proj.base,\n+                                                            is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n-                                        place,\n+                                        place_base,\n+                                        place_projection,\n                                         is_local_mutation_allowed,\n                                     })\n                                 }\n                             }\n                         } else {\n-                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                            self.is_mutable(place_base, &proj.base, is_local_mutation_allowed)\n                         }\n                     }\n                 }\n@@ -2236,33 +2288,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n-    pub fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n-        let (place, by_ref) = if let Place::Projection(ref proj) = place {\n-            if let ProjectionElem::Deref = proj.elem {\n-                (&proj.base, true)\n-            } else {\n-                (place, false)\n-            }\n-        } else {\n-            (place, false)\n-        };\n-\n-        match place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let tcx = self.infcx.tcx;\n-                    let base_ty = proj.base.ty(self.body, tcx).ty;\n+    pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'cx, 'tcx>) -> Option<Field> {\n+        let mut place_projection = place_ref.projection;\n+        let mut by_ref = false;\n+\n+        if let Some(box Projection {\n+            base,\n+            elem: ProjectionElem::Deref,\n+        }) = place_projection {\n+            place_projection = &base;\n+            by_ref = true;\n+        }\n \n-                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n-                        (!by_ref || self.upvars[field.index()].by_ref)\n-                    {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n+        match place_projection {\n+            Some(box Projection {\n+                base,\n+                elem: ProjectionElem::Field(field, _ty),\n+            }) => {\n+                let tcx = self.infcx.tcx;\n+                let base_ty = Place::ty_from(place_ref.base, &base, self.body, tcx).ty;\n+\n+                if (base_ty.is_closure() || base_ty.is_generator()) &&\n+                    (!by_ref || self.upvars[field.index()].by_ref) {\n+                    Some(*field)\n+                } else {\n+                    None\n+                }\n             }\n+\n             _ => None,\n         }\n     }"}, {"sha": "38653dc0e5e9b79cf8596245ca84a1a2a35b3112", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -91,7 +91,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(local)),\n+                    Place {\n+                        base: PlaceBase::Local(local),\n+                        projection: None,\n+                    },\n                     box Rvalue::Use(Operand::Move(move_from)),\n                 )) = self.body.basic_blocks()[location.block]\n                     .statements\n@@ -128,7 +131,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let move_spans = self.move_spans(&original_path, location);\n+                let move_spans = self.move_spans(original_path.as_place_ref(), location);\n                 grouped_errors.push(GroupedMoveError::OtherIllegalMove {\n                     use_spans: move_spans,\n                     original_path,\n@@ -157,7 +160,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let from_simple_let = match_place.is_none();\n         let match_place = match_place.as_ref().unwrap_or(move_from);\n \n-        match self.move_data.rev_lookup.find(match_place) {\n+        match self.move_data.rev_lookup.find(match_place.as_place_ref()) {\n             // Error with the match place\n             LookupResult::Parent(_) => {\n                 for ge in &mut *grouped_errors {\n@@ -189,7 +192,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             // Error with the pattern\n             LookupResult::Exact(_) => {\n-                let mpi = match self.move_data.rev_lookup.find(move_from) {\n+                let mpi = match self.move_data.rev_lookup.find(move_from.as_place_ref()) {\n                     LookupResult::Parent(Some(mpi)) => mpi,\n                     // move_from should be a projection from match_place.\n                     _ => unreachable!(\"Probably not unreachable...\"),\n@@ -239,7 +242,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   self.is_upvar_field_projection(original_path));\n+                   self.is_upvar_field_projection(original_path.as_place_ref()));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n@@ -273,20 +276,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let mut base_static = place;\n-        loop {\n-            match base_static {\n-                Place::Base(_) => break,\n-                Place::Projection(box Projection { base, .. }) => base_static = base,\n+        let description = if place.projection.is_none() {\n+            format!(\"static item `{}`\", self.describe_place(place.as_place_ref()).unwrap())\n+        } else {\n+            let mut base_static = &place.projection;\n+            while let Some(box Projection { base: Some(ref proj), .. }) = base_static {\n+                base_static = &proj.base;\n             }\n-        }\n+            let base_static = PlaceRef {\n+                base: &place.base,\n+                projection: base_static,\n+            };\n \n-        let description = if let Place::Base(_) = place {\n-            format!(\"static item `{}`\", self.describe_place(place).unwrap())\n-        } else {\n             format!(\n                 \"`{:?}` as `{:?}` is a static item\",\n-                self.describe_place(place).unwrap(),\n+                self.describe_place(place.as_place_ref()).unwrap(),\n                 self.describe_place(base_static).unwrap(),\n             )\n         };\n@@ -304,16 +308,22 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n         let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n-        let upvar_field = self.prefixes(&move_place, PrefixSet::All)\n+        let upvar_field = self.prefixes(move_place.as_place_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n-        let deref_base = match deref_target_place {\n-            Place::Projection(box Projection { base, elem: ProjectionElem::Deref }) => base,\n+        let deref_base = match deref_target_place.projection {\n+            Some(box Projection { ref base, elem: ProjectionElem::Deref }) => PlaceRef {\n+                base: &deref_target_place.base,\n+                projection: base,\n+            },\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n-        if let Place::Base(PlaceBase::Local(local)) = *deref_base {\n-            let decl = &self.body.local_decls[local];\n+        if let PlaceRef {\n+            base: PlaceBase::Local(local),\n+            projection: None,\n+        } = deref_base {\n+            let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of(\n                     span,\n@@ -353,9 +363,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar_name = upvar.name;\n                 let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n \n-                let place_name = self.describe_place(move_place).unwrap();\n+                let place_name = self.describe_place(move_place.as_place_ref()).unwrap();\n \n-                let place_description = if self.is_upvar_field_projection(move_place).is_some() {\n+                let place_description = if self\n+                    .is_upvar_field_projection(move_place.as_place_ref())\n+                    .is_some()\n+                {\n                     format!(\"`{}`, a {}\", place_name, capture_description)\n                 } else {\n                     format!(\n@@ -379,7 +392,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             _ => {\n                 let source = self.borrowed_content_source(deref_base);\n-                match (self.describe_place(move_place), source.describe_for_named_place()) {\n+                match (\n+                    self.describe_place(move_place.as_place_ref()),\n+                    source.describe_for_named_place(),\n+                ) {\n                     (Some(place_desc), Some(source_desc)) => {\n                         self.cannot_move_out_of(\n                             span,\n@@ -439,7 +455,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n-                    let place_desc = match self.describe_place(&move_from) {\n+                    let place_desc = match self.describe_place(move_from.as_place_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n                     };\n@@ -467,7 +483,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n                 let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n-                let place_desc = match self.describe_place(original_path) {\n+                let place_desc = match self.describe_place(original_path.as_place_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),\n                 };"}, {"sha": "c424c06c41add30a8986b77cab091cbc4ca59082", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 180, "deletions": 99, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -2,7 +2,9 @@ use core::unicode::property::Pattern_White_Space;\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n-use rustc::mir::{Mutability, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind};\n+use rustc::mir::{\n+    Mutability, Place, PlaceRef, PlaceBase, Projection, ProjectionElem, Static, StaticKind\n+};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n@@ -25,7 +27,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         &mut self,\n         access_place: &Place<'tcx>,\n         span: Span,\n-        the_place_err: &Place<'tcx>,\n+        the_place_err: PlaceRef<'cx, 'tcx>,\n         error_access: AccessKind,\n         location: Location,\n     ) {\n@@ -40,13 +42,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let item_msg;\n         let reason;\n         let mut opt_source = None;\n-        let access_place_desc = self.describe_place(access_place);\n+        let access_place_desc = self.describe_place(access_place.as_place_ref());\n         debug!(\"report_mutability_error: access_place_desc={:?}\", access_place_desc);\n \n         match the_place_err {\n-            Place::Base(PlaceBase::Local(local)) => {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if let Place::Base(PlaceBase::Local(_)) = access_place {\n+                if let Place {\n+                    base: PlaceBase::Local(_),\n+                    projection: None,\n+                } = access_place {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.body.local_decls[*local]\n@@ -56,51 +64,70 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            Place::Projection(box Projection {\n-                base,\n-                elem: ProjectionElem::Field(upvar_index, _),\n-            }) => {\n+            PlaceRef {\n+                base: _,\n+                projection:\n+                    Some(box Projection {\n+                        base,\n+                        elem: ProjectionElem::Field(upvar_index, _),\n+                    }),\n+            } => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&the_place_err.base, &base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if self.is_upvar_field_projection(access_place).is_some() {\n+                if self.is_upvar_field_projection(access_place.as_place_ref()).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.upvars[upvar_index.index()].name;\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n \n-            Place::Projection(box Projection {\n-                base,\n-                elem: ProjectionElem::Deref,\n-            }) => {\n-                if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n+            PlaceRef {\n+                base: _,\n+                projection:\n+                    Some(box Projection {\n+                        base,\n+                        elem: ProjectionElem::Deref,\n+                    }),\n+            } => {\n+                if the_place_err.base == &PlaceBase::Local(Local::new(1)) &&\n+                    base.is_none() &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.body, self.infcx.tcx).ty\n+                        Place::ty_from(\n+                            the_place_err.base,\n+                            the_place_err.projection,\n+                            self.body,\n+                            self.infcx.tcx\n+                        )\n+                        .ty\n                     ));\n \n-                    reason = if self.is_upvar_field_projection(access_place).is_some() {\n-                        \", as it is a captured variable in a `Fn` closure\".to_string()\n-                    } else {\n-                        \", as `Fn` closures cannot mutate their captured variables\".to_string()\n-                    }\n+                    reason =\n+                        if self.is_upvar_field_projection(access_place.as_place_ref()).is_some() {\n+                            \", as it is a captured variable in a `Fn` closure\".to_string()\n+                        } else {\n+                            \", as `Fn` closures cannot mutate their captured variables\".to_string()\n+                        }\n                 } else if {\n-                    if let Place::Base(PlaceBase::Local(local)) = *base {\n-                        self.body.local_decls[local].is_ref_for_guard()\n+                    if let (PlaceBase::Local(local), None) = (&the_place_err.base, base) {\n+                        self.body.local_decls[*local].is_ref_for_guard()\n                     } else {\n                         false\n                     }\n                 } {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n-                    let source = self.borrowed_content_source(base);\n+                    let source = self.borrowed_content_source(PlaceRef {\n+                        base: the_place_err.base,\n+                        projection: base,\n+                    });\n                     let pointer_type = source.describe_for_immutable_place();\n                     opt_source = Some(source);\n                     if let Some(desc) = access_place_desc {\n@@ -119,11 +146,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) =>\n-                unreachable!(),\n+            PlaceRef {\n+                base:\n+                    PlaceBase::Static(box Static {\n+                        kind: StaticKind::Promoted(_),\n+                        ..\n+                    }),\n+                projection: None,\n+            } => unreachable!(),\n \n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })) => {\n-                if let Place::Base(PlaceBase::Static(_)) = access_place {\n+            PlaceRef {\n+                base:\n+                    PlaceBase::Static(box Static {\n+                        kind: StaticKind::Static(def_id),\n+                        ..\n+                    }),\n+                projection: None,\n+            } => {\n+                if let Place {\n+                    base: PlaceBase::Static(_),\n+                    projection: None,\n+                } = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {\n@@ -133,22 +176,36 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            Place::Projection(box Projection {\n+            PlaceRef {\n                 base: _,\n-                elem: ProjectionElem::Index(_),\n-            })\n-            | Place::Projection(box Projection {\n+                projection:\n+                    Some(box Projection {\n+                        base: _,\n+                        elem: ProjectionElem::Index(_),\n+                    }),\n+            }\n+            | PlaceRef {\n                 base: _,\n-                elem: ProjectionElem::ConstantIndex { .. },\n-            })\n-            | Place::Projection(box Projection {\n+                projection:\n+                    Some(box Projection {\n+                        base: _,\n+                        elem: ProjectionElem::ConstantIndex { .. },\n+                    }),\n+            }\n+            | PlaceRef {\n                 base: _,\n-                elem: ProjectionElem::Subslice { .. },\n-            })\n-            | Place::Projection(box Projection {\n+                projection: Some(box Projection {\n+                    base: _,\n+                    elem: ProjectionElem::Subslice { .. },\n+                }),\n+            }\n+            | PlaceRef {\n                 base: _,\n-                elem: ProjectionElem::Downcast(..),\n-            }) => bug!(\"Unexpected immutable place.\"),\n+                projection: Some(box Projection {\n+                    base: _,\n+                    elem: ProjectionElem::Downcast(..),\n+                }),\n+            } => bug!(\"Unexpected immutable place.\"),\n         }\n \n         debug!(\"report_mutability_error: item_msg={:?}, reason={:?}\", item_msg, reason);\n@@ -187,7 +244,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\n                         \"mutable borrow occurs due to use of `{}` in closure\",\n                         // always Some() if the message is printed.\n-                        self.describe_place(access_place).unwrap_or_default(),\n+                        self.describe_place(access_place.as_place_ref()).unwrap_or_default(),\n                     )\n                 );\n                 borrow_span\n@@ -203,21 +260,24 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // something like `*((*_1).0`. The local that we get will be a reference to the\n             // struct we've got a field access of (it must be a reference since there's a deref\n             // after the field access).\n-            Place::Projection(box Projection {\n-                base: Place::Projection(box Projection {\n-                    base: Place::Projection(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Deref,\n+            PlaceRef {\n+                base,\n+                projection: Some(box Projection {\n+                    base: Some(box Projection {\n+                        base: Some(box Projection {\n+                            base: base_proj,\n+                            elem: ProjectionElem::Deref,\n+                        }),\n+                        elem: ProjectionElem::Field(field, _),\n                     }),\n-                    elem: ProjectionElem::Field(field, _),\n+                    elem: ProjectionElem::Deref,\n                 }),\n-                elem: ProjectionElem::Deref,\n-            }) => {\n+            } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    base.ty(self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(&base, &base_proj, self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -230,43 +290,46 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             },\n \n             // Suggest removing a `&mut` from the use of a mutable reference.\n-            Place::Base(PlaceBase::Local(local))\n-                if {\n-                    self.body.local_decls.get(*local).map(|local_decl| {\n-                        if let ClearCrossCrate::Set(\n-                            mir::BindingForm::ImplicitSelf(kind)\n-                        ) = local_decl.is_user_variable.as_ref().unwrap() {\n-                            // Check if the user variable is a `&mut self` and we can therefore\n-                            // suggest removing the `&mut`.\n-                            //\n-                            // Deliberately fall into this case for all implicit self types,\n-                            // so that we don't fall in to the next case with them.\n-                            *kind == mir::ImplicitSelfKind::MutRef\n-                        } else if Some(kw::SelfLower) == local_decl.name {\n-                            // Otherwise, check if the name is the self kewyord - in which case\n-                            // we have an explicit self. Do the same thing in this case and check\n-                            // for a `self: &mut Self` to suggest removing the `&mut`.\n-                            if let ty::Ref(\n-                                _, _, hir::Mutability::MutMutable\n-                            ) = local_decl.ty.sty {\n-                                true\n-                            } else {\n-                                false\n-                            }\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } if {\n+                self.body.local_decls.get(*local).map(|local_decl| {\n+                    if let ClearCrossCrate::Set(\n+                        mir::BindingForm::ImplicitSelf(kind)\n+                    ) = local_decl.is_user_variable.as_ref().unwrap() {\n+                        // Check if the user variable is a `&mut self` and we can therefore\n+                        // suggest removing the `&mut`.\n+                        //\n+                        // Deliberately fall into this case for all implicit self types,\n+                        // so that we don't fall in to the next case with them.\n+                        *kind == mir::ImplicitSelfKind::MutRef\n+                    } else if Some(kw::SelfLower) == local_decl.name {\n+                        // Otherwise, check if the name is the self kewyord - in which case\n+                        // we have an explicit self. Do the same thing in this case and check\n+                        // for a `self: &mut Self` to suggest removing the `&mut`.\n+                        if let ty::Ref(\n+                            _, _, hir::Mutability::MutMutable\n+                        ) = local_decl.ty.sty {\n+                            true\n                         } else {\n                             false\n                         }\n-                    }).unwrap_or(false)\n-                } =>\n-            {\n+                    } else {\n+                        false\n+                    }\n+                }).unwrap_or(false)\n+            } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_label(span, \"try removing `&mut` here\");\n             },\n \n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n-            Place::Base(PlaceBase::Local(local))\n-                if self.body.local_decls[*local].can_be_made_mutable() => {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } if self.body.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n@@ -284,12 +347,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             // Also suggest adding mut for upvars\n-            Place::Projection(box Projection {\n+            PlaceRef {\n                 base,\n-                elem: ProjectionElem::Field(upvar_index, _),\n-            }) => {\n+                projection: Some(box Projection {\n+                    base: proj_base,\n+                    elem: ProjectionElem::Field(upvar_index, _),\n+                }),\n+            } => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&base, &proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -317,8 +383,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            Place::Base(PlaceBase::Local(_))\n-                if {\n+            PlaceRef {\n+                base: PlaceBase::Local(_),\n+                projection: None,\n+            } if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n                     } else {\n@@ -330,10 +398,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, \"try removing `&mut` here\");\n             }\n \n-            Place::Projection(box Projection {\n-                base: Place::Base(PlaceBase::Local(local)),\n-                elem: ProjectionElem::Deref,\n-            }) if {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } if {\n                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n                     self.body.local_decls[*local].is_user_variable\n                 {\n@@ -354,10 +425,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             //\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n-            Place::Projection(box Projection {\n-                base: Place::Base(PlaceBase::Local(local)),\n-                elem: ProjectionElem::Deref,\n-            }) if self.body.local_decls[*local].is_user_variable.is_some() =>\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } if self.body.local_decls[*local].is_user_variable.is_some() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n@@ -434,10 +508,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            Place::Projection(box Projection {\n+            PlaceRef {\n                 base,\n-                elem: ProjectionElem::Deref,\n-            }) if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            // FIXME document what is this 1 magic number about\n+            } if *base == PlaceBase::Local(Local::new(1)) &&\n                   !self.upvars.is_empty() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -447,10 +525,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            Place::Projection(box Projection {\n+            PlaceRef {\n                 base: _,\n-                elem: ProjectionElem::Deref,\n-            }) => {\n+                projection: Some(box Projection {\n+                    base: _,\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 match opt_source {"}, {"sha": "055568f0a27a21e056306d88f0deb932668965d0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -128,7 +128,10 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n         // When we see `X = ...`, then kill borrows of\n         // `(*X).foo` and so forth.\n         if let Some(all_facts) = self.all_facts {\n-            if let Place::Base(PlaceBase::Local(temp)) = place {\n+            if let Place {\n+                base: PlaceBase::Local(temp),\n+                projection: None,\n+            } = place {\n                 if let Some(borrow_indices) = self.borrow_set.local_map.get(temp) {\n                     all_facts.killed.reserve(borrow_indices.len());\n                     for &borrow_index in borrow_indices {"}, {"sha": "abb84c59d9b9e740b6febb840fd4a89bf6ccc893", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -7,7 +7,7 @@ use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n     CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, PlaceBase,\n-    Projection, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n+    Rvalue, Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::adjustment::{PointerCast};\n@@ -252,7 +252,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = body.source_info(location).span;\n                 let spans = self\n-                    .move_spans(&Place::from(local), location)\n+                    .move_spans(Place::from(local).as_place_ref(), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 let borrow_location = location;\n@@ -272,7 +272,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mut should_note_order = false;\n                 if body.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Place::Base(PlaceBase::Local(borrowed_local)) = place {\n+                        if let Place {\n+                            base: PlaceBase::Local(borrowed_local),\n+                            projection: None,\n+                        } = place {\n                              if body.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n                             {\n@@ -301,7 +304,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             region,\n                         );\n                     if let Some(region_name) = region_name {\n-                        let opt_place_desc = self.describe_place(&borrow.borrowed_place);\n+                        let opt_place_desc =\n+                            self.describe_place(borrow.borrowed_place.as_place_ref());\n                         BorrowExplanation::MustBeValidFor {\n                             category,\n                             from_closure,\n@@ -489,8 +493,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n-                            Operand::Copy(Place::Base(PlaceBase::Local(l))) |\n-                            Operand::Move(Place::Base(PlaceBase::Local(l))) => {\n+                            Operand::Copy(Place {\n+                                base: PlaceBase::Local(l),\n+                                projection: None,\n+                            }) |\n+                            Operand::Move(Place {\n+                                base: PlaceBase::Local(l),\n+                                projection: None,\n+                            }) => {\n                                 let local_decl = &self.body.local_decls[*l];\n                                 if local_decl.name.is_none() {\n                                     local_decl.source_info.span\n@@ -531,7 +541,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _),\n+            kind: StatementKind::Assign(Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            }, _),\n             ..\n         }) = stmt\n         {\n@@ -555,13 +568,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // The only kind of statement that we care about is assignments...\n                 if let StatementKind::Assign(place, box rvalue) = &stmt.kind {\n-                    let into = match place {\n-                        Place::Base(PlaceBase::Local(into)) => into,\n-                        Place::Projection(box Projection {\n-                            base: Place::Base(PlaceBase::Local(into)),\n-                            elem: ProjectionElem::Deref,\n-                        }) => into,\n-                        _ => {\n+                    let into = match place.local_or_deref_local() {\n+                        Some(into) => into,\n+                        None => {\n                             // Continue at the next location.\n                             queue.push(current_location.successor_within_block());\n                             continue;\n@@ -572,11 +581,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place::Base(PlaceBase::Local(from)))\n-                            | Operand::Move(Place::Base(PlaceBase::Local(from)))\n+                            Operand::Copy(Place {\n+                                base: PlaceBase::Local(from),\n+                                projection: None,\n+                            })\n+                            | Operand::Move(Place {\n+                                base: PlaceBase::Local(from),\n+                                projection: None,\n+                            })\n                                 if *from == target =>\n                             {\n-                                target = *into;\n+                                target = into;\n                             }\n                             _ => {}\n                         },\n@@ -585,8 +600,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Cast(\n                             CastKind::Pointer(PointerCast::Unsize), operand, ty\n                         ) => match operand {\n-                            Operand::Copy(Place::Base(PlaceBase::Local(from)))\n-                            | Operand::Move(Place::Base(PlaceBase::Local(from)))\n+                            Operand::Copy(Place {\n+                                base: PlaceBase::Local(from),\n+                                projection: None,\n+                            })\n+                            | Operand::Move(Place {\n+                                base: PlaceBase::Local(from),\n+                                projection: None,\n+                            })\n                                 if *from == target =>\n                             {\n                                 debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n@@ -616,7 +637,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n \n                 if let TerminatorKind::Call {\n-                    destination: Some((Place::Base(PlaceBase::Local(dest)), block)),\n+                    destination: Some((Place {\n+                        base: PlaceBase::Local(dest),\n+                        projection: None,\n+                    }, block)),\n                     args,\n                     ..\n                 } = &terminator.kind\n@@ -627,7 +651,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                     // Check if one of the arguments to this function is the target place.\n                     let found_target = args.iter().any(|arg| {\n-                        if let Operand::Move(Place::Base(PlaceBase::Local(potential))) = arg {\n+                        if let Operand::Move(Place {\n+                            base: PlaceBase::Local(potential),\n+                            projection: None,\n+                        }) = arg {\n                             *potential == target\n                         } else {\n                             false"}, {"sha": "b0e364fa2dd9a0e5e779a219e2d8398d46876366", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -499,13 +499,16 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             };\n \n             // FIXME use place_projection.is_empty() when is available\n-            if let Place::Base(_) = place {\n+            if place.projection.is_none() {\n                 if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n                     let is_promoted = match place {\n-                        Place::Base(PlaceBase::Static(box Static {\n-                            kind: StaticKind::Promoted(_),\n-                            ..\n-                        })) => true,\n+                        Place {\n+                            base: PlaceBase::Static(box Static {\n+                                kind: StaticKind::Promoted(_),\n+                                ..\n+                            }),\n+                            projection: None,\n+                        } => true,\n                         _ => false,\n                     };\n \n@@ -1345,15 +1348,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n-                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => if let BorrowCheckContext {\n+                    Place {\n+                        base: PlaceBase::Local(RETURN_PLACE),\n+                        projection: None,\n+                    } => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n                                 ..\n                             },\n                         ..\n-                    } = self.borrowck_context\n-                    {\n+                    } = self.borrowck_context {\n                         if tcx.is_static(*def_id) {\n                             ConstraintCategory::UseAsStatic\n                         } else {\n@@ -1362,8 +1367,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Place::Base(PlaceBase::Local(l))\n-                        if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Place {\n+                        base: PlaceBase::Local(l),\n+                        projection: None,\n+                    } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1647,7 +1654,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(body, tcx).ty;\n                 let category = match *dest {\n-                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n+                    Place {\n+                        base: PlaceBase::Local(RETURN_PLACE),\n+                        projection: None,\n+                    } => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n@@ -1666,8 +1676,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Place::Base(PlaceBase::Local(l))\n-                        if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Place {\n+                        base: PlaceBase::Local(l),\n+                        projection: None,\n+                    } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -2400,19 +2412,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // *p`, where the `p` has type `&'b mut Foo`, for example, we\n         // need to ensure that `'b: 'a`.\n \n-        let mut borrowed_place = borrowed_place;\n+        let mut borrowed_projection = &borrowed_place.projection;\n \n         debug!(\n             \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n             location, borrow_region, borrowed_place\n         );\n-        while let Place::Projection(box Projection { base, elem }) = borrowed_place {\n-            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n+        while let Some(box proj) = borrowed_projection {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_projection);\n \n-            match *elem {\n+            match proj.elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(body, tcx).ty;\n+                    let base_ty = Place::ty_from(&borrowed_place.base, &proj.base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n@@ -2477,7 +2489,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n             // The \"propagate\" case. We need to check that our base is valid\n             // for the borrow's lifetime.\n-            borrowed_place = base;\n+            borrowed_projection = &proj.base;\n         }\n     }\n "}, {"sha": "75065816df0506363766dbda7f46b4ce34eec211", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -50,7 +50,7 @@ pub(super) fn each_borrow_involving_path<'tcx, F, I, S>(\n             body,\n             &borrowed.borrowed_place,\n             borrowed.kind,\n-            place,\n+            place.as_place_ref(),\n             access,\n             places_conflict::PlaceConflictBias::Overlap,\n         ) {"}, {"sha": "72d5588c34120523522ce5971e14c52f0c7b7f2b", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n \n             for proj in place_projection {\n                 if proj.elem == ProjectionElem::Deref {\n-                    let ty = proj.base.ty(body, tcx).ty;\n+                    let ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and"}, {"sha": "348214f97f25606c1c27a458016335fcec77d72c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -3,8 +3,8 @@ use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{\n-    BorrowKind, Body, Place, PlaceBase, Projection, ProjectionElem, ProjectionsIter,\n-    StaticKind\n+    Body, BorrowKind, Place, PlaceBase, PlaceRef, Projection, ProjectionElem, ProjectionsIter,\n+    StaticKind,\n };\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n@@ -36,7 +36,7 @@ crate fn places_conflict<'tcx>(\n         body,\n         borrow_place,\n         BorrowKind::Mut { allow_two_phase_borrow: true },\n-        access_place,\n+        access_place.as_place_ref(),\n         AccessDepth::Deep,\n         bias,\n     )\n@@ -51,7 +51,7 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_place: &Place<'tcx>,\n+    access_place: PlaceRef<'_, 'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -62,8 +62,14 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n \n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n-    if let Place::Base(PlaceBase::Local(l1)) = borrow_place {\n-        if let Place::Base(PlaceBase::Local(l2)) = access_place {\n+    if let Place {\n+        base: PlaceBase::Local(l1),\n+        projection: None,\n+    } = borrow_place {\n+        if let PlaceRef {\n+            base: PlaceBase::Local(l2),\n+            projection: None,\n+        } = access_place {\n             return l1 == l2;\n         }\n     }\n@@ -175,7 +181,7 @@ fn place_components_conflict<'tcx>(\n                 // check whether the components being borrowed vs\n                 // accessed are disjoint (as in the second example,\n                 // but not the first).\n-                match place_projection_conflict(tcx, body, borrow_c, access_c, bias) {\n+                match place_projection_conflict(tcx, body, borrow_base, borrow_c, access_c, bias) {\n                     Overlap::Arbitrary => {\n                         // We have encountered different fields of potentially\n                         // the same union - the borrow now partially overlaps.\n@@ -214,7 +220,7 @@ fn place_components_conflict<'tcx>(\n \n                 let base = &borrow_c.base;\n                 let elem = &borrow_c.elem;\n-                let base_ty = base.ty(body, tcx).ty;\n+                let base_ty = Place::ty_from(borrow_base, base, body, tcx).ty;\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -368,6 +374,7 @@ fn place_base_conflict<'tcx>(\n fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n+    pi1_base: &PlaceBase<'tcx>,\n     pi1: &Projection<'tcx>,\n     pi2: &Projection<'tcx>,\n     bias: PlaceConflictBias,\n@@ -384,7 +391,7 @@ fn place_projection_conflict<'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = pi1.base.ty(body, tcx).ty;\n+                let ty = Place::ty_from(pi1_base, &pi1.base, body, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck."}, {"sha": "ecafd4eb1157ec3c1284d657cfb1113adb47172d", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 55, "deletions": 30, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -11,26 +11,23 @@ use super::MirBorrowckCtxt;\n \n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{Body, Place, PlaceBase, ProjectionElem};\n+use rustc::mir::{Body, Place, PlaceBase, PlaceRef, ProjectionElem};\n \n-pub trait IsPrefixOf<'tcx> {\n-    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n+pub trait IsPrefixOf<'cx, 'tcx> {\n+    fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool;\n }\n \n-impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n-    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n-        let mut cursor = other;\n+impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n+    fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n+        let mut cursor = other.projection;\n         loop {\n-            if self == cursor {\n-                return true;\n+            if self.projection == cursor {\n+                return self.base == other.base;\n             }\n \n-            match *cursor {\n-                Place::Base(PlaceBase::Local(_)) |\n-                Place::Base(PlaceBase::Static(_)) => return false,\n-                Place::Projection(ref proj) => {\n-                    cursor = &proj.base;\n-                }\n+            match cursor {\n+                None => return false,\n+                Some(proj) => cursor = &proj.base,\n             }\n         }\n     }\n@@ -40,7 +37,7 @@ pub(super) struct Prefixes<'cx, 'tcx> {\n     body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n-    next: Option<&'cx Place<'tcx>>,\n+    next: Option<(PlaceRef<'cx, 'tcx>)>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -59,9 +56,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns an iterator over the prefixes of `place`\n     /// (inclusive) from longest to smallest, potentially\n     /// terminating the iteration early based on `kind`.\n-    pub(super) fn prefixes(&self, place: &'cx Place<'tcx>, kind: PrefixSet) -> Prefixes<'cx, 'tcx> {\n+    pub(super) fn prefixes(\n+        &self,\n+        place_ref: PlaceRef<'cx, 'tcx>,\n+        kind: PrefixSet,\n+    ) -> Prefixes<'cx, 'tcx> {\n         Prefixes {\n-            next: Some(place),\n+            next: Some(place_ref),\n             kind,\n             body: self.body,\n             tcx: self.infcx.tcx,\n@@ -70,7 +71,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n-    type Item = &'cx Place<'tcx>;\n+    type Item = PlaceRef<'cx, 'tcx>;\n     fn next(&mut self) -> Option<Self::Item> {\n         let mut cursor = self.next?;\n \n@@ -80,27 +81,42 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {\n-            let proj = match *cursor {\n-                Place::Base(PlaceBase::Local(_)) | // search yielded this leaf\n-                Place::Base(PlaceBase::Static(_)) => {\n+            let proj = match &cursor {\n+                PlaceRef {\n+                    base: PlaceBase::Local(_),\n+                    projection: None,\n+                }\n+                | // search yielded this leaf\n+                PlaceRef {\n+                    base: PlaceBase::Static(_),\n+                    projection: None,\n+                } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n-\n-                Place::Projection(ref proj) => proj,\n+                PlaceRef {\n+                    base: _,\n+                    projection: Some(proj),\n+                } => proj,\n             };\n \n             match proj.elem {\n                 ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n-                        // FIXME: add union handling\n-                    self.next = Some(&proj.base);\n+                    // FIXME: add union handling\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n                 ProjectionElem::Downcast(..) |\n                 ProjectionElem::Subslice { .. } |\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Index(_) => {\n-                    cursor = &proj.base;\n+                    cursor = PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    };\n                     continue 'cursor;\n                 }\n                 ProjectionElem::Deref => {\n@@ -121,7 +137,10 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                 PrefixSet::All => {\n                     // all prefixes: just blindly enqueue the base\n                     // of the projection\n-                    self.next = Some(&proj.base);\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n                 PrefixSet::Supporting => {\n@@ -134,7 +153,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n             // derefs, except we stop at the deref of a shared\n             // reference.\n \n-            let ty = proj.base.ty(self.body, self.tcx).ty;\n+            let ty = Place::ty_from(cursor.base, &proj.base, self.body, self.tcx).ty;\n             match ty.sty {\n                 ty::RawPtr(_) |\n                 ty::Ref(\n@@ -152,12 +171,18 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     _, /*ty*/\n                     hir::MutMutable,\n                     ) => {\n-                    self.next = Some(&proj.base);\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n \n                 ty::Adt(..) if ty.is_box() => {\n-                    self.next = Some(&proj.base);\n+                    self.next = Some(PlaceRef {\n+                        base: cursor.base,\n+                        projection: &proj.base,\n+                    });\n                     return Some(cursor);\n                 }\n "}, {"sha": "2587d14a73a8fe9df62ed74f4f641991e16ed6b3", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -59,7 +59,7 @@ impl GatherUsedMutsVisitor<'_, '_, '_> {\n         // be those that were never initialized - we will consider those as being used as\n         // they will either have been removed by unreachable code optimizations; or linted\n         // as unused variables.\n-        if let Some(local) = into.base_local() {\n+        if let PlaceBase::Local(local) = into.base {\n             let _ = self.never_initialized_mut_locals.remove(&local);\n         }\n     }\n@@ -90,7 +90,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n     ) {\n         match &statement.kind {\n             StatementKind::Assign(into, _) => {\n-                if let Some(local) = into.base_local() {\n+                if let PlaceBase::Local(local) = into.base {\n                     debug!(\n                         \"visit_statement: statement={:?} local={:?} \\\n                          never_initialized_mut_locals={:?}\",\n@@ -118,7 +118,10 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                     \"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n                     path.place, local, path.place\n                 );\n-                if let Place::Base(PlaceBase::Local(user_local)) = path.place {\n+                if let Place {\n+                    base: PlaceBase::Local(user_local),\n+                    projection: None,\n+                } = path.place {\n                     self.mbcx.used_mut.insert(user_local);\n                 }\n             }"}, {"sha": "2d9e7ac75c7b80449b3abc744043423539e3ba59", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -123,10 +123,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 block.and(place)\n             }\n-            ExprKind::StaticRef { id } => block.and(Place::Base(PlaceBase::Static(Box::new(Static {\n-                ty: expr.ty,\n-                kind: StaticKind::Static(id),\n-            })))),\n+            ExprKind::StaticRef { id } => block.and(Place {\n+                base: PlaceBase::Static(Box::new(Static {\n+                    ty: expr.ty,\n+                    kind: StaticKind::Static(id),\n+                })),\n+                projection: None,\n+            }),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place = unpack!(block = this.as_place(block, source));"}, {"sha": "851a6b0b07cf6632c1b0d95bcc904feebfc09e7b", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -497,32 +497,48 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place {\n-            Place::Base(PlaceBase::Local(local)) => this.local_decls[local].mutability,\n-            Place::Projection(box Projection {\n-                base: Place::Base(PlaceBase::Local(local)),\n-                elem: ProjectionElem::Deref,\n-            }) => {\n+            Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => this.local_decls[local].mutability,\n+            Place {\n+                base: PlaceBase::Local(local),\n+                projection: Some(box Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                })\n+            } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n                 this.local_decls[local].mutability\n             }\n-            Place::Projection(box Projection {\n+            Place {\n+                ref base,\n+                projection: Some(box Projection {\n+                    base: ref base_proj,\n+                    elem: ProjectionElem::Field(upvar_index, _),\n+                }),\n+            }\n+            | Place {\n                 ref base,\n-                elem: ProjectionElem::Field(upvar_index, _),\n-            })\n-            | Place::Projection(box Projection {\n-                base:\n-                    Place::Projection(box Projection {\n-                        ref base,\n+                projection: Some(box Projection {\n+                    base: Some(box Projection {\n+                        base: ref base_proj,\n                         elem: ProjectionElem::Field(upvar_index, _),\n                     }),\n-                elem: ProjectionElem::Deref,\n-            }) => {\n+                    elem: ProjectionElem::Deref,\n+                }),\n+            } => {\n+                let place = PlaceRef {\n+                    base,\n+                    projection: base_proj,\n+                };\n+\n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!(\n-                    match base.local_or_deref_local() {\n+                    match place.local_or_deref_local() {\n                         Some(local) => local == Local::new(1),\n                         None => false,\n                     },"}, {"sha": "2815361a647605e2ffc3cb0711fea04ab4928084", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Create a \"fake\" temporary variable so that we check that the\n                 // value is Sized. Usually, this is caught in type checking, but\n                 // in the case of box expr there is no such check.\n-                if let Place::Projection(..) = destination {\n+                if destination.projection.is_some() {\n                     this.local_decls\n                         .push(LocalDecl::new_temp(expr.ty, expr.span));\n                 }"}, {"sha": "b58cef9cce1e7779886da6a9023d81f9f95a8324", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, local_id, var_ty, DropKind::Storage);\n-        Place::Base(PlaceBase::Local(local_id))\n+        Place::from(local_id)\n     }\n \n     pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n@@ -937,11 +937,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for Binding { source, .. }\n                 in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n-                let mut cursor = source;\n-                while let Place::Projection(box Projection { base, elem }) = cursor {\n+                let mut cursor = &source.projection;\n+                while let Some(box Projection { base, elem }) = cursor {\n                     cursor = base;\n                     if let ProjectionElem::Deref = elem {\n-                        fake_borrows.insert(cursor.clone());\n+                        fake_borrows.insert(Place {\n+                            base: source.base.clone(),\n+                            projection: cursor.clone(),\n+                        });\n                         break;\n                     }\n                 }\n@@ -1277,7 +1280,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         fake_borrows: &'b FxHashSet<Place<'tcx>>,\n         temp_span: Span,\n-    ) -> Vec<(&'b Place<'tcx>, Local)> {\n+    ) -> Vec<(PlaceRef<'b, 'tcx>, Local)> {\n         let tcx = self.hir.tcx();\n \n         debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n@@ -1287,18 +1290,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n         for place in fake_borrows\n         {\n-            let mut prefix_cursor = place;\n-            while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n+            let mut prefix_cursor = &place.projection;\n+            while let Some(box Projection { base, elem }) = prefix_cursor {\n                 if let ProjectionElem::Deref = elem {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push(base);\n+                    all_fake_borrows.push(PlaceRef {\n+                        base: &place.base,\n+                        projection: base,\n+                    });\n                 }\n                 prefix_cursor = base;\n             }\n \n-            all_fake_borrows.push(place);\n+            all_fake_borrows.push(place.as_place_ref());\n         }\n \n         // Deduplicate and ensure a deterministic order.\n@@ -1308,7 +1314,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n \n         all_fake_borrows.into_iter().map(|matched_place| {\n-            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n+            let fake_borrow_deref_ty = Place::ty_from(\n+                matched_place.base,\n+                matched_place.projection,\n+                &self.local_decls,\n+                tcx,\n+            )\n+            .ty;\n             let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n             let fake_borrow_temp = self.local_decls.push(\n                 LocalDecl::new_temp(fake_borrow_ty, temp_span)\n@@ -1339,7 +1351,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         guard: Option<Guard<'tcx>>,\n-        fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n+        fake_borrows: &Vec<(PlaceRef<'_, 'tcx>, Local)>,\n         scrutinee_span: Span,\n         region_scope: region::Scope,\n     ) -> BasicBlock {\n@@ -1470,16 +1482,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             let re_erased = tcx.lifetimes.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n-            for &(place, temp) in fake_borrows {\n+            for (place, temp) in fake_borrows {\n                 let borrow = Rvalue::Ref(\n                     re_erased,\n                     BorrowKind::Shallow,\n-                    place.clone(),\n+                    Place {\n+                        base: place.base.clone(),\n+                        projection: place.projection.clone(),\n+                    },\n                 );\n                 self.cfg.push_assign(\n                     block,\n                     scrutinee_source_info,\n-                    &Place::from(temp),\n+                    &Place::from(*temp),\n                     borrow,\n                 );\n             }\n@@ -1549,7 +1564,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // place they refer to can't be modified by the guard.\n             for binding in by_value_bindings.clone() {\n                 let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n-                    let place = Place::from(local_id);\n+                let place = Place::from(local_id);\n                 self.cfg.push(\n                     post_guard_block,\n                     Statement {"}, {"sha": "a04c041ca9dc7e8e0969f813c5ac9b1010cadac0", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -851,8 +851,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If constants and statics, we don't generate StorageLive for this\n             // temporary, so don't try to generate StorageDead for it either.\n             _ if self.local_scope().is_none() => (),\n-            Operand::Copy(Place::Base(PlaceBase::Local(cond_temp)))\n-            | Operand::Move(Place::Base(PlaceBase::Local(cond_temp))) => {\n+            Operand::Copy(Place {\n+                base: PlaceBase::Local(cond_temp),\n+                projection: None,\n+            })\n+            | Operand::Move(Place {\n+                base: PlaceBase::Local(cond_temp),\n+                projection: None,\n+            }) => {\n                 // Manually drop the condition on both branches.\n                 let top_scope = self.scopes.scopes.last_mut().unwrap();\n                 let top_drop_data = top_scope.drops.pop().unwrap();"}, {"sha": "b6dd544d395618945126a8b1f75936fdb458fbfb", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -14,8 +14,8 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n-        match move_data.move_paths[child_index].place {\n-            mir::Place::Projection(ref proj) => {\n+        match move_data.move_paths[child_index].place.projection {\n+            Some(ref proj) => {\n                 if cond(proj) {\n                     return Some(child_index)\n                 }\n@@ -171,7 +171,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'tcx, F>(\n     let move_data = &ctxt.move_data;\n     for arg in body.args_iter() {\n         let place = mir::Place::from(arg);\n-        let lookup_result = move_data.rev_lookup.find(&place);\n+        let lookup_result = move_data.rev_lookup.find(place.as_place_ref());\n         on_lookup_result_bits(tcx, body, move_data,\n                               lookup_result,\n                               |mpi| callback(mpi, DropFlagState::Present));"}, {"sha": "10c3e52b5255a62464fc30009c12259d021ddcea", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     ) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n-        if let Some(local) = place.base_local() {\n+        if let PlaceBase::Local(local) = place.base {\n             let other_borrows_of_local = self\n                 .borrow_set\n                 .local_map\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // If the borrowed place is a local with no projections, all other borrows of this\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n-            if let Place::Base(PlaceBase::Local(_)) = place {\n+            if place.projection.is_none() {\n                 trans.kill_all(other_borrows_of_local);\n                 return;\n             }"}, {"sha": "ade732bbb75970ad08126d0a2434fb2e853e38a9", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_place),\n+                              self.move_data().rev_lookup.find(dest_place.as_place_ref()),\n                               |mpi| { in_out.insert(mpi); });\n     }\n }\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_place),\n+                              self.move_data().rev_lookup.find(dest_place.as_place_ref()),\n                               |mpi| { in_out.remove(mpi); });\n     }\n }\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n-                              self.move_data().rev_lookup.find(dest_place),\n+                              self.move_data().rev_lookup.find(dest_place.as_place_ref()),\n                               |mpi| { in_out.insert(mpi); });\n     }\n }"}, {"sha": "0e01701ea9e4467ccd068289ebaf4578538a8e33", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -121,11 +121,15 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(ref place, _)\n             | StatementKind::SetDiscriminant { ref place, .. } => {\n-                place.base_local().map(|l| sets.gen(l));\n+                if let PlaceBase::Local(local) = place.base {\n+                    sets.gen(local);\n+                }\n             }\n             StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n                 for p in &**outputs {\n-                    p.base_local().map(|l| sets.gen(l));\n+                    if let PlaceBase::Local(local) = p.base {\n+                        sets.gen(local);\n+                    }\n                 }\n             }\n             _ => (),\n@@ -146,7 +150,9 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         _dest_bb: mir::BasicBlock,\n         dest_place: &mir::Place<'tcx>,\n     ) {\n-        dest_place.base_local().map(|l| in_out.insert(l));\n+        if let PlaceBase::Local(local) = dest_place.base {\n+            in_out.insert(local);\n+        }\n     }\n }\n "}, {"sha": "3bdd3e3da048e4b1c3d5d20920a4104d2e0702d9", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -314,12 +314,12 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n \n     fn visit_statement_entry(&mut self,\n                              _loc: Location,\n-                             _stmt: &Statement<'tcx>,\n+                             _stmt: &'a Statement<'tcx>,\n                              _flow_state: &Self::FlowState) {}\n \n     fn visit_terminator_entry(&mut self,\n                               _loc: Location,\n-                              _term: &Terminator<'tcx>,\n+                              _term: &'a Terminator<'tcx>,\n                               _flow_state: &Self::FlowState) {}\n \n     // Main entry point: this drives the processing of results."}, {"sha": "436ac30ffb42ed9b3c131f2f443102d3c8196ca9", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -106,13 +106,16 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             for proj in place_projection {\n                 let body = self.builder.body;\n                 let tcx = self.builder.tcx;\n-                let place_ty = proj.base.ty(body, tcx).ty;\n+                let place_ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n                 match place_ty.sty {\n                     ty::Ref(..) | ty::RawPtr(..) =>\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n                             BorrowedContent {\n-                                target_place: Place::Projection(Box::new(proj.clone())),\n+                                target_place: Place {\n+                                    base: place_base.clone(),\n+                                    projection: Some(Box::new(proj.clone())),\n+                                }\n                             })),\n                     ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n                         return Err(MoveError::cannot_move_out_of(self.loc,\n@@ -159,7 +162,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             &mut self.builder.data.path_map,\n                             &mut self.builder.data.init_path_map,\n                             Some(base),\n-                            Place::Projection(Box::new(proj.clone())),\n+                            Place {\n+                                base: place_base.clone(),\n+                                projection: Some(Box::new(proj.clone())),\n+                            },\n                         );\n                         ent.insert(path);\n                         path\n@@ -268,9 +274,9 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n                     self.create_move_path(&place.clone().deref());\n-                    self.gather_init(place, InitKind::Shallow);\n+                    self.gather_init(place.as_place_ref(), InitKind::Shallow);\n                 } else {\n-                    self.gather_init(place, InitKind::Deep);\n+                    self.gather_init(place.as_place_ref(), InitKind::Deep);\n                 }\n                 self.gather_rvalue(rval);\n             }\n@@ -280,7 +286,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             StatementKind::InlineAsm(ref asm) => {\n                 for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n                     if !kind.is_indirect {\n-                        self.gather_init(output, InitKind::Deep);\n+                        self.gather_init(output.as_place_ref(), InitKind::Deep);\n                     }\n                 }\n                 for (_, input) in asm.inputs.iter() {\n@@ -370,7 +376,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 self.create_move_path(location);\n                 self.gather_operand(value);\n-                self.gather_init(location, InitKind::Deep);\n+                self.gather_init(location.as_place_ref(), InitKind::Deep);\n             }\n             TerminatorKind::Call {\n                 ref func,\n@@ -385,7 +391,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n                     self.create_move_path(destination);\n-                    self.gather_init(destination, InitKind::NonPanicPathOnly);\n+                    self.gather_init(destination.as_place_ref(), InitKind::NonPanicPathOnly);\n                 }\n             }\n         }\n@@ -420,22 +426,24 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }\n \n-    fn gather_init(&mut self, place: &Place<'tcx>, kind: InitKind) {\n+    fn gather_init(&mut self, place: PlaceRef<'cx, 'tcx>, kind: InitKind) {\n         debug!(\"gather_init({:?}, {:?})\", self.loc, place);\n \n-        let place = match place {\n-            // Check if we are assigning into a field of a union, if so, lookup the place\n-            // of the union so it is marked as initialized again.\n-            Place::Projection(box Projection {\n-                base,\n-                elem: ProjectionElem::Field(_, _),\n-            }) if match base.ty(self.builder.body, self.builder.tcx).ty.sty {\n-                    ty::Adt(def, _) if def.is_union() => true,\n-                    _ => false,\n-            } => base,\n-            // Otherwise, lookup the place.\n-            _ => place,\n-        };\n+        let mut place = place;\n+\n+        // Check if we are assigning into a field of a union, if so, lookup the place\n+        // of the union so it is marked as initialized again.\n+        if let Some(box Projection { base: proj_base, elem: ProjectionElem::Field(_, _) }) =\n+            place.projection\n+        {\n+            if let ty::Adt(def, _) =\n+                Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.sty\n+            {\n+                if def.is_union() {\n+                    place = PlaceRef { base: place.base, projection: proj_base }\n+                }\n+            }\n+        }\n \n         if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(place) {\n             let init = self.builder.data.inits.push(Init {"}, {"sha": "5c2255882b2c740d81d4cbd329d2d4306c8bb057", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -240,8 +240,8 @@ impl MovePathLookup {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n-        place.iterate(|place_base, place_projection| {\n+    pub fn find(&self, place_ref: PlaceRef<'cx, 'tcx>) -> LookupResult {\n+        place_ref.iterate(|place_base, place_projection| {\n             let mut result = match place_base {\n                 PlaceBase::Local(local) => self.locals[*local],\n                 PlaceBase::Static(..) => return LookupResult::Parent(None),\n@@ -318,7 +318,10 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place::Base(PlaceBase::Local(l)) = path.place { return Some(l); }\n+            if let Place {\n+                base: PlaceBase::Local(l),\n+                projection: None,\n+            } = path.place { return Some(l); }\n             if let Some(parent) = path.parent { mpi = parent; continue } else { return None }\n         }\n     }"}, {"sha": "1816171d7b1276ecbd6f87ac23a2f9f4bbf5cc44", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -455,17 +455,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::Place;\n         use rustc::mir::PlaceBase;\n \n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n                 PlaceBase::Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n-                    // FIXME use place_projection.is_empty() when is available\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n-                    let layout = if let Place::Base(_) = mir_place {\n+                    // FIXME use place_projection.is_empty() when is available\n+                    let layout = if mir_place.projection.is_none() {\n                         layout\n                     } else {\n                         None"}, {"sha": "887f93c64787884ccae038a4e4cafe719f65c9d6", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -15,34 +15,30 @@ pub struct AddRetag;\n /// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n /// copies.  Data races are UB.)\n fn is_stable(\n-    place: &Place<'_>,\n+    place: PlaceRef<'_, '_>,\n ) -> bool {\n-    use rustc::mir::Place::*;\n-\n-    match *place {\n-        // Locals and statics have stable addresses, for sure\n-        Base(PlaceBase::Local { .. }) |\n-        Base(PlaceBase::Static { .. }) =>\n-            true,\n-        // Recurse for projections\n-        Projection(ref proj) => {\n-            match proj.elem {\n-                // Which place this evaluates to can change with any memory write,\n-                // so cannot assume this to be stable.\n-                ProjectionElem::Deref =>\n-                    false,\n-                // Array indices are intersting, but MIR building generates a *fresh*\n-                // temporary for every array access, so the index cannot be changed as\n-                // a side-effect.\n-                ProjectionElem::Index { .. } |\n-                // The rest is completely boring, they just offset by a constant.\n-                ProjectionElem::Field { .. } |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::Downcast { .. } =>\n-                    is_stable(&proj.base),\n-            }\n+    if let Some(proj) = &place.projection {\n+        match proj.elem {\n+            // Which place this evaluates to can change with any memory write,\n+            // so cannot assume this to be stable.\n+            ProjectionElem::Deref =>\n+                false,\n+            // Array indices are intersting, but MIR building generates a *fresh*\n+            // temporary for every array access, so the index cannot be changed as\n+            // a side-effect.\n+            ProjectionElem::Index { .. } |\n+            // The rest is completely boring, they just offset by a constant.\n+            ProjectionElem::Field { .. } |\n+            ProjectionElem::ConstantIndex { .. } |\n+            ProjectionElem::Subslice { .. } |\n+            ProjectionElem::Downcast { .. } =>\n+                is_stable(PlaceRef {\n+                    base: place.base,\n+                    projection: &proj.base,\n+                }),\n         }\n+    } else {\n+        true\n     }\n }\n \n@@ -83,7 +79,8 @@ impl MirPass for AddRetag {\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n-            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n+            is_stable(place.as_place_ref())\n+                && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n         };\n \n         // PART 1"}, {"sha": "d5c5267a119d369d183b361f082f47ea925fbe3d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -248,8 +248,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         }], &[]);\n                     }\n                 }\n-                let is_borrow_of_interior_mut = context.is_borrow() && !proj.base\n-                    .ty(self.body, self.tcx)\n+                let is_borrow_of_interior_mut = context.is_borrow() &&\n+                    !Place::ty_from(&place.base, &proj.base, self.body, self.tcx)\n                     .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n                 // prevent\n@@ -264,15 +264,15 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     );\n                 }\n                 let old_source_info = self.source_info;\n-                if let Place::Base(PlaceBase::Local(local)) = proj.base {\n-                    if self.body.local_decls[local].internal {\n+                if let (PlaceBase::Local(local), None) = (&place.base, &proj.base) {\n+                    if self.body.local_decls[*local].internal {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n                         // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[local].source_info;\n+                        self.source_info = self.body.local_decls[*local].source_info;\n                     }\n                 }\n-                let base_ty = proj.base.ty(self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(&place.base, &proj.base, self.body, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -404,15 +404,16 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     }\n     fn check_mut_borrowing_layout_constrained_field(\n         &mut self,\n-        mut place: &Place<'tcx>,\n+        place: &Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        while let &Place::Projection(box Projection {\n-            ref base, ref elem\n-        }) = place {\n-            match *elem {\n+        let mut projection = &place.projection;\n+        while let Some(proj) = projection {\n+            match proj.elem {\n                 ProjectionElem::Field(..) => {\n-                    let ty = base.ty(&self.body.local_decls, self.tcx).ty;\n+                    let ty =\n+                        Place::ty_from(&place.base, &proj.base, &self.body.local_decls, self.tcx)\n+                            .ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {},\n@@ -446,7 +447,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 }\n                 _ => {}\n             }\n-            place = base;\n+            projection = &proj.base;\n         }\n     }\n }"}, {"sha": "72390228aa839d22c9689bcd58b9637ad5041820", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -781,7 +781,10 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n-                    if let Place::Base(PlaceBase::Local(local)) = *place {\n+                    if let Place {\n+                        base: PlaceBase::Local(local),\n+                        projection: None,\n+                    } = *place {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {\n                             trace!(\"storing {:?} to {:?}\", value, local);\n@@ -821,11 +824,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         // doesn't use the invalid value\n                         match cond {\n                             Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                let mut place = place;\n-                                while let Place::Projection(ref proj) = *place {\n-                                    place = &proj.base;\n-                                }\n-                                if let Place::Base(PlaceBase::Local(local)) = *place {\n+                                if let PlaceBase::Local(local) = place.base {\n                                     self.remove_const(local);\n                                 }\n                             },"}, {"sha": "7c9eeb5a57741485ceddf7636bd8f9a54086032a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -94,7 +94,10 @@ impl MirPass for CopyPropagation {\n                     // That use of the source must be an assignment.\n                     match statement.kind {\n                         StatementKind::Assign(\n-                            Place::Base(PlaceBase::Local(local)),\n+                            Place {\n+                                base: PlaceBase::Local(local),\n+                                projection: None,\n+                            },\n                             box Rvalue::Use(ref operand)\n                         ) if local == dest_local => {\n                             let maybe_action = match *operand {\n@@ -145,12 +148,24 @@ fn eliminate_self_assignments(\n             if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n                 match stmt.kind {\n                     StatementKind::Assign(\n-                        Place::Base(PlaceBase::Local(local)),\n-                        box Rvalue::Use(Operand::Copy(Place::Base(PlaceBase::Local(src_local)))),\n+                        Place {\n+                            base: PlaceBase::Local(local),\n+                            projection: None,\n+                        },\n+                        box Rvalue::Use(Operand::Copy(Place {\n+                            base: PlaceBase::Local(src_local),\n+                            projection: None,\n+                        })),\n                     ) |\n                     StatementKind::Assign(\n-                        Place::Base(PlaceBase::Local(local)),\n-                        box Rvalue::Use(Operand::Move(Place::Base(PlaceBase::Local(src_local)))),\n+                        Place {\n+                            base: PlaceBase::Local(local),\n+                            projection: None,\n+                        },\n+                        box Rvalue::Use(Operand::Move(Place {\n+                            base: PlaceBase::Local(src_local),\n+                            projection: None,\n+                        })),\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n                         continue;\n@@ -177,7 +192,10 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(body: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Place::Base(PlaceBase::Local(local)) = *src_place {\n+        let src_local = if let Place {\n+            base: PlaceBase::Local(local),\n+            projection: None,\n+        } = *src_place {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -331,8 +349,14 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Copy(Place::Base(PlaceBase::Local(local))) |\n-            Operand::Move(Place::Base(PlaceBase::Local(local))) if local == self.dest_local => {}\n+            Operand::Copy(Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            }) |\n+            Operand::Move(Place {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            }) if local == self.dest_local => {}\n             _ => return,\n         }\n "}, {"sha": "0748321f605938ed3830697a9b7ba1b0727a0409", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -105,7 +105,7 @@ fn find_dead_unwinds<'tcx>(\n             init_data.apply_location(tcx, body, env, loc);\n         }\n \n-        let path = match env.move_data.rev_lookup.find(location) {\n+        let path = match env.move_data.rev_lookup.find(location.as_place_ref()) {\n             LookupResult::Exact(e) => e,\n             LookupResult::Parent(..) => {\n                 debug!(\"find_dead_unwinds: has parent; skipping\");\n@@ -360,7 +360,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 statement_index: data.statements.len()\n             });\n \n-            let path = self.move_data().rev_lookup.find(location);\n+            let path = self.move_data().rev_lookup.find(location.as_place_ref());\n             debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\",\n                    bb, location, path);\n \n@@ -399,7 +399,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             match terminator.kind {\n                 TerminatorKind::Drop { ref location, target, unwind } => {\n                     let init_data = self.initialization_data_at(loc);\n-                    match self.move_data().rev_lookup.find(location) {\n+                    match self.move_data().rev_lookup.find(location.as_place_ref()) {\n                         LookupResult::Exact(path) => {\n                             elaborate_drop(\n                                 &mut Elaborator {\n@@ -488,7 +488,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             is_cleanup: false,\n         });\n \n-        match self.move_data().rev_lookup.find(location) {\n+        match self.move_data().rev_lookup.find(location.as_place_ref()) {\n             LookupResult::Exact(path) => {\n                 debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n                 let init_data = self.initialization_data_at(loc);\n@@ -558,7 +558,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 assert!(!self.patch.is_patched(bb));\n \n                 let loc = Location { block: tgt, statement_index: 0 };\n-                let path = self.move_data().rev_lookup.find(place);\n+                let path = self.move_data().rev_lookup.find(place.as_place_ref());\n                 on_lookup_result_bits(\n                     self.tcx, self.body, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n@@ -632,7 +632,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 assert!(!self.patch.is_patched(bb));\n \n                 let loc = Location { block: bb, statement_index: data.statements.len() };\n-                let path = self.move_data().rev_lookup.find(place);\n+                let path = self.move_data().rev_lookup.find(place.as_place_ref());\n                 on_lookup_result_bits(\n                     self.tcx, self.body, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)"}, {"sha": "af412edbdc23f73f32376aa1eba5b7f6369420dd", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -104,11 +104,14 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext,\n                     location: Location) {\n-        if place.base_local() == Some(self_arg()) {\n-            replace_base(place, Place::Projection(Box::new(Projection {\n-                base: Place::Base(PlaceBase::Local(self_arg())),\n-                elem: ProjectionElem::Deref,\n-            })));\n+        if place.base == PlaceBase::Local(self_arg()) {\n+            replace_base(place, Place {\n+                base: PlaceBase::Local(self_arg()),\n+                projection: Some(Box::new(Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Deref,\n+                })),\n+            });\n         } else {\n             self.super_place(place, context, location);\n         }\n@@ -131,23 +134,28 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext,\n                     location: Location) {\n-        if place.base_local() == Some(self_arg()) {\n-            replace_base(place, Place::Projection(Box::new(Projection {\n-                base: Place::Base(PlaceBase::Local(self_arg())),\n-                elem: ProjectionElem::Field(Field::new(0), self.ref_gen_ty),\n-            })));\n+        if place.base == PlaceBase::Local(self_arg()) {\n+            replace_base(place, Place {\n+                base: PlaceBase::Local(self_arg()),\n+                projection: Some(Box::new(Projection {\n+                    base: None,\n+                    elem: ProjectionElem::Field(Field::new(0), self.ref_gen_ty),\n+                })),\n+            });\n         } else {\n             self.super_place(place, context, location);\n         }\n     }\n }\n \n fn replace_base(place: &mut Place<'tcx>, new_base: Place<'tcx>) {\n-    if let Place::Projection(proj) = place {\n-        replace_base(&mut proj.base, new_base);\n-    } else {\n-        *place = new_base;\n+    let mut projection = &mut place.projection;\n+    while let Some(box proj) = projection {\n+        projection = &mut proj.base;\n     }\n+\n+    place.base = new_base.base;\n+    *projection = new_base.projection;\n }\n \n fn self_arg() -> Local {\n@@ -203,10 +211,13 @@ impl TransformVisitor<'tcx> {\n         let self_place = Place::from(self_arg());\n         let base = self_place.downcast_unnamed(variant_index);\n         let field = Projection {\n-            base: base,\n+            base: base.projection,\n             elem: ProjectionElem::Field(Field::new(idx), ty),\n         };\n-        Place::Projection(Box::new(field))\n+        Place {\n+            base: base.base,\n+            projection: Some(Box::new(field)),\n+        }\n     }\n \n     // Create a statement which changes the discriminant\n@@ -245,7 +256,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext,\n                     location: Location) {\n-        if let Some(l) = place.base_local() {\n+        if let PlaceBase::Local(l) = place.base {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n                 replace_base(place, self.make_field(variant_index, idx, ty));\n@@ -835,7 +846,10 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n             &Terminator {\n                 source_info,\n                 kind: TerminatorKind::Drop {\n-                    location: Place::Base(PlaceBase::Local(local)),\n+                    location: Place {\n+                        base: PlaceBase::Local(local),\n+                        projection: None,\n+                    },\n                     target,\n                     unwind\n                 }"}, {"sha": "343832fe4a76164f1c9f37a4e5e8d20c996d1238", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -603,7 +603,10 @@ impl Inliner<'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Move(Place::Base(PlaceBase::Local(local))) = arg {\n+        if let Operand::Move(Place {\n+            base: PlaceBase::Local(local),\n+            projection: None,\n+        }) = arg {\n             if caller_body.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n                 return local;\n@@ -671,7 +674,10 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                    _location: Location) {\n         if *local == RETURN_PLACE {\n             match self.destination {\n-                Place::Base(PlaceBase::Local(l)) => {\n+                Place {\n+                    base: PlaceBase::Local(l),\n+                    projection: None,\n+                } => {\n                     *local = l;\n                     return;\n                 },\n@@ -692,13 +698,20 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                     _location: Location) {\n \n         match place {\n-            Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n+            Place {\n+                base: PlaceBase::Local(RETURN_PLACE),\n+                projection: None,\n+            } => {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })\n-            ) => {\n+            Place {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(promoted),\n+                    ..\n+                }),\n+                projection: None,\n+            } => {\n                 if let Some(p) = self.promoted_map.get(*promoted).cloned() {\n                     *promoted = p;\n                 }"}, {"sha": "55429265036937d3e727cbfe7223ccb60470417b", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -41,10 +41,14 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"replacing `&*`: {:?}\", rvalue);\n             let new_place = match *rvalue {\n-                Rvalue::Ref(_, _, Place::Projection(ref mut projection)) => {\n+                Rvalue::Ref(_, _, Place {\n+                    ref mut base,\n+                    projection: Some(ref mut projection),\n+                }) => Place {\n                     // Replace with dummy\n-                    mem::replace(&mut projection.base, Place::Base(PlaceBase::Local(Local::new(0))))\n-                }\n+                    base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n+                    projection: projection.base.take(),\n+                },\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n             *rvalue = Rvalue::Use(Operand::Copy(new_place))\n@@ -78,9 +82,12 @@ impl OptimizationFinder<'b, 'tcx> {\n \n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n+        if let Rvalue::Ref(_, _, Place {\n+            ref base,\n+            projection: Some(ref projection),\n+        }) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n-                if projection.base.ty(self.body, self.tcx).ty.is_region_ptr() {\n+                if Place::ty_from(&base, &projection.base, self.body, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }"}, {"sha": "3090b63a7e9934c3952e5b10d62f3b213be5471c", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -300,27 +300,28 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n-                Place::Base(\n-                    PlaceBase::Static(box Static{ kind: StaticKind::Promoted(promoted_id), ty })\n-                )\n+                Place {\n+                    base: PlaceBase::Static(box Static {\n+                        kind: StaticKind::Promoted(promoted_id),\n+                        ty\n+                    }),\n+                    projection: None,\n+                }\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n                         StatementKind::Assign(_, box Rvalue::Ref(_, _, ref mut place)) => {\n-                            // Find the underlying local for this (necessarily interior) borrow.\n-                            let mut place = place;\n-                            while let Place::Projection(ref mut proj) = *place {\n-                                assert_ne!(proj.elem, ProjectionElem::Deref);\n-                                place = &mut proj.base;\n-                            };\n-\n-                            let ty = place.ty(local_decls, self.tcx).ty;\n+                            // Use the underlying local for this (necessarily interior) borrow.\n+                            let ty = place.base.ty(local_decls).ty;\n                             let span = statement.source_info.span;\n \n-                            Operand::Move(mem::replace(place, promoted_place(ty, span)))\n+                            Operand::Move(Place {\n+                                base: mem::replace(&mut place.base, promoted_place(ty, span).base),\n+                                projection: None,\n+                            })\n                         }\n                         _ => bug!()\n                     }\n@@ -397,7 +398,10 @@ pub fn promote_candidates<'tcx>(\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n                 match body[block].statements[statement_index].kind {\n-                    StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _) => {\n+                    StatementKind::Assign(Place {\n+                        base: PlaceBase::Local(local),\n+                        projection: None,\n+                    }, _) => {\n                         if temps[local] == TempState::PromotedOut {\n                             // Already promoted.\n                             continue;\n@@ -444,7 +448,10 @@ pub fn promote_candidates<'tcx>(\n     for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n-                StatementKind::Assign(Place::Base(PlaceBase::Local(index)), _) |\n+                StatementKind::Assign(Place {\n+                    base: PlaceBase::Local(index),\n+                    projection: None,\n+                }, _) |\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n                     !promoted(index)\n@@ -454,7 +461,10 @@ pub fn promote_candidates<'tcx>(\n         });\n         let terminator = block.terminator_mut();\n         match terminator.kind {\n-            TerminatorKind::Drop { location: Place::Base(PlaceBase::Local(index)), target, .. } => {\n+            TerminatorKind::Drop { location: Place {\n+                base: PlaceBase::Local(index),\n+                projection: None,\n+            }, target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {\n                         target,"}, {"sha": "739e2172b03bc6f6892fc06f5724495d815aa0b3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 106, "deletions": 57, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -182,12 +182,16 @@ trait Qualif {\n \n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n+        base: &PlaceBase<'tcx>,\n         proj: &Projection<'tcx>,\n     ) -> bool {\n-        let base_qualif = Self::in_place(cx, &proj.base);\n+        let base_qualif = Self::in_place(cx, PlaceRef {\n+            base,\n+            projection: &proj.base,\n+        });\n         let qualif = base_qualif && Self::mask_for_ty(\n             cx,\n-            proj.base.ty(cx.body, cx.tcx)\n+            Place::ty_from(&base, &proj.base, cx.body, cx.tcx)\n                 .projection_ty(cx.tcx, &proj.elem)\n                 .ty,\n         );\n@@ -202,26 +206,44 @@ trait Qualif {\n         }\n     }\n \n-    fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &Projection<'tcx>) -> bool {\n-        Self::in_projection_structurally(cx, proj)\n+    fn in_projection(\n+        cx: &ConstCx<'_, 'tcx>,\n+        base: &PlaceBase<'tcx>,\n+        proj: &Projection<'tcx>,\n+    ) -> bool {\n+        Self::in_projection_structurally(cx, base, proj)\n     }\n \n-    fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n-        match *place {\n-            Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n-            Place::Base(PlaceBase::Static(box Static {kind: StaticKind::Promoted(_), .. })) =>\n-                bug!(\"qualifying already promoted MIR\"),\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n+    fn in_place(cx: &ConstCx<'_, 'tcx>, place: PlaceRef<'_, 'tcx>) -> bool {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => Self::in_local(cx, *local),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(_),\n+                    ..\n+                }),\n+                projection: None,\n+            } => bug!(\"qualifying already promoted MIR\"),\n+            PlaceRef {\n+                base: PlaceBase::Static(static_),\n+                projection: None,\n+            } => {\n                 Self::in_static(cx, static_)\n             },\n-            Place::Projection(ref proj) => Self::in_projection(cx, proj),\n+            PlaceRef {\n+                base,\n+                projection: Some(proj),\n+            } => Self::in_projection(cx, base, proj),\n         }\n     }\n \n     fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n         match *operand {\n             Operand::Copy(ref place) |\n-            Operand::Move(ref place) => Self::in_place(cx, place),\n+            Operand::Move(ref place) => Self::in_place(cx, place.as_place_ref()),\n \n             Operand::Constant(ref constant) => {\n                 if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n@@ -250,7 +272,7 @@ trait Qualif {\n             Rvalue::NullaryOp(..) => false,\n \n             Rvalue::Discriminant(ref place) |\n-            Rvalue::Len(ref place) => Self::in_place(cx, place),\n+            Rvalue::Len(ref place) => Self::in_place(cx, place.as_place_ref()),\n \n             Rvalue::Use(ref operand) |\n             Rvalue::Repeat(ref operand, _) |\n@@ -264,16 +286,19 @@ trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let Place::Projection(ref proj) = *place {\n+                if let Some(ref proj) = place.projection {\n                     if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = proj.base.ty(cx.body, cx.tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, &proj.base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n-                            return Self::in_place(cx, &proj.base);\n+                            return Self::in_place(cx, PlaceRef {\n+                                base: &place.base,\n+                                projection: &proj.base,\n+                            });\n                         }\n                     }\n                 }\n \n-                Self::in_place(cx, place)\n+                Self::in_place(cx, place.as_place_ref())\n             }\n \n             Rvalue::Aggregate(_, ref operands) => {\n@@ -421,7 +446,11 @@ impl Qualif for IsNotPromotable {\n         }\n     }\n \n-    fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &Projection<'tcx>) -> bool {\n+    fn in_projection(\n+        cx: &ConstCx<'_, 'tcx>,\n+        base: &PlaceBase<'tcx>,\n+        proj: &Projection<'tcx>,\n+    ) -> bool {\n         match proj.elem {\n             ProjectionElem::Deref |\n             ProjectionElem::Downcast(..) => return true,\n@@ -432,7 +461,7 @@ impl Qualif for IsNotPromotable {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::NonConstFn {\n-                    let base_ty = proj.base.ty(cx.body, cx.tcx).ty;\n+                    let base_ty = Place::ty_from(base, &proj.base, cx.body, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         // No promotion of union field accesses.\n                         if def.is_union() {\n@@ -443,7 +472,7 @@ impl Qualif for IsNotPromotable {\n             }\n         }\n \n-        Self::in_projection_structurally(cx, proj)\n+        Self::in_projection_structurally(cx, base, proj)\n     }\n \n     fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n@@ -773,28 +802,32 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     // We might have a candidate for promotion.\n                     let candidate = Candidate::Ref(location);\n                     // Start by traversing to the \"base\", with non-deref projections removed.\n-                    let mut place = place;\n-                    while let Place::Projection(ref proj) = *place {\n+                    let mut place_projection = &place.projection;\n+                    while let Some(proj) = place_projection {\n                         if proj.elem == ProjectionElem::Deref {\n                             break;\n                         }\n-                        place = &proj.base;\n+                        place_projection = &proj.base;\n                     }\n-                    debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+\n+                    debug!(\n+                        \"qualify_consts: promotion candidate: place={:?} {:?}\",\n+                        place.base, place_projection\n+                    );\n                     // We can only promote interior borrows of promotable temps (non-temps\n                     // don't get promoted anyway).\n                     // (If we bailed out of the loop due to a `Deref` above, we will definitely\n                     // not enter the conditional here.)\n-                    if let Place::Base(PlaceBase::Local(local)) = *place {\n-                        if self.body.local_kind(local) == LocalKind::Temp {\n+                    if let (PlaceBase::Local(local), None) = (&place.base, place_projection) {\n+                        if self.body.local_kind(*local) == LocalKind::Temp {\n                             debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n                             // The borrowed place doesn't have `HasMutInterior`\n                             // (from `in_rvalue`), so we can safely ignore\n                             // `HasMutInterior` from the local's qualifications.\n                             // This allows borrowing fields which don't have\n                             // `HasMutInterior`, from a type that does, e.g.:\n                             // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                            let mut local_qualifs = self.qualifs_in_local(local);\n+                            let mut local_qualifs = self.qualifs_in_local(*local);\n                             // Any qualifications, except HasMutInterior (see above), disqualify\n                             // from promotion.\n                             // This is, in particular, the \"implicit promotion\" version of\n@@ -821,34 +854,31 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             _ => {},\n         }\n \n-        let mut dest = dest;\n+        let mut dest_projection = &dest.projection;\n         let index = loop {\n-            match dest {\n+            match (&dest.base, dest_projection) {\n                 // We treat all locals equal in constants\n-                Place::Base(PlaceBase::Local(index)) => break *index,\n+                (&PlaceBase::Local(index), None) => break index,\n                 // projections are transparent for assignments\n                 // we qualify the entire destination at once, even if just a field would have\n                 // stricter qualification\n-                Place::Projection(proj) => {\n+                (base, Some(proj)) => {\n                     // Catch more errors in the destination. `visit_place` also checks various\n                     // projection rules like union field access and raw pointer deref\n-                    self.visit_place(\n-                        dest,\n-                        PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                        location\n-                    );\n-                    dest = &proj.base;\n+                    let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n+                    self.visit_place_base(base, context, location);\n+                    self.visit_projection(base, proj, context, location);\n+                    dest_projection = &proj.base;\n                 },\n-                Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n-                    bug!(\"promoteds don't exist yet during promotion\"),\n-                Place::Base(PlaceBase::Static(box Static{ kind: _, .. })) => {\n+                (&PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(_),\n+                    ..\n+                }), None) => bug!(\"promoteds don't exist yet during promotion\"),\n+                (&PlaceBase::Static(box Static{ kind: _, .. }), None) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n-                    self.visit_place(\n-                        dest,\n-                        PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                        location\n-                    );\n+                    let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n+                    self.visit_place_base(&dest.base, context, location);\n                     return;\n                 }\n             }\n@@ -950,7 +980,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             match *candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(_, box Rvalue::Repeat(\n-                        Operand::Move(Place::Base(PlaceBase::Local(index))),\n+                        Operand::Move(Place {\n+                            base: PlaceBase::Local(index),\n+                            projection: None,\n+                        }),\n                         _\n                     )) = self.body[bb].statements[stmt_idx].kind {\n                         promoted_temps.insert(index);\n@@ -959,7 +992,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(\n                         _,\n-                        box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n+                        box Rvalue::Ref(_, _, Place {\n+                            base: PlaceBase::Local(index),\n+                            projection: None,\n+                        })\n                     ) = self.body[bb].statements[stmt_idx].kind {\n                         promoted_temps.insert(index);\n                     }\n@@ -1043,6 +1079,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n     fn visit_projection(\n         &mut self,\n+        place_base: &PlaceBase<'tcx>,\n         proj: &Projection<'tcx>,\n         context: PlaceContext,\n         location: Location,\n@@ -1051,14 +1088,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             \"visit_place_projection: proj={:?} context={:?} location={:?}\",\n             proj, context, location,\n         );\n-        self.super_projection(proj, context, location);\n+        self.super_projection(place_base, proj, context, location);\n         match proj.elem {\n             ProjectionElem::Deref => {\n                 if context.is_mutating_use() {\n                     // `not_const` errors out in const contexts\n                     self.not_const()\n                 }\n-                let base_ty = proj.base.ty(self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, &proj.base, self.body, self.tcx).ty;\n                 match self.mode {\n                     Mode::NonConstFn => {},\n                     _ => {\n@@ -1082,7 +1119,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = proj.base.ty(self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, &proj.base, self.body, self.tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     if def.is_union() {\n                         match self.mode {\n@@ -1119,7 +1156,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Place::Base(PlaceBase::Local(local)) = *place {\n+                if let Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                } = *place {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n@@ -1135,16 +1175,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n             let mut reborrow_place = None;\n-            if let Place::Projection(ref proj) = *place {\n+            if let Some(ref proj) = place.projection {\n                 if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = proj.base.ty(self.body, self.tcx).ty;\n+                    let base_ty = Place::ty_from(&place.base, &proj.base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n                         reborrow_place = Some(&proj.base);\n                     }\n                 }\n             }\n \n-            if let Some(place) = reborrow_place {\n+            if let Some(proj) = reborrow_place {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -1159,7 +1199,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         MutatingUseContext::Borrow,\n                     ),\n                 };\n-                self.visit_place(place, ctx, location);\n+                self.visit_place_base(&place.base, ctx, location);\n+                if let Some(proj) = proj {\n+                    self.visit_projection(&place.base, proj, ctx, location);\n+                }\n             } else {\n                 self.super_rvalue(rvalue, location);\n             }\n@@ -1428,7 +1471,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Place::Base(PlaceBase::Local(local)) = *place {\n+                let needs_drop = if let Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: None,\n+                } = *place {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.body.local_decls[local].source_info.span)\n                     } else {\n@@ -1658,7 +1704,10 @@ impl MirPass for QualifyAndPromoteConstants {\n                 let terminator = block.terminator_mut();\n                 match terminator.kind {\n                     TerminatorKind::Drop {\n-                        location: Place::Base(PlaceBase::Local(index)),\n+                        location: Place {\n+                            base: PlaceBase::Local(index),\n+                            projection: None,\n+                        },\n                         target,\n                         ..\n                     } => {"}, {"sha": "adba9097d12df9090fb14c6423b56ee76124599b", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -41,7 +41,10 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(Place::Base(PlaceBase::Local(_)), box Rvalue::Use(_)) => {\n+                StatementKind::Assign(Place {\n+                    base: PlaceBase::Local(_),\n+                    projection: None,\n+                }, box Rvalue::Use(_)) => {\n                     // Writing to a local (e.g., a drop flag) does not\n                     // turn a landing pad to a non-nop\n                 }"}, {"sha": "1fd865c42fcdb696b9c92ec793e4f3b0166cc1dd", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -118,8 +118,14 @@ fn each_block<'tcx, O>(\n     };\n     assert!(args.len() == 1);\n     let peek_arg_place = match args[0] {\n-        mir::Operand::Copy(ref place @ mir::Place::Base(mir::PlaceBase::Local(_))) |\n-        mir::Operand::Move(ref place @ mir::Place::Base(mir::PlaceBase::Local(_))) => Some(place),\n+        mir::Operand::Copy(ref place @ mir::Place {\n+            base: mir::PlaceBase::Local(_),\n+            projection: None,\n+        }) |\n+        mir::Operand::Move(ref place @ mir::Place {\n+            base: mir::PlaceBase::Local(_),\n+            projection: None,\n+        }) => Some(place),\n         _ => None,\n     };\n \n@@ -162,7 +168,7 @@ fn each_block<'tcx, O>(\n         if place == peek_arg_place {\n             if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = **rvalue {\n                 // Okay, our search is over.\n-                match move_data.rev_lookup.find(peeking_at_place) {\n+                match move_data.rev_lookup.find(peeking_at_place.as_place_ref()) {\n                     LookupResult::Exact(peek_mpi) => {\n                         let bit_state = on_entry.contains(peek_mpi);\n                         debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n@@ -186,7 +192,7 @@ fn each_block<'tcx, O>(\n             }\n         }\n \n-        let lhs_mpi = move_data.rev_lookup.find(place);\n+        let lhs_mpi = move_data.rev_lookup.find(place.as_place_ref());\n \n         debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n                place, lhs_mpi, stmt);"}, {"sha": "6aceeebaea161ab88dd91203a47602330c922c7a", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -59,19 +59,27 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let Place::Projection(ref proj) = *src_place {\n+            if let Some(ref proj) = src_place.projection {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n                                                      from_end: false} = proj.elem {\n                     // no need to transformation\n                 } else {\n-                    let place_ty = proj.base.ty(self.body, self.tcx).ty;\n+                    let place_ty =\n+                        Place::ty_from(&src_place.base, &proj.base, self.body, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n                                     \"uniform array move out doesn't supported\n                                      for array bigger then u32\");\n-                            self.uniform(location, dst_place, proj, item_ty, size as u32);\n+                            self.uniform(\n+                                location,\n+                                dst_place,\n+                                &src_place.base,\n+                                proj,\n+                                item_ty,\n+                                size as u32,\n+                            );\n                         }\n                     }\n \n@@ -86,6 +94,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n     fn uniform(&mut self,\n                location: Location,\n                dst_place: &Place<'tcx>,\n+               base: &PlaceBase<'tcx>,\n                proj: &Projection<'tcx>,\n                item_ty: &'tcx ty::TyS<'tcx>,\n                size: u32) {\n@@ -100,13 +109,20 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                           Place::from(temp),\n                                           Rvalue::Use(\n                                               Operand::Move(\n-                                                  Place::Projection(box Projection{\n-                                                      base: proj.base.clone(),\n-                                                      elem: ProjectionElem::ConstantIndex{\n-                                                          offset: i,\n-                                                          min_length: size,\n-                                                          from_end: false}\n-                                                  }))));\n+                                                  Place {\n+                                                      base: base.clone(),\n+                                                      projection: Some(box Projection {\n+                                                          base: proj.base.clone(),\n+                                                          elem: ProjectionElem::ConstantIndex {\n+                                                              offset: i,\n+                                                              min_length: size,\n+                                                              from_end: false,\n+                                                          }\n+                                                      }),\n+                                                  }\n+                                              )\n+                                          )\n+                    );\n                     temp\n                 }).collect();\n                 self.patch.add_assign(\n@@ -130,12 +146,20 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                       dst_place.clone(),\n                                       Rvalue::Use(\n                                           Operand::Move(\n-                                              Place::Projection(box Projection{\n-                                                  base: proj.base.clone(),\n-                                                  elem: ProjectionElem::ConstantIndex{\n-                                                      offset: size - offset,\n-                                                      min_length: size,\n-                                                      from_end: false }}))));\n+                                              Place {\n+                                                  base: base.clone(),\n+                                                  projection: Some(box Projection {\n+                                                      base: proj.base.clone(),\n+                                                      elem: ProjectionElem::ConstantIndex {\n+                                                          offset: size - offset,\n+                                                          min_length: size,\n+                                                          from_end: false,\n+                                                      },\n+                                                  }),\n+                                              }\n+                                          )\n+                                      )\n+                );\n             }\n             _ => {}\n         }\n@@ -173,7 +197,10 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                 if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = **rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(Place::Base(PlaceBase::Local(local))) = item {\n+                            if let Operand::Move(Place {\n+                                base: PlaceBase::Local(local),\n+                                projection: None,\n+                            }) = item {\n                                 let local_use = &visitor.locals_use[*local];\n                                 let opt_index_and_place =\n                                     Self::try_get_item_source(local_use, body);\n@@ -189,7 +216,8 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n \n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = src_place.ty(body, tcx).ty;\n+                            let src_ty =\n+                                Place::ty_from(src_place.base, src_place.projection, body, tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {\n@@ -210,14 +238,15 @@ impl RestoreSubsliceArrayMoveOut {\n     // indices is an integer interval. If all checks pass do the replacent.\n     // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n     fn check_and_patch<'tcx>(candidate: Location,\n-                             items: &[Option<(&LocalUse, u32, &Place<'tcx>)>],\n+                             items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n                              opt_size: Option<u64>,\n                              patch: &mut MirPatch<'tcx>,\n                              dst_place: &Place<'tcx>) {\n         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n \n         if opt_size.is_some() && items.iter().all(\n             |l| l.is_some() && l.unwrap().2 == opt_src_place.unwrap()) {\n+            let src_place = opt_src_place.unwrap();\n \n             let indices: Vec<_> = items.iter().map(|x| x.unwrap().1).collect();\n             for i in 1..indices.len() {\n@@ -241,25 +270,39 @@ impl RestoreSubsliceArrayMoveOut {\n                              dst_place.clone(),\n                              Rvalue::Use(\n                                  Operand::Move(\n-                                     Place::Projection(box Projection{\n-                                         base: opt_src_place.unwrap().clone(),\n-                                         elem: ProjectionElem::Subslice{\n-                                             from: min, to: size - max - 1}}))));\n+                                     Place {\n+                                         base: src_place.base.clone(),\n+                                         projection: Some(box Projection {\n+                                             base: src_place.projection.clone(),\n+                                             elem: ProjectionElem::Subslice{\n+                                                 from: min, to: size - max - 1}})})));\n         }\n     }\n \n     fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n-                                     body: &'a Body<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n+                                     body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n         if let Some(location) = local_use.first_use {\n             let block = &body[location.block];\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n-                    Place::Base(PlaceBase::Local(_)),\n-                    box Rvalue::Use(Operand::Move(Place::Projection(box Projection{\n-                        ref base, elem: ProjectionElem::ConstantIndex{\n-                            offset, min_length: _, from_end: false}})))) = statement.kind {\n-                    return Some((offset, base))\n+                    Place {\n+                        base: PlaceBase::Local(_),\n+                        projection: None,\n+                    },\n+                    box Rvalue::Use(Operand::Move(Place {\n+                        base,\n+                        projection: Some(box Projection {\n+                            base: proj_base,\n+                            elem: ProjectionElem::ConstantIndex {\n+                                offset, min_length: _, from_end: false\n+                            }\n+                        }),\n+                    }))) = &statement.kind {\n+                    return Some((*offset, PlaceRef {\n+                        base,\n+                        projection: proj_base,\n+                    }))\n                 }\n             }\n         }"}, {"sha": "b8ef77da02e6033142c2bc03630298252339163b", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -38,15 +38,14 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut place = place;\n-    while let &Place::Projection(box Projection {\n-        ref base, ref elem\n-    }) = place {\n-        match *elem {\n+    let mut place_projection = &place.projection;\n+\n+    while let Some(proj) = place_projection {\n+        match proj.elem {\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = base.ty(local_decls, tcx).ty;\n+                let ty = Place::ty_from(&place.base, &proj.base, local_decls, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true\n@@ -56,7 +55,7 @@ where\n             }\n             _ => {}\n         }\n-        place = base;\n+        place_projection = &proj.base;\n     }\n \n     false"}, {"sha": "61ad2ba8f5737355c448af551cfb69b42214ad0d", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1301422a6c2e8916560b8cc2f0564f38d8858a75/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=1301422a6c2e8916560b8cc2f0564f38d8858a75", "patch": "@@ -584,10 +584,13 @@ where\n             (Rvalue::Ref(\n                 tcx.lifetimes.re_erased,\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n-                Place::Projection(Box::new(Projection {\n-                    base: Place::Base(PlaceBase::Local(cur)),\n-                    elem: ProjectionElem::Deref,\n-                }))\n+                Place {\n+                    base: PlaceBase::Local(cur),\n+                    projection: Some(Box::new(Projection {\n+                        base: None,\n+                        elem: ProjectionElem::Deref,\n+                    })),\n+                }\n              ),\n              Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n         } else {"}]}