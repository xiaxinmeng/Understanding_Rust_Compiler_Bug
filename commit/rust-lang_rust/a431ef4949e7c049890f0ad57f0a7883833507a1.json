{"sha": "a431ef4949e7c049890f0ad57f0a7883833507a1", "node_id": "C_kwDOAAsO6NoAKGE0MzFlZjQ5NDllN2MwNDk4OTBmMGFkNTdmMGE3ODgzODMzNTA3YTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-09T22:00:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-09T22:00:36Z"}, "message": "Rollup merge of #100319 - GuillaumeGomez:rm-clean-impls-2, r=Dylan-DPC\n\nRemove more Clean trait implementations\n\nFollow-up of https://github.com/rust-lang/rust/pull/99638.\n\nr? ``@Dylan-DPC``", "tree": {"sha": "3901222c950f2e3001673dbb7d7c2c590ac97fe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3901222c950f2e3001673dbb7d7c2c590ac97fe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a431ef4949e7c049890f0ad57f0a7883833507a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8tkECRBK7hj4Ov3rIwAACBcIAK3UZM6XBQR72hXoQ/LO2Jfn\na5fDq1C2MTej+wV9sAUZ9sSMjpvBiHtYoh2CYsqB2VXENI7/Sb5LlnVtl3V3Qlyu\nmHhLKTt5hPB6qqAy4ir1Tp+ZPfbi5bPuYVvc3vJqKW3iuJQJvFdKet2q17gCZMZ+\nvbv9GIGr4Q6dvk/OMSIZ85zTXl1h6vBvAUiMaiUEzjCUFEvpf4iZnAQ2Mbt5/dWN\njnXaupCHyvb0GRSarMgK6IN0SJLQas0jkE/L4ps4XI+IuSgAXSi84NIsxUGfUkcD\nkG6Q53kpagmBAMTTqteqeKLjpSgK0lLHXc0GIpVLPTy8tuQW1pAOnTo/9R++fYg=\n=uLBH\n-----END PGP SIGNATURE-----\n", "payload": "tree 3901222c950f2e3001673dbb7d7c2c590ac97fe8\nparent e8d8599ad95ef664b4c53a05153e18910d149328\nparent daa0e8fecca0a2e54cb69c3c4ed9518a0960a724\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660082436 +0200\ncommitter GitHub <noreply@github.com> 1660082436 +0200\n\nRollup merge of #100319 - GuillaumeGomez:rm-clean-impls-2, r=Dylan-DPC\n\nRemove more Clean trait implementations\n\nFollow-up of https://github.com/rust-lang/rust/pull/99638.\n\nr? ``@Dylan-DPC``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a431ef4949e7c049890f0ad57f0a7883833507a1", "html_url": "https://github.com/rust-lang/rust/commit/a431ef4949e7c049890f0ad57f0a7883833507a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a431ef4949e7c049890f0ad57f0a7883833507a1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d8599ad95ef664b4c53a05153e18910d149328", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d8599ad95ef664b4c53a05153e18910d149328", "html_url": "https://github.com/rust-lang/rust/commit/e8d8599ad95ef664b4c53a05153e18910d149328"}, {"sha": "daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "html_url": "https://github.com/rust-lang/rust/commit/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724"}], "stats": {"total": 213, "additions": 108, "deletions": 105}, "files": [{"sha": "4e9456ba7cb71ecd2cd8b18bc708952fce0b681f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a431ef4949e7c049890f0ad57f0a7883833507a1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a431ef4949e7c049890f0ad57f0a7883833507a1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a431ef4949e7c049890f0ad57f0a7883833507a1", "patch": "@@ -16,8 +16,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_middle_field, clean_middle_ty,\n-    clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n+    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_field,\n+    clean_middle_ty, clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n     clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n@@ -426,9 +426,9 @@ pub(crate) fn build_impl(\n                         true\n                     }\n                 })\n-                .map(|item| item.clean(cx))\n+                .map(|item| clean_impl_item(item, cx))\n                 .collect::<Vec<_>>(),\n-            impl_.generics.clean(cx),\n+            clean_generics(impl_.generics, cx),\n         ),\n         None => (\n             tcx.associated_items(did)"}, {"sha": "402e4f29860a261eab9b3a9bb74c469676d0d0c8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 104, "deletions": 101, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/a431ef4949e7c049890f0ad57f0a7883833507a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a431ef4949e7c049890f0ad57f0a7883833507a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a431ef4949e7c049890f0ad57f0a7883833507a1", "patch": "@@ -561,69 +561,68 @@ fn is_elided_lifetime(param: &hir::GenericParam<'_>) -> bool {\n     matches!(param.kind, hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided })\n }\n \n-impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n-        let impl_trait_params = self\n-            .params\n-            .iter()\n-            .filter(|param| is_impl_trait(param))\n-            .map(|param| {\n-                let param = clean_generic_param(cx, Some(self), param);\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime { .. } => unreachable!(),\n-                    GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n-                    }\n-                    GenericParamDefKind::Const { .. } => unreachable!(),\n+pub(crate) fn clean_generics<'tcx>(\n+    gens: &hir::Generics<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Generics {\n+    let impl_trait_params = gens\n+        .params\n+        .iter()\n+        .filter(|param| is_impl_trait(param))\n+        .map(|param| {\n+            let param = clean_generic_param(cx, Some(gens), param);\n+            match param.kind {\n+                GenericParamDefKind::Lifetime { .. } => unreachable!(),\n+                GenericParamDefKind::Type { did, ref bounds, .. } => {\n+                    cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n                 }\n-                param\n-            })\n-            .collect::<Vec<_>>();\n+                GenericParamDefKind::Const { .. } => unreachable!(),\n+            }\n+            param\n+        })\n+        .collect::<Vec<_>>();\n \n-        let mut params = Vec::with_capacity(self.params.len());\n-        for p in self.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-            let p = clean_generic_param(cx, Some(self), p);\n-            params.push(p);\n-        }\n-        params.extend(impl_trait_params);\n+    let mut params = Vec::with_capacity(gens.params.len());\n+    for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n+        let p = clean_generic_param(cx, Some(gens), p);\n+        params.push(p);\n+    }\n+    params.extend(impl_trait_params);\n \n-        let mut generics = Generics {\n-            params,\n-            where_predicates: self\n-                .predicates\n-                .iter()\n-                .filter_map(|x| clean_where_predicate(x, cx))\n-                .collect(),\n-        };\n+    let mut generics = Generics {\n+        params,\n+        where_predicates: gens\n+            .predicates\n+            .iter()\n+            .filter_map(|x| clean_where_predicate(x, cx))\n+            .collect(),\n+    };\n \n-        // Some duplicates are generated for ?Sized bounds between type params and where\n-        // predicates. The point in here is to move the bounds definitions from type params\n-        // to where predicates when such cases occur.\n-        for where_pred in &mut generics.where_predicates {\n-            match *where_pred {\n-                WherePredicate::BoundPredicate {\n-                    ty: Generic(ref name), ref mut bounds, ..\n-                } => {\n-                    if bounds.is_empty() {\n-                        for param in &mut generics.params {\n-                            match param.kind {\n-                                GenericParamDefKind::Lifetime { .. } => {}\n-                                GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n-                                    if &param.name == name {\n-                                        mem::swap(bounds, ty_bounds);\n-                                        break;\n-                                    }\n+    // Some duplicates are generated for ?Sized bounds between type params and where\n+    // predicates. The point in here is to move the bounds definitions from type params\n+    // to where predicates when such cases occur.\n+    for where_pred in &mut generics.where_predicates {\n+        match *where_pred {\n+            WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds, .. } => {\n+                if bounds.is_empty() {\n+                    for param in &mut generics.params {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime { .. } => {}\n+                            GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n+                                if &param.name == name {\n+                                    mem::swap(bounds, ty_bounds);\n+                                    break;\n                                 }\n-                                GenericParamDefKind::Const { .. } => {}\n                             }\n+                            GenericParamDefKind::Const { .. } => {}\n                         }\n                     }\n                 }\n-                _ => continue,\n             }\n+            _ => continue,\n         }\n-        generics\n     }\n+    generics\n }\n \n fn clean_ty_generics<'tcx>(\n@@ -889,7 +888,7 @@ fn clean_function<'tcx>(\n ) -> Box<Function> {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n         // NOTE: generics must be cleaned before args\n-        let generics = generics.clean(cx);\n+        let generics = clean_generics(generics, cx);\n         let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n         (generics, decl)\n@@ -1018,15 +1017,15 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n-                    let generics = trait_item.generics.clean(cx);\n+                    let generics = clean_generics(trait_item.generics, cx);\n                     let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n                     (generics, decl)\n                 });\n                 TyMethodItem(Box::new(Function { decl, generics }))\n             }\n             hir::TraitItemKind::Type(bounds, Some(default)) => {\n-                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n                 let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n                 AssocTypeItem(\n@@ -1039,7 +1038,7 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n                 )\n             }\n             hir::TraitItemKind::Type(bounds, None) => {\n-                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n                 TyAssocTypeItem(Box::new(generics), bounds)\n             }\n@@ -1051,45 +1050,46 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n     })\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let local_did = self.def_id.to_def_id();\n-        cx.with_param_env(local_did, |cx| {\n-            let inner = match self.kind {\n-                hir::ImplItemKind::Const(ty, expr) => {\n-                    let default = ConstantKind::Local { def_id: local_did, body: expr };\n-                    AssocConstItem(clean_ty(ty, cx), default)\n-                }\n-                hir::ImplItemKind::Fn(ref sig, body) => {\n-                    let m = clean_function(cx, sig, self.generics, body);\n-                    let defaultness = cx.tcx.impl_defaultness(self.def_id);\n-                    MethodItem(m, Some(defaultness))\n-                }\n-                hir::ImplItemKind::TyAlias(hir_ty) => {\n-                    let type_ = clean_ty(hir_ty, cx);\n-                    let generics = self.generics.clean(cx);\n-                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n-                    AssocTypeItem(\n-                        Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n-                        Vec::new(),\n-                    )\n-                }\n-            };\n+pub(crate) fn clean_impl_item<'tcx>(\n+    impl_: &hir::ImplItem<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Item {\n+    let local_did = impl_.def_id.to_def_id();\n+    cx.with_param_env(local_did, |cx| {\n+        let inner = match impl_.kind {\n+            hir::ImplItemKind::Const(ty, expr) => {\n+                let default = ConstantKind::Local { def_id: local_did, body: expr };\n+                AssocConstItem(clean_ty(ty, cx), default)\n+            }\n+            hir::ImplItemKind::Fn(ref sig, body) => {\n+                let m = clean_function(cx, sig, impl_.generics, body);\n+                let defaultness = cx.tcx.impl_defaultness(impl_.def_id);\n+                MethodItem(m, Some(defaultness))\n+            }\n+            hir::ImplItemKind::TyAlias(hir_ty) => {\n+                let type_ = clean_ty(hir_ty, cx);\n+                let generics = clean_generics(impl_.generics, cx);\n+                let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n+                AssocTypeItem(\n+                    Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n+                    Vec::new(),\n+                )\n+            }\n+        };\n \n-            let mut what_rustc_thinks =\n-                Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n+        let mut what_rustc_thinks =\n+            Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n \n-            let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(self.def_id));\n+        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.def_id));\n \n-            // Trait impl items always inherit the impl's visibility --\n-            // we don't want to show `pub`.\n-            if impl_ref.is_some() {\n-                what_rustc_thinks.visibility = Inherited;\n-            }\n+        // Trait impl items always inherit the impl's visibility --\n+        // we don't want to show `pub`.\n+        if impl_ref.is_some() {\n+            what_rustc_thinks.visibility = Inherited;\n+        }\n \n-            what_rustc_thinks\n-        })\n-    }\n+        what_rustc_thinks\n+    })\n }\n \n impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n@@ -1898,32 +1898,32 @@ fn clean_maybe_renamed_item<'tcx>(\n             }),\n             ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n                 bounds: ty.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-                generics: ty.generics.clean(cx),\n+                generics: clean_generics(ty.generics, cx),\n             }),\n             ItemKind::TyAlias(hir_ty, generics) => {\n                 let rustdoc_ty = clean_ty(hir_ty, cx);\n                 let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                 TypedefItem(Box::new(Typedef {\n                     type_: rustdoc_ty,\n-                    generics: generics.clean(cx),\n+                    generics: clean_generics(generics, cx),\n                     item_type: Some(ty),\n                 }))\n             }\n             ItemKind::Enum(ref def, generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n             }),\n             ItemKind::TraitAlias(generics, bounds) => TraitAliasItem(TraitAlias {\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n             }),\n             ItemKind::Union(ref variant_data, generics) => UnionItem(Union {\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Struct(ref variant_data, generics) => StructItem(Struct {\n                 struct_type: CtorKind::from_hir(variant_data),\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n@@ -1946,7 +1946,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 TraitItem(Trait {\n                     def_id,\n                     items,\n-                    generics: generics.clean(cx),\n+                    generics: clean_generics(generics, cx),\n                     bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n                 })\n             }\n@@ -1981,8 +1981,11 @@ fn clean_impl<'tcx>(\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.as_ref().map(|t| clean_trait_ref(t, cx));\n-    let items =\n-        impl_.items.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n+    let items = impl_\n+        .items\n+        .iter()\n+        .map(|ii| clean_impl_item(tcx.hir().impl_item(ii.id), cx))\n+        .collect::<Vec<_>>();\n     let def_id = tcx.hir().local_def_id(hir_id);\n \n     // If this impl block is an implementation of the Deref trait, then we\n@@ -1999,7 +2002,7 @@ fn clean_impl<'tcx>(\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Box::new(Impl {\n             unsafety: impl_.unsafety,\n-            generics: impl_.generics.clean(cx),\n+            generics: clean_generics(impl_.generics, cx),\n             trait_,\n             for_,\n             items,\n@@ -2196,7 +2199,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n             hir::ForeignItemKind::Fn(decl, names, generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n-                    let generics = generics.clean(cx);\n+                    let generics = clean_generics(generics, cx);\n                     let args = clean_args_from_types_and_names(cx, decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, decl, args);\n                     (generics, decl)"}]}