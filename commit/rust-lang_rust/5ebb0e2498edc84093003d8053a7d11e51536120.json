{"sha": "5ebb0e2498edc84093003d8053a7d11e51536120", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYmIwZTI0OThlZGM4NDA5MzAwM2Q4MDUzYTdkMTFlNTE1MzYxMjA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-05T04:42:39Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-12T02:14:23Z"}, "message": "Implement a bunch more signature functions", "tree": {"sha": "3489ad328137f158c0eeba1e3f6ab669b5dd8b85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3489ad328137f158c0eeba1e3f6ab669b5dd8b85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ebb0e2498edc84093003d8053a7d11e51536120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebb0e2498edc84093003d8053a7d11e51536120", "html_url": "https://github.com/rust-lang/rust/commit/5ebb0e2498edc84093003d8053a7d11e51536120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ebb0e2498edc84093003d8053a7d11e51536120/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35abf139a2e43b8695d907ab62bc2bb46bc8bcc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/35abf139a2e43b8695d907ab62bc2bb46bc8bcc3", "html_url": "https://github.com/rust-lang/rust/commit/35abf139a2e43b8695d907ab62bc2bb46bc8bcc3"}], "stats": {"total": 266, "additions": 231, "deletions": 35}, "files": [{"sha": "61fc9a9adfb09efb750fd630fca0e8fdb0e9c341", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb0e2498edc84093003d8053a7d11e51536120/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb0e2498edc84093003d8053a7d11e51536120/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5ebb0e2498edc84093003d8053a7d11e51536120", "patch": "@@ -701,8 +701,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             scope: enum_data.scope,\n                             parent: Some(make_def_id(item.id, &self.tcx.hir)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n-                            // TODO\n-                            sig: None,\n+                            sig: sig::variant_signature(variant, &self.save_ctxt),\n                             attributes: variant.node.attrs.clone(),\n                         }.lower(self.tcx));\n                     }\n@@ -729,8 +728,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             scope: enum_data.scope,\n                             parent: Some(make_def_id(item.id, &self.tcx.hir)),\n                             docs: docs_for_attrs(&variant.node.attrs),\n-                            // TODO\n-                            sig: None,\n+                            sig: sig::variant_signature(variant, &self.save_ctxt),\n                             attributes: variant.node.attrs.clone(),\n                         }.lower(self.tcx));\n                     }"}, {"sha": "8e280377ce2d6fa2d1d95ee7e1cf66f14fde5e34", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb0e2498edc84093003d8053a7d11e51536120/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb0e2498edc84093003d8053a7d11e51536120/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5ebb0e2498edc84093003d8053a7d11e51536120", "patch": "@@ -141,8 +141,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     visibility: From::from(&item.vis),\n                     parent: None,\n                     docs: docs_for_attrs(&item.attrs),\n-                    // TODO\n-                    sig: None,\n+                    sig: sig::foreign_item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -162,8 +161,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(ty),\n                     visibility: From::from(&item.vis),\n                     docs: docs_for_attrs(&item.attrs),\n-                    // TODO\n-                    sig: None,\n+                    sig: sig::foreign_item_signature(item, self),\n                     attributes: item.attrs.clone(),\n                 }))\n             }\n@@ -361,8 +359,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 type_value: typ,\n                 visibility: From::from(&field.vis),\n                 docs: docs_for_attrs(&field.attrs),\n-                // TODO\n-                sig: None,\n+                sig: sig::field_signature(field, self),\n                 attributes: field.attrs.clone(),\n             })\n         } else {"}, {"sha": "b2a62038dfc15c7a2357e04161d3d0cf51267e97", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 226, "deletions": 25, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/5ebb0e2498edc84093003d8053a7d11e51536120/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebb0e2498edc84093003d8053a7d11e51536120/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=5ebb0e2498edc84093003d8053a7d11e51536120", "patch": "@@ -48,6 +48,21 @@ pub fn item_signature(item: &ast::Item, scx: &SaveContext) -> Option<Signature>\n     item.make(0, None, scx).ok()\n }\n \n+pub fn foreign_item_signature(item: &ast::ForeignItem, scx: &SaveContext) -> Option<Signature> {\n+    item.make(0, None, scx).ok()\n+}\n+\n+/// Signature for a struct or tuple field declaration.\n+/// Does not include a trailing comma.\n+pub fn field_signature(field: &ast::StructField, scx: &SaveContext) -> Option<Signature> {\n+    field.make(0, None, scx).ok()\n+}\n+\n+/// Does not include a trailing comma.\n+pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext) -> Option<Signature> {\n+    variant.node.make(0, None, scx).ok()\n+}\n+\n type Result = ::std::result::Result<Signature, &'static str>;\n \n trait Sig {\n@@ -255,20 +270,6 @@ impl Sig for ast::Item {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n         let id = Some(self.id);\n \n-        let name_and_generics = |mut text: String, generics: &ast::Generics| -> Result {\n-            let name = self.ident.to_string();\n-            let def = SigElement {\n-                id: id_from_node_id(self.id, scx),\n-                start: offset + text.len(),\n-                end: offset + text.len() + name.len(),\n-            };\n-            text.push_str(&name);\n-            let generics: Signature = generics.make(offset + text.len(), id, scx)?;\n-            // FIXME where clause\n-            let text = format!(\"{}{}\", text, generics.text);\n-            Ok(extend_sig(generics, text, vec![def], vec![]))\n-        };\n-\n         match self.node {\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 let mut text = \"static \".to_owned();\n@@ -330,7 +331,12 @@ impl Sig for ast::Item {\n                 }\n                 text.push_str(\"fn \");\n \n-                let mut sig = name_and_generics(text, generics)?;\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n \n                 sig.text.push('(');\n                 for i in &decl.inputs {\n@@ -352,6 +358,7 @@ impl Sig for ast::Item {\n                     sig.defs.extend(nested.defs.into_iter());\n                     sig.refs.extend(nested.refs.into_iter());\n                 }\n+                sig.text.push_str(\" {}\");\n \n                 Ok(sig)\n             }\n@@ -375,7 +382,12 @@ impl Sig for ast::Item {\n             }\n             ast::ItemKind::Ty(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n-                let mut sig = name_and_generics(text, generics)?;\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n \n                 sig.text.push_str(\" = \");\n                 let ty = ty.make(offset + sig.text.len(), id, scx)?;\n@@ -386,19 +398,34 @@ impl Sig for ast::Item {\n             }\n             ast::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n-                let mut sig = name_and_generics(text, generics)?;\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             ast::ItemKind::Struct(_, ref generics) => {\n                 let text = \"struct \".to_owned();\n-                let mut sig = name_and_generics(text, generics)?;\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             ast::ItemKind::Union(_, ref generics) => {\n                 let text = \"union \".to_owned();\n-                let mut sig = name_and_generics(text, generics)?;\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n@@ -408,7 +435,12 @@ impl Sig for ast::Item {\n                     text.push_str(\"unsafe \");\n                 }\n                 text.push_str(\"trait \");\n-                let mut sig = name_and_generics(text, generics)?;\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\": \");\n@@ -485,10 +517,6 @@ impl Sig for ast::Item {\n \n impl Sig for ast::Path {\n     fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext) -> Result {\n-        // if generated_code(span) {\n-        //     return Err(\"Generated code\");\n-        // }\n-\n         let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n \n         let (name, start, end) = match def {\n@@ -583,4 +611,177 @@ impl Sig for ast::Generics {\n     }\n }\n \n-// TODO impl items, trait items, fields, extern items, enum variant\n+impl Sig for ast::StructField {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let mut text = String::new();\n+        let mut defs = None;\n+        if let Some(ref ident) = self.ident {\n+            text.push_str(&ident.to_string());\n+            defs = Some(SigElement {\n+                id: id_from_node_id(self.id, scx),\n+                start: offset,\n+                end: offset + text.len(),\n+            });\n+            text.push_str(\": \");\n+        }\n+\n+        let mut ty_sig = self.ty.make(offset + text.len(), Some(self.id), scx)?;\n+        text.push_str(&ty_sig.text);\n+        ty_sig.text = text;\n+        ty_sig.defs.extend(defs.into_iter());\n+        Ok(ty_sig)\n+    }\n+}\n+\n+\n+impl Sig for ast::Variant_ {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let mut text = self.name.to_string();\n+        match self.data {\n+            ast::VariantData::Struct(ref fields, id) => {\n+                let name_def = SigElement {\n+                    id: id_from_node_id(id, scx),\n+                    start: offset,\n+                    end: offset + text.len(),\n+                };\n+                text.push_str(\" { \");\n+                let mut defs = vec![name_def];\n+                let mut refs = vec![];\n+                for f in fields {\n+                    let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n+                    text.push_str(&field_sig.text);\n+                    text.push_str(\", \");\n+                    defs.extend(field_sig.defs.into_iter());\n+                    refs.extend(field_sig.refs.into_iter());\n+                }\n+                text.push('}');\n+                Ok(Signature {\n+                    text,\n+                    defs: defs,\n+                    refs: refs,\n+                })\n+            }\n+            ast::VariantData::Tuple(ref fields, id) => {\n+                let name_def = SigElement {\n+                    id: id_from_node_id(id, scx),\n+                    start: offset,\n+                    end: offset + text.len(),\n+                };\n+                text.push('(');\n+                let mut defs = vec![name_def];\n+                let mut refs = vec![];\n+                for f in fields {\n+                    let field_sig = f.make(offset + text.len(), Some(id), scx)?;\n+                    text.push_str(&field_sig.text);\n+                    text.push_str(\", \");\n+                    defs.extend(field_sig.defs.into_iter());\n+                    refs.extend(field_sig.refs.into_iter());\n+                }\n+                text.push(')');\n+                Ok(Signature {\n+                    text,\n+                    defs: defs,\n+                    refs: refs,\n+                })\n+            }\n+            ast::VariantData::Unit(id) => {\n+                let name_def = SigElement {\n+                    id: id_from_node_id(id, scx),\n+                    start: offset,\n+                    end: offset + text.len(),\n+                };\n+                Ok(Signature {\n+                    text,\n+                    defs: vec![name_def],\n+                    refs: vec![],\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl Sig for ast::ForeignItem {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let id = Some(self.id);\n+        match self.node {\n+            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n+                let mut text = String::new();\n+                text.push_str(\"fn \");\n+\n+                let mut sig = name_and_generics(text,\n+                                                offset,\n+                                                generics,\n+                                                self.id,\n+                                                self.ident,\n+                                                scx)?;\n+\n+                sig.text.push('(');\n+                for i in &decl.inputs {\n+                    // FIXME should descend into patterns to add defs.\n+                    sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+                    sig.text.push_str(\": \");\n+                    let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.text.push(',');\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push(')');\n+\n+                if let ast::FunctionRetTy::Ty(ref t) = decl.output {\n+                    sig.text.push_str(\" -> \");\n+                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push(';');\n+\n+                Ok(sig)\n+            }\n+            ast::ForeignItemKind::Static(ref ty, m) => {\n+                let mut text = \"static \".to_owned();\n+                if m {\n+                    text.push_str(\"mut \");\n+                }\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                text.push_str(\": \");\n+\n+                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n+                text.push(';');\n+\n+                Ok(extend_sig(ty_sig, text, defs, vec![]))\n+            }\n+        }\n+    }\n+}\n+\n+fn name_and_generics(mut text: String,\n+                     offset: usize,\n+                     generics: &ast::Generics,\n+                     id: NodeId,\n+                     name: ast::Ident,\n+                     scx: &SaveContext)\n+                     -> Result {\n+    let name = name.to_string();\n+    let def = SigElement {\n+        id: id_from_node_id(id, scx),\n+        start: offset + text.len(),\n+        end: offset + text.len() + name.len(),\n+    };\n+    text.push_str(&name);\n+    let generics: Signature = generics.make(offset + text.len(), Some(id), scx)?;\n+    // FIXME where clause\n+    let text = format!(\"{}{}\", text, generics.text);\n+    Ok(extend_sig(generics, text, vec![def], vec![]))\n+}\n+\n+\n+// TODO impl items, trait items\n+// for impl/trait sigs - function for each kind, rather than use trait."}]}