{"sha": "b5499775d6bee080b3f46539d59d238de2c1726f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NDk5Nzc1ZDZiZWUwODBiM2Y0NjUzOWQ1OWQyMzhkZTJjMTcyNmY=", "commit": {"author": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-03-14T18:05:00Z"}, "committer": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-04-24T03:02:25Z"}, "message": "Structural changes for associated constants\n\nIntroduces new variants and types in syntax::ast, middle::ty, and middle::def.", "tree": {"sha": "b8d5b0e9aae8d8ffcf884c9f98299ef1add06ed0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8d5b0e9aae8d8ffcf884c9f98299ef1add06ed0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5499775d6bee080b3f46539d59d238de2c1726f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5499775d6bee080b3f46539d59d238de2c1726f", "html_url": "https://github.com/rust-lang/rust/commit/b5499775d6bee080b3f46539d59d238de2c1726f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5499775d6bee080b3f46539d59d238de2c1726f/comments", "author": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "committer": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21f278a6877b3a66f665d86402c6ae057827a610", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f278a6877b3a66f665d86402c6ae057827a610", "html_url": "https://github.com/rust-lang/rust/commit/21f278a6877b3a66f665d86402c6ae057827a610"}], "stats": {"total": 659, "additions": 416, "deletions": 243}, "files": [{"sha": "8e3f77f949b6b23f4bc66d3f63ae86a189626b46", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -951,11 +951,8 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                                     cdata,\n                                                     did.node,\n                                                     tcx);\n-            match trait_item {\n-                ty::MethodTraitItem(ref method) => {\n-                    result.push((*method).clone())\n-                }\n-                ty::TypeTraitItem(_) => {}\n+            if let ty::MethodTraitItem(ref method) = trait_item {\n+                result.push((*method).clone())\n             }\n         }\n         true"}, {"sha": "5f31e24a0637f30ce9bbc67f425f1af3bda7be30", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -378,14 +378,11 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n-                    match impl_item {\n-                        ty::MethodTraitItem(ref m) => {\n-                            encode_reexported_static_method(rbml_w,\n-                                                            exp,\n-                                                            m.def_id,\n-                                                            m.name);\n-                        }\n-                        ty::TypeTraitItem(_) => {}\n+                    if let ty::MethodTraitItem(ref m) = impl_item {\n+                        encode_reexported_static_method(rbml_w,\n+                                                        exp,\n+                                                        m.def_id,\n+                                                        m.name);\n                     }\n                 }\n             }\n@@ -1195,6 +1192,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n+                ty::ConstTraitItemId(_) => {}\n                 ty::MethodTraitItemId(item_def_id) => {\n                     encode_def_id(rbml_w, item_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1232,6 +1230,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             });\n \n             match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+                ty::ConstTraitItem(_) => {}\n                 ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n@@ -1276,6 +1275,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n+                ty::ConstTraitItemId(_) => {}\n                 ty::MethodTraitItemId(method_def_id) => {\n                     encode_def_id(rbml_w, method_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1321,6 +1321,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::impl_or_trait_item(tcx, item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n+                ty::ConstTraitItem(_) => {\n+                    is_nonstatic_method = false;\n+                }\n                 ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n@@ -1365,6 +1368,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n+                ast::ConstTraitItem(_, _) => {}\n                 ast::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n                     // encoded this."}, {"sha": "61b610ab6555e7dfe6f70ea905b7799c7be63f42", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -465,6 +465,9 @@ impl tr for def::Def {\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n           def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n+          def::DefAssociatedConst(did, p) => {\n+              def::DefAssociatedConst(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n+          }\n           def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)"}, {"sha": "fc40febdbf82e3d6446af3ef20855298641cc81b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n             match def.full_def() {\n-                def::DefConst(_) => {\n+                def::DefConst(_) | def::DefAssociatedConst(..) => {\n                     self.check_def_id(def.def_id())\n                 }\n                 _ if self.ignore_non_const_paths => (),\n@@ -114,14 +114,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         let trait_item = ty::trait_item(self.tcx,\n                                                         trait_ref.def_id,\n                                                         index);\n-                        match trait_item {\n-                            ty::MethodTraitItem(method) => {\n-                                self.check_def_id(method.def_id);\n-                            }\n-                            ty::TypeTraitItem(typedef) => {\n-                                self.check_def_id(typedef.def_id);\n-                            }\n-                        }\n+                        self.check_def_id(trait_item.def_id());\n                     }\n                 }\n             }\n@@ -365,6 +358,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n+                        ast::ConstImplItem(..) => {}\n                         ast::MethodImplItem(..) => {\n                             if opt_trait.is_some() ||\n                                     has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n@@ -584,6 +578,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n         match trait_method.node {\n+            ast::ConstTraitItem(_, _) => {}\n             ast::MethodTraitItem(_, Some(ref body)) => {\n                 visit::walk_block(self, body)\n             }"}, {"sha": "bce246fa4af866dbd2ec1f974dbdd4158ee5f0f0", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -28,6 +28,7 @@ pub enum Def {\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n     DefConst(ast::DefId),\n+    DefAssociatedConst(ast::DefId /* const */, MethodProvenance),\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n@@ -140,7 +141,8 @@ impl Def {\n             DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) | DefConst(id) | DefSelfTy(Some(id), None)=> {\n+            DefMethod(id, _) | DefConst(id) | DefAssociatedConst(id, _) |\n+            DefSelfTy(Some(id), None)=> {\n                 id\n             }\n             DefLocal(id) |"}, {"sha": "87379bd48f0c44ae164cae4e64ccd5ad78885856", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -234,7 +234,7 @@ impl OverloadedCallType {\n             ty::MethodTraitItem(ref method_descriptor) => {\n                 (*method_descriptor).clone()\n             }\n-            ty::TypeTraitItem(_) => {\n+            _ => {\n                 tcx.sess.bug(\"overloaded call method wasn't in method map\")\n             }\n         };\n@@ -1183,6 +1183,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         }\n \n                         Some(def::DefConst(..)) |\n+                        Some(def::DefAssociatedConst(..)) |\n                         Some(def::DefLocal(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no"}, {"sha": "22e3376e09ea8f4a46ba4cd8bcabd84c597b8412", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -843,8 +843,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n-                        ast::TypeImplItem(_) => None,\n-                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n+                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\"),\n+                        _ => None,\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n@@ -1723,8 +1723,8 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                         taken.push_all(&sig.generics.lifetimes);\n                         Some(ii.id)\n                     }\n-                    ast::TypeImplItem(_) => None,\n-                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\")\n+                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\"),\n+                    _ => None,\n                 }\n             }\n             _ => None"}, {"sha": "6db55baf483503a1fd87ec9ac7b12ae423984603", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -589,7 +589,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n-          def::DefFn(..) | def::DefMethod(..) => {\n+          def::DefAssociatedConst(..) | def::DefFn(..) | def::DefMethod(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n@@ -1286,7 +1286,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n-                Some(def::DefConst(..)) => {\n+                Some(def::DefConst(..)) | Some(def::DefAssociatedConst(..)) => {\n                     for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }"}, {"sha": "7a0f58947fe709688523991103ccf0232434d3fb", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -62,7 +62,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) => true,\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "b532dc88df4cb5c939c6935ddd20bd1edbd2fba8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n-                            def::DefConst(..) => {\n+                            def::DefConst(..) | def::DefAssociatedConst(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n \n@@ -183,12 +183,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n+                    ast::ConstTraitItem(_, ref default) => default.is_some(),\n                     ast::MethodTraitItem(_, ref body) => body.is_some(),\n                     ast::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(..) => true,\n                     ast::MethodImplItem(ref sig, _) => {\n                         if generics_require_inlining(&sig.generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n@@ -303,9 +305,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n+                    ast::ConstTraitItem(_, None) |\n                     ast::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n+                    ast::ConstTraitItem(_, Some(ref expr)) => {\n+                        self.visit_expr(&*expr);\n+                    }\n                     ast::MethodTraitItem(_, Some(ref body)) => {\n                         visit::walk_block(self, body);\n                     }\n@@ -314,6 +320,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(_, ref expr) => {\n+                        self.visit_expr(&*expr);\n+                    }\n                     ast::MethodImplItem(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {"}, {"sha": "3d6ed3c34406118fdea3f0bedfc381d78e7e7c6e", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -100,9 +100,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                         .into_iter()\n                 }\n-                ty::TypeTraitItem(_) => {\n-                    None.into_iter()\n-                }\n+                _ => None.into_iter(),\n             }\n         })\n         .collect();"}, {"sha": "9cdae21868ed3393ec4493ca2c7cb06fce921c80", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -863,7 +863,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     for impl_item in impl_items {\n         let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-            ty::MethodTraitItem(..) => { continue; }\n+            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => { continue; }\n         };\n \n         if assoc_type.name != obligation.predicate.item_name {"}, {"sha": "6ecff3b7faabe9178064a6676be5deaf85124cf5", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -434,7 +434,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         for trait_item in &**trait_items {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n-                ty::TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n     }\n@@ -445,14 +445,14 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for trait_item in trait_items.iter().take(method_offset_in_trait) {\n         match *trait_item {\n             ty::MethodTraitItem(_) => method_count += 1,\n-            ty::TypeTraitItem(_) => {}\n+            _ => {}\n         }\n     }\n \n     // the item at the offset we were given really ought to be a method\n     assert!(match trait_items[method_offset_in_trait] {\n         ty::MethodTraitItem(_) => true,\n-        ty::TypeTraitItem(_) => false\n+        _ => false\n     });\n \n     method_count"}, {"sha": "3f5f40ec0b59bf7bc91754d30872698e6d0a5af0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 70, "deletions": 14, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -131,13 +131,17 @@ impl ImplOrTraitItemContainer {\n \n #[derive(Clone, Debug)]\n pub enum ImplOrTraitItem<'tcx> {\n+    ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n     MethodTraitItem(Rc<Method<'tcx>>),\n     TypeTraitItem(Rc<AssociatedType>),\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n     fn id(&self) -> ImplOrTraitItemId {\n         match *self {\n+            ConstTraitItem(ref associated_const) => {\n+                ConstTraitItemId(associated_const.def_id)\n+            }\n             MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n             TypeTraitItem(ref associated_type) => {\n                 TypeTraitItemId(associated_type.def_id)\n@@ -147,20 +151,31 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n \n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.def_id,\n             MethodTraitItem(ref method) => method.def_id,\n             TypeTraitItem(ref associated_type) => associated_type.def_id,\n         }\n     }\n \n     pub fn name(&self) -> ast::Name {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.name,\n             MethodTraitItem(ref method) => method.name,\n             TypeTraitItem(ref associated_type) => associated_type.name,\n         }\n     }\n \n+    pub fn vis(&self) -> ast::Visibility {\n+        match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.vis,\n+            MethodTraitItem(ref method) => method.vis,\n+            TypeTraitItem(ref associated_type) => associated_type.vis,\n+        }\n+    }\n+\n     pub fn container(&self) -> ImplOrTraitItemContainer {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.container,\n             MethodTraitItem(ref method) => method.container,\n             TypeTraitItem(ref associated_type) => associated_type.container,\n         }\n@@ -169,20 +184,22 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n         match *self {\n             MethodTraitItem(ref m) => Some((*m).clone()),\n-            TypeTraitItem(_) => None\n+            _ => None,\n         }\n     }\n }\n \n #[derive(Clone, Copy, Debug)]\n pub enum ImplOrTraitItemId {\n+    ConstTraitItemId(ast::DefId),\n     MethodTraitItemId(ast::DefId),\n     TypeTraitItemId(ast::DefId),\n }\n \n impl ImplOrTraitItemId {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n+            ConstTraitItemId(def_id) => def_id,\n             MethodTraitItemId(def_id) => def_id,\n             TypeTraitItemId(def_id) => def_id,\n         }\n@@ -236,6 +253,16 @@ impl<'tcx> Method<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+pub struct AssociatedConst<'tcx> {\n+    pub name: ast::Name,\n+    pub ty: Ty<'tcx>,\n+    pub vis: ast::Visibility,\n+    pub def_id: ast::DefId,\n+    pub container: ImplOrTraitItemContainer,\n+    pub default: Option<ast::DefId>,\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct AssociatedType {\n     pub name: ast::Name,\n@@ -2273,6 +2300,16 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(_, _) => {\n+                        let def_id = ast_util::local_def(id);\n+                        let scheme = lookup_item_type(cx, def_id);\n+                        let predicates = lookup_predicates(cx, def_id);\n+                        construct_parameter_environment(cx,\n+                                                        impl_item.span,\n+                                                        &scheme.generics,\n+                                                        &predicates,\n+                                                        id)\n+                    }\n                     ast::MethodImplItem(_, ref body) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n@@ -2286,11 +2323,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     method_bounds,\n                                     body.id)\n                             }\n-                            TypeTraitItem(_) => {\n+                            _ => {\n                                 cx.sess\n                                   .bug(\"ParameterEnvironment::for_item(): \\\n-                                        can't create a parameter environment \\\n-                                        for type trait items\")\n+                                        got non-method item from impl method?!\")\n                             }\n                         }\n                     }\n@@ -2304,6 +2340,25 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n+                    ast::ConstTraitItem(_, ref default) => {\n+                        match *default {\n+                            Some(_) => {\n+                                let def_id = ast_util::local_def(id);\n+                                let scheme = lookup_item_type(cx, def_id);\n+                                let predicates = lookup_predicates(cx, def_id);\n+                                construct_parameter_environment(cx,\n+                                                                trait_item.span,\n+                                                                &scheme.generics,\n+                                                                &predicates,\n+                                                                id)\n+                            }\n+                            None => {\n+                                cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n+                                             can't create a parameter environment \\\n+                                             for const trait items without defaults\")\n+                            }\n+                        }\n+                    }\n                     ast::MethodTraitItem(_, None) => {\n                         cx.sess.span_bug(trait_item.span,\n                                          \"ParameterEnvironment::for_item():\n@@ -2324,11 +2379,11 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     method_bounds,\n                                     body.id)\n                             }\n-                            TypeTraitItem(_) => {\n+                            _ => {\n                                 cx.sess\n                                   .bug(\"ParameterEnvironment::for_item(): \\\n-                                        can't create a parameter environment \\\n-                                        for type trait items\")\n+                                        got non-method item from provided \\\n+                                        method?!\")\n                             }\n                         }\n                     }\n@@ -4700,7 +4755,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefUpvar(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n-                def::DefConst(..) => RvalueDatumExpr,\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => RvalueDatumExpr,\n \n                 def => {\n                     tcx.sess.span_bug(\n@@ -5051,10 +5107,10 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n                     match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n                         MethodTraitItem(m) => Some(m),\n-                        TypeTraitItem(_) => {\n+                        _ => {\n                             cx.sess.bug(\"provided_trait_methods(): \\\n-                                         associated type found from \\\n-                                         looking up ProvidedMethod?!\")\n+                                         non-method item found from \\\n+                                         looking up provided method?!\")\n                         }\n                     }\n                 } else {\n@@ -5155,7 +5211,7 @@ pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n                 Some(ref item) => {\n                     match **item {\n                         TypeTraitItem(_) => true,\n-                        MethodTraitItem(_) => false,\n+                        _ => false,\n                     }\n                 }\n                 None => false,\n@@ -6169,7 +6225,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                            .insert(method_def_id, source);\n                     }\n                 }\n-                TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n \n@@ -6221,7 +6277,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n                             .insert(method_def_id, source);\n                     }\n                 }\n-                TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n "}, {"sha": "3d56371dd52cafc56ae365b786a0b623e1504548", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -830,6 +830,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let kind = match self.node {\n+            ast::ConstTraitItem(..) => \"ConstTraitItem\",\n             ast::MethodTraitItem(..) => \"MethodTraitItem\",\n             ast::TypeTraitItem(..) => \"TypeTraitItem\",\n         };\n@@ -1054,9 +1055,39 @@ impl<'tcx> Repr<'tcx> for ty::Variance {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::ImplOrTraitItem<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ImplOrTraitItem({})\",\n+                match *self {\n+                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(tcx),\n+                })\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::AssociatedConst<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"AssociatedConst(name: {}, ty: {}, vis: {}, def_id: {})\",\n+                self.name.repr(tcx),\n+                self.ty.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::AssociatedType {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n+                self.name.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n+        format!(\"Method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n                 self.generics.repr(tcx),"}, {"sha": "f4761f95505642409b041c678de10fb2fc70adcb", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -1584,8 +1584,9 @@ impl LintPass for MissingDoc {\n         if self.private_traits.contains(&trait_item.id) { return }\n \n         let desc = match trait_item.node {\n+            ast::ConstTraitItem(..) => \"an associated constant\",\n             ast::MethodTraitItem(..) => \"a trait method\",\n-            ast::TypeTraitItem(..) => \"an associated type\"\n+            ast::TypeTraitItem(..) => \"an associated type\",\n         };\n \n         self.check_missing_docs_attrs(cx, Some(trait_item.id),\n@@ -1600,9 +1601,10 @@ impl LintPass for MissingDoc {\n         }\n \n         let desc = match impl_item.node {\n+            ast::ConstImplItem(..) => \"an associated constant\",\n             ast::MethodImplItem(..) => \"a method\",\n             ast::TypeImplItem(_) => \"an associated type\",\n-            ast::MacImplItem(_) => \"an impl item macro\"\n+            ast::MacImplItem(_) => \"an impl item macro\",\n         };\n         self.check_missing_docs_attrs(cx, Some(impl_item.id),\n                                       &impl_item.attrs,"}, {"sha": "832a33e3fe0cf7a78b838557aba0e47ba849b38e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -272,6 +272,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n+                            ast::ConstImplItem(_, _) => {}\n                             ast::MethodImplItem(ref sig, _) => {\n                                 let meth_public = match sig.explicit_self.node {\n                                     ast::SelfStatic => public_ty,\n@@ -399,6 +400,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             debug!(\"privacy - is {:?} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n+                Some(&ty::ConstTraitItem(_)) => ExternallyDenied,\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n                     debug!(\"privacy - well at least it's a method: {:?}\",\n                            *meth);\n@@ -490,6 +492,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n                     match ii.node {\n+                        ast::ConstImplItem(..) |\n                         ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n@@ -693,7 +696,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ty::MethodTraitItem(method_type) => {\n                 method_type.provided_source.unwrap_or(method_id)\n             }\n-            ty::TypeTraitItem(_) => method_id,\n+            _ => {\n+                self.tcx.sess\n+                    .span_bug(span,\n+                              \"got non-method item in check_static_method\")\n+            }\n         };\n \n         let string = token::get_name(name);\n@@ -1128,8 +1135,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(..) => {\n                             check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n-                        ast::TypeImplItem(_) |\n-                        ast::MacImplItem(_) => {}\n+                        _ => {}\n                     }\n                 }\n             }\n@@ -1307,6 +1313,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match impl_item.node {\n+                                      ast::ConstImplItem(..) |\n                                       ast::MethodImplItem(..) => {\n                                           self.exported_items.contains(&impl_item.id)\n                                       }\n@@ -1330,6 +1337,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 match impl_item.node {\n+                                    ast::ConstImplItem(..) |\n                                     ast::MethodImplItem(..)\n                                         if self.item_is_public(&impl_item.id, impl_item.vis) =>\n                                     {\n@@ -1360,12 +1368,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                match impl_item.node {\n-                                    ast::TypeImplItem(ref ty) => {\n-                                        self.visit_ty(ty);\n-                                    }\n-                                    ast::MethodImplItem(..) |\n-                                    ast::MacImplItem(_) => {},\n+                                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                                    self.visit_ty(ty);\n                                 }\n                             }\n                         }\n@@ -1376,15 +1380,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n                         match impl_item.node {\n+                            ast::ConstImplItem(..) => {\n+                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                    found_pub_static = true;\n+                                    visit::walk_impl_item(self, impl_item);\n+                                }\n+                            }\n                             ast::MethodImplItem(ref sig, _) => {\n                                 if sig.explicit_self.node == ast::SelfStatic &&\n-                                        self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n                                     visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => {}\n+                            _ => {}\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "0d25700d2b7f101f69f3ffb7adc7e671ae076b48", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -530,6 +530,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         trait_item.span);\n \n                     match trait_item.node {\n+                        ast::ConstTraitItem(..) => {\n+                            let def = DefAssociatedConst(local_def(trait_item.id),\n+                                                         FromTrait(local_def(item.id)));\n+                            // NB: not IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                        }\n                         ast::MethodTraitItem(..) => {\n                             let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n@@ -703,7 +709,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n           }\n-          DefFn(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n+          DefFn(..) | DefStatic(..) | DefConst(..) | DefAssociatedConst(..) |\n+          DefMethod(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             // impl methods have already been defined with the correct importability modifier"}, {"sha": "f43d951aaaa71ab3071770283bd05da6af6aeb20", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -60,7 +60,8 @@ use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n-use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n+use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block};\n+use syntax::ast::{ConstImplItem, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n@@ -1831,6 +1832,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // FIXME #4951: Do we need a node ID here?\n \n                             let type_parameters = match trait_item.node {\n+                                ast::ConstTraitItem(..) => NoTypeParameters,\n                                 ast::MethodTraitItem(ref sig, _) => {\n                                     HasTypeParameters(&sig.generics,\n                                                       FnSpace,\n@@ -2094,6 +2096,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             match impl_item.node {\n+                                ConstImplItem(_, _) => {}\n                                 MethodImplItem(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n@@ -2466,7 +2469,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // This must be an enum variant, struct or const.\n                     if let Some(path_res) = self.resolve_path(pat_id, path, 0, ValueNS, false) {\n                         match path_res.base_def {\n-                            DefVariant(..) | DefStruct(..) | DefConst(..) => {\n+                            DefVariant(..) | DefStruct(..) | DefConst(..) |\n+                            DefAssociatedConst(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n@@ -2542,7 +2546,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def @ DefVariant(..) | def @ DefStruct(..) => {\n                                 return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n-                            def @ DefConst(..) => {\n+                            def @ DefConst(..) | def @ DefAssociatedConst(..) => {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {"}, {"sha": "237270da5628be83b3888180855d7c0237989416", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -242,6 +242,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefConst(_) |\n+            def::DefAssociatedConst(..) |\n             def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n             def::DefUpvar(..) => Some(recorder::VarRef),\n@@ -359,14 +360,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n                                              ast_util::local_def(id))\n-            .and_then(|def_id| {\n-                if match def_id {\n-                    ty::MethodTraitItemId(def_id) => {\n-                        def_id.node != 0 && def_id != ast_util::local_def(id)\n-                    }\n-                    ty::TypeTraitItemId(_) => false,\n-                } {\n-                    Some(def_id.def_id())\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n                 } else {\n                     None\n                 }\n@@ -800,6 +797,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n                                                     span,\n                                                     sub_span,\n@@ -883,6 +881,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n@@ -966,7 +965,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n-                    ty::TypeTraitItem(_) => def_id,\n+                    _ => self.sess\n+                             .span_bug(ex.span,\n+                                       \"save::process_method_call: non-method \\\n+                                        DefId in MethodStatic or MethodStaticClosure\"),\n                 };\n                 (Some(def_id), decl_id)\n             }\n@@ -1008,7 +1010,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n                 let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n-                    def::DefConst(..) => None,\n+                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n                         match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n@@ -1236,6 +1238,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n+            ast::ConstTraitItem(..) => {}\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 self.process_method(sig, body.as_ref().map(|x| &**x),\n                                     trait_item.id, trait_item.ident.name, trait_item.span);\n@@ -1246,6 +1249,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n+            ast::ConstImplItem(..) => {}\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig, Some(body), impl_item.id,\n                                     impl_item.ident.name, impl_item.span);\n@@ -1432,8 +1436,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n-                def::DefStatic(_, _) => {}\n-                def::DefConst(..) => {}\n+                def::DefStatic(_, _) |\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                             def)\n             }"}, {"sha": "1ceba3c8230d21f9e761ecdb830f87254a80d09e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -1078,25 +1078,17 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         Some(ast_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n                 ast::MethodTraitItem(_, Some(ref body)) => body,\n-                ast::MethodTraitItem(_, None) => {\n-                    tcx.sess.bug(\"unexpected variant: required trait method \\\n-                                  in has_nested_returns\")\n-                }\n-                ast::TypeTraitItem(..) => {\n-                    tcx.sess.bug(\"unexpected variant: associated type trait item in \\\n-                                  has_nested_returns\")\n+                _ => {\n+                    tcx.sess.bug(\"unexpected variant: trait item other than a \\\n+                                  provided method in has_nested_returns\")\n                 }\n             }\n         }\n         Some(ast_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n                 ast::MethodImplItem(_, ref body) => body,\n-                ast::TypeImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n-                                  has_nested_returns\")\n-                }\n-                ast::MacImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: unexpanded macro impl item in \\\n+                _ => {\n+                    tcx.sess.bug(\"unexpected variant: non-method impl item in \\\n                                   has_nested_returns\")\n                 }\n             }\n@@ -2363,13 +2355,14 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         ast_map::NodeTraitItem(trait_item) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n             match trait_item.node {\n-                ast::MethodTraitItem(_, None) | ast::TypeTraitItem(..) => {\n-                    ccx.sess().span_bug(trait_item.span,\n-                        \"unexpected variant: required trait method in get_item_val()\");\n-                }\n                 ast::MethodTraitItem(_, Some(_)) => {\n                     register_method(ccx, id, &trait_item.attrs, trait_item.span)\n                 }\n+                _ => {\n+                    ccx.sess().span_bug(trait_item.span,\n+                        \"unexpected variant: trait item other than a provided \\\n+                         method in get_item_val()\");\n+                }\n             }\n         }\n \n@@ -2378,13 +2371,10 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::MethodImplItem(..) => {\n                     register_method(ccx, id, &impl_item.attrs, impl_item.span)\n                 }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: associated type in get_item_val()\")\n-                }\n-                ast::MacImplItem(_) => {\n+                _ => {\n                     ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: unexpanded macro in get_item_val()\")\n+                        \"unexpected variant: non-method impl item in \\\n+                         get_item_val()\");\n                 }\n             }\n         }"}, {"sha": "0e4680723073f50881e8a0b0b0389ea221996d1a", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -202,6 +202,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             }\n             def::DefStatic(..) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefLocal(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n@@ -465,9 +466,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n                     (true, source_id, new_substs)\n                 }\n-                ty::TypeTraitItem(_) => {\n+                _ => {\n                     tcx.sess.bug(\"trans_fn_ref_with_vtables() tried \\\n-                                  to translate an associated type?!\")\n+                                  to translate a non-method?!\")\n                 }\n             }\n         }"}, {"sha": "69cd57d1bab70c9da43ba5482226e7856877afd9", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -1314,15 +1314,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                      impl_item.span,\n                      true)\n                 }\n-                ast::TypeImplItem(_) => {\n-                    cx.sess().span_bug(impl_item.span,\n-                                       \"create_function_debug_context() \\\n-                                        called on associated type?!\")\n-                }\n-                ast::MacImplItem(_) => {\n+                _ => {\n                     cx.sess().span_bug(impl_item.span,\n                                        \"create_function_debug_context() \\\n-                                        called on unexpanded macro?!\")\n+                                        called on non-method impl item?!\")\n                 }\n             }\n         }"}, {"sha": "fda931fde6e6c8b14a03acf55092f3ea5cbfdea5", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -74,8 +74,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 ast::MethodImplItem(..) => {\n                     visit::walk_impl_item(&mut v, impl_item);\n                 }\n-                ast::TypeImplItem(_) |\n-                ast::MacImplItem(_) => {}\n+                _ => {}\n             }\n         }\n         return;\n@@ -98,8 +97,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 }\n                 visit::walk_impl_item(&mut v, impl_item);\n             }\n-            ast::TypeImplItem(_) |\n-            ast::MacImplItem(_) => {}\n+            _ => {}\n         }\n     }\n }\n@@ -336,9 +334,9 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let impl_did = vtable_impl.impl_def_id;\n             let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n                 ty::MethodTraitItem(method) => method.name,\n-                ty::TypeTraitItem(_) => {\n-                    bcx.tcx().sess.bug(\"can't monomorphize an associated \\\n-                                        type\")\n+                _ => {\n+                    bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n+                                        item\")\n                 }\n             };\n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n@@ -579,8 +577,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n     // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n         ty::MethodTraitItem(method) => method,\n-        ty::TypeTraitItem(_) => {\n-            tcx.sess.bug(\"can't create a method shim for an associated type\")\n+        _ => {\n+            tcx.sess.bug(\"can't create a method shim for a non-method item\")\n         }\n     };\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n@@ -789,11 +787,11 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trait_item_def_ids\n         .iter()\n \n-        // Filter out the associated types.\n+        // Filter out non-method items.\n         .filter_map(|item_def_id| {\n             match *item_def_id {\n                 ty::MethodTraitItemId(def_id) => Some(def_id),\n-                ty::TypeTraitItemId(_) => None,\n+                _ => None,\n             }\n         })\n \n@@ -806,7 +804,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n             let name = trait_method_type.name;\n \n@@ -824,7 +822,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let impl_method_def_id = method_with_name(ccx, impl_id, name);\n             let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n \n             debug!(\"emit_vtable_methods: impl_method_type={}\","}, {"sha": "03fdd0c45c16ae6aa37d19e01b8673ca26956ed5", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -236,11 +236,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     }\n                     d\n                 }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().bug(\"can't monomorphize an associated type\")\n-                }\n-                ast::MacImplItem(_) => {\n-                    ccx.sess().bug(\"can't monomorphize an unexpanded macro\")\n+                _ => {\n+                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                           map_node))\n                 }\n             }\n         }"}, {"sha": "47388e0e5583f54101e15e2ad84b1a57a03975c8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -808,6 +808,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n \n         for impl_item in impl_items {\n             match impl_item.node {\n+                ast::ConstImplItem(_, _) => {}\n                 ast::MethodImplItem(ref sig, ref body) => {\n                     check_method_body(ccx, &impl_pty.generics, sig, body,\n                                       impl_item.id, impl_item.span);\n@@ -823,6 +824,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n+                ast::ConstTraitItem(_, _) => {}\n                 ast::MethodTraitItem(_, None) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n@@ -920,6 +922,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n+            ast::ConstImplItem(_, _) => {}\n             ast::MethodImplItem(_, ref body) => {\n                 let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n@@ -979,13 +982,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         match (associated_type, &typedef_ty) {\n                             (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n                             _ => {\n-                                // This is `span_bug` as it should have\n-                                // already been caught in resolve.\n-                                tcx.sess.span_bug(\n-                                    impl_item.span,\n-                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                             token::get_name(typedef_ty.name()),\n-                                             impl_trait_ref.repr(tcx)));\n+                                // Formerly `span_bug`, but it turns out that\n+                                // this is not checked in resolve, so this is\n+                                // the first place where we'll notice the\n+                                // mismatch.\n+                                span_err!(tcx.sess, impl_item.span, E0323,\n+                                          \"item `{}` is an associated type, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(typedef_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n                             }\n                         }\n                     }\n@@ -1012,15 +1017,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut missing_methods = Vec::new();\n     for trait_item in &*trait_items {\n         match *trait_item {\n+            ty::ConstTraitItem(_) => {}\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n                         match ii.node {\n                             ast::MethodImplItem(..) => {\n                                 ii.ident.name == trait_method.name\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => false,\n+                            _ => false,\n                         }\n                     });\n                 let is_provided =\n@@ -1035,8 +1040,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ast::TypeImplItem(_) => {\n                             ii.ident.name == associated_type.name\n                         }\n-                        ast::MethodImplItem(..) |\n-                        ast::MacImplItem(_) => false,\n+                        _ => false,\n                     }\n                 });\n                 if !is_implemented {\n@@ -4208,7 +4212,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         def::DefFn(id, _) | def::DefMethod(id, _) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-        def::DefStruct(id) | def::DefConst(id) => {\n+        def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id, _) => {\n             (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n         }\n         def::DefTrait(_) |\n@@ -4351,6 +4355,10 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n+        def::DefAssociatedConst(..) => {\n+            segment_spaces = repeat(None).take(segments.len()).collect();\n+        }\n+\n         // Other cases. Various nonsense that really shouldn't show up\n         // here. If they do, an error will have been reported\n         // elsewhere. (I hope)"}, {"sha": "fbfe73674e16088eb95388debd7338ffe97c53d9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -20,8 +20,9 @@ use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst::{self, Subst};\n use middle::ty::RegionEscape;\n-use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n-use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n+use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n+use middle::ty::{MethodTraitItemId, TypeTraitItemId};\n+use middle::ty::{ParameterEnvironment, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -278,6 +279,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n+                        ast::ConstImplItem(..) => {\n+                            ConstTraitItemId(local_def(impl_item.id))\n+                        }\n                         ast::MethodImplItem(..) => {\n                             MethodTraitItemId(local_def(impl_item.id))\n                         }\n@@ -348,7 +352,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                            .insert(item_def_id.def_id(), source);\n                     }\n                 }\n-                ty::TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n "}, {"sha": "d04e447a4608a84c22c6c3629fe76ae503b14ce7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -196,7 +196,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let def_id = local_def(method_id);\n         match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n-            ty::TypeTraitItem(..) => {\n+            _ => {\n                 self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n             }\n         }\n@@ -830,43 +830,37 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             // Convert all the associated types.\n             for impl_item in impl_items {\n-                match impl_item.node {\n-                    ast::TypeImplItem(ref ty) => {\n-                        if opt_trait_ref.is_none() {\n-                            span_err!(tcx.sess, impl_item.span, E0202,\n-                                              \"associated items are not allowed in inherent impls\");\n-                        }\n-\n-                        as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n-                                                impl_item.ident, impl_item.id, impl_item.vis);\n-\n-                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n-                        tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n-                                                       TypeScheme {\n-                                                           generics: ty::Generics::empty(),\n-                                                           ty: typ,\n-                                                       });\n-                        tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n-                                                           ty::GenericPredicates::empty());\n-                        write_ty_to_tcx(tcx, impl_item.id, typ);\n+                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                    if opt_trait_ref.is_none() {\n+                        span_err!(tcx.sess, impl_item.span, E0202,\n+                                  \"associated items are not allowed in inherent impls\");\n                     }\n-                    ast::MethodImplItem(..) |\n-                    ast::MacImplItem(_) => {}\n+\n+                    as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n+                                        impl_item.ident, impl_item.id, impl_item.vis);\n+\n+                    let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n+                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n+                                                   TypeScheme {\n+                                                       generics: ty::Generics::empty(),\n+                                                       ty: typ,\n+                                                   });\n+                    tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n+                                                       ty::GenericPredicates::empty());\n+                    write_ty_to_tcx(tcx, impl_item.id, typ);\n                 }\n             }\n \n             let methods = impl_items.iter().filter_map(|ii| {\n-                match ii.node {\n-                    ast::MethodImplItem(ref sig, _) => {\n-                        // if the method specifies a visibility, use that, otherwise\n-                        // inherit the visibility from the impl (so `foo` in `pub impl\n-                        // { fn foo(); }` is public, but private in `priv impl { fn\n-                        // foo(); }`).\n-                        let method_vis = ii.vis.inherit_from(parent_visibility);\n-                        Some((sig, ii.id, ii.ident, method_vis, ii.span))\n-                    }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => None\n+                if let ast::MethodImplItem(ref sig, _) = ii.node {\n+                    // if the method specifies a visibility, use that, otherwise\n+                    // inherit the visibility from the impl (so `foo` in `pub impl\n+                    // { fn foo(); }` is public, but private in `priv impl { fn\n+                    // foo(); }`).\n+                    let method_vis = ii.vis.inherit_from(parent_visibility);\n+                    Some((sig, ii.id, ii.ident, method_vis, ii.span))\n+                } else {\n+                    None\n                 }\n             });\n             convert_methods(ccx,\n@@ -877,18 +871,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             &ty_predicates);\n \n             for impl_item in impl_items {\n-                match impl_item.node {\n-                    ast::MethodImplItem(ref sig, ref body) => {\n-                        let body_id = body.id;\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               ccx.method_ty(impl_item.id),\n-                                               selfty,\n-                                               &sig.explicit_self,\n-                                               body_id);\n-                    }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => {}\n+                if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n+                    let body_id = body.id;\n+                    check_method_self_type(ccx,\n+                                           &BindingRscope::new(),\n+                                           ccx.method_ty(impl_item.id),\n+                                           selfty,\n+                                           &sig.explicit_self,\n+                                           body_id);\n                 }\n             }\n \n@@ -919,18 +909,18 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 match trait_item.node {\n-                    ast::MethodTraitItem(..) => {}\n                     ast::TypeTraitItem(..) => {\n                         as_refsociated_type(ccx, TraitContainer(local_def(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public);\n                     }\n+                    _ => {}\n                 }\n             };\n \n             let methods = trait_items.iter().filter_map(|ti| {\n                 let sig = match ti.node {\n                     ast::MethodTraitItem(ref sig, _) => sig,\n-                    ast::TypeTraitItem(..) => return None,\n+                    _ => return None,\n                 };\n                 Some((sig, ti.id, ti.ident, ast::Inherited, ti.span))\n             });\n@@ -947,6 +937,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n                 let def_id = local_def(trait_item.id);\n                 match trait_item.node {\n+                    ast::ConstTraitItem(..) => {\n+                        ty::ConstTraitItemId(def_id)\n+                    }\n                     ast::MethodTraitItem(..) => {\n                         ty::MethodTraitItemId(def_id)\n                     }\n@@ -962,7 +955,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             for trait_item in trait_items {\n                 let sig = match trait_item.node {\n                     ast::MethodTraitItem(ref sig, _) => sig,\n-                    ast::TypeTraitItem(..) => continue\n+                    _ => continue\n                 };\n                 check_method_self_type(ccx,\n                                        &BindingRscope::new(),\n@@ -1185,8 +1178,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            ast::MethodTraitItem(..) => None,\n             ast::TypeTraitItem(..) => Some(trait_item.ident.name),\n+            _ => None,\n         }\n     }).collect();\n \n@@ -1260,7 +1253,7 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n     trait_items.iter().any(|trait_item| {\n         match trait_item.node {\n             ast::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n-            ast::MethodTraitItem(..) => false,\n+            _ => false,\n         }\n     })\n }\n@@ -1320,7 +1313,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         trait_items.iter().flat_map(|trait_item| {\n             let bounds = match trait_item.node {\n                 ast::TypeTraitItem(ref bounds, _) => bounds,\n-                ast::MethodTraitItem(..) => {\n+                _ => {\n                     return vec!().into_iter();\n                 }\n             };\n@@ -2227,7 +2220,8 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         impl_items.iter()\n                   .filter_map(|item| match item.node {\n                       ast::TypeImplItem(..) => Some(ty::node_id_to_type(tcx, item.id)),\n-                      ast::MethodImplItem(..) | ast::MacImplItem(..) => None,\n+                      ast::ConstImplItem(..) | ast::MethodImplItem(..) |\n+                      ast::MacImplItem(..) => None,\n                   })\n                   .flat_map(|ty| ctp::parameters_for_type(ty).into_iter())\n                   .filter_map(|p| match p {"}, {"sha": "b17a7f4f3189d6f9fb0b933f2f49b0335b726c1c", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -176,6 +176,7 @@ register_diagnostics! {\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n     E0322, // cannot implement Sized explicitly\n+    E0323, // implemented trait where method should have been provided\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types"}, {"sha": "0bc3da416cb5583de3ec50536a1dd4a40cf7f0a1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -312,6 +312,7 @@ pub fn build_impl(cx: &DocContext,\n         let did = did.def_id();\n         let impl_item = ty::impl_or_trait_item(tcx, did);\n         match impl_item {\n+            ty::ConstTraitItem(_) => { return None }\n             ty::MethodTraitItem(method) => {\n                 if method.vis != ast::Public && associated_trait.is_none() {\n                     return None"}, {"sha": "73fbfe29224eeecaf12f78bf4760513441afa0f9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -361,6 +361,7 @@ pub enum ItemEnum {\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n     PrimitiveItem(PrimitiveType),\n+    AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n }\n@@ -1235,6 +1236,11 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n impl Clean<Item> for ast::TraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n+            ast::ConstTraitItem(ref ty, ref default) => {\n+                AssociatedConstItem(ty.clean(cx),\n+                                    default.as_ref().map(|expr|\n+                                                         expr.span.to_src(cx)))\n+            }\n             ast::MethodTraitItem(ref sig, Some(_)) => {\n                 MethodItem(sig.clean(cx))\n             }\n@@ -1260,6 +1266,12 @@ impl Clean<Item> for ast::TraitItem {\n impl Clean<Item> for ast::ImplItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                ConstantItem(Constant{\n+                    type_: ty.clean(cx),\n+                    expr: expr.span.to_src(cx),\n+                })\n+            }\n             ast::MethodImplItem(ref sig, _) => {\n                 MethodItem(sig.clean(cx))\n             }\n@@ -1363,6 +1375,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         match *self {\n+            ty::ConstTraitItem(ref cti) => cti.clean(cx),\n             ty::MethodTraitItem(ref mti) => mti.clean(cx),\n             ty::TypeTraitItem(ref tti) => tti.clean(cx),\n         }\n@@ -2672,6 +2685,20 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n+impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            source: DUMMY_SP.clean(cx),\n+            name: Some(self.name.clean(cx)),\n+            attrs: Vec::new(),\n+            inner: AssociatedConstItem(self.ty.clean(cx), None),\n+            visibility: None,\n+            def_id: self.def_id,\n+            stability: None,\n+        }\n+    }\n+}\n+\n impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // When loading a cross-crate associated type, the bounds for this type"}, {"sha": "afc93f41172e84498729ceece2adebcc6845022d", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -39,6 +39,7 @@ pub enum ItemType {\n     Primitive       = 15,\n     AssociatedType  = 16,\n     Constant        = 17,\n+    AssociatedConst = 18,\n }\n \n impl ItemType {\n@@ -63,6 +64,7 @@ impl ItemType {\n             clean::ForeignStaticItem(..)   => ItemType::Static, // no ForeignStatic\n             clean::MacroItem(..)           => ItemType::Macro,\n             clean::PrimitiveItem(..)       => ItemType::Primitive,\n+            clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n         }\n@@ -102,6 +104,7 @@ impl ItemType {\n             ItemType::Primitive       => \"primitive\",\n             ItemType::AssociatedType  => \"associatedtype\",\n             ItemType::Constant        => \"constant\",\n+            ItemType::AssociatedConst => \"associatedconstant\",\n         }\n     }\n }"}, {"sha": "447cf7eab458d38e56395d099ebecebacbd94e3f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -1629,6 +1629,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Macro           => (\"macros\", \"Macros\"),\n                 ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n                 ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n+                ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\\n@@ -1799,23 +1800,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"{{\\n\"));\n         for t in &types {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, t, MethodLink::Anchor));\n+            try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if !types.is_empty() && !required.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m, MethodLink::Anchor));\n+            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if !required.is_empty() && !provided.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m, MethodLink::Anchor));\n+            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n             try!(write!(w, \" {{ ... }}\\n\"));\n         }\n         try!(write!(w, \"}}\"));\n@@ -1831,7 +1832,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     ty = shortty(m),\n                     name = *m.name.as_ref().unwrap(),\n                     stab = m.stability_class()));\n-        try!(render_method(w, m, MethodLink::Anchor));\n+        try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m));\n         Ok(())\n@@ -1871,7 +1872,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_methods(w, it.def_id, MethodRender::All));\n+    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -1917,19 +1918,19 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n-                 link: MethodLink) -> fmt::Result {\n+fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n+                     link: AssocItemLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter, it: &clean::Item,\n               unsafety: ast::Unsafety, abi: abi::Abi,\n               g: &clean::Generics, selfty: &clean::SelfTy,\n-              d: &clean::FnDecl, link: MethodLink) -> fmt::Result {\n+              d: &clean::FnDecl, link: AssocItemLink) -> fmt::Result {\n         use syntax::abi::Abi;\n \n         let name = it.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", shortty(it), name);\n         let href = match link {\n-            MethodLink::Anchor => anchor,\n-            MethodLink::GotoSource(did) => {\n+            AssocItemLink::Anchor => anchor,\n+            AssocItemLink::GotoSource(did) => {\n                 href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n             }\n         };\n@@ -1958,10 +1959,11 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n             method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n+        clean::AssociatedConstItem(_, _) => Ok(()),\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n             assoc_type(w, meth, bounds, default)\n         }\n-        _ => panic!(\"render_method called on non-method\")\n+        _ => panic!(\"render_assoc_item called on non-associated-item\")\n     }\n }\n \n@@ -2001,7 +2003,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_methods(w, it.def_id, MethodRender::All)\n+    render_assoc_items(w, it.def_id, AssocItemRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n@@ -2100,7 +2102,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_methods(w, it.def_id, MethodRender::All));\n+    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n     Ok(())\n }\n \n@@ -2184,19 +2186,19 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n #[derive(Copy, Clone)]\n-enum MethodLink {\n+enum AssocItemLink {\n     Anchor,\n     GotoSource(ast::DefId),\n }\n \n-enum MethodRender<'a> {\n+enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type },\n }\n \n-fn render_methods(w: &mut fmt::Formatter,\n-                  it: ast::DefId,\n-                  what: MethodRender) -> fmt::Result {\n+fn render_assoc_items(w: &mut fmt::Formatter,\n+                      it: ast::DefId,\n+                      what: AssocItemRender) -> fmt::Result {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n@@ -2207,21 +2209,21 @@ fn render_methods(w: &mut fmt::Formatter,\n     });\n     if !non_trait.is_empty() {\n         let render_header = match what {\n-            MethodRender::All => {\n+            AssocItemRender::All => {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 true\n             }\n-            MethodRender::DerefFor { trait_, type_ } => {\n+            AssocItemRender::DerefFor { trait_, type_ } => {\n                 try!(write!(w, \"<h2 id='deref-methods'>Methods from \\\n                                     {}&lt;Target={}&gt;</h2>\", trait_, type_));\n                 false\n             }\n         };\n         for i in &non_trait {\n-            try!(render_impl(w, i, MethodLink::Anchor, render_header));\n+            try!(render_impl(w, i, AssocItemLink::Anchor, render_header));\n         }\n     }\n-    if let MethodRender::DerefFor { .. } = what {\n+    if let AssocItemRender::DerefFor { .. } = what {\n         return Ok(())\n     }\n     if !traits.is_empty() {\n@@ -2243,15 +2245,15 @@ fn render_methods(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n+            try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n+                try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n             }\n         }\n     }\n@@ -2266,22 +2268,22 @@ fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n             _ => None,\n         }\n     }).next().unwrap();\n-    let what = MethodRender::DerefFor { trait_: deref_type, type_: target };\n+    let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n     match *target {\n-        clean::ResolvedPath { did, .. } => render_methods(w, did, what),\n+        clean::ResolvedPath { did, .. } => render_assoc_items(w, did, what),\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n                     let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n-                    try!(render_methods(w, did, what));\n+                    try!(render_assoc_items(w, did, what));\n                 }\n             }\n             Ok(())\n         }\n     }\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n                render_header: bool) -> fmt::Result {\n     if render_header {\n         try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n@@ -2300,13 +2302,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n-                    link: MethodLink) -> fmt::Result {\n+                    link: AssocItemLink) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 try!(write!(w, \"<h4 id='method.{}' class='{}'><code>\",\n                             *item.name.as_ref().unwrap(),\n                             shortty(item)));\n-                try!(render_method(w, item, link));\n+                try!(render_assoc_item(w, item, link));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::TypedefItem(ref tydef) => {\n@@ -2317,6 +2319,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n+            clean::AssociatedConstItem(_, _) => {}\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n@@ -2327,7 +2330,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n-        if let MethodLink::Anchor = link {\n+        if let AssocItemLink::Anchor = link {\n             document(w, item)\n         } else {\n             Ok(())\n@@ -2339,18 +2342,18 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n         try!(doctraititem(w, trait_item, link));\n     }\n \n-    fn render_default_methods(w: &mut fmt::Formatter,\n-                              did: ast::DefId,\n-                              t: &clean::Trait,\n-                              i: &clean::Impl) -> fmt::Result {\n+    fn render_default_items(w: &mut fmt::Formatter,\n+                            did: ast::DefId,\n+                            t: &clean::Trait,\n+                            i: &clean::Impl) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, MethodLink::GotoSource(did)));\n+            try!(doctraititem(w, trait_item, AssocItemLink::GotoSource(did)));\n         }\n         Ok(())\n     }\n@@ -2361,7 +2364,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_methods(w, did, t, &i.impl_));\n+            try!(render_default_items(w, did, t, &i.impl_));\n         }\n     }\n     try!(write!(w, \"</div>\"));\n@@ -2458,7 +2461,7 @@ fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n-    render_methods(w, it.def_id, MethodRender::All)\n+    render_assoc_items(w, it.def_id, AssocItemRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}, {"sha": "74c16127f41ccac87c3bf3aba6d2acb37b644c7e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -184,7 +184,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n \n-            // Associated types are never stripped\n+            // Associated consts and types are never stripped\n+            clean::AssociatedConstItem(..) |\n             clean::AssociatedTypeItem(..) => {}\n         }\n "}, {"sha": "3f2e7c765a5e4fef6c30faacf75b96b31766e2cb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -1236,6 +1236,7 @@ pub struct TraitItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem_ {\n+    ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     MethodTraitItem(MethodSig, Option<P<Block>>),\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n@@ -1252,6 +1253,7 @@ pub struct ImplItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItem_ {\n+    ConstImplItem(P<Ty>, P<Expr>),\n     MethodImplItem(MethodSig, P<Block>),\n     TypeImplItem(P<Ty>),\n     MacImplItem(Mac),"}, {"sha": "36a7f3a93817c127b966e56ea6099ee55446e08e", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -222,8 +222,7 @@ impl<'a> FnLikeNode<'a> {\n                     ast::MethodImplItem(ref sig, ref body) => {\n                         method(ii.id, ii.ident, sig, Some(ii.vis), body, ii.span)\n                     }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => {\n+                    _ => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }"}, {"sha": "795391d4009144cea3a2682086d5497b725a50a7", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -940,6 +940,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n+                ConstImplItem(..) => {\n+                    format!(\"assoc const {} in {}{}\",\n+                            token::get_ident(ii.ident),\n+                            map.path_to_string(id),\n+                            id_str)\n+                }\n                 MethodImplItem(..) => {\n                     format!(\"method {} in {}{}\",\n                             token::get_ident(ii.ident),\n@@ -959,9 +965,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeTraitItem(ti)) => {\n             let kind = match ti.node {\n+                ConstTraitItem(..) => \"assoc constant\",\n                 MethodTraitItem(..) => \"trait method\",\n                 TypeTraitItem(..) => \"assoc type\",\n-//                 ConstTraitItem(..) => \"assoc constant\"\n             };\n \n             format!(\"{} {} in {}{}\","}, {"sha": "22bc3a198e231c59ba539cbf7c13e59b3ad4f086", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -973,6 +973,10 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n+            ConstTraitItem(ty, default) => {\n+                ConstTraitItem(folder.fold_ty(ty),\n+                               default.map(|x| folder.fold_expr(x)))\n+            }\n             MethodTraitItem(sig, body) => {\n                 MethodTraitItem(noop_fold_method_sig(sig, folder),\n                                 body.map(|x| folder.fold_block(x)))\n@@ -994,6 +998,9 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n         attrs: fold_attrs(attrs, folder),\n         vis: vis,\n         node: match node  {\n+            ConstImplItem(ty, expr) => {\n+                ConstImplItem(folder.fold_ty(ty), folder.fold_expr(expr))\n+            }\n             MethodImplItem(sig, body) => {\n                 MethodImplItem(noop_fold_method_sig(sig, folder),\n                                folder.fold_block(body))"}, {"sha": "6fd2a8b181518c132afc3b6dd1f34b5ed78ef197", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -1269,6 +1269,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n+            ast::ConstTraitItem(_, _) => Ok(()),\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     try!(self.head(\"\"));\n@@ -1295,6 +1296,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n         match ii.node {\n+            ast::ConstImplItem(_, _) => Ok(()),\n             ast::MethodImplItem(ref sig, ref body) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_method_sig(ii.ident, sig, ii.vis));"}, {"sha": "2ab353676251ee2450932666c436239265a70151", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5499775d6bee080b3f46539d59d238de2c1726f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b5499775d6bee080b3f46539d59d238de2c1726f", "patch": "@@ -619,6 +619,12 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         visitor.visit_attribute(attr);\n     }\n     match trait_item.node {\n+        ConstTraitItem(ref ty, ref default) => {\n+            visitor.visit_ty(ty);\n+            if let Some(ref expr) = *default {\n+                visitor.visit_expr(expr);\n+            }\n+        }\n         MethodTraitItem(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n@@ -641,6 +647,10 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         visitor.visit_attribute(attr);\n     }\n     match impl_item.node {\n+        ConstImplItem(ref ty, ref expr) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expr);\n+        }\n         MethodImplItem(ref sig, ref body) => {\n             visitor.visit_fn(FkMethod(impl_item.ident, sig, Some(impl_item.vis)), &sig.decl,\n                              body, impl_item.span, impl_item.id);"}]}